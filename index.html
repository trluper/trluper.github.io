<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Trluper">
<meta property="og:url" content="https://example.com/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="trluper">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">Redis数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-25 16:16:51" itemprop="dateCreated datePublished" datetime="2023-06-25T16:16:51+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 15:01:36" itemprop="dateModified" datetime="2023-06-26T15:01:36+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="redis数据类型">1. Redis数据类型</h2>
<p>Redis提供了<code>String,Hash,List,Set,Zset</code>五种数据类型。</p>
<h3 id="string">String</h3>
<p><code>String</code>数据结构是最简单的<code>key-value</code>类型，<code>value</code>不仅可以是<code>String</code>,也可以是数字，包括整数，浮点数和二进制数。</p>
<p><code>string</code> 数据结构是简单的 <code>key-value</code> 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串（simple dynamic string，SDS）</strong>。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<p>主要的应用有：缓存，计数（比如用户的访问次数、热点文章的点赞转发数量等等），共享session和限速。</p>
<p>内部编码主要有：</p>
<ul>
<li><strong><code>int</code></strong>:8个字节的长整型</li>
<li><strong><code>embstr</code></strong>:小于等于39个字节的字符串</li>
<li><strong><code>raw</code></strong>:大于39个字节的字符串</li>
</ul>
<p>各个指令的时间复杂度</p>
<ul>
<li><strong><code>SET</code></strong>：为一个 key 设置 value，可以配合 EX/PX 参数指定 key 的有效期，通过 NX/XX 参数针对 key 是否存在的情况进行区别操作，时间复杂度 O(1)</li>
<li><strong><code>GET</code></strong>：获取某个 key 对应的 value，时间复杂度 O(1)</li>
<li><strong><code>GETSET</code></strong>：为一个 key 设置 value，并返回该 key 的原 value，时间复杂度 O(1)</li>
<li><strong><code>MSET</code></strong>：为多个 key 设置 value，时间复杂度 O(N)</li>
<li><strong><code>MSETNX</code></strong>：同 MSET，如果指定的 key 中有任意一个已存在，则不进行任何操作，时间复杂度 O(N)</li>
<li><strong><code>MGET</code></strong>：获取多个 key 对应的 value，时间复杂度 O(N)</li>
<li><strong><code>INCR</code></strong>：将 key 对应的 value 值自增1，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li>
<li><strong><code>INCRBY</code></strong>：将 key 对应的 value 值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li>
<li><strong><code>DECR/DECRBY</code></strong>：同 INCR/INCRBY，自增改为自减。</li>
</ul>
<h3 id="hash">Hash</h3>
<p><code>Hash</code>是一个<code>string</code>类型的<code>field</code>和<code>value</code>的映射表，hash特别适合用于存储对象，后续操作的时候，可以直接仅仅修改这个对象某个字段的值。比如可以用hash数据结构来存储用户信息，商品信息等。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key = JavaUser</span><br><span class="line">value = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="string">&quot;location&quot;</span>: <span class="string">&quot;GuangDong,Jieyang&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要应用有：将关系型数据库每一行数据存储为一个哈希键</p>
<p><strong>内部编码主要：</strong></p>
<ul>
<li><code>ziplist(压缩列表)</code>：当哈希类型元素个数小于<code>hash-max-ziplist-entries</code>配置（默认512个字节），同时所有值小于<code>hash-max-ziplist-value</code>配置（默认64个字节）时，使用<code>ziplist</code>作为内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀</li>
<li><code>hashtable(哈希表)</code>：当哈希类型无法满足ziplist的条件时，使用hashtable作为内部实现，因为此时ziplist读写效率会下降，而hashtable读写时间复杂度为O(1)</li>
</ul>
<h4 id="各个指令的时间复杂度">各个指令的时间复杂度</h4>
<p>与 Hash 相关的常用命令：</p>
<ul>
<li><strong>HSET</strong>：将 key 对应的 Hash 中的 field 设置为 value。如果该 Hash 不存在，会自动创建一个。时间复杂度 O(1)</li>
<li>***：返回指定 Hash 中 field 字段的值，时间复杂度 O(1)</li>
<li>HMSET/HMGET：同 HSET 和 HGET，可以批量操作同一个 key 下的多个 field，时间复杂度：O(N)，N为一次操作的 field 数量</li>
<li>HSETNX：同 HSET，但如 field 已经存在，HSETNX 不会进行任何操作，时间复杂度 O(1)</li>
<li>HEXISTS：判断指定Hash中 field 是否存在，存在返回1，不存在返回0，时间复杂度 O(1)</li>
<li>HDEL：删除指定 Hash 中的 field（1个或多个），时间复杂度：O(N)，N 为操作的 field 数量</li>
<li>HINCRBY：同 INCRBY 命令，对指定 Hash 中的一个 field 进行 INCRBY，时间复杂度 O(1)</li>
</ul>
<p><strong>应谨慎使用的Hash相关命令：</strong></p>
<ul>
<li>HGETALL：返回指定 Hash 中所有的 field-value 对。返回结果为数组，数组中 field 和 value 交替出现。时间复杂度 O(N)</li>
<li>HKEYS/HVALS：返回指定 Hash 中所有的 field/value，时间复杂度 O(N)</li>
<li>上述三个命令都会对 Hash 进行完整遍历，Hash中的 field 数量与命令的耗时线性相关，对于尺寸不可预知的 Hash，应严格避免使用上面三个命令，而改为使用 HSCAN 命令进行游标式的遍历</li>
</ul>
<h3 id="list">List</h3>
<p><code>list</code>就是链表，Redis中list的应用场景非常多，也是Redis最重要的数据结构之一</p>
<p><strong><code>list</code>的实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</strong></p>
<p>另外可以通过<code>lrange</code>，就是从某个元素开始读取多少个元素，可以基于<code>list</code>实现分页查询，基于 redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
<p>主要的应用有：<strong>栈、队列，消息队列（抢购），文章列表等</strong></p>
<p><strong>内部编码有：</strong></p>
<ul>
<li><strong><code>ziplist(压缩列表)</code>：</strong>当哈希类型元素个数小于<code>list-max-ziplist-entries</code>配置（默认512），同时所有值小于<code>list-max-ziplist-value</code>配置（默认64）时，使用<code>ziplist作</code>为内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀</li>
<li><strong><code>linkedlist</code>(链表)</strong>：当列表类型无法满足<code>ziplist</code>条件时，使用链表作为内部实现</li>
</ul>
<h4 id="各个指令的时间复杂度-1">各个指令的时间复杂度</h4>
<ul>
<li><strong><code>LPUSH</code></strong>：向指定<code>List</code>的左侧（即头部）插入 1 个或多个元素，返回插入后的<code>List</code> 长度。时间复杂度<code>O(N)</code>，<code>N</code>为插入元素的数量</li>
<li><strong><code>RPUSH</code>：</strong>同 <code>LPUSH</code>，向指定<code>List</code>的右侧（即尾部）插入 1 或多个元素</li>
<li><strong><code>LPOP</code>：</strong>从指定<code>List</code>的左侧（即头部）移除一个元素并返回，时间复杂度 O(1)</li>
<li><strong><code>RPOP</code>：</strong>同 <code>LPOP</code>，从指定 <code>List</code> 的右侧（即尾部）移除 1 个元素并返回</li>
<li><strong><code>LPUSHX/RPUSHX</code></strong>：与 <code>LPUSH/RPUSH</code> 类似，区别在于，<code>LPUSHX/RPUSHX</code> 操作的 <code>key</code> 如果不存在，则不会进行任何操作</li>
<li><strong><code>LLEN</code></strong>：返回指定<code>List</code>的长度，时间复杂度 O(1)</li>
<li><strong><code>LRANGE</code></strong>：返回指定 <code>List</code> 中指定范围的元素（双端包含，即 <code>LRANGE key 0 10</code>会返回 <code>11</code> 个元素），时间复杂度 O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的 <code>List</code> 元素会导致延迟，同时对长度不可预知的<code>List</code>，避免使用 <code>LRANGE key 0 -1</code>这样的完整遍历操作。</li>
</ul>
<p>应谨慎使用的List相关命令：</p>
<ul>
<li><strong><code>LINDEX</code></strong>：返回指定<code>List</code>指定 <code>index</code> 上的元素，如果<code>index</code> 越界，返回<code>nil</code>。<code>index</code>数值是回环的，即 <code>-1</code>代表 <code>List</code> 最后一个位置，<code>-2</code>代表<code>List</code>倒数第二个位置。时间复杂度 O(N)</li>
<li><strong><code>LSET</code></strong>：将指定 <code>List</code>指定 <code>index</code> 上的元素设置为 <code>value</code>，如果 <code>index</code> 越界则返回错误，时间复杂度 <code>O(N)</code>，如果操作的是头/尾部的元素，则时间复杂度为<code>O(1)</code></li>
<li><strong><code>LINSERT</code></strong>：向指定 <code>List</code> 中指定元素之前/之后插入一个新元素，并返回操作后的 <code>List</code> 长度。如果指定的元素不存在，返回<code>-1</code>。如果指定<code>key</code> 不存在，不会进行任何操作，时间复杂度 <code>O(N)</code></li>
</ul>
<p><strong>由于<code>Redis</code> 的 List 是链表结构的，上述的三个命令的算法效率较低，需要对 <code>List</code>进行遍历，命令的耗时无法预估，在<code>List</code>长度大的情况下耗时会明显增加，应谨慎使用。</strong></p>
<h3 id="set">Set</h3>
<p>集合（set）可以保存多个字符串元素，但是不允许有重复元素，并且集合中的元素是无序的，一个集合最多可以存储2^32-1个元素，集合可以进行内部的增删改查和多个集合取交集，并集，差集。</p>
<p>主要的应用有：<strong>标签，生成随机数（抽奖），社交需求（共同好友，粉丝等等）</strong></p>
<p><strong>内部编码主要有：</strong></p>
<ul>
<li>** intset(整数集合)**：当集合中的元素都是整数而且元素个数小于set-max-intset-entries配置（默认512个）时，使用该编码减少内存的使用</li>
<li><strong>hashtable(哈希表)</strong>：其它条件下使用哈希表作为内部实现</li>
</ul>
<h4 id="各个指令的时间复杂度-2">各个指令的时间复杂度</h4>
<ul>
<li><strong>SADD</strong>：向指定 Set 中添加 1 个或多个 member，如果指定 Set 不存在，会自动创建一个。时间复杂度 O(N)，N 为添加的 member 个数</li>
<li><strong>SREM</strong>：从指定 Set 中移除 1 个或多个 member，时间复杂度 O(N)，N 为移除的 member 个数</li>
<li><strong>SRANDMEMBER</strong>：从指定 Set 中随机返回 1 个或多个 member，时间复杂度 O(N)，N 为返回的 member 个数</li>
<li><strong>SPOP：</strong>从指定 Set 中随机移除并返回 count 个 member，时间复杂度 O(N)，N 为移除的 member 个数</li>
<li><strong>SCARD</strong>：返回指定 Set 中的 member 个数，时间复杂度 O(1)</li>
<li><strong>SISMEMBER</strong>：判断指定的 value 是否存在于指定 Set 中，时间复杂度 O(1)</li>
<li><strong>SMOVE</strong>：将指定 member 从一个 Set 移至另一个 Set</li>
</ul>
<p>慎用的Set相关命令：</p>
<ul>
<li><strong>SMEMBERS</strong>：返回指定 Hash 中所有的 member，时间复杂度 O(N)</li>
<li><strong>SUNION/SUNIONSTORE：</strong>计算多个 Set 的并集并返回/存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
<li><strong>SINTER/SINTERSTORE</strong>：计算多个 Set 的交集并返回/存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
<li><strong>SDIFF/SDIFFSTORE：</strong>计算 1 个 Set 与 1 或多个 Set 的差集并返回/存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
</ul>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的 Set 尺寸不可知的情况下，应严格避免使用。可以考虑通过 SSCAN 命令遍历获取相关 Set 的全部 member，如果需要做并集/交集/差集计算，可以在客户端进行，或在不服务实时查询请求的 Slave 上进行</p>
<h3 id="zset">ZSet</h3>
<p>有序集合（zset）保留集合元素不能重复的特性，但是有序集合中的元素可以排序，它为每一个元素设定一个score作为排序的依据</p>
<p>应用：<strong>排行榜系统，用户点赞。需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</strong></p>
<p><strong>内部编码实现：</strong></p>
<ul>
<li><strong>ziplist(压缩列表)</strong>：当哈希类型元素个数小于zset-max-ziplist-entries配置（默认128个），同时所有值小于zset-max-ziplist-value配置（默认64）时，使用ziplist作为内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀。</li>
<li><strong>skiplist(跳表)：</strong>当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降</li>
</ul>
<h4 id="各个指令的时间复杂度-3">各个指令的时间复杂度</h4>
<ul>
<li><strong>ZADD</strong>：向指定 Sorted Set 中添加 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为添加的 member 数量，N 为 Sorted Set 中的 member 数量</li>
<li><strong>ZREM</strong>：从指定 Sorted Set 中删除 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为删除的 member 数量，N 为 Sorted Set 中的 member 数量</li>
<li><strong>ZCOUNT</strong>：返回指定 Sorted Set 中指定 score 范围内的 member 数量，时间复杂度：O(log(N))</li>
<li><strong>ZCARD</strong>：返回指定 Sorted Set 中的 member 数量，时间复杂度 O(1)</li>
<li><strong>ZSCORE</strong>：返回指定 Sorted Set 中指定 member 的 score，时间复杂度 O(1)</li>
<li><strong>ZRANK/ZREVRANK</strong>：返回指定 member 在 Sorted Set 中的排名，ZRANK 返回按升序排序的排名，ZREVRANK 则返回按降序排序的排名。时间复杂度 O(log(N))</li>
<li><strong>ZINCRBY</strong>：同 INCRBY，对指定 Sorted Set 中的指定 member 的 score 进行自增，时间复杂度 O(log(N))</li>
</ul>
<p><strong>慎用的Sorted Set相关命令：</strong></p>
<ul>
<li><strong>ZRANGE/ZREVRANGE：</strong>返回指定 Sorted Set 中指定排名范围内的所有 member，ZRANGE 为按 score 升序排序，ZREVRANGE 为按 score 降序排序，时间复杂度 O(log(N)+M)，M为本次返回的 member 数</li>
<li><strong>ZRANGEBYSCORE/ZREVRANGEBYSCORE</strong>：返回指定 Sorted Set 中指定 score 范围内的所有 member，返回结果以升序/降序排序，min 和 max 可以指定为 -inf和+ inf，代表返回所有的 member。时间复杂度 O(log(N)+M)</li>
<li><strong>ZREMRANGEBYRANK/ZREMRANGEBYSCORE</strong>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有 member。时间复杂度 O(log(N)+M)</li>
</ul>
<p>上述几个命令，应尽量避免传递<code>[0 -1]</code>或<code>[-inf +inf]</code>这样的参数，来对 Sorted Set 做一次性的完整遍历，特别是在 Sorted Set 的尺寸不可预知的情况下。可以通过 ZSCAN 命令来进行游标式的遍历，或通过 LIMIT 参数来限制返回 member 的数量（适用于 ZRANGEBYSCORE 和 ZREVRANGEBYSCORE 命令），以实现游标式的遍历。</p>
<h2 id="为什么要用redis为什么要用缓存">2. 为什么要用redis/为什么要用缓存</h2>
<p>主要从“高性能”和“高并发”这两个点来看待这个问题</p>
<p><strong>高性能：</strong></p>
<p>Redis中的数据是存储在内存中的，所以读写速度非常快。假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变之后，同步改变缓存中相应的数据即可。</p>
<p><strong>高并发：</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库</p>
<h2 id="redis的数据怎么存储在内存中内存这么有限怎么存储的">3. Redis的数据怎么存储在内存中（内存这么有限，怎么存储的）</h2>
<h2 id="为什么使用redis而不直接在程序中使用map做缓存">4. 为什么使用redis而不直接在程序中使用map做缓存？</h2>
<p>缓存分为本地缓存和分布式缓存，使用语言自带得map实现的是本地缓存，最主要得特点是轻量以及快速，生命周期随着该实例的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。</p>
<h2 id="redis的线程模型">5. redis的线程模型</h2>
<p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型 </strong>。redis内部使用文件事件处理器file event handler,这个文件事件处理器是单线程的，所以redis才叫做单线程的模型。</p>
<p>它采用IO多路复用机制同时监听多个socket，它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。根据socket上的事件来选择对应的事件处理器进行处理。</p>
<p>这样的好处非常明显： I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：</p>
<ul>
<li>文件事件;</li>
<li>时间事件。</li>
</ul>
<p>时间事件不需要多花时间了解，我们接触最多的还是 文件事件（客户端进行读取写入等操作，涉及一系列网络通信）。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件的： &gt;Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event &gt;handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<blockquote>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
</blockquote>
<blockquote>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</strong></p>
</blockquote>
<p>文件事件处理器的结构包含4各部分：</p>
<ul>
<li>多个socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器，命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路服用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis事件处理器.png" width="700"></p>
<p>客户端与redis的一次通信过程如下： <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis一次通行过程.png" width="800"></p>
<p>客户端<code>socket01</code>向<code>redis</code>的<code>server socket</code>请求建立连接，此时<code>server socket</code>会产生一个<code>AE_READBLE</code>事件，IO多路复用程序监听到<code>server socket</code>产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的<code>socket01</code>,并将该<code>socket01</code>的<code>AE_READBLE</code>事件与命令请求处理器相关联。</p>
<p>假设此时客户端发送了一个<code>set key value</code>请求，此时<code>redis</code>的<code>socket01</code>会产生<code>AE_READABLE</code>事件，IO多路复用程序将事件压入队列，此时事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取<code>socket01</code>中的<code>key value</code>并在自己内存中完成<code>key value</code>的设置。操作完成后，它会将<code>socket01</code>的<code>AE_WRITABLE</code>事件与命令回复处理器相关联。</p>
<p>如果此时客户端准备好接收返回结果了，那么redis中的<code>socket01</code>会产生一个<code>AE_WRITABLE</code>事件，同样压入队列中，事件分派器找到相关联的的命令回复处理器，由命令回复处理器对<code>socket01</code>输入本次操作的一个结果，比如ok，之后解除<code>socket01</code>的<code>AE_WRITABLE</code>事件与命令回复处理器的关联。</p>
<p>这就完成了一次通信。</p>
<h2 id="redis-使用单线程的原因">6. Redis 使用单线程的原因</h2>
<p>Redis 从一开始就选择使用单线程模型处理来自客户端的绝大多数网络请求，这种考虑其实是多方面的，其中最重要的几个原因如下：</p>
<ul>
<li>使用单线程模型能带来更好的可维护性，方便开发和调试；</li>
<li>使用单线程模型也能并发的处理客户端的请求；</li>
<li><strong>Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；</strong></li>
</ul>
<p>上述三个原因中的最后一个是最终使用单线程模型的决定性因素，其他的两个原因都是使用单线程模型额外带来的好处，在这里按顺序介绍上述的几个原因。</p>
<h3 id="可维护性">可维护性</h3>
<p>可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。</p>
<p>如果计算机中的两个进程（线程同理）同时尝试修改一个共享内存的内容，在没有并发控制的情况下，最终的结果依赖于两个进程的执行顺序和时机，如果发生了并发访问冲突，最后的结果就会是不正确的。</p>
<p>引入了多线程，就必须要同时引入并发控制来保证在多个线程同时访问数据时程序行为的正确性，这就需要工程师额外维护并发控制的相关代码，例如，会需要在可能被并发读写的变量上增加互斥锁。</p>
<p>在访问这些变量或者内存之前也需要先对获取互斥锁，一旦忘记获取锁或者忘记释放锁就可能会导致各种诡异的问题，管理相关的并发控制机制也需要付出额外的研发成本和负担。</p>
<h3 id="并发处理">并发处理</h3>
<p><strong>使用单线程模型也并不意味着程序不能并发的处理任务，Redis 虽然使用单线程模型处理用户的请求，但是它却使用 I/O 多路复用机制并发处理来自客户端的多个连接，同时等待多个连接发送的请求。</strong></p>
<p>在 I/O 多路复用模型中，最重要的函数调用就是 select 以及类似函数，该方法的能够同时监控多个文件描述符（也就是客户端的连接）的可读可写情况，当其中的某些文件描述符可读或者可写时，select 方法就会返回可读以及可写的文件描述符个数。</p>
<p>使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要额外创建和维护进程和线程来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。</p>
<h3 id="性能瓶颈">性能瓶颈</h3>
<p>这个就是 Redis 选择单线程模型的决定性原因 —— 多线程技术能够帮助我们充分利用 CPU 的计算资源来并发的执行不同的任务，但是 CPU 资源往往都不是 Redis 服务器的性能瓶颈。哪怕在一个普通的 Linux 服务器上启动 Redis 服务，它也能在 1s 的时间内处理 1,000,000 个用户请求。</p>
<p>如果这种吞吐量不能满足我们的需求，更推荐的做法是使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。</p>
<p>简单总结一下，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。</p>
<p>多线程虽然会更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的开销，其中包括：</p>
<ul>
<li>保存线程 1 的执行上下文；</li>
<li>加载线程 2 的执行上下文；</li>
</ul>
<p>频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。</p>
<p>##7. Redis 多线程 ### Redis 4.0 虽然说 <code>Redis</code> 是单线程模型，但是， 实际上，<code>Redis</code> 在 4.0 之后的版本中就已经加入了对多线程的支持。</p>
<p>不过，<strong><code>Redis 4.0</code> 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</strong></p>
<p>Redis 在最新的几个版本中加入了一些可以被其他线程异步处理的删除操作，例如 <code>UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC</code>等非阻塞的删除操作。为什么会需要这些删除操作，而它们为什么需要通过多线程的方式异步处理？</p>
<h4 id="删除操作多线程的原因">删除操作多线程的原因</h4>
<p>可以在 Redis 在中使用 <code>DEL</code> 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是同步地删除这些键值对也不会消耗太多的时间。</p>
<p>但<strong>是对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的 PCT99 和可用性。</strong></p>
<p><strong>然而释放内存空间的工作其实可以由后台线程异步进行处理，这也就是 UNLINK 命令的实现原理，它只会将键从元数据中删除，真正的删除操作会在后台异步执行。</strong></p>
<blockquote>
<p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p>
</blockquote>
<h3 id="redis6.0-之后引入了多线程">Redis6.0 之后引入了多线程</h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/06/10/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-10 12:18:36" itemprop="dateCreated datePublished" datetime="2023-06-10T12:18:36+08:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-14 17:30:27" itemprop="dateModified" datetime="2023-06-14T17:30:27+08:00">2023-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="准备工作">准备工作</h2>
<h3 id="安装redis">安装Redis</h3>
<ol type="1">
<li>在ubuntu安装Redis <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure></li>
<li>Redis服务器连接默认没有密码，可通过更改<code>/etc/redis/redis.conf</code>内的<code># requirepass foobared</code>来指定登录密码,比如去掉注释后更改密码为<code>requirepass 123456</code>，指定了密码为<code>123456</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/redis/redis.conf</span><br><span class="line">#修改密码</span><br><span class="line">requirepass <span class="number">123456</span></span><br></pre></td></tr></table></figure></li>
<li>运行远程连接redis，redis默认只允许本地连接，你可以通过注释掉<code>bind 127.0.0.1::1</code>来支持远程登录。</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/06/10/Redis/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/05/22/CMU15-445-FALL2023-PROJECT-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/22/CMU15-445-FALL2023-PROJECT-0/" class="post-title-link" itemprop="url">CMU15-445-FALL2022-PROJECT_0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-22 08:47:02" itemprop="dateCreated datePublished" datetime="2023-05-22T08:47:02+08:00">2023-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-06 15:25:52" itemprop="dateModified" datetime="2023-06-06T15:25:52+08:00">2023-06-06</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="介绍">1 介绍</h3>
<p>此次project0项目是实现一个键值对存储，数据结构由<strong>写时复制的字典树</strong>构成。实现的键-值存储可以存储映射到任何类型值的字符串键。键的值存储在表示该键的最后一个字符的节点中(又称终端节点)。例如，考虑在trie中插入kv对(&quot;ab&quot;， 1)和(&quot;ac&quot;， &quot;val&quot;)。 <img src="/2023/05/22/CMU15-445-FALL2023-PROJECT-0/keyvalue.png" width="500"></p>
<h3 id="task1copy-on-write-trie">2 Task1:Copy-On-Write trie</h3>
<ul>
<li><p>在本任务中，只需要修改<code>trie .h</code>和<code>trie .cpp</code>来实现写时复制(copy-on-write) tree。<strong>在写即复制tree中，操作不会直接修改原始tree中的节点。相反，将为修改后的数据创建新节点，并为新修改的trie返回一个新根</strong>。写时复制(Copy-on-write)使我们能够在每次操作之后随时以最小的开销访问该树。考虑在上面的例子中插入<code>(&quot;ad&quot;， 2)</code>。我们通过重用原始树中的两个子节点来创建一个新的Node2，并创建一个新的值节点2。(见下图) <img src="/2023/05/22/CMU15-445-FALL2023-PROJECT-0/new1.png" width="700"></p></li>
<li><p>插入<code>(&quot;b&quot;， 3)</code>，我们将创建一个新的根，一个新的节点，并重用以前的节点。通过这种方式，我们可以在每次插入操作之前和之后获得树的内容。只要我们有根对象(Trie类)，我们就可以访问当时Trie中的数据。(见下图) <img src="/2023/05/22/CMU15-445-FALL2023-PROJECT-0/new2.png" width="700"></p></li>
<li><p>插入<code>(“a”，“abc”)</code>并删除<code>(“ab”，1)</code>，我们可以得到下面的trie。注意，父节点可以有值，并且在删除后需要清除所有不必要的节点。 <img src="/2023/05/22/CMU15-445-FALL2023-PROJECT-0/new3.png" width="700"></p></li>
</ul>
<p>因此，在这里你需要实现三个函数：</p>
<ul>
<li><p><code>Get(key)</code>:获取键对应的值。</p></li>
<li><p><code>Put(key, value)</code>:设置键对应的值。如果键已经存在，则覆盖现有值。注意，值的类型可能是不可复制的(即<code>std::unique_ptr&lt;int&gt;</code>)。这个方法返回一个新的树。</p></li>
<li><p><code>Delete(key)</code>:删除键的值。这个方法返回一个新的树。</p></li>
</ul>
<blockquote>
<p>这些操作都不应该直接在trie本身上执行。您应该创建新的树节点，并尽可能重用现有的树节点。 要创建一个新节点，您应该使用<code>TrieNode</code>类上的<code>Clone</code>函数。要重用新树中的现有节点，可以复制<code>std::shared_pt&lt;TrieNode&gt;</code>复制共享指针不会复制底层数据。您不应该在此项目中通过使用<code>new</code>和<code>delete</code>手动分配内存。当没有人有对底层对象的引用时，<code>std::shared_ptr</code>将释放对象。</p>
</blockquote>
<p>分析：</p>
<ul>
<li><strong>节点类<code>TrieNode</code>使用<code>map&lt;char, std::shared_ptr&lt;const TrieNode&gt;&gt;</code>来存储这种键值结构，</strong>，在这里另一个重要的函数是<code>Clone</code>函数（使用了C++类的构造函数的隐式转换)，<code>Clone</code>函数实现新建树中现有节点</li>
<li><strong>叶子类<code>TrieNodeWithValue</code></strong>，继承于<code>TrieNode</code>，增加了叶子节点存值功能</li>
<li><code>Trie</code>类，内部声明了<code>root</code>（初始为NULL),三个上述待实现的功能</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/05/21/CMU15-445-FALL2023-HOMEWORK1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/CMU15-445-FALL2023-HOMEWORK1/" class="post-title-link" itemprop="url">CMU15-445-FALL2022-HOMEWORK1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-21 15:37:00" itemprop="dateCreated datePublished" datetime="2023-05-21T15:37:00+08:00">2023-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-06 15:25:15" itemprop="dateModified" datetime="2023-06-06T15:25:15+08:00">2023-06-06</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="实验准备">1 实验准备</h3>
<p><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2022/homework1/">作业地址</a></p>
<p>实验当中提供的数据库，其中表关系如下： <img src="/2023/05/21/CMU15-445-FALL2023-HOMEWORK1/schema.png" width="700"></p>
<p>索引创建如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE INDEX ix_people_name ON <span class="title">people</span> <span class="params">(name)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_titles_type ON <span class="title">titles</span> <span class="params">(type)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_titles_primary_title ON <span class="title">titles</span> <span class="params">(primary_title)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_titles_original_title ON <span class="title">titles</span> <span class="params">(original_title)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_akas_title_id ON <span class="title">akas</span> <span class="params">(title_id)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_akas_title ON <span class="title">akas</span> <span class="params">(title)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_crew_title_id ON <span class="title">crew</span> <span class="params">(title_id)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_crew_person_id ON <span class="title">crew</span> <span class="params">(person_id)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="sqlite3的一些特性">2 SQLite3的一些特性</h3>
<ul>
<li><p><code>SQLite3</code>与<code>MySQL</code>的一些不同是一些命另和函数，其数据库的使用直接采用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">imdb-cmudb2022.db  placeholder</span><br><span class="line">$ sqlite3 imdb-cmudb2022.db</span><br></pre></td></tr></table></figure></p></li>
<li><p>查看表： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; .tables</span><br><span class="line">akas      crew      episodes  people    ratings   titles</span><br></pre></td></tr></table></figure></p></li>
<li><p>查看表结构 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; .<span class="function">schema people</span></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">people</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  person_id VARCHAR PRIMARY KEY,</span></span></span><br><span class="line"><span class="params"><span class="function">  name VARCHAR,</span></span></span><br><span class="line"><span class="params"><span class="function">  born INTEGER,</span></span></span><br><span class="line"><span class="params"><span class="function">  died INTEGER</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_people_name ON <span class="title">people</span> <span class="params">(name)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>更大命令使用<code>.help</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; .help</span><br></pre></td></tr></table></figure></p></li>
</ul>
<blockquote>
<p>注意，MySQL当中的一些函数，SQLite未必有，就如<code>concat</code>我就发现没有，SQLite使用<code>||</code>替代字符串拼接</p>
</blockquote>
<h3 id="实验问题">3 实验问题</h3>
<blockquote>
<p>2022 #### 3.1 <code>Q2 [5 points] (q2_sci_fi)</code> <code>Find the 10</code>Sci-Fi<code>works with the longest runtimes.</code> <strong><code>Details:</code></strong> <code>Print the title of the work, the premiere date, and the runtime. The column listing the runtime should be suffixed with the string &quot; (mins)&quot;, for example, if the runtime_mins value is</code>12<code>, you should output 12 (mins). Note a work is Sci-Fi even if it is categorized in multiple genres, as long as Sci-Fi is one of the genres.</code> <code>Your first row should look like this: Cicak-Man 2: Planet Hitam|2008|999 (mins)</code></p>
</blockquote>
<blockquote>
<p>找出10个运行时间最长的“科幻”作品。输出其<code>primary_title、primiered、runtime_minutes</code>，其中<code>runtime_minutes</code>后边要接<code>(mins)</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT PRIMARY_TITLE,PREMIERED,(RUNTIME_MINUTES||<span class="string">&#x27; (mins)&#x27;</span> )</span><br><span class="line">FROM TITLES </span><br><span class="line">WHERE GENRES LIKE <span class="string">&#x27;%Sci-Fi&#x27;</span> </span><br><span class="line">order by RUNTIME_MINUTES DESC LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<h4 id="q3_oldest_people">3.2 <code>q3_oldest_people</code></h4>
<p><code>Determine the oldest people in the dataset who were born in or after 1900. You should assume that a person without a known death year is still alive.</code> <strong>Details:</strong> <code>Print the name and age of each person. People should be ordered by a compound value of their age and secondly their name in alphabetical order. Return the first 20 results.</code></p>
</blockquote>
<blockquote>
<p>Your output should have the format: <code>NAME|AGE</code></p>
</blockquote>
<blockquote>
<p>找出出生于1900后（包含1900），年龄最大的20个人，按照年龄年龄和姓名的字母联合排序。注意没有死亡日期，证明还活着，你要能够处理这类数据 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select name,</span><br><span class="line"><span class="keyword">case</span></span><br><span class="line">    when died is null then <span class="number">2022</span>-born</span><br><span class="line">    <span class="keyword">else</span> died-born</span><br><span class="line">end as age</span><br><span class="line">from people</span><br><span class="line">where born&gt;=<span class="number">1900</span> order by age desc,name limit <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>2023</p>
</blockquote>
<h4 id="q2_not_the_same_title">3.1 <code>q2_not_the_same_title</code></h4>
<p><code>Find the 10 Action movies with the newest premiere date whose original title is not the same as its primary title.</code></p>
<p><strong>Details:</strong> Print the premiere year, followed by the two titles in a special format. The column listing the two titles should be in the format of primary_title (original_title) Note a work is Action even if it is categorized in multiple genres, as long as Action is one of the genres. Also note that it's possible for the premiered year to be in the future. If multiple movies premiered in the same year, order them alphabetically. Your first row should look like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT PREMIERED,(PRIMARY_TITLE||<span class="string">&#x27; (&#x27;</span>||ORIGINAL_TITLE||<span class="string">&#x27;)&#x27;</span>) AS T </span><br><span class="line">FROM TITLES </span><br><span class="line">WHERE PRIMARY_TITLE!=ORIGINAL_TITLE </span><br><span class="line">	AND GENRES LIKE <span class="string">&#x27;%Action%&#x27;</span> </span><br><span class="line">order by PREMIERED DESC,T LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="q3_longest_running_tv">3.2 <code>q3_longest_running_tv</code></h4>
<p><code>Find the top 20 longest running tv series.</code></p>
<p><strong><code>Details</code>: </strong><code>Print the title and the years the series has been running for. The series must have a non NULL premiered year. If the ended date is NULL, assume it to be the current year (2023). If multiple tv series have been running the same number of years, order them alphabetically. Print the top 20 results.</code></p>
<p>Your output should have the format: TITLE|YEARS_RUNNING Your first row should look like this:<code>Looney Tunes|93</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT PRIMARY_TITLE,</span><br><span class="line">CASE </span><br><span class="line">	WHEN ENDED IS <span class="literal">NULL</span> THEN <span class="number">2023</span>-PREMIERED </span><br><span class="line">	ELSE ENDED-PREMIERED </span><br><span class="line">END AS YEARS_RUNNING </span><br><span class="line">FROM TITLES </span><br><span class="line">WHERE PREMIERED IS NOT <span class="literal">NULL</span> </span><br><span class="line">	AND TYPE=<span class="string">&#x27;tvSeries&#x27;</span> </span><br><span class="line">ORDER BY YEARS_RUNNING DESC,PRIMARY_TITLE LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<h4 id="q4_directors_in_each_decade">3.3 <code>q4_directors_in_each_decade</code></h4>
<p>List the number directors born in each decade since 1900.(计算自1900年以来每10年出生的导演人数)</p>
<p><strong>Details:</strong> Print the decade in a fancier format by constructing a string that looks like this: 1990s. Order the results by decade.</p>
<p>Your output should look like this: <code>DECADE|NUM_DIRECTORS</code> Your first row should look like this: <code>1900s|376</code></p>
<p><strong>分析：从事领域存储在<code>crew</code>表的<code>category</code>,其中人的出生时期存储在<code>people</code>表，两表通过<code>person_id</code>联结，<code>people</code>的为主键，<code>crew</code>的为外键</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT decade || <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">    <span class="built_in">COUNT</span>(*)</span><br><span class="line"><span class="built_in">FROM</span> (</span><br><span class="line">        SELECT <span class="built_in">DISTINCT</span>(people.person_id),</span><br><span class="line">            <span class="built_in">FLOOR</span>(people.born / <span class="number">10</span>) * <span class="number">10</span> AS decade</span><br><span class="line">        FROM people</span><br><span class="line">            INNER JOIN crew ON crew.person_id = people.person_id</span><br><span class="line">        WHERE crew.category = <span class="string">&#x27;director&#x27;</span></span><br><span class="line">            AND people.born &gt;= <span class="number">1900</span></span><br><span class="line">    )</span><br><span class="line">GROUP BY decade</span><br><span class="line">ORDER BY decade;</span><br></pre></td></tr></table></figure>
<p><strong>上面的group by decade1</strong>最重要，这样<code>count()</code>会以<code>decade</code>组区分进行统计</p>
<h4 id="q5_german_type_ratings">3.4 <code>q5_german_type_ratings</code></h4>
<p><code>Compute statistics about different type of works that has a German title</code>.(计算具有德语标题的不同类型作品的统计数据。) <strong><code>Details:</code></strong> <code>Compute the average (rounded to 2 decimal places), min, and max rating for each type of work that has a German title and the akas types is either imdbDisplay or original. Sort the output by the average rating of each title type.</code>(计算具有德语标题且<code>akas</code>类型为<code>imdbDisplay</code>或<code>original</code>的每种类型的作品的平均值(舍入到小数点后2位)、最小值和最大值。按每个标题类型的平均评分对输出进行排序。)</p>
<p>Your output should have the format: <code>TITLE_TYPE|AVG_RATING|MIN_RATING|MAX_RATING</code> Your first row should look like this:<code>movie|6.65|3.4|8.2</code></p>
<p><strong>分析：<code>titles</code>表、<code>akas</code>和<code>ratings</code>表通过<code>title_id</code>进行联结，其中<code>titles</code>中作为主键，<code>akas</code>和<code>ratings</code>作为外键。要求<code>akas.types in ('imdbDisplay','original') and akas.language='de'</code>,计算平均值、最大值、最小值</strong>。为三表查询</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT T.TYPE, <span class="built_in">ROUND</span>(<span class="built_in">AVG</span>(R.RATING),<span class="number">2</span>),<span class="built_in">MIN</span>(R.RATING),<span class="built_in">MAX</span>(R.RATING)</span><br><span class="line">FROM TITLES AS T</span><br><span class="line">	INNER JOIN AKAS AS A ON T.TITLE_ID=A.TITLE_ID</span><br><span class="line">	INNER JOIN RATINGS AS R ON T.TITLE_ID=R.TITLE_ID</span><br><span class="line">WHERE A.TYPES <span class="built_in">IN</span> (<span class="string">&#x27;imdbDisplay&#x27;</span>,<span class="string">&#x27;original&#x27;</span>)</span><br><span class="line">	AND A.LANGUAGE=<span class="string">&#x27;de&#x27;</span></span><br><span class="line">GROUP BY T.TYPE</span><br><span class="line">ORDER BY T.TYPE;</span><br></pre></td></tr></table></figure>
<h4 id="q6_who_played_a_batman">3.5 <code>q6_who_played_a_batman</code></h4>
<p><code>List the 10 highest rated actors who played a character named &quot;Batman&quot;.</code>(请列出出演过“蝙蝠侠”角色的10位评价最高的演员) <strong><code>Details:</code> </strong><code>Calculate the actor rating by taking the average rating of all their works. Return both the name of the actor and their rating and only list the top 10 results in order from highest to lowest rating. Round average rating to the nearest hundredth.</code>(通过取所有作品的平均评分来计算演员的评分。返回演员的名字和他们的评分，并且只按评分从高到低的顺序列出前10个结果。四舍五入平均评级到最接近的百分之一。)</p>
<p>Make sure your output is formatted as follows: <code>Kayd Currier|8.05</code></p>
<p><strong>分析</strong>：<code>name</code>在<code>people</code>表，<code>rating</code>在<code>ratings</code>表，<code>characters</code>在<code>crew</code>表，其中三者的联结依赖主外键，<code>ratings</code>和<code>crew</code>通过<code>title_id</code>联结，<code>crew</code>和<code>people</code>通过<code>person_id</code>联结，要求<code>crew.characters like '%Batman%'</code>。<strong>可将<code>people</code>和<code>crew</code>先用<code>person_id</code>进行内连接得到actor,然后利用actor与<code>ratings</code>连接</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WITH actors <span class="title">AS</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SELECT DISTINCT(crew.person_id) AS person_id,</span></span></span><br><span class="line"><span class="params"><span class="function">        people.name AS person_name</span></span></span><br><span class="line"><span class="params"><span class="function">    FROM crew</span></span></span><br><span class="line"><span class="params"><span class="function">        INNER JOIN people ON people.person_id = crew.person_id</span></span></span><br><span class="line"><span class="params"><span class="function">    WHERE crew.characters LIKE <span class="string">&#x27;%&quot;Batman&quot;%&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        AND crew.category = <span class="string">&quot;actor&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function">SELECT a.person_name,</span></span><br><span class="line"><span class="function">    <span class="title">ROUND</span><span class="params">(AVG(rating), <span class="number">2</span>)</span> AS average</span></span><br><span class="line"><span class="function">FROM actors AS a</span></span><br><span class="line"><span class="function">    INNER JOIN crew AS c ON c.person_id </span>= a.person_id</span><br><span class="line">    INNER JOIN ratings AS r ON c.title_id = r.title_id</span><br><span class="line">GROUP BY a.person_id</span><br><span class="line">ORDER BY average DESC</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>上述等价于： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.name,<span class="built_in">ROUND</span>(<span class="built_in">AVG</span>(R.rating),<span class="number">2</span>) <span class="function">AS SCORE</span></span><br><span class="line"><span class="function"><span class="title">FROM</span> <span class="params">(SELECT DISTINCT(C.person_id),P.name,C.title_id</span></span></span><br><span class="line"><span class="params"><span class="function">	FROM crew AS C</span></span></span><br><span class="line"><span class="params"><span class="function">	INNER JOIN people AS P ON C.person_id=P.person_id</span></span></span><br><span class="line"><span class="params"><span class="function">	WHERE C.characters LIKE <span class="string">&#x27;%&quot;Batman&quot;%&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		AND C.category = <span class="string">&#x27;actor&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span> AS A</span></span><br><span class="line"><span class="function">	INNER JOIN crew AS C ON C.person_id</span>=A.person_id</span><br><span class="line">	INNER JOIN ratings AS R ON C.title_id=R.title_id</span><br><span class="line">GROUP BY A.person_id</span><br><span class="line">ORDER BY SCORE DESC</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="q7_born_with_prestige">3.6 <code>q7_born_with_prestige</code></h4>
<p><code>List the number of actors or actress who were born on the year that &quot;The Prestige&quot; was premiered.</code>(列出在《致命魔术》首映那一年出生的演员人数。) <strong><code>Details</code>:</strong> <code>Print only the total number of actors born that year. For this question, determine distinct people by their person_id, not their names. Do not hard code the query.</code>(只打印当年出生的演员总数。对于这个问题，确定不同的人通过他们的person_id，而不是他们的名字。不要硬编码查询。)</p>
<p><strong>分析</strong>：<code>born</code>在<code>people</code>表，<code>primary_title</code>在<code>title</code>表，因此需要将<code>crew</code>与<code>people</code>联结起来。加上条件<code>category IN ('actor', 'actress')和primary_title = 'The Prestige'</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">COUNT</span><span class="params">(DISTINCT(p.person_id))</span></span></span><br><span class="line"><span class="function">FROM people AS p</span></span><br><span class="line"><span class="function">    INNER JOIN crew AS c ON p.person_id </span>= c.person_id</span><br><span class="line">WHERE c.<span class="function">category <span class="title">IN</span> <span class="params">(<span class="string">&#x27;actor&#x27;</span>, <span class="string">&#x27;actress&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    AND p.born <span class="title">IN</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        SELECT premiered</span></span></span><br><span class="line"><span class="params"><span class="function">        FROM titles</span></span></span><br><span class="line"><span class="params"><span class="function">        WHERE primary_title = <span class="string">&#x27;The Prestige&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="q8_directing_rose.sql">3.7 <code>q8_directing_rose.sql</code></h4>
<p><code>Find all the directors who have worked with an actress with first name &quot;Rose&quot;.</code>(找出所有与名字为“Rose”的女演员合作过的导演。) <strong><code>Details:</code></strong> <code>Print only the names of the directors in alphabetical order. Each name should only appear once in the output.</code></p>
<p><strong>分析：</strong><code>category</code>在表<code>crew</code>,<code>name</code>在<code>people</code></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> title_ids <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> c.title_id <span class="keyword">AS</span> title_id</span><br><span class="line">    <span class="keyword">FROM</span> crew <span class="keyword">AS</span> c</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span> people <span class="keyword">AS</span> p <span class="keyword">ON</span> p.person_id = c.person_id</span><br><span class="line">    <span class="keyword">WHERE</span> p.name <span class="keyword">like</span> <span class="string">&#x27;Rose%&#x27;</span></span><br><span class="line">        <span class="keyword">AND</span> c.category = <span class="string">&#x27;actress&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(p.name) <span class="keyword">AS</span> <span class="type">name</span></span><br><span class="line"><span class="keyword">FROM</span> title_ids <span class="keyword">AS</span> t</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> crew <span class="keyword">AS</span> c <span class="keyword">ON</span> t.title_id = c.title_id</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> people <span class="keyword">AS</span> p <span class="keyword">ON</span> p.person_id = c.person_id</span><br><span class="line"><span class="keyword">WHERE</span> c.category = <span class="string">&#x27;director&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">name</span>;</span><br></pre></td></tr></table></figure>
<h4 id="section">3.8</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">深入理解计算机系统-虚拟内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-17 12:44:28" itemprop="dateCreated datePublished" datetime="2023-05-17T12:44:28+08:00">2023-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-30 16:24:29" itemprop="dateModified" datetime="2023-05-30T16:24:29+08:00">2023-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">深入理解计算机系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="虚拟内存">1 虚拟内存</h3>
<p>一个系统中的进程是与其他进程共享CPU和主存资源的。在之前我们明白一个进程会有4GB的内存，但实际中不可能为一个进程真实的分配这么多，否则对于8G的主存，只要两个进程就占满了。因此，计算机系统的设计者们引入了一中很聪明的做法——<strong>虚拟内存</strong>。</p>
<p>虚拟内存是硬件异常、硬件地址翻译、主存和磁盘文件和内核软件的完美交互：</p>
<h4 id="虚拟寻址和地址空间">1.1 虚拟寻址和地址空间</h4>
<p>在计算机中每个字节都存在它唯一的地址，该地址就是<strong>物理地址</strong>，我们将通过真实物理地址进行寻址的方法称为<strong>物理地址</strong>。</p>
<p>而虚拟地址，是指由CPU生成一个<strong>虚拟地址（VA）</strong>来访问主存，如下图，这个虚拟地址在送到内存之前会经过<code>MMU内存管理单元</code>来翻译成物理地址，在这里会结合到后面的<strong>页表</strong>来进行翻译。通过虚拟地址寻址的方式就是<strong>虚拟寻址</strong>。现在计算绝大部分都是使用<strong>寻你寻址</strong>。 <img src="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/MMU.png" width="700"></p>
<p><strong>地址空间</strong>：</p>
<ul>
<li><strong>虚拟地址空间</strong>：虚拟地址空间一般以地址总线条数为基准，如32位的位<span class="math inline">\(2^{32}=4GB\)</span></li>
<li><strong>物理地址空间</strong>：对应与实际内存挡住的M字节，一般来说，物理地址空间由进程运行过程中所实际使用的内存大小所决定</li>
</ul>
<p>物理地址空间和虚拟地址空间是对应关系的，即由虚拟地址找到真实的物理地址。</p>
<h4 id="虚拟内存是作为缓存的工具">1.2 虚拟内存是作为缓存的工具</h4>
<p>在概念上，<strong>虚拟内存是指存放在磁盘上的N字节大小的内存区域，</strong>每个字节都要相应的虚拟地址，作物寻址索引。<strong>和存储结构的缓存一样，磁盘的数据也被分割成块，在这类为做区别称之为虚拟页，每个虚拟页大小由计算机系统决定为<span class="math inline">\(P=2^p\)</span></strong>，与之对应的是物理页，其大小也应该为<code>P</code>。</p>
<p>在任何时刻，我们都不能实际真实一股脑的为进程分配全部的存储空间，因此虚拟页面分为三个不相交的子集：</p>
<ul>
<li><strong>未分配的：</strong>VM系统还没有分配的页，此时未分配的块没有任何数据和它们管理，因此此时不会占有任何磁盘空间</li>
<li><strong>缓存的</strong>：当前缓存的虚拟页在占有磁盘中的空间，当然由于缓存到内存。内存当中也会占有一定内存空间</li>
<li><strong>维缓存的</strong>：在磁盘中占用空间，但并未缓存在内存中，当然不占用内存(此时当CPU要寻址该页当中一个数据时，由于未缓存在内存中，就会造成<strong>缺页异常</strong>。) <img src="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/VP.png" width="700"></li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" class="post-title-link" itemprop="url">深入理解计算机系统-异常控制流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-15 10:28:04" itemprop="dateCreated datePublished" datetime="2023-05-15T10:28:04+08:00">2023-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 10:19:19" itemprop="dateModified" datetime="2023-05-16T10:19:19+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">深入理解计算机系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="异常控制流">1 异常控制流</h3>
<p>现代系统通过使控制流发生突变来对这些情况做出反应，我们把这些突变称为异常控制流(ECF)。</p>
<ul>
<li>在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序；</li>
<li>在操作系统层，内核通过<strong>上下文切换</strong>将控制从一个用户进程转移到另一个用户进程；</li>
<li>在应用层，一个进程可发发送信号到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序。</li>
</ul>
<p>作为程序员，理解ECF很重要：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-09 14:47:11" itemprop="dateCreated datePublished" datetime="2023-05-09T14:47:11+08:00">2023-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-10 11:25:51" itemprop="dateModified" datetime="2023-06-10T11:25:51+08:00">2023-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>36k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="操作系统的基本概念">1 操作系统的基本概念</h3>
<ol type="1">
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li>操作系统本质上是一个运行在计算机上的<strong>软件程序</strong> ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li>操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 </strong>内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<h4 id="操作系统的内核kernel">操作系统的内核（Kernel）</h4>
<p>维基百科对于内核的解释： &gt;<strong>内核</strong>（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I/O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 <strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</strong></p>
<blockquote>
<p>早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!</p>
</blockquote>
<p><strong>简单概括两点：</strong></p>
<ul>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li>
<li>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</li>
</ul>
<h4 id="中央处理器cpucentral-processing-unit">中央处理器（CPU，Central Processing Unit）</h4>
<p>关于 CPU 简单概括三点：</p>
<ul>
<li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑</strong>。</li>
<li>** CPU 主要包括两个部分：控制器+运算器。**</li>
<li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li>
</ul>
<h4 id="cpu-vs-kernel内核">CPU vs Kernel(内核)</h4>
<p>可以简单从下面两点来区别：</p>
<ul>
<li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li>
<li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/操作系统概念.png" width="500"></li>
</ul>
<h3 id="操作系统的基本特性">2 操作系统的基本特性</h3>
<p>操作系统的基本特性是<strong>并发性、共享性、虚拟性、异步性。</strong></p>
<h4 id="并发性">并发性</h4>
<p><strong>并行性和并发性(Concurrence)是既相似又有区别的两个概念，</strong>并行性是指两个或多个事件在同一时刻发生；而并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。（宏观并发微观串行）</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h4 id="共享性">共享性</h4>
<p>指系统中的资源可供内存中多个并发执行的进程(线程)共同使用，相应地，把这种资源共同使用称为资源共享，或称为资源复用。目前主要实现资源共享的方式有：</p>
<ul>
<li>互斥共享方式</li>
<li>同时访问方式</li>
</ul>
<h5 id="互斥共享方式">互斥共享方式</h5>
<p>当一个进程 A 要访问某资源时，必须先提出请求。如果此时该资源空闲，系统便可将之分配给请求进程 A 使用。此后若再有其它进程也要访问该资源时(只要 A 未用完)，则必须等待。仅当 A 进程访问完并释放该资源后，才允许另一进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源，例如打印机。</p>
<h5 id="同时访问方式">同时访问方式</h5>
<p>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p>
<h4 id="虚拟性">虚拟性</h4>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：<strong>时（时间）分复用技术和空（空间）分复用技术。</strong></p>
<p><strong>多个进程能在同一个处理器上并发执行使用了时分复用技术</strong>，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p>虚拟内存使用了<strong>空分复用技术</strong>，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<h4 id="异步性">异步性</h4>
<p>在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。进程是以人们不可预知的速度向前推进，此即进程的异步性。</p>
<h3 id="操作系统的基本功能">3 操作系统的基本功能</h3>
<p>操作系统的基本功能包括<strong>进程管理、内存管理、文件管理、设备管理。</strong></p>
<ul>
<li><strong>进程管理</strong>：进程控制、进程同步、进程通信、死锁处理、处理机调度等</li>
<li><strong>内存管理</strong>：内存分配、地址映射、内存保护与共享、虚拟内存等</li>
<li><strong>文件管理</strong>：文件存储空间的管理、目录管理、文件读写管理和保护等</li>
<li><strong>设备管理</strong>：完成用户I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备管理、设备处理、虚拟设备等。</li>
</ul>
<h3 id="什么是系统调用用户态和系统态是">4 什么是系统调用/用户态和系统态是？</h3>
<p>根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：</p>
<ul>
<li>** 用户态(user mode) **: 用户态运行的进程或程序可以直接读取用户程序的数据。</li>
<li><strong>系统态(kernel mode)</strong>:可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ul>
<p>我们运行的程序基本都是运行在用户态，如果要调用操作系统提供的系统态级别的子功能，那就需要系统调用了！</p>
<p>也就是说在运行的用户程序中，<strong>凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</strong></p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/systemcall.png" width="600"></li>
</ul>
<h4 id="为什么要有用户态与内核态">为什么要有用户态与内核态?</h4>
<p><strong>在 cpu 的所有指令中，有些指令是非常危险的，如果使用不当，将会造成系统崩溃等后果。为了避免这种情况发生，cpu 将指令划分为特权级(内核态)指令和非特权级(用户态)指令。</strong></p>
<p><strong>对于那些危险的指令只允许内核及其相关模块调用，对于那些不会造成危险的指令，就允许用户应用程序调用。</strong></p>
<ul>
<li>内核态(核心态,特权态): 内核态是操作系统内核运行的模式。 内核态控制计算机的硬件资源，如硬件设备，文件系统等等，并为上层应用程序提供执行环境。</li>
<li>用户态: 用户态是用户应用程序运行的状态。 应用程序必须依托于内核态运行,因此用户态的操作权限比内核态是要低的，如磁盘，文件等，访问操作都是受限的。</li>
<li>系统调用: 系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。</li>
</ul>
<h4 id="用户态切换到内核态的几种方式">用户态切换到内核态的几种方式</h4>
<ul>
<li><strong>系统调用:</strong> 系统调用是用户态主动要求切换到内核态的一种方式，用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</li>
<li><strong>异常:</strong> 当 cpu 在执行用户态的应用程序时，发生了某些不可知的异常。于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</li>
<li><strong>硬件设备的中断:</strong> 当硬件设备完成用户请求后，会向 cpu 发出相应的中断信号，这时 cpu 会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序，如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核台的转换。</li>
</ul>
<h3 id="计算机的局部性原理">5 计算机的局部性原理</h3>
<p>一个编写良好的计算机程序常常具有良好的<strong>局部性</strong>，即他们更加倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用或的数据项本身，这种特性，常常称为<strong>局部性原理</strong>。局部性由两种不同的形式：<strong>时间局部性和空间局部性</strong></p>
<ul>
<li><strong>时间局部性</strong>：被引用过一次的内存位置很有可能在不久的将来再次被多次引用。</li>
<li><strong>空间局部性</strong>：一个内存被引用过了，那么极有可能在不久的将来会引用器附近的内存位置。在高速缓存中的表现形式是以<strong>数据块</strong>的形式进行缓存，弥补未命中时的惩罚</li>
</ul>
<p>我们应该理解局部性原理，因为一般而言，一个良好局部性的程序比局部性差的程序运行得更快，这是由现代计算机系统得设计结构所决定得，在现代计算系统得各个层次之哦你给，都引入了局部性原理：</p>
<ul>
<li>在硬件层，计算机设计者通过引入称为<strong>高速缓存存储器</strong>这样小而快得快速存储器来保存最近引用得指令和数据项，从而提高对主存得访问速度。</li>
<li>在操作系统中，系统使用主存作为<strong>虚拟地址空间</strong>，来存储最近被引用得数据项，来避免因从磁盘取数据过慢而导致CPU资源的浪费</li>
<li>类似的，用主存来缓存磁盘文件中最近被使用的磁盘块。</li>
<li>局部性原理在应用程序中也有应用，入<code>Web</code>浏览器将最近引用的文档放在本地磁盘上，利用的就是时间局部性。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">深入理解计算机系统-链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-09 14:45:40" itemprop="dateCreated datePublished" datetime="2023-05-09T14:45:40+08:00">2023-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-14 21:24:55" itemprop="dateModified" datetime="2023-05-14T21:24:55+08:00">2023-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">深入理解计算机系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="链接器">1 链接器</h3>
<h4 id="链接是什么">1.1 链接是什么</h4>
<p><strong>链接是将各种代码和数据片段收集并组合成为一个单一文件的过程</strong>，这个文件可被加载到内存并执行。</p>
<ul>
<li>链接可以执行与编译时，也就是源代码被翻译成机器代码时；</li>
<li>也可以执行与加载时，也就是在程序被加载器（loader)加载带内存并执行时</li>
<li><strong>甚至也可执行于运行时，也就是有程序来执行</strong></li>
</ul>
<p>链接器在开发中是一个关键角色，因为它使得<strong>分离编译</strong>成为可能，我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以分解成更小、更好管理的模块。可以单独修改和编译这些模块。理解<strong>链接</strong>有以下的好处：</p>
<ul>
<li><p><strong>理解链接器将帮助你构造大型程序</strong>。构造大型程序的程序员经常会遇到<strong>缺少模块、库或者不兼容版本引起的链接器错误</strong>，当你理解了链接器如何<strong>解析引用、什么是库以及链接器是如何使用库来解析引用时，你就能够较好的解决这类问题</strong></p></li>
<li><p><strong>理解链接器将帮助你避免一些危险的编程错误</strong>。Linux链接器解析引用时所做的决定可以不动声色影响你程序的正确性。在默认情况下，错误的定义多个全局变量的程序将通过链接器，而不产生任何警告信息。</p></li>
<li><p><strong>理解链接器将帮助你理解语言的作用域规则是如何实现的</strong>。全局变量和局部变量、static变量和static函数，在低层到底有何区别？</p></li>
<li><p><strong>理解链接器帮助你理解其他重要系统概念</strong>。链接器产生的可执行目标文件咋子系统功能中扮演关键角色，如<strong>加载运行程序、虚拟内存、分页、内存映射。</strong></p></li>
<li><p><strong>理解链接器将使你能够利用共享库</strong>。共享库和动态链接在现代操作系统日益重要，掌握如何动态链接原理极其重要。</p></li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">深入理解计算机系统-存储器层次结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-07 21:15:21" itemprop="dateCreated datePublished" datetime="2023-05-07T21:15:21+08:00">2023-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-09 11:10:41" itemprop="dateModified" datetime="2023-05-09T11:10:41+08:00">2023-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">深入理解计算机系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="存储技术">1 存储技术</h3>
<p>作为一名程序员，你必须了解存储器的层次结构，因为它对应用程序的性能有着巨大的影响。</p>
<ul>
<li><strong>如果你的数据是在cpu寄存器上，那么指令执行期间在0个周期就能访问到</strong></li>
<li>如果是在高速缓存中，需要4-75个周期</li>
<li>如果在主存，需要上百个周期</li>
<li><strong>如果是在磁盘，那么就需要大约几千万个周期，时间大概是毫秒级，比主存慢10万倍，比高速缓存慢100万倍</strong></li>
</ul>
<h4 id="随机访问存储器">1.1 随机访问存储器</h4>
<p>随机访问存储器(RAM)有两类：静态和动态。静态RAM(SRAM)比动态DRAM(DRAM)更快，但也更贵，<strong>因此SRAM一般集成在CPU上作为高速缓存，DRAM则作为主存。</strong>断电以后，DRAM和SRAM都会丢失它们的信息</p>
<p><strong>访问主存：</strong>每次CPU和主存之间的数据传送都是通过一系列的步骤来完成，这些步骤称为<strong>总线事务</strong>。<strong>读事务</strong>从主存传输数据到CPU，<strong>写事务</strong>从CPU传送数据到主存。总线是一组并行的导线，能携带地址、数据和控制信号。 <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/bus.png" width="600"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">深入理解计算机系统-优化程序性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-06 20:29:03" itemprop="dateCreated datePublished" datetime="2023-05-06T20:29:03+08:00">2023-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-07 21:30:55" itemprop="dateModified" datetime="2023-05-07T21:30:55+08:00">2023-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">深入理解计算机系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>574</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="导读">1 导读</h3>
<p>程序优化涉及的范围实在是太广了，几乎每个层面都可以进行优化，比如撰写<编译器友好型>以及<缓存友好型>的程序，针对不同的目标硬件平台还可能进行特定的优化，等等，优化的难点在于你需要对系统有充分理解，当然了在你做优化之前<strong>首先要保证原始程序功能正确（并且有回归测试）</strong>，否则一切都是徒劳。</缓存友好型></编译器友好型></p>
<blockquote>
<p>首先需要理解，哪些因素会影响程序的性能 <img src="/2023/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/influence.png" width="700"></p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">968k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:40</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
 


<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>