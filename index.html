<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Trluper">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="trluper">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/" class="post-title-link" itemprop="url">python数学库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-18 10:40:45 / 修改时间：16:25:30" itemprop="dateCreated datePublished" datetime="2022-09-18T10:40:45+08:00">2022-09-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="numpy概述">1. Numpy概述</h4>
<h5 id="概念">1.1 概念</h5>
<p>Python本身含有列表和数组，但对于大数据来说，这些结构是有很多不足的。由于列表的元素可以是任何对象，因此列表中所保存的是对象的指针。对于数值运算来说这种 结构比较浪费内存和CPU资源。至于数组对象，它可以直接保存 数值，和C语言的一维数组比较类似。但是由于它不支持多维，在上面的函数也不多，因此也不适合做数值运算。Numpy提供了两种基本的对象：<code>ndarray(N-dimensional Array Object)</code>和 <code>ufunc(Universal Function Object)</code>。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。</p>
<h5 id="功能">1.2 功能</h5>
<ul>
<li>创建n维数组(矩阵)</li>
<li>对数组进行函数运算，使用函数计算十分快速，节省了大量的时间，且不需要编写循环，十分方便</li>
<li>数值积分、线性代数运算、傅里叶变换</li>
<li>ndarray快速节省空间的多维数组，提供数组化的算术运算和高级的 广播功能</li>
</ul>
<h5 id="对象">1.3 对象</h5>
<ul>
<li>NumPy中的核心对象是<code>ndarray</code></li>
<li><code>ndarray</code>可以看成数组，存放 同类元素</li>
<li>NumPy里面所有的函数都是围绕ndarray展开的</li>
</ul>
<p><strong><code>ndarray</code> 内部由以下内容组成：</strong></p>
<ul>
<li>一个指向数据(内存或内存映射文件中的一块数据)的指针。</li>
<li>数据类型或 dtype，描述在数组中的固定大小值的格子。</li>
<li>一个表示数组形状(shape)的元组，表示各维度大小的元组。形状为(row×col)</li>
</ul>
<h5 id="数据类型">1.4 数据类型</h5>
<p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和C语言的数据类型对应上。主要包括<code>int8、int16、int32、int64、uint8、uint16、uint32、uint64、float16、float32、float64</code></p>
<h5 id="数组属性">1.5 数组属性</h5>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ndarray.ndim</code></td>
<td>秩，即轴的数量或维度的数量</td>
</tr>
<tr class="even">
<td><code>ndarray.shape</code></td>
<td>数组的维度(n×m)，对于矩阵，n 行 m 列</td>
</tr>
<tr class="odd">
<td><code>ndarray.size</code></td>
<td>数组元素的总个数，相当于 .shape 中 n*m 的值</td>
</tr>
<tr class="even">
<td><code>ndarray.dtype</code></td>
<td>ndarray 对象的元素类型</td>
</tr>
<tr class="odd">
<td><code>ndarray.itemsize</code></td>
<td>ndarray 对象中每个元素的大小，以字节为单位</td>
</tr>
<tr class="even">
<td><code>ndarray.flags</code></td>
<td>ndarray对象的内存信息</td>
</tr>
<tr class="odd">
<td><code>ndarray.real</code></td>
<td>ndarray元素的实部</td>
</tr>
<tr class="even">
<td><code>ndarray.imag</code></td>
<td>ndarray元素的虚部</td>
</tr>
<tr class="odd">
<td><code>ndarray.data</code></td>
<td>包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td>
</tr>
</tbody>
</table>
<h4 id="具体操作">2. 具体操作</h4>
<h5 id="numpy的创建">2.1 Numpy的创建</h5>
<h6 id="利用列表生成数组">2.1.1 利用列表生成数组</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">lst=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">np1=np.array(lst)</span><br><span class="line"><span class="built_in">print</span>(np1,<span class="built_in">type</span>(np1))</span><br></pre></td></tr></table></figure>
<h6 id="利用random模块生成数组">2.1.2 利用random模块生成数组</h6>
<p><img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/numpyRandom.png" width="600"> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#0到1标准正态分布</span></span><br><span class="line">arr1 = np.random.randn(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#0到1均匀分布</span></span><br><span class="line">arr2 = np.random.rand(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#均匀分布的随机数（浮点数），前两个参数表示随机数的范围，第三个表示生成随机数的个数</span></span><br><span class="line">arr3 = np.random.uniform(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">#均匀分布的随机数（整数），前两个参数表示随机数的范围，第三个表示生成随机数的个数</span></span><br><span class="line">arr4 = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;arr1 : <span class="subst">&#123;arr1&#125;</span>\narr2 : <span class="subst">&#123;arr2&#125;</span>\narr3 : <span class="subst">&#123;arr3&#125;</span>\narr4 : <span class="subst">&#123;arr4&#125;</span>&#x27;</span>)</span><br><span class="line">out : </span><br><span class="line"><span class="comment"># arr1 : [[-0.31637952 -0.08258995  1.43866984]</span></span><br><span class="line"><span class="comment">#  [-0.11216775  0.43881134  0.11745847]</span></span><br><span class="line"><span class="comment">#  [-1.1770306  -0.97657465  2.2368878 ]]</span></span><br><span class="line"><span class="comment"># arr2 : [[0.16350611 0.4467384  0.9465067 ]</span></span><br><span class="line"><span class="comment">#  [0.1882318  0.40261184 0.93577701]</span></span><br><span class="line"><span class="comment">#  [0.56243911 0.69179631 0.83407725]]</span></span><br><span class="line"><span class="comment"># arr3 : [4.41402883 6.03259052]</span></span><br><span class="line"><span class="comment"># arr4 : [9 7 7]</span></span><br></pre></td></tr></table></figure></p>
<h6 id="创建特定形状数组">2.1.3 创建特定形状数组</h6>
<p><img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/spacial.png" width="600"> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mport numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#未初始化的数组</span></span><br><span class="line">arr1 = np.empty((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">#数组元素以 0 来填充</span></span><br><span class="line">arr2 = np.zeros((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">#数组元素以 1 来填充</span></span><br><span class="line">arr3 = np.ones((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">#数组以指定的数来进行填充，这里举例3</span></span><br><span class="line">arr4 = np.full((<span class="number">2</span>, <span class="number">3</span>), <span class="number">3</span>)</span><br><span class="line"><span class="comment">#生成单位，对角线上元素为 1，其他为0</span></span><br><span class="line">arr5 = np.eye(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#二维矩阵输出矩阵对角线的元素，一维矩阵形成一个以一维数组为对角线元素的矩阵</span></span><br><span class="line">arr6 = np.diag(np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]))</span><br></pre></td></tr></table></figure></p>
<h6 id="linspace">2.1.4 linspace</h6>
<p>此函数类似于arange()函数。在此函数中，指定了范围之间的均匀间隔数量，而不是步长。用法如下 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.linspace(start, stop, num, endpoint, retstep, dtype)</span><br></pre></td></tr></table></figure> - <code>start</code> 序列的起始值 - <code>stop</code> 序列的终止值，如果endpoint为true，该值包含于序列中 - <code>num</code> 要生成的等间隔样例数量，默认为50 - <code>endpoint</code> 序列中是否包含stop值，默认为ture - <code>retstep</code> 如果为true，返回样例，以及连续数字之间的步长 - <code>dtype</code> 输出ndarray的数据类型</p>
<h5 id="查找和搜索">2.2 查找和搜索</h5>
<p>Numpy可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样，设置start, stop 及 step 参数</p>
<h6 id="切片操作">2.2.1 切片操作</h6>
<p><img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/index.png" width="600"></p>
<h6 id="元素查找定位">2.2.2 元素查找定位</h6>
<p>Numpy库中提供了<code>where</code>函数来查找满足条件元素的索引，表示如下：</p>
<ul>
<li><code>np.where(condition, x, y)</code>: 满足条件(condition)，输出x，不满足输出y</li>
<li><code>np.where(condition)</code>: 输出满足条件 (即非0) 元素的坐标</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>]).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x=np.where(a&gt;<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a[x])</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">6</span>  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span>]</span><br></pre></td></tr></table></figure></p>
<h6 id="高级索引">2.2.3 高级索引</h6>
<p>如果一个<code>ndarray</code>是非元组序列，数据类型为整数或布尔值的ndarray，或者至少一个元素为序列对象的元组，我们就能够用它来索引ndarray。高级索引始终返回数据的副本。使用方法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([[<span class="number">1</span>,  <span class="number">2</span>],  [<span class="number">3</span>,  <span class="number">4</span>],  [<span class="number">5</span>,  <span class="number">6</span>]]) </span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]  </span><br><span class="line"><span class="built_in">print</span> y</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure> 解析:上面的x下标索引的两个列表进行两两配对<code>(0,0),(1,1),(2,0)</code>位置，得到`x[0,0],x[1,1],x[2,0]等就是输出结果</p>
<h5 id="删除">2.3 删除</h5>
<p><code>np.delete(arr, index, axis=None)</code></p>
<ul>
<li>第一个参数：要处理的矩阵，</li>
<li>第二个参数，处理的位置，下标</li>
<li>第三个参数，0表示按照行删除，1表示按照列删除，默认为0</li>
<li>返回值为删除后的剩余元素构成的矩阵</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m=np.delete(a,[<span class="number">0</span>],<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure>
<h5 id="numpy的拼接和分割">2.4 numpy的拼接和分割</h5>
<h6 id="拼接">2.4.1 拼接</h6>
<p>下面的图列举了常见的用于数组或向量 合并的方法。 <img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/append.png" width="600"></p>
<ul>
<li><code>append、concatenate</code>以及<code>stack</code>都有一个<code>axis</code>参数，用于控制数组的合 并方式是按行还是按列。</li>
<li>对于<code>append</code>和<code>concatenate</code>，待合并的数组必须有相同的行数或列数</li>
<li><code>stack、hstack、dstack</code>，要求待合并的数组必须具有相同的形状</li>
</ul>
<h6 id="分割">2.4.2 分割</h6>
<ul>
<li>水平分割：<code>np.split(arr,n,axis=1) 或 np.hsplit(arr,n)</code>：按列分成<code>n</code>份。返回一个<code>list</code></li>
<li>垂直分割：<code>np.split(arr,n,axis=0)</code> 或 <code>np.vsplit(arr,n)</code>：按行分成n份，返回一个<code>list</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">splitTes=np.split(a,<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">splitTes2=np.split(a,<span class="number">3</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="维度变换">2.5 维度变换</h5>
<p>在机器学习以及深度学习的任务中，通常需要将处理好的数据以模型能 接收的格式输入给模型，然后由模型通过一系列的运算，最终返回一个处理 结果。然而，由于不同模型所接收的输入格式不一样，往往需要先对其进行 一系列的变形和运算，从而将数据处理成符合模型要求的格式。在矩阵或者 数组的运算中，经常会遇到需要把多个向量或矩阵按某轴方向合并，或展平 (如在卷积或循环神经网络中，在全连接层之前，需要把矩阵展平)的情 况。下面介绍几种常用的数据变形方法。 <img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/switch.png" width="600"></p>
<h6 id="reshape">2.5.1 reshape</h6>
<p>不会改变数组内额元素，返回一个指定的shap维度的数组，按原顺序放置元素 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#三行四列，如果单指定行数或列数，另一个参数可设置为-1</span></span><br><span class="line">x=np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<h6 id="resize">2.5.2 resize</h6>
<p>改变向量的维度，同<code>reshape</code>作用 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#二行五列</span></span><br><span class="line">arr=np.arange(<span class="number">10</span>)</span><br><span class="line">arr.resize(<span class="number">2</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<h6 id="转置">2.5.3 转置</h6>
<p>将矩阵转置 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr=np.nrange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.T)</span><br></pre></td></tr></table></figure></p>
<h6 id="向量展平">2.5.4 向量展平</h6>
<p>将多维数组转为一维数组，不会产生数组的副本 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr=arr.ravel()</span><br></pre></td></tr></table></figure></p>
<h6 id="向量展平之flatten">2.5.5 向量展平之flatten</h6>
<p>把矩阵转换为向量，这种需求经常出现在卷积网络与全连接层之间 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">arr.flatten() <span class="comment"># out : array([0, 1, 2, 3, 4, 5, 6, 7])</span></span><br></pre></td></tr></table></figure></p>
<h6 id="squeeze">2.5.6 squeeze</h6>
<p>这是一个降维的函数，把矩阵中为1维的维度去掉 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">arr.shape <span class="comment"># out : (2, 4, 1)</span></span><br><span class="line">arr.squeeze().shape <span class="comment"># out : (2, 4)</span></span><br></pre></td></tr></table></figure></p>
<h6 id="transpose">2.5.7 transpose</h6>
<p>对高维矩阵进行轴对换，这个在深度学习中经常使用，比如把图片中表 示颜色顺序的RGB改为GBR。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).reshape(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>)</span><br><span class="line">arr.shape <span class="comment"># out : (2, 6, 1)</span></span><br><span class="line">arr.transpose(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).shape <span class="comment"># out : (6, 1, 2)</span></span><br></pre></td></tr></table></figure></p>
<h5 id="矩阵运算">2.6 矩阵运算</h5>
<h6 id="对于元素相乘">2.6.1 对于元素相乘</h6>
<p>对应元素相乘（Element-Wise Product）是两个矩阵中对应元素乘积。 np.multiply函数用于数组或矩阵对应元素相乘，输出与相乘数组或矩阵的大 小一致。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.array([[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line">np.multiply(a, b) <span class="comment"># 等效于a * b，out : array([[4, 0], [0, 2]])</span></span><br></pre></td></tr></table></figure></p>
<h6 id="点积">2.6.2 点积</h6>
<p>点积运算(Dot Product)又称为内积，在Numpy用np.dot或者np.matmul表示 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.array([[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line">np.dot(a, b) <span class="comment"># 等效于np.matmul(a, b) out : array([[4, 1], [2, 2]])</span></span><br></pre></td></tr></table></figure></p>
<h6 id="行列式">2.6.3 行列式</h6>
<p>计算行列式的值 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">np.linalg.det(arr) <span class="comment"># out : -2.0000000000000004</span></span><br></pre></td></tr></table></figure></p>
<h6 id="求逆">2.6.4 求逆</h6>
<p>求逆 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">np.linalg.inv(arr) <span class="comment"># out : array([[-2. ,  1. ], [ 1.5, -0.5]])</span></span><br></pre></td></tr></table></figure></p>
<h6 id="特征值和特征向量">2.6.5 特征值和特征向量</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.<span class="built_in">randint</span>(<span class="number">-10</span>,<span class="number">10</span>,(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">C = np.<span class="built_in">dot</span>(A.T, A)</span><br><span class="line">vals, vecs = np.linalg.<span class="built_in">eig</span>(C) </span><br><span class="line"><span class="built_in">print</span>(f<span class="number">&#x27;</span>特征值 : &#123;vals&#125;, 特征向量 : &#123;vecs&#125;<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">#out : </span></span><br><span class="line"><span class="string">特征值 : [395.26566729 358.52489695  44.41465068  52.79478508]</span></span><br><span class="line"><span class="string">特征向量 : [[ 0.30221599  0.64309202 -0.64757004 -0.27522935]</span></span><br><span class="line"><span class="string">             [ 0.87819925 -0.03518532  0.18871425  0.43808105]</span></span><br><span class="line"><span class="string">             [-0.35779498  0.26192443 -0.27010759  0.85464626]</span></span><br><span class="line"><span class="string">             [ 0.09702746 -0.71874212 -0.68708214  0.04374437]]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h5 id="numpy--matplotlib">2.7 numpy- Matplotlib</h5>
<p>Matplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure> 这里<code>pyplot()</code>是 <code>matplotlib</code>库中最重要的函数，用于绘制 2D 数据。 以下脚本绘制方程<code>y = 2x + 5：</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt </span><br><span class="line"> </span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">11</span>) <span class="comment">#x=np.linspace(1,11,2000)</span></span><br><span class="line">y =  <span class="number">2</span>  * x +  <span class="number">5</span> </span><br><span class="line">plt.title(<span class="string">&quot;Matplotlib demo&quot;</span>) </span><br><span class="line">plt.xlabel(<span class="string">&quot;x axis caption&quot;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&quot;y axis caption&quot;</span>) </span><br><span class="line">plt.plot(x,y) plt.show()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://quantfabric.blog.csdn.net/article/details/123096127?spm=1001.2014.3001.5502">Numpy详细教程</a></p>
<h4 id="pandas概述">3.pandas概述</h4>
<p>Pandas是Python的一个大数据处理模块。Pandas使用一个二维的数据结构DataFrame来表示表格式的数据，相比较于Numpy，Pandas可以存储混合的数据结构，同时使用NaN来表示缺失的数据，而不用像Numpy一样要手工处理缺失的数据，并且Pandas使用轴标签来表示行和列。它具有：</p>
<ul>
<li>便捷的数据处理能力</li>
<li>独特的数据结构</li>
<li>读取文件方便</li>
<li>封装了<code>matplotlib</code>的画图和<code>numpy</code>的计算</li>
</ul>
<h5 id="pandas的数据结构">3.1 pandas的数据结构</h5>
<p>Pandas有三种主要数据结构<code>Series、DataFrame、Panel</code>。</p>
<ul>
<li><p><code>Series</code>是带有标签的一维数组，可以保存任何数据类型（整数，字符串，浮点数，Python对象等），轴标签统称为索引（index）。</p></li>
<li><p><code>DataFrame</code>是带有标签的二维数据结构，具有<code>index</code>（行标签）和<code>columns</code>（列标签）。如果传递<code>index</code>或<code>columns</code>，则会用于生成的D<code>ataFrame</code>的<code>index</code>或<code>columns</code>。</p></li>
<li><p><code>Panel</code>是一个三维数据结构，由<code>items、major_axis、minor_axis</code>定义。<code>items</code>（条目），即轴0，每个条目对应一个<code>DataFrame</code>；<code>major_axis（主轴）</code>，即轴1，是每个<code>DataFrame</code>的index（行）；<code>minor_axis</code>（副轴），即轴2，是每个<code>DataFrame</code>的columns（列）。</p></li>
</ul>
<h5 id="series">3.2 Series</h5>
<p>Series是能够保存任何类型数据(整数，字符串，浮点数，Python对象等)的一维标记数组，轴标签统称为index（索引）。series是一种一维数据结构，每一个元素都带有一个索引，其中索引可以为数字或字符串。Series结构名称： <img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/Series.png" width="400"></p>
<h6 id="构造对象">3.2.1 构造对象</h6>
<p>Series的构造函数如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.Series( data, index, dtype, copy)</span><br></pre></td></tr></table></figure> - <code>data</code>：构建Series的数据，可以是ndarray，list，dict，constants。 - <code>index</code>：索引值必须是唯一的和散列的，与数据的长度相同。 如果没有索引被传递，默认为np.arange(n)。 - <code>dtype</code>：数据类型，如果没有，将推断数据类型。 - <code>copy</code>：是否复制数据，默认为false。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = np.array([<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">    s = pd.Series(data,index=[<span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 101      a</span></span><br><span class="line"><span class="comment"># 102      1</span></span><br><span class="line"><span class="comment"># 103      2</span></span><br><span class="line"><span class="comment"># hello    4</span></span><br><span class="line"><span class="comment"># world    6</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br></pre></td></tr></table></figure>
<p>使用<code>ndarray</code>作为数据时，传递的索引必须与<code>ndarray</code>具有相同的长度。 如果没有传递索引值，那么默认的索引是<code>range(n)</code>，其中n是数组长度，即<code>[0,1,2,3…. range(len(array))-1] - 1]</code>。</p>
<h6 id="series数据的访问">3.2.2 Series数据的访问</h6>
<p>Series中的数据可以使用有序序列的方式进行访问。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(s[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(s[-<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(s[-<span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># c    3</span></span><br><span class="line"><span class="comment"># d    4</span></span><br><span class="line"><span class="comment"># e    5</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br></pre></td></tr></table></figure></p>
<h6 id="series属性">3.2.3 Series属性</h6>
<ul>
<li><code>Series.axes</code>：返回行轴标签列表</li>
<li><code>Series.dtype</code>：返回对象的数据类型</li>
<li><code>Series.empty</code>：如果对象为空，返回True</li>
<li><code>Series.ndim</code>：返回底层数据的维数，默认为1</li>
<li><code>Series.size</code>：返回基础数据中的元素数</li>
<li><code>Series.values</code>：将对象作为ndarray返回</li>
<li><code>Series.head()</code>：返回前n行</li>
<li><code>Series.tail()</code>：返回后n行</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = pd.Series([<span class="string">&quot;Bauer&quot;</span>, <span class="number">30</span>, <span class="number">90</span>], index=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Score&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Series=================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;axes===================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.axes)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dtype==================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.dtype)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;empty==================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.empty)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ndim===================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.ndim)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;size===================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.size)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;values=================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.values)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;head()=================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.head(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tail()=================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.tail(<span class="number">2</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Series=================</span></span><br><span class="line"><span class="comment"># Name     Bauer</span></span><br><span class="line"><span class="comment"># Age         30</span></span><br><span class="line"><span class="comment"># Score       90</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br><span class="line"><span class="comment"># axes===================</span></span><br><span class="line"><span class="comment"># [Index([&#x27;Name&#x27;, &#x27;Age&#x27;, &#x27;Score&#x27;], dtype=&#x27;object&#x27;)]</span></span><br><span class="line"><span class="comment"># dtype==================</span></span><br><span class="line"><span class="comment"># object</span></span><br><span class="line"><span class="comment"># empty==================</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># ndim===================</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># size===================</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># values=================</span></span><br><span class="line"><span class="comment"># [&#x27;Bauer&#x27; 30 90]</span></span><br><span class="line"><span class="comment"># head()=================</span></span><br><span class="line"><span class="comment"># Name    Bauer</span></span><br><span class="line"><span class="comment"># Age        30</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br><span class="line"><span class="comment"># tail()=================</span></span><br><span class="line"><span class="comment"># Age      30</span></span><br><span class="line"><span class="comment"># Score    90</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br></pre></td></tr></table></figure>
<h5 id="dataframe">3.3 DataFrame</h5>
<p>数据帧(DataFrame)是二维的表格型数据结构，即数据以行和列的表格方式排列，DataFrame是Series的容器。 <img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/DataFrame.png" width="400"> <strong>特点：</strong></p>
<ul>
<li>底层数据列是不同的类型</li>
<li>大小可变</li>
<li>标记轴(行和列)</li>
<li>可以对行和列执行算术运算</li>
</ul>
<h6 id="dataframe对象构造">3.3.1 DataFrame对象构造</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.DataFrame( data, index, columns, dtype, copy)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code>：构建DataFrame的数据，可以是ndarray，series，map，lists，dict，constant和其它DataFrame。</li>
<li><code>index</code>：行索引标签，如果没有传递索引值，索引默认为np.arrange(n)。</li>
<li><code>columns</code>：列索引标签，如果没有传递索列引值，默认列索引是np.arange(n)。</li>
<li><code>dtype</code>：每列的数据类型。</li>
<li><code>copy</code>：如果默认值为False，则此命令(或任何它)用于复制数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = &#123;<span class="string">&#x27;one&#x27;</span>: pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;two&#x27;</span>: pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;three&#x27;</span>: pd.Series([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])&#125;</span><br><span class="line">    df = pd.DataFrame(data, columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(df)</span><br><span class="line">    <span class="keyword">del</span>(df[<span class="string">&#x27;two&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#  one  two  three</span></span><br><span class="line"><span class="comment"># a  1.0    1   10.0</span></span><br><span class="line"><span class="comment"># b  2.0    2   20.0</span></span><br><span class="line"><span class="comment"># c  3.0    3   30.0</span></span><br><span class="line"><span class="comment"># d  NaN    4    NaN</span></span><br><span class="line"><span class="comment">#    one  three</span></span><br><span class="line"><span class="comment"># a  1.0   10.0</span></span><br><span class="line"><span class="comment"># b  2.0   20.0</span></span><br><span class="line"><span class="comment"># c  3.0   30.0</span></span><br><span class="line"><span class="comment"># d  NaN    NaN</span></span><br></pre></td></tr></table></figure>
<h6 id="dataframe属性">3.3.2 DataFrame属性</h6>
<ul>
<li><code>DataFrame.T</code>：转置行和列</li>
<li><code>DataFrame.axes</code>：返回一个列，行轴标签和列轴标签作为唯一的成员。</li>
<li><code>DataFrame.dtypes</code>：返回对象的数据类型</li>
<li><code>DataFrame.empty</code>：如果NDFrame完全为空，返回True</li>
<li><code>DataFrame.ndim</code>：返回轴/数组维度的大小</li>
<li><code>DataFrame.shape</code>：返回表示DataFrame维度的元组</li>
<li><code>DataFrame.size</code>：返回DataFrame的元素数</li>
<li><code>DataFrame.values</code>：将对象作为ndarray返回</li>
<li><code>DataFrame.head()</code>：返回前n行</li>
<li><code>DataFrame.tail()</code>：返回后n行</li>
</ul>
<h6 id="示例">3.3.3 示例</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个符合正态分布的10个股票5天的涨跌幅数据,0表示正态分布的中心点，1表示标准宽度，越大曲线越矮越胖，[10,5]数据shape</span></span><br><span class="line">stocks = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">10</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 使用pandas中的数据结构 DataFrame() 处理数据</span></span><br><span class="line">stocks_rise = pd.DataFrame(stocks)</span><br><span class="line"><span class="comment"># 设置行索引,获取行数 stocks_rise.shape[0] 进行遍历 列表生成式</span></span><br><span class="line">index_row = [<span class="string">&#x27;股票&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(stocks_rise.shape[<span class="number">0</span>])]</span><br><span class="line"><span class="comment"># 设置列索引，日期是一个时间序列，为了简便，使用pd.date_range()生成一组连续的时间序列</span></span><br><span class="line"><span class="comment"># pd.date_range(start,end,periods,freq) start:开始时间, end:结束时间</span></span><br><span class="line"><span class="comment"># periods:时间天数, freq:递进单位，默认1天，&#x27;B&#x27;默认略过周末</span></span><br><span class="line">index_col = pd.date_range(start=<span class="string">&#x27;20220201&#x27;</span>,periods=stocks_rise.shape[<span class="number">1</span>],freq=<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加索引，注意数据是ndarray数据 index表示行索引，columns表示列索引</span></span><br><span class="line">data = pd.DataFrame(stocks, index=index_row, columns=index_col)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">      <span class="number">2022</span>-02-01  <span class="number">2022</span>-02-02  <span class="number">2022</span>-02-03  <span class="number">2022</span>-02-04  <span class="number">2022</span>-02-07</span><br><span class="line">股票<span class="number">1</span>    -<span class="number">2.054041</span>   -<span class="number">1.170757</span>    <span class="number">0.162393</span>    <span class="number">0.253333</span>   -<span class="number">1.638837</span></span><br><span class="line">股票<span class="number">2</span>    -<span class="number">1.463734</span>    <span class="number">0.408459</span>    <span class="number">0.530070</span>   -<span class="number">0.925281</span>    <span class="number">1.454630</span></span><br><span class="line">股票<span class="number">3</span>    -<span class="number">0.511517</span>   -<span class="number">0.827591</span>   -<span class="number">2.076265</span>    <span class="number">0.139486</span>    <span class="number">0.658707</span></span><br><span class="line">股票<span class="number">4</span>    -<span class="number">1.698789</span>    <span class="number">0.250902</span>   -<span class="number">0.624713</span>    <span class="number">1.378845</span>   -<span class="number">1.672292</span></span><br><span class="line">股票<span class="number">5</span>     <span class="number">0.683233</span>   -<span class="number">1.083694</span>    <span class="number">0.810567</span>    <span class="number">0.421215</span>    <span class="number">1.375385</span></span><br><span class="line">股票<span class="number">6</span>    -<span class="number">0.296111</span>   -<span class="number">0.946959</span>    <span class="number">0.836536</span>   -<span class="number">1.179879</span>   -<span class="number">0.397406</span></span><br><span class="line">股票<span class="number">7</span>     <span class="number">0.017772</span>    <span class="number">0.180210</span>    <span class="number">2.022776</span>    <span class="number">0.436337</span>   -<span class="number">1.555866</span></span><br><span class="line">股票<span class="number">8</span>     <span class="number">0.638262</span>   -<span class="number">0.790932</span>    <span class="number">1.077822</span>   -<span class="number">1.746631</span>   -<span class="number">0.591360</span></span><br><span class="line">股票<span class="number">9</span>    -<span class="number">0.681391</span>   -<span class="number">0.613255</span>   -<span class="number">1.849094</span>    <span class="number">0.438304</span>   -<span class="number">0.503742</span></span><br><span class="line">股票<span class="number">10</span>   -<span class="number">0.243500</span>   -<span class="number">1.733623</span>   -<span class="number">1.137840</span>    <span class="number">0.124976</span>   -<span class="number">0.415727</span></span><br></pre></td></tr></table></figure>
<h5 id="panel">3.4 panel</h5>
<p>panel 是三维的数据结构，是DataFrame的容器，Panel的3个轴如下：</p>
<ul>
<li><code>items</code>：axis 0，每个项目对应于内部包含的数据帧(DataFrame)。</li>
<li><code>major_axis</code> ：axis 1，是每个数据帧(DataFrame)的索引(行)。</li>
<li><code>minor_axis</code>：axis 2，是每个数据帧(DataFrame)的列。</li>
</ul>
<h6 id="panel对象构造">3.4.1 Panel对象构造</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.Panel(data, items, major_axis, minor_axis, dtype, copy)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code>：构建Panel的数据，采取各种形式，如<code>ndarray，series，map，lists，dict，constant</code>和另一个数据帧<code>DataFrame</code>。</li>
<li><code>items</code>：axis=0</li>
<li><code>major_axis</code>：axis=1</li>
<li><code>minor_axis</code>：axis=2</li>
<li><code>dtype</code>：每列的数据类型</li>
<li><code>copy</code>：复制数据，默认 - false</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = np.random.rand(<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    p = pd.Panel(data, items=[<span class="string">&quot;item1&quot;</span>, <span class="string">&quot;item2&quot;</span>], major_axis=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], minor_axis=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(p)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;item1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(p[<span class="string">&quot;item1&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(p.major_xs(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(p.minor_xs(<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;pandas.core.panel.Panel&#x27;&gt;</span></span><br><span class="line"><span class="comment"># Dimensions: 2 (items) x 4 (major_axis) x 5 (minor_axis)</span></span><br><span class="line"><span class="comment"># Items axis: item1 to item2</span></span><br><span class="line"><span class="comment"># Major_axis axis: 1 to 4</span></span><br><span class="line"><span class="comment"># Minor_axis axis: a to e</span></span><br><span class="line"><span class="comment"># item1</span></span><br><span class="line"><span class="comment">#           a         b         c         d         e</span></span><br><span class="line"><span class="comment"># 1  0.185626  0.976123  0.566263  0.273208  0.675442</span></span><br><span class="line"><span class="comment"># 2  0.209664  0.205190  0.217200  0.158447  0.400683</span></span><br><span class="line"><span class="comment"># 3  0.499591  0.963321  0.759330  0.089930  0.362824</span></span><br><span class="line"><span class="comment"># 4  0.723158  0.585642  0.629246  0.886086  0.493039</span></span><br><span class="line"><span class="comment">#       item1     item2</span></span><br><span class="line"><span class="comment"># a  0.209664  0.592154</span></span><br><span class="line"><span class="comment"># b  0.205190  0.661562</span></span><br><span class="line"><span class="comment"># c  0.217200  0.743716</span></span><br><span class="line"><span class="comment"># d  0.158447  0.055882</span></span><br><span class="line"><span class="comment"># e  0.400683  0.245760</span></span><br><span class="line"><span class="comment">#       item1     item2</span></span><br><span class="line"><span class="comment"># 1  0.976123  0.630320</span></span><br><span class="line"><span class="comment"># 2  0.205190  0.661562</span></span><br><span class="line"><span class="comment"># 3  0.963321  0.741791</span></span><br><span class="line"><span class="comment"># 4  0.585642  0.729366</span></span><br></pre></td></tr></table></figure>
<h6 id="panel数据索引">3.4.2 Panel数据索引</h6>
<p>Panel右三个数据索引，因此可使用它们获取相应的结果，这里使用<code>Items</code>访问<code>Panel</code>可以获取相应的<code>DataFrame</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = &#123;<span class="string">&#x27;Table1&#x27;</span>: pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line">                                   index=[<span class="string">&#x27;rank1&#x27;</span>, <span class="string">&#x27;rank2&#x27;</span>, <span class="string">&#x27;rank3&#x27;</span>, <span class="string">&#x27;rank4&#x27;</span>],</span><br><span class="line">                                   columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Score&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;Table2&#x27;</span>: pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line">                                   index=[<span class="string">&#x27;rank1&#x27;</span>, <span class="string">&#x27;rank2&#x27;</span>, <span class="string">&#x27;rank3&#x27;</span>, <span class="string">&#x27;rank4&#x27;</span>],</span><br><span class="line">                                   columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Score&#x27;</span>]</span><br><span class="line">                                   )</span><br><span class="line">            &#125;</span><br><span class="line">    p = pd.Panel(data)</span><br><span class="line">    <span class="built_in">print</span>(p[<span class="string">&#x27;Table1&#x27;</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#            Name       Age     Score</span></span><br><span class="line"><span class="comment"># rank1 -1.240644 -0.820041  1.656150</span></span><br><span class="line"><span class="comment"># rank2  1.830655 -0.258068 -0.728560</span></span><br><span class="line"><span class="comment"># rank3  1.268695  1.259693 -1.005151</span></span><br><span class="line"><span class="comment"># rank4 -0.139876  0.611589  2.343394</span></span><br></pre></td></tr></table></figure></p>
<h6 id="panel属性">3.4.3 Panel属性</h6>
<ul>
<li><code>Panel.T</code>：转置行和列</li>
<li><code>Panel.axes</code>：返回一个列，行轴标签和列轴标签作为唯一的成员。</li>
<li><code>Panel.dtypes</code>：返回对象的数据类型</li>
<li><code>Panel.empty</code>：如果NDFrame完全为空，返回True</li>
<li><code>Panel.ndim</code>：返回轴/数组维度的大小</li>
<li><code>Panel.shape</code>：返回表示DataFrame维度的元组</li>
<li><code>Panel.size</code>：返回DataFrame的元素数</li>
<li><code>Panel.values</code>：将对象作为ndarray返回</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45698637/article/details/122766366">Pandas教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">python环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-17 14:02:12 / 修改时间：15:23:19" itemprop="dateCreated datePublished" datetime="2022-09-17T14:02:12+08:00">2022-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="使用anaconda">1. 使用Anaconda</h4>
<p>Anaconda，中文大蟒蛇，是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖.可通过<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Anaconda下载</a>。选择合适版本。</p>
<p><strong><em>注意</em></strong>：一个python环境应当只安装一个版本的tensorflow，如果还需要安装其他版本的tensorflow，应该再创建一个python环境</p>
<h5 id="anaconda创建指定python环境">1.1 anaconda创建指定python环境</h5>
<p>主要命令为配置自己环境<code>conda create -n 环境的名字 python=版本号</code></p>
<ul>
<li>步骤一：打开Anaconda powershell prompt。</li>
<li>步骤二：输入命令<code>conda create -n py36 anaconda=2020.02 python=3.6</code>，版本<code>python=3.x</code>自己指定。</li>
<li>步骤三：应用该环境<code>conda activate py36</code></li>
<li>下载的环境会在<code>D:\pythonDeve\Anaconda\envs\py36</code>处</li>
</ul>
<blockquote>
<p>退出该环境使用<code>conda deactivate py36</code> 显示当前所有已发现的环境：<code>conda info --envs</code></p>
</blockquote>
<h5 id="pycharm中导入该python版本编译环境">1.2pycharm中导入该python版本编译环境：</h5>
<ul>
<li>步骤一：打开pycharm，点击<code>File\settings\project:项目名</code> <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/one.png" width="500"></li>
<li>步骤二：选择上面提到的路径导入 <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/two.png" width="500"></li>
</ul>
<h5 id="配置python环境变量">1.3 配置python环境变量</h5>
<p>配置python环境变量是为了能在命令行窗口中能够找到该命令。一般建议配置，因为后续的许多安装都要用到<code>pip</code>和<code>conda</code>。 <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/three.png" width="500"></p>
<h5 id="安装指定版本tensorflow">1.4 安装指定版本tensorflow</h5>
<ul>
<li>查看当前可使用的tensorflow版本<code>conda search  --full tensorflow</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(py36) PS C:\Users\Trluper&gt; conda search  --full tensorflow</span><br><span class="line">&gt;&gt;</span><br><span class="line">Loading channels: done</span><br><span class="line"># Name                       Version           Build  Channel</span><br><span class="line">tensorflow                     <span class="number">1.7</span><span class="number">.0</span>               <span class="number">0</span>  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.7</span><span class="number">.1</span>               <span class="number">0</span>  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.8</span><span class="number">.0</span>               <span class="number">0</span>  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.8</span><span class="number">.0</span>      haa95532_0  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.9</span><span class="number">.0</span> eigen_py35hb0e21f4_1  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.9</span><span class="number">.0</span> eigen_py36h0b764b7_1  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.9</span><span class="number">.0</span> gpu_py35h0075c17_1  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.9</span><span class="number">.0</span> gpu_py36hfdee9c2_1  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> eigen_py35h38c8211_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> eigen_py36h849fbd8_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> gpu_py35ha5d5ef7_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> gpu_py36h3514669_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> mkl_py35h4a0f5c2_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> mkl_py36hb361250_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.11</span><span class="number">.0</span> eigen_py36h346fd36_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.11</span><span class="number">.0</span> gpu_py36h5dc63e2_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.11</span><span class="number">.0</span> mkl_py36h41bbc20_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.12</span><span class="number">.0</span> eigen_py36h67ac661_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.12</span><span class="number">.0</span> gpu_py36ha5f9131_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.12</span><span class="number">.0</span> mkl_py36h4f00353_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> eigen_py36hf0a88a9_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> eigen_py37h2a8d240_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> gpu_py36h1635174_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> gpu_py36h9006a92_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> gpu_py37h83e5d6a_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> gpu_py37hbc1a9d5_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> mkl_py36hd212fbe_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> mkl_py37h9463c59_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.14</span><span class="number">.0</span> eigen_py36hf4fd08c_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.14</span><span class="number">.0</span> eigen_py37hcf3f253_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.14</span><span class="number">.0</span> gpu_py36h305fd99_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.14</span><span class="number">.0</span> gpu_py36heb2afb7_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.14</span><span class="number">.0</span> gpu_py37h2fabf85_0  pkgs/main</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<ul>
<li>查看tensorflow包信息及依赖关系<code>conda  info  tensorflow</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(py36) PS C:\Users\Trluper&gt; conda  info  tensorflow</span><br><span class="line">tensorflow <span class="number">1.15</span><span class="number">.0</span> mkl_py36h997801b_0</span><br><span class="line">------------------------------------</span><br><span class="line">file name   : tensorflow<span class="number">-1.15</span><span class="number">.0</span>-mkl_py36h997801b_0.conda</span><br><span class="line">name        : tensorflow</span><br><span class="line">version     : <span class="number">1.15</span><span class="number">.0</span></span><br><span class="line">build string: mkl_py36h997801b_0</span><br><span class="line">build number: <span class="number">0</span></span><br><span class="line">channel     : https:<span class="comment">//repo.anaconda.com/pkgs/main/win-64</span></span><br><span class="line">size        : <span class="number">4</span> KB</span><br><span class="line">arch        : None</span><br><span class="line">constrains  : ()</span><br><span class="line">legacy_bz2_md5: ad6e18c8cdd17fe2bd396177ba904065</span><br><span class="line">legacy_bz2_size: <span class="number">3829</span></span><br><span class="line">license     : Apache <span class="number">2.0</span></span><br><span class="line">license_family: Apache</span><br><span class="line">md5         : aa94e7a35e3cf46219e5750ea5674fa0</span><br><span class="line">platform    : None</span><br><span class="line">sha256      : <span class="number">04b</span>f8a4c378f150163cbdfe1cf5d996c1251b9231acf2d723336668259a4e0e4</span><br><span class="line">subdir      : win<span class="number">-64</span></span><br><span class="line">timestamp   : <span class="number">1573235601611</span></span><br><span class="line">url         : https:<span class="comment">//repo.anaconda.com/pkgs/main/win-64/tensorflow-1.15.0-mkl_py36h997801b_0.conda</span></span><br><span class="line">dependencies:</span><br><span class="line">    _tflow_select <span class="number">2.3</span><span class="number">.0</span> mkl</span><br><span class="line">    python <span class="number">3.6</span>.*</span><br><span class="line">    tensorboard &gt;=<span class="number">1.15</span><span class="number">.0</span></span><br><span class="line">    tensorflow-base <span class="number">1.15</span><span class="number">.0</span> mkl_py36h190a33d_0</span><br><span class="line">    tensorflow-estimator &gt;=<span class="number">1.15</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>主要看<code>dependencies</code>，可以看到tensorflow对应的python版本</p>
<ul>
<li>安装指定版本tensorflow：<code>conda  install tensorflow-cpu=1.13</code>，其中<code>-cpu</code>指cpu版本，还有<code>-gpu</code>版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定清华源，但有一些会没有</span></span><br><span class="line">pip install -i  https:<span class="comment">//pypi.mirrors.ustc.edu.cn/simple  tensorflow-cpu==2.1.0</span></span><br><span class="line"><span class="comment">//国外源</span></span><br><span class="line">pip install tensorflow-cpu==<span class="number">2.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>激活tensorflow<code>conda activate tensorflow</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate tensorflow</span><br></pre></td></tr></table></figure>
<ul>
<li>查看该环境下安装的tensorflow：<code>conda list tensorflow</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(py36) PS C:\Users\Trluper&gt; conda list tensorflow</span><br><span class="line"><span class="meta"># packages in environment at D:\pythonDeve\Anaconda\envs\py36:</span></span><br><span class="line">#</span><br><span class="line"># Name                    Version                   Build  Channel</span><br><span class="line">tensorflow-cpu            <span class="number">2.1</span><span class="number">.0</span>                    pypi_0    pypi</span><br><span class="line">tensorflow-estimator      <span class="number">2.1</span><span class="number">.0</span>                    pypi_0    pypi</span><br></pre></td></tr></table></figure>
<h5 id="安装指定版本keras">1.5 安装指定版本keras</h5>
<ul>
<li>查询所有版本的keras</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(py36) PS C:\Users\Trluper&gt; conda info keras</span><br><span class="line">keras <span class="number">2.6</span><span class="number">.0</span> pyhd3eb1b0_0</span><br><span class="line">------------------------</span><br><span class="line">file name   : keras<span class="number">-2.6</span><span class="number">.0</span>-pyhd3eb1b0_0.conda</span><br><span class="line">name        : keras</span><br><span class="line">version     : <span class="number">2.6</span><span class="number">.0</span></span><br><span class="line">build string: pyhd3eb1b0_0</span><br><span class="line">build number: <span class="number">0</span></span><br><span class="line">channel     : https:<span class="comment">//repo.anaconda.com/pkgs/main/noarch</span></span><br><span class="line">size        : <span class="number">721</span> KB</span><br><span class="line">arch        : None</span><br><span class="line">constrains  : (<span class="string">&#x27;tensorflow 2.6.0&#x27;</span>,)</span><br><span class="line">legacy_bz2_md5: <span class="number">9</span>c47afd01ba08eeb2130cf9811c59918</span><br><span class="line">legacy_bz2_size: <span class="number">848011</span></span><br><span class="line">license     : MIT</span><br><span class="line">license_family: MIT</span><br><span class="line">md5         : <span class="number">4</span>aeef3bf046f7e1ed44efe59fb7d3e23</span><br><span class="line">noarch      : python</span><br><span class="line">package_type: noarch_python</span><br><span class="line">platform    : None</span><br><span class="line">sha256      : c0156c162ce479d5eafd468acb956b977b7b9ae9236494b698d5b4dab02cdd7d</span><br><span class="line">subdir      : noarch</span><br><span class="line">timestamp   : <span class="number">1643826831715</span></span><br><span class="line">url         : https:<span class="comment">//repo.anaconda.com/pkgs/main/noarch/keras-2.6.0-pyhd3eb1b0_0.conda</span></span><br><span class="line">dependencies:</span><br><span class="line">    python &gt;=<span class="number">3.6</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<ul>
<li>安装指定版本keras</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(py36) PS C:\Users\Trluper&gt; pip install keras==<span class="number">2.6</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<h4 id="错误总览">2. 错误总览</h4>
<h5 id="cannot-import-name-get_config">2.1 cannot import name 'get_config'</h5>
<ul>
<li><p>问题：导入语句<code>from keras.datasets import mnist</code>出现<code>ImportError: cannot import name ‘get_config’</code></p></li>
<li><p><code>解决方法</code>： <code>ImportError: cannot import name ‘get_config’</code> 这个类型报错的问题我遇到的都可以通过导入包时使用tensorflow.keras解决,如下：成功解决 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from tensorflow.keras.datasets <span class="keyword">import</span> mnist</span><br></pre></td></tr></table></figure></p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">深度学习核心算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-12 20:47:43" itemprop="dateCreated datePublished" datetime="2022-09-12T20:47:43+08:00">2022-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-17 15:25:36" itemprop="dateModified" datetime="2022-09-17T15:25:36+08:00">2022-09-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">深度学习算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="我的思考">0. 我的思考</h4>
<p>两个可供突破的大方向：</p>
<ul>
<li>是否能推动深度学习的训练数据规模减小？</li>
<li>怎么使得训练模型的结果更加精确。</li>
</ul>
<p>资源:</p>
<ul>
<li>kaggle机器学习竞赛</li>
</ul>
<h4 id="人工智能机器学习和深度学习">1. 人工智能、机器学习和深度学习</h4>
<p>人工智能、机器学习和深度学习三者的关系如下所示： <img src="/2022/09/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/relationship.png" wudth="500"></p>
<ul>
<li>机器学习：机器学习系统是训练出来的，而不是明确用代码编写出来的。人们通过输入数据和从这些数据中预期得到的答案，系统输出相应的规则。</li>
<li>深度学习：<strong>深度学习里面的&quot;深度&quot;不是指通过学习获得更深层次的理解，而是指通过一系列连续的表示层来获得更有效果的数据特征。一个深度学习模型有多少层就被称为模型的深度是多少</strong>。一般来说，现代深度学习通常包含数十个甚至上百个连续的表示层。<strong>这些层也被称为神经网络</strong> <img src="/2022/09/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/CNN.png" wudth="500"></li>
</ul>
<h4 id="深度学习的指标">2. 深度学习的指标</h4>
<p>在上面我们已经知道，深度学习是<strong>通过各层对输入数据不断提取特征</strong>，提取方式的具体操作就是<strong>每层都是对输入数据进行权重计算</strong>，其本质就是一串数字，</p>
<p>如下图所示，<span class="math display">\[$X_i\]</span><span class="math inline">\(是从图片拉伸出来的像素，它是不会变的，无法对其进行操作。而\)</span><span class="math display">\[W\]</span><span class="math inline">\(矩阵就是参数矩阵，\)</span><span class="math display">\[b\]</span>$是神经元偏置。<strong>因此对于深度学习，对于参数矩阵的选择是一项艰巨的任务，参数的好坏决定了输出结果的优劣</strong>。但是我们不能糊里糊涂的对参数进行更改，这样可能适得其反，<strong>必须借助某一个评估指标来更改，这就是接下来要介绍的损失函数</strong> <img src="/2022/09/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/pixels.png" wudth="500"></p>
<h5 id="损失函数">2.1 损失函数</h5>
<p><strong>损失函数</strong>：损失函数的任务，就是通过一定数学式子衡量出该深度学习的实际输出与预期标准值之间的距离。</p>
<p><strong>通过损失函数计算的损失值作为反馈信号来对参数矩阵中的权值进行微调，来降低对应的损失值</strong>。这种调节右优化器来完成，它实现了所谓的<strong>反向传播</strong>算法。 <img src="/2022/09/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/optimizer.png" wudth="300"></p>
<blockquote>
<p>一般来说，一开始神经网络的权值是随机赋值的，那么第一次的输出也就通常与预期值相差甚远，但随着权重值的不断微调，损失在也在降低，这就是为什么说学习模型是训练出来的。</p>
</blockquote>
<h5 id="softmax分类器">2.2 softmax分类器</h5>
<p>上面我们经过各层神经网络最终得到一个输入的得分值，但我们想一想如果结果给与我们一个概率不是更好，那么把得分值转化为概率就是<code>softmax</code>的作用。</p>
<p><code>softmax</code>分类器将各个得分值<strong>进行放大然后归一化后再计算概率</strong></p>
<h4 id="卷积神经网络">3. 卷积神经网络</h4>
<p>神经网络本质上就是将我们的输入信息转换为特征矩阵。<strong>卷积神经网络就是对同一个区域可以提取多个特征值，传统的神经网络一般只提取单个特征值，这样卷积更加全面稳实。</strong></p>
<p>卷积神经网络右输入层、隐含层、输出层组成：</p>
<ul>
<li><p>输入层：卷积神经网络的输入层可以处理多维数据，常见地，一维卷积神经网络的输入层接收一维或二维数组，其中一维数组通常为时间或频谱采样；二维数组可能包含多个通道；二维卷积神经网络的输入层接收二维或三维数组；三维卷积神经网络的输入层接收四维数组。由于使用<strong>梯度下降算法</strong>进行学习，卷积神经网络的输入特征需要进行标准化处理。具体地，在将学习数据输入卷积神经网络前，<strong>需在通道或时间/频率维对输入数据进行归一化</strong>，若输入数据为像素，也可将分布于的原始像素值归一化至<span class="math inline">\([0,1]\)</span>区间</p></li>
<li><p><strong>隐含层</strong>：隐含层包含卷积层、池化层和全连接层3类常见构筑。卷积层中的卷积核包含权重系数，而池化层不包含权重系数</p>
<ul>
<li><p><strong>卷积核</strong>：卷积层的功能是对输入数据进行特征提取，其内部包含多个<strong>卷积核</strong>，组成卷积核的每个元素都对应一个权重系数和一个偏差量（bias vector）。卷积核就是图像处理时，给定输入图像，输入图像中一个小区域中像素加权平均后成为输出图像中的每个对应像素，其中权值由一个函数定义，这个函数称为卷积核。</p></li>
<li><p><strong>激励函数</strong>：卷积层中包含激励函数以协助表达复杂特征，卷积神经网络通常使用线性整流函数<code>Rectified Linear Unit, ReLU</code>,它的作用就是对于上一层经过卷积后的数据经过<code>relu</code>的<code>max(0,x)</code>筛选</p></li>
<li><strong>池化层</strong>：在卷积层进行特征提取后，为避免特征量太多计算缓慢，对其进行特征值压缩，输出的特征图会被传递至池化层进行特征选择和信息过滤。池化层包含预设定的池化函数，其功能是将特征图中单个点的结果替换为其相邻区域的特征图统计量。</li>
<li><p><strong>全连接层</strong>：卷积神经网络中的卷积层和池化层能够对输入数据进行特征提取，<strong>全连接层的作用则是对提取的特征进行非线性组合以得到输出，即全连接层本身不被期望具有特征提取能力</strong>，而是试图利用现有的高阶特征完成学习目标 <img src="/2022/09/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/car.png" wudth="500"></p></li>
</ul></li>
</ul>
<h4 id="神经网络的数学基础">4. 神经网络的数学基础</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">计算机视觉课程笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-09 20:14:55" itemprop="dateCreated datePublished" datetime="2022-09-09T20:14:55+08:00">2022-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-12 22:37:58" itemprop="dateModified" datetime="2022-09-12T22:37:58+08:00">2022-09-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>222</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="深度学习cnn卷积神经网络算法精讲">1. 深度学习CNN卷积神经网络算法精讲</h4>
<h5 id="cnn与transformer的不同点">1.1 CNN与Transformer的不同点</h5>
<ul>
<li>要明白CNN就是对图像提取特征，提取不是一次性提取，而是多次，由局部向全局做特征。</li>
<li>Transformer则与CNN不同，直接全局考提取特征，这就避免了多次提取特征。</li>
</ul>
<h4 id="ai当下最火模块注意力机制解读">2. AI当下最火模块注意力机制解读</h4>
<h4 id="视觉领域transformer应用实例">3. 视觉领域transformer应用实例</h4>
<p>Transformer则与CNN不同，直接全局考提取特征，这就避免了多次提取特征。</p>
<h5 id="应用">3.1 应用</h5>
<h4 id="视觉当下最新研究方向与进展">4. 视觉当下最新研究方向与进展</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">研究生学习方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-08 10:38:18" itemprop="dateCreated datePublished" datetime="2022-09-08T10:38:18+08:00">2022-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-18 16:29:54" itemprop="dateModified" datetime="2022-09-18T16:29:54+08:00">2022-09-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>768</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="步骤">1. 步骤</h4>
<ul>
<li>阅读大量文献：需要阅读该方向的经典论文和最新论文文献</li>
<li>在阅读这些文献之后，需要自己提出一个具体的研究问题。</li>
<li>制定详细的研究计划</li>
<li>论文的写作和投稿</li>
</ul>
<h4 id="论文检索与下载">2. 论文检索与下载</h4>
<p>正如前面所说的，阅读文献的选择应该是在你确定了一个大的研究方向之后，选择经典和最新的文献进行阅读其摘要是否与自己领域相关，相关都建议下载阅读，所谓经典和最新是指：</p>
<ul>
<li>经典（重要）：高被引用的文献</li>
<li>最新（重要）：你所研究方向进一两年的最新成果，在此基础上提出你的具有创新性的研究小方向</li>
<li>其他相关文献</li>
</ul>
<h5 id="文献检索方法">2.1 文献检索方法</h5>
<ul>
<li>中文文献：中国知网、百度学术</li>
<li>外文文献：谷歌学术</li>
</ul>
<p>在查询后找到相应的DIO，渠道sci-hub进行下载。</p>
<h4 id="论文文献阅读与管理">3. 论文文献阅读与管理</h4>
<h5 id="文献阅读的大致顺序">3.1 文献阅读的大致顺序</h5>
<p><code>经典文献-&gt;最新文献-&gt;相关文献。</code></p>
<ul>
<li>经典文献：帮助你了解你研究领域的基本情况</li>
<li>最新文献：帮助你快速了解研究领域的最新进展，对提出研究方向、研究方案和思路已经是否具有创新性的重要一环。</li>
<li>相关文献：学习相关与研究领域知识，提供灵感和创造性</li>
</ul>
<h5 id="如何进行阅读">3.2 如何进行阅读</h5>
<ul>
<li>经典文献和最新文献应该持续以恒的进行全篇阅读</li>
</ul>
<p>不要用软件大段翻译，最好是划词翻译，长久来看比较有好处</p>
<ul>
<li>（1）文献阅读前首先要确定好自己的研究方向，将研究方向中的关键点找出来，这样在阅读文献前就弄清楚自己想要了解的内容是哪个方面的。<br>
</li>
<li>（2）在阅读某篇具体文献时，先看标题和摘要，了解文章大致内容，同时确定该篇文献中和自己研究方向相关的部分，作为阅读重点</li>
<li>（3）作为一个求知者，最重要的是一个新的看待问题的视角或者说一个新的思考问题的思路，很多问题没有一个明确的答案，我们需要在学习他人研究成果的同时，加强自己对问题的思考能力</li>
</ul>
<h5 id="文献管理">3.3 文献管理</h5>
<p>使用ENDNOTE对文献进行分类管理，记录每个文献主要讲了什么，有什么创新点和对自己的启发，同时讲不同的文献进行分组，方便后续的查看。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">git使用教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-07 10:10:47 / 修改时间：15:21:59" itemprop="dateCreated datePublished" datetime="2022-09-07T10:10:47+08:00">2022-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="git是什么">1. Git是什么</h4>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git原来是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<h5 id="git-与-svn-区别">1.1 Git 与 SVN 区别</h5>
<p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。</p>
<p><code>Git</code>与<code>SVN</code>区别点：</p>
<ul>
<li><p>1、<code>Git</code>是分布式的，<code>SVN</code>不是：这是<code>Git</code>和其它非分布式的版本控制系统，</p></li>
<li><p>2、<code>Git</code>把内容按元数据方式存储，而<code>SVN</code>是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 <code>.svn、.cvs</code>等的文件夹里。</p></li>
<li><p>3、<code>Git</code>分支和<code>SVN</code>的分支不同：分支在 <code>SVN</code>中一点都不特别，其实它就是版本库中的另外一个目录。</p></li>
<li><p>4、<code>Git</code>没有一个全局的版本号，而<code>SVN</code>有：目前为止这是跟<code>SVN</code>相比<code>Git</code>缺少的最大的一个特征。</p></li>
<li><p>5、<code>Git</code>的内容完整性要优于<code>SVN</code>：<code>Git</code>的内容存储使用的是<code>SHA-1</code>哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Git.png" width="500"></p></li>
</ul>
<h4 id="git安装">2. Git安装</h4>
<h5 id="linux下的git">2.1 Linux下的Git</h5>
<p>Git 的工作需要调用<code>curl，zlib，openssl，expat，libiconv</code>等库的代码，所以需要先安装这些依赖工具。 在有<code>yum</code>的系统上centOS或者有<code>apt-get</code>的系统上（比如 Debian 体系），可以用下面的命令安装：</p>
<h6 id="ubuntu安装">2.1.1 ubuntu安装</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \</span><br><span class="line">  libz-dev libssl-dev</span><br><span class="line"></span><br><span class="line">$ apt-get install git</span><br><span class="line"></span><br><span class="line">$ git --version</span><br><span class="line">git version <span class="number">1.8</span><span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
<h6 id="centos安装">2.1.2 centOS安装</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel \</span><br><span class="line">  openssl-devel zlib-devel</span><br><span class="line"></span><br><span class="line">$ yum -y install git-core</span><br><span class="line"></span><br><span class="line">$ git --version</span><br><span class="line">git version <span class="number">1.7</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<h5 id="windows下的git">2.2 windows下的Git</h5>
<p>在 Windows平台上安装 Git同样轻松,找到<a target="_blank" rel="noopener" href="https://gitforwindows.org/">官网下载链接</a>，点击下一步直接安装即可。</p>
<h5 id="git配置">2.3 Git配置</h5>
<p>Git 提供了一个叫做<code>git config</code>的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ul>
<li><code>/etc/gitconfig</code>文件：系统中对所有用户都普遍适用的配置。若使用<code>git config</code>时用 <code>--system</code>选项，读写的就是这个文件。</li>
<li><code>~/.gitconfig</code>文件：用户目录下的配置文件只适用于该用户。若使用<code>git config</code>时用 <code>--global</code>选项，读写的就是这个文件。</li>
<li>当前项目的<code>Git</code>目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code>里的配置会覆盖 <code>/etc/gitconfig</code>中的同名变量。</li>
</ul>
<p>在 Windows 系统上，Git 会找寻用户主目录下的 <code>.gitconfig</code>文件。主目录即 $HOME 变量指定的目录，一般都是 <code>C:\Documents and Settings\$USER。</code></p>
<p>此外，Git 还会尝试找寻 <code>/etc/gitconfig</code>文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<h6 id="用户信息">2.3.1 用户信息</h6>
<p>为了方便后续Git能跟踪到谁做了修改，我们需要设置对应的用户名与邮箱地址。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;wuwenjie&quot;</span></span><br><span class="line">$ git config --global user.email <span class="number">1229413537</span>@qq.com</span><br><span class="line"></span><br><span class="line">$ git config --list</span><br><span class="line">diff.astextplain.textconv=astextplain</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=<span class="literal">true</span></span><br><span class="line">http.sslbackend=openssl</span><br><span class="line">http.sslcainfo=D:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt</span><br><span class="line">core.autocrlf=<span class="literal">true</span></span><br><span class="line">core.fscache=<span class="literal">true</span></span><br><span class="line">core.symlinks=<span class="literal">false</span></span><br><span class="line">pull.rebase=<span class="literal">false</span></span><br><span class="line">credential.helper=manager-core</span><br><span class="line">credential.https:<span class="comment">//dev.azure.com.usehttppath=true</span></span><br><span class="line">init.defaultbranch=master</span><br><span class="line">user.email=<span class="number">1229413537</span>@qq.com</span><br><span class="line">user.name=wuwenjie</span><br></pre></td></tr></table></figure></p>
<h4 id="git工作流程">3. git工作流程</h4>
<p>git一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/git-process.png" width="500"></li>
</ul>
<h4 id="git三个区和三个状态">4. git三个区和三个状态</h4>
<p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p>
<ul>
<li><strong>工作区</strong>：就是你在电脑里能看到的目录。</li>
<li><strong>暂存区</strong>：英文叫<code>stage</code>或<code>index</code>。一般存放在<code>.git</code>目录下的<code>index</code>文件（<code>.git/index</code>）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><p><strong>版本库</strong>：工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 <code>Git</code> 的版本库。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Three.png" width="500"></p></li>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为 <code>index</code>的区域是暂存区<code>stage/index</code>，标记为 <code>master</code>的是<code>master</code>分支所代表的目录树。</li>
<li>图中我们可以看出此时<code>HEAD</code>实际是指向<code>master</code>分支的一个<code>游标</code>。所以图示的命令中出现<code>HEAD</code>的地方可以用<code>master</code>来替换。</li>
<li>图中的<code>objects</code>标识的区域为<code>Git</code>的对象库，实际位于<code>.git/objects</code>目录下，里面包含了创建的各种对象及内容。</li>
<li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li>
<li>当执行提交操作<code>git commit</code>时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 <code>master</code>指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，被 <code>master</code>分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 <code>git rm --cached &lt;file&gt;</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行 <code>git checkout</code> . 或者 <code>git checkout -- &lt;file&gt;</code>命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li>
<li><p>当执行 <code>git checkout HEAD</code> . 或者 <code>git checkout HEAD &lt;file&gt;</code>命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li>
</ul>
<h4 id="git创建仓库">5. Git创建仓库</h4>
<p>可以使用一个已经存在的目录作为<code>Git</code>仓库。<code>Git</code>使用<code>git init</code>命令来初始化一个<code>Git</code>仓库，<code>Git</code>的很多命令都需要在<code>Git</code>的仓库中运行，所以<code>git init</code>是使用<code>Git</code>的第一个命令。</p>
<p>在执行完成<code>git init</code>命令后，<code>Git</code> 仓库会生成一个<code>.git</code>目录，该目录包含了资源的所有元数据，其他的项目目录保持不变</p>
<ul>
<li><p><strong>当前目录即为仓库</strong>：使用当前目录作为 Git 仓库，我们只需使它初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure> 该命令执行完后会在当前目录生成一个 .git 目录。</p></li>
<li><p><strong>使用我们指定目录作为Git仓库。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure> 初始化后，会在<code>newrepo</code>目录下会出现一个名为 <code>.git</code>的目录，所有<code>Git</code>需要的数据和资源都存放在这个目录中。</p></li>
</ul>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用<code>git add</code>命令告诉<code>Git</code>开始对这些文件进行跟踪，然后提交： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下命令将目录下以 .c 结尾及 README 文件提交到仓库中。</span></span><br><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">&#x27;初始化项目版本&#x27;</span></span><br></pre></td></tr></table></figure> &gt; 注： 在 Linux 系统中，commit 信息使用单引号 <code>'</code>，Windows 系统，commit 信息使用双引号<code>&quot;</code>。 &gt;所以在 git bash 中<code>git commit -m '提交说明'</code>这样是可以的，在 Windows 命令行中就要使用双引号 &gt;<code>git commit -m &quot;提交说明&quot;</code>。</p>
<h4 id="git的基本操作">6. Git的基本操作</h4>
<p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。Git 常用的是以下 6 个命令：<code>git clone、git push、git add 、git commit、git checkout、git pull</code>，后面我们会详细介绍。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/git-command.png" width="500"></p>
<ul>
<li><code>workspace</code>：工作区</li>
<li><code>staging area</code>：暂存区/缓存区</li>
<li><code>local repository</code>：版本库或本地仓库</li>
<li><code>remote repository</code>：远程仓库</li>
</ul>
<h5 id="git-clone">6.1 git clone</h5>
<p>我们使用<code>git clone</code>从现有<code>Git</code>仓库中拷贝项目（类似<code>svn checkout</code>）.克隆仓库的命令格式为：<code>git clone &lt;repo&gt;</code>。</p>
<p>要克隆<code>Ruby</code>语言的<code>Git</code>代码仓库<code>Grit</code>，可以用下面的命令： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git:<span class="comment">//github.com/schacon/grit.git</span></span><br></pre></td></tr></table></figure></p>
<h5 id="提交与修改">6.2 提交与修改</h5>
<p>下表列出了有关创建与提交你的项目的快照的命令：</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>git add</code></td>
<td>添加文件到暂存区</td>
</tr>
<tr class="even">
<td><code>git status</code></td>
<td>查看仓库当前的状态，显示有变更的文件。</td>
</tr>
<tr class="odd">
<td><code>git diff</code></td>
<td>比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr class="even">
<td><code>git commit</code></td>
<td>提交暂存区到本地仓库。</td>
</tr>
<tr class="odd">
<td><code>git reset</code></td>
<td>回退版本。</td>
</tr>
<tr class="even">
<td><code>git rm</code></td>
<td>将文件从暂存区和工作区中删除。</td>
</tr>
<tr class="odd">
<td><code>git mv</code></td>
<td>移动或重命名工作区文件。</td>
</tr>
</tbody>
</table>
<h5 id="提交日志">6.3 提交日志</h5>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>git log</code></td>
<td>查看历史提交记录</td>
</tr>
<tr class="even">
<td><code>git blame &lt;file&gt;</code></td>
<td>以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody>
</table>
<h5 id="远程操作">6.4 远程操作</h5>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>git remote</code></td>
<td>远程仓库操作</td>
</tr>
<tr class="even">
<td><code>git fetch</code></td>
<td>从远程获取代码库</td>
</tr>
<tr class="odd">
<td><code>git pull</code></td>
<td>下载远程代码并合并</td>
</tr>
<tr class="even">
<td><code>git push</code></td>
<td>上传远程代码并合并</td>
</tr>
</tbody>
</table>
<h4 id="git的分支管理">7. Git的分支管理</h4>
<p>几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。<code>Git</code>分支实际上是指向更改快照的指针。有人把<code>Git</code>的分支模型称为必杀技特性，而正是因为它，将<code>Git</code>从版本控制系统家族里区分出来。</p>
<h5 id="git-branch创建分支">7.1 git branch创建分支</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">git <span class="title">branch</span> <span class="params">(branchname)</span></span></span><br></pre></td></tr></table></figure>
<p>没有参数时，<code>git branch</code>会列出你在本地的分支。当你执行<code>git init</code>的时候，默认情况下<code>Git</code>就会为你创建<code>master</code>主分支。如果我们要手动创建一个分支。执行<code>git branch (branchname)</code>即可。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure></p>
<h5 id="git-checkout切换分支">7.2 git checkout切换分支</h5>
<p>用<code>git checkout (branch)</code>切换到我们要修改的分支 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ echo <span class="string">&#x27;runoob.com&#x27;</span> &gt; test.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&#x27;add test.txt&#x27;</span></span><br><span class="line">[master <span class="number">3e92</span>c19] add test.txt</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> <span class="built_in">insertion</span>(+)</span><br><span class="line"> create mode <span class="number">100644</span> test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git checkout testing</span><br><span class="line">Switched to branch <span class="string">&#x27;testing&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure> 当我们切换到<code>testing</code>分支的时候，我们添加的新文件 <code>test.txt</code>被移除了。切换回<code>master</code>分支的时候，它们又重新出现了。</p>
<p>我们也可以使用<code>git checkout -b (branchname)</code> 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b newtest</span><br><span class="line">Switched to a <span class="keyword">new</span> branch <span class="string">&#x27;newtest&#x27;</span></span><br><span class="line">$ git rm test.txt </span><br><span class="line">rm <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ touch runoob.php</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -am <span class="string">&#x27;removed test.txt、add runoob.php&#x27;</span></span><br><span class="line">[newtest c1501a2] removed test.txt、add runoob.php</span><br><span class="line"> <span class="number">2</span> files changed, <span class="number">1</span> <span class="built_in">deletion</span>(-)</span><br><span class="line"> create mode <span class="number">100644</span> runoob.php</span><br><span class="line"> <span class="keyword">delete</span> mode <span class="number">100644</span> test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        runoob.php</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure>
<p>如你所见，我们创建了一个分支，在该分支上移除了一些文件<code>test.txt</code>，并添加了<code>runoob.php</code>文件，然后切换回我们的主分支，删除的<code>test.txt</code>文件又回来了，且新增加的<code>runoob.php</code>不存在主分支中。</p>
<p>这样就将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p>
<h5 id="合并分支">7.4 合并分支</h5>
<p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：<code>git merge</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  newtest</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git merge newtest</span><br><span class="line">Updating <span class="number">3e92</span>c19..c1501a2</span><br><span class="line">Fast-forward</span><br><span class="line"> runoob.php | <span class="number">0</span></span><br><span class="line"> test.txt   | <span class="number">1</span> -</span><br><span class="line"> <span class="number">2</span> files changed, <span class="number">1</span> <span class="built_in">deletion</span>(-)</span><br><span class="line"> create mode <span class="number">100644</span> runoob.php</span><br><span class="line"> <span class="keyword">delete</span> mode <span class="number">100644</span> test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        runoob.php</span><br></pre></td></tr></table></figure> 以上实例中我们将<code>newtest</code>分支合并到主分支去，那么<code>test.txt</code>文件被删除,<code>runoob.php</code>被添加到主分支</p>
<h5 id="删除分支">7.5 删除分支</h5>
<p>删除分支只需加个<code>-d</code>即可：<code>git branch -d (branchname)</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br><span class="line">$ git branch -<span class="function">d testing</span></span><br><span class="line"><span class="function">Deleted branch <span class="title">testing</span> <span class="params">(was <span class="number">85f</span>c7e7)</span>.</span></span><br><span class="line"><span class="function">$ git branch</span></span><br><span class="line"><span class="function">* master</span></span><br></pre></td></tr></table></figure></p>
<p>文章来源：<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-workflow.html">菜鸟教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/07/VScode%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/07/VScode%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">VScode教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-07 09:46:11 / 修改时间：11:19:39" itemprop="dateCreated datePublished" datetime="2022-09-07T09:46:11+08:00">2022-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VScode/" itemprop="url" rel="index"><span itemprop="name">VScode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="为什么使用vscode">1. 为什么使用VScode</h4>
<p>VScode是微软推出一个轻量化编辑器，只需要下载相应的编译器和包即可支持C/C++、java、python的编写。相对于VS来说，VScode更加的轻便、体积小，支持许多插件。</p>
<h4 id="vscode的界面使用">2. VScode的界面使用</h4>
<p><img src="/2022/09/07/VScode%E6%95%99%E7%A8%8B/someClick.png" width="600"></p>
<h5 id="用户设置">2.1 用户设置</h5>
<p><code>文件File--首选项preferences--设置settings</code>，打开用户设置。VScode支持选择配置，也支持编辑<code>setting.json</code>文件修改默认配置 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）editor.fontsize用来设置字体大小，可以设置editor.fontsize : <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）files.autoSave这个属性是表示文件是否进行自动保存，推荐设置为onFocusChange——文件焦点变化时自动保存。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）editor.tabCompletion用来在出现推荐值时，按下Tab键是否自动填入最佳推荐值，推荐设置为on;</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）editor.codeActionsOnSave中的source.organizeImports属性，这个属性能够在保存时，自动调整 <span class="keyword">import</span> 语句相关顺序，能够让你的 <span class="keyword">import</span> 语句按照字母顺序进行排列，推荐设置为<span class="literal">true</span>,即<span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123; <span class="string">&quot;source.organizeImports&quot;</span>: <span class="literal">true</span> &#125;；</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）editor.lineNumbers设置代码行号,即editor.lineNumbers ：<span class="literal">true</span>；</span><br></pre></td></tr></table></figure></p>
<h4 id="常用快捷键">3. 常用快捷键</h4>
<p>高效的使用vscode,记住一些常用的快捷键是必不可少的，这里罗列了一些常用的快捷键。 ##### 3.1 主命令</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+P</code></td>
<td>俗称万能键，可以输入任何命令</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+P</code></td>
<td>根据名称查找文件</td>
</tr>
</tbody>
</table>
<h5 id="编辑器与窗口管理">3.2 编辑器与窗口管理</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+N</code></td>
<td><strong>新建文件</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+N</code></td>
<td><strong>打开一个新的VSCode编辑器</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+O</code></td>
<td><strong>打开文件</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+O</code></td>
<td>打开文件夹</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+W</code></td>
<td>关闭当前文件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+W 或 Alt+F4</code></td>
<td>关闭当前VSCode编辑器</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+\</code></td>
<td>新建窗口显示代码（相当于复制当前代码到一个新的窗口；同一引用，修改一个文件，其他相同文件会一起改变）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Alt+→</code></td>
<td>移动当前文件到右窗口，若没有右窗口，则创建一个新窗口</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Alt+←</code></td>
<td>移动当前文件到左窗口</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Tab</code></td>
<td><strong>切换文件窗口</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+B</code></td>
<td>显示/隐藏侧边栏</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl +/-</code></td>
<td>放大/缩小编辑器窗口</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+E</code></td>
<td>文件资源管理器（Explorer）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+G</code></td>
<td>git管理窗口（Source Control）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+X</code></td>
<td>扩展（插件）管理窗口（Extentions）</td>
</tr>
</tbody>
</table>
<h5 id="代码文本快捷键">3.3 代码文本快捷键</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+F</code></td>
<td><strong>查找</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+H</code></td>
<td><strong>查找替换</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+F</code></td>
<td>全局查找</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+H</code></td>
<td>全局查找替换</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+D</code></td>
<td>选中下一个匹配项</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+L</code></td>
<td>选中所有匹配项（秀儿）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+[</code></td>
<td>向左缩进</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+]</code></td>
<td>向右缩进</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Alt+Up</code></td>
<td><strong>向上移动当前行</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Alt+Down</code></td>
<td>向下移动当前行</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Shift+Alt+Up</code></td>
<td><strong>向上复制当前行</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Shift+Alt+Down</code></td>
<td>向下复制当前行</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Enter</code></td>
<td><strong>在当前行下方插入空行（光标位置可以不在行尾）</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+Enter</code></td>
<td>在当前行上方插入空行（光标位置可以不在行尾）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Alt+Z</code></td>
<td>切换内容是否自动换行（底部显示/隐藏滚动条</td>
</tr>
</tbody>
</table>
<p>如果在编程中忘记了快捷键，也可以使用<code>Ctrl+K/Ctrl+S</code>来查看VSCode中全部快捷键。</p>
<h4 id="插件安装">4. 插件安装</h4>
<p>在输入框中输入想要安装的插件名称，点击安装即可，推荐安装的插件有： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、Bracket Pair Colorizer：给嵌套的各种括号加上不同的颜色。</span><br><span class="line"><span class="number">2</span>、Path Intellisense：智能路径提示，可以在你输入文件路径时智能提示。</span><br><span class="line"><span class="number">3</span>、Markdown Preview：实时预览 markdown。</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-07 21:34:12" itemprop="dateCreated datePublished" datetime="2022-08-07T21:34:12+08:00">2022-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 09:47:06" itemprop="dateModified" datetime="2022-08-22T09:47:06+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="get请求和post请求的区别">1. get请求和post请求的区别</h4>
<p><strong>在实际应用中，get和post请求的区别主要有以下几个：</strong></p>
<ul>
<li><strong><code>get</code>请求用于从服务器上获得资源，而<code>post</code>请求用于向服务器提交数据</strong></li>
<li><code>get</code>将表单中的数据按照<code>key=value</code>的形式，添加到<code>action</code>指定的<code>URL</code>后面，并且两者之间使用<code>?</code>连接，各个变量之间使用&amp;连接；post是将表单的数据放在HTTP协议的请求头或者消息体中，传递到action所指向的URL</li>
<li><strong><code>get</code>传输的数据要受到URL长度的限制（最大长度是2048个字符）；而<code>post</code>可以传输大量数据，上传文件通常使用post</strong></li>
<li><strong>使用<code>get</code>时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用<code>get</code>，对于敏感数据应使用<code>post</code></strong></li>
<li><code>get</code>使用<code>MIME</code>类型<code>application/x-www-form-urlencoded</code>的URL编码（也叫百分号编码）文本格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是<code>%20</code></li>
<li><strong><code>get</code>请求参数会被完整保留在浏览器历史记录里，而<code>post</code>中的参数不会被保留。</strong></li>
</ul>
<p><strong>但是在本质上，get和post请求没有区别：</strong></p>
<p><code>get</code>和<code>post</code>是HTTP协议中的两种发送请求的方法，而HTTP是基于<code>TCP/IP</code>的关于数据如何在万维网中如何通信的协议。因此，<code>get</code>和<code>post</code>的底层也是<code>TCP/IP</code>,也就是说，<code>get</code>和<code>post</code>都是TCP链接。</p>
<p><strong>此外，get和post还有一个重要的区别：</strong></p>
<p><code>get</code>产生一个<code>TCP</code>数据包；<code>POST</code>产生两个TCP数据包。对于<code>get</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应200（返回数据）；而对于<code>post</code>，浏览器先发送<code>header</code>，服务器响应<code>100 continue</code>，浏览器再发送<code>data</code>，服务器响应<code>200 ok</code>（返回数据）。</p>
<h4 id="tcp和udp的区别">2. TCP和UDP的区别</h4>
<ul>
<li><strong>连接性：</strong>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。UDP无连接。</li>
<li><strong>服务对象</strong>：TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；UDP支持一对一，一对多，多对一，多对多的交互通信。</li>
<li><strong>可靠性</strong>：TCP是有保证数据安全可靠的措施，可靠交付：无差错，不丢失，不重复，按序到达。UDP是尽最大努力交付，不保证可靠交付。</li>
<li><strong>拥塞控制和流量控制</strong>：TCP有拥塞控制和流量控制保证数据传输的安全性。UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li>
<li><strong>报文长度</strong>：TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li>
<li><strong>首部开销</strong>：TCP首部开销大，首部20个字节。UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</li>
<li><strong>TCP和UDP适用场景</strong>：从特点上我们已经知道，TCP是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</li>
</ul>
<p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP.png" width="600"></p>
<h4 id="tcp三次握手">3. TCP三次握手</h4>
<ul>
<li>只有<code>SYN</code>位置1表示连接请求。</li>
<li>只有<code>ACK</code>置1表示<code>ACK</code>报文段，携带数据时会消耗序号<code>seq</code>，不携带则不消耗</li>
<li><code>ACK</code>和<code>SYN</code>都置1，不能携带数据，但消耗1个序号<code>seq</code> <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/threeAndFour.png" width="600"></li>
</ul>
<h5 id="三次握手">3.1 三次握手</h5>
<ul>
<li>1、Client将标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，并将该数据包发送给Server，Client进入<code>SYN_SENT</code>状态，等待Server确认。</li>
<li>2、Server收到数据包后由标志位<code>SYN=1</code>知道Client请求建立连接，Server将标志位<code>SYN</code>和<code>ACK</code>都置为1，<code>ack=J+1</code>，随机产生一个值<code>seq=K</code>，并将该数据包发送给Client以确认连接请求，Server进入<code>SYN_RCVD</code>状态。</li>
<li>3、Client收到确认后，检查<code>ack</code>是否为J+1，ACK若为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给Server，Server检查<code>ack</code>是否为K+1，<code>ACK</code>为1，如果正确则连接建立成功，Client和Server进入<code>ESTABLISHED</code>状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<h5 id="三次握手的原因">3.2 三次握手的原因</h5>
<ul>
<li>①建立连接，</li>
<li>②第三次要回ACK的原因：如果没有第三次回ACK，会导致已经失效的连接请求报文突然又传输到服务器端，又建立客户端与服务器的连接，但客户端又不发送数据，此时导致的服务器资源浪费。 所谓已经失效的连接请求是指客户端发出的连接请求滞留在网络中，超时后但又被服务器接收到。</li>
</ul>
<h5 id="思考connect为什么会阻塞即第三次ack丢失下客户端怎么办">3.3 思考：connect为什么会阻塞（即第三次ACK丢失下客户端怎么办）</h5>
<p><strong>server端：</strong></p>
<blockquote>
<p>第三次的ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。 而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为&gt;5.如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。</p>
</blockquote>
<p><strong>client端</strong>：</p>
<blockquote>
<p>在linux c 中，client 一般是通过<code>connect()</code>函数来连接服务器的，而<code>connect()</code>是在TCP的三次握手的第二次握手完成后就成功返回值。也就是说client在接收到 SYN+ACK包，它的TCP连接状态就为established （已连接），表示该连接已经建立。 那么如果第三次握手中的ACK包丢失的情况下，Client 向<code>server</code>端发送数据，Server端将以<code>reset</code>包响应，方能感知到Server的错误。</p>
</blockquote>
<h4 id="tcp四次挥手">4. TCP四次挥手</h4>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个<code>FIN</code>来终止这一方向的连接，收到一个<code>FIN</code> 只是意味着这一方向上没有数据流动了，即不会再发送到数据了，但是在这个TCP连接上仍然能够收数据，直到另一方也发送了<code>FIN</code>。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<h5 id="四次挥手过程">4.1 四次挥手过程</h5>
<ul>
<li>1.数据传输结束后，客户端的应用进程发出连接释放<code>FIN</code>报文段，并停止发送数据，客户端进入<code>FIN_WAIT_1</code>状态，此时客户端依然可以接收服务器发送来的数据。</li>
<li>2.服务器接收到<code>FIN</code>后，发送一个<code>ACK</code>给客户端，确认序号为收到的序号<code>+1</code>，服务器进入<code>CLOSE_WAIT</code>状态。客户端收到后进入<code>FIN_WAIT_2</code>状态。</li>
<li>3.当服务器没有数据要发送时，服务器也发送一个<code>FIN</code>报文，此时服务器进入<code>LAST_ACK</code>状态，等待客户端的确认</li>
<li>4.客户端收到服务器的<code>FIN</code>报文后，给服务器发送一个<code>ACK</code>报文，确认序列号为收到的序号<code>+1</code>。此时客户端进入<code>TIME_WAIT</code>状态，等待<code>2MSL</code>（MSL：报文段最大生存时间），然后关闭连接。</li>
</ul>
<p>应用层可以使用系统调用函数read函数==0来判断对端是否关闭连接。</p>
<h5 id="为什么要等待2msl才关闭链接">4.2 为什么要等待2MSL才关闭链接</h5>
<ul>
<li>①为保证客户端发送的最后一个ACK报文段能够到达服务器。若第4次挥手的报文段丢失了，服务器就会超时重传第3次挥手的报文段。</li>
<li>②经过2MSL时间，可以使本次连接持续时间内所以产生的报文段(主要针对滞留在网络中的）都失效，这样就可避免已失效的本次链接请求影响下一次链接请求。</li>
</ul>
<h5 id="为什么要4次挥手">4.3 为什么要4次挥手</h5>
<p>因为主动关闭的一方是已经确定没有数据要发送了，而被动关闭的一方还未<code>FIN</code>报文，先回一个<code>ACK</code>确认报文，其在<code>FIN</code>发生前可能还要发送数据，只有等待数据发生完，才能回一个<code>FIN</code>报文，主动关闭方再回一个<code>ACK</code>确认,才能达到双向关闭，</p>
<h4 id="tcp机的状态转移">5. TCP机的状态转移</h4>
<p><img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/statusSwitch.png" width="600"> [^上半部分为3次握手，下半部分为4次挥手，实线表示主动，虚线为被动，细线为特殊情况]</p>
<p><strong>状态解释：</strong></p>
<ul>
<li><code>CLOSED</code>：表示初始状态。</li>
<li><code>LISTEN</code>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li>
<li><code>SYN_SENT</code>：这个状态与<code>SYN_RCVD</code>遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。<code>SYN_SENT</code>状态表示客户端已发送SYN报文。</li>
<li><code>SYN_RCVD</code>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</li>
<li><p><code>ESTABLISHED</code>：表示连接已经建立。</p></li>
<li><strong><code>FIN_WAIT_1</code>: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文</strong>。区别是：
<ul>
<li><code>FIN_WAIT_1</code>状态是当socket在<code>ESTABLISHED</code>状态时，想主动关闭连接，向对方发送了<code>FIN</code>报文，此时该socket进入到FIN_WAIT_1状态。</li>
<li><code>FIN_WAIT_2</code>状态是当对方回应<code>ACK</code>后，该socket进入到<code>FIN_WAIT_2</code>状态，正常情况下，对方应马上回应<code>ACK</code>报文，所以<code>FIN_WAIT_1</code>状态一般较难见到，而<code>FIN_WAIT_2</code>状态可用netstat看到。</li>
</ul></li>
<li><p><code>FIN_WAIT_2</code>：<strong>主动关闭链接的一方，发出<code>FIN</code>收到<code>ACK</code>以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发，既socket上还有数据流动。</strong></p></li>
<li><p><code>TIME_WAIT</code>: <strong>表示收到了对方的<code>FIN</code>报文，并发送出了<code>ACK</code>报文，等2MSL后即可回到CLOSED可用状态。如果<code>FIN_WAIT_1</code>状态下，收到对方同时带<code>FIN</code>标志和<code>ACK</code>标志的报文时，可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code>状态。</strong></p></li>
<li><p><code>CLOSING</code>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p></li>
<li><code>CLOSE_WAIT</code>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。（服务器）</li>
<li><p><code>LAST_ACK</code>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。（服务器）</p></li>
</ul>
<h4 id="tcp的拥塞控制对整个网络">6. TCP的拥塞控制：对整个网络</h4>
<p>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。<strong>流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口<code>cwnd</code>。</strong></p>
<ul>
<li><p><strong>慢开始</strong>：最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免<code>cwnd</code>增长过大。</p></li>
<li><p><strong>拥塞避免</strong>：每经过一个往返时间<code>RTT</code>，<code>cwnd</code>只增长1。在慢开始和拥塞避免的过程中，一旦发现网络拥塞（超时），就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）</p></li>
<li><p><strong>快重传</strong>：接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。</p></li>
<li><p><strong>快恢复</strong>：当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），并将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/controlOfcrowd.png" width="600"></p></li>
</ul>
<h4 id="tcp的可靠性保证">7. TCP的可靠性保证</h4>
<p>TCP主要提供了<strong>检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制</strong>等方法实现了可靠性传输。</p>
<ul>
<li><p><strong>检验和</strong>：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部</p></li>
<li><p>最大长度：在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</p></li>
<li><p><strong>滑动窗口：</strong>我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。这就提出了一个滑动窗口的概念:不必等等确认，发送端直接发送数据，在连续收到三个重复确认应答时，重新发生要求的序列号包 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/resend.png" width="600"></p></li>
</ul>
<h4 id="tcp的滑动窗口">8. TCP的滑动窗口</h4>
<p>端对端的流量控制,也解决包乱序问题（数据包格式有SequenceNumber，是数据包的序号seq,ACK——用于确认收到，用来解决不丢包的问题)。每一次读取数据之后,回ack报文,报文中会携带当前缓冲区大小,用来告知对方发送的数据不能超过我接收的缓冲区大小。</p>
<h4 id="tcp黏包问题">9. TCP黏包问题</h4>
<p><strong>原因：</strong> TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p>
<p><strong>解决：</strong></p>
<ul>
<li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li>
<li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li>
<li>在数据包之间设置边界，如添加特殊符号 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 ，则会误判为消息的边界。</li>
</ul>
<h4 id="简述域名解析过程本机如何干预域名解析">10. 简述域名解析过程，本机如何干预域名解析</h4>
<ul>
<li><p>1）在浏览器中输入<code>www.qq.com</code>域名，操作系统会先检查自己本地的<code>hosts</code>文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p></li>
<li><p>2）如果<code>hosts</code>里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p></li>
<li><p>3）如果<code>hosts</code>与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p></li>
<li><p>4）如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p></li>
<li><p>5）如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名<code>.com</code>是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责<code>.com</code>域的这台服务器。这台负责<code>.com</code>域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址<code>qq.com</code>给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找<code>qq.com</code>域服务器，重复上面的动作，进行查询，直至找到<code>www.qq.com</code>主机。</p></li>
<li><p>6）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></li>
</ul>
<p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>
<h4 id="section">10.</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/" class="post-title-link" itemprop="url">高性能MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-04 21:34:03" itemprop="dateCreated datePublished" datetime="2022-08-04T21:34:03+08:00">2022-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-07 21:12:18" itemprop="dateModified" datetime="2022-08-07T21:12:18+08:00">2022-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="mysql的架构">1. MySQL的架构</h4>
<p>MySQL最重要最与众不同的就是它的存储引擎架构，这种架构设计将查询处理(<code>QUERY PROCESSING</code>)及其他系统任务和数据存储/提取相分离。在这里主要介绍MySQL的服务器架构、各种存储引擎之间的区别。</p>
<h5 id="逻辑架构">1.1 逻辑架构</h5>
<p>MySQL各组件协同工作的示意图如下：</p>
<ul>
<li>最上层的客户端不是MySQL独有的，像许多C/S结构都具有。</li>
<li>第二层架构是大多数MySQL的核心服务功能所在的一层，如查询解析、分析、优化、缓存和所有的内置函数，所有跨存储引擎的功能也在这一层实现：存储过程、视图、触发器等。</li>
<li>第三层包含了存储引擎，存储引擎负责MySQL中数据的存储和提取 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/Fram.png" width="400"></li>
</ul>
<h6 id="连接管理与安全性">1.1.1 连接管理与安全性</h6>
<p>每个客户端连接到MySQL服务器进程有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU时间片中执行语句。服务器会负责缓存管理线程，因此不需要为每一个新建的连接创建或者销毁线程。</p>
<p>当有来自于客户端的连接请求时，服务器会对连接信息进行认证，认证基于用户名、密码和主机信息进行。</p>
<h6 id="优化与执行">1.1.2 优化与执行</h6>
<p><strong>进行解析的过程：</strong></p>
<ul>
<li>MySQL会解析查询，并创建内部数据结构（解析树），<strong>然后对其进行各种优化：包括重写查询、决定表的读取顺序以及选择合适的索引等。</strong></li>
<li>用户可以通过特殊的关键字提示优化器来影响它的优化决策过程，也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器时如何进行优化决策的。</li>
<li>优化器不关心表使用哪种存储引擎，但存储引擎对优化查询是有影响的，因为优化器会请求存储引擎提供容量或某个具体操作的开销。</li>
</ul>
<p><strong>当然不要忘了还有查询缓存：</strong></p>
<p>对于select语句，在解析查询之前，服务器会先检查查询缓存，如果能在查询缓存中找到对应查询，服务器就不必执行解析器、优化和执行的整个过程，直接返回查询缓存中的结果集即可。</p>
<h5 id="并发控制">1.2 并发控制</h5>
<p>在MySQL当中是在两个面讨论的并发控制：服务器层和存储引擎层。在并发场景下，如果不对并发进行控制，则会导致数据的损坏无效，一般来说我们都是用锁<code>lock</code>来对其进行控制。在MySQL中的锁有共享锁(<code>shared lock</code>)、排他锁(<code>exclusive lock</code>)，也叫读锁(<code>read lock</code>)和写锁(<code>write lock</code>)</p>
<h4 id="锁">2. 锁</h4>
<p>锁这个知识点比较繁杂，下图是对锁的各个概念范围进行分类： <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/Lockrecord.png" width="700"></p>
<h5 id="锁类型兼容性">2.1 锁类型（兼容性）</h5>
<p>对于读取内容来说一般不会发生什么问题，因为本线程没有对数据进行修改，<strong>但是试想一下你正在对读的使用，另一个人正在对数据进行写入，这时候问题就来了，你读的数据会是确定呢吗?答案肯定是不确定的</strong>，因此对于读操作也要注意。而写操作就更不用说了，每一次的写入都会改变数据，必定加入排斥锁。在MySQL中读锁即为共享锁，写锁即为排斥锁。</p>
<ul>
<li><p><strong>共享锁（读锁）</strong>：读锁是共享的，或者说是不阻塞的，多个线程可以在同一时刻可以同时读取同一个资源而互不干扰，但是当有一个线程试图写时，是不被允许的，即读锁不阻塞其他的读操作，但是阻塞写操作。</p></li>
<li><p><strong>排斥锁（写锁）</strong>：写锁是排他的，一个写锁会阻塞其他的写锁和读锁。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享锁</span></span><br><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line"><span class="comment">//排他锁（X)</span></span><br><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></table></figure>
<h5 id="锁的粒度">2.2 锁的粒度</h5>
<p><strong>为提供共享资源并发性就是让锁的对象更具有选择性，即尽量只锁定需要修改的部分数据，而不是所有的资源，任何时候，在给定资源锁的粒度越小精度越高，则系统的并发程度越高。但是我们不能无限制的只加最小粒度的锁，因为锁也需要消耗资源的，如锁的各种操作、包括获得锁、检查锁是否解除、释放锁都会增加系统开销</strong>，因此对锁选择策略是在锁的开销和数据安全性之间寻找平衡折中。</p>
<h6 id="表级锁">2.2.1 表级锁</h6>
<p>表级锁是对整个表加锁的一种操作。MyISAM和InnoDB引擎都支持表级锁，</p>
<ul>
<li><strong>优点：</strong>是MySQL中锁定粒度最大的一种锁，实现简单，资源消耗也比较少，加锁快，只对一个表操作不会出现死锁。</li>
<li><strong>缺点</strong>：其锁定粒度最大，触发锁冲突的概率最高，并发度最低。</li>
</ul>
<p>表锁的语法是<code>lock tables … read/write</code>。可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。<code>lock tables</code>语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#为表t1上读锁，t2上写锁</span><br><span class="line">lock tables t1 read,t2 wirte;</span><br><span class="line">#释放锁</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line">mysql&gt; lock tables employee read;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; insert into employee <span class="title">values</span><span class="params">(<span class="string">&#x27;crf&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="number">15000</span>,now(),<span class="number">300</span>)</span></span>;</span><br><span class="line">ERROR <span class="number">1099</span> (HY000): Table <span class="string">&#x27;employee&#x27;</span> was locked with a READ lock <span class="keyword">and</span> can<span class="number">&#x27;</span>t be updated</span><br></pre></td></tr></table></figure></p>
<h6 id="行级锁">2.2.2 行级锁</h6>
<p>行级锁是MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁，在MySQL中MyISAM不支持行锁，InnoDB支持。<strong>记住行级锁只能对是有索引字段进行加锁从而锁住改行。</strong></p>
<ul>
<li><strong>优点：</strong>行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，</li>
<li><strong>缺点：</strong>因为粒度小，因此加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将退化使用的是表锁</strong>。</p>
<p><strong>其他注意事项：</strong></p>
<ul>
<li><p>在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁。</p></li>
<li><p>如果MySQL的行锁是针对范围索引加的锁，不是针对记录加的锁，所以即使是访问不同行的记录，如果使用了相同的索引键，也是会出现锁冲突的，这是因为间隙锁的原因（接下来会讲）</p></li>
<li><p>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</p></li>
<li><p>即便在条件中使用了索引字段，但具体是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p></li>
</ul>
<p><strong>隐式默认加锁</strong>：</p>
<ul>
<li>InnoDB自动加意向锁。</li>
<li>对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，<code>InnoDB</code>会自动给涉及数据集加排他锁<code>（X)</code>；</li>
<li>对于普通<code>SELECT</code>语句，InnoDB不会加任何锁；</li>
</ul>
<p><strong>显示加锁</strong>：</p>
<ul>
<li><strong>共享锁（S）</strong>：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code></li>
<li><strong>排他锁（X)</strong> ：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code></li>
</ul>
<p><strong><em>注意</em></strong>：正如上面所说的，行锁是根据索引上的索引项加锁实现的，即上面的对于的列必须有加索引才能是为行级锁，否则为表级锁，如下开两个客户端连接MySQL,因为不是索引，所以为表锁 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#客户端<span class="number">1</span>：不是索引，粒度为表锁，类型为排他锁</span><br><span class="line">mysql&gt; select id,<span class="function">job_name from employee_job where id <span class="title">in</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span> <span class="keyword">for</span> update</span>;</span><br><span class="line">+----+--------------+</span><br><span class="line">| id | job_name     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">2</span>  | 老板         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">#客户端2：</span></span><br><span class="line"><span class="function">mysql&gt; select id,job_name from employee_job where id <span class="title">in</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">ERROR <span class="number">1100</span> (HY000): Table <span class="string">&#x27;employee_job&#x27;</span> was <span class="keyword">not</span> locked with LOCK TABLES</span><br></pre></td></tr></table></figure></p>
<h6 id="页级锁">2.2.3 页级锁</h6>
<p>页级锁的粒度介于行级锁和表级锁中间的一种锁。它比表级锁速度快，比表级锁的冲突多，比行级锁的冲突少，但速度慢。因此页级是一种折中锁，一次锁定相邻的一组记录。BDB 支持页级锁。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p>
<p><strong><em>注意：行级锁不一定比表级锁要好，锁的粒度越细，代价越高，相比表级锁在表的头部直接加锁，行级锁还要扫描找到对应的行对其上锁，这样的代价其实是比较高的，所以表锁和行锁各有所长。</em></strong></p>
<h6 id="全局锁">2.2.4 全局锁</h6>
<p>MySQL提供了一个加全局读锁的方法，命令是<code>Flush tables with read lock</code>,当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#对所有数据库实例加读锁</span><br><span class="line">Flush tables with read lock</span><br><span class="line">#对所有数据库实例加写锁</span><br><span class="line">Flush tables with write lock</span><br></pre></td></tr></table></figure></p>
<h5 id="死锁">2.3 死锁</h5>
<p>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，</p>
<h6 id="引起死锁的原因">2.3.1 引起死锁的原因</h6>
<ul>
<li>①竞争不可抢占资源引起死锁（不可抢占是指没有使用完的资源，不能被抢占）</li>
<li>②竞争可消耗资源引起死锁</li>
<li>③线程推进顺序不当引起死锁</li>
</ul>
<p>情况1：有线程<code>p1</code>，<code>p2</code>，都需要资源<code>A</code>，<code>B</code>，本来可以<code>p1运行A</code> --&gt; <code>p1运行B</code> --&gt; <code>p2运行A</code> --&gt; <code>p2运行B</code>，但是顺序换了，<code>p1</code>运行<code>A</code>时<code>p2</code>运行<code>B</code>，容易发生第一种死锁。互相抢占资源对放持有的资源。</p>
<p>情况2：有<code>p1，p2，p3</code>三个线程，<code>p1</code>向<code>p2</code>发送消息并接受<code>p3</code>发送的消息，<code>p2</code>向<code>p3</code>发送消息并接受<code>p1</code>的消息，<code>p3</code>向<code>p1</code>发送消息并接受<code>p2</code>的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成死锁。</p>
<h6 id="产生死锁的必要条件">2.3.2 产生死锁的必要条件</h6>
<ul>
<li><p><strong>互斥条件</strong>：某资源只能被一个进程使用，其他进程请求该资源时，只能等待，直到资源使用完毕后释放资源。</p></li>
<li><p><strong>请求和保持条件</strong>：程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。</p></li>
<li><p><strong>不可抢占条件</strong>：进程已获得的资源没有使用完，不能被抢占。</p></li>
<li><p><strong>循环等待条件</strong>：必然存在一个循环链。</p></li>
</ul>
<h6 id="解决死锁的方式">2.3.3 解决死锁的方式</h6>
<p>在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在</p>
<ul>
<li><strong>预防死锁：</strong>在设计时，对锁的使用进行预防，以确保业务不会发生死锁，通过破坏死锁产生的后三个必要条件：即破坏请求持、不可抢占、循环等待条件之一来预防死锁。
<ul>
<li><strong>破坏请求和保持条件</strong>：所有线程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生。</li>
<li><strong>破坏不可抢占条件</strong>：当一个已经保持了某种不可抢占资源的线程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请</li>
<li><strong>破坏循环等待条件</strong>：对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</li>
</ul></li>
<li><p><strong>解除死锁：</strong>产生死锁时，能够从死锁中解脱处理，比如一种策略超时退出。在MySQL中这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置，默认为<code>50s</code>.</p></li>
<li><p><strong>检查死锁：</strong>在MySQL种有这样的机制，线程发现死锁后，会主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。可将参数<code>innodb_deadlock_detect</code>设置为<code>on</code>，表示开启这个逻辑。但是它有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，消耗大。</p></li>
<li><p><strong>一种特殊情况：</strong>在<code>REPEATABLE-READ</code>隔离级别下，如果两个线程同时对相同条件记录用<code>SELECT…FOR UPDATE</code>加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成<code>READ COMMITTED</code>，就可避免问题。</p></li>
</ul>
<h5 id="三种行级锁模式原理">2.4 三种行级锁模式（原理）</h5>
<h6 id="记录锁">2.4.1 记录锁</h6>
<p><strong>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，粒度是行级锁，类型是排他锁</strong>。一般记录锁出现在<code>select、update</code>语句，比如下面这句，它会在<code>id=1</code>的记录上加上记录锁，以阻止其他事务插入，更新，删除和更新<code>id=1</code>这一行。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id 列必须为主键列或唯一索引列</span></span><br><span class="line">SELECT * FROM test WHERE id=<span class="number">1</span> FOR UPDATE;</span><br><span class="line">UPDATE SET age = <span class="number">50</span> WHERE id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure> <strong>记录锁的条件：</strong></p>
<ul>
<li><code>id</code> 列必须为唯一索引列或主键列(主键索引)，否则上述语句加的锁就会变成临键锁(有关临键锁下面会讲)。</li>
<li>同时查询语句的条件子句必须为精准匹配即为<code>=</code>，不能为<code>&gt;、&lt;、like</code>等，否则也会退化成间隙锁或者临键锁</li>
</ul>
<p><strong><em>注意：如果要锁的列没有索引，进行全表记录加锁（行级锁的性质）</em></strong></p>
<h6 id="间隙锁">2.4.2 间隙锁</h6>
<p><strong>间隙锁<code>Gap Lock</code>是指在InnoDB存储引擎中锁可以加在不存在的空闲空间的一种锁</strong>。它能在两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。<strong>间隙锁是一种行级锁，是 InnoDB在 RR(可重复读) 隔离级别下为了解决幻读问题时引入的锁机制。</strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</p>
<p><strong>产生间隙锁的条件：</strong></p>
<ul>
<li>使用普通索引锁定，或者使用多列唯一索引，或者使用唯一索引锁定多行记录。</li>
<li>条件子句不为精确匹配，为范围</li>
</ul>
<p><strong>可能光说不好理解，看例子：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建test表，id为主键索引</span></span><br><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` <span class="built_in">int</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="built_in">varchar</span>(<span class="number">8</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">INSERT INTO `test` <span class="built_in">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;小罗&#x27;</span>),(<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;小黄&#x27;</span>),(<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>),(<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>);</span><br></pre></td></tr></table></figure> 上面的插入语句完成后，<code>test</code>表中存在的隐藏间隙如下： <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/gaplock.png" width="600"> 即有范围：<code>(-∞, 1]、(1, 5]、(5, 7]、(7, 11]、(11, +∞]</code>，那么当我使用下面语句的时候就会触发间隙锁 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM `test` WHERE `id` BETWEEN <span class="number">5</span> AND <span class="number">7</span> FOR UPDATE;</span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;小张1&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">9</span>, <span class="string">&#x27;大东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">11</span>, <span class="string">&#x27;李西&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务8插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">12</span>, <span class="string">&#x27;张三&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure> 从上面我们可以看到，<code>(5, 7]、(7, 11]</code>这两个区间被事务1锁住，在此期间的其他事务的插入操作失败，而其它区间，都可以正常插入数据。所以我们可以得出结论：当我们给 <code>(5, 7]</code>这个区间加锁的时候，会锁住 <code>(5, 7]、(7, 11]</code>这两个区间。</p>
<p><strong>间隙锁的缺点</strong>:</p>
<ul>
<li>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。虽然解决了幻读，但在某些场景下这可能会对性能造成很大的危害</li>
<li>当Query无法利用索引的时候， Innodb会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；</li>
</ul>
<p><strong>间隙锁的作用：</strong></p>
<ul>
<li>解决可重复读隔离级别下的幻读</li>
<li>为了数据恢复和复制的需要。</li>
</ul>
<p><strong><em>注意：可重复读级别下才会有间隙锁！还有如果对不存的记录操作即使使用<code>=</code>也会产生间隙锁，如<code>select id,name from test where id=3 for update;</code>,id=3是不存在的记录</em></strong></p>
<h6 id="临键锁next-key-locks">2.4.3 临键锁（Next-Key Locks）</h6>
<p><strong><code>Next-key locks</code>是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。</strong></p>
<p>也可以理解为一种特殊的间隙锁，因此临建锁肯定也可以解决幻读的问题。 <strong>每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据</strong>。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，<strong>而临键锁只与非唯一索引列有关，在唯一索引列（包括主键索引）上不存在临键锁。</strong>即临键锁是对非唯一索引而言的。</p>
<p>假设有如下表：InnoDB，RR隔离级别，<code>id</code>主键, <code>age</code>普通索引 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/nextkeylocks.png" width="600"> 则有<code>age</code>范围:<code>(-∞, 10],(10, 24],(24, 32],(32, 45],(45, +∞]</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/事务A执行下述语句</span><br><span class="line">-- 根据非唯一索引列 UPDATE 某条记录 </span><br><span class="line">UPDATE table SET name = Vladimir WHERE age = <span class="number">24</span>; </span><br><span class="line">-- 或根据非唯一索引列 锁住某条记录 </span><br><span class="line">SELECT * FROM table WHERE age = <span class="number">24</span> FOR UPDATE;</span><br><span class="line"><span class="comment">//事务B执行下述语句</span></span><br><span class="line"><span class="function">INSERT INTO table <span class="title">VALUES</span><span class="params">(<span class="number">100</span>, <span class="number">26</span>, <span class="string">&#x27;tianqi&#x27;</span>)</span></span>; </span><br></pre></td></tr></table></figure> 上面因为<code>age=26</code>恰好在<code>(24,32]范围内</code>,age为非唯一索引，使用临检索模式的行级锁，则不管事务A执行那个语句，事务B的插入语句总会阻塞。</p>
<p><strong>总结：</strong></p>
<ul>
<li><strong>InnoDB 中的行锁的实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁。</strong></li>
<li><strong>记录锁</strong>存在于包括主键索引在内的唯一索引中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于非唯一索引中，锁定开区间范围内的一段间隔，它是基于临键锁实现的。</li>
<li><strong>临键锁</strong>存在于非唯一索引中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的间隙锁，锁定一段左开右闭的索引区间。</li>
</ul>
<h5 id="意向锁">2.5 意向锁</h5>
<p>意向锁又分为<strong>意向共享锁（IS）</strong>和 <strong>意向排他锁（IX）</strong>。在介绍意向锁的意义之前，必须明白下面四点：</p>
<ul>
<li>意向共享锁（IS）和 意向排他锁（IX）都是<strong>表锁</strong>。</li>
<li><strong>意向锁是一种不与行级锁冲突的表级锁，这一点非常重要。它只会与非意向的表锁冲突</strong></li>
<li><strong>意向锁与意向锁之间永远是兼容的</strong></li>
<li>意向锁是<code>InnoDB</code>自动加的， 不需用户干预。当兵对表或对行加排他锁时，就会获得意向排他锁；加共享锁时，会获得意向共享锁。</li>
<li>意向锁是在<code>InnoDB</code>下存在的内部锁，对于<code>MyISAM</code>而言 没有意向锁之说。</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">兼容性</th>
<th style="text-align: center;">表IS</th>
<th style="text-align: center;">表IX</th>
<th style="text-align: center;">表s</th>
<th style="text-align: center;">表x</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>表IS</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>表IX</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>表S</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>表X</strong></td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
</tbody>
</table>
<p><strong>意向锁的存在目的是为了让InnoDB中的行锁和表锁能够更高效的共存</strong>。假设有下表，InnoDB，RR隔离级别 <code>id</code>是主键 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/ilock.png" width="500"></p>
<p>加入现在有事务<code>A</code>，进行了一条<code>SELECT * FROM users WHERE id = 6 FOR UPDATE;</code>但未提交，那么事务<code>A</code>会获得<code>id=6</code>的行级锁，且为记录排他锁，同时还有自动生成一个意向排他锁。</p>
<p>这时候有个事务<code>B</code>,进行操作<code>LOCK TABLES users READ;</code>会失败，因为对于要表锁来说，必须要保证：</p>
<ul>
<li>当前没有其他事务持有<code>users</code>表的排他锁。</li>
<li>当前没有其他事务持有<code>users</code>表中任意一行的排他锁 。</li>
</ul>
<p>但是现在<code>users</code>表的排他锁已经被事务<code>A</code>持有了，事务B的这个想获取表共享锁的操作会失败。</p>
<p>上面的例子是有意向锁的情况，试想一下没有意向锁和表锁情况会这样：事务B会去检查<code>user</code>表中的每一行查看是否有排他锁，如果有则无法执行，无则会执行。很明显这样的效率极低，但有意向锁后，只需检查意向表锁即可。</p>
<h4 id="事务">3. 事务</h4>
<p>事务就是由一批SQL语句组成，可以说它是一个独立的工作单元。<strong>事务处理可以用来维护数据的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行，事务处理是一种机制，利用事务处理可以保证成批的MySQL操作不会只执行一部分，如果全部执行那没问题，如果在执行过程中发生错误，它就会进行回退以恢复到数据库以前安全版本</strong>。MySQL中InnoDB支持事务，MyISAM不支持。</p>
<h5 id="事务的acid">3.1 事务的ACID</h5>
<p>一个运行良好的事务处理系统，必须具备四大特性：原子性(<code>atomicity</code>)、一致性(<code>consistency</code>)、隔离性(<code>isolation</code>)和持久性(<code>durability</code>)。实现了ACID的数据库相比于未实现的数据库，其通常需要更强的CPU处理能力，更大的内存和磁盘空间。因此要酌情堪虑是否选用事务型存储引擎。</p>
<ul>
<li><strong>原子性</strong>：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的操作要么全部提交成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>：数据库总是从一个一致性状态转移达到另一个一致性状态，一致性状态就是由事务原子性保障，一个事务提交了，那是ok的，一个事务未提交，那也是OK的。</li>
<li><strong>隔离性</strong>：通常来说，一个事务所做的修改在未提交以前，对其他事务是不可见的。事务间是互不干扰的。</li>
<li><strong>持久性</strong>：一旦事务提交了，其所做的修改会永久保存到数据库总中，即使系统崩溃，修改的数据也不会丢失，（持久性不能做到100%保证策略，如果数据库本身就能做到吃性，那么要备份又有什么用呢）</li>
</ul>
<h5 id="隔离级别">3.2 隔离级别</h5>
<p>在SQL标准中定义了四种隔离级别，<strong>每一种级别都规定了一个事务所做的修改，在哪些事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也低</strong></p>
<ul>
<li><p><strong>未提交读(<code>read uncommitted</code>)</strong>：在该隔离级别，事务中的修改，即使没有提交，对其他事务也都是可见的。<strong>事务可以读取未提交的数据，这也被称为脏读</strong>。这个级别会导致喝多问题，从性能上来说，该级别没有比其他级别好很多，一般不推荐使用。</p></li>
<li><strong>提交读(<code>read committed</code>)：在该级别，一个事务开始时只能看见已经提交的事务的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，因此也可称为</strong>不可重复的**。这个隔离级别时大多数数据库默认的隔离级别。</li>
<li><strong>可重复读(<code>repeatable read</code>)</strong>：在该级别，保证了同一个事务多次读取同样的记录的结果是一致的。可重复读是MySQ的默认隔离级别，解决了脏读的问题，但是对于幻读无法解决。<strong>所谓的幻读就是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围插入新的记录，当之前的事务再次读取该范围记录时，产生幻行。</strong>InooDB引擎使用多版本控制MVCC解决幻读问题。</li>
<li><p><strong>可串行化(<code>serializable1</code>)</strong>：该隔离级别时最高的隔离级别，它通过强制事务串行执行，避免了前面说的幻读问题。简单来说，就是在读取每一行数据都加锁，所有会导致大量的超时和锁争问题。</p></li>
</ul>
<h5 id="事务日志">3.3 事务日志</h5>
<p>首先必须明白InnoDB存储引擎是以页为单位来管理存储空间的，真正访问页面之前，需要把在磁盘上的页缓存到内存中的缓存池之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘（checkpoint机制），通过缓存池来优化cpu和磁盘之间的鸿沟。事务的原子性、一致性和持久性由事务的<code>redo日志</code>和<code>undo日志</code>来保证。</p>
<ul>
<li><p><strong><code>REDO LOG</code>称为重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</strong><code>redo</code>日志的存在使得我们再对表进行修改时会把这些修改写进日志里，然后再写入磁盘，只有日志写入成功，才算事务的提交完成，<strong>这样即使数据库发生宕机未刷新到磁盘，也可以通过<code>redo</code>日志恢复。</strong></p></li>
<li><p><strong><code>UNDO LOG</code>称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性</strong>。有的DBA或许会认为<code>UNDO</code>是<code>REDO</code>的逆过程，其实不然。<code>undo log</code>是存储引擎(<code>innodb</code>)生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了<code>insert</code>语句操作，那么<code>undo log</code>就记录一条与之相反的delete操作，主要用于事务回滚（<code>undo log</code>记录的是每个修改操作的逆操作）和一致性非锁定定读（<code>undo log</code>回滚行记录到某种特定的版本,mvcc，多版本并发控制）。 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/log.png" width="600"></p></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zuodaoyong/article/details/123454426">MySQL事务日志详解</a></p>
<h4 id="多版本并发控制mvcc">4. 多版本并发控制MVCC</h4>
<p><strong>在MySQL你可以认为MVCC是行级锁的一种变种，为适应并提升并发性能，大多数情况下避免了加锁操作，因此开销更低，也解决了MySQL默认隔离级别可重复读下的幻读问题</strong>。MVCC旨在<code>repeatable read</code>和<code>read committed</code>下工作。</p>
<p><strong>MVCC的实现，是通过保存数据在某个时间点（说是时间点是未了更好理解，其实是事务的系统版本号）的快照来实现的。在InnoDB的MVCC中，通过在每行记录后面保存两个隐藏的列来实现，这两个列一个是保存了行的创建时间，一个保存了行的过期时间，当然存储的不是实际的时间值，而是系统版本号，系统版本号会根据没新开一个事务而自动递增</strong>。有了这两个列之后，对于<code>select\update\delete\insert</code>则必须遵循下面的规则：</p>
<ul>
<li><strong><code>select</code></strong>：对于select，InnoDB会根据一下规则来检索
<ul>
<li><ol type="a">
<li><strong>InnoDB只查找版本号早于当前事务版本号的数据行，这样确保了事务读取的行，要么在事务开始之前就已经存在，要么是当前事务自己插入或者修改的，绝不可能是该事务之后的事务进行修改的，这样解决了幻读的问题。</strong></li>
</ol></li>
<li><ol start="2" type="a">
<li><strong>行的删除版本要么未定义，要么就是大于当前事务的版本号，这就可以确保事务读取到的行，在该十五i开始前还未删除。如果之前就删除了那么删除版本号肯定有值而读取不了。</strong></li>
</ol></li>
</ul></li>
<li><p><strong><code>INSERT</code></strong>：InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p></li>
<li><p><strong><code>DELETE</code></strong>：InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p></li>
<li><p><strong><code>UPDATE</code></strong>：InnoDB为插入一行新记录，保存当前事务系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p></li>
</ul>
<p><strong><em>注意：MVCC并不能彻底解决并发带来的安全问题，它只是起到一个缓解并发冲突量的作用，如果两个事务有明显的次序要求，如事务A，B是希望A修改该行后再交由B修改，那么就必须人为事务A所在的行加锁，这样才能保证B是再A修改后才修改的</em></strong>，因此该用锁的时候还是要用，否则有MVCC就能解决这些的话，还要锁干嘛</p>
<h4 id="mysql的存储引擎">5. MySQL的存储引擎</h4>
<p>数据库存储引擎是极其重要的，这是因为：</p>
<ul>
<li>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。</li>
<li>不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL的核心就是存储引擎。</li>
<li>用户可以根据不同的需求为数据表选择不同的存储引擎(表类型)</li>
</ul>
<p>MySQL的存储引擎主要有InnoDB、MyISAM。</p>
<h5 id="innodb">5.1 InnoDB</h5>
<p>InnoDB是MySQL当中默认的事务型存储引擎，它被设计用来处理大量的短期事务，短期事务大部分情况下都是正常提交的，很少会回滚。<strong>InnoDB的数据存储在表空间<code>xxx.ibd</code>中，能将表的数据和索引放置在单独的文件中，其表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能，不过它的二级索引（非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的索引都会很大，消耗空间多</strong></p>
<p><strong>InnoDB的特点：</strong></p>
<ul>
<li><strong>采用MVCC多版本并发控制来支持高并发，并且实现了四个标准隔离级别，默认级别为可重复的，使用间隙锁和MVCC策略防止了幻读的出现。</strong></li>
<li>支持自动增长列`AUTO_INCREMENT·。自动增长列的值不能为空，且值必须唯一。MySQL中规定自增列必须为主键。</li>
<li>支持外键，保证数据的完整性和正确性。外键所在表为子表，外键所依赖的表为父表。父表中被子表外键关联的字段必须为主键</li>
<li><strong>支持行级锁，提高并发访问性能。</strong></li>
<li><strong>作为事务性存储，InnoDB通过一些机制和工具支持真正的热备份。</strong>（热备份是指在正常情况下,两余度同时工作,当某一余度出现故障时,系统可切除故障余度,启用单余度方式,降级工作.本系统采用热备份方式）</li>
</ul>
<h5 id="myisam">5.2 MyISAM</h5>
<p>MyISAM是MySQL早期的默认存储引擎。MyISAM将表存储在两个文件中：数据文件(<code>xxx.MYD</code>)和索引文件(<code>xxx.MYI</code>)。MyISAM不支持事务和行级锁，而且有一个致命的缺陷就是崩溃后无法安全恢复。</p>
<p><strong>MyISAM特点：</strong></p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>占用空间小，访问速度快 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/engine.png" width="700"></li>
</ul>
<h4 id="mysql的索引">6. MySQL的索引</h4>
<p>索引在MySQL中也叫<strong>键</strong>，是存储引擎用于快速找到记录的一种数据结构。因此索引对于数据库的性能非常关键，尤其是当表中的数据量越来越多时，索引对性能的影响愈发重要。总计索引的优点有三点：</p>
<ul>
<li>索引可以快速查询，大大减少了服务器查找时需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变成顺序I/O，如<code>order by</code>就是索引支持的</li>
</ul>
<p><strong>索引分类</strong>：</p>
<ul>
<li><strong>普通索引：</strong>是最基本的索引，主要其加快查询速度，可使用<code>key</code>或者<code>index</code>定义一个列的普通索引或联合普通索引。</li>
<li><strong>主键索引</strong>：即主键，一个表只能有一个主键，则也就只能有一个主键索引，不允许有重复值和<code>NULL</code>值。以<code>primary key</code>定义。</li>
<li><strong>唯一索引</strong>：不允许有重复值，但运行为<code>NULL</code>值，同时一个表可以有多个唯一索引。适用<code>unique key</code>或者<code>unique index</code>定义</li>
</ul>
<p><strong><em>注意</em></strong>：<code>key</code>和<code>index</code>的区别是，<code>key</code>除了会定义一个相应的索引之外，还会形成一种约束，约束该列的规范，比如<code>primary key</code>约束表只能有一个主键列，且不能重复不能为NULL，而<code>index</code>只是生成这一的一个索引。</p>
<h5 id="索引基础">6.1 索引基础</h5>
<p>理解索引当然是看例子更合适： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name from sahilia.actor where actor_id=<span class="number">5</span>;</span><br></pre></td></tr></table></figure> 上面这个检索语句中，如果在<code>actor_id</code>列上设有索引，则MySQL将使用索引找到<code>actor_id=5</code>的行，即MySQL会在索引上按值查找，然后返回该值的数据行。</p>
<p>索引可以包含一个或多个列(创建键)。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效的使用索引的<strong>最左前缀原则</strong>。需要明确的是<strong>最左前缀原则</strong>是发生在复合索引上的，只有复合索引才会有所谓的左和右之分，在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配</p>
<p><strong>mysql 建立多列索引（联合索引）有最左前缀的原则，即最左优先，如：</strong></p>
<ul>
<li>如果有一个 2 列的索引<code>(col1, col2)</code>，则已经对<code>(col1)、(col1, col2)</code>上建立了索引；</li>
<li>如果有一个 3 列索引<code>(col1, col2, col3)</code>，则已经对<code>(col1)、(col1, col2)、(col1, col2, col3)</code>上建立了索引；</li>
</ul>
<p><strong>原理</strong>：</p>
<p>B+树的数据项是复合的数据结构，比如<code>(name,age,sex)</code>的时候，B+树是按照从左到右的顺序来建立索引树的，比如当<code>(张三,20,F)</code>这样的数据来检索的时候，B+树就优先比较name来确定下一步的搜索方向，如果name相同则再依次比较<code>age</code>和<code>sex</code>，最后得到检索到的数据；但当<code>（20，F）</code>这样的没有<code>name</code>的数据来的时候，B+树就不知道第一步应该检查哪个节点，因此此时就不会使用联合索引。</p>
<h5 id="索引类型">6.2 索引类型</h5>
<p>索引有很多种类型，可以为不同的场景提高供更好的性能。在MySQL中，索引是在存储引擎实现的，因此没有统一的索引标准。下面介绍MySQL中的支持的索引类型。</p>
<h6 id="btree索引">6.2.1 B+Tree索引</h6>
<p>InnoDB使用的时B+Tree索引。这意味着所有的值都是按顺序存储的，<strong>且数据域都存储在叶子节点处，非叶子节点只存储索引不能存储数据</strong>，这样对于查询性能来说很稳定，都是<code>h</code>。B+Tree索引适用于全键值、键值范围或键前缀查找：比如定义了普通联合索引<code>key(last_name,first_name,birthday)</code></p>
<ul>
<li><strong>全值匹配：</strong>指的是和索引中的所有列进行匹配，即<code>last_name,first_name,birthday</code>均匹配</li>
<li><strong>匹配最左前缀</strong>：查找时，可以只列举第一列<code>last_name</code>进行查找</li>
<li><strong>匹配列前缀</strong>：也可只匹配某一列的值的开头部分，如寻找姓以<code>J</code>开头的数据</li>
<li><strong>匹配范围</strong>：对姓名<code>last_name</code>也支持范围查找。</li>
</ul>
<p><strong><em>注意：说到B+Tree的叶子节点，必须区分MySQL中的聚簇索引和非聚簇索引（二级索引），在聚簇索引的叶子节点存储的是完整的行数据，而二级索引叶子节点存储的是数据<code>行指针</code>,这里的<code>行指针</code>的实质是叶子节点保存只是行的主键值，因此非聚簇索引必须还要在聚簇索引结构上进行查找，这也是为什么它被称为二级索引</em></strong></p>
<p>更详细的B+Tree见：<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构</a></p>
<h6 id="哈希索引">6.2.2 哈希索引</h6>
<p><strong>哈希索引是基于哈希表实现的，因此对于使用哈希索引其关键字的存储是无序的，不支持范围匹配查找，只有精确匹配锁索引所有列的查询才有效。</strong>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码解决其存储的位置，因此其查找一个值的复杂度为<code>O(1)</code>，比B+Tree更快。</p>
<p>在MySQL中，只有Memory引擎显式支持哈希索引，也是其默认的索引类型。</p>
<p><strong>优点：</strong></p>
<ul>
<li>访问内存的速度很快，同时因为是通过计算哈希值来确定关键字位置，访问哈希索引的数据也很快</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不会存储字段值，所有不能使用索引中的值来避免读行。</li>
<li>哈希索引数据是按照计算的哈希值排列的，因此也就是无序的，不支持范围查找。</li>
<li>哈希索引不想B+Tree索引那样支持部分列查找，因为索引的哈希值是所有列共同计算的结果。</li>
<li>哈希冲突多的时候，维护操作的代价比较高昂。</li>
</ul>
<h5 id="为什么b树更适合做索引">6.3 为什么B+树更适合做索引</h5>
<p><strong>我们先分析B+Tree与众不同的特点：</strong></p>
<ul>
<li>第一个就是B+树在B树的基础之上最重要的改进就是非叶子结点只存储关键字和下一层的索引，不存储Data域，只在叶子结点存储Data域；</li>
<li>第二点就是所有叶子结点增加一个链指针，使所有叶结点构成一个有序链表，因此当我们需要有序遍历所有关键字时，直接从最小关键字的叶子结点开始遍历即可。</li>
</ul>
<h6 id="非叶子结点不存储data域的好处">6.3.1非叶子结点不存储Data域的好处</h6>
<ul>
<li><p><strong>每一个结点可以存放更多的关键字和下一层的索引。数据库是存储在磁盘上的，我们读取数据是从磁盘读取到内存中，我们在进行磁盘预读取时，是以块的单位进行数据读取，我们在检索B/B+树的结点时，每次以块为单位将一个结点读取到内存中，若一块磁盘包含了树结点以外的数据，就造成了浪费，因此我们需要使每一个结点的数据大小正好或者接近一块磁盘的大小</strong>。于是我们在构建B+/B树时，树的阶数其实就取决于一块磁盘中能容纳多少个关键字以及相关的索引和Data域。<strong>B+树的非叶子结点不存储Data域，因此它可以存储更多个关键字和下一层索引，因此B+树会比B树更宽胖</strong>。若我需要查找的关键字正好在叶子结点，B+树所进行的I/O次数更少,因为途中经过每一层，我们都需要进行一次I/O读取一个结点，B+树会更矮，途径的层数会更少。</p></li>
<li><p>使得B+树查询速度更稳定，B+树所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p></li>
</ul>
<h6 id="所有叶结点构成一个有序链表的好处">6.3.2所有叶结点构成一个有序链表的好处</h6>
<ul>
<li><p><strong>B+树便于区间查找（这点才是B+树作为索引的关键）</strong>，我们进行数据库查询大多为区间查询，B+树天然具备排序功能，B+树所有的叶子结点构成了一个有序链表，在查询大小区间的数据时候更方便，B+树查询，只需通过头结点往下找到第一个叶子结点，然后在叶子结点的链表上就行遍历即可完成区间查询，而B树的关键字大小相邻近的结点可能隔得很远，要想进行区间查询需要不停的进行中序遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li>
<li><p>B+树全结点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要进行中序遍历，这有利于数据库做全表扫描。</p></li>
</ul>
<p><strong>总结B+树优点(选择B+树作为索引的原因)</strong></p>
<ul>
<li>因为没有非叶子节点没有存储数据，因此单一非叶子结点能存储更多的关键字索引</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；</li>
<li>所有叶子节点形成有序链表，便于范围查询以及全结点遍历更快。</li>
</ul>
<h5 id="高性能的索引策略">6.4 高性能的索引策略</h5>
<p>正确的创建和使用索引是实现高性能查询的基础。创建索引是最忌讳的就是为每一个列都建上独立的索引或者按照错误的顺序创建联合索引，这样会大大降低性能。</p>
<h6 id="选择合适的索引序列">6.4.1 选择合适的索引序列</h6>
<p>对于B+Tree多列索引来说，按照其最左前缀匹配原则，正确的的顺序依赖于使用哪些列选择性高，同时还有考虑如何更好的满足排序和分组的需要，即满足<code>order by\group by\distinct</code>查询子句的查询需求。</p>
<p><strong>有一条经验法则：将选择性最高的列放在索引的最前面。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">count</span><span class="params">(distinct staff_id)</span>/<span class="title">count</span><span class="params">(*)</span> as staff_id_selectivity,</span></span><br><span class="line"><span class="function">	-&gt; <span class="title">count</span><span class="params">(distinct customer_id)</span>/<span class="title">count</span><span class="params">(*)</span> as customer_id_selectivoty,</span></span><br><span class="line"><span class="function">	-&gt; <span class="title">count</span><span class="params">(*)</span></span></span><br><span class="line"><span class="function">	-&gt; from payment</span>;</span><br><span class="line">-------------------------------输出--------------------------------------------------*</span><br><span class="line">staff_id_seletivity:<span class="number">0.0001</span></span><br><span class="line">customer_id_selectibity:<span class="number">0.0373</span></span><br><span class="line"><span class="built_in">count</span>(*):<span class="number">16049</span></span><br></pre></td></tr></table></figure> 从上面可以看到选择性更高的是<code>customer_id</code>，因此将其放在索引第一列： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table payment add <span class="title">key</span><span class="params">(customer_id,staff_id)</span></span>;</span><br></pre></td></tr></table></figure> 最后还要说一句尽管这条关于选择性和基数的经验法则对于一般情况适用，但是别忘了还要考虑<code>where</code>子句当中的排序、分组和范围查询，要对这些折中考虑。</p>
<h5 id="聚簇索引">6.5 聚簇索引</h5>
<p>首先要明白的是聚簇索引不是开始说到的属于<strong>普通索引、唯一索引和主键索引的分类</strong>，MySQL的索引分类只有这三种。<strong>聚簇索引并不是一个单独索引类型，而是一种数据的存储方式的专有名词</strong>。</p>
<p><strong>对于InnoDB来说，InnoDB就会选择一个唯一的非空索引作为聚簇索引，当没有符合的唯一非空索引，就会隐式的定义一个主键来作为聚簇索引</strong>，因此一般情况你也可以理解主键就是聚簇索引；但是，有些时候唯一索引也有可能是聚簇索引</p>
<h6 id="聚簇索引与非聚簇索引的区别">6.5.1 聚簇索引与非聚簇索引的区别</h6>
<p>在上面说到B+Tree的时候已经介绍到了聚簇索引和非聚簇索引之间的区别，这里在系统的总结一下。</p>
<ul>
<li><strong>首先就是一张表只有有一个聚簇索引，但可以有多个非聚簇索引</strong></li>
<li><strong>另外聚簇索引的叶子节点存储的是完整的行数据，而非聚簇索引的叶子节点存储的是其相应主键列的关键字值，因此使用非聚簇索引进行查询时，除了查询非聚簇索引得到主键关键字值外，还要利用该值进行回表查询聚簇索引，最终得到整个行数据</strong>，这也是非聚簇索引又叫二级索引的由来。</li>
</ul>
<p><img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/aindex.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用主键索引(聚簇索引)查询</span></span><br><span class="line">select * from table where ID = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//使用非聚簇索引查询</span></span><br><span class="line">select * from table where k = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="聚簇索引的优缺点">6.5.2 聚簇索引的优缺点</h6>
<p>聚簇索引可能对性能有帮助，但也会导致严重的问题，下面分析其优缺点</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>聚簇索引的存在将相关数据都保存在一起，磁盘一次I/O就获得所有数据</strong>，如用户邮箱的管理，以ID为主键形成聚簇索引结构，则更加ID用户将其相关的数据都聚簇在叶子节点，可一下获得其所有数据。如果没有聚簇索引，则要获取该ID的所有信息要经过多次磁盘I/O</li>
<li><strong>数据访问速度更快，聚簇索引将索引和数据保存在同一个B+Tree上，因此聚簇索引比非聚簇索引的查询更快。</strong></li>
<li>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p><strong>插入速度严重依赖插入的顺序，其存储结构说明了按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式</strong>。如果不是按照逐渐顺序，会慢很大，而且最坏使用<code>optimize table</code>重新组织一下表。</p></li>
<li><p>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</p></li>
<li><p>更新行或插入行被强制移动带新的行，如果是要插入满行的一页，则会导致<code>页分类</code>。存储引擎通过页分裂称两个页面以能够存储该行，一次页分裂操作，导致表占有更多的空间。</p></li>
</ul>
<h5 id="覆盖索引">6.6 覆盖索引</h5>
<p>上面提到了二级索引想要查询行的所有列必须进行回表查询，有没有什么办法不用回表查询就能得到一些列的信息呢。这是要就用到了<strong>覆盖索引</strong>，<strong>如果一个索引包含了所有要查询字段的值，就称为为覆盖索引</strong>。在<code>select</code>前使用<code>explain</code>表示优先使用覆盖索引</p>
<p>不是所有的索引类型都能成为覆盖索引，覆盖索引必须存储该索引所在行的值，而像哈希索引、空间索引这些都不能存储。因此MySQL只有B+Tree索引能使用覆盖索引。现在来讲解覆盖索引的实现要求：</p>
<ul>
<li>表有除一个主键索引，其他列建立相应的零和索引，这一才能在二级索引存储有其他列的值。对于主键很明显在二级索引的叶子节点上</li>
<li>在<code>select</code>上使用<code>explain</code>，优先使用覆盖索引</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lengyue1084/article/details/119352209">覆盖索引详解</a></p>
<h5 id="冗余索引">6.7 冗余索引</h5>
<p>同一信息的重复储存，叫做冗余,冗余索引通常发生在为表添加新索引的时候。如<code>key(name,city)</code>和<code>key(name)</code>这两个索引就是冗余索引，能够命中后者的查询肯定能够命中前者。</p>
<p>大多数情况下我们都不需要冗余索引，因为索引的维护需要一定的开销。但有时候却页不得不创建一个冗余索引，就比如新加了一个字段，同时现有的联合索引已经非常庞大，如果再将这字段加入这个联合索引就会使得该联合索引更加庞大，此时使用新建冗余索引更好。</p>
<h4 id="优化查询">7. 优化查询</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/" class="post-title-link" itemprop="url">Linux操作系统_2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-30 22:29:06 / 修改时间：22:31:44" itemprop="dateCreated datePublished" datetime="2022-07-30T22:29:06+08:00">2022-07-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">467k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:05</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
