<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Trluper">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="trluper">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">Linux系统编程—网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-19 14:26:39" itemprop="dateCreated datePublished" datetime="2023-02-19T14:26:39+08:00">2023-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 13:38:14" itemprop="dateModified" datetime="2023-02-21T13:38:14+08:00">2023-02-21</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="tcpip协议">1 TCP/IP协议</h4>
<p>TCP/IP协议套件是一个分层联网协议，它包括因特网协议(ip)和位于其上层的各个协议层。</p>
<h5 id="osi七层模型和tcpip模型">1.1 OSI七层模型和TCP/IP模型</h5>
<p><img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/osi.png" width="500"> 各层协议主要有：</p>
<ul>
<li>应用层协议: FTP（文件传输协议）<strong>、HTTP（超文本传输协议）</strong>、NFS（网络文件系统）</li>
<li><strong>传输层协议： TCP （传输控制协议）、UDP（用户数据报协议）</strong></li>
<li>网络层：<strong>IP（英特网互联协议）</strong>、<strong>ICMP（英特网控制报文协议ping）</strong> 、IGMP（英特网组管理协议）</li>
<li>链路层协议：ARP（地址解析协议 通过ip找mac地址）、RARP:（反向地址解析协议 通过mac找ip）</li>
</ul>
<h5 id="tcp报文格式">1.2 TCP报文格式</h5>
<p><img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/TCP.png" width="500"> - 序列号：该报文的序列号，标识TCP发端向TCP接收端发送的数据字节流 - <strong>确认序列号</strong>：如果设定了<code>ACK</code>,那么从这个字段包含了接收放期望从发送方接收到的下一个数据字节的序列号 - 首部长度：该字段标识了TCP报文首部长度，该字段4个比特网位，则表示首部长度最大可达60字节 - 保留位：该字段有4位未使用的比特位 - 控制位： - <code>CWR</code>：拥塞窗口减小标记 - <code>ECE</code>：显示的拥塞通知回显标记 - <code>URG</code>：若设置了该位，则紧急指针字段包含的信息有效 - <strong><code>ACK</code>：若设置了该位，则确认序列号字段包含的信息有效</strong> - <code>PSH</code>：将所有收到的数据发送接收的进程 - <code>RST</code>：重置连接 - <strong><code>SYN</code>：同步序列号</strong> - <strong><code>FIN</code>：发送端提示已经完成了发送任务</strong></p>
<ul>
<li>窗口大小：该字段用在接收端发送ACK确认时提示自己可接受数据的空间大小</li>
<li>校验和：16位的检验</li>
</ul>
<h5 id="tcp和udp的区别">1.3 TCP和UDP的区别</h5>
<ul>
<li><strong>连接</strong>
<ul>
<li><strong>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</strong></li>
<li>UDP则是无连接。</li>
</ul></li>
<li><strong>服务对象</strong>
<ul>
<li>TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</li>
<li>UDP支持一对一，一对多，多对一，多对多的交互通信。</li>
</ul></li>
<li><strong>可靠性</strong>
<ul>
<li><strong>TCP是可靠交付，无差错，不丢失，不重复，按序到达。</strong></li>
<li>UDP是尽最大努力交付，不保证可靠交付。</li>
</ul></li>
<li><strong>拥塞控制，流量控制机制</strong>
<ul>
<li><strong>TCP有拥塞控制和流量控制保证数据传输的安全性。</strong></li>
<li>UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li>
</ul></li>
<li><strong>报文长度</strong>
<ul>
<li><strong>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</strong></li>
<li>UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li>
</ul></li>
<li><strong>首部开销</strong>
<ul>
<li>TCP首部开销大，首部20个字节。</li>
<li>UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</li>
</ul></li>
<li><strong>TCP和UDP适用场景</strong>
<ul>
<li><strong>从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</strong></li>
</ul></li>
</ul>
<h5 id="tcp三次握手四次挥手">1.4 TCP三次握手/四次挥手</h5>
<ul>
<li><strong>只有SYN位置1表示连接请求。</strong></li>
<li><strong>只有ACK置1表示ACK报文段，携带数据时会消耗序号seq，不携带则不消耗</strong></li>
<li><strong>ACK和SYN都置1，不能携带数据，但消耗1个序号seq</strong> <img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/TCP_connect.png" width="400"></li>
</ul>
<h6 id="三次握手">1.4.1 三次握手</h6>
<ul>
<li>1、Client将标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，并将该数据包发送给Server，Client进入<strong>SYN_SENT</strong>状态，等待Server确认。</li>
<li>2、Server收到数据包后由标志位<code>SYN=1</code>知道Client请求建立连接，Server将标志位<code>SYN</code>和<code>ACK</code>都置为1，<code>ack=J+1</code>，随机产生一个值<code>seq=K</code>，并将该数据包发送给Client以确认连接请求，Server进入<strong><code>SYN_RCVD</code></strong>状态。</li>
<li>3、Client收到确认后，检查<code>ack</code>是否为J+1，<code>ACK</code>是否为1，如果正确则将标志位<code>ACK</code>置为1，<code>ack=K+1</code>，并将该数据包发送给Server，Server检查<code>ack</code>是否为K+1，<code>ACK</code>是否为1，如果正确则连接建立成功，Client和Server进入<strong><code>ESTABLISHED</code></strong>状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<p><strong>三次握手的原因：</strong></p>
<ul>
<li>建立连接</li>
<li>第三次要回ACK的原因：如果没有第三次回ACK，会导致已经失效的连接请求报文突然又传输到服务器端，又建立客户端与服务器的连接，但客户端又不发送数据，此时导致的服务器资源浪费。所谓已经失效的连接请求是指客户端发出的连接请求滞留在网络中，超时后但又被服务器接收到。</li>
</ul>
<h6 id="四次挥手">1.4.2 四次挥手</h6>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个<code>FIN</code>来终止这一方向的连接，收到一个<code>FIN</code>只是意味着这一方向上没有数据流动了，即不会再发送到数据了，但是在这个<code>TCP</code>连接上仍然能够收数据，直到另一方也发送了<code>FIN</code>。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p><strong>过程：</strong></p>
<ul>
<li>1.数据传输结束后，客户端的应用进程发出连接释放FIN报文段，并停止发送数据，客户端进入<code>FIN_WAIT_1</code>状态，此时客户端依然可以接收服务器发送来的数据。</li>
<li>2.服务器接收到<code>FIN</code>后，发送一个ACK给客户端，确认序号为收到的序号<code>+1</code>，服务器进入<code>CLOSE_WAIT</code>状态。客户端收到后进入<code>FIN_WAIT_2</code>状态。</li>
<li>3.当服务器没有数据要发送时，服务器发送一个<code>FIN</code>报文，此时服务器进入<code>LAST_ACK</code>状态，等待客户端的确认</li>
<li>4.客户端收到服务器的<code>FIN</code>报文后，给服务器发送一个<code>ACK</code>报文，确认序列号为收到的序号<code>+1</code>。此时客户端进入<code>TIME_WAIT</code>状态，等待<code>2MSL</code>（MSL：报文段最大生存时间），然后关闭连接。</li>
</ul>
<p><strong>应用层可以使用系统调用函数read函数==0来判断对端是否关闭连接。</strong>为什么要等待2MSL才关闭链接:</p>
<ul>
<li>为保证客户端发送的最后一个ACK报文段能够到达服务器。超时重传</li>
<li>经过2MSL时间，可以使本次连接持续时间内所以产生的报文段(主要针对滞留在网络中的）都失效，这样就可避免已失效的本次链接请求影响下一次链接请求。</li>
</ul>
<h6 id="tcp状态转换图">1.4.3 TCP状态转换图</h6>
<p><img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/TCP_stat.png" width="500"></p>
<ul>
<li><code>CLOSED</code>：表示初始状态。</li>
<li><code>LISTEN</code>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li>
<li><code>SYN_SENT</code>：这个状态与<code>SYN_RCVD</code>遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送<code>SYN</code>报文，随即进入到了<code>SYN_SENT</code>状态，并等待服务端的发送三次握手中的第2个报文。<code>SYN_SENT</code>状态表示客户端已发送SYN报文。</li>
<li><code>SYN_RCVD</code>: 该状态表示接收到<code>SYN</code>报文，在正常情况下，这个状态是服务器端的<code>SOCKET</code>在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到<code>ESTABLISHED</code>状态。</li>
<li><code>ESTABLISHED</code>：表示连接已经建立。</li>
<li><code>FIN_WAIT_1</code>: <code>FIN_WAIT_1</code>和<code>FIN_WAIT_2</code>状态的真正含义都是表示等待对方的FIN报文。区别是：
<ul>
<li><code>FIN_WAIT_1</code>状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。</li>
<li><code>FIN_WAIT_2</code>状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</li>
</ul></li>
<li><p><code>FIN_WAIT_2</code>：主动关闭链接的一方，发出<code>FIN</code>收到<code>ACK</code>以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发，既socket上还有数据流动。</p></li>
<li><p><strong><code>TIME_WAIT</code></strong>: 表示收到了对方的<code>FIN</code>报文，并发送出了<code>ACK</code>报文，等2MSL后即可回到<code>CLOSED</code>可用状态。如果<code>FIN_WAIT_1</code>状态下，收到对方同时带 <code>FIN</code>标志和<code>ACK</code>标志的报文时，可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code>状态。</p></li>
<li><p><strong><code>CLOSING</code></strong>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送<code>FIN</code>报文后，按理来说是应该先收到（或同时收到）对方的<code>ACK</code>报文，再收到对方的<code>FIN</code>报文。但是<code>CLOSING</code>状态表示你发送<code>FIN</code>报文后，并没有收到对方的<code>ACK</code>报文，反而却也收到了对方的<code>FIN</code>报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现<code>CLOSING</code>状态，表示双方都正在关闭<code>SOCKET</code>连接。</p></li>
<li><strong><code>CLOSE_WAIT</code></strong>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送<code>FIN</code>报文给自己，系统会回应一个ACK报文给对方，此时则进入到<code>CLOSE_WAIT</code>状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在<code>CLOSE_WAIT</code>状态下，需要关闭连接。（服务器）</li>
<li><p><strong><code>LAST_ACK</code></strong>: 该状态是被动关闭一方在发送<code>FIN</code>报文后，最后等待对方的<code>ACK</code>报文。当收到ACK报文后，即可以进入到<code>CLOSED</code>可用状态。（服务器）</p></li>
</ul>
<h4 id="网络socket先备知识点">2. 网络socket先备知识点</h4>
<h5 id="端口">2.1 端口</h5>
<p><strong>传输层协议的任务是向位于不同主机上的应用程序提供端到端的通信服务。为完成这个任务，传输层需要采用一中方法来区分主机上的应用程序，这种区分工作就由一个16位端口号来完成，即用来标识应用程序(进程)。</strong>众所周知，一些端口已经固定分配给一些应用，如<code>22——ssh</code>、<code>80-HTTP</code>，</p>
<ul>
<li>port：2个字节 0-65535。</li>
<li>0-1023为 知名端口（不可更改）。</li>
<li>自定义端口 1024 - 65535</li>
<li>查看端口使用情况：<code>netstat</code></li>
</ul>
<h5 id="字节序">2.2 字节序</h5>
<p>IP地址和端口号是整数值，这些值在网络传递中的一个问题是不同的硬件结构会以不同的顺序来存储一个多字节整数的字节：</p>
<ul>
<li>存储整数时在最小内存地址先存储最高位的称为大端，<strong>低位存低地址，高位存高地址</strong>（也叫网络字节序）</li>
<li>存储整数时在最小内存地址先存储最低位的称为小端，<strong>低位存高地址，高位存低地址</strong></li>
</ul>
<p><img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/bigorsmall.png" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unit32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">unit32_t</span> hostlong)</span>	<span class="comment">//host to newwork long</span></span></span><br><span class="line"><span class="function"><span class="type">unit16_t</span> <span class="title">htons</span><span class="params">(<span class="type">unit16_t</span> hostshort)</span></span></span><br><span class="line"><span class="function"><span class="type">unit32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">unit32_t</span> netlong)</span></span></span><br><span class="line"><span class="function"><span class="type">nuit16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">unit16_t</span> netshort)</span></span></span><br></pre></td></tr></table></figure> 示例deamon: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="string">&lt;apra/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">4</span>]=&#123;<span class="number">192</span>,<span class="number">168</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	<span class="comment">//int is 4B,char is 1B,can cover by int just right</span></span><br><span class="line">	<span class="type">int</span> num =*(<span class="type">int</span>*)buf;</span><br><span class="line">	<span class="type">int</span> sum=<span class="built_in">htonl</span>(num);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *p=&amp;num;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p=<span class="number">3</span>));</span><br><span class="line">	<span class="type">int</span> sum1=<span class="built_in">ntohl</span>(num);</span><br><span class="line">	p=&amp;sum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p=<span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="ip转换">2.3 ip转换</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;</span><br><span class="line">功能: 将点分十进制串 转成<span class="number">32</span>位网络大端的数据(<span class="string">&quot;192.168.1.2&quot;</span>  ==&gt;   )</span><br><span class="line">参数:</span><br><span class="line">    af : </span><br><span class="line">        AF_INET         IPV4</span><br><span class="line">        AF_INET6        IPV6</span><br><span class="line">  src: 点分十进制串的首地址 </span><br><span class="line">  dst : <span class="number">32</span>位网络数据的地址 </span><br><span class="line">成功返回<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br><span class="line">功能: 将<span class="number">32</span>位大端的网络数据转成点分十进制串</span><br><span class="line">参数:</span><br><span class="line">    af : AF_INET</span><br><span class="line">    src : <span class="number">32</span>位大端的网络数 地址</span><br><span class="line">    dst : 存储点分十进制串 地址</span><br><span class="line">    size : 存储点分制串数组的大小  ，一般为<span class="number">16</span></span><br><span class="line">返回值: 存储点分制串数组首地址</span><br></pre></td></tr></table></figure>
<p>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[]=<span class="string">&quot;192.16.1.2&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET,buf,&amp;num);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* p=(<span class="type">unsigned</span> <span class="type">char</span>*)&amp;num;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p=<span class="number">3</span>));</span><br><span class="line">	cahr ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">inet_ntop</span>(AF_INET,&amp;num,ip,<span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="套接字结构体">2.4 套接字结构体</h5>
<p>网络通信只需解决3个问题（其它组包过程协议会帮我们完成）：协议、ip、端口。而在三个统一在对应的结构体封装，我们只需要创建一个已初始化的结构体即可。</p>
<h6 id="ipv4结构体">2.4.1 IPv4结构体</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">strcut in_addr&#123;				<span class="comment">//地址结构体，存储ip地址</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;		<span class="comment">//无符号32位整型</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">	<span class="type">sa_family_t</span> sin_family;		<span class="comment">//协议类型：AF_INET</span></span><br><span class="line">	<span class="type">in_port_t</span>	sin_port;		<span class="comment">//端口</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;	<span class="comment">//ip地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="ipv6结构体">2.4.2 IPv6结构体</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span>&#123;</span><br><span class="line">	<span class="type">uint8_t</span> s6_addr[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span>&#123;</span><br><span class="line">	<span class="type">sa_family_t</span> sin6_family;	<span class="comment">//AF_INET6</span></span><br><span class="line">	<span class="type">in_port_t</span> sin6_port;</span><br><span class="line">	<span class="type">unit32_t</span> sin6_flowinfo;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;</span><br><span class="line">	<span class="type">uint32_t</span> sin6_scope_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="unix-domain结构体">2.4.3 Unix domain结构体</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span>&#123;</span><br><span class="line">	<span class="type">sa_family_t</span> sun_family;		<span class="comment">//AF_UNIX</span></span><br><span class="line">	<span class="type">char</span> sun_path[<span class="number">108</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="通用结构体">2.4.4 通用结构体</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;     <span class="comment">/* address family, AF_xxx */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];          <span class="comment">/* 14 bytes of protocol address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="socket套接字">3 socket套接字</h4>
<p>socket是一钟IPC方法，它允许位于同一主机或使用网络连接起来的不同主机上的应用程序之间能够交换数据。常见的就是： - UNIX domain(AF_UNIX)允许在同一主机上的应用程序之间通信。 - <strong>IPv4(AF_INET)domain允许在使用因特网协议第四版(IPv4)网络连接起来的应用程序之间通信</strong> - <strong>IPv6(AF_INET6)domain允许在使用因特网协议第六版(IPv6)网络连接起来的应用程序之间通信</strong></p>
<p>这里我们主要对网络间通信做说明 <img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/socket_domain.png" width="600"></p>
<p>同样在网络通信中socket支持两种形式的传输一个是<strong>流socket(TCP socket)</strong>，另一个是<strong>数据报socket(UDP socket)</strong>，顾名思义，<strong>它们在传输层走的协议分别是TCP和UDP</strong> <img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/socket_type.png" width="600"></p>
<h5 id="sockettcpudp服务器通信步骤">3.1 socket：TCP/UDP服务器通信步骤</h5>
<p><strong>TCP服务器通信步骤：</strong></p>
<ul>
<li><strong>服务器：</strong>创建套接字 socket-&gt; 绑定 bind-&gt;监听 listen-&gt;提取 accept-&gt;读写-&gt;关闭</li>
<li><strong>客户端</strong>：创建套接字 socket-&gt; 建立连接 connect <img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/client_server.png" width="500"></li>
</ul>
<p><strong>UDP服务器通信步骤：</strong></p>
<ul>
<li>服务器: 创建报式套接字socket-&gt; 绑定bind-&gt; 读写-&gt; 关闭</li>
<li>客户端: 创建报式套接字socket-&gt; 读写-&gt; 关闭 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">发数据：</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">dest_addr: 目的地的地址信息</span><br><span class="line">addrlen: 结构体大小</span><br><span class="line">收数据:</span><br><span class="line">  <span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">src_addr: 对方的地址信息</span><br><span class="line">addrlen: 结构体大小的地址</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="创建套接字api">3.1.1 创建套接字API</h6>
<p>无论是服务器还是客户端都要创建socket</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line">创建套接字</span><br><span class="line">参数:</span><br><span class="line">domain:AF_INET</span><br><span class="line">type: SOCK_STREAM 流式套接字 用于tcp通信</span><br><span class="line">protocol: <span class="number">0</span></span><br><span class="line">成功返回文件描述符,失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h6 id="bind绑定">3.1.2 bind绑定</h6>
<p>给套接字绑定固定的端口和ip</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">成功返回<span class="number">0</span> 失败返回;<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h6 id="listen使服务器处于监听状态">3.1.3 listen：使服务器处于监听状态</h6>
<p>服务器在创建完socket和绑定了相应的端口和ip地址后，要置于监听状态，监听网络中客户端的连接请求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">    backlog :  已完成连接队列和未完成连接队里数之和的最大值  <span class="number">128</span></span><br></pre></td></tr></table></figure>
<h6 id="accept响应连接请求并建立连接">3.1.4 accept:响应连接请求，并建立连接</h6>
<p>如果连接队列没有新的连接,accept会阻塞</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> socket, <span class="keyword">struct</span> sockaddr *restrict address,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">socklen_t</span> *restrict address_len)</span></span>;</span><br><span class="line">功能: 从已完成连接队列提取新的连接</span><br><span class="line">参数:</span><br><span class="line">    socket : 套接字</span><br><span class="line">    address : 获取的客户端的的ip和端口信息  iPv4套接字结构体地址</span><br><span class="line">    address_len: iPv4套接字结构体的大小的地址</span><br><span class="line">返回值:  新的已连接套接字的文件描述符</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr );</span><br></pre></td></tr></table></figure>
<h6 id="connect客户端连接服务器">3.1.5 connect：客户端连接服务器</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd , <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">功能: 连接服务器</span><br><span class="line">sockfd:  socket套接字</span><br><span class="line">addr:  ipv4套接字结构体的地址</span><br><span class="line">addrlen: ipv4套接字结构体的长</span><br></pre></td></tr></table></figure>
<h6 id="socket的发送接收函数">3.1.6 socket的发送接收函数</h6>
<p>除了常用的<code>read</code>和<code>write</code>函数以外，还有专用于套接字的I/O系统调用<code>recv()</code>和<code>send()</code>(这些一般来说适用于TCP socket) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;<span class="comment">//flags==MSG_PEEK 读数据不会删除缓冲区的数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;<span class="comment">//flags=1 紧急数据</span></span><br></pre></td></tr></table></figure> <strong>flag参数</strong>：(详细请查书)</p>
<ul>
<li><code>MSG_DONTAIT：</code>让<code>recv</code>以非阻塞形式执行</li>
<li><code>MSG_OOB</code>：在套接字上接收带外数据</li>
</ul>
<h5 id="示例简易客户端实现">3.2 示例：简易客户端实现</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sock_fd;</span><br><span class="line">	sock_fd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//建立连接</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port=<span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET,<span class="string">&quot;169.254.128.147&quot;</span>,&amp;addr.sin_addr.s_addr);</span><br><span class="line">	<span class="type">int</span> ero=<span class="built_in">connect</span>(sock_fd,(<span class="keyword">struct</span> sockaddr*)&amp;addr,<span class="built_in">seziof</span>(addr));</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>!=ero)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;连接失败\n&quot;</span>);</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n =<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">seziof</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(sock_fd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		n= <span class="built_in">read</span>(sock_fd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(STDOUT_FIFLENO,buf,n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(sock_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="示例简易服务器实现">3.3 示例：简易服务器实现</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	<span class="type">int</span> sfd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//绑定</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">	addr.sin_family=AF_INET;</span><br><span class="line">	addr.sin_port=<span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET,<span class="string">&quot;192,168.3.8&quot;</span>,&amp;addr.sin_addr.s_addr);</span><br><span class="line">	<span class="built_in">bind</span>(sfd,(<span class="keyword">struct</span> sockaddr*)&amp;addr,<span class="built_in">sizeof</span>(addr));</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	<span class="built_in">listen</span>(sfd,<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//提取</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">	<span class="type">socklen_t</span> len=<span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">	<span class="type">int</span> cfd=<span class="built_in">accept</span>(sfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">	<span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;建立连接，对端ip：%s\n&quot;</span>,<span class="built_in">inet_ntop</span>(AF_INET,&amp;(cliaddr.sin_addr.s_addr),ip,<span class="number">16</span>));</span><br><span class="line">	<span class="comment">//读写</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">sezifo</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(cfd,buf,n);</span><br><span class="line">		n=<span class="built_in">read</span>(cfd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭</span></span><br><span class="line">	<span class="built_in">close</span>(sfd);</span><br><span class="line">	<span class="built_in">close</span>(cfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务器示例">4 服务器示例</h4>
<h5 id="setsockopt函数">4.1 setsockopt函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">( <span class="type">int</span> socket, <span class="type">int</span> level, <span class="type">int</span> option_name,<span class="type">const</span> <span class="type">void</span> *option_value, <span class="type">size_t</span> ，ption_len)</span></span>;</span><br><span class="line">第一个参数socket是套接字描述符。</span><br><span class="line">第二个参数level是被设置的选项的级别，如果想要在套接字级别上设置选项，就必须把level设置为 SOL_SOCKET。 </span><br><span class="line">option_name指定准备设置的选项，option_name可以有哪些取值，这取决于level</span><br></pre></td></tr></table></figure>
<p><strong><code>option_name</code>:</strong></p>
<ul>
<li><p><code>SO_DEBUG</code>，打开或关闭调试信息。当option_value不等于0时，打开，否则，关闭</p></li>
<li><p><code>SO_REUSEADDR</code>，打开或关闭地址端口复用功能，当option_value不等于0时，打开，否则，关闭。</p></li>
<li><p><code>SO_DONTROUTE</code>，打开或关闭路由查找功能。</p></li>
<li><p><code>SO_BROADCAST</code>，允许或禁止发送广播数据。</p></li>
<li><p><code>SO_SNDBUF</code>，设置发送缓冲区的大小。发送缓冲区的大小是有上下限的，其上限为256 * (sizeof(struct sk_buff) + 256)，下限为2048字节。</p></li>
<li><p><code>SO_RCVBUF</code>，设置接收缓冲区的大小。接收缓冲区大小的上下限分别是：256 * (sizeof(struct sk_buff) + 256)和256字节。</p></li>
<li><p><code>SO_KEEPALIVE</code>，套接字保活。如果协议是TCP，并且当前的套接字状态不是侦听(listen)或关闭(close)，那么，当option_value不是零时，启用TCP保活定时 器，否则关闭保活定时器。</p></li>
<li><p><code>SO_OOBINLINE</code>，紧急数据放入普通数据流。</p></li>
<li><p><code>SO_NO_CHECK</code>，打开或关闭校验和。</p></li>
</ul>
<h5 id="心跳包">4.1 心跳包</h5>
<p>在TCP网络通信中，<strong>经常会出现客户端和服务器之间的非正常断开，需要实时检测查询链接状态。常用的解决方法就是在程序中加入心跳机制。</strong>如果对方异常断开,本机检测不到,一直等待,浪费资源。需要设置tcp的保持连接,作用就是每隔一定的时间间隔发送探测分节,如果连续发送多个探测分节对方还未回,就将次连接断开 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//心跳包</span></span><br><span class="line"><span class="type">int</span>  keepAlive = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="type">void</span>*)&amp;keepAlive, <span class="built_in">sizeof</span>(keepAlive));</span><br></pre></td></tr></table></figure> <strong><em>注：</em></strong> - 心跳包: 最小粒度 - 乒乓包: 携带比较多的数据的心跳包</p>
<h5 id="io端口复用">4.2 IO端口复用</h5>
<p>实际上，默认的情况下，如果一个网络应用程序的一个套接字 绑定了一个端口( 占用了 8000 )，这时候，别的套接字就无法使用这个端口( 8000 )。或者关闭了这个应用程序，但处于TIME_WAIT需等待2MSL，为避免等待，就要使用IO端口复用。 设置端口复用的办法：在套接字绑定前，加以下两句： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="type">void</span>*)&amp;opt, <span class="built_in">sizeof</span>(opt));</span><br></pre></td></tr></table></figure> SO_REUSEADDR可以用在以下四种情况下。 (摘自《Unix网络编程》卷一，即UNPv1)</p>
<ul>
<li>1、当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。</li>
<li>2、SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可以测试这种情况。</li>
<li>3、SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。这和2很相似，区别请看UNPv1。</li>
<li>4、SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。</li>
</ul>
<h5 id="多进程版服务器">4.3 多进程版服务器</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_process</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pid=<span class="built_in">waitpid</span>(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">		<span class="keyword">if</span>(pid&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;	<span class="comment">//小于0，代表子进程全部退出，等于0，没有子进程退出</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child pid=%d\n&quot;</span>,pid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用已包裹函数实现socket</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//crtl+c率先于信号注册杀死进程，SIGCHLD信号默认是忽略的</span></span><br><span class="line">	<span class="comment">//导致无法捕捉该信号，因此先屏蔽</span></span><br><span class="line">	<span class="type">sigset_t</span> set;</span><br><span class="line">	<span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;set,SIGCHLD);</span><br><span class="line">	<span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;set,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//创建套接字，绑定</span></span><br><span class="line">	<span class="type">int</span> lfd=<span class="built_in">tcp4bind</span>(<span class="number">8000</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	<span class="built_in">Listen</span>(lfd,<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//提取，回摄服务器</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_int</span> cliaddr;</span><br><span class="line">	<span class="type">socklen_t</span> len=<span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">int</span> cfd=<span class="built_in">Accept</span>(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;建立连接，对端ip:%s\n&quot;</span>,<span class="built_in">inet_ntop</span>(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,<span class="number">16</span>))</span><br><span class="line">		<span class="comment">//创建子进程</span></span><br><span class="line">		<span class="type">pid_t</span> pid;</span><br><span class="line">		pid=fork();</span><br><span class="line">		<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>==pid)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//子进程</span></span><br><span class="line">			<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="type">int</span> n=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">sezifo</span>(buf));</span><br><span class="line">			<span class="built_in">write</span>(cfd,buf,n);</span><br><span class="line">			n=<span class="built_in">read</span>(cfd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">			<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">perror</span>(”read<span class="string">&quot;);</span></span><br><span class="line"><span class="string">				close(cfd);</span></span><br><span class="line"><span class="string">				exit(0);</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			else if(0==n)</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				printf(&quot;</span>客户端已关闭\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">				eixt(0)</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		else&#123;</span></span><br><span class="line"><span class="string">			//父进程</span></span><br><span class="line"><span class="string">			close(fd);</span></span><br><span class="line"><span class="string">			//回收，注册信号，避免父进程粗赛无法提取连接进程</span></span><br><span class="line"><span class="string">			strcut sigcation art;</span></span><br><span class="line"><span class="string">			act.sa.hindler=0;</span></span><br><span class="line"><span class="string">			sigemptyset(&amp;act,sa_fmask);</span></span><br><span class="line"><span class="string">			sigaction(SIGCHLD,&amp;Aact,NULL);</span></span><br><span class="line"><span class="string">			//基础屏蔽</span></span><br><span class="line"><span class="string">			sigcrocmask(SIG_UNBLOCK,%SET,null);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="多线程版实现服务器">4.4 多线程版实现服务器</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">client_info</span>&#123;</span><br><span class="line">	<span class="type">int</span> c_cfd;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> c_addr;</span><br><span class="line">&#125;INFO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Client_fun</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用已包裹函数实现socket</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//分离线程，让系统回收</span></span><br><span class="line">	<span class="type">pthread_attr_t</span> attr;</span><br><span class="line">	<span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">	<span class="type">int</span> m= <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">	<span class="keyword">if</span>(m!=<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;setdetachstate failed\n&quot;</span>);</span><br><span class="line">	<span class="comment">//创建套接字，绑定</span></span><br><span class="line">	<span class="type">int</span> lfd=<span class="built_in">tcp4bind</span>(<span class="number">8000</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	<span class="built_in">Listen</span>(lfd,<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//提取，回摄服务器</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_int</span> cliaddr;</span><br><span class="line">	<span class="type">socklen_t</span> len=<span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">	INFO* c_info;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> cfd=<span class="built_in">Accept</span>(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">		<span class="comment">//要传入线程的参数</span></span><br><span class="line">		c_info=(INFO*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(INFO));</span><br><span class="line">		c_info-&gt;c_cfd=cfd;</span><br><span class="line">		c_info-&gt;c_addr=cliaddr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建线程</span></span><br><span class="line">		<span class="type">pthread_t</span> pth;</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">pthread_create</span>(&amp;pth,&amp;attr,Client_fun,c_info);</span><br><span class="line">		<span class="keyword">if</span>(n!=<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Client_fun</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INFO* info=(INFO*)arg;</span><br><span class="line">	<span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;client ip:%s,port:%d\n&quot;</span>,<span class="built_in">inet_ntop</span>(AP_INET,</span><br><span class="line">	&amp;(info-&gt;c_addr.sin_addr.s_addr),ip,<span class="number">16</span>),<span class="built_in">ntohs</span>(info-&gt;c_addr.sin_port));</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cfd=info-&gt;c_cfd;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(cfd,buf,n);</span><br><span class="line">		n=<span class="built_in">read</span>(cfd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;client close\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(cfd);</span><br><span class="line">	<span class="built_in">free</span>(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="高并发技术io多路复用">5 高并发技术(IO多路复用)</h4>
<h5 id="多路io转接复用服务器">5.1 多路IO转接(复用)服务器</h5>
<p>多路IO转接服务器也叫做多任务IO服务器。<strong>该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件描述符的属性变化，查看它们是否准备好执行I/O。</strong></p>
<p>主要使用的方法有三种：select、poll、epoll <img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/compare.png" width="500"></p>
<h5 id="select">5.2 select</h5>
<h6 id="select原理">5.2.1 select原理</h6>
<p><img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/select.png" width="600"> select拜托内核去监听<code>cfd</code>和<code>lfd</code>，在应用层上<strong>我们需要人为的备份一份<code>fd_set</code>集合称为<code>oldset</code>，用于每次监听传入的集合。</strong></p>
<p><strong>select进入内核中后，将只会保留那些发生改变的文件描述符，并返回给应用层，此时，我们只需遍历一下返回的集合，就知道要做哪些操作（是读还是写，还是提取新<code>cfd</code>)。后再将更新后（既发生了lfd提取，如上图可增加7之后的文件描述符）或无需更新（未发生提取）的备份<code>oldset</code>传入select</strong>,再次监听。循环如此</p>
<h6 id="select接口">5.2.2 select接口</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">select的API</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">                  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line">功能: 监听多个文件描述符的属性变化(读,写,异常)</span><br><span class="line">     参数:</span><br><span class="line">    nfds  : 最大文件描述符+<span class="number">1</span>(select会遍历的文件描述符的取值范围，因为文件描述符是位图存储（默认共<span class="number">1024</span>个，<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>默认是标准输入输出错误输出占有））</span><br><span class="line">    readfds : 需要监听的读的文件描述符存放集合</span><br><span class="line">    writefds :需要监听的写的文件描述符存放集合 </span><br><span class="line">    exceptfds : 需要监听的异常的文件描述符存放集合  </span><br><span class="line">    timeout: 多长时间监听一次   固定的时间,限时等待   <span class="literal">NULL</span> 永久监听</span><br><span class="line">    <span class="keyword">struct</span> timeval &#123;</span><br><span class="line">               <span class="type">long</span>    tv_sec;         <span class="comment">/* seconds */</span> 秒</span><br><span class="line">               <span class="type">long</span>    tv_usec;        <span class="comment">/* microseconds */</span>微妙</span><br><span class="line">           &#125;;</span><br><span class="line">返回值: 返回的是变化的文件描述符的个数</span><br><span class="line">注意: 变化的文件描述符会存在监听的集合中,未变化的文件描述符会从集合中删除</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">FD_CLR</span>(<span class="type">int</span> fd, fd_set *set);</span><br><span class="line"><span class="type">int</span>  <span class="built_in">FD_ISSET</span>(<span class="type">int</span> fd, fd_set *set);</span><br><span class="line"><span class="type">void</span> <span class="built_in">FD_SET</span>(<span class="type">int</span> fd, fd_set *set);</span><br><span class="line"><span class="type">void</span> <span class="built_in">FD_ZERO</span>(fd_set *set);</span><br></pre></td></tr></table></figure>
<h6 id="select的优缺点">5.2.3 select的优缺点</h6>
<p><strong>优点</strong>：</p>
<ul>
<li>select使用的较为广泛，在unix和windows上都标准化了，<strong>支持跨平台，移植性较好</strong>。</li>
<li>select的超市精度可为微妙级，比poll和epoll的秒级好。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>由于 FD_SETSIZE的限制，文监听的件描述符有1024数量的限制，若要修改，要重新编译程序</strong></li>
<li><strong>只是返回变化的文件描述符的个数,具体哪个那个变化需要完整遍历集合</strong>。</li>
<li>** select和poll一样，每次都需要将需要监听的文件描述集合由应用层符拷贝到内核。当应对大量的文件描述符时，这种从用户空间到内核空间的来回拷贝数据回耗费大量时间。（select和poll共同点）**</li>
<li>** select必须额外维护一个数据结构，这样在再次调用select时才能将其重新传入内核。**</li>
<li><strong>select调用完成后，程序必须按顺序在集合查找发生变化的文件描述符，效率低</strong>
<ul>
<li>假设现在 4-1023个文件描述符需要监听,5-1000这些文件描述发来消息，ok,这种情况没问题</li>
<li>假设现在 4-1023个文件描述符需要监听,但是只有 5,1002 发来消息，无解，只能一一遍历</li>
</ul></li>
</ul>
<h5 id="epoll">5.3 epoll</h5>
<p>epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，<strong>因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</strong></p>
<p>epoll除了提供select/poll那种IO事件的<strong>水平触发</strong>（Level Triggered）外，还提供了<strong>边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</strong></p>
<p><strong>简而言之，epoll具有的特点：</strong></p>
<ul>
<li>同poll一样没有文件描述符的限制</li>
<li>下次监听不需要将需要监听的文件描述符从应用层再次拷贝到核</li>
<li>会返回已经变化的的文件描述符，不用我们去遍历红黑树</li>
</ul>
<h6 id="epoll的api">5.3.1 epoll的API</h6>
<p><strong>①创建一颗红黑树的句柄</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">	size：监听数目</span></span><br><span class="line"><span class="function">	返回值：成功：非负文件描述符，失败：-1，设置响应的errno</span></span><br></pre></td></tr></table></figure></p>
<p><strong>②将需要监听的文件描述符上树，下树、修改操作</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">    epfd : 树的句柄</span><br><span class="line">    op : EPOLL_CTL_ADD 上树   EPOLL_CTL_DEL 下树 EPOLL_CTL_MOD 修改</span><br><span class="line">    fd : 上树,下树的文件描述符</span><br><span class="line">    event :   上树的节点</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">               <span class="type">uint32_t</span>  events;      <span class="comment">/* Epoll events */</span>  需要监听的事件</span><br><span class="line">               <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span> 需要监听的文件描述符</span><br><span class="line">           &#125;;</span><br><span class="line">相应联合体：</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">               <span class="type">void</span>        *ptr;</span><br><span class="line">               <span class="type">int</span>          fd;</span><br><span class="line">               <span class="type">uint32_t</span>     u32;</span><br><span class="line">               <span class="type">uint64_t</span>     u64;</span><br><span class="line">           &#125; <span class="type">epoll_data_t</span>;</span><br><span class="line">例：</span><br><span class="line">将cfd上树</span><br><span class="line"><span class="type">int</span> epfd =  <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev. data.fd = cfd;</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD,cfd, &amp;ev);</span><br></pre></td></tr></table></figure> <code>struct epoll_event</code>结构中，events可以是以下几个宏的集合：</p>
<ul>
<li><strong><code>EPOLLIN</code> ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</strong></li>
<li><strong><code>EPOLLOUT</code>：表示对应的文件描述符可以写；</strong></li>
<li><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li><code>EPOLLERR</code>：表示对应的文件描述符发生错误；</li>
<li><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；</li>
<li><strong><code>EPOLLET</code>： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</strong></li>
<li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</li>
</ul>
<p><strong>③监听：timeout=-1时阻塞</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line">    功能: 监听树上文件描述符的变化</span><br><span class="line">    epfd : 数的句柄</span><br><span class="line">    events : 接收变化的节点（结构体）的数组的首地址，所以我们要创建一个数组去接收他</span><br><span class="line">    maxevents :  数组元素的个数</span><br><span class="line">    timeout : <span class="number">-1</span> 永久监听,阻塞直到有文件描述符发生变化  大于等于<span class="number">0</span> 限时等待</span><br><span class="line">返回值: 返回的是变化的文件描述符个数</span><br></pre></td></tr></table></figure></p>
<h6 id="epoll_wait的两个工作方式">5.3.2 epoll_wait的两个工作方式</h6>
<p>epoll除了提供<code>select/poll</code>那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），<strong>这就使得用户空间程序有可能缓存IO状态，减少<code>epoll_wait/epoll_pwait</code>的调用，提高应用程序效率</strong>。(<code>epoll_wait</code>是一个系统调用,尽量少调用。所以尽量使用边沿触发)</p>
<ul>
<li><strong>水平触发(level-trggered):</strong>
<ul>
<li>只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，</li>
<li>当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知</li>
<li>LT模式支持<strong>阻塞和非阻塞两种方式</strong>，即设置<code>timeout</code>的值。epoll默认的模式是LT</li>
</ul></li>
<li><strong>边缘触发(edge-triggered)</strong>：
<ul>
<li>当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知</li>
<li>当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知</li>
</ul></li>
</ul>
<p>epoll默认为水平触发，若改为边沿，则只需<code>ev.events=EPOLLIN | EPOLLET</code>。水平触发,只要缓存区有数据<code>epoll_wait</code>就会被触发，边沿触发数据来一次只触发一次。</p>
<ul>
<li><strong>水平触发和边缘触发模式区别</strong>
<ul>
<li>读缓冲区刚开始是空的，然后读缓冲区写入2KB数据，水平触发和边缘触发模式此时都会发出可读信号，收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据，水平触发会再次进行通知，而边缘触发不会再进行通知。所以，边缘触发需要一次性的把缓冲区的数据读完为止，也就是一直读，直到读到EGAIN为止，EGAIN说明缓冲区已经空了<strong>，因为这一点，边缘触发需要设置文件句柄为非阻塞</strong></li>
</ul></li>
</ul>
<p><strong><em>注：（即指在使用边缘触发时，由于读数据只触发一次，这个时候要求一次性将数据读完,所以while循环读,读到最后。又因为read默认带阻塞,为不能让read阻塞（因为阻塞的话不能再去监听）,因此设置cfd为非阻塞,这样read读到最后一次返回值为-1.判断errno的值为EAGAIN,代表数据读干净，然后再进行监听）</em></strong></p>
<p><strong><em>工作中： 一般来说，cfd采用边沿触发 + 非阻塞 = 高速模式；lfd采用水平触发</em></strong> <strong><em>注意：边缘触发，目的是减少epoll_wait的调用次数，提升程序效率</em></strong></p>
<h6 id="边缘触发时文件描述符饥饿现象">5.3.3 边缘触发时文件描述符饥饿现象</h6>
<ul>
<li><strong>什么是文件描述符饥饿现象：</strong>现在我么使用边缘触发通知监视多个文件描述符，其中一个就绪态的描述符上有着大量的输入存在，此时我们的程序通过非阻塞的式的读操作将所有输入都读取，那么此时就会使其他文件描述符处于饥饿状态的风险，即我们再次检查文件描述符之前有很长一段处理时间）</li>
<li>解决方法；
<ul>
<li>应用程序维护一个列表，调用epoll_wait监视描述符时，将处于就绪状态的描述符添加到应用程序维护的列表中；然后对列表中的文件描述符进行一定限度的I/O操作(可以采用轮转调度方式循环处理)，当相关非阻塞I/O系统调用出现EAGAIN时，这些文件描述符就能从列表删除，这样就避免了单个文件描述符长时间占有CPU资源导致其他文件描述符的饥饿现象。</li>
</ul></li>
</ul>
<h6 id="epoll监听管道读描述符">5.3.4 epoll监听管道读描述符</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建无名管道,fd[0]为读，fd[1]为写</span></span><br><span class="line">	<span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> ret =<span class="built_in">pipe</span>(fd);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建epoll,fd[0]上树</span></span><br><span class="line">	<span class="type">int</span> epollfd=<span class="built_in">epoll_create</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="keyword">if</span>(epollfd&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;epoll&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">	ev.events=EPOLLIN;</span><br><span class="line">	ev.data.fd=fd[<span class="number">0</span>];</span><br><span class="line">	ret=<span class="built_in">epoll_ctl</span>(epollfd,EPOLL_CTL_ADD,fd[<span class="number">0</span>],&amp;ev);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>!=ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//监听数组</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> change fd[<span class="number">64</span>];</span><br><span class="line">	<span class="comment">//创建子进程</span></span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>==pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//子进程</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="type">int</span> m=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">			<span class="built_in">write</span>(fs[<span class="number">1</span>],buf,m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//epoll监听</span></span><br><span class="line">		<span class="type">int</span> nfds=<span class="built_in">epoll_wait</span>(epollfd,change_fd,<span class="number">3</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">-1</span>==nfds)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(change_fd[i].data.fd==fd[<span class="number">0</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">				<span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="epoll应用于服务器">5.3.5 epoll应用于服务器</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcnlt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建套接字，绑定</span></span><br><span class="line">	<span class="type">int</span> lfd=<span class="built_in">tec4bind</span>(<span class="number">8000</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	<span class="built_in">Listen</span>(lfd,<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//创建epoll句柄</span></span><br><span class="line">	<span class="type">int</span> epfd=<span class="built_in">epoll_create</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//将lfd上述</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev,evs[<span class="number">1024</span>;</span><br><span class="line">	ev.data.fd=lfd;</span><br><span class="line">	ev.events=EPOLLIN;</span><br><span class="line">	<span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);</span><br><span class="line">	<span class="comment">//while监听</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> nready=<span class="built_in">epoll_wait</span>(epfd,evs,<span class="number">1024</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-----epoll_wait-----\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(nready&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;epoll_wait failed\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(nready==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//文件描述符有变化</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nready;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//判断lfd变化，并且时读事件变化</span></span><br><span class="line">				<span class="keyword">if</span>(evs[i].data.fd==lfd&amp;&amp;evs[i].events&amp;EPOLLIN)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">					<span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">					<span class="type">socklen_t</span> len=<span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">					<span class="comment">//提取新连接</span></span><br><span class="line">					<span class="type">int</span> cfd=<span class="built_in">Accepet</span>(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);	</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;new connect from ip:%s port:%d\n&quot;</span>,</span><br><span class="line">					<span class="built_in">inet_ntop</span>(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,<span class="number">16</span>),</span><br><span class="line">					<span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line">					<span class="comment">//设置cfd为非阻塞</span></span><br><span class="line">					in flags=<span class="built_in">fcnlt</span>(cfd,F_GETFL);	<span class="comment">//获取cfd的标志位</span></span><br><span class="line">					flags|=O_NONBLOCK;</span><br><span class="line">					<span class="built_in">fcnlt</span>(cfd,F_SETFL,flags);</span><br><span class="line">					<span class="comment">//将cfd上树且为边缘触发</span></span><br><span class="line">					ev.data.fd=cfd;</span><br><span class="line">					ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">					<span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(evs[i].events&amp;EPOLLIN)&#123;</span><br><span class="line">					<span class="comment">//cdf发生变化</span></span><br><span class="line">					<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">						<span class="type">int</span> n=<span class="built_in">read</span>(evs[i].data.fd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">						<span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="comment">//出错</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">//若缓存区是无数据的，跳出while，继续监听</span></span><br><span class="line">							<span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							<span class="comment">//普通错误,cfd该下树</span></span><br><span class="line">							<span class="built_in">perror</span>(<span class="string">&quot;else error\n&quot;</span>);</span><br><span class="line">							<span class="built_in">close</span>(evs[i].data.fd);	<span class="comment">//关闭cfd</span></span><br><span class="line">							<span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&amp;evs[i]);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="comment">//客户端关闭</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="built_in">printf</span>(<span class="string">&quot;client close\n&quot;</span>);</span><br><span class="line">							<span class="built_in">close</span>(evs[i].data.fd);	<span class="comment">//关闭cfd</span></span><br><span class="line">							<span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&amp;evs[i]);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span>&#123;</span><br><span class="line">							<span class="built_in">write</span>(STDIN_FILENO,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">							<span class="built_in">write</span>(evs[i].data.fd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="epoll反应堆">6 epoll反应堆</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/19/C-%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/19/C-%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">C++并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-19 09:57:24 / 修改时间：12:00:51" itemprop="dateCreated datePublished" datetime="2023-02-19T09:57:24+08:00">2023-02-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/02/19/C-%E5%B9%B6%E5%8F%91/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/02/19/C-%E5%B9%B6%E5%8F%91/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Linux系统编程-线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-18 10:14:24" itemprop="dateCreated datePublished" datetime="2023-02-18T10:14:24+08:00">2023-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 13:38:47" itemprop="dateModified" datetime="2023-02-21T13:38:47+08:00">2023-02-21</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="线程熟悉">1 线程（熟悉）</h4>
<ul>
<li><p><strong>进程：</strong>程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。因此程序是静态的，进程是动态的。是CPU分配资源的最小单位</p></li>
<li><p><strong>线程：</strong>线程（thread）是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。线程是CPU调度的最小单位</p></li>
</ul>
<h5 id="进程和线程的区别">1.1 进程和线程的区别</h5>
<ul>
<li><p><strong>进程</strong>，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源，所以我们也说，进程是CPU分配资源的最小单位。</p></li>
<li><p><strong>线程：</strong>线程存在与进程当中(进程可以认为是线程的容器)，<strong>线程是操作系统调度执行的最小单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源，共享全局内存区域，包括初始话数据段data、未初始化数据段bss和堆内存段。（是为避免进程fork()产生写时拷贝的不必要时间和内存支出）</strong> <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread.png" width="400"></p></li>
<li><strong>关系：</strong>
<ul>
<li>一个进程可有多个线程</li>
<li>进程间的共享数据要依靠进程间通信工具，而线程在共享的全局内存区域很容易实现数据共享</li>
<li>进程比线程消耗更多的计算机资源</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>进程间不会相互影响，而一个线程挂掉将导致整个进程挂掉</li>
</ul></li>
</ul>
<h5 id="线程概览">1.2 线程概览</h5>
<p>POSIX C的线程库<code>pthread</code>API定义了一干数据类型，下面列出了其中的一部分： <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/typeofpthread.png" width="500"> 进程可蜕变为线程。实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数<code>clone</code>。</p>
<ul>
<li>** Ø 如果复制对方的地址空间，那么就产出一个“进程”；---&gt;深拷贝**</li>
<li>** Ø 如果共享对方的地址空间，就产生一个“线程”。---&gt;浅拷贝**</li>
</ul>
<p>Linux内核是不区分进程和线程的, 只在用户层面上进行区分。所以，线程所有操作函数<code>pthread_*</code>是库函数，而非系统调用。</p>
<ul>
<li><strong>线程共享资源包括有：</strong>
<ul>
<li><ol type="1">
<li>文件描述符表</li>
</ol></li>
<li><ol start="2" type="1">
<li>每种信号的处理方式</li>
</ol></li>
<li><ol start="3" type="1">
<li>当前工作目录</li>
</ol></li>
<li><ol start="4" type="1">
<li>用户ID和组ID</li>
</ol></li>
<li>5）内存地址空间<code>(.text/.data/.bss/heap/共享库)</code></li>
</ul></li>
<li><strong>线程非共享资源:</strong>
<ul>
<li><ol type="1">
<li>线程id</li>
</ol></li>
<li><ol start="2" type="1">
<li>处理器现场和栈指针(内核栈)</li>
</ol></li>
<li><ol start="3" type="1">
<li>独立的线程栈空间(用户空间栈)</li>
</ol></li>
<li><ol start="4" type="1">
<li>errno变量</li>
</ol></li>
<li><ol start="5" type="1">
<li>信号屏蔽字</li>
</ol></li>
<li><ol start="6" type="1">
<li>调度优先级</li>
</ol></li>
</ul></li>
</ul>
<p><strong><em>注：</em></strong>Linux中系统调用的错误都存储于<code>errno</code>中，<code>errno</code>由操作系统维护是一个全局整型变量，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。<strong><code>errno</code>是一个包含在<code>&lt;errno.h&gt;</code>中的预定义的外部int变量，用于表示最近一个函数调用是否产生了错误</strong>。但是显然，<code>errno</code>在多线程上会发生竞争，因此为适应多线程，各个线程独立拥有<code>errno</code>。简言概之，就是errno机制在保留Linux的报错方式同时，也是适应了多线程环境。</p>
<h5 id="线程优缺点">1.3 线程优缺点</h5>
<ul>
<li><strong>优点：</strong>
<ul>
<li>Ø 提高程序并发性。</li>
<li>Ø 开销小，共享全局内存区域</li>
<li>Ø 数据通信、共享数据方便</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>Ø 库函数，不稳定</li>
<li>Ø 调试、编写困难、gdb不支持</li>
<li>Ø 对信号支持不好</li>
</ul></li>
</ul>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。 <strong><em>注意：gcc编译时要链接 -pthread</em></strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="number">5</span>pthread_self.c -pthread</span><br></pre></td></tr></table></figure></p>
<h5 id="线程常用api">1.4 线程常用API</h5>
<h6 id="pthread_self获取线程号">1.4.1 pthread_self：获取线程号</h6>
<p>线程号只在它所属的进程环境中有效。一般来说应把<code>pthread_t</code>当作一结构体，而不是整型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/*功能：</span></span><br><span class="line"><span class="comment">	获取线程号</span></span><br><span class="line"><span class="comment">	返回值：调用线程的线程ID</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h6 id="pthread_equal线程号比较">1.4.2 pthread_equal：线程号比较</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1,<span class="type">pthread_t</span> t2)</span></span>;</span><br><span class="line"><span class="comment">/*功能：</span></span><br><span class="line"><span class="comment">	判断线程号t1、t2是否相等，</span></span><br><span class="line"><span class="comment">	返回值：相等为非0，不等为0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h6 id="pthread_create线程创建">1.4.3 pthread_create:线程创建</h6>
<p>在一个线程中调用<code>pthread_create()</code>创建新的线程后，当前线程从<code>pthread_create()</code>返回继续往下执行，而新的线程所执行的代码由我们传给<code>pthread_create</code>的函数指针<code>start_routine</code>决定。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_create.png" width="600"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_fun</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> num=*((<span class="type">int</span> *)arg);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;int the new thread:num=%d\n&quot;</span>,num);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="type">int</span> test =<span class="number">100</span>;</span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid,<span class="literal">NULL</span>,thread_fun,(<span class="type">void</span>*)&amp;test);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error number:%d\n&quot;</span>,ret);</span><br><span class="line">		<span class="comment">//根据错误信号打印错误信息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error information:%s\n&quot;</span>,<span class="built_in">strerror</span>(ret));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong><em>注：注：由于<code>pthread_create</code>的错误码不保存在<code>errno</code>中，因此不能直接用<code>perror()</code>打印错误信息，可以先用<code>strerror()</code>把错误码转换成错误信息再打印。</em></strong></p>
<h6 id="pthread_join线程资源回收">1.4.4 pthread_join线程资源回收</h6>
<p><strong>调用该函数的线程将挂起等待，直到id为tid的线程终止</strong>。tid线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</p>
<ul>
<li><ol type="1">
<li>如果<code>tid</code>线程通过return返回，<code>retval</code>所指向的单元里存放的是<code>tid</code>线程函数的返回值。</li>
</ol></li>
<li><ol start="2" type="1">
<li>如果<code>thread</code>线程被别的线程调用<code>pthread_cancel</code>异常终止掉，<code>retval</code>所指向的单元里存放的是常数PTHREAD_CANCELED。</li>
</ol></li>
<li><ol start="3" type="1">
<li>如果<code>thread</code>线程是自己调用<code>pthread_exit</code>终止的，<code>retval</code>所指向的单元存放的是传给<code>pthread_exit</code>的参数。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_join.png" width="600"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">thead</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num =<span class="number">123</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;after 2 seconds, thread will return\n&quot;</span>);</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> &amp;num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="type">void</span> * value=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;tid,<span class="literal">NULL</span>,thread_fun,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//等待线程号为tid的线程，如果此线程结束就回收其资源</span></span><br><span class="line">	<span class="comment">//&amp;value保存线程退出的返回值</span></span><br><span class="line">	<span class="built_in">pthread_join</span>(tid,&amp;value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value=%d\n&quot;</span>,*(<span class="type">int</span>*)value);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
<h6 id="pthread_detach线程分离">1.4.5 pthread_detach:线程分离</h6>
<p><strong>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态</strong></p>
<p>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_detach.png" width="600"></p>
<h6 id="pthread_exit线程退出">1.4.6 pthread_exit线程退出</h6>
<p>在进程中我们可以调用exit函数或_exit函数来结束进程，在一个线程中我们可以通过以下三种在不终止整个进程的情况下停止它的控制流。</p>
<ul>
<li>线程从执行函数中返回。</li>
<li>线程调用<code>pthread_exit</code>退出线程。</li>
<li>线程可以被同一进程中的其它线程取消。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_exit.png" width="600"></li>
</ul>
<h6 id="pthread_cancle">1.4.7 pthread_cancle</h6>
<p>线程的取消并不是实时的，而又一定的延时。需要等待线程到达某个取消点(检查点)。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：杀死线程</span></span><br><span class="line"><span class="comment">参数：thread:目标线程ID</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功：0</span></span><br><span class="line"><span class="comment">	失败：错误编号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure> <strong>取消点：</strong>是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write..... 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。可粗略认为一个系统调用(进入内核)即为一个取消点。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/quxiao.png" width="600"></p>
<h5 id="线程属性">1.5 线程属性</h5>
<p>Linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。</p>
<p>如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/shuxing.png" width="600"> <strong>主要结构体成员：</strong></p>
<ul>
<li><ol type="1">
<li>线程分离状态</li>
</ol></li>
<li><ol start="2" type="1">
<li>线程栈大小（默认平均分配）</li>
</ol></li>
<li><ol start="3" type="1">
<li>线程栈警戒缓冲区大小（位于栈末尾）</li>
</ol></li>
<li><ol start="4" type="1">
<li>线程栈最低地址</li>
</ol></li>
</ul>
<p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为<code>pthread_attr_init</code>，这个函数必须在<code>pthread_create</code>函数之前调用。之后须用<code>pthread_attr_destroy</code>函数来释放资源。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_attr.png" width="600"></p>
<h6 id="线程分离状态">1.5.1 线程分离状态</h6>
<p><strong>线程的分离状态决定一个线程以什么样的方式来终止自己。</strong></p>
<ul>
<li><p><strong>非分离状态</strong>：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</p></li>
<li><p><strong>分离状态</strong>：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/fengli.png" width="600"></p></li>
</ul>
<h4 id="线程同步之互斥锁">2. 线程同步之互斥锁</h4>
<p>在多核CPU中，同时运行的多个任务可能：</p>
<ul>
<li>都需要访问/使用同一种资源，但对该资源操作不是原子操作，可能出现不可预知的错误</li>
<li>多个任务之间有依赖关系，某个任务的运行依赖于另一个任务</li>
</ul>
<p><strong>同步和互斥就是用于解决这两个问题的。</strong></p>
<ul>
<li><p><strong>互斥：是指散步在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行</strong>。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</p></li>
<li><p><strong>同步：是指散步在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。</strong>最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。</p></li>
</ul>
<h5 id="互斥锁保护对共享变量的访问">2.1 互斥锁：保护对共享变量的访问</h5>
<p>在上面我们介绍过线程的<strong>主要优势就是能通过全局变量来共享信息，但是必须保证多个线程不会同时修改同一变量或者某一线程不会读取正由其他线程修改的变量</strong>。临界区即指访问某一共享资源代码片段时，这段代码片段的执行应为<strong>原子操作，即其他线程不能终止该片段执行</strong>，否则在没有进行互斥机制下会出错： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> glob=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> loops =*((<span class="type">int</span>*)arg);</span><br><span class="line">	<span class="type">int</span> loc,j;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;loops;j++)&#123;</span><br><span class="line">		loc=glob;</span><br><span class="line">		loc++;</span><br><span class="line">		glob=loc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,cahr* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> t1,t2;</span><br><span class="line">	<span class="type">int</span> loops,s;</span><br><span class="line">	loops=<span class="number">10000</span>;</span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">NULL</span>,threadFunc,&amp;loops);</span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">NULL</span>,threadFunc,&amp;loops);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;glob=%d\n&quot;</span>,glob);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>上述代码中<code>glob</code>按正常来说应该输出为20000，但是输出却是少于这个数的，就是因为多线程对共享区域执行非原子操作时出现的问题，必须使用互斥量</strong></p>
<p>线程里有这么一把锁叫互斥锁（<code>mutex</code>），也叫互斥量，互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即加锁(<code>lock</code>)和解锁(<code>unlock</code>)。互斥锁的操作流程如下：</p>
<ul>
<li>1）在访问共享资源后临界区域前，对互斥锁进行加锁。</li>
<li>2）在访问完成后释放互斥锁导上的锁。</li>
<li>3）对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。</li>
</ul>
<p>互斥锁的数据类型是： <code>pthread_mutex_t</code></p>
<h5 id="互斥锁常用函数">2.2 互斥锁常用函数</h5>
<h6 id="pthread_mutex_init函数初始化一个互斥锁">2.2.1 pthread_mutex_init()函数：初始化一个互斥锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_mutex_init.png" width="600"> <strong><em><code>restrict</code>，C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</em></strong></p>
<h6 id="pthread_mutex_destroy函数销毁互斥锁">2.2.2 pthread_mutex_destroy函数:销毁互斥锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_mutex_destroy.png" width="600"></p>
<h6 id="pthread_mutex_lock函数上锁">2.2.3 pthread_mutex_lock函数：上锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_mutex_lock.png" width="600"></p>
<h6 id="pthread_mutex_unlock函数解锁">2.2.4 pthread_mutex_unlock函数：解锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_mutex_unlock.png" width="600"></p>
<h6 id="示例打印机">2.2.5 示例：打印机</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;		<span class="comment">//互斥量</span></span><br><span class="line"><span class="comment">//打印机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printer</span><span class="params">(<span class="type">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);		<span class="comment">//上锁</span></span><br><span class="line">	<span class="keyword">while</span>(*str!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(*str);</span><br><span class="line">		<span class="built_in">fflush</span>(stdout);</span><br><span class="line">		str++;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);	<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程一</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread_fun_1</span><span class="params">(<span class="type">void</span>*arg)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str =<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="built_in">printer</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程二</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread_fun_2</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">	<span class="built_in">printer</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> t1,t2;</span><br><span class="line">	<span class="comment">//初始化一个互斥锁</span></span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//创建两个线程，处理函数分别为thread_fun_1\thread_fun_2</span></span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">NULL</span>,thread_fun_1,<span class="literal">NULL</span>);</span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">NULL</span>,thread_fun_2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="死锁">2.3 死锁</h5>
<p><strong>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</strong></p>
<h6 id="死锁引起的原因">2.3.1 死锁引起的原因</h6>
<ul>
<li><strong>竞争不可抢占资源引起死锁（</strong>不可抢占是指没有使用完的资源，不能被抢占）</li>
<li><strong>竞争可消耗资源引起死锁</strong>：有p1，p2，p3三个进程，p1向p2发送消息并接受p3发送的消息，p2向p3发送消息并接受p1的消息，p3向p1发送消息并接受p2的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成死锁。</li>
<li><strong>进程推进顺序不当引起死锁</strong>：有进程p1，p2，都需要资源A，B，本来可以p1运行A --&gt; p1运行B --&gt; p2运行A --&gt; p2运行B，但是顺序换了，p1运行A时p2运行B，容易发生第一种死锁。互相抢占资源。</li>
</ul>
<h6 id="死锁的必要条件">2.3.2 死锁的必要条件</h6>
<ul>
<li><strong>互斥条件：</strong>某资源只能被一个进程使用，其他进程请求该资源时，只能等待，直到资源使用完毕后释放资源。</li>
<li><strong>请求和保持条件</strong>：程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。</li>
<li><strong>不可抢占条件：</strong>进程已获得的资源没有使用完，不能被抢占。</li>
<li><strong>循环等待条件：</strong>必然存在一个循环链。</li>
</ul>
<h6 id="预防死锁的思路">2.3.3 预防死锁的思路</h6>
<ul>
<li><strong>预防死锁：</strong>破坏死锁的四个必要条件中的一个或多个来预防死锁。</li>
<li><strong>避免死锁</strong>：和预防死锁的区别就是，在资源动态分配过程中，用某种方式防止系统进入不安全的状态。</li>
<li><strong>检测死锁</strong>：运行时出现死锁，能及时发现死锁，把程序解脱出来</li>
<li><strong>解除死锁</strong>：发生死锁后，解脱进程，通常撤销进程，回收资源，再分配给正处于阻塞状态的进程。</li>
</ul>
<h6 id="预防死锁的方法">2.3.4 预防死锁的方法</h6>
<ul>
<li><strong>破坏请求和保持条件</strong>
<ul>
<li><strong>协议1：</strong>所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生。</li>
<li><strong>协议2：</strong>允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来。然后再请求新的资源。</li>
</ul></li>
<li><p>** 破坏不可抢占条件**：当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请 。</p></li>
<li><p><strong>破坏循环等待条件：</strong>对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</p></li>
</ul>
<h4 id="线程同步之读写锁">3 线程同步之读写锁</h4>
<p>实际上多个线程同时读访问共享资源并不会导致问题。但互斥锁的排他性，导致其它进程或线程无法读取，为克服这个缺陷，就引入了读写锁。 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了<strong>读写锁</strong>来实现。</p>
<h5 id="读写锁的特点">3.1 读写锁的特点</h5>
<ul>
<li>1）如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。</li>
<li>2）如果有其它线程写数据，则其它线程都不允许读、写操作。</li>
</ul>
<p><strong>读写锁分为读锁和写锁，规则如下：</strong></p>
<ul>
<li>1）如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁。</li>
<li>2）如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁。</li>
</ul>
<p>POSIX 定义的读写锁的数据类型是： <code>pthread_rwlock_t</code></p>
<h5 id="读写锁常用函数">3.2 读写锁常用函数</h5>
<h6 id="pthread_rwlock_init函数初始化读写锁">3.2.1 pthread_rwlock_init函数：初始化读写锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_rwlock_init.png" width="600"></p>
<h6 id="pthread_rwlock_destroy函数销毁读写锁">3.2.2 pthread_rwlock_destroy函数：销毁读写锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_rwlock_destroy.png" width="600"></p>
<h6 id="pthread_rwlock_rdlock函数在读写锁上获取读锁">3.2.3 pthread_rwlock_rdlock函数：在读写锁上获取读锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_rwlock_rdlock.png" width="600"></p>
<h6 id="pthread_rwlock_wrlock函数获取写锁">3.2.4 pthread_rwlock_wrlock函数：获取写锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_rwlock_wrlock.png" width="600"></p>
<h5 id="pthread_rwlock_unlock函数解锁">3.2.5 pthread_rwlock_unlock函数：解锁</h5>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_rwlock_unlock.png" width="600"></p>
<h4 id="线程同步之条件变量">4 线程同步之条件变量</h4>
<p><strong>与互斥锁不同，条件变量是用来等待而不是用来上锁的，条件变量本身不是锁！条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。条件变量就共享变量的状态改变发出通知，而互斥量则提供对该共享变量访问的互斥</strong>。条件变量的类型: <code>pthread_cond_t</code></p>
<p>条件变量的两个动作：</p>
<ul>
<li>条件不满, 阻塞线程</li>
<li>当条件满足, 通知阻塞的线程开始工作</li>
</ul>
<p><strong>条件变量的优点是相较于mutex而言，条件变量可以减少竞争提升效率。如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，且如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的还会浪费CPU资源。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</strong></p>
<h5 id="条件变量常用函数">4.1 条件变量常用函数</h5>
<h6 id="pthread_cond_init函数初始化条件变量">4.1.1 pthread_cond_init函数：初始化条件变量</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_cond_init.png" width="600"></p>
<h6 id="pthread_cond_destroy函数销毁条件变量">4.1.2 pthread_cond_destroy函数：销毁条件变量</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_cond_destroy.png" width="600"></p>
<h6 id="pthread_cond_wait函数阻塞等待">4.1.3 pthread_cond_wait函数：阻塞等待</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_cond_wait.png" width="600"> <strong>abstime补充说明：</strong> <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/abstime.png" width="600"></p>
<h6 id="pthread_cond_signal函数唤醒至少一个阻塞在条件变量上的线程">4.1.4 pthread_cond_signal函数：唤醒至少一个阻塞在条件变量上的线程</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_cond_signal.png" width="600"></p>
<h5 id="示例生产者消费者模型">4.2 示例：生产者消费者模型</h5>
<p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。 <strong>假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//永远指向链表头部的指针</span></span><br><span class="line">Node* head=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//线程同步-互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">//阻塞线程-条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//创建一个链表的节点</span></span><br><span class="line">		Node* pnew =(Node*)<span class="built_in">malloc</span>(<span class="built_in">seziof</span>(Node));</span><br><span class="line">		<span class="comment">//节点初始化</span></span><br><span class="line">		pnew-&gt;data=<span class="built_in">rand</span>()%<span class="number">1000</span>;</span><br><span class="line">		<span class="comment">//使用互斥锁保护共享数据</span></span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">		pnew-&gt;next=head;</span><br><span class="line">		head=pnew;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;=====produce:%lu,%d\n&quot;</span>,<span class="built_in">pthread_self</span>(),pnew-&gt;data);</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//通知条件变量阻塞线程，解除阻塞</span></span><br><span class="line">		<span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="built_in">rand</span>()%<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">customer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">		<span class="comment">//判断链表是否为空，空则阻塞等待</span></span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//线程阻塞，释放互斥锁</span></span><br><span class="line">			<span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex);</span><br><span class="line">			<span class="comment">//解除阻塞后，对互斥锁进行加锁</span></span><br><span class="line">		&#125;</span><br><span class="line">		Node* pdel=head;</span><br><span class="line">		head=head-&gt;next;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----customer:%lu,&amp;d\n&quot;</span>,<span class="built_in">pthread_self</span>(),pdel-&gt;data);</span><br><span class="line">		<span class="built_in">free</span>(pdel);</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数入口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> p1,p2;</span><br><span class="line">	<span class="comment">//init</span></span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_cond_init</span>(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//创建生产者线程</span></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;p1,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//消费者线程</span></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;p2,<span class="literal">NULL</span>,customer,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//阻塞回收子线程</span></span><br><span class="line">	<span class="built_in">pthread_join</span>(p1,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_join</span>(p2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//销毁互斥锁、条件变量</span></span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">	<span class="built_in">pthread_mutex_destory</span>(&amp;cond);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="信号量">5 信号量</h4>
<p>在进程模块我们已经介绍了POSIX信号量，这里我们再做一次介绍。</p>
<ul>
<li><p><strong>信号量广泛用于进程或线程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号量值大于 0 时，则可以访问，否则将阻塞。</strong></p></li>
<li><p>PV原语是对信号量的操作，一次 P 操作使信号量减１，一次 V 操作使信号量加１。信号量主要用于进程或线程间的同步和互斥这两种典型情况。</p></li>
<li><p>信号量数据类型为：sem_t</p></li>
</ul>
<h5 id="信号量用于同步和互斥">5.1 信号量用于同步和互斥</h5>
<p>信号量可用于同步和互斥情况，其用于两种环境分别如下所示：</p>
<ul>
<li>互斥 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/signal_mutex.png" width="400"></li>
<li>同步 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/signal_sync.png" width="400"></li>
</ul>
<h5 id="未命名信号量常用函数">5.2 未命名信号量常用函数</h5>
<h6 id="sem_init函数初始化">5.2.1 sem_init函数：初始化</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/sem_init.png" width="600"></p>
<h6 id="sem_destroy函数销毁">5.2.2 sem_destroy函数：销毁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/sem_destroy.png" width="600"></p>
<h6 id="sem_wait函数信号量p操作减1">5.2.3 sem_wait函数：信号量p操作减1</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/sem_wait.png" width="600"> <code>abs_timeout</code>补充说明： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span>&#123;</span><br><span class="line">	<span class="type">time_t</span> tv_sec;		<span class="comment">//秒</span></span><br><span class="line">	<span class="type">long</span> tv_nsec;		<span class="comment">//纳秒</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="type">time_t</span> cur=<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> t;</span><br><span class="line">t.tv_sec=cur+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">sem_timedwait</span>(&amp;cond,&amp;t);</span><br></pre></td></tr></table></figure></p>
<h6 id="sem_post函数信号量v操作">5.2.4 sem_post函数：信号量v操作</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/sem_post.png" width="600"></p>
<h6 id="sem_getvalue获取信号量的值">5.2.5 sem_getvalue:获取信号量的值</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/sem_getvalue.png" width="600"></p>
<h5 id="示例打印机-1">5.3 示例：打印机</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;		<span class="comment">//信号量</span></span><br><span class="line"><span class="comment">//打印机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printer</span><span class="params">(<span class="type">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="built_in">sem_wait</span>(&amp;sem);		<span class="comment">//上锁</span></span><br><span class="line">	<span class="keyword">while</span>(*str!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(*str);</span><br><span class="line">		<span class="built_in">fflush</span>(stdout);</span><br><span class="line">		str++;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">sem_post</span>(&amp;sem);	<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程一</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread_fun_1</span><span class="params">(<span class="type">void</span>*arg)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str =<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="built_in">printer</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程二</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread_fun_2</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">	<span class="built_in">printer</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> t1,t2;</span><br><span class="line">	<span class="comment">//初始化一个未命名信号量,在线程间使用，初始值为1</span></span><br><span class="line">	<span class="built_in">sem_init</span>(&amp;sem,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//创建两个线程</span></span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">NULL</span>,thread_fun_1,<span class="literal">NULL</span>);</span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">NULL</span>,thread_fun_2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自旋锁">6 自旋锁</h4>
<ul>
<li>自旋锁：<code>spinlock</code>，<strong>在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。 </strong></li>
</ul>
<h4 id="线程安全">7 线程安全</h4>
<ul>
<li><strong>线程安全</strong>：当一个执行区域可供多个线程同时执行，没有出现错误时，我们成为线程安全的。换句话说就是函数可同时供多个线程同时调用，则为线程安全函数。</li>
</ul>
<p>下面代码就不是线程安全，因为当多个线程并发调用该函数时，<code>glob</code>的最终值不得而知，<strong>通常出现线程不安全的原因是因为使用了全局或静态变量</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> glob=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> loops =*((<span class="type">int</span>*)arg);</span><br><span class="line">	<span class="type">int</span> loc,j;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;loops;j++)&#123;</span><br><span class="line">		loc=glob;</span><br><span class="line">		loc++;</span><br><span class="line">		glob=loc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在多线程中保证线程安全的方法有：</p>
<ul>
<li>仅在函数中操作共享变量的代码前后加入互斥量，这样能实现大部分的线程安全；但由于互斥锁的加、解锁开销，也就带来了性能的下降。</li>
<li>如果能避免使用全局或静态变量，可重入函数则无需使用互斥量即可实现线程安全</li>
<li>对于单核CPU时，只需要保证对共享变量是原子操作即可保证线程安全；但多核CPU，则不行</li>
</ul>
<h5 id="可重入不不可重入">7.1 可重入不不可重入</h5>
<ul>
<li><p><strong>不可重入函数：</strong>不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数。如使用了静态的数据解够、malloc()和free、以及标准的I/O函数（因为带缓冲区）都是不可重入函数。</p></li>
<li><p><strong>可重入函数</strong>：函数在被多个进程调度时，不必担心数据出错</p></li>
<li><strong>保证函数的可重入性的方法：</strong>
<ul>
<li>在写函数时候尽量使用局部变量（例如寄存器、栈中的变量）；</li>
<li>对于要使用的全局变量要加以保护（如采取关中断、信号量等互斥方法），这样构成的函数就一定是一个可重入的函数。</li>
</ul></li>
</ul>
<h4 id="线程池">8 线程池</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Linux系统编程_进程线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-16 15:20:41" itemprop="dateCreated datePublished" datetime="2022-12-16T15:20:41+08:00">2022-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-19 14:38:54" itemprop="dateModified" datetime="2023-02-19T14:38:54+08:00">2023-02-19</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="进程概念">1 进程概念</h4>
<h5 id="进程和线程的区别">1.1 进程和线程的区别</h5>
<ul>
<li><strong>进程：</strong>程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。程序是静态的，进程是动态的。是CPU分配资源的最小单位</li>
<li><strong>线程：</strong>线程（thread）是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。线程是CPU调度的最小单位</li>
</ul>
<p><strong>关系：</strong></p>
<ul>
<li>一个进程可有多个线程</li>
<li>进程间很难共享数据，线程很容易实现数据共享</li>
<li>进程比线程消耗更多的计算机资源</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li><p>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉</p></li>
<li><p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源，所以我们也说，进程是CPU分配资源的最小单位。</p></li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>线程存在与进程当中(进程可以认为是线程的容器)，是操作系统调度执行的最小单位。说通俗点，线程就是干活的，轻量级进程。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。（是为避免进程fork()产生写时拷贝的不必要时间和内存支出） <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/memory.png" width="400"></li>
</ul>
<h5 id="并行和并发">1.2 并行和并发</h5>
<ul>
<li><strong>并行(parallel)</strong>：指在同一时刻，有多条指令在多个处理器上同时执行。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/parallel.png" width="400"></li>
<li><strong>并发(concurrency)：</strong>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/concurrency.png" width="400"></li>
</ul>
<h5 id="进程的状态">1.3 进程的状态</h5>
<p>在五态模型中，进程分为<strong>新建态、终止态，运行态，就绪态，阻塞态</strong>. <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/process.png" width="500"></p>
<ul>
<li><p><strong>创建状态：</strong>进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</p></li>
<li><p><strong>就绪状态</strong>：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行</p></li>
<li><p><strong>执行状态</strong>：进程处于就绪状态被调度后，进程进入执行状态</p></li>
<li><p><strong>阻塞状态</strong>：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用</p></li>
<li><p><strong>终止状态</strong>：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</p></li>
</ul>
<h5 id="孤儿进程和僵尸进程">1.4 孤儿进程和僵尸进程</h5>
<ul>
<li><p><strong>孤儿进程</strong>：父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程（Orphan Process）。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 <code>init</code> ，而 <code>init</code> 进程会循环地 <code>wait()</code> 它的已经退出的子进程。孤儿进程不会有什么危害。</p></li>
<li><p><strong>僵尸进程：</strong>进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。这样就会导致一个问题，如果进程不调用<code>wait()</code> 或 <code>waitpid()</code> 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用。因此一定要回收进程号。</p></li>
</ul>
<h6 id="避免僵尸进程的方法">1.4.1 避免僵尸进程的方法</h6>
<ul>
<li><strong>SIGCHID产生条件</strong>：
<ul>
<li>子进程终止时</li>
<li>子进程接收到SIGSTOP信号停止时</li>
<li>子进程处在停止态，接受到SIGCONT后唤醒时</li>
</ul></li>
<li><strong>避免方法</strong>
<ul>
<li>最简单的方法，父进程通过<code>wait()</code>和 <code>waitpid()</code> 等函数等待子进程结束，但是，这会导致父进程挂起。</li>
<li>如果父进程要处理的事情很多，不能够挂起，通过<code>signal()</code>函数人为处理信号 SIGCHLD ， 只要有子进程退出自动调用指定好的回调函数，因为子进程结束后， 父进程会收到该信号 SIGCHLD ，可以在其回调函数里调用<code>wait()</code>或<code>waitpid()</code>回收。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_child</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="comment">//处理僵尸进程，-1代表等待任意一个子进程，WNOHANG代表不阻塞</span></span><br><span class="line">	<span class="keyword">while</span>((pid=<span class="built_in">waitpid</span>(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>,pid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//捕捉子进程退出信号，只有子进程退出，触犯SIGCHLD,自动调用sig_child</span></span><br><span class="line">	<span class="built_in">signal</span>(SIGCHLD,sig_child);</span><br><span class="line">	<span class="comment">//创建子进程，执行相应任务</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>交由内核处理</strong>：如果父进程不关心子进程什么时候结束，那么可以用<code>signal(SIGCHLD, SIG_IGN)</code>通知内核，自己对子进程的结束不感兴趣，父进程忽略此信号，那么子进程结束后，内核会回收，并不再给父进程发送信号。</li>
</ul></li>
</ul>
<h5 id="进程相关命令">1.5 进程相关命令</h5>
<h6 id="ps命令">1.5.1 ps命令</h6>
<p>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。<code>ps</code>命令可以查看进程的详细状况，常用选项(选项可以不加<code>“-”</code>)如下: <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/ps.png" width="600"></p>
<p>进程的状态表示： <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/status_ps.png" width="600"></p>
<h6 id="top命令">1.5.2 top命令</h6>
<p><code>top</code>命令用来动态显示运行中的进程。<code>top</code>命令能够在运行后，在指定的时间间隔更新显示信息。可以在使用<code>top</code>命令时加上<code>-d</code>来指定显示信息更新的时间间隔。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/top.png" width="600"></p>
<h6 id="kill命令">1.5.3 kill命令</h6>
<p><code>kill</code>命令指定进程号的进程，需要配合<code>ps</code>使用。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure> 信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。</p>
<h6 id="killall命令">1.5.4 killall命令</h6>
<p>通过进程名字杀死进程 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">killall [选项]  name</span><br><span class="line"><span class="meta"># killall -9 php-fpm          <span class="comment">//结束所有的 php-fpm 进程</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="进程函数">2 进程函数</h4>
<h5 id="进程号">2.1 进程号</h5>
<p>每个进程都要唯一标识号码，我们称为进程号，后续的许多工作我们都要使用到进程号来指定哪个进程。</p>
<ul>
<li>** 进程号（PID）：**标识进程的一个非负整型数。</li>
<li><strong>父进程号（PPID）</strong>：任何进程（ 除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。如，A 进程创建了 B 进程，A 的进程号就是 B 进程的父进程号。</li>
<li>** 进程组号（PGID）：**进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID） ，默认的情况下，当前的进程号会当做当前的进程组号</li>
</ul>
<h6 id="getpid函数">2.1.1 getpid函数</h6>
<p><code>getpdid</code>函数的作用是获取当前进程的进程号 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/getpid.png" width="600"></p>
<h6 id="getppid函数">2.1.2 getppid函数</h6>
<p><code>getppid</code>函数作用是获取当前调用该函数进程的父进程号。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/getppid.png" width="500"></p>
<h6 id="getpgid函数">2.1.3 getpgid函数</h6>
<p><code>getpgid</code>函数获取指定进程的进程组号 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/getpgid.png" width="600"></p>
<h5 id="进程创建">2.2 进程创建</h5>
<p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/fork.png" width="600"></p>
<h6 id="父子进程的关系">2.2.1 父子进程的关系</h6>
<p>使用<code>fork()</code>函数得到的子进程是父进程的一个复制品，它从父进程处拷贝整个进程的虚拟内存空间：<strong>包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。</strong>子进程所独有的只有它的<strong>进程号，计时器等（只有小量信息）</strong>。因此，使用 fork() 函数的代价是很大的。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/relations.png" width="400"></p>
<p><strong>幸运的是，Linux 的<code>fork()</code>使用是通过</strong>写时拷贝 (copy- on-write) *实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个内存地址空间。只用在需要写入的时候才会复制地址空间从而使各个进程拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享同一物理内存。** <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/writecopy.png" width="500"></p>
<p><code>fork</code>之后父子进程共享文件，<code>fork</code>产生的子进程与父进程具有相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件的偏移指针。(后面会讲到父子进程的地址空间)</p>
<h6 id="区分父子进程">2.2.2 区分父子进程</h6>
<p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样的。利用<code>fork()</code>函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是<code>0</code>，而父进程的返回值则是新子进程的进程<code>ID</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">		<span class="comment">//子进程</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;I am son\n&quot;</span>);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//父进程</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;I am father\n&quot;</span>);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 注意的是，在子进程的地址空间里，子进程是从 fork() 这个函数后才开始执行代码 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/runson.png" width="500"></p>
<h6 id="父子进程的地址空间">2.2.3 父子进程的地址空间</h6>
<p>父子进程各自的地址空间是独立的。通过上面的写时拷贝/读时共享机制介绍得知，在子进程修改变量 a，b 的值，并不影响到父进程 a，b 的值。（写时拷贝） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b= <span class="number">20</span>;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;son: a=%d, b=%d\n&quot;</span>,a,b); <span class="comment">//son: a=10，b=20</span></span><br><span class="line">		a=<span class="number">111</span>;</span><br><span class="line">		b=<span class="number">222</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;son: a=%d, b=%d\n&quot;</span>,a,b); <span class="comment">//son: a=111，b=222</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);	<span class="comment">//保证子进程先运行</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;father: a=%d, b=%d\n&quot;</span>,a,b);<span class="comment">//father: a=10，b=20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 同理，子进程睡眠，父进程写也是如此。<strong>堆区分配空间也一样，但要注意，要释放两次：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>==p)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc failed...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*p=<span class="number">200</span>;</span><br><span class="line">num=<span class="number">100</span>;</span><br><span class="line">var=<span class="number">88</span>;</span><br><span class="line">pid=fork();</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">	<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子进程睡醒之后 *p=%d&quot;</span> num=%d var=%d\n<span class="string">&quot;,*p,num,var); //200 100 88</span></span><br><span class="line"><span class="string">	free(p);</span></span><br><span class="line"><span class="string">	p=NULL;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else if(pid&gt;0)&#123;</span></span><br><span class="line"><span class="string">	printf(&quot;</span>父进程执行前：*p=%d<span class="string">&quot; num=%d var=%d\n&quot;</span>,*p,num,var);<span class="comment">//200 100 88</span></span><br><span class="line">	<span class="comment">//执行写入，会进行拷贝</span></span><br><span class="line">	var++;</span><br><span class="line">	num++;</span><br><span class="line">	*p++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;父进程执行后：*p=%d&quot;</span> num=%d var=%d\n<span class="string">&quot;,*p,num,var); //201 101 89</span></span><br><span class="line"><span class="string">	free(p);</span></span><br><span class="line"><span class="string">	p=NULL;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>2次分配，2次释放<code>（valgrind 查看)</code> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/malloc.png" width="500"></p>
<h5 id="进程退出">2.3 进程退出</h5>
<h6 id="进程退出函数">2.3.1 进程退出函数</h6>
<p><code>exit()</code>和<code>exit()</code>函数功能和用法是一样的，无非时所包含的头文件不一样，还有的区别就是：<code>exit()</code>属于标准库函数，<code>_exit()</code>属于系统调用函数。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/exit.png" width="600"></p>
<h6 id="等待子进程退出函数">2.3.2 等待子进程退出函数</h6>
<p><code>wait()</code> 和 <code>waitpid()</code> 函数的功能一样，区别在于，<code>wait()</code> 函数会阻塞，<code>waitpid()</code> 可以设置不阻塞，<code>waitpid()</code> 还可以指定等待哪个子进程结束。</p>
<ul>
<li><p>①wait函数 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/wait.png" width="600"> <strong>调用 <code>wait()</code> 函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒（相当于继续往下执行）</strong>。若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。所以，<code>wait()</code>函数的主要功能为回收已经结束子进程的资源。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">		<span class="comment">//子进程</span></span><br><span class="line">		<span class="type">int</span> i=<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">while</span>(i)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;I am son,i am doing something\n&quot;</span>);</span><br><span class="line">			i--;</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//子进程终止</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//父进程执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;I am waiting for son\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now,son has done all thing\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 对于<code>wait(&amp;status)</code>函数获取到的<code>status</code>状态，我们可使用已定义好的宏查看其子进程返回的是什么状态(分为三种）：</p>
<ul>
<li><ol type="1">
<li><code>WIFEXITED(status)</code>：判断进程是否正常结束，若正常结束；使用此宏<code>WEXITSTATUS(status)</code>获取进程退出状态 (exit的参数)</li>
</ol></li>
<li><ol start="2" type="1">
<li><code>WIFSIGNALED(status)</code>：判断进程是否异常终止，若是；使用此宏<code>WTERMSIG(status)</code>取得使进程终止的那个信号的编号。</li>
</ol></li>
<li><ol start="3" type="1">
<li><code>WIFSTOPPED(status)</code>:判断进程是否处于暂停状态，若是；使用此宏<code>WSTOPSIG(status)</code>取得使进程暂停的那个信号的编号。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子进程退出状态码：%d\n&quot;</span>,<span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">WIFSIGNALED</span>(status))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子进程被信号%d杀死了\n&quot;</span>,<span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">WIFSTOPPED</span>(status))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子进程被信号%d暂停了\n&quot;</span>,<span class="built_in">WSTOPSIG</span>(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul></li>
<li><p>②waitpid函数 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/waitpid.png" width="600"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父进程执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am waiting for son\n&quot;</span>);</span><br><span class="line">ret=<span class="built_in">waitpid</span>(<span class="number">-1</span>,&amp;status,WNOHANG);</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="进程替换">2.3.3 进程替换</h6>
<p>Linux 平台，我们可以通过<code>./</code> 运行，让一个可执行程序成为一个进程。但是，如果我们本来就运行着一个程序（进程），我们如何在这个进程内部启动一个外部程序，由内核将这个外部程序读入内存，使其执行起来成为一个进程？这里我们通过 <code>exec</code> 函数族实现。</p>
<p><code>exec</code> 指的是一组函数，一共有 6个 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/exec.png" width="600"></p>
<ul>
<li><strong>其中只有 <code>execve()</code> 是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</strong></li>
<li><code>exec</code>函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</li>
<li>进程调用一种 <code>exec</code>函数时，该进程完全由新程序替换，而新程序则从其<code>main</code>函数开始执行。因为调用 <code>exec</code> 并不创建新进程，所以前后的进程 ID （当然还有父进程号、进程组号、当前工作目录……）并未改变。<code>exec</code> 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换）。</li>
</ul>
<h4 id="进程间通信重要">3 进程间通信(重要)</h4>
<p>进程间通信主要包括管道、FIFO、系统IPC（消息队列、共享内存、信号量）、Socket、；进程同步主要有信号量、文件锁、互斥锁、条件变量； <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/IPC.png" width="500"></p>
<h5 id="通信方式的选择">3.1 通信方式的选择</h5>
<p>要依据应用选择进程间的通信方式，就必须了解各个进程通信方式的特点。在数据传输工具当中，有几点要注意：</p>
<ul>
<li>一些数据传输工具主要以字节流形式传输(如管道、流socket、FIFO)，另一些则是面向消息的(如消息队列、数据报socket)。</li>
<li>System V和POSIX消息队列特有的一个特性就是它们能够给消息赋一个数值类型或优先级，这样传递消息的顺序可以与发生消息的顺序不同了。</li>
<li>管道、FIFO、Socket使用文件描述符来实现，这样这些传输工具就能够使用I/O多路复用进行控制，而那些使用标识符的则无法使用该技术。（注意区分文件描述符和IPC标识符，文件描述符是一个进程特性，标识符则是对象的一个属性并且全局可见）</li>
<li>POSIX消息队列提供了一个通知工具，当一条消息进入一个之前为空的队列中时可以使用它来向进程发送信号或实例化一个新线程</li>
<li>管道、匿名内存映射等一些IPC工具只允许有关系的进程进行互相通信</li>
</ul>
<h5 id="管道">3.2 管道</h5>
<p>管道主要包括<strong>无名管道(pipe)和命名管道(FIFO)</strong>。</p>
<ul>
<li>无名管道：可用于具有亲缘关系的父子进程间的通信，</li>
<li>有名管道：除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</li>
</ul>
<h6 id="无名管道pipe">3.2.1 无名管道PIPE</h6>
<p>管道也叫无名管道，所有的 UNIX 系统都支持这种通信机制。 具有如下特点：</p>
<ul>
<li><ol type="1">
<li>半双工，数据在同一时刻只能在一个方向上流动。</li>
</ol></li>
<li><ol start="2" type="1">
<li>数据只能从管道的一端写入，从另一端读出。</li>
</ol></li>
<li><ol start="3" type="1">
<li>写入管道中的数据遵循先入先出的规则。</li>
</ol></li>
<li><ol start="4" type="1">
<li>管道所传送的数据是无格式的，它是字节流形式，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息等。</li>
</ol></li>
<li><ol start="5" type="1">
<li>管道不是普通的文件，不属于某个文件系统，其只存在于内存中。</li>
</ol></li>
<li><ol start="6" type="1">
<li>管道在内存中对应一个缓冲区，有其容量限制。不同的系统其大小不一定相同。</li>
</ol></li>
<li><ol start="7" type="1">
<li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据。</li>
</ol></li>
<li><ol start="8" type="1">
<li>管道没有名字，只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</li>
</ol></li>
<li>9）可以确保在多进程中，当写入数据量不超过PIPE_BUF时，写入<code>write</code>为原子操作，否则可能不是。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/pipe.png" width="600"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例：子进程通过无名管道给父进程传递一个字符串数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd_pipe[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">pipe</span>(fd_pipe)&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;create pipe failed..\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> buf[]=<span class="string">&quot;I am son&quot;</span>;</span><br><span class="line">		<span class="built_in">write</span>(fd_pipe[<span class="number">1</span>],buf,strlen[buf]);</span><br><span class="line">		_exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wait</span>(<span class="literal">NULL</span>);<span class="comment">//等待子进程结束，回收其资源</span></span><br><span class="line">		<span class="type">char</span> str[<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="built_in">read</span>(fd_pipe[<span class="number">0</span>],str,<span class="built_in">sizeof</span>(str));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str=[%s]\n&quot;</span>,str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>读写特点:</strong></li>
<li>读管道：
<ul>
<li>1、管道中有数据，read返回实际读到的字节数。</li>
<li>2、 管道中无数据：
<ul>
<li>管道写端被全部关闭，read返回0 (相当于读到文件结尾)</li>
<li>写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</li>
</ul></li>
</ul></li>
<li>写管道：
<ul>
<li>1、 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程终止)</li>
<li>2、 管道读端没有全部关闭：
<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ul></li>
</ul></li>
</ul>
<p><strong>设置非阻塞的方法：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先获取原来的flag</span></span><br><span class="line"><span class="type">int</span> flags=<span class="built_in">fcnlt</span>(fd[<span class="number">0</span>],F_GETFL);</span><br><span class="line"><span class="comment">//设置新的flags</span></span><br><span class="line">flags |=O_NONBLOCK;</span><br><span class="line"><span class="built_in">fcnlt</span>(fd[<span class="number">0</span>],F_SETFL,flags);</span><br></pre></td></tr></table></figure> 此时如果写端没有关闭，读端因为设置为非阻塞， 如果没有数据，直接返回-1</p>
<p><strong>获取缓冲区大小函数/命令</strong>： <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/fpathconf.png" width="600"></p>
<p>命令：可以使用ulimit -a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。</p>
<h6 id="有名管道fifo">3.2.2 有名管道FIFO</h6>
<p>命名管道<code>FIFO</code>，也叫有名管道、FIFO文件。<strong>FIFO支持不相关的进程也可以进行通信。</strong>命名管道（FIFO)和无名管道（pipe）有一些特点是相同的，不一样的地方在于：</p>
<ul>
<li><ol type="1">
<li>FIFO 在文件系统中作为一个特殊的文件而存在，但 FIFO 中的内容却存放在内存中。</li>
</ol></li>
<li><ol start="2" type="1">
<li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。</li>
</ol></li>
<li><ol start="3" type="1">
<li>FIFO 有名字，不相关的进程可以通过打开命名管道进行通信。</li>
</ol></li>
</ul>
<p><strong>创建FIFO的函数<code>mkfifo()</code></strong>: <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/mkfifo.png" width="600"> 也可以通过命令<code>mkfifo</code>管道名，创建一个<code>fifo</code></p>
<p><strong>读写操作</strong>： 一旦使用<code>mkfifo</code>创建了一个FIFO，就可以使用<code>open</code>打开它，常见的文件I/O函数都可用于fifo。如：<code>close、read、write</code>等。FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程1，执行写</span></span><br><span class="line"><span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;my_fifo&quot;</span>,O_WRONLY);</span><br><span class="line"><span class="type">char</span> send[<span class="number">1000</span>]=<span class="string">&quot;HELLO WORLD&quot;</span>;</span><br><span class="line"><span class="built_in">write</span>(fd,send,<span class="built_in">strlen</span>(send));</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程2，执行读</span></span><br><span class="line"><span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;my_fifo&quot;</span>,O_RDONLY);</span><br><span class="line"><span class="type">char</span> recv[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//读数据时，命名管道没数据时会堵塞，有数据时就读出来</span></span><br><span class="line"><span class="built_in">read</span>(fd,recv,<span class="built_in">seziof</span>(recv));</span><br><span class="line"><span class="built_in">printf</span>(read from my_fifo buf=[%s]\n<span class="string">&quot;,recv);</span></span><br></pre></td></tr></table></figure> - 1) 一个为只读而打开一个管道的进程会阻塞直到另外一个进程为只写打开该管道 - 2）一个为只写而打开一个管道的进程会阻塞直到另外一个进程为只读打开该管道</p>
<h5 id="system-v-ipc通信和posix-ipc通信概览">3.3 system V IPC通信和POSIX IPC通信概览</h5>
<p>不管是system V IPC通信，还是POSIX IPC通信，两种形式的IPC通信都只适合在同一主机下进行进程通信。其中包含的消息队列、信号和共享内存三者作用是：</p>
<ul>
<li><strong>消息队列可以用来在进程间传递消息。</strong></li>
<li><strong>信号量允许多个进程同步各自的动作。</strong></li>
<li><strong>共享内存使得多个进程能够共享同一块内存区域</strong></li>
</ul>
<h6 id="system-v-ipc通信">3.3.1 System V IPC通信</h6>
<p>System V IPC的接口如下所示 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/system v ipc.png" width="600"></p>
<ul>
<li>每钟system V IPC机制都要相关的<code>get</code>调用，其完成作用有（<strong>注意区分文件描述符和IPC标识符，文件描述符是一个进程特性，标识符则是对象的一个属性并且全局可见</strong> ）：
<ul>
<li>使用给的key创建一个新IPC对象并返回一个唯一标识符来标识该对象</li>
<li>返回一个给定key的既有的IPC对象标识符</li>
</ul></li>
<li>System V 提供的进程间通信机制需要一个唯一 key 值，通过 key 值就可在系统内获得一个唯一标识符。key 值可以是人为指定的，也可以通过 <code>ftok()</code> 函数获得。key获得有两种方法：
<ul>
<li>使用IPC_PRIVATE产生一个唯一key：如<code>id=msgget(IPC_PRIVATE,S_IRUSR|S_IWUSR)</code>，此时，代码无需指定<code>IPC_CREAT</code>和<code>IPC_EXCL</code>标识</li>
<li>使用<code>ftok()</code>产生一个唯一key：<code>ftok()</code>函数会返回一个适合在后续对某个System V IPC get系统调用进行调用时的key值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span> key;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">key=<span class="built_in">ftok</span>(<span class="string">&quot;/mydir/mylife&quot;</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span>==key)</span><br><span class="line">	<span class="built_in">errExit</span>(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">id=<span class="built_in">msgget</span>(key,IPC_CREAT|S_IRUSR|S_IWUSR);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span>==id)</span><br><span class="line">	<span class="built_in">errExiit</span>(<span class="string">&quot;msgget&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><code>ipcs</code>和<code>ipcrm</code>命令：<code>ipcs</code>和<code>ipcrm</code>命令是System v IPC领域中类似ls和rm文件命令，使用ipcs能够获取系统上的IPC对象信息,而ipcrm则删除一个ipc对象，主要有两种形式<code>ipcrm -X key</code>和<code>ipcrm -x id</code> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/ipcs.png" width="500"></li>
</ul>
<h6 id="posix-ipc通信">3.3.2 POSIX IPC通信</h6>
<p>POSIX IPC的接口如下所示 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/POSIX.png" width="500"></p>
<ul>
<li>每种POSIX IPC机制都有一个关联的<code>open()</code>调用，其完成两个任务中的一个
<ul>
<li>使用给定名字创建一个新对象，打开该对象并返回该对象的一个<strong>文件描述符</strong>（与System V不同之处，这时候就可以使用I/O多路复用机制，如poll、select、epoll等）</li>
<li>打开一个既有对象并返回该对象的一个句柄</li>
</ul></li>
<li>同样，与System V一样，创建时使用<code>O_CREAT</code>和<code>O_EXCL</code>标识,作用与<code>IPC_CREAT</code>和<code>IPC_EXCL</code>标识一样。
<ul>
<li><code>O_CREAT</code>：若对象不存在，就创建；若存在但未指定这个标记，则会返回错误<code>ENOENT</code></li>
<li><code>O_EXCL</code>：只能与<code>O_CREAT</code>结合使用。若同时指定<code>O_CREAT</code>且对象存在，则会返回错误<code>EEXIST</code>，这个标识符检查&quot;是否存在和创建”是原子操作，</li>
</ul></li>
<li>所有<code>open()</code>至少接收三个参数——<code>name、oflag和mode</code>,如<code>fd=shm_open(&quot;/mymem&quot;,O_CREAT|O_RDWR,S_IRUSR|S_IWUSR);</code></li>
</ul>
<h6 id="区别">3.3.3 区别</h6>
<p>system V是早期实践中弄出来的，posix是后来标准化之后的产物，因此：</p>
<ul>
<li>system V的移植性更强，几乎所有Unix实现都支持System V；而POSIX 移植性弱一些</li>
<li>POSIX使用文件描述符，因此可以使用I/O多路复用技术，而System V使用标识符，不能使用</li>
<li>因为创建的System V IPC使用标识符，因此内核不会维护引用System V的进程数，那么应用程序就不知道何时应该删除一个System V IPC通信方式；而POSIX IPC的对象是引用计数的，当所有进程都关闭该对象后计数为0，对象就会被销毁。</li>
</ul>
<p>就经验来说：在使用IPC的场景下，一般进程间的消息传递和同步上，使用POSIX较为普遍，而共享内存则是system V笔记多。</p>
<h5 id="system-v消息队列">3.4 system V消息队列</h5>
<h6 id="消息队列的特点">3.4.1 消息队列的特点</h6>
<p>消息队列虽然在某些方面与FIFO类似，但也有不同：</p>
<ul>
<li><p>1）消息队列可以实现消息的随机查询。消息不一定要以先进先出的次序读取，编程时可以按消息的类型读取，即有优先级。</p></li>
<li><p>2）消息队列允许一个或多个进程向它写入或者读取消息。</p></li>
<li><p>3）与无名管道、命名管道一样，从消息队列中读出消息，消息队列中对应的数据都会被删除。</p></li>
<li><p>4）不同的是消息队列是面向消息的，即接收和写入都是整条消息，读取一条消息的一部分而让剩余的遗留在队列中是不可能的。</p></li>
<li><p>5）每个消息队列都有消息队列标识符，不是文件描述符，消息队列的标识符在整个系统中也是唯一的。</p></li>
<li><p>6）消息队列是消息的链表，存放在内存中，由内核维护。<strong>只有内核重启或人工删除消息队列时，该消息队列才会被删除。</strong>若不人工删除消息队列，消息队列会一直存在于系统中。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="创建或打开一个消息队列">3.4.2 创建或打开一个消息队列</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建一个新的或打开一个已经存在的消息队列。不同的进程调用此函数，只要用相同的 key 值就能得到同一个消息队列的标识符</span></span><br><span class="line"><span class="comment">//key: ftok() 返回的 key 值</span></span><br><span class="line"><span class="comment">//msgflg: 标识函数的行为及消息队列的权限，其取值如下：</span></span><br><span class="line"><span class="comment">//	IPC_CREAT：创建消息队列。</span></span><br><span class="line"><span class="comment">//	IPC_EXCL： 检测消息队列是否存在。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>
<h6 id="交换消息">3.4.3 交换消息</h6>
<p><code>msgsnd()</code>和<code>msgrcv()</code>系统调用执行消息队列上的I/O，这两个系统调用接收的第一个参数是队列标识符<code>msqid</code>。第二个参数是由调用者定义的结构体指针，该结构用来存放消息，结构可为： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mymsg</span>&#123;</span><br><span class="line">	<span class="type">long</span> mtype;</span><br><span class="line">	<span class="type">char</span> mtext[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 发送信息：<code>msgsnd()</code>将新消息添加到消息队列。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include &lt;sys/msg.h&gt;</span><br><span class="line"><span class="comment">//msqid： 消息队列的标识符。</span></span><br><span class="line"><span class="comment">//msgp：  待发送消息结构体的地址。</span></span><br><span class="line"><span class="comment">//msgsz： 消息正文的字节数。</span></span><br><span class="line"><span class="comment">//msgflg：函数的控制属性，其取值如下：</span></span><br><span class="line"><span class="comment">//0：msgsnd() 调用阻塞直到条件满足为止。</span></span><br><span class="line"><span class="comment">//IPC_NOWAIT: 若消息没有立即发送则调用该函数的进程会立即返回。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(  <span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure> 接收信息：<code>msgrcv()</code>从消息队列中读取（以及删除）一条消息并将内容复制进<code>msgp</code>指向的缓冲区中 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">//msqid：消息队列的标识符，代表要从哪个消息列中获取消息。</span></span><br><span class="line"><span class="comment">//msgp： 存放消息结构体的地址。</span></span><br><span class="line"><span class="comment">//msgsz：消息正文的字节数。</span></span><br><span class="line"><span class="comment">//msgtyp：消息的类型。可以有以下几种类型：</span></span><br><span class="line">	msgtyp = <span class="number">0</span>：返回队列中的第一个消息。</span><br><span class="line">	msgtyp &gt; <span class="number">0</span>：返回队列中消息类型为 msgtyp 的消息（常用）。</span><br><span class="line">	msgtyp &lt; <span class="number">0</span>：返回队列中消息类型值小于或等于 msgtyp 绝对值的消息，如果这种消息有若干个，则取类型值最小的消息。</span><br><span class="line"><span class="comment">//msgflg：函数的控制属性。其取值如下：</span></span><br><span class="line">	<span class="number">0</span>：<span class="built_in">msgrcv</span>() 调用阻塞直到接收消息成功为止。</span><br><span class="line">	MSG_NOERROR: 若返回的消息字节数比 nbytes 字节数多,则消息就会截短到 nbytes 字节，且不通知消息发送进程。</span><br><span class="line">	IPC_NOWAIT: 调用进程会立即返回。若没有收到消息则立即返回 <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="built_in">msgrcv</span>( <span class="type">int</span> msqid, <span class="type">void</span> *msgp,  <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg );</span><br><span class="line"></span><br></pre></td></tr></table></figure> <strong><em>注意：在获取某类型消息的时候，若队列中有多条此类型的消息，则获取最先添加的消息，即先进先出原则。</em></strong></p>
<ul>
<li>成功：读取消息的长度</li>
<li>失败：-1</li>
</ul>
<h6 id="消息队列的控制">3.4.4 消息队列的控制</h6>
<p>对消息队列进行各种控制，如修改消息队列的属性，或删除消息消息队列。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">//msqid：消息队列的标识符。</span></span><br><span class="line"><span class="comment">//cmd：函数功能的控制。其取值如下：</span></span><br><span class="line">	IPC_RMID：删除由 msqid 指示的消息队列，将它从系统中删除并破坏相关数据结构。</span><br><span class="line">	IPC_STAT：将 msqid 相关的数据结构中各个元素的当前值存入到由 buf 指向的结构中。相对于，把消息队列的属性备份到 buf </span><br><span class="line">	IPC_SET：将 msqid 相关的数据结构中的元素设置为由 buf 指向的结构中的对应值。相当于，消息队列原来的属性值清空，再由 buf 来替换。</span><br><span class="line"><span class="comment">//buf：msqid_ds 数据类型的地址，用来存放或更改消息队列的属性。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure> <strong><em>注意：<code>struct msqid_ds</code>为消息队列的关联数据结构，具体内容其自行查询</em></strong></p>
<h6 id="消息队列在服务器-客户端的应用">3.4.5 消息队列在服务器-客户端的应用</h6>
<p>本节主要介绍System V消息队列的方式有很多种，这里介绍两种：</p>
<ul>
<li>在服务器和客户端之间使用单个消息队列进行双向的消息交换</li>
<li>服务器和各个客户端使用单独的消息队列，服务端上的队列用来接收进入客户端请求，相应的响应则通过各个客户端队列来发送给客户端</li>
</ul>
<p><strong>1. 服务器和客户端使用一个消息队列</strong> 这种情况是可以的，但是要注意一下几点：</p>
<ul>
<li><p><strong>由于多个进程可能会同时读取消息，因此必须使用消息类型字段来让各个进程只选择那些发送给自己的消息</strong>。如服务器向客户端响应时，发送的信息中以客户端进程的ID号作为消息类型，这样各个客户端能在消息队列中找到自己的消息；同理客户端向服务器发生请求时，将服务器的ID作为消息类型。</p></li>
<li>消息队列的容量是有限的，因此
<ul>
<li>问题一就是多个并行的客户端可能会填满消息队列，从而导致死锁发生，即所有客户端都无法提交请求，服务器在写入任何响应时都发生阻塞。（<strong>解决方法</strong>：使用两个队列，一个用于存放客户端发送给服务器的消息，另一个用于存放服务器发送给客户端的消息）</li>
<li>问题二就是不良或恶意的客户端只发送请求而不读取服务器响应，从而导致队列充满未被读取的消息。（<strong>解决方法</strong>：一个客户端使用一个的消息队列）</li>
</ul></li>
</ul>
<p><strong>2.一个客户端使用一个消息队列</strong> 一个客户端各自使用一个消息队列能够解决服务器和客户端使用一个消息队列所出现的问题，但是也需要注意：</p>
<ul>
<li>每个客户端要创建自己的消息队列并通知服务器队列的标识符。</li>
<li>系统对消息队列的数量是有限制的(MSGMNI)，如果客户端数量多，要提高该限制值。</li>
<li>服务器应该允许出现客户端的消息队列不再存在的情况</li>
</ul>
<h6 id="消息队列实现文件服务器应用程序一个客户端使用一个消息队列">3.4.6 消息队列实现文件服务器应用程序（一个客户端使用一个消息队列）</h6>
<ul>
<li>这是一个简单的文件服务器，首先客户端向服务器的消息队列发送一个请求，请求指定文件内容；然后服务器收到该请求后，将响应的文件内容作为一系列消息作为响应。</li>
<li>由于服务器对客户端不做任何鉴权操作，因此所有客户端都能获得服务器的文件内容 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/onetoone.png" width="500"></li>
</ul>
<p><strong>1.公共头文件</strong></p>
<ul>
<li>该文件是客户端和服务器都需要用到的头文件，这个头文件为服务器消息队列定义了一个众所周知的<code>SERVER_KEY</code>。并且定义了客户端和服务器之间传递消息的格式</li>
<li><code>requestMsg</code>结构定义了客户端发送给服务器的请求格式。<code>mtest</code>由两个字段构成，分别是客户端消息队列的标识符和客户端请求的文件的路径名。</li>
<li><code>responseMsg</code>结构定义了服务器返回给客户端的响应消息格式。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件名称svmg_file.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_KEY 0x1aaaaaa1	<span class="comment">//服务器消息队列标识符</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">requsetMsg</span>&#123;				<span class="comment">//客户端到服务器的请求格式</span></span><br><span class="line">	<span class="type">long</span> mtype;					<span class="comment">//未使用</span></span><br><span class="line">	<span class="type">int</span> clientID;				<span class="comment">//客户端消息队列的标识符</span></span><br><span class="line">	<span class="type">char</span> pathname[PATH_MAX];	<span class="comment">//请求的文件</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQ_MSG_SIZE (offsetof(struct requestMsg,pathname)-\</span></span><br><span class="line"><span class="meta">					offsetof(struct requestMSg,clientID)+PATH_MAX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESP_MSG_SIZE 8192</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">responseMsg</span>&#123;				<span class="comment">//服务启的响应格式</span></span><br><span class="line">	<span class="type">long</span> mtype;					<span class="comment">//三种类型</span></span><br><span class="line">	<span class="type">char</span> data[RESP_MSG_SIZE];	<span class="comment">//文件内容</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESP_MT_FAILURE 1  <span class="comment">//文件无法打开</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESP_MT_DATA 2     <span class="comment">//可发送</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESP_MT_END 3	   <span class="comment">//文件传输完成</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2.服务器程序</strong> - 服务器能够并发处理请求 - 每个客户端请求都会创建一个子进程来执行相应的响应 - 要避免僵尸进程，父进程应该有回收，即为SIGCHLD建立一个处理器并在其中调用<code>wait/waitpid</code> - 父服务器进程中的<code>msgrcv</code>调用可能会阻塞，这样就可能会被SIGCHLD处理器中断。为解决该情况，需要使用循环来完成EINTR错误发生之后的重启操作(用到了信号的知识) - 服务器子进程执行<code>serveRequest()</code>函数，该函数向客户端返回三种信息（头文件中的宏<code>RESP_MT_FAILURE</code>等）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;svmg_file.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">grimReaper</span><span class="params">(<span class="type">int</span> sig)</span>		<span class="comment">//SIGCHLD 处理器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> savedErrno;</span><br><span class="line">	savedError=errno</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">waitpid</span>(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG)&gt;<span class="number">0</span>)	</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	errno=savedErrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">serveRequest</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> requestMsg* req)</span><span class="comment">//消息发送</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">ssize_t</span> numRead;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">responseMsg</span> resp;</span><br><span class="line">	fd=<span class="built_in">open</span>(req-&gt;pathname,O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span>==fd)&#123;</span><br><span class="line">		resp.mtype=RESP_MT_FAILUER;</span><br><span class="line">		<span class="built_in">snprintf</span>(resp.data,<span class="built_in">sizeof</span>(resp.data),<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;Counldn&#x27;t open&quot;</span>);</span><br><span class="line">		msgsnd（req-&gt;clientID,&amp;resp,<span class="built_in">strlen</span>(resp.data)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE)</span><br><span class="line">	&#125;</span><br><span class="line">	resp.mtype=RESP_MT_DATA;</span><br><span class="line">	<span class="keyword">while</span>((numRead=<span class="built_in">read</span>(fd,resp.data,RESP_MSG_SIZE))&gt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">msgsnd</span>(req-&gt;clientID,&amp;resp,numRead,<span class="number">0</span>)==<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	resp.mtype=RESP_MT_END;</span><br><span class="line">	<span class="built_in">msgsnd</span>(req-&gt;clientID,&amp;resp,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">requestMsg</span> req;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">ssize_t</span> msgLen;</span><br><span class="line">	<span class="type">int</span> serverId;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">	<span class="comment">//建立服务器消息队列</span></span><br><span class="line">	serverId=<span class="built_in">msgget</span>(SERVER_KEY,IPC_CREAT|IPC_EXCL|S_IRUSR|S_IWUSR|S_IWGRP);</span><br><span class="line">	<span class="keyword">if</span>(serverId==<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">errExit</span>(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">	<span class="comment">//使用信号建立SIGCHLD的处理器</span></span><br><span class="line">	<span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">	sa.sa_flags=SA_RESTART;</span><br><span class="line">	sa.sa_hanlder=grimReaper;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">sigaction</span>(SIGCHLD,&amp;sa,<span class="literal">NULL</span>)==<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">errExit</span>(<span class="string">&quot;sigcation&quot;</span>);</span><br><span class="line">	<span class="comment">//读取客户端请求，创建子进程取处理</span></span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		msgLen=<span class="built_in">msgrcv</span>(serverId,&amp;req,REQ_MSG_SIZE,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">-1</span>==msgLen)&#123;</span><br><span class="line">			<span class="keyword">if</span>(errno==EINTR)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">errMsg</span>(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pid=fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="built_in">errMsg</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">serveRequest</span>(&amp;req);</span><br><span class="line">			_exit(EXIT_SUCCESS);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="system消息队列的缺点">3.4.6 System消息队列的缺点</h6>
<p>消息队列一个最与众不同的特性就是能够为每个消息加上一个数字类型，这样读取进程就可以<strong>根据类型来选择消息，或者可以采用一种优先策略以便优先读取高优先级的消息</strong>。但，消息队列也有相应的缺点：</p>
<ul>
<li>消息队列通过标识符引用，而不像管道、FIFO、socket使用文件描述符，因此无法使用I/O多路复用技术。</li>
<li>消息队列是无连接的，内核不会像对待管道、FIFO、socket那样维护引用队列的进程数。</li>
<li>消息队列的总数、消息的大小以及单个队列的容量都是有限制的，虽然它们可配置，但需要做一些额外的工作取配置它们。</li>
</ul>
<p><strong>因此，一般避免使用System V消息队列，而使用POSIX消息队列，也应当考虑其他技术替代（如文件描述符类的）</strong></p>
<p><strong><em>system v共享内存和信号量略（着重介绍POSIX系列）</em></strong></p>
<h5 id="system-v共享内存">3.5 System V共享内存</h5>
<p><strong>共享内存允许两个或多个进程共享物理内存的同一块区域(通常称为段)，由于一个共享内存段会成为一个进程用户空间内存的一部分，因此这种IPC无需内核介入</strong>，因此它有一下两点要注意：</p>
<ul>
<li><p>共享内存是进程间共享数据的一种最快的方法。 一个进程向共享的内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。</p></li>
<li><p>不使用内核控制意味着使用共享内存时要注意的是多个进程之间对一个给定存储区访问的互斥。若一个进程正在向共享内存区写数据，则在它做完这一步操作前，别的进程不应当去读、写这些数据。</p></li>
</ul>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/sharedmemory.png" width="300"></p>
<h6 id="共享内存段">3.5.1 共享内存段</h6>
<p><strong>使用System V共享内存的步骤：</strong></p>
<ul>
<li><strong>调用<code>shmget()</code>创建一个新的共享内存段或取得一个既有共享内存段的标识符。</strong></li>
<li>使用<code>shmat()</code>来附上贡献内存段，即使该段成为调用进程的虚拟内存的一部分</li>
<li><strong>此刻在程序中就可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存段，程序需要使用由<code>shmat()</code>调用返回的地址值<code>addr</code>，它是一个指向进程虚拟地址空间该共享内存段的起点指针</strong></li>
<li>调用<code>shmdt()</code>来分离共享内存段，之后进程无法引用这块共享内存</li>
<li>调用<code>shmctl()</code>来销毁共享内存段</li>
</ul>
<p>一般来说，其内存布局如下图所示，<strong>共享内存段被附加在向上增长的堆和向下增长的栈之间的未被分配的空间中</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/location.png" width="500"></p>
<h5 id="poxis的消息队列">3.6 POXIS的消息队列</h5>
<p>POSIX消息队列与System消息队列的相似之处在于数据的交换单位都是整体消息。不同点是：</p>
<ul>
<li><p><strong>POSIX消息队列使用引用计数，所有使用该队列的进程关闭后队列就删除，而System消息队列则不确定</strong>。</p></li>
<li><p><strong>POSIX消息队列使用文件描述符，因此可使用epoll等技术</strong></p></li>
<li><p><strong>POSIX队列提供了一个<code>mq_notify()</code>函数允许队列中的一条消息可用时异步地通知进程</strong></p></li>
<li><p><strong>System消息队列使用一个整数来标识优先级，而POSIX消息队列有一个关联的优先级，并且消息之间是严格按照优先级顺序排列的，灵活性不如System消息队列</strong>。</p></li>
<li><p>POSIX的移植性不如System</p></li>
</ul>
<h6 id="接口概览">3.6.1 接口概览</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcnlt.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys.stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mqueue.h&gt;</span> <span class="comment">//消息队列头文件</span></span></span><br><span class="line"><span class="built_in">mq_open</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> oflag,...); <span class="comment">//创建一个新消息队列或打开已有队列，返回其文件描述符。</span></span><br><span class="line"><span class="built_in">mq_send</span>(<span class="type">mqd_t</span> mqdes,<span class="type">const</span> <span class="type">char</span>* msg_ptr,<span class="type">size_t</span> msg_len,<span class="type">unsigned</span> <span class="type">int</span> msg_prio);       <span class="comment">//向队列写入一条消息</span></span><br><span class="line"><span class="built_in">mq_receive</span>(<span class="type">mqd_t</span> mqdes,<span class="type">const</span> <span class="type">char</span>* msg_ptr,<span class="type">size_t</span> msg_len,<span class="type">unsigned</span> <span class="type">int</span> msg_prio)	<span class="comment">//从队列读取一条消息,会阻塞</span></span><br><span class="line"><span class="built_in">mq_close</span>(<span class="type">mqd_t</span> mqdes)	<span class="comment">//关闭该进程之前打开的一个对应消息队列</span></span><br><span class="line"><span class="built_in">mq_unlink</span>(<span class="type">const</span> <span class="type">char</span>* name)		<span class="comment">//删除一个消息队列名并当所有进程关闭该队列时对队列进行标记以便删除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mq_getattr</span>(<span class="type">mqd_t</span> mqdes,<span class="keyword">struct</span> mq_attr* attr)</span><br><span class="line"><span class="built_in">mq_setattr</span>(<span class="type">mqd_t</span> mqdes,<span class="keyword">struct</span> mq_attr* newattr,<span class="keyword">struct</span> mq_attr* oldattr)	<span class="comment">//每个消息队列都有一组关联特性，可通过这两个函数获取/设置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mq_notify</span>(<span class="type">mqd_t</span> mqdes,<span class="type">const</span> <span class="keyword">struct</span> sigevent* notification)    </span><br><span class="line"><span class="comment">//允许一个进程向一个队列注册接收消息通知。在注册之后，当一条消息可用时会通过发送一个信号或在一个单独的线程调用一个函数来通知进程。**</span></span><br></pre></td></tr></table></figure>
<h6 id="消息队列的特性">3.6.2 消息队列的特性</h6>
<p>该结构体也定义在<code>&lt;mqueue.h&gt;</code>中。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mq_attr</span>&#123;</span><br><span class="line">	<span class="type">long</span> mq_flags;		<span class="comment">//消息队列描述</span></span><br><span class="line">	<span class="type">long</span> mq_msgsize;	</span><br><span class="line">	<span class="comment">//maxmsg和msgsize在mq_open阶段设置，指示消息队列添加消息的上限和每条消息的大小上限，不可更改</span></span><br><span class="line">	<span class="type">long</span> mq_maxmsg;</span><br><span class="line">	<span class="type">long</span> mq_curmsgs;	<span class="comment">//当前状态的相关信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="消息通知">3.5.3 消息通知</h6>
<p><strong>允许一个进程向一个队列注册接收消息通知。在注册之后，当一条消息可用时会通过发送一个信号或在一个单独的线程调用一个函数来通知进程</strong>。这个特性意味着<strong><em>在接受消息时，该进程已经无需执行一个阻塞的<code>mq_receive()</code>调用，或者说该特性使得消息队列描述符能够标记为非阻塞并在队列上定期执行<code>mq_receive()</code>。</em></strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mq_notify</span>(<span class="type">mqd_t</span> mqdes,<span class="type">const</span> <span class="keyword">struct</span> sigevent* notification) </span><br></pre></td></tr></table></figure> notifcation参数指定了进程接收通知的机制。对应消息通知，其细节有：</p>
<ul>
<li><p>任何一个时刻，对于消息队列来说，有且只有一个进程（“注册进程”）能够注册接收通知，即同一时刻最多只有一个注册进程。</p></li>
<li><p>只有当一条新消息进入之前为空的队列时注册进程才会收到通知。</p></li>
<li><p><strong>当向注册进程发送一个通知后就会删除注册信息。因此，之后任一进程可公平竞争该消息队列的注册通知。话句话说，若一个进程想要持续的接收通知，那么它必须在每次接收通知后再次调用<code>mq_notify()</code>来注册自己</strong></p></li>
<li><p>其他进程（非注册进程）在消息队列调用<code>mq_receive()</code>而阻塞（说明此时消息是被注册进程读取），那么注册进程会读取消息，而且还会保持注册状态。</p></li>
<li><p>进程可将notifcation置为<code>NULL</code>来撤销注册信息</p></li>
</ul>
<h5 id="posix信号量">3.7 POSIX信号量</h5>
<p>信号量不做进程间数据的通信，<strong>而是允许进程或线程同步对共享资源的访问</strong>。对于POSIX信号量有两种类型：</p>
<ul>
<li><p><strong>命名信号量</strong>：拥有名字。<strong>通过使用相同的名字调用<code>sem_open()</code>,不相关进程能够访问同一个信号量</strong></p></li>
<li><strong>未命名信号量</strong>：没有名字。<strong>因此它位于内存中预先商定的位置处，未命名信号量可以在进程之间或一组线程之间共享</strong>。
<ul>
<li>当进程间共享时，必须位于一个共享区域（System V、POSIX或mmap())。</li>
<li>当线程之间共享时，信号量可以位于被这些线程共享的内存区域，如堆或全局变量中。</li>
</ul></li>
</ul>
<h6 id="命名信号量接口概览">3.7.1 命名信号量接口概览</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcnlt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys.stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="built_in">sem_open</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> oflag,...);	<span class="comment">//创建或打开一个信号量并返回一个文件描述符</span></span><br><span class="line"><span class="built_in">sem_post</span>(<span class="type">sem_t</span>* sem);		<span class="comment">//递增sem引用的信号量的值</span></span><br><span class="line"><span class="built_in">sem_wait</span>(<span class="type">sem_t</span>* sem);		<span class="comment">//递减sem引用的信号量的值</span></span><br><span class="line"><span class="built_in">sem_close</span>(<span class="type">sem_t</span>* sem);		<span class="comment">//删除调用进程与它之前打开的一个信号量的关联关系</span></span><br><span class="line"><span class="built_in">sem_getvalue</span>(<span class="type">sem_t</span>* sem,<span class="type">int</span>* sval);				<span class="comment">//获取信号量的当前值</span></span><br><span class="line"><span class="built_in">sem_unlink</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br></pre></td></tr></table></figure>
<h6 id="posix和system的信号量操作">3.7.2 POSIX和system的信号量操作</h6>
<p>与System V信号量一样，<strong>一个POSIX信号量也是一个整数且系统不会允许其值小于0</strong>。</p>
<ul>
<li>修改信号量值的函数是<code>sem_post()</code>和<code>sem_wait()</code>,一次只操作一个信号量。而形成对比的是，System V的<code>semop()</code>能够操作一个集合中的多个信号量</li>
<li><code>sem_post()</code>和<code>sem_wait()</code>只对信号量增1或减1；而形成对比的是，<code>semop()</code>能够加或减任一个数</li>
<li>system V信号量没有提供一个<code>wait for zero</code>的操作（即将sops.sem_op字段指定为0的semop()调用）</li>
</ul>
<h6 id="信号量操作之sem_wait">3.7.3 信号量操作之sem_wait()</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行<code>sem_wait</code>函数会递减sem引用的信号量的值。</li>
<li><strong>如果信号量值为0，则<code>sem_wait()</code>不会执行，阻塞直到信号量大于0。</strong></li>
<li><strong>当信号量大于0时，<code>sem_wait()</code>会立即返回，并且递减信号量操作。</strong></li>
<li>若一个阻塞的<code>sem_wait()</code>调用被一个信号处理器中断了，那么他会失败且返回EINTR错误</li>
</ul>
<p>该函数有两个变体，一个是<code>sem_trywait()</code>,另一个是<code>sem_timedwait()</code>:</p>
<ul>
<li><code>sem_trywait()</code>是非阻塞版本，如果递减操作无法立即执行，就会失败并返回EAGAIN错误</li>
<li><code>sem_timedwait()</code>调用若在规定时间内无法递减，则会失败并返回ETIMEDOUT错误</li>
</ul>
<h6 id="信号操作之sem_post">3.7.4 信号操作之sem_post()</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在<code>sem_post</code>调用之前信号量值为0，并且其他某个进程或线程正在因等待递减这个信号量而阻塞，则该进程会被唤醒，它的<code>sem_wait()</code>调用会继续往前执行来递减这个信号量</li>
</ul>
<h6 id="未命名信号量">3.7.5 未命名信号量</h6>
<p><strong>未命名信号量是类型<code>sem_t</code>并存储在应用程序分配的内存变量中。通过将这个信号量放在由几个进程或线程共享道的内存区域就能够使用</strong>。操作未命名信号量所使用的函数与命名信号量一样都是<code>sem_wait、sem_post、sem_getvalue</code>，只有两个不同：</p>
<ul>
<li><code>sem_init()</code>:对一个未命名信号量初始化并通知系统该信号量会在进程间共享还是单个进程中的线程共享</li>
<li><code>sem_destroy()</code>:销毁一个未命名信号量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">int</span> pshared,<span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pshared</code>指示这个信号量是在线程共享还是进程间共享
<ul>
<li>为0时，信号量会在调用进程的线程间共享。此时<code>sem</code>通常被指定为一个全局变量或分配到堆的一个地址</li>
<li>为非0时，即为进程间共享，此时<code>sem</code>必须是（System V、POSIX或mmap())共享区域</li>
</ul></li>
</ul>
<h5 id="内存映射">3.8 内存映射</h5>
<p><code>mmap()</code>系统调用在调用进程的虚拟地址空间创建一个新内存映射，映射分为两种：</p>
<ul>
<li><strong>文件映射：文件映射将一个文件的一部分直接映射到调用进程的虚拟内存中。</strong>一旦一个文件被映射之后就可以通过在相应的内存区域中操作字节来访问文件内容，此时映射的分页会在需要的时候从文件加载。</li>
<li><strong>匿名映射：匿名映射没有对应文件，因此这种映射的分页会被初始化为0</strong></li>
</ul>
<p>上面介绍中我们并没有看到进程间的通信作用，但是<strong>一个进程的映射中的内存可以与其他进程中的映射共享</strong>，此时就体现了进程间的通信作用：<strong>此时映射为共享模式时，多个进程共享相同分页时，每个进程都会看到其他进程对分页做出的改变。</strong></p>
<ul>
<li><strong>私有映射(<code>MAP_PRIVATE</code>):其变更不会影响到底层文件，因此映射内容上发送的变更对其他进程是不可见的。</strong></li>
<li><strong>共享映射(<code>MAP_SHARED</code>):其变更会影响到底层文件，因此映射内容上发送的变更对其他进程是可见的</strong>。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/map.png" width="500"></li>
</ul>
<p><strong><em>注意：共享文件映射可用于不同进程通信，而共享匿名映射只能用于具有关系的进程通信</em></strong></p>
<h6 id="原理详解共享文件为例">3.8.1 原理详解（共享文件为例）</h6>
<p><strong>当多个进程创建了同一个文件区域的共享映射时，它们会共享同样的内存物理分页。此时，对映射内容所做出的变更都会自动反应到文件上。</strong></p>
<p>此时，内存映射一个最大的优势就是<strong>可以简单通过访问内存中的映射内容就能实现文件I/O，依靠内核来确保对内存的变更会被传递到映射文件上</strong>。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/filemmap.png" width="500"> 内存映射I/O优势：</p>
<ul>
<li>正常的<code>read()</code>和<code>write()</code>需要两次I/O,一次时文件内核高速缓存区和之间，另一次是内核高速缓存区和用户空间缓冲区。而<code>mmap()</code>只需要一次，一旦将相应文件块映射进用户内存之后用户进程就能够使用它们，只进行一次I/O，节省了一次内核空间和用户空间的传输。</li>
<li>同样，mmap跨过了内核态这个中间状态，文件内容不用存储在内核态，只需存储在用户内存空间中，节省了空间。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/cross.png" width="500"></li>
</ul>
<h6 id="映射函数mmap">3.8.2 映射函数mmap()</h6>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/mmap.png" width="600"></p>
<p><strong><em>注意：关于mmap函数的使用总结：</em></strong> - 1) 第一个参数写成<code>NULL</code> - 2) 第二个参数要映射的文件大小<code>&gt; 0</code> - 3) 第三个参数：<code>PROT_READ 、PROT_WRITE</code> - 4) 第四个参数：<code>MAP_SHARED</code> 或者 <code>MAP_PRIVATE</code> - 5) 第五个参数：打开的文件对应的文件描述符 - 6) 第六个参数：4k的整数倍，通常为0</p>
<h6 id="解除映射munmap">3.8.3 解除映射munmap</h6>
<p><code>munmap()</code>系统调用执行<code>mmap()</code>相反的操作，即从调用进程虚拟地址空间中删除一个映射 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">/*参数</span></span><br><span class="line"><span class="comment">addr：使用mmap函数创建的映射区首地址</span></span><br><span class="line"><span class="comment">length：映射区大小</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h6 id="举例以共享文件映射进行父子进程通信">3.8.4 举例：以共享文件映射进行父子进程通信</h6>
<p>文件映射的缺陷是，每次创建映射区一定要依赖一个文件才能实现。使用MAP_ANONYMOUS (或MAP_ANON)可实现无需文件就可进行通信的匿名映射。<code>int *p = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></p>
<ul>
<li><code>MAP_ANONYMOUS</code>和<code>MAP_ANON</code>这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcnlt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;trluper.txt&quot;</span>,O_RDWR);	</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">lseek</span>(fd,<span class="number">0</span>,SEEK_END);	<span class="comment">//文件大小</span></span><br><span class="line">	<span class="comment">//创建文件映射区</span></span><br><span class="line">	<span class="type">void</span>* ptr=<span class="built_in">mmap</span>(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//void *ptr=mmap(NULL,len,PROT_READ|PORT_WRITE,MAP_SHARED,-1,0);	//匿名映射区</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">clsoe</span>(fd);</span><br><span class="line">	<span class="comment">//创建子进程</span></span><br><span class="line">	<span class="type">pid_t</span> pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//读数据</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr,<span class="string">&quot;i am u father!!&quot;</span>);</span><br><span class="line">		<span class="comment">//回收子进程资源</span></span><br><span class="line">		<span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放内存映射区</span></span><br><span class="line">	<span class="type">int</span> ret=<span class="built_in">munmap</span>(ptr,len);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;munmap failed&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="信号">3.9 信号</h5>
<p><strong>信号是 Linux 进程间通信的最古老的方式。信号是软件中断。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断</strong>，转而处理某一个突发事件。信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。在Linux中1-31为常规信号；34-64为实时信号，用户可自定义，默认动作是终止进程。</p>
<p>信号的特点：</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特设条件才发送</li>
</ul>
<p>一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数。如下图所示：（这里的产生、注册、注销是指系统的内部机制中信号的完整周期，而不是单指信号函数产生） <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/signal.png" width="600"></p>
<p>Linux 可使用命令：<code>kill -l</code>（&quot;l&quot; 为字母），查看相应的信号编号。（详情查看文件资料）</p>
<h6 id="信号四要素及状态">3.9.1 信号四要素及状态</h6>
<p>每个信号必备4要素，分别是：编号、名称 、事件 、默认处理动作。可通过<code>man 7 signal</code>查看帮助文档获取</p>
<p>信号的状态：产生、未决状态（没有被处理）、递达状态（信号被处理了）。Linux内核的进程控制块PCB是一个结构体<code>task_struct</code>, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集。</strong></p>
<ul>
<li>阻塞信号集(信号屏蔽字)：将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(处理发生在解除屏蔽后)。（类似黑名单）</li>
<li>未决信号集：信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回为0。</li>
</ul>
<h6 id="信号相关函数">3.9.2 信号相关函数</h6>
<ul>
<li><p><strong>1.kill函数：信号产生函数</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/kill.png" width="600"> <strong><em>注:super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。用户只能向自己创建的进程发生信号。（父进程可向子进程发送信号，子进程也可向父进程发送信号） 例：</em></strong></p></li>
<li><p>raise函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="comment">//功能：给当前进程发送指定信号，等价于kill(getpid(),sig)</span></span><br><span class="line"><span class="comment">//参数：sig为信号编号</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>abort函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//功能：给自己发送异常终止信号6）SIGABRT，并产生core文件，等价于kill(getpid(),SIGABRT)</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>alarm函数 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/alarm.png" width="600"> 定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸……无论进程处于何种状态，alarm都计时。</p></li>
<li><p>setitimer函数 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/setitimer.png" width="600"> <strong>实例：setitimer默认动作是终止进程，所有要加信号捕捉signal函数，实现周期定时。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">itimerval</span> new_value;</span><br><span class="line">	<span class="comment">//触发周期</span></span><br><span class="line">	new_value.it_interval.tv_sec=<span class="number">1</span>;</span><br><span class="line">	new_value.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//第一次触发时间</span></span><br><span class="line">	new_value.it_value.tv_sec=<span class="number">2</span>;</span><br><span class="line">	new_value.it_value.tv.usec=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">signal</span>(SIGALRM,function);</span><br><span class="line">	<span class="built_in">setitimer</span>(ITIMER_REAL,&amp;new_value,<span class="literal">NULL</span>);<span class="comment">//定时器设置</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="信号集">3.9.3 信号集</h6>
<p>在PCB中有两个非常重要的信号集。<strong>一个为“阻塞信号集”，另一个为“未决信号集”</strong>。这两个信号集都是内核使用位图机制来实现的<strong>。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。 </strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/signalset.png" width="600"></p>
<p>信号集是一个能表示多个信号的数据类型<code>sigset_t set</code>，<code>set</code>即一个信号集。既然是一个集合，就需要对集合进行添加/删除等操作。<strong>信号集主要作用是方便我们操作<code>sigprocmask</code>和<code>sigpending</code>函数对阻塞信号集和未决信号集的添加删除信号管理</strong>。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/operateset.png" width="600"></p>
<ul>
<li><p><code>sigprocmask</code>函数:信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞。<strong>我们可以通过 sigprocmask() 修改当前的阻塞信号集中包含的信号（即设置要被阻塞的信号种类的添加、删除） </strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/sigprocmask.png" width="600"></p></li>
<li><p>sigpending函数：读取未决信号集（未决由内核管理，用户只要读权限，没有写权限） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigpending</span><span class="params">(sigset* set)</span></span>;</span><br><span class="line"><span class="comment">//功能：读取当前进程的未决信号集</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//自定义信号集</span></span><br><span class="line">	<span class="type">sigset_t</span> myset,old;</span><br><span class="line">	<span class="built_in">sigemptyset</span>(&amp;myset);	<span class="comment">//清空</span></span><br><span class="line">	<span class="comment">//添加阻塞信号</span></span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;myset,SIGINT);</span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;myset,SIGQUIT);</span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;myset,SIGKILL);</span><br><span class="line">	<span class="comment">//自定义信号集设置到内核中的阻塞信号集</span></span><br><span class="line">	<span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;myset,&amp;old);</span><br><span class="line">	<span class="type">sigset_t</span> pend; </span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//读未决信号集的状态</span></span><br><span class="line">		<span class="built_in">sigpending</span>(&amp;pend);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">sigismember</span>(&amp;pend,i))</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sigusmember</span>(&amp;pend,i)==<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		i++;</span><br><span class="line">		<span class="comment">//10s后解除阻塞</span></span><br><span class="line">		<span class="keyword">if</span>(i&gt;<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;old,<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="信号捕捉">3.9.4 信号捕捉</h6>
<p>如上所示，一些函数的默认动作不是我们想要，而要改变这些动作，就必须依靠信号捕捉来实现自定义信号处理函数。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/signalhunter.png" width="600"> <strong><em>【注意】：SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。</em></strong></p>
<ul>
<li><p>signal函数（了解） <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/func_signal.png" width="600"></p></li>
<li>sigaction函数 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/sigaction.png" width="600"> <strong><code>struct sigaction</code>结构体：</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/sigas.png" width="600">
<ul>
<li><ol type="1">
<li>sa_handler、sa_sigaction：信号处理函数指针，和 signal() 里的函数指针用法一样，应根据情况给sa_sigaction、sa_handler 两者之一赋值，其取值如下：</li>
</ol>
<ul>
<li><ol type="a">
<li>SIG_IGN：忽略该信号</li>
</ol></li>
<li><ol start="2" type="a">
<li>SIG_DFL：执行系统默认动作</li>
</ol></li>
<li><ol start="3" type="a">
<li>处理函数名：自定义信号处理函数</li>
</ol></li>
</ul></li>
<li><ol start="2" type="1">
<li>sa_mask：信号阻塞集，在信号处理函数执行过程中，临时屏蔽指定的信号。</li>
</ol></li>
<li><ol start="3" type="1">
<li>sa_flags：用于指定信号处理的行为，通常设置为0，表使用默认属性。它可以是一下值的“按位或”组合：</li>
</ol>
<ul>
<li>Ø SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。</li>
<li>Ø SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程（因为由init进程回收）。</li>
<li>Ø SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。</li>
<li>Ø SA_RESETHAND：信号处理之后重新设置为默认的处理方式。</li>
<li>Ø SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="进程组和守护进程">4 进程组和守护进程</h4>
<h5 id="进程组">4.1 进程组</h5>
<p>当父进程创建子进程的时候，默认子进程与父进程属于同一进程组。**进程组ID为第一个进程的ID(组长进程)。进程组的出现是为了方便管理多个进程： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill <span class="number">-9</span> -进程组ID    <span class="comment">//杀死整个进程组内的进程全部杀死</span></span><br></pre></td></tr></table></figure></p>
<p><strong>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。一个进程可以为自己或子进程设置进程组ID。 </strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/gprocess.png" width="600"></p>
<h5 id="会话">4.2 会话</h5>
<p><strong>会话是一个或多个进程组的集合。一个会话可以有一个控制终端。这通常是终端设备或伪终端设备；</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/hui.png" width="600"></p>
<ul>
<li><strong>建立与控制终端连接的会话首进程被称为控制进程；</strong></li>
<li><strong>一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组；</strong></li>
<li><strong>如果一个会话有一个控制终端，则它有一个前台进程组，其它进程组为后台进程组</strong>；</li>
<li><strong>如果终端接口检测到断开连接，则将挂断信号发送至控制进程（会话首进程）。</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/huihua.png" width="600"></li>
</ul>
<p><strong>创建会话的注意事项：</strong></p>
<ul>
<li><ol type="1">
<li>调用进程不能是进程组组长，若调用进程是组长进程，则出错返回</li>
</ol></li>
<li><ol start="2" type="1">
<li>调用进程会成为一个新进程组的组长进程，同时该进程变成新会话首进程(session header)既控制进程</li>
</ol></li>
<li><ol start="3" type="1">
<li>需有root权限(ubuntu不需要)</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>新会话丢弃原有的控制终端，该会话没有控制终端（能成为守护进程的关键）</strong></li>
</ol></li>
<li><ol start="5" type="1">
<li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/setsid.png" width="600"></li>
</ol></li>
</ul>
<h5 id="守护进程">4.3 守护进程</h5>
<p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。守护进程是个特殊的孤儿进程，<strong>这种进程脱离终端，以避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。Linux 的大多数服务器就是用守护进程实现的</strong></p>
<p><strong>守护进程的创建流程：</strong></p>
<ul>
<li><ol type="1">
<li>创建子进程，父进程退出(必须)：所有工作在子进程中进行形式上脱离了控制终端</li>
</ol></li>
<li><ol start="2" type="1">
<li>在子进程中创建新会话(必须)：<code>setsid()</code>函数，使子进程完全独立出来，脱离控制</li>
</ol></li>
<li><ol start="3" type="1">
<li>改变当前目录为根目录(不是必须)---&gt;chdir(char *path)函数，防止占用可卸载的文件系统</li>
</ol></li>
<li><ol start="4" type="1">
<li>重设文件权限掩码(不是必须)：umask()函数，防止继承的文件创建屏蔽字拒绝某些权限，增加守护进程灵活性</li>
</ol></li>
<li><ol start="5" type="1">
<li>关闭文件描述符(不是必须)：继承的打开文件不会用到，浪费系统资源，无法卸载</li>
</ol></li>
<li><ol start="6" type="1">
<li>开始执行守护进程核心工作(必须)：守护进程退出处理程序模型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建子进程，父进程退出</span></span><br><span class="line">	<span class="type">pid_t</span> pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span>==pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;父进程退\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">		<span class="comment">//在子进程创建会话，脱离终端</span></span><br><span class="line">		<span class="type">pid_t</span> hpid=<span class="built_in">setsid</span>();</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">-1</span>==hpid)&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;setsid\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//改变工作目录</span></span><br><span class="line">		<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">		<span class="comment">//改变权限掩码，0没有屏蔽任何权限</span></span><br><span class="line">		<span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//关闭文件描述符</span></span><br><span class="line">		<span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line">		<span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">		<span class="built_in">close</span>(STDERR_FILENO);</span><br><span class="line">		<span class="comment">//防止子进程退出，执行核心任务</span></span><br><span class="line">		<span class="built_in">task</span>();</span><br><span class="line">		<span class="comment">//每隔1s输出当前时间到temp/txt.log</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;date&gt;&gt;/temp/txt.log&quot;</span>);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/" class="post-title-link" itemprop="url">Linux系统编程_1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-16 15:20:24" itemprop="dateCreated datePublished" datetime="2022-12-16T15:20:24+08:00">2022-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-16 12:30:45" itemprop="dateModified" datetime="2023-02-16T12:30:45+08:00">2023-02-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Linux系统编程</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="基本概念">1.基本概念</h4>
<p>这里我们只对一些概念做简单介绍，让第一次接触的读者有一个大概的映像。后续会进行详细的讲述 ##### 1.1 操作系统的核心-内核 操作系统是指完整的软件包，它包括了用来管理和分配计算机资源的核心层软件，以及附带所有标准软件工具，诸如命令行解释器、图形用户界面、文件操作工具和文件编辑器等。其中最为重要的是其核心层软件——内核：</p>
<p><strong>内核</strong>：内核执行的主要任务是<strong>进程调度、内存管理</strong>、提供系统文件、创建和终止进程、对设备的访问、联网、提供系统调用应用编程接口(API)</p>
<ul>
<li><strong>进程调度</strong>：计算机均配备一个或多个CPU以执行程序指令，<strong>Linux与其他系统如Windows一样属于抢占式多任务操作系统</strong>，即多个任务（进程）可同时驻留在CPU中，每个进程都可以获得对CPU的使用权，那么内核就得规定什么时候哪个进程占有CPU进行处理。</li>
<li><strong>内存管理</strong>：linux当中采用了<strong>虚拟内存管理机制</strong>，这种机制有两个优点：<strong>一</strong>是使得进程与进程之间，进程与内核之间彼此隔离，一个进程无法读取或修改内核或其他进程的内存内容；<strong>二</strong>是只需将进程的一部分保存在内存中，降低了每个进程对内存的需求量，使得RAM能够加载更多的进程。</li>
<li><strong>系统调用</strong>：内核提供了系统调用应用编程接口，这样进程可以利用内核入口点（系统调用）请求内核去执行各种任务，如<code>epoll</code></li>
</ul>
<p><strong><em>注意：</em></strong>必须得理解并行并发，在多核CPU中可以做到并行</p>
<ul>
<li>并行：真正的同一时刻</li>
<li>并发：同一时间周期（我们感觉是同时执行，但是计算机执行周期是毫秒单位级别的，我们感觉不到）</li>
</ul>
<h5 id="内核态和用户态">1.2 内核态和用户态</h5>
<ul>
<li><strong>用户态：</strong>当在用户态运行时，CPU只能访问进程中被标记为用户空间的内存，试图访问内核空间会引发硬件异常。</li>
<li><strong>内核态</strong>：当处于内核态时，CPU既能访问用户内存空间，也能访问内核空间内存。一个用户态要切换到内核态，唯一方法是通过<strong>中断、故障、或者陷入系统调用</strong>这样的异常。处理后返回时，又变为用户模式。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/system.png" width="400"></li>
</ul>
<h5 id="shell">1.3 shell</h5>
<p>shell时一种具有特殊用途的的程序，主要用于读取用户输入的命令，并执行相应的程序以响应命令</p>
<h5 id="用户和组">1.4 用户和组</h5>
<ul>
<li><p><strong>用户</strong>：系统的每一个用户都有唯一的登录名和相应的整型用户UID</p></li>
<li><p><strong>组</strong>：为了管理方便，控制对文件和其它资源的访问，将多个用户分组。每个组都有相应的组ID（GID）。</p></li>
</ul>
<p>每个文件都有与之相应的用户ID和组ID，分别定义文件的属主和属组。系统根据所有权来判定用户对文件的访问权。</p>
<h5 id="单根目录层级目录链接及文件">1.5 单根目录层级、目录、链接及文件</h5>
<p>Linux内核维护着一套<strong>单根目录结构</strong>,以放置系统的所有文件，这与windows形成鲜明对比（windows分硬盘区映射）。Linux的目录层级的根未<code>/</code>，其余的所有目录均为其子孙： <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/root.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/home/trluper<span class="meta"># cd /</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/<span class="meta"># ls</span></span><br><span class="line">bin    dev   lib    libx32      mnt   root  snap      sys  var</span><br><span class="line">boot   etc   lib32  lost+found  opt   run   srv       tmp</span><br><span class="line">cdrom  home  lib64  media       proc  sbin  swapfile  usr</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/</code>：根目录，一般根目录下只存放目录，<strong>在<code>Linux</code>下有且只有一个根目录</strong>。所有的东西都是从这里开始。当你在终端里输入<code>/home</code>，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</li>
<li><code>/bin</code>: <strong>这一目录中存放了供超级用户和一般用户都可以使用的命令，常用的命令<code>ls、tar、mv、cat</code>等</strong></li>
<li><code>/usr/bin</code>: <strong>安装的外部的命令，<code>usr</code>表示的是<code>unix software source</code>，不是user。</strong></li>
<li><code>/boot</code>：放置<code>linux</code>系统启动时用到的一些文件，如<code>Linux</code>的内核文件<code>/boot/vmlinuz</code>，系统引导管理器<code>/boot/grub</code>。</li>
<li><code>/dev</code>：存放<code>linux</code>系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，</li>
<li><code>/etc</code>：<strong>系统配置文件存放的目录，不建议在此目录下存放可执行文件</strong>，重要的配置文件有 <code>/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</code></li>
<li><code>/home</code>：<strong>系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，<code>~edu</code>表示用户<code>edu</code>的家目录。</strong></li>
<li><code>/lib</code>：<strong>内核级别</strong>,系统使用的函数库的目录，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/lib</code>: <strong>系统级别</strong>，目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录</li>
<li><code>/usr/local/lib</code>：<strong>用户级别</strong>，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/include</code>：<strong>C程序语言编译使用的头文件。<code>linux</code>下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数</strong></li>
<li><code>/lost+fount</code>：系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li><code>/mnt、/media</code>:光盘默认挂载点，通常光盘挂载<code>/mnt/cdrom</code>下，也不一定，可以选择任意位置进行挂载。</li>
<li><code>/opt</code>：给主机额外安装软件所摆放的目录。</li>
<li><code>/proc</code>：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 <code>/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*</code> 等。</li>
<li><code>/root</code>：系统管理员root的家目录。</li>
<li><code>/sbin、/usr/sbin、/usr/local/sbin</code>：<strong>放置系统管理员使用的可执行命令</strong>，如<code>fdisk、shutdown、mount</code>等。<strong>与<code>/bin</code>不同的是，这几个目录是给系统管理员root使用的命令，</strong>一般用户只能&quot;查看&quot;而不能设置和使用。</li>
<li><code>/tmp</code>：<strong>一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</strong></li>
<li><code>/srv</code>：服务启动之后需要访问的数据目录，如<code>www</code>服务需要访问的网页数据存放在<code>/srv/www</code>内。</li>
<li><code>/usr</code>：<strong>应用程序存放目录，<code>/usr/bin</code>存放应用程序，<code>/usr/share</code>存放共享数据，<code>/usr/lib</code>存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。<code>/usr/local</code>:存放软件升级包。<code>/usr/share/doc:</code>系统说明文件存放目录。<code>/usr/share/man:</code>程序说明文件存放目录。</strong></li>
<li><code>/var</code>：放置系统执行过程中经常变化的文件，如随时更改的日志文件 <code>/var/log，/var/log/message</code>所有的登录文件存放目录，<code>/var/spool/mail</code>邮件存放的目录，<code>/var/run</code>程序或服务启动后，其PID存放在该目录</li>
</ul>
<p>Linux世界里，一切皆文件。在Linux中，文件可分为以下几种：<strong>普通文件（普通文件、可执行文件、压缩文件）、目录文件、设备文件、链接文件和套接字</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/linuxFile.png" width="400"></p>
<p><strong>文件符号标识：</strong></p>
<ul>
<li>普通文件:<code>-</code></li>
<li>目录：<code>d</code></li>
<li>字符设备：<code>c</code></li>
<li>管道：<code>p</code></li>
<li>符号链接：<code>l</code></li>
<li>套接字：<code>s</code></li>
<li>符号连结：<code>l</code></li>
<li>一般文件:<code>f</code></li>
</ul>
<h5 id="文件io">1.6 文件IO</h5>
<p>unix系统I/0模型具有通用性，即对任何文件采用<code>open()、read()、write()、close()</code>等这些系统调用的程序能够处理任何类型的文件。</p>
<p><strong><em>附</em></strong>：<code>stdio</code>函数库的I<code>fopen()、fclose()、scanf()、print()、fputs()、fgets()</code>等，这些函数位于系统调用<code>open()、read()、write()、close()</code>之上</p>
<h5 id="进程">1.7 进程</h5>
<p>进程是正在执行的程序的实例，当我们运行一个程序时就创建了一个进程。在执行过程中，内核会将程序代码载入虚拟内存，未程序变量分配空间<strong>(Linux中分配4G的虚拟内存映射)</strong>。</p>
<ul>
<li><p>因此在一个系统可同时运行多个进程，而每个进程都好像独占地使用硬件。</p></li>
<li><p>对于单核CPU来说进程是并发运行，则是说一个进程的指令和另一个进程的指令是交错执行（有重叠）的。传统的系统在一个时刻只能执行一个程序，但多核处理器能同时执行多个程序，即并行。</p></li>
<li><p>并发的实现是通过进程间切换来实现的（上下文切换），上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。</p></li>
<li><p>一个进程实际上可以由多个称为线程的执行单元组成。每个线程都运行在进程的上下文中，共享同样的代码、全局数据和堆。但它们有自己的栈，用来装载本地变量和函数调用链接信息。</p></li>
</ul>
<p><strong><em>特殊进程介绍</em></strong>： - <strong>init进程</strong>：init进程是Linux当中所有进程之父，当我们启动Linux系统时，它就已经在运行，后续的所有进程不是有init亲自创建<code>fork()</code>，就是尤其子孙创建的。init进程的<strong>ID号为1</strong>，以超级用户<code>root</code>权限运行，谁都无法杀死init进程，其任务是创建并监控系统运行过程中的一系列进程。</p>
<ul>
<li><strong>守护进程</strong>：守护进程也称为<strong>精灵进程</strong>，守护进程在后台运行，没有控制终端供其读取或写入数据的能力，只有在系统主动关闭是他才会消失，否则一直健在。有着它特殊的作用。</li>
</ul>
<h5 id="静态库和共享库">1.8 静态库和共享库</h5>
<ul>
<li><p><strong>静态链接</strong>：静态库时一种目标库，如果一个程序引用了静态库的函数，那么链接器在解析了引用之后，会从库中抽取所需目标模块，将其复制到最重可执行目标文件中，这就是静态链接。<strong>静态链接需要更多内存和静态库版本依赖严重</strong></p></li>
<li><p><strong>动态链接</strong>：共享库是一目标模块，在运行或加载时，可以加载到任意内存地址，并和一个内存中的程序链接起来，实施<strong>运行时链接。这个过程称为动态链接</strong></p></li>
</ul>
<h5 id="内存映射">1.9 内存映射</h5>
<p>调用系统函数<code>mmap()</code>的进程，会在指定进程的虚拟地址空间中创建一个新的内存映射，映射有两种：</p>
<ul>
<li><p><strong>文件映射：</strong>将文件的<strong>部分区域</strong>映射入调用进程的虚拟内存。映射一旦完成，对文件映射内容的访问则转化为对相应内存区域的字节操作（<strong>即将数据放入内存缓存中，避免磁盘反复I/O影响速率，这样就能加快执行效率</strong>）。注意映射不是一次性映射，而是按需自动从文件加载</p></li>
<li><p><strong>匿名映射</strong>：没有文件与之对应映射时，映射页面的内容会被初始化为0</p></li>
</ul>
<h5 id="进程间的通信和同步">1.10 进程间的通信和同步</h5>
<p>Linux上有许多进程在运行，有些时独立的，但有一些是相互合作的，Linux提供了丰富的进程间通信（IPC)机制：</p>
<ul>
<li>信号（signal),用来表示事件的发生</li>
<li>管道（shell当中的<code>|</code>操作）和FIFO，用于进程间的数据传递。</li>
<li>套接字，提供了一台主机或是联网的不同主机所运行进程之间的数据传递（服务端----客户端）</li>
<li>消息队列，用于进程间交换信息</li>
<li>信号量，用来同步进程动作</li>
<li>共享内存，运行两个及以上的进程共享一块内存，当某一进程改变了共享内存的内容，其他进程会知道。</li>
</ul>
<h5 id="信号">1.11 信号</h5>
<p>尽管信号被认为是IPC的一种，但是它运用于其他更为广泛，往往会将信号作为<strong>‘软件中断’</strong>，进程收到信号，就意味着某一事件或异常发生（如定时任务，<code>ctrl+c</code>中断）</p>
<p>信号的类型有很多，以<code>SIGXXX</code>标识，</p>
<p><strong><em>接下来就正式进入Linux系统编程的学习</em></strong></p>
<h4 id="系统调用">2. 系统调用</h4>
<p><strong>系统调用</strong>是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务</p>
<p>相应的操作系统也有不同的运行级别，<strong>用户态和内核态</strong>。</p>
<ul>
<li><strong>运行在内核态的进程可以毫无限制的访问各种资源，</strong></li>
<li>** 而在用户态下的用户进程的各种操作都有着限制，比如不能随意的访问内存、不能开闭中断以及切换运行的特权级别。**</li>
</ul>
<p>操作系统一般是通过软件中断从用户态切换到内核态。</p>
<h5 id="库函数和系统调用区别">2.1 库函数和系统调用区别</h5>
<p>Linux 下对文件操作有两种方式：<strong>系统调用（<code>system call</code>）和库函数调用（<code>Library functions</code>）。</strong></p>
<ul>
<li><strong>系统调用</strong>：系统调用是需要时间的，程序中频繁的使用系统调用会降低程序的运行效率。当运行内核代码时，CPU工作在内核态，在系统调用发生前需要保存用户态的栈和内存环境，然后转入内核态工作。系统调用结束后，又要切换回用户态。这种环境的切换会消耗掉许多时间 。</li>
</ul>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/libraryfunctions.png" width="100"></p>
<h5 id="文件描述符">2.2 文件描述符</h5>
<p>对文件进行相应的操作<code>open()、close()、write() 、read()</code>等）。打开现存文件或新建文件时，<strong>系统（内核）会返回一个文件描述符，文件描述符用来指定已打开的文件</strong></p>
<p>程序运行起来后（每个进程）都有一张文件描述符的表，标准输入、标准输出、标准错误输出设备文件被打开，对应的文件描述符 <code>0、1、2</code>记录在表中。程序运行起来后这三个文件描述符是默认打开的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN_FILENO 0  <span class="comment">//标准输入的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT_FILENO 1 <span class="comment">//标准输出的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR_FILENO 2 <span class="comment">//标准错误的文件描述符</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Linux 中一个进程默认最多只能打开的文件是1024个。</strong></p>
<h5 id="相关文件函数系统调用版">2.3 相关文件函数（系统调用版）</h5>
<h6 id="open函数">2.3.1 open函数</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">int</span> flags,<span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">	打开文件，如果文件不存在则可以选择创建，并返回一个文件描述符</span><br><span class="line">参数：</span><br><span class="line">	pathname:文件路径及文件名</span><br><span class="line">	flags:打开文件的行为标志，必选项有O_RDONLY,O_WRONLY,O_RDWR</span><br><span class="line">	mode:该参数只在文件不存时创建文件时有效，指新建文件时指定的文件权限</span><br></pre></td></tr></table></figure>
<p><strong>flages详细说明：</strong></p>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/statopen.png" width="500"></p>
<p><strong>mode说明：</strong>： <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/mode.png" width="500"></p>
<h6 id="close函数">2.3.2 close函数</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">	关闭已打开的文件</span><br><span class="line">参数：</span><br><span class="line">	fd:文件描述符，<span class="built_in">open</span>()返回值</span><br><span class="line">返回值：</span><br><span class="line">	成功：<span class="number">0</span></span><br><span class="line">	失败：<span class="number">-1</span>，并设置errno</span><br></pre></td></tr></table></figure>
<p>需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用<code>close</code>关闭，所以即使用户程序不调用<code>close</code>，在终止时内核也会自动关闭它打开的所有文件。</p>
<h6 id="write函数">2.3.3 write函数</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">sszie_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">void</span>* buf,<span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">	把指定数目的数据写到文件fd</span><br><span class="line">参数：</span><br><span class="line">	fd：文件描述符</span><br><span class="line">	buf：数据首地址</span><br><span class="line">	count：写入数据长度</span><br><span class="line">返回值：</span><br><span class="line">	成功：实写入数据的字节数</span><br><span class="line">	失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h6 id="read函数">2.3.4 read函数</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span>* buf,<span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">	把指定数目的数据读到内存（缓冲区）</span><br><span class="line">参数：</span><br><span class="line">	fd：文件描述符</span><br><span class="line">	buf：内存首地址</span><br><span class="line">	count：读取的字节数</span><br><span class="line">返回值：</span><br><span class="line">	成功：实际读取到的字节数</span><br><span class="line">	失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h6 id="lseek函数文件偏移量">2.3.5 lseek()函数:文件偏移量</h6>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/lseek.png" width="600"></p>
<p>所有打开的文件都有一个当前文件偏移量(current file offset)，以下简称为<code>cfo</code>。<code>cfo</code> 通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。</p>
<p><strong><em>示例：</em></strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd =<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> ret =<span class="number">-1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *str=<span class="string">&quot;trluper&quot;</span></span><br><span class="line">	<span class="type">char</span> buf[SIZE];</span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">&quot;txt&quot;</span>,O_WRONLY|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">	<span class="comment">//写入</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span>==fd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fd=%d\n&quot;</span>,fd);</span><br><span class="line">	ret= <span class="built_in">write</span>(fd,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span> == ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;write len:%d\n&quot;</span>,ret);</span><br><span class="line">	<span class="comment">//设置偏移量</span></span><br><span class="line">	ret=<span class="built_in">lseek</span>(fd,<span class="number">7</span>,SEEK_SET);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span> == ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">write</span>(fd,<span class="string">&quot; github&quot;</span>,<span class="number">6</span>);</span><br><span class="line">	<span class="comment">//将文件位置指针指向文件开头，读取</span></span><br><span class="line">	<span class="built_in">lseek</span>(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">	ret= <span class="built_in">read</span>(fd,buf,SIZE)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read ret:%d buf:%s\n&quot;</span>,ret,buf);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="perror">2.3.6 perror</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="comment">//输出函数调用失败的错误消息 会在你输入的字符串后面拼接错误信息 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> sys_errlist[];</span><br><span class="line"><span class="type">int</span> sys_nerr;</span><br><span class="line"><span class="comment">//error是一个全局变量 通过他获得错误码</span></span><br><span class="line"><span class="type">int</span> errno;</span><br></pre></td></tr></table></figure>
<p><strong>错误码</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	EPERM		 1	<span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOENT		 2	<span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESRCH		 3	<span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINTR		 4	<span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EIO		 5	<span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENXIO		 6	<span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	E2BIG		 7	<span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOEXEC		 8	<span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBADF		 9	<span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ECHILD		10	<span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EAGAIN		11	<span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOMEM		12	<span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EACCES		13	<span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFAULT		14	<span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTBLK		15	<span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBUSY		16	<span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EEXIST		17	<span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXDEV		18	<span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENODEV		19	<span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTDIR		20	<span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EISDIR		21	<span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINVAL		22	<span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENFILE		23	<span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMFILE		24	<span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTTY		25	<span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ETXTBSY		26	<span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFBIG		27	<span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOSPC		28	<span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESPIPE		29	<span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EROFS		30	<span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMLINK		31	<span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EPIPE		32	<span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EDOM		33	<span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ERANGE		34	<span class="comment">/* Math result not representable */</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="阻塞和非阻塞">2.4 阻塞和非阻塞</h5>
<ul>
<li><p><strong>读常规文件是不会阻塞的，不管读多少字节，<code>read</code>一定会在有限的时间内返回。</strong></p></li>
<li><p><strong>从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用<code>read</code>读终端设备就会阻塞</strong>，如果网络上没有接收到数据包，调用<code>read</code>从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。</p></li>
<li><p><strong>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定</strong></p></li>
</ul>
<h5 id="stat函数">2.5 stat()函数</h5>
<p>stat函数在之后的编程中会经常用到，可以了解一下 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/stat.png" width="600"> <code>struct stat</code>结构体说明：buf传出，获取指定文件信息 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/statbuf.png" width="600"> 使用实例1：判断文件类型（先明白如何判断，用man 2 stat查看st_mode的使用）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(s-&gt;st_mode&amp;S_IFMT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> S_IFREG:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是普通文件\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFDIR:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是目录\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFCHR:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是字符设备\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFBLK:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是块设备\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是套接字\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFFIFO:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是管道\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>文件类型和权限解释：</strong></p>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/filetype.png" width="600"></p>
<h5 id="文件描述符的复制">2.6 文件描述符的复制</h5>
<p>dup() 和 dup2() 是两个非常有用的系统调用，都是用来复制一个文件的描述符，使新的文件描述符也标识旧的文件描述符所标识的文件。</p>
<h6 id="dup函数">2.6.1 dup()函数</h6>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/dup.png" width="600"></p>
<h6 id="dup2函数">2.6.2 dup2()函数</h6>
<p>dup2函数：应用于重定向 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/dup2.png" width="600"></p>
<h5 id="fcnlt函数改变打开文件的性质">2.7 fcnlt函数：改变打开文件的性质</h5>
<p><strong><code>fcntl</code>函数有5种功能：</strong></p>
<ul>
<li><ol type="1">
<li>复制一个现有的描述符（cmd=F_DUPFD）</li>
</ol></li>
<li><ol start="2" type="1">
<li>获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD)</li>
</ol></li>
<li><ol start="3" type="1">
<li>获得／设置文件状态标记(cmd=F_GETFL或F_SETFL)</li>
</ol></li>
<li><ol start="4" type="1">
<li>获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN)</li>
</ol></li>
<li><ol start="5" type="1">
<li>获得／设置记录锁(cmd=F_GETLK, F_SETLK或F_SETLKW) <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/fcntl.png" width="600"></li>
</ol></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcnlt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//等价于dup()</span></span><br><span class="line">	<span class="type">int</span> new_fd=<span class="built_in">fcnlt</span>(fd,F_DUPFD,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//获取文件状态标记</span></span><br><span class="line">	<span class="type">int</span> flag=<span class="built_in">fcnlt</span>(fd,F_GETFD,<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">switch</span>(flag&amp;O_ACCMODE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> O_RDONLY:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;read only\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag&amp;O_APPEND)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;append\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flag|=O_APPEND;	<span class="comment">//追加flag</span></span><br><span class="line">	<span class="built_in">fcnlt</span>(new_fd,F_SETFT,flag);	<span class="comment">//设置状态标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="目录的相关函数">2.8 目录的相关函数</h5>
<h6 id="getcwd函数">2.8.1 getcwd函数</h6>
<p>getcwd函数：获取当前进程的工作目录 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/getcwd.png" width="600"></p>
<h6 id="chdir函数">2.8.2 chdir函数</h6>
<p><code>chdir</code>函数：修改当前进程的路径 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/chdir.png" width="500"></p>
<h6 id="opendir函数">2.8.3 opendir函数</h6>
<p><code>opendir</code>函数：打开一个目录，相当于cd命令 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/opendir.png" width="500"></p>
<h6 id="closedir函数">2.8.4 closedir函数</h6>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/closedir.png" width="500"></p>
<h6 id="readdir函数">2.8.5 readdir函数</h6>
<p><code>readdir</code>函数:读取目录 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/readdir.png" width="500"></p>
<p><strong>相关结构体说明：</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/dirent.png" width="500"></p>
<p>d_type文件类型说明： <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/d_type.png" width="500"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">github访问问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 14:29:48 / 修改时间：15:04:50" itemprop="dateCreated datePublished" datetime="2022-12-16T14:29:48+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/github/" itemprop="url" rel="index"><span itemprop="name">github</span></a>
                </span>
            </span>

          
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>545</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="github无法访问">1. github无法访问</h4>
<p>由于github是外国网站，常常会有些时候无法登进去，这是由于<code>github</code>的IP地址时常会发生改变，我们在浏览器输入 GitHub 的网址时，会向 DNS 服务器发送一个请求，获取到 GitHub 网站所在的服务器 IP 地址，从而进行访问。如果DNS未即使更新地址的话给你一个过期ip，你自然无法访问到。为解决这个问题，可以通过修改host。</p>
<h5 id="查询可通的ip地址">1.1 查询可通的ip地址</h5>
<p>首先通过<a target="_blank" rel="noopener" href="https://tool.chinaz.com/dns/?type=1&amp;host=github.com&amp;ip=">站长</a>,查询<code>github.com</code>可达的ip节点： <img src="/2022/12/16/github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/ip.jpg"></p>
<h5 id="本地修改host">1.2 本地修改host</h5>
<p>先找到域名解析文件 hosts 文件的位置，不同操作系统，hosts 文件的存储位置也不同：</p>
<ul>
<li>Windows 系统：<code>C:\Windows\System32\drivers\etc\hosts</code></li>
<li>Linux 系统：<code>/etc/hosts</code></li>
<li>Mac（苹果电脑）系统：<code>/etc/hosts</code></li>
<li>Android（安卓）系统：<code>/system/etc/hosts</code></li>
<li>iPhone（iOS）系统：<code>/etc/hosts</code></li>
</ul>
<p>进入host文件，在末尾增加该地址<code>20.205.243.166 www.github.com</code> <img src="/2022/12/16/github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/host.jpg"></p>
<p>最后在终端窗口执行：<code>ipconfig/flushdns</code>即可。</p>
<p><strong><em>附：</em></strong>你也可以用<a target="_blank" rel="noopener" href="https://github.com/521xueweihan/GitHub520">github520定时更新的host</a></p>
<p>将其复制到host保存,在执行<code>ipconfig/flushdns</code>即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/blog%E5%9F%9F%E5%90%8D%E6%8C%82%E9%9D%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/blog%E5%9F%9F%E5%90%8D%E6%8C%82%E9%9D%A0/" class="post-title-link" itemprop="url">blog域名挂靠</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 13:37:53 / 修改时间：14:20:00" itemprop="dateCreated datePublished" datetime="2022-12-16T13:37:53+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/blog/" itemprop="url" rel="index"><span itemprop="name">blog</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/12/16/blog%E5%9F%9F%E5%90%8D%E6%8C%82%E9%9D%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/12/16/blog%E5%9F%9F%E5%90%8D%E6%8C%82%E9%9D%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>505</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="github上的博客域名挂靠">1. github上的博客域名挂靠</h4>
<p>由于github是外国网站，存在者有时候节点ip无法访问到github，导致博客也登不上去，为了解决这个方法，可以使用域名进行挂靠。</p>
<h5 id="域名设置">1.1 域名设置</h5>
<p>域名购买可以买腾讯云、阿里喝华为的，这里以腾讯云为例子，点击<a target="_blank" rel="noopener" href="https://cloud.tencent.com/act/pro/domain_sales?fromSource=gwzcw.6927043.6927043.6927043&amp;utm_medium=cpc&amp;utm_id=gwzcw.6927043.6927043.6927043&amp;bd_vid=11616374416468829912">域名购买</a>。购买完成后，进入<a target="_blank" rel="noopener" href="https://console.cloud.tencent.com/domain">域名控制平台</a>-&gt;我的域名，进行设置： <img src="/2022/12/16/blog%E5%9F%9F%E5%90%8D%E6%8C%82%E9%9D%A0/yuming.jpg"></p>
<p>点击<strong>解析</strong>,进入如下页面： <img src="/2022/12/16/blog%E5%9F%9F%E5%90%8D%E6%8C%82%E9%9D%A0/jiexi.jpg"> <strong>然后增加<code>CNAME</code>记录类型，其记录值为你的博客地址，如我的为<code>trluper.github.io</code></strong></p>
<h5 id="github进行settings">1.2 github进行settings</h5>
<p>完成上面步骤后，进入你github的博客仓库，点击<code>settings</code>后选择<code>Pages</code>,设置<code>custom domain</code>的值为你购买的域名，如我的为<code>trluper.cn</code>。 <img src="/2022/12/16/blog%E5%9F%9F%E5%90%8D%E6%8C%82%E9%9D%A0/github.jpg"></p>
<p>之后大功告成，可以测试一下是否通过域名能够访问你的博客。</p>
<h5 id="解决每次git-depoly后域名消失">1.3 解决每次git depoly后域名消失</h5>
<p>git deploy之后发现个问题，访问自己的域名返回404，查看github的Custom domain发现已经被还原为空值。解决方案为： - 在你的本地blog文件中<code>source</code>目录下，增加一文件<code>CNAME</code>,文件内只写上你自己的域名url <img src="/2022/12/16/blog%E5%9F%9F%E5%90%8D%E6%8C%82%E9%9D%A0/xiaoshi.jpg"></p>
<p>然后进行<code>hexo clean\hexo g\ hexo s</code>即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/vim/" class="post-title-link" itemprop="url">vim</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-16 11:50:28 / 修改时间：13:57:09" itemprop="dateCreated datePublished" datetime="2022-12-16T11:50:28+08:00">2022-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vim/" itemprop="url" rel="index"><span itemprop="name">vim</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vim/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/12/16/vim/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/12/16/vim/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>787</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="vim的三种模式">6.1 vim的三种模式</h5>
<p>vi有三种基本工作模式: <strong>命令模式、文本输入模式(编辑模式)、末行模式</strong></p>
<ul>
<li><p><strong>命令模式：</strong> <strong>任何时候,不管用户处于何种模式,只要按一下<code>ESC</code>键,即可使<code>vi</code>进入命令模式</strong>。我们在<code>shell</code>环境(提示符为<code>$</code>)下输入启动<code>vim</code>命令，进入编辑器时，也是处于该模式下。在命令模式下，用户可以输入各种合法的<code>vi</code>命令，用于管理自己的文档。<strong>此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的<code>vi</code>命令，则<code>vi</code>在接受用户命令之后完成相应的动作</strong>。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是<code>vi</code>的合法命令，<code>vi</code>会响铃报警。</p></li>
<li><p>文本输入模式： 在命令模式下输入插入命令<code>i（I）、附加命令a（A） 、打开命令o（O）、替换命s（S）</code>都可以进入文本输入模式，此时vi窗口的最后一行会显示“插入”,可进行文本编辑.</p></li>
<li><p>末行模式： 末行模式下，用户可以对文件进行一些附加处理。尽管命令模式下的命令可以完成很多功能，但要执行一些如字符串查找、替换、显示行号等操作还是必须要进入末行模式的。<strong>在命令模式下，输入冒号<code>:</code>即可进入末行模式。此时vi窗口的状态行会显示出冒号，等待用户输入命令。用户输入完成后，按回车执行，之后<code>vi</code>编辑器又自动返回到命令模式下</strong> <img src="/2022/12/16/vim/vi-vim.gif"></p></li>
</ul>
<h5 id="命令模式下的命令操作">6.2 命令模式下的命令操作</h5>
<h6 id="切换到编辑模式">6.2.1 切换到编辑模式</h6>
<p><img src="/2022/12/16/vim/vimbianji.png"></p>
<h6 id="光标移动">6.2.2 光标移动</h6>
<p><img src="/2022/12/16/vim/mousemove.png"></p>
<h6 id="删除">6.2.3 删除</h6>
<p><img src="/2022/12/16/vim/delete.png"> <strong>常用：<code>D</code>、<code>dG</code>、<code>nx</code>(n为数字)、<code>ndd</code></strong></p>
<h6 id="查找">6.2.4 查找</h6>
<p><img src="/2022/12/16/vim/find.png"></p>
<h6 id="可视模式">6.2.5 可视模式</h6>
<p><img src="/2022/12/16/vim/copydelete.png"></p>
<h6 id="粘贴和复制">6.2.6 粘贴和复制</h6>
<ul>
<li><code>p</code>:粘贴在光标后面</li>
<li><code>P</code>:粘贴在光标前面</li>
<li><code>y</code>:拷贝行</li>
<li><code>Y</code>:拷贝行</li>
</ul>
<h5 id="末行模式下的命令操作">6.3 末行模式下的命令操作</h5>
<h6 id="保存退出">6.3.1 保存退出</h6>
<p><img src="/2022/12/16/vim/saveexit.png"></p>
<h6 id="替换">6.3.2 替换</h6>
<p><img src="/2022/12/16/vim/tihuan.png"> 可以从上图总结：<code>s(</code>代表本行，<code>g</code>为所有(global)都替换，<code>%</code>指本文件所有行，<code>c</code>每次替换都要求确认</p>
<h6 id="分屏">6.3.3 分屏</h6>
<p><img src="/2022/12/16/vim/fenping.png"></p>
<h6 id="其他用法扩展">6.3.4 其他用法扩展</h6>
<p><img src="/2022/12/16/vim/others.png"></p>
<h5 id="vim的配置文件所在">6.4 vim的配置文件所在</h5>
<p>局部配置文件（推荐）：<code>~/.vimrc</code> 全局配置文件:<code>/etc/vim/vimrc</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/29/Effective-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/29/Effective-C/" class="post-title-link" itemprop="url">Effective C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-29 18:26:41 / 修改时间：21:01:48" itemprop="dateCreated datePublished" datetime="2022-10-29T18:26:41+08:00">2022-10-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/" itemprop="url" rel="index"><span itemprop="name">Effective C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-C/C/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/10/29/Effective-C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/29/Effective-C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>在本笔记中主要对《Effective C++》一书中的重要条款做学习笔记，提取当中主要的知识点和面试考点，读者在进行<code>C plus plus</code>岗位面试前可细读该篇文章的（重要）部分。</strong></p>
<h5 id="条款1视c为一个语言联邦">1 条款1：视C++为一个语言联邦</h5>
<p>在C++中我们总会有一种错觉，那就是人为C++主要就是面向对象的编程，但是这是不全面的，作为从C中延伸的语言，它保留了C的特性，也集成了许多新的功能，你可理解成:</p>
<ul>
<li>C：以C为基础。</li>
<li>面向对象的C++：添加面向对象特性。</li>
<li>模板C++：泛型编程概念，使用模板。</li>
<li>STL：使用STL的容器、迭代器、算法、及函数对象。</li>
</ul>
<p>四者的集合</p>
<h5 id="条款2尽量用编译器替换预处理器">2 条款2：尽量用编译器替换预处理器</h5>
<p>在C/C++中，我们明白一个程序流程为<code>预处理--&gt;编译--&gt;汇编--&gt;链接</code>，在预处理阶段中，我们对文件内的进行<strong>头文件展开、宏替换和去注释</strong>等预处理操作。那么也就是说<strong>像宏定义相关的定义从未被编译器看见</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.645</span></span><br></pre></td></tr></table></figure> 上面的记号名称<code>ASPECT_RATIO</code>也许在编译器开始处理源码之前它就被预处理器移走了，于是该记号就没有进入<strong>记号表（在二进制文件即生成的<code>.o</code>文件中）</strong>。那么当你运用此常量但获得一个编译错误信息时，这个错误信息也许只会提到<code>1.653</code>而不是<code>ASPECT_ARTIO</code>，而它又被定义在一个非你所写的头文件，那么你对<code>1.635</code>来自何处毫无概念，你要耗费大量时间寻找它。</p>
<p>用<code>const</code>替换<code>#define</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> AspectRatio=<span class="number">1.635</span>;</span><br></pre></td></tr></table></figure> 作为一个常量，它肯定能被编译器看到并放到符号表内。</p>
<p>基于上述的一个讲解，因此对于条款2有一下准则：</p>
<ul>
<li>对于单纯常量，尽量以<code>const</code>对象或<code>enums</code>枚举来代替#define。</li>
<li>若用<code>define</code>的可能会导致程序出出现多份目标码，而常量不会出现这种情况</li>
<li>取一<code>enum</code>的地址就不合法，这种行为和<code>define</code>类似因此可以用此来代替<code>define</code> ，如果你不想让别人获得一个<code>pointer</code>或<code>reference</code>指向你的某个整数常量，<code>enum</code>可以帮助你实现这个约束。</li>
<li>对于函数宏，用<code>inline</code>函数代替<code>#define</code>（<code>define</code>是死板的替换，容易产生传递计算式类似累加多次的问题）</li>
</ul>
<h5 id="条款3尽可能使用const重要">3. 条款3：尽可能使用const(重要)</h5>
<p><code>const</code>是C++中最为常用、也是最为强大的一个关键字，也是面试过程中极有可能问到的。<strong><code>const</code>可以修饰变量、指针、引用、函数、static</strong>。在说其详细应用时，我们必须先去了解<code>const</code>规则：</p>
<ul>
<li><code>const</code>修饰指针时分为底层<code>const</code>和顶层<code>const</code>。</li>
<li>非<code>const</code>变量可以赋值给<code>const</code>变量，反之不行。</li>
<li><code>const</code>常量必须被初始化</li>
<li>后续不能对<code>const</code>常量做改变</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/29/pytorch%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/29/pytorch%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">pytorch常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-29 15:50:21" itemprop="dateCreated datePublished" datetime="2022-10-29T15:50:21+08:00">2022-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-16 16:25:37" itemprop="dateModified" datetime="2022-11-16T16:25:37+08:00">2022-11-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">深度学习算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/10/29/pytorch%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/29/pytorch%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="torch">1. torch</h4>
<p>包 torch 包含了多维张量的数据结构以及基于其上的多种数学操作。另外，它也提供了多种工具，其中一些可以更有效地对张量和任意类型进行序列化。</p>
<p>它有 CUDA 的对应实现，可以在 NVIDIA GPU 上进行张量运算(计算能力&gt;=2.0)。</p>
<h5 id="tensor张量">1.1 Tensor张量</h5>
<h6 id="torch.numel">1.1.1 torch.numel</h6>
<p><code>torch.numel(input)-&gt;int</code>，返回 input 张量中的元素个数。</p>
<ul>
<li>参数: input (Tensor)为输入张量对象 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.randn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.numel(a)</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="创建操作">1.2 创建操作</h5>
<h6 id="torch.eye">1.2.1 torch.eye</h6>
<p><code>torch.eye(n, m=None, out=None)</code>,返回一个 2 维张量，对角线位置全 1，其它位置全 0</p>
<ul>
<li><code>n (int )</code> – 行数</li>
<li><code>m (int, optional)</code> – 列数.如果为 None,则默认为 n</li>
<li><code>out (Tensor, optinal)</code> - Output tensor</li>
</ul>
<p>返回值: 对角线位置全 1，其它位置全 0 的 2 维张量 返回值类型: Tensor <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.eye(<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">[torch.FloatTensor of size 3x3]</span><br></pre></td></tr></table></figure></p>
<h6 id="from_numpy">1.2.2 from_numpy</h6>
<p><code>torch.from_numpy(ndarray) → Tensor</code>。将 numpy.ndarray 转换为 pytorch 的 Tensor。返回的张量 tensor 和 numpy的 ndarray 共享同一内存空间。修改一个会导致另外一个也被修改。返回的张量不能改变大小。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = numpy.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = torch.from_numpy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">torch.LongTensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([-<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></p>
<h6 id="torch.linspace">1.2.3 torch.linspace</h6>
<p><code>torch.linspace(start, end, steps=100, out=None) → Tensor</code>返回一个 1 维张量，包含在区间 <code>start</code> 和 <code>end</code> 上均匀间隔的 step 个点。 输出 1 维张量的长度为</p>
<ul>
<li><code>start (float)</code> – 序列的起始点</li>
<li><code>end (float)</code> – 序列的最终值</li>
<li><code>steps (int)</code> – 在 start 和 end 间生成的样本数</li>
<li><code>out (Tensor, optional)</code> – 结果张量 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.linspace(<span class="number">3</span>, <span class="number">10</span>, steps=<span class="number">5</span>)</span><br><span class="line"><span class="number">3.0000</span></span><br><span class="line"><span class="number">4.7500</span></span><br><span class="line"><span class="number">6.5000</span></span><br><span class="line"><span class="number">8.2500</span></span><br><span class="line"><span class="number">10.0000</span></span><br><span class="line">[torch.FloatTensor of size <span class="number">5</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.ones">1.2.4 torch.ones</h6>
<p><code>torch.ones(*sizes, out=None) → Tensor</code>.返回一个全为 1 的张量，形状由可变参数 sizes 定义。 参数:</p>
<ul>
<li><code>sizes (int...)</code> – 整数序列，定义了输出形状</li>
<li><code>out (Tensor, optional)</code> – 结果张量 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.ones(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">[torch.FloatTensor of size 2x3]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.rand">1.2.5 torch.rand</h6>
<p><code>torch.rand(*sizes, out=None) → Tensor</code>返回一个张量，包含了从区间[0,1)的均匀分布中抽取的一组随机数，形状由可变参数sizes 定义。 参数:</p>
<ul>
<li><code>sizes (int...)</code> – 整数序列，定义了输出形状</li>
<li><code>out (Tensor, optinal)</code> - 结果张量 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.rand(<span class="number">4</span>)</span><br><span class="line"><span class="number">0.9193</span></span><br><span class="line"><span class="number">0.3347</span></span><br><span class="line"><span class="number">0.3232</span></span><br><span class="line"><span class="number">0.7715</span></span><br><span class="line">[torch.FloatTensor of size <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.randn">1.2.6 torch.randn</h6>
<p><code>torch.randn(*sizes, out=None) → Tensor</code>.返回一个张量，包含了从标准正态分布(均值为 0，方差为 1，即高斯白噪声)中抽取一组随机数，形状由可变参数 sizes 定义。 参数:</p>
<ul>
<li><code>sizes (int...)</code> – 整数序列，定义了输出形状</li>
<li><code>out (Tensor, optinal)</code> - 结果张量 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1.4339</span> <span class="number">0.3351</span> -<span class="number">1.0999</span></span><br><span class="line"><span class="number">1.5458</span> -<span class="number">0.9643</span> -<span class="number">0.3558</span></span><br><span class="line">[torch.FloatTensor of size 2x3]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.randperm">1.2.7 torch.randperm</h6>
<p><code>torch.randperm(n, out=None) → LongTensor</code>.给定参数 n，返回一个从 0 到 n-1 的随机整数排列。 参数:</p>
<ul>
<li><code>n (int)</code> – 上边界(不包含) <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.randperm(<span class="number">4</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">[torch.LongTensor of size <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.arange">1.2.8 torch.arange</h6>
<p><code>torch.arange(start, end, step=1, out=None) → Tensor</code>。返回一个 1 维张量，长度为 <code>floor((end−start)/step)</code>。包含从<code>start</code>到<code>end</code>，以 <code>step</code> 为步长的一组序列值(默认步长为 1)。 参数:</p>
<ul>
<li><code>start (float)</code> – 序列的起始点</li>
<li><code>end (float)</code> – 序列的终止点</li>
<li><code>step (float)</code> – 相邻点的间隔大小 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.arange(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[torch.FloatTensor of size <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.range">1.2.9 torch.range</h6>
<p><code>torch.range(start, end, step=1, out=None) → Tensor</code>。返回一个 1 维张量，有 <code>floor((end−start)/step)+1</code>个元素。包含在半开区间<code>[start, end）</code>从 start开始，以 step 为步长的一组值。 step 是两个值之间的间隔，即 <code>xi+1=xi+step</code></p>
<p><strong><em>警告：建议使用函数 torch.arange()</em></strong></p>
<ul>
<li><code>start (float)</code> – 序列的起始点</li>
<li><code>end (float)</code> – 序列的最终值</li>
<li><code>step (int)</code> – 相邻点的间隔大小 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;torch.<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">[torch.FloatTensor of size <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.tensor">1.2.10 torch.tensor</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">torch.tensor(data, </span><br><span class="line">             dtype=<span class="literal">None</span>, </span><br><span class="line">             device=<span class="literal">None</span>, </span><br><span class="line">             requires_grad=<span class="literal">False</span>, </span><br><span class="line">             pin_memory=<span class="literal">False</span>) -&gt; Tensor</span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code>：数据，可以是list，也可以是numpy</li>
<li><code>dtype</code>：数据类型，默认和data一致</li>
<li><code>device</code>：tensor所在的设备</li>
<li><code>requires_grad</code>：是否需要梯度，默认False，在搭建神经网络时需要将求导的参数设为True</li>
<li><code>pin_memory</code>：是否存于锁页内存，默认False</li>
</ul>
<h6 id="torch.zeros">1.2.11 torch.zeros</h6>
<p>返回一个全为标量 0 的张量，形状由可变参数 sizes 定义。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">torch.zeros(*size, </span><br><span class="line">            out=<span class="literal">None</span>, </span><br><span class="line">            dtype=<span class="literal">None</span>, </span><br><span class="line">            layout=torch.strided, </span><br><span class="line">            device=<span class="literal">None</span>, </span><br><span class="line">            requires_grad=<span class="literal">False</span>) -&gt; Tensor</span><br></pre></td></tr></table></figure> - <code>size</code>：张量的形状，如（3，3） - <code>layout</code> ：这个是内存中的布局形式,有strided和sparse_coo等 - <code>out</code>：表示输出张量，就是再把这个张量赋值给别的一个张量，但是这两个张量时一样的，指的同一个内存地址 - <code>device</code>：所在的设备，gpu/cpu - <code>requires_grad</code>：是否需要梯度</p>
<h5 id="tensor的常用操作">1.3 Tensor的常用操作</h5>
<p>对于tensor数据我们经常会进行切片、索引、降维、升维、连接等操作。这里介绍一下我们经常用到的。</p>
<h6 id="torch.cat">1.3.1 torch.cat</h6>
<p><code>torch.cat(inputs, dimension=0) → Tensor</code>。在<strong>给定维度</strong>上对输入的张量序列 seq 进行连接操作。<code>torch.cat()</code>可以看做 <code>torch.split()</code>和 <code>torch.chunk()</code>的反操作。</p>
<ul>
<li><code>inputs (sequence of Tensors)</code> – 可以是任意相同 Tensor 类型的 python 序列</li>
<li><code>dimension (int, optional)</code> – 沿着此维连接张量序列。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#沿着0维合并</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">0.5983</span> -<span class="number">0.0341</span> <span class="number">2.4918</span></span><br><span class="line"><span class="number">1.5981</span> -<span class="number">0.5265</span> -<span class="number">0.8735</span></span><br><span class="line">[torch.FloatTensor of size 2x3]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, x, x), <span class="number">0</span>)</span><br><span class="line"><span class="number">0.5983</span> -<span class="number">0.0341</span> <span class="number">2.4918</span></span><br><span class="line"><span class="number">1.5981</span> -<span class="number">0.5265</span> -<span class="number">0.8735</span></span><br><span class="line"><span class="number">0.5983</span> -<span class="number">0.0341</span> <span class="number">2.4918</span></span><br><span class="line"><span class="number">1.5981</span> -<span class="number">0.5265</span> -<span class="number">0.8735</span></span><br><span class="line"><span class="number">0.5983</span> -<span class="number">0.0341</span> <span class="number">2.4918</span></span><br><span class="line"><span class="number">1.5981</span> -<span class="number">0.5265</span> -<span class="number">0.8735</span></span><br><span class="line">[torch.FloatTensor of size 6x3]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.chunk">1.3.2 torch.chunk</h6>
<p><code>torch.chunk(tensor, chunks, dim=0)</code>。在给定维度(轴)上将输入张量进行分块儿。</p>
<ul>
<li><code>tensor (Tensor)</code> – 待分块的输入张量</li>
<li><code>chunks (int)</code> – 分块的个数</li>
<li><code>dim (int)</code> – 沿着此维度进行分块</li>
</ul>
<h6 id="torch.split">1.3.3 torch.split</h6>
<p><code>torch.split(tensor, split_size, dim=0)</code>。将输入张量分割成相等形状的 chunks（如果可分）。 如果沿指定维的张量形状大小不能被<code>split_size</code>整分， 则最后一个分块会小于其它分块。</p>
<ul>
<li><code>tensor (Tensor)</code> – 待分割张量</li>
<li><code>split_size (int)</code> – 单个分块的形状大小</li>
<li><code>dim (int)</code> – 沿着此维进行分割</li>
</ul>
<h6 id="torch.squeeze">1.3.4 torch.squeeze</h6>
<p><code>torch.squeeze(input, dim=None, out=None)</code>。当未给定<code>dim</code>时，将输入张量形状中维度为1 去除并返回。 如果输入是形如<code>(A×1×B×1×C×1×D)</code>，那么输出形状就为：<code>(A×B×C×D)</code></p>
<p>当给定 dim 时 ， 那 么 挤 压 操 作 只 在 给 定 维 度 上 。 例 如 ， 输 入 形 状为: <code>(A×1×B)</code>, <code>squeeze(input, 0)</code> 将会保持张量不变，只有用 <code>squeeze(input, 1)</code>，形状会变成<code>(A×B)</code>。</p>
<p><strong><em>注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。</em></strong> 参数:</p>
<ul>
<li><code>input (Tensor)</code> – 输入张量</li>
<li><code>dim (int, optional)</code> – 如果给定，则 input 只会在给定维度挤压</li>
<li><code>out (Tensor, optional)</code> – 输出张量 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.zeros(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.size()</span><br><span class="line">(<span class="number">2L</span>, <span class="number">1L</span>, <span class="number">2L</span>, <span class="number">1L</span>, <span class="number">2L</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.squeeze(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.size()</span><br><span class="line">(<span class="number">2L</span>, <span class="number">2L</span>, <span class="number">2L</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.squeeze(x, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.size()</span><br><span class="line">(<span class="number">2L</span>, <span class="number">1L</span>, <span class="number">2L</span>, <span class="number">1L</span>, <span class="number">2L</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.squeeze(x, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.size()</span><br><span class="line">(<span class="number">2L</span>, <span class="number">2L</span>, <span class="number">1L</span>, <span class="number">2L</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.stacksource">1.3.5 torch.stack[source]</h6>
<p><code>torch.stack(sequence, dim=0)</code>。沿着一个新维度对输入张量序列进行连接。 序列中所有的张量都应该为相同形状。</p>
<p>参数:</p>
<ul>
<li><code>sqequence (Sequence)</code> – 待连接的张量序列</li>
<li><code>dim (int)</code> – 插入的维度。必须介于 0 与 待连接的张量序列数之间。</li>
</ul>
<h6 id="torch.transpose">1.3.6 torch.transpose</h6>
<p><code>torch.transpose(input, dim0, dim1, out=None) → Tensor</code>。交换维度 dim0 和 dim1。 输出张量与输入张量共享内存，所以改变其中一个会导致另外一个也被修改。</p>
<ul>
<li><code>input (Tensor)</code> – 输入张量</li>
<li><code>dim0 (int)</code> – 转置的第一维</li>
<li><code>dim1 (int)</code> – 转置的第二维 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">0.5983</span> -<span class="number">0.0341</span> <span class="number">2.4918</span></span><br><span class="line"><span class="number">1.5981</span> -<span class="number">0.5265</span> -<span class="number">0.8735</span></span><br><span class="line">[torch.FloatTensor of size 2x3]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.unsqueeze">1.3.7 torch.unsqueeze</h6>
<p><code>torch.unsqueeze(input, dim, out=None)</code>。返回一个新的张量，对输入的制定位置插入维度1 注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。如果 <code>dim</code> 为负，则将会被转化 <code>dim+input.dim()+1</code> 参数:</p>
<ul>
<li><code>tensor (Tensor)</code> – 输入张量</li>
<li><code>dim (int)</code> – 插入维度的索引</li>
<li><code>out (Tensor, optional)</code> – 结果张量</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.Tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.unsqueeze(x, <span class="number">0</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">[torch.FloatTensor of size 1x4]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.unsqueeze(x, <span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">[torch.FloatTensor of size 4x1]</span><br></pre></td></tr></table></figure>
<h4 id="nn模块">2. nn模块</h4>
<p>首先应该知道在nn模块当中有两个重要的，分别是<code>torch.nn.Module</code>和<code>nn.functional</code>。<code>torch.nn.Module</code>是所有网络的基类。你的模型也应该继承这个类。 ##### 2.1 一般函数 ###### 2.1.1 nn.ModuleList() 将<code>submodules</code>保存在一个<code>list</code>中。ModuleList 可以像一般的 Python list 一样被索引。而且 ModuleList 中包含的 modules 已经被正确的注册，对所有的 module method 可见。它与<code>Sequential()</code>相似，只是为了集成一些操作便于管理。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> out_channel in vgg_out_channels:</span><br><span class="line">    #M为最大池化操作</span><br><span class="line">    <span class="keyword">if</span> out_channel == <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        layers += [nn.<span class="built_in">MaxPool2d</span>(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)]</span><br><span class="line">    #其他为卷积，输出为指定值，刚开始为<span class="number">3</span>通道</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        conv2d = nn.<span class="built_in">Conv2d</span>(in_channel, out_channel, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        layers += [conv2d, nn.<span class="built_in">ReLU</span>(inplace=True)]</span><br><span class="line">        in_channel = out_channel</span><br><span class="line">self.vgg = nn.<span class="built_in">ModuleList</span>(layers)</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">feats = self.vgg[idx](feats)</span><br></pre></td></tr></table></figure></p>
<h6 id="nn.sequential">2.1.2 nn.Sequential()</h6>
<p><code>torch.nn.Sequential</code>是一个<code>Sequential</code>容器，模块将按照构造函数中传递的顺序添加到模块中。另外，也可以传入一个有序模块。具体理解如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.covn1=nn.<span class="built_in">Sequential</span>(nn.<span class="built_in">Conv2d</span>(<span class="number">96</span>, <span class="number">96</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>), nn.<span class="built_in">BatchNorm2d</span>(<span class="number">96</span>), nn.<span class="built_in">ReLU</span>(inplace=True),</span><br><span class="line">              nn.<span class="built_in">Conv2d</span>(<span class="number">96</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>), nn.<span class="built_in">BatchNorm2d</span>(<span class="number">32</span>), nn.<span class="built_in">ReLU</span>(inplace=True))</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">features=self.<span class="built_in">covn1</span>(features)</span><br></pre></td></tr></table></figure></p>
<h6 id="torch.nn.parameter">2.1.3 torch.nn.Parameter()</h6>
<p><code>torch.nn.Parameter</code>继承torch.Tensor，其作用将一个不可训练的类型为Tensor的参数转化为可训练的类型为<code>parameter</code>的参数，并将这个参数绑定到<code>module</code>里面，成为<code>module</code>中可训练的参数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Parameter</span>(Tensor data, <span class="type">bool</span> requires_grad)</span><br></pre></td></tr></table></figure> 其中：data为传入Tensor类型参数，requires_grad默认值为True，表示可训练，False表示不可训练。</p>
<h5 id="卷积函数和层次常用">2.2 卷积函数和层次常用</h5>
<h6 id="conv1d">2.2.1 Conv1d</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Conv1d</span>(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, </span><br><span class="line">groups=<span class="number">1</span>, bias=True)</span><br></pre></td></tr></table></figure>
<h6 id="conv2d">2.2.2 Conv2d</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Conv2d</span>(in_channels, </span><br><span class="line">                out_channels, </span><br><span class="line">                kernel_size, </span><br><span class="line">                stride=<span class="number">1</span>, </span><br><span class="line">                padding=<span class="number">0</span>, </span><br><span class="line">                dilation=<span class="number">1</span>, </span><br><span class="line">                groups=<span class="number">1</span>, </span><br><span class="line">                bias=True, </span><br><span class="line">                padding_mode=<span class="string">&#x27;zeros&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>in_channels(int)</code> – 输入信号的通道</li>
<li><code>out_channels(int)</code> – 卷积产生的通道</li>
<li><code>kerner_size(int or tuple)</code> - 卷积核的尺寸</li>
<li><code>stride(int or tuple, optional)</code> - 卷积步长</li>
<li><code>padding(int or tuple, optional)</code> - 输入的每一条边补充 0 的层数</li>
<li><code>dilation(int or tuple, optional)</code> – <strong>定义了卷积核处理数据时各值的间距。换句话说，相比原来的标准卷积，扩张卷积多了一个超参数称之为dilation rate（扩张率），指的是kernel各点之间的间隔数量，正常的卷积核的dilation为1。</strong></li>
<li><code>groups(int, optional)</code> – 从输入通道到输出通道的阻塞连接数</li>
<li><code>bias(bool, optional)</code> - 如果 bias=True，添加偏置</li>
</ul>
<p><img src="/2022/10/29/pytorch%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/dialation.gif" width="400"> 上图是一个扩张率为2，尺寸为 3×3 的空洞卷积，感受野与5×5的卷积核相同，而且仅需要9个参数。在相同的计算条件下，空洞卷积提供了更大的感受野，获得更为丰富的上下文信息。</p>
<h6 id="conv3d">2.2.3 Conv3d</h6>
<p>三维卷积层, 输入的尺度是<code>(N, C_in,D,H,W)</code>，输出尺度<code>（N,C_out,D_out,H_out,W_out）</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Conv3d</span>(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, </span><br><span class="line">groups=<span class="number">1</span>, bias=True)</span><br></pre></td></tr></table></figure></p>
<h6 id="convtranspose1d">2.2.4 ConvTranspose1d</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">ConvTranspose1d</span>(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, </span><br><span class="line">output_padding=<span class="number">0</span>, groups=<span class="number">1</span>, bias=True)</span><br></pre></td></tr></table></figure>
<p>1 维的解卷积操作（transposed convolution operator，注意改视作操作可视作解卷积操作，但并不是真正的解卷积操作） <strong>该模块可以看作是 Conv1d 相对于其输入的梯度</strong>，有时（但不正确地）被称为解卷积操作</p>
<p><strong><em>注意：由于内核的大小，输入的最后的一些列的数据可能会丢失。因为输入和输出是不是完全的互相关。因此，用户可以进行适当的填充（padding 操作）。</em></strong></p>
<h6 id="convtranspose2d">2.2.5 ConvTranspose2d</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">ConvTranspose2d</span>(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, </span><br><span class="line">output_padding=<span class="number">0</span>, groups=<span class="number">1</span>, bias=True)</span><br></pre></td></tr></table></figure>
<p>2 维的转置卷积操作（transposed convolution operator，注意改视作操作可视作解卷积操作，但并不是真正的解卷积操作） 该模块可以看作是 Conv2d 相对于其输入的梯度，有时（但不正确地）被称为解卷积操作。</p>
<h6 id="nn.linear">2.2.6 nn.Linear</h6>
<p>对输入数据做线性变换：$y=Ax+b#，也是我们MLP中使用的函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Linear</span>(in_features, out_features, bias=True)</span><br></pre></td></tr></table></figure> - <code>in_features</code> - 每个输入样本的大小 - <code>out_features</code> - 每个输出样本的大小 - <code>bias</code> - 若设置为 False，这层不会学习偏置。默认值：True</p>
<h6 id="dropout">2.2.7 Dropout</h6>
<p>随机以概率p将输入张量中部分元素设置为 0。对于每次前向调用，被置 0 的元素都是随机的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Dropout</span>(p=<span class="number">0.5</span>, inplace=False)</span><br></pre></td></tr></table></figure> - <code>p</code> - 将元素置 0 的概率。默认值：0.5 - <code>in-place</code> - 若设置为 True，会在原地执行操作。默认值：False</p>
<h5 id="池化函数">2.3 池化函数</h5>
<h6 id="maxpool2d">2.3.1 MaxPool2d</h6>
<p>对于输入信号的输入通道，提供 2 维最大池化（max pooling）操作。如果输入的大小是<code>(N,C,H,W)</code>，那么输出的大小是<code>(N,C,H_out,W_out)</code>。即只会改变矩阵大小，不会改变通道数量。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.<span class="built_in">MaxPool2d</span>(kernel_size, stride=None, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, return_indices=False, ceil_mode=False)</span><br></pre></td></tr></table></figure> - <code>kernel_size(int or tuple)</code> - max pooling的窗口大小 - <code>stride(int or tuple, optional)</code> - max pooling的窗口移动的步长。默认值是kernel_size - <code>padding(int or tuple, optional)</code> - 输入的每一条边补充0的层数 - <code>dilation(int or tuple, optional)</code> – 每个点之间的间隙，空洞卷积会用到 - <code>return_indices</code> - 如果等于True，会返回输出最大值的序号，对于上采样操作会有帮助 - <code>ceil_mode</code> - 如果等于True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</p>
<h6 id="maxunpool2d">2.3.2 MaxUnpool2d</h6>
<p>Maxpool2d的逆过程，不过并不是完全的逆过程，因为在 maxpool2d 的过程中，一些值的已经丢失。 MaxUnpool2d 的输入是 MaxPool2d 的输出，包括最大值的索引，并计算所有 maxpool2d 过程中非最大值被设置为零的部分的反向 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">MaxUnpool2d</span>(kernel_size, stride=None, padding=<span class="number">0</span>)</span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：注意：MaxPool2d 可以将多个输入大小映射到相同的输出大小。因此，反演过程可能会变得模棱两可。 为了适应这一点，可以在调用中将输出大小（output_size）作为额外的参数传入。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pool = nn.<span class="built_in">MaxPool2d</span>(<span class="number">2</span>, stride=<span class="number">2</span>, return_indices=True)</span><br><span class="line">&gt;&gt;&gt; unpool = nn.<span class="built_in">MaxUnpool2d</span>(<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; input = <span class="built_in">Variable</span>(torch.<span class="built_in">Tensor</span>([[[[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"> ... [ <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"> ... [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"> ... [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]]]]))</span><br><span class="line">&gt;&gt;&gt; output, indices = <span class="built_in">pool</span>(input)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">unpool</span>(output, indices)</span><br><span class="line"> Variable containing:</span><br><span class="line"> (<span class="number">0</span> ,<span class="number">0</span> ,.,.) =</span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span> <span class="number">8</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">14</span> <span class="number">0</span> <span class="number">16</span></span><br><span class="line"> [torch.FloatTensor of size <span class="number">1</span>x1x4x4]</span><br><span class="line">&gt;&gt;&gt; <span class="meta"># specify a different output size than input size</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">unpool</span>(output, indices, output_size=torch.<span class="built_in">Size</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>]))</span><br><span class="line"> Variable containing:</span><br><span class="line"> (<span class="number">0</span> ,<span class="number">0</span> ,.,.) =</span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">6</span> <span class="number">0</span> <span class="number">8</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">14</span> <span class="number">0</span></span><br><span class="line"> <span class="number">16</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> [torch.FloatTensor of size <span class="number">1</span>x1x5x5]</span><br><span class="line"><span class="keyword">class</span> torch.nn.<span class="built_in">MaxUnpool3d</span>(kernel_size, stride=None, padding=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h6 id="avgpool2d">2.3.3 AvgPool2d</h6>
<p>对信号的输入通道，提供 2 维的平均池化（average pooling ）。输入信号的大小(N,C,H,W)，输出大小(N,C,H_out,W_out)和池化窗口大小(kH,kW)的关系是 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">AvgPool2d</span>(kernel_size, stride=None, padding=<span class="number">0</span>, ceil_mode=False, </span><br><span class="line">count_include_pad=True)</span><br></pre></td></tr></table></figure></p>
<h6 id="adaptivemaxpool2d">2.3.4 AdaptiveMaxPool2d</h6>
<p>对输入信号，提供 1 维的自适应最大池化操作 对于任何输入大小的输入，可以将输出尺寸指定为<code>H</code>，但是输入和输出特征的数目不会变化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">AdaptiveMaxPool2d</span>(output_size, return_indices=False)</span><br></pre></td></tr></table></figure> - <code>output_size</code>: 输出信号的尺寸</p>
<ul>
<li><code>return_indices</code>: 如果设置为 True，会返回输出的索引。对 nn.MaxUnpool1d 有用，默认值是 False</li>
</ul>
<h5 id="归一化函数">2.4 归一化函数</h5>
<h6 id="batchnorm2d">2.4.1 BatchNorm2d</h6>
<p>对于所有的batch中样本的同一个channel的数据元素进行标准化处理，即如果有C个通道，无论batch中有多少个样本，都会在通道维度上进行标准化处理，一共进行C次。</p>
<p><span class="math display">\[

y={{x-mean(x)}\over{\sqrt{var(x)+eps}}}×γ+β

\]</span></p>
<ul>
<li>在训练时，该层计算每次输入的均值与方差，并进行移动平均。移动平均默认的动量值为 0.1。</li>
<li>在验证时，训练求得的均值/方差将用于标准化验证数据。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">BatchNorm2d</span>(num_features, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=True)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>num_features</code>： 来自期望输入的特征数，该期望输入的大小为<code>batch_size × num_features × height × width</code></li>
<li><code>eps</code>： 为保证数值稳定性（分母不能趋近或取 0）,给分母加上的值。默认为 1e-5。</li>
<li><code>momentum</code>： 动态均值和动态方差所使用的动量。默认为 0.1。</li>
<li><code>affine</code>： 一个布尔值，当设为 true，给该层添加可学习的仿射变换参数。</li>
</ul>
<p>momentum的作用：BatchNorm2d里面存储均值（running_mean）和方差（running_var）更新时的参数。 <span class="math display">\[
x_{new}=(1-momentum)*x_{old}+momentum*x_{obser}
\]</span> 其中<span class="math inline">\(x_{old}\)</span>为BatchNorm2d里面的均值<code>（running_mean）</code>和方差<code>（running_var）</code>,<span class="math inline">\(x_{0bser}\)</span>为当前观测值（样本）的均值或方差,<span class="math inline">\(x_{new}\)</span>更新后的均值或方差（最后需要重新存储到BatchNorm2d中），momentum为更新参数</p>
<h5 id="functional模块">2.5 functional模块</h5>
<h6 id="interpolate函数">2.5.1 interpolate()函数</h6>
<p><code>torch.nn.functional.interpolate</code>实现插值和上采样。上采样，在深度学习框架中，可以简单的理解为任何可以让你的图像变成更高分辨率的技术即矩阵升维。 最简单的方式是重采样和插值：将输入图片input image进行rescale到一个想要的尺寸，而且计算每个点的像素点，使用如<strong>双线性插值<code>bilinear</code></strong>等插值方法对其余点进行插值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.functional.<span class="built_in">interpolate</span>(input, size=None, scale_factor=None, mode=<span class="string">&#x27;nearest&#x27;</span>, align_corners=None)</span><br></pre></td></tr></table></figure> - <code>input (Tensor)</code> – 输入张量</p>
<ul>
<li><p><code>size (int or Tuple[int] or Tuple[int, int] or Tuple[int, int, int])</code> – 输出大小.</p></li>
<li><p><code>scale_factor (float or Tuple[float])</code> – 指定输出为输入的多少倍数。如果输入为tuple，其也要制定为tuple类型</p></li>
<li><p><code>mode (str)</code> – 可使用的上采样算法，有’nearest’, ‘linear’, ‘bilinear’, ‘bicubic’ , ‘trilinear’和’area’. 默认使用’nearest</p></li>
</ul>
<h5 id="nn.module">2.6 nn.Module</h5>
<p>注意下面的这些函数都是<code>Module</code>这个类的成员函数，不同于上面的一般函数为全局函数。下面的<code>modle</code>都指代模型对象</p>
<h6 id="parameter">2.6.1 parameter()</h6>
<p><code>model.parameters()</code>，这个是成员函数,指获取该模型的所有参数，一般我们再把模型参数传递给优化器是会使用到。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params = model.<span class="built_in">parameters</span>()</span><br><span class="line">optimizer = torch.optim.<span class="built_in">Adam</span>(params, config.TRAIN[<span class="string">&#x27;learning_rate&#x27;</span>])</span><br></pre></td></tr></table></figure></p>
<h6 id="add_modulename-module">2.6.2 add_module(name, module)</h6>
<p>该函数是一个成岩函数。将一个 <code>child module</code> 添加到当前 <code>modle</code>。 被添加的 <code>module</code> 可以通过 <code>name</code> 属性来获取 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_module</span>(name, <span class="keyword">module</span>)</span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">import</span> torch.<span class="function">nn as nn</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"><span class="function"> def __init__(self):</span></span><br><span class="line"><span class="function"> super(Model, self).__init__()</span></span><br><span class="line"><span class="function"> self.add_module(<span class="string">&quot;conv&quot;</span>, nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, <span class="number">4</span>))</span></span><br><span class="line"><span class="function"> #self.conv =</span> nn.<span class="built_in">Conv2d</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">4</span>) 和上面这个增加 <span class="keyword">module</span> 的方式等价</span><br><span class="line">model = <span class="built_in">Model</span>()</span><br></pre></td></tr></table></figure></p>
<h6 id="children">2.6.3 children()</h6>
<p>该函数返回当前模型子模块的迭代器。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.<span class="function">nn as nn</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"><span class="function"> def __init__(self):</span></span><br><span class="line"><span class="function"> super(Model, self).__init__()</span></span><br><span class="line"><span class="function"> self.add_module(<span class="string">&quot;conv&quot;</span>, nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, <span class="number">4</span>))</span></span><br><span class="line"><span class="function"> self.add_module(<span class="string">&quot;conv1&quot;</span>, nn.Conv2d(<span class="number">20</span> ,<span class="number">10</span>, <span class="number">4</span>))</span></span><br><span class="line"><span class="function">model =</span> <span class="built_in">Model</span>()</span><br><span class="line"><span class="keyword">for</span> sub_module in model.<span class="built_in">children</span>():</span><br><span class="line"> <span class="built_in">print</span>(sub_module)</span><br><span class="line"> </span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">Conv2d</span>(<span class="number">10</span>, <span class="number">20</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">Conv2d</span>(<span class="number">20</span>, <span class="number">10</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<h6 id="cpudevice_idnone和cudadevice_idnone">2.6.4 cpu(device_id=None)和cuda(device_id=None)</h6>
<p><code>cpu(device_id=None)</code>和cuda<code>(device_id=None)</code>将所有的模型参数(parameters)和 buffers 赋值给CPU或者GPU <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modle=modle.<span class="built_in">cuda</span>()</span><br><span class="line"><span class="keyword">for</span> i, (images, gts, depths) in <span class="built_in">enumerate</span>(train_loader, start=<span class="number">1</span>):</span><br><span class="line">	optimizer.<span class="built_in">zero_grad</span>()</span><br><span class="line">	images = images.<span class="built_in">cuda</span>()</span><br><span class="line">	gts = gts.<span class="built_in">cuda</span>()</span><br><span class="line">	depths=depths.<span class="built_in">cuda</span>()</span><br></pre></td></tr></table></figure> 上面的式子等价于<code>to()</code>函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device = torch.<span class="built_in">device</span>(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">images, gts, depths, = images.<span class="built_in">to</span>(device), gts.<span class="built_in">to</span>(device), depths.<span class="built_in">to</span>(device)</span><br></pre></td></tr></table></figure></p>
<h6 id="eval和train模式">2.6.5 eval()和train模式</h6>
<p><code>eval()</code>将模型设置成 evaluation 模式仅仅当模型中有 Dropout 和 BatchNorm 是才会有影响；<code>train()</code>将模型设置为训练模式，会有优化操作，即梯度下降和反向传播算法。</p>
<h6 id="state_dict-dict">2.6.6 state_dict (dict)</h6>
<p><code>state_dict</code>是一个简单的python的字典对象,将每一层与它的对应参数建立映射关系.(如model的每一层的weights及偏置等等)。注意只有那些参数可以训练的layer才会被保存到模型的state_dict中,如卷积层,线性层等等</p>
<ul>
<li><p><code>state_dict</code>是在定义了<code>model</code>或<code>optimizer</code>之后pytorch自动生成的,可以直接调用.常用的保存<code>state_dict</code>的格式是&quot;.pt&quot;或'.pth'的文件,即下面命令的 PATH=&quot;./***.pt&quot; <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.<span class="built_in">save</span>(model.<span class="built_in">state_dict</span>(), PATH)</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>load_state_dict</code>也是<code>model</code>或<code>optimizer</code>之后pytorch自动具备的函数,可以直接调用 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = <span class="built_in">TheModelClass</span>(*args, **kwargs)</span><br><span class="line">model.<span class="built_in">load_state_dict</span>(torch.<span class="built_in">load</span>(PATH))</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="modules">2.6.7 modules()</h6>
<p>返回一个包含 当前模型 所有模块的迭代器。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">module</span> in model.<span class="built_in">modules</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="keyword">module</span>)</span><br><span class="line"> </span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">Model</span> (</span><br><span class="line">	(conv): <span class="built_in">Conv2d</span>(<span class="number">10</span>, <span class="number">20</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">	(conv1): <span class="built_in">Conv2d</span>(<span class="number">20</span>, <span class="number">10</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">)</span><br><span class="line"><span class="built_in">Conv2d</span>(<span class="number">10</span>, <span class="number">20</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">Conv2d</span>(<span class="number">20</span>, <span class="number">10</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure> 可以看出，<code>modules()</code>返回的 iterator 不止包含子模块，还有父模块。这是和 <code>children()</code>的不同。</p>
<h6 id="named_children">2.6.8 named_children()</h6>
<p>返回包含模型当前子模块的迭代器，yield 模块<strong>名字和模块本身</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, <span class="keyword">module</span> in model.<span class="built_in">named_children</span>():</span><br><span class="line">	<span class="keyword">if</span> name in [<span class="string">&#x27;conv4&#x27;</span>, <span class="string">&#x27;conv5&#x27;</span>]:</span><br><span class="line">	<span class="built_in">print</span>(<span class="keyword">module</span>)</span><br></pre></td></tr></table></figure> 同理有<code>name_modules</code></p>
<h5 id="激活函数">2.7 激活函数</h5>
<h6 id="relu">2.7.1 ReLU</h6>
<p>对输入运用修正线性单元函数<span class="math inline">\({ReLU}(x)= max(0, x)\)</span>， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.<span class="built_in">ReLU</span>(inplace=False)</span><br></pre></td></tr></table></figure></p>
<h6 id="sigmoid">2.7.2 Sigmoid</h6>
<p>对每个元素运用 Sigmoid 函数，Sigmoid 定义如下：<span class="math inline">\(f(x)=1/(1+e^{−x})\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.Sigmoid</span><br></pre></td></tr></table></figure></p>
<h6 id="softmax">2.7.3 Softmax</h6>
<p>对 n 维输入张量运用 Softmax 函数，将张量的每个元素缩放到（0,1）区间且和为 1。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.Softmax</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">627k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:30</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'TXhU0V217D2k9wXcjdYcmYLt-gzGzoHsz',
      appKey     : '7vt5hNdJIFoHxQb92AoWuR3E',
      placeholder: "骚言骚语",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
