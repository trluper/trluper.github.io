<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Trluper">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="trluper">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/" class="post-title-link" itemprop="url">c++primer前部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-07 19:54:22" itemprop="dateCreated datePublished" datetime="2022-07-07T19:54:22+08:00">2022-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-11 11:24:24" itemprop="dateModified" datetime="2022-07-11T11:24:24+08:00">2022-07-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>73k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:06</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-类型"><a href="#1-类型" class="headerlink" title="1.类型"></a>1.类型</h4><h5 id="1-1-基本内置类型"><a href="#1-1-基本内置类型" class="headerlink" title="1.1 基本内置类型"></a>1.1 基本内置类型</h5><p>基本内置类型有算术类型和空类型。算术类型分两类为整型和浮点型，下图显示了C++的算数类型:<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/clipboard.png" width="600"></p>
<h5 id="1-2-复合类型"><a href="#1-2-复合类型" class="headerlink" title="1.2 复合类型"></a>1.2 复合类型</h5><p>c++有几种复合类型：数组、结构、string、引用和指针。这里讨论引用和指针。<br><strong>1.2.1引用</strong><br>引用为对象起了另外一个名字。引用类型必须与其所引用的对象类型一致，通过&amp;d的形式定义引用类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp;d=value;	<span class="comment">//引用必须被初始化</span></span><br><span class="line">d=<span class="number">20</span>;	<span class="comment">//即value=d=20</span></span><br><span class="line"><span class="type">int</span> i=d;	<span class="comment">//即i=value;</span></span><br></pre></td></tr></table></figure>
<p>程序把引用和它的初始值绑定在一起（而不是拷贝）。一但绑定了，无法再重新绑定另外的对象。引用并非是对象，只是已存在对象的别名。</p>
<p><strong>1.2.2指针</strong><br>与引用类似，指针也实现了对其他对象的间接访问。但与引用相比也有不同，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象，指针也无须在定义时赋初值。<br>指针的值应是下列4种状态之一：</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针</li>
<li>无效指针，即上述情况外的其他值</li>
</ul>
<h4 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2.类型转换"></a>2.类型转换</h4><p>如果两种类型可以相互转换，那么它们就是关联的。<br><strong>2.1 隐式转换</strong><br><code>如int ival=3.14+3；</code>。编译器会自动转换运算对象的类型的情况：</p>
<ul>
<li>①在大多数表达式中，比int型小的整型值首先提升为较大的整数类型</li>
<li>②条件语句中，非bool类型转化为bool类型</li>
<li>③初始化中，右值转换为左值类型</li>
<li>④算术运算和关系运算的对象要转化为同一种类型：先整型提升、再看是否为带符号运算（有符号&lt;不带符号，应当减少带符号与不带符号的混用）</li>
<li>⑤函数调用也会发生转换</li>
<li>⑥*void类型指针的转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">-11</span>;</span><br><span class="line">	<span class="type">int</span> c=a+b;		<span class="comment">//强制转换为int</span></span><br><span class="line">	<span class="type">unsigned</span> d=a+B;		<span class="comment">//输出了错误结果4294967295,理论计算结果为-1，带符号型的为负值，带符号&lt;不带符号，+-*\这些运算都会隐式转换为不带符号类型，若左值不声明为带符号型出错</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>2.2 显示转换</strong><br>强制类型转换形式是<code>cast_name&lt;type&gt;(expression)</code>(一般多为右值，但当type为引用类型时，为左值）。</p>
<ul>
<li><code>type</code>是转换的目标类型，</li>
<li><code>expression</code>是要转换的值。</li>
<li><code>cast_name:static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。</code><br>①<code>static_cast</code>:任何有明确定义的类型转换，只要不包含底层<code>const</code>，均可使用<br>②<code>const_cast</code>:只能改变运算对象的底层<code>const</code>，即只改变常量属性，不能改变类型<br>③<code>dynamic_cast</code>:用于将基类的指针或者引用安全地转换成派生类的指针或引用。<br>④<code>reinterpret_cast</code>:通常为运算对象的位模式提供较低层次上的重新解释。<code>reinterpret_cast</code>可以用来在任意类型间进行转换，转换后其正确性由程序员保证。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>	*pc;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);	<span class="comment">//合法，但通过p写值是未定义行为</span></span><br><span class="line"><span class="comment">//上面我们称为去const性质（常量对象转化为非常量对象，这种情况编译器此时就不允许我们进行写操作了）</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cp=&amp;c;</span><br><span class="line"><span class="type">char</span>* q=<span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(cp);		<span class="comment">//不合法，想改变底层const</span></span><br><span class="line">string a = <span class="built_in">static_cast</span>&lt;string&gt;(cp);	<span class="comment">//合法，字符串转换为string类型</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;string&gt;(cp)				<span class="comment">//不合法</span></span><br></pre></td></tr></table></figure>
<h4 id="3-const关键字"><a href="#3-const关键字" class="headerlink" title="3.const关键字"></a>3.const关键字</h4><p>使用关键字<code>const</code>对变量类型加以限定，它的值不能被改变。注意在默认情况下，<code>const</code>对象仅在文件内有效。如果像让const对象能在文件间共享，加<code>extern</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> buffer=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> buffer=<span class="number">25</span>;</span><br></pre></td></tr></table></figure>
<h5 id="3-1const引用"><a href="#3-1const引用" class="headerlink" title="3.1const引用"></a>3.1const引用</h5><p>把引用绑定在<code>const</code>对象上，称为对常量的引用。与普通引用所不同的是，对常量的引用不能被用作修改它所绑定的对象：(非常量引用不能绑定常量对象，但允许常量引用绑定非常量对象）:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onst <span class="type">int</span> ci=<span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri=ci;</span><br><span class="line"><span class="type">int</span> &amp;a=ci;		<span class="comment">//错误，不能用非常量引用绑定常量对象</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">40</span>;</span><br><span class="line">r1=<span class="number">42</span>;		<span class="comment">//错误，r1是对常量的引用，不能被修改所绑定的对象ci</span></span><br><span class="line"><span class="type">int</span> &amp;r=ci;	<span class="comment">//错误，不能非常量引用绑定常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;d=i;		<span class="comment">//允许const int&amp; 绑定在一个int对象上</span></span><br></pre></td></tr></table></figure>
<p>还有以下也不允许：<strong>一个常量引用绑定另外一种类型。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> i=<span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p=i;</span><br><span class="line"><span class="comment">/*实际的底层：</span></span><br><span class="line"><span class="comment">double i=3;</span></span><br><span class="line"><span class="comment">int temp=i;</span></span><br><span class="line"><span class="comment">const int &amp;p=temp;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>原因是为了确保p绑定的是整型，编译器会把上述的代码中的i由双精度浮点数生产一个临时整型（常\变）量，此时p就绑定了一个临时量对象temp。如果p不是常量，此时不能对p赋值来改变i的值（因为实际改变的是零时temp的值），在c++看来这是非法的。</p>
<h5 id="3-2指针和const"><a href="#3-2指针和const" class="headerlink" title="3.2指针和const"></a>3.2指针和const</h5><p>与引用一样，也可以让指针指向常量或非常量。指向常量的指针不能改变其所指向对象的值。且常量指针必须初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *p 	<span class="comment">//表示 指向的内容不能改变。</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> p	<span class="comment">//就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3顶层const和底层const"><a href="#3-3顶层const和底层const" class="headerlink" title="3.3顶层const和底层const"></a>3.3顶层const和底层const</h5><p>一般来说对于指针而言才有底层和顶层这个区分。顶层const表示指针本身是一个常量，底层const表示指针所指向的对象是一个常量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci=<span class="number">42</span>;	<span class="comment">//顶层const,不能修改ci的值</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> cr=<span class="number">40</span>;	<span class="comment">//顶层const</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p=&amp;i;	<span class="comment">//顶层const,不允许修改p的值</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p1=&amp;i;	<span class="comment">//底层const，允许修改p1的值，但不能修改ci的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2=&amp;ci;	<span class="comment">//底层const，允许修改p2的值，但不能修改ci的值</span></span><br></pre></td></tr></table></figure>
<p><em><strong>注意：执行对象拷贝时，必须至少具有相同底层const资格，或非常量可转化为常量，但反过来不行。如下的两句</strong></em>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> *p=&amp;i;	<span class="comment">//底层const</span></span><br><span class="line"><span class="type">int</span>* f = p;		<span class="comment">//不允许</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* g = i;	<span class="comment">//合法</span></span><br></pre></td></tr></table></figure>


<h4 id="4-标准库string"><a href="#4-标准库string" class="headerlink" title="4.标准库string"></a>4.标准库string</h4><p>C++大大增强了对字符串的支持，除了可以使用C风格的字符串，还可以使用内置的 string 类。string 类处理起字符串来会方便很多，完全可以代替C语言中的字符数组或字符串指针。string类重载许多运算符，如<code>&lt;,&gt;,&lt;=,&gt;=,==,!=,[],+</code>,以及输出流<code>&lt;&lt;</code>和<code>&gt;&gt;</code></p>
<h5 id="4-1-string的构造"><a href="#4-1-string的构造" class="headerlink" title="4.1 string的构造"></a>4.1 string的构造</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> naemspace std;</span><br><span class="line">string s1;		<span class="comment">//未定义具体值，则调用string类的未传参构造函数，s1=&quot;&quot;</span></span><br><span class="line">string s2=s1;	<span class="comment">//赋值拷贝</span></span><br><span class="line">string s3=<span class="string">&quot;value&quot;</span>;	<span class="comment">//赋值拷贝</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;		<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>;	<span class="comment">//s4的内容为ccccccccccc，直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(s3,<span class="number">2</span>)</span></span>;	<span class="comment">//结果为lue</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-string关于长度的函数"><a href="#4-2-string关于长度的函数" class="headerlink" title="4.2 string关于长度的函数"></a>4.2 string关于长度的函数</h5><p>string支持较多的关于长度的函数，这里通过表格形式列举：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>调用</th>
</tr>
</thead>
<tbody><tr>
<td><code>size()</code></td>
<td>返回字符数量</td>
<td><code>s.size()</code></td>
</tr>
<tr>
<td><code>length()</code></td>
<td>返回字符数量</td>
<td><code>s.length()</code></td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判空操作</td>
<td><code>s.empty()</code></td>
</tr>
<tr>
<td><code>capacity</code></td>
<td>返回字符容量</td>
<td><code>s.capacity()</code></td>
</tr>
<tr>
<td><code>reserve(size_t)</code></td>
<td>保留内存以存储一定数量的字符</td>
<td><code>s.reserve(20)</code></td>
</tr>
<tr>
<td><code>resize(size_t)</code></td>
<td>改变字符数量</td>
<td><code>s.reszie(20)</code></td>
</tr>
</tbody></table>
<h5 id="4-3-string的增删"><a href="#4-3-string的增删" class="headerlink" title="4.3 string的增删"></a>4.3 string的增删</h5><p>一般来说相同名称的接口有很多个重载，因此列举的只是一部分，读者可以在实际开发中依据编辑器给的提示选择：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s2=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">s1=s1+<span class="string">&quot; &quot;</span>+s2;	<span class="comment">//重载+运算符</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>,<span class="string">&quot;ins&quot;</span>); <span class="comment">//从s1的1位置开始，插入&quot;ins&quot;字符串，即s1=&quot;hinsello&quot;;</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;ins&quot;</span>, <span class="number">2</span>);<span class="comment">//从s1的1位置开始，插入&quot;ins&quot;字符串的前2个字符，即s1=&quot;hinello&quot;;</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;ins&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//从s1的1位置开始，插入&quot;ins&quot;字符串的从1位置开始的2个字符，即s1=&quot;hnsello&quot;;</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="type">char</span> c)</span></span>;<span class="comment">//在it处插入字符c，返回插入后迭代器的位置，该insert不是string的insert，而是算法层的函数</span></span><br><span class="line">s1.<span class="built_in">append</span>(str);</span><br><span class="line">s1.<span class="built_in">push_back</span>(<span class="type">char</span> c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊</span></span><br><span class="line">s1.<span class="built_in">assign</span>(str);		<span class="comment">//赋新值，旧值全部删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">iterator s1.<span class="built_in">erase</span>(iterator first, iterator last);<span class="comment">//删除[first，last）之间的所有字符，返回删除后迭代器的位置</span></span><br><span class="line">iterator s1.<span class="built_in">erase</span>(iterator it);<span class="comment">//删除it指向的字符，返回删除后迭代器的位置</span></span><br><span class="line">string&amp;  s1.<span class="built_in">erase</span>(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> n = npos);<span class="comment">//删除pos开始的n个字符，返回修改后的字符串</span></span><br></pre></td></tr></table></figure>

<h5 id="4-4-string的查找"><a href="#4-4-string的查找" class="headerlink" title="4.4 string的查找"></a>4.4 string的查找</h5><p>string类的查找函数提供了比较多的接口，以下是列举的一些常用<code>find</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，-1表示查找不到子串</span></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">(charc, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="type">size_t</span> <span class="title">rfind</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</span></span><br><span class="line"><span class="number">4.</span> <span class="function"><span class="type">size_t</span> <span class="title">rfind</span> <span class="params">(charc, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">5.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">6.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">7.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">8.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</span></span><br></pre></td></tr></table></figure>
<h5 id="4-5-string的遍历和排序"><a href="#4-5-string的遍历和排序" class="headerlink" title="4.5 string的遍历和排序"></a>4.5 string的遍历和排序</h5><p>string支持下标<code>[]</code>随机访问，也支持迭代器遍历，因此对于遍历string可通过这些功能来遍历。排序我们使用<code>algorithm</code>头文件内的<code>sort</code>，<code>sort</code>内部的实现机制是快排，并且通过修改避免快排中复杂都最高的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="comment">//foreach循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">	<span class="built_in">printf</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">	cout&lt;&lt;c&lt;&lt;ends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string::iterator it=s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it&lt;s.<span class="built_in">end</span>())&#123;</span><br><span class="line">	cout&lt;&lt;*it&lt;&lt;ends;</span><br><span class="line">	it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="4-6-其他操作"><a href="#4-6-其他操作" class="headerlink" title="4.6 其他操作"></a>4.6 其他操作</h5><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/cctype.png" width="600">

<p><em><strong>注意</strong></em>：在c++中存在一个从<code>const char*</code>到<code>string</code>的隐式类型转换，却不存在从一个<code>string</code>对象到<code>C_string</code>的自动类型转换。对于<code>string</code>类型的字符串，可以通过<code>c_str()</code>函数返回<code>string</code>对象对应的<code>C_string</code>.  通常，程序员在整个程序中应坚持使用<code>string</code>类对象，直到必须将内容转化为<code>char*</code>时才将其转换为<code>C_string</code>.</p>
<h4 id="5-初见迭代器"><a href="#5-初见迭代器" class="headerlink" title="5. 初见迭代器"></a>5. 初见迭代器</h4><p>这里尽对迭代器做一个简单的介绍，更加具体的见<strong>STL源码剖析</strong>。我们可通过下标运算符来访问string和vector对象的元素。还有一种是通过迭代器（iterator)进行访问，在c++中我们强烈推荐使用迭代器而不是下标，因为标准库几乎为每一种容器都提供了迭代器，而迭代器提供了对对象的间接访问。</p>
<ul>
<li><strong>使用迭代器</strong>：有迭代器的类型同时拥有返回迭代器成员的函数，如<code>begin</code>和<code>end</code>,其中<code>begin</code>成员负责返回指向第一个元素；<code>end</code>成员负责返回尾元素的下一个位置。和指针类似，也能通过解引用迭代器来获取它所指示的元素。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">begin</span>()!=s.<span class="built_in">end</span>())&#123;	<span class="comment">//确保s非空</span></span><br><span class="line"><span class="keyword">auto</span> it=s.<span class="built_in">begin</span>();	<span class="comment">//it表示s的第一个字符地址</span></span><br><span class="line">*it=<span class="built_in">toupper</span>(*it);	<span class="comment">//将第一个改为大写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将迭代器从一个元素移动到另外一个元素：使用递增++运算符达到这个目的，如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>()&amp;&amp;!<span class="built_in">isspace</span>(*it);it++)to</span><br><span class="line">*it=<span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-1迭代器类型"><a href="#5-1迭代器类型" class="headerlink" title="5.1迭代器类型"></a>5.1迭代器类型</h5><p>拥有迭代器的标准库类类型使用iterator和const_iterator来表示迭代器类型.所以如果对象是一个常量，只能用const_iterator。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;	<span class="comment">//it能读写vector&lt;int&gt;的有元素</span></span><br><span class="line">string::iterator it2;		<span class="comment">//it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;		<span class="comment">//it3只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4;			<span class="comment">//只能读，无法写</span></span><br></pre></td></tr></table></figure>

<h5 id="5-2-迭代器运算"><a href="#5-2-迭代器运算" class="headerlink" title="5.2 迭代器运算"></a>5.2 迭代器运算</h5><p>迭代器的递增运算令迭代器每次移动一个元素，所有标准库都支持递增运算，也能用&#x3D;&#x3D;和!&#x3D;对两个有效迭代器进行比较。以下是vector和string提供的个更多的关系运算:<br> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/iterator.png" width="600" align="middle"></p>
<h4 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h4><p>异常处理包括：</p>
<ul>
<li><code>throw</code>表达式：异常检测部分使用<code>throw</code>表达式来表示它遇到了无法处理的问题。</li>
<li><code>try</code>语句块：异常处理部分使用<code>try</code>语句块处理异常，<code>try</code>语句块代码中抛出的异常会被某个<code>catch</code>子句处理。（<code>catch</code>为异常处理代码）</li>
<li>一套异常类：用于<code>throw</code>语句和相关<code>catch</code>子句之间传递异常的具体信息</li>
</ul>
<p><strong>1）throw表达式</strong><br>throw表达式引发一个异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(item1.<span class="built_in">isbn</span>()!=item2.<span class="built_in">isbn</span>())</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to	same ISBN&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;item1+item2&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>c++标准异常类,它们分别位于4个头文件中：</p>
<ul>
<li>①<code>exception</code></li>
<li>②<code>stdexcept</code></li>
<li>③<code>new</code>头文件定义的<code>bad_alloc</code></li>
<li>④<code>type_inof</code>头文件定义的<code>bad_cast</code></li>
</ul>
<img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/exception.png" width="600">


<h4 id="7-函数"><a href="#7-函数" class="headerlink" title="7.函数"></a>7.函数</h4><h5 id="7-1-局部对象"><a href="#7-1-局部对象" class="headerlink" title="7.1 局部对象"></a>7.1 局部对象</h5><p>在c++中，名字有作用域，对象有<strong>生命周期。</strong></p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见</li>
<li>对象的生命周期是程序执行过程中该对象存在时间</li>
</ul>
<p>形参和函数体内部定义的变量统称为<strong>局部变量</strong>。所有在函数体之外定义的对象存在于程序的整个执行过程。</p>
<ul>
<li><strong>自动对象</strong>：只存在于块执行期间的对象为自动对象。<strong>即对于局部变量，当函数的执行路径经过变量定义语句时创建该对象，到达块末尾时销毁它</strong>。</li>
<li><strong>局部静态对象</strong>：将局部变量定义成static类型从而可获得。在定义中初始化时生产该对象，直到程序终止才被销毁（即static修饰得变量只会被初始化一次）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">size_t</span> ctr=<span class="number">0</span>;	<span class="comment">//只被初始化一次</span></span><br><span class="line">	<span class="keyword">return</span>	++ctr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>:i++)</span><br><span class="line">	cout&lt;&lt;<span class="built_in">count</span>()&lt;&lt;endl;	<span class="comment">//输出得一次为1、2、3.....10</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-2-参数传递"><a href="#7-2-参数传递" class="headerlink" title="7.2 参数传递"></a>7.2 参数传递</h5><p>形参的类型决定了形参与实参得交互方式。若形参为引用类型，则对应得实参被引用传递，引用形参是它对应实参得别名。当实参的值被拷贝给形参时，形参和实参是两个独立的对象，此时实参被值传递。</p>
<ul>
<li><strong>①指针形参</strong>：和其他非引用形参一样，形参的指针执行拷贝时，拷贝的是实参指针，两个指针是不同的指针，但他们都指向同一对象，因此可修改指向对象的值。</li>
<li><strong>②引用行参</strong>：引用参数绑定初始化它的对象，改变形参也就改变了所引对象的值。使用引用能避免拷贝。</li>
</ul>
<h6 id="7-2-1-指针形参与const"><a href="#7-2-1-指针形参与const" class="headerlink" title="7.2.1 指针形参与const"></a>7.2.1 指针形参与const</h6><p>达到不改变实参和形参所指对象的值，而且调用时，若改变了值，编译器报错。但需注意(于底层const)允许非常量初始化常量对象（形参），但不允许常量(实参）初始化一个非常量对象（形参）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> a)</span></span>;	<span class="comment">//顶层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* a)</span></span>;	<span class="comment">//底层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>* a)</span></span>;		<span class="comment">//正常指针参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span>* y = &amp;x;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* a = &amp;x;</span><br><span class="line">	<span class="type">int</span>* <span class="type">const</span> b = &amp;x;</span><br><span class="line">	<span class="built_in">func1</span>(b);</span><br><span class="line">	<span class="comment">//func1(a); 不允许，实参为底层，形参为顶层，想用底层初始化顶层是不被允许的</span></span><br><span class="line">	<span class="built_in">func2</span>(a);</span><br><span class="line">	<span class="built_in">func2</span>(b);</span><br><span class="line">	<span class="built_in">func3</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;顶层const可以用非常亮初始化一个常量对象（形参），反之不行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	*a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;底层const可以用非常亮初始化一个常量对象（形参），反之不行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//*a=20;		//错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>* a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;不允许常量初始化一个非常量对象（形参）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	*a = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="7-2-2-引用形参与const"><a href="#7-2-2-引用形参与const" class="headerlink" title="7.2.2 引用形参与const"></a>7.2.2 引用形参与const</h6><p>常量引用时候我们经常要用到的东西。同const指针形参一样，同样不能修改值。普通引用（即没有const)的限制:</p>
<ul>
<li>不允许实参为const对象（即非常量不能初始化常量对象）</li>
<li>不允许实参为字面值</li>
<li>不能提供类型转换</li>
</ul>
<p>const引用形参却能克服这些限制。但就是不能改变绑定的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="type">const</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">	<span class="comment">//func1(a) 不允许，普通引用不允许实参为const</span></span><br><span class="line">	<span class="comment">//func1(10) 不允许，普通引用形参不允许实参为字面值</span></span><br><span class="line">	<span class="built_in">func1</span>(b);</span><br><span class="line">	<span class="built_in">func2</span>(a);</span><br><span class="line">	<span class="built_in">func2</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;这里是func1&quot;</span>&lt;&lt;endl;</span><br><span class="line">	a=<span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;这里是function2&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//a=40;		不允许对const引用的修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="7-2-3-数组形参"><a href="#7-2-3-数组形参" class="headerlink" title="7.2.3 数组形参"></a>7.2.3 数组形参</h6><p>因为数组不能被拷贝，所以无法以值传递的方式使用数组参数。但数组会被转换为指针，所以当我们传递一个数组时，实际上传递的指向数组首元素的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这三个函数声明均为const int*类型。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="comment">//还有数组引用形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> (&amp;arry)[])</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="7-2-4-可变形参函数"><a href="#7-2-4-可变形参函数" class="headerlink" title="7.2.4 可变形参函数"></a>7.2.4 可变形参函数</h6><p>有时我们无法预知应该向函数传递几个参数，所以可使用可变形参函数.c++11新标准提供了以下主要方法：</p>
<ul>
<li>若所以实参类型相同，可传递一个名为initializer_list的标准库类型</li>
<li>若实参类型不同，编写一个可变参数模板</li>
<li><strong>c++还有一种形参类型（省略符），用它来传递可变数量的实参。</strong></li>
</ul>
<p><strong>1.initializer_list形参</strong><br>它是一种标准库类型，定义在同名（initializer_list)头文件中。它提供的操作有：</p>
<img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/initializer.png" width="600">
和vector不同的是，initializer_list对象中的元素是常量值，我们无法修改它们的值。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">msg</span><span class="params">(initializer_list&lt;string&gt; li)</span>	<span class="comment">//均为string类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	functionbody;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.省略符形参</strong></p>
<p>省略符形参应该仅仅用于c和c++的通用的类型（因为省略符的实际就是为了c++能够访问特殊c代码所设计的，这些代码使用了varargs的c标准库功能）。使用参数是用位置数字代号作为形参变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略符形参只有两种形式：</span></span><br><span class="line"><span class="built_in">foo</span>(parm_list,...);	<span class="comment">//指定部分形参类型</span></span><br><span class="line"><span class="built_in">foo</span>(...);			<span class="comment">//均无指定</span></span><br><span class="line"><span class="comment">//用数字作为代号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="7-3返回值"><a href="#7-3返回值" class="headerlink" title="7.3返回值"></a>7.3返回值</h5><ul>
<li>①c++11新标准规定，函数可以返回花括号包围的列表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">	....<span class="comment">//expect\actual为string对象</span></span><br><span class="line">	<span class="keyword">if</span>(expected.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(expected==actual)</span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="string">&quot;funtionX&quot;</span>,<span class="string">&quot;OK&quot;</span>&#125;;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>c++11新标准规定，main函数的类型如果不为void,也可没有return语句（编译器会自己添加return 0;)</li>
</ul>
<h5 id="7-4函数重载"><a href="#7-4函数重载" class="headerlink" title="7.4函数重载"></a>7.4函数重载</h5><p>如果同一作用域内的几个<strong>函数名字相同但形参列表不同，称为重载函数</strong>（函数的重载应该使用于那些操作非常类似的函数）,返回值也可不同（但不是必须）。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* beg,<span class="type">const</span> <span class="type">int</span> *end)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> aa[],<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些重载函数形参类型不同，当调用这些函数时，编译器会根据传递的实参类型推断调用的是哪个函数。</p>
<h6 id="7-4-1-重载和const形参"><a href="#7-4-1-重载和const形参" class="headerlink" title="7.4.1 重载和const形参"></a>7.4.1 重载和const形参</h6><ul>
<li>拥有顶层const和没有顶层const的形参无法区分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>	<span class="title">lookup</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>	<span class="title">lookup</span><span class="params">(<span class="type">const</span> <span class="type">int</span>)</span></span>;	<span class="comment">//不能识别，不要这样用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>	<span class="title">lookup</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> )</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>底层const可区分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;	<span class="comment">//重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span> *）；</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> lookup(<span class="type">const</span> <span class="type">int</span>*);	<span class="comment">//重载</span></span></span></span><br></pre></td></tr></table></figure>

<h6 id="7-4-2-const-cast和重载"><a href="#7-4-2-const-cast和重载" class="headerlink" title="7.4.2 const_cast和重载"></a>7.4.2 const_cast和重载</h6><p>const_cast在重载函数的情景中最有用。例子如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">shorterString</span><span class="params">(<span class="type">const</span> string&amp; s1,<span class="type">const</span> string&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size&lt;=s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个参数和返回类型都是<code>const string</code>的引用。当我们传入的参数时非常量的时候，我们当然希望返回的是<code>string</code>的引用，而不是<code>const string</code>的引用，这时候就用到显示类型转换<code>const_cast</code>.改进如下：重载另一<code>shorterString</code>函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">shorterString</span><span class="params">(string&amp; s1,string&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; r=<span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其参数和返回值均为string&amp;。在该函数内部调用const的版本，参数强制转换为const string&amp;型<br>执行后返回后auto&amp; r。无const版本再强制转为string&amp;。<br>你觉得很不应该，直接在无<code>const</code>函数实现不就行了吗，其实不是的，这样写是为了方便代码的维护,要修改的时候我们只有修改<code>const</code>版本</p>
<h5 id="7-5特殊用途语言特性"><a href="#7-5特殊用途语言特性" class="headerlink" title="7.5特殊用途语言特性"></a>7.5特殊用途语言特性</h5><p>这里介绍<strong>默认实参、内联函数和constexpr函数</strong>。</p>
<h6 id="7-5-1-默认实参"><a href="#7-5-1-默认实参" class="headerlink" title="7.5.1 默认实参"></a>7.5.1 默认实参</h6><p>某些函数再多次调用时都被赋予一个相同值，这个反复出现的值就为默认实参。其声明定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> ht=<span class="number">24</span>,<span class="type">int</span> wid=<span class="number">10</span>,<span class="type">char</span>  backgrd=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">typedef</span> string::szie_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht=<span class="number">24</span>,sz wid=<span class="number">10</span>,<span class="type">char</span>  backgrd=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数时：</span></span><br><span class="line">string window;</span><br><span class="line">window=<span class="built_in">screen</span>();		<span class="comment">//默认实参</span></span><br><span class="line">window=<span class="built_in">screen</span>(<span class="number">60</span>);	<span class="comment">//等价于screen(60,10,&#x27; &#x27;);</span></span><br><span class="line">window=<span class="built_in">screen</span>(<span class="number">60</span>,<span class="number">10</span>,<span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="7-5-2-内联函数和constexptr函数"><a href="#7-5-2-内联函数和constexptr函数" class="headerlink" title="7.5.2 内联函数和constexptr函数"></a>7.5.2 内联函数和constexptr函数</h6><p>因为调用函数要先保存寄存器，并在返回时恢复。有一定的时间开销。而内联函数可避免调用函数的开销。关键字是<code>inline</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string&amp; <span class="title">shorterString</span><span class="params">(<span class="type">const</span> string&amp; s1,<span class="type">const</span> string&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size&lt;=s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>constexptr函数</code>:指能用于常量表达式的函数。函数的返回类型及所有形参的的类型都是字面值，函数体中有且仅有一条return语句。</p>
<h5 id="7-6-lambda表达式"><a href="#7-6-lambda表达式" class="headerlink" title="7.6 lambda表达式"></a>7.6 lambda表达式</h5><h6 id="7-6-1-lambda语法"><a href="#7-6-1-lambda语法" class="headerlink" title="7.6.1 lambda语法"></a>7.6.1 lambda语法</h6><h4 id="8-类"><a href="#8-类" class="headerlink" title="8.类"></a>8.类</h4><p>c++语言中，使用类定义自己的数据类型，是我们更容易编写、调试和修改程序。类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>。<br><strong>数据抽象是一种依赖接口和实现的分离编程技术</strong>。类的接口包括用户所能执行的操作，类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。要实现数据抽象，首先要定义抽象数据类型。</p>
<h5 id="8-1-定义抽象数据类型"><a href="#8-1-定义抽象数据类型" class="headerlink" title="8.1 定义抽象数据类型"></a>8.1 定义抽象数据类型</h5><p><strong>成员函数的声明必须在类的内部</strong>，它的定义既可以在类的内部也可以在类的外部。而作为接口组成部分的非成员函数，他们的定义和声明都在类的外部。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;		<span class="comment">//Sales_data类</span></span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> 	BookNo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	std::string 	BookNo;</span><br><span class="line">	<span class="type">unsigned</span>  units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面这个类成员函数有<code>isbn、combine、avg_prince</code>。其中<code>isbn</code>在类的内部定义，<code>combine</code>和<code>avg_price</code>定义在类外部（声明于类内部）。</p>
<h5 id="8-2-成员函数"><a href="#8-2-成员函数" class="headerlink" title="8.2 成员函数"></a>8.2 成员函数</h5><h6 id="8-2-1-const修饰函数—常量成员函数"><a href="#8-2-1-const修饰函数—常量成员函数" class="headerlink" title="8.2.1 const修饰函数—常量成员函数"></a>8.2.1 const修饰函数—常量成员函数</h6><ul>
<li><p>在类中将成员函数修饰为<code>const</code>表明在该函数体内，<em><strong>不能修改对象的数据成员而且它不能调用非const函数</strong></em>。</p>
</li>
<li><p><strong>为什么不能调用非<code>const</code>函数</strong>:因为非<code>const</code>函数可能修改数据成员，<code>const</code>成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数。</p>
</li>
<li><p>同时这里的<code>const</code>也有修改隐式<code>this</code>指针的作用，使<code>T*const register this</code>为<code>const T*const register this</code>，这样<code>this</code>指针就能绑定到一个常量（<code>const</code>）对象上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;	<span class="comment">//set函数设置值，不能声明为const函数</span></span><br><span class="line">			i=n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span><span class="type">const</span></span>&#123;		<span class="comment">//get函数只取值，声明为const符合规范设计</span></span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="8-2-2-this指针"><a href="#8-2-2-this指针" class="headerlink" title="8.2.2 this指针"></a>8.2.2 this指针</h6><p>上面提到了<code>this</code>指针，它指的是对于类的内部成员函数，其参数列表的第一若不显式写出总是隐藏有一个<code>this</code>指针:</p>
<ul>
<li><em><strong>成员函数this指针：成员函数通过一个名为this的隐式参数来访问调用它的那个对象</strong></em>。<code>this</code>指针是一个指向当前对象的指针，或者说当前对象的地址。</li>
<li><strong>this指针只能在一个类的非静态成员函数中使用（全局函数、静态函数不能使用）</strong>。</li>
<li>C++的非静态成员函数的第一个默认并且被隐藏的参数是<code>T *const register this</code>。比如我们在<code>Student</code>这个类里声明这样一个函数：<code>int SetName(const char *name)</code>;其实编译器处理的时候会变为 <code>int SetName(Student *const register this, const char *name)</code>;</li>
</ul>
<h6 id="8-2-3-类的静态函数没有this指针"><a href="#8-2-3-类的静态函数没有this指针" class="headerlink" title="8.2.3 类的静态函数没有this指针"></a>8.2.3 类的静态函数没有this指针</h6><p><strong>静态函数如同静态变量一样，他不属于具体的哪一个对象而是属于类</strong>，静态函数表示了整个类范围意义上的信息。<strong>而this指针却实实在在的对应一个对象，所以this指针不能被静态函数使用了</strong>，同理，全局函数也一样。</p>
<p><em><strong>注意：</strong></em>在静态成员函数的实现中不能直接引用类中说明的非静态成员，但可以引用类中说明的静态成员。非静态成员函数即可以引用类中静态成员和非静态成员（这点非常重要）</p>
<h6 id="8-2-3-this指针什么时候创建的"><a href="#8-2-3-this指针什么时候创建的" class="headerlink" title="8.2.3 this指针什么时候创建的"></a>8.2.3 this指针什么时候创建的</h6><p><strong><code>this</code>在成员函数的开始执行前构造的，在成员的执行结束后清除</strong>。<code>this</code>指针只有在成员函数中才有定义。因此你获得一个对象后，不能通过对象使用this指针。所以，我们也无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置，this指针存于寄存器中）。</p>
<p>当然，在成员函数里，是可以知道this指针的位置的（可以&amp;this获得)，也可以直接使用的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个返回this对象的函数：</span></span><br><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">	units_sold+=rhs.units_sold;		<span class="comment">//把rhs的成员加到this对象的成员上</span></span><br><span class="line">	revenue+=rhs.revenue;			<span class="comment">//同理</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;					<span class="comment">//返回调用该函数的对象（引用）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-3类相关的非成员函数"><a href="#8-3类相关的非成员函数" class="headerlink" title="8.3类相关的非成员函数"></a>8.3类相关的非成员函数</h5><p>类的定义常常需要辅助函数（非成员函数），它们的声明要与类声明在同一头文件中。最常用的就是输入输出的非成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream &amp;is,Sales_data&amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> price=<span class="number">0</span>;</span><br><span class="line">	is&gt;&gt;item.BookNO&gt;&gt;item.units_sold&gt;&gt;price;</span><br><span class="line">	item.revenue=price*item.units_sold</span><br><span class="line">	<span class="keyword">return</span> is</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="built_in">print</span>(ostream &amp;os,Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	os&lt;&lt;item.<span class="built_in">isbn</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.units_sold&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">	&lt;&lt;item.revenue&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.<span class="built_in">avg_price</span>();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Sales_data sum=lhs;		<span class="comment">//lhs拷贝给sum</span></span><br><span class="line">	sum.<span class="built_in">combine</span>(rhs);		<span class="comment">//将rhs的数据加到sum中，sum存放lhs和rhs和</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-4类的静态成员"><a href="#8-4类的静态成员" class="headerlink" title="8.4类的静态成员"></a>8.4类的静态成员</h5><h6 id="8-4-1-什么是静态成员（声明）"><a href="#8-4-1-什么是静态成员（声明）" class="headerlink" title="8.4.1 什么是静态成员（声明）"></a>8.4.1 什么是静态成员（声明）</h6><p><strong>有时候我们需要一些成员与类本身直接相关</strong>，而不是与类的各个对象保持关联。在该成员变动时，希望每个对象都能使用新值，就如银行利率。这个时候就引入了类的静态成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			amount+=amoubt*interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">static</span>	<span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string owner;</span><br><span class="line">		<span class="type">double</span> amount;</span><br><span class="line">		<span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="title">doubleinitRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的静态成员存在于任何对象之外，对象中不包含任何与静态成员有关的数据（），<strong>因此<code>Account</code>的对象只包含了两个数据成员<code>owner和amount</code>。<code>interestRate</code>被所有对象共享。</strong><br>静态成员函数也不与对象绑定，它们不包含<code>this</code>指针，所以静态成员函数不能被声明为<code>const</code>。</p>
<h6 id="8-4-2-定义静态成员及类外初始化（静态成员变量和静态成员函数）"><a href="#8-4-2-定义静态成员及类外初始化（静态成员变量和静态成员函数）" class="headerlink" title="8.4.2 定义静态成员及类外初始化（静态成员变量和静态成员函数）"></a>8.4.2 定义静态成员及类外初始化（静态成员变量和静态成员函数）</h6><p>和其他成员函数一样，可在内部定义也可在外部定义（在外部时，不可重复使用static关键字，static只出现在内部声明语句）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Account::rate</span><span class="params">(<span class="type">double</span> newRate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	interestRate=newRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态成员不属于类的对象，因此它们并不是在创建对象时被定义的，<strong>即它们不是由类的构造函数初始化的</strong>。<strong>类似于全局变量，静态数据成员定义在任何函数之外，它一旦被定义，就一直存在于程序整个生命周期，它只能被定义一次</strong>。（一般在类外初始化）<br>如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> Account::interestRate=<span class="built_in">initRate</span>();		<span class="comment">//定义并初始化一个静态成员</span></span><br></pre></td></tr></table></figure>

<h6 id="8-4-3-使用静态成员"><a href="#8-4-3-使用静态成员" class="headerlink" title="8.4.3 使用静态成员"></a>8.4.3 使用静态成员</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用域运算符直接访问静态成员</span></span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    r=Account::<span class="built_in">rate</span>();</span><br><span class="line"><span class="comment">//使用类的对象、引用或者指针访问</span></span><br><span class="line">	Account ac1;</span><br><span class="line">	Account *ac2=&amp;ac1;</span><br><span class="line">	r=ac1.<span class="built_in">rate</span>();</span><br><span class="line">	r=ac2-&gt;<span class="built_in">rata</span>();</span><br><span class="line">成员函数不需要使用域运算符，可直接使用静态成员</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			amount+=amoubt*interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> interestRate;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-5-构造函数"><a href="#8-5-构造函数" class="headerlink" title="8.5 构造函数"></a>8.5 构造函数</h5><p>每个类都定义了它的对象被初始化的方式，类是通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数就是<strong>构造函数</strong>。<strong>构造函数的任务就是初始化对象的数据成员，只要类的对象被创建，就会执行构造函数—-&gt;拷贝。</strong></p>
<ul>
<li><strong>构造函数</strong>：构造函数的名字与类名相同，没有返回(值）类型，不能被声明为<code>const</code>（const对象执行构造函数时，执行完毕才成为const对象）。</li>
<li><strong>拷贝和赋值：</strong>拷贝是构造行为，状态取决于用于构造的对象；赋值是对已构造对象进行状态更新。赋值侧重于更新，构造侧重于构造。</li>
</ul>
<h6 id="8-5-1-默认构造函数–-gt-也可写成默认实参的构造函数（还是默认构造函数）"><a href="#8-5-1-默认构造函数–-gt-也可写成默认实参的构造函数（还是默认构造函数）" class="headerlink" title="8.5.1 默认构造函数–&gt;也可写成默认实参的构造函数（还是默认构造函数）"></a>8.5.1 默认构造函数–&gt;也可写成默认实参的构造函数（还是默认构造函数）</h6><p>在没有为对象提供初始值，类没有显示地定义任何构造函数，编译器会为我们隐式的定义一个构造函数，称为合成的默认构造函数。其初始化规则：</p>
<ul>
<li>类内如果存在初始值，用它来初始化成员</li>
<li>没有，默认初始化（为0）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;		<span class="comment">//Sales_data类</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Sales_data</span>()=<span class="keyword">default</span>;	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> std::stsring&amp; s,<span class="type">unsigned</span> n,<span class="type">double</span> p):</span><br><span class="line">		<span class="built_in">BookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n) &#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> BookNo;&#125;</span><br><span class="line">	<span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	std::string BookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>c++11新标准，可以通过&#x3D;default来要求编译器生成合成的默认构造函数（default在类内部声明为内联的，在外部就不是）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>同时上面这条语句中，在<strong>初始化列表</strong>中有数据成员<code>units_sold,revenue</code>被忽略，那么他等价于<code>Salse_data(const std::string&amp; s):BookNo(s)，units_sold(0),revenue(0) &#123;&#125;;</code></p>
<h6 id="8-5-2-构造函数初始值列表"><a href="#8-5-2-构造函数初始值列表" class="headerlink" title="8.5.2 构造函数初始值列表"></a>8.5.2 构造函数初始值列表</h6><ul>
<li>冒号和花括号之间的部分。其负责为新创建的对象的一个或几个数据成员赋值。列表是是类内置成员的名字，其()括号内就为初始值（注意不是赋值而是初始化）。</li>
<li><em><strong>注意：列表对成员变量的初始化是按其类内声明顺序初始化，而不是列表顺序。</strong></em></li>
<li>使用初始化列表是直接初始化,因此具有更高的效率，而在函数体内是先初始化再赋值。存在效率的差异，如果是类对象，那么效率更低</li>
<li>构造函数的初始值列表解决了初始值必不可少的三种情况：<br>1.** 一是const或者引用成员，他们必须被初始化，因为在函数体内是赋值而不是初始化**。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况1</span></span><br><span class="line">Class  Test&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Test</span>(<span class="type">int</span> ii);	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> ci;		<span class="comment">//未被初始化</span></span><br><span class="line">		<span class="type">int</span> &amp;ri;			<span class="comment">//未被初始化</span></span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> cr=<span class="number">10</span>;	<span class="comment">//已类内初始化</span></span><br><span class="line">&#125;;</span><br><span class="line">Test:<span class="built_in">Test</span>(<span class="type">int</span> ii)&#123;</span><br><span class="line">	i=ii;</span><br><span class="line">	ci=ii;		<span class="comment">//错误，不能给const赋值</span></span><br><span class="line">	ri=i;			<span class="comment">//错误，引用必须创建时被初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
2.<strong>二是当成员属于某种类类型且该类型没有默认构造函数，也必须将这个成员初始化。</strong>尝试在内部通过赋值的方式初始化，但没有默认的构造函数，即参数列表为空，那么test就会首先被默认初始化，但是Test类没有默认的构造函数从而出现错误，所以初始化只能放在列表中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;	<span class="comment">//无默认构造函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Test&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mytest</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mytest</span>():<span class="built_in">test</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#123;       <span class="comment">//初始化ok</span></span><br><span class="line">        <span class="comment">//test(Test(1,2,3));//error: no match for call to &#x27;(Test) (Test)&#x27;</span></span><br><span class="line">        <span class="comment">//test=Test(12,3,4);//error: no matching function for call to &#x27;Test::Test()&#x27;</span></span><br><span class="line">        <span class="comment">//test(1,2,3);//error: no match for call to &#x27;(Test) (int, int, int)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Test test; <span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
3.<strong>三是需要初始化的数据成员是对象(存在继承关系，继承时调用基类构造函数)原因同样是创建对象时，要初始类成员的每一个成员</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Test</span> (<span class="type">int</span> x)&#123; int_x = x;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt; int_x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> int_x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mytest</span>:<span class="keyword">public</span> Test&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mytest</span>():<span class="built_in">Test</span>(<span class="number">110</span>)&#123;<span class="comment">//打印出110</span></span><br><span class="line">      <span class="comment">//Test(110);  //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用 。不报错但打印随机数：14887136</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em><strong>注意：从无到有叫初始化，初始化（调用拷贝构造函数）创建了新对象；赋值（调用赋值操作符）没有创建新对象，而是对已有的对象赋值。</strong></em></p>
<h6 id="8-5-3-类外构造函数的定义"><a href="#8-5-3-类外构造函数的定义" class="headerlink" title="8.5.3 类外构造函数的定义"></a>8.5.3 类外构造函数的定义</h6><p>以istream为参数的的构造函数因为要执行一些实际操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非成员函数</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">((istream &amp;is,Sales_data&amp; item)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">double</span> price=<span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	is&gt;&gt;item.BookNO&gt;&gt;item.units_sold&gt;&gt;price;</span></span></span><br><span class="line"><span class="params"><span class="function">	item.revenue=price*item.units_sold</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">return</span> is</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//构造函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">Sales_data::Sales_data(std::istream &amp;is)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	read(is,*<span class="keyword">this</span>);	<span class="comment">//read函数的作用是从is中读取一条交易信息后存入this</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>该构造函数的初始值列表是为空的，但对象的成员仍能够初始化。第二个参数的<code>this</code>是一个<code>Sale_data</code>对象的引用。<br>其他的诸如<strong>拷贝构造、赋值构造、析构和移动构造</strong>放在后面的<strong>拷贝控制</strong>详细讲述。</p>
<h6 id="8-5-4-委托构造函数"><a href="#8-5-4-委托构造函数" class="headerlink" title="8.5.4 委托构造函数"></a>8.5.4 委托构造函数</h6><p>c++11新标准扩展了构造函数初始值的功能，使得我们可以定义委托构造函数。所谓的委托构造函数其实就是一个构造函数的任务交给零一构造函数去完成，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">		<span class="built_in">Sales_data</span>(sting s,<span class="type">unsigned</span> cnt,<span class="type">double</span> price):</span><br><span class="line">			<span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(cnt),<span class="built_in">revenue</span>(cny*price)&#123;&#125;</span><br><span class="line">		<span class="comment">//委托构造函数</span></span><br><span class="line">		<span class="built_in">Sales_data</span>():<span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">		<span class="built_in">Sales_data</span>(string s):<span class="built_in">Sales_data</span>(s,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="8-5-5转换构造函数"><a href="#8-5-5转换构造函数" class="headerlink" title="8.5.5转换构造函数"></a>8.5.5转换构造函数</h6><p>如果构造函数只接受一个实参，<strong>那么实际上定义了转换为此类类型的隐式转换机制</strong>。这种构造函数称为<strong>转换构造函数</strong>，但只允许一步类类型转换。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;<span class="comment">//这个构造函数。支持了转换构造,参数为const</span></span><br></pre></td></tr></table></figure>
<p>在类中我们定义了一个<code>Sales_data &amp;combine(const Sales_data&amp;);</code>函数,参数为<code>const</code>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data item;	<span class="comment">//执行了默认构造函数</span></span><br><span class="line">string null_book=<span class="string">&quot;9-999-999&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(null_book);<span class="comment">//在这里combine函数的参数时Sales_data类型，因此这里用单参转换构造函数构造了一零时Sales_data对象，即null_book隐式转换为Sales_data类型</span></span><br></pre></td></tr></table></figure>
<p>在这里<code>combine</code>函数的参数实际是<code>Sales_data</code>类型，因此这里调用单参转换构造函数<code>Salse_data(const std::string&amp; s):BookNo(s)&#123;&#125;;</code>构造了一零时<code>Sales_data</code>对象，即null_book隐式转换为Sales_data类型,然后在执行该语句。<br><em><strong>注意：形参必须声明为<code>const</code></strong></em></p>
<h6 id="8-5-6-深浅拷贝区别"><a href="#8-5-6-深浅拷贝区别" class="headerlink" title="8.5.6 深浅拷贝区别"></a>8.5.6 深浅拷贝区别</h6><p><strong>背景：</strong></p>
<ol>
<li><strong>默认的拷贝构造函数进行了简单的赋值操作（浅拷贝）</strong></li>
<li><strong>浅拷贝的问题：当多个对象执行默认拷贝构造函数时会多次释放同一个分配的内存空间</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> age)&#123;</span><br><span class="line">		pName=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName,name);</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Student</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(pName);</span><br><span class="line">			pName=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;小明&quot;</span>，<span class="number">22</span>)</span>；</span></span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;		<span class="comment">//执行默认拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p>如下图，两个对象的<code>name</code>指针指向同一块内存。在释放时，这会导致同一块内存会被释放两次，这是不允许的。<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/copy.png" width="600" align="middle"><br><strong>深拷贝解决浅拷贝问题：自己写拷贝构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> Student &amp;stu)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//1.申请空间</span></span><br><span class="line">	pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(stu.pName) + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//2.拷贝数据</span></span><br><span class="line">	<span class="built_in">strcpy</span>(pName, stu.pName);</span><br><span class="line">	age = stu.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="8-6-访问控制和封装"><a href="#8-6-访问控制和封装" class="headerlink" title="8.6 访问控制和封装"></a>8.6 访问控制和封装</h5><h6 id="8-6-1-封装"><a href="#8-6-1-封装" class="headerlink" title="8.6.1 封装"></a>8.6.1 封装</h6><p>我们为类定义了接口，但并没有机制制约用户使用这些接口。使用访问说明符加强类的封装性：</p>
<ul>
<li><code>public</code>:<code>public</code>说明符之后的成员在整个程序可被访问</li>
<li><code>private</code>:可以被类的成员函数访问，但不能被使用该类的代码访问。</li>
<li><code>protected</code>:被该关键词修饰的成员不能被外部访问，但是能够给成员函数和继承的类访问</li>
<li><code>class</code>:<code>class</code>和<code>struct</code>一样的作用,声明一个类，唯一不同是定义在第一个访问说明符之前的成员的访问权限不同<code>struct</code>是<code>public</code>,<code>class</code>是<code>private</code></li>
</ul>
<h6 id="8-6-2-友元"><a href="#8-6-2-友元" class="headerlink" title="8.6.2 友元"></a>8.6.2 友元</h6><p>在真正的项目中，有一些一起声明在头文件的类的非成员函数，它们作为类的接口的一部分，想要访问该类的私有成员，但不是类的的成员，因此无法做到，而友元可以很好的解决这类问题：</p>
<p><strong>类可以允许其他类或者函数访问它的非公有成员，只要让这些类或函数成为该类的友员(friend)即可。友元函数必须被声明过。</strong>友元分为<strong>非成员函数友元、类友元和成员函数友元</strong>。</p>
<ul>
<li><p>非成员函数友元：即非成员函数在类内部声明<code>friends</code>。增加一条friend关键字开头的函数声明即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;		<span class="comment">//Sales_data类</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//三个非成员函数声明友元</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="built_in">Sales_data</span>()=<span class="keyword">default</span>;	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> std::stsring&amp; s,<span class="type">unsigned</span> n,<span class="type">double</span> p):</span><br><span class="line">	<span class="built_in">BookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n) &#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> BookNo;&#125;</span><br><span class="line">	<span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span>  <span class="type">const</span></span>;</span><br><span class="line">	std::string BookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类友元：即在类A中声明另一个类B为它的友元，那么类B可以访问类A的私有成员，但是A不能访问B的私有成员，如果要访问，那么应该也罢A声明为B的友元，即友元使单向的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	friends <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearA</span><span class="params">()</span></span>;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>成员函数友元:即将类A中声明一个类B的函数为友元，该函数能够访问A的私有成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">B::clearB</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em><strong>注意:要使某个类成员函数为另一类的友元，则必须组织程序的结构使声明和定义符合</strong></em><br>1.首先要定义B类，其中声明<code>clearB</code>函数但不定义。（在<code>clearB</code>使用<code>A</code>的成员之前必须先声明<code>A</code>）<br>2.定义<code>A</code>类，包括对<code>clearB</code>的友元声明<br>3.最后定义<code>clearB</code></p>
</li>
</ul>
<h5 id="8-7-类的其他特性"><a href="#8-7-类的其他特性" class="headerlink" title="8.7 类的其他特性"></a>8.7 类的其他特性</h5><h6 id="8-7-1-成员函数的重载"><a href="#8-7-1-成员函数的重载" class="headerlink" title="8.7.1 成员函数的重载"></a>8.7.1 成员函数的重载</h6><p>成员函数可支持重载，参数不同即可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Screen</span>()=defalut;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">(<span class="type">char</span> s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(<span class="type">char</span> s,<span class="type">size_t</span> i)</span></span>;	<span class="comment">//成员函数重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="8-7-2-内联函数"><a href="#8-7-2-内联函数" class="headerlink" title="8.7.2 内联函数"></a>8.7.2 内联函数</h6><p>在类中成为内联函数有两种：</p>
<ul>
<li>在类内定义的（隐式内联）</li>
<li>有inline关键字(显示内联）</li>
</ul>
<h6 id="8-7-3-可变数据成员"><a href="#8-7-3-可变数据成员" class="headerlink" title="8.7.3 可变数据成员"></a>8.7.3 可变数据成员</h6><p>在类中，存在<code>const</code>函数防止类内成员在此函数的修改，但有时候对于有些成员我们希望在任何函数都能够得到可变的保证，即使是在<code>const</code>函数总，因此出现了<code>mutable</code>关键字。只有被该关键字修饰的成员变量无论在类的哪个成员函数内都能得到可修改的保证：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">get</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">		acces_time++;</span><br><span class="line">		<span class="keyword">return</span> acces_time;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">size_t</span> acces_time=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="8-8-聚合类"><a href="#8-8-聚合类" class="headerlink" title="8.8 聚合类"></a>8.8 聚合类</h5><p>当一个类满足下述条件使，是聚合类（使用户可以直接访问其成员）：</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，也没有virtual函数。</li>
</ul>
<h4 id="9-IO库"><a href="#9-IO库" class="headerlink" title="9.IO库"></a>9.IO库</h4><h5 id="9-1-IO类"><a href="#9-1-IO类" class="headerlink" title="9.1 IO类"></a>9.1 IO类</h5><p>IO库设施和主要的类包括：</p>
<ul>
<li><code>ostream</code>类型，提供输出操作;<code>istream</code>类型，提供输入操作</li>
<li><code>cin</code>,一个<code>istream</code>对象，从标准输入读取数据;<code>cout</code>,一个<code>ostream</code>对象，向标准输出写入数;<code>cerr</code>，一个<code>ostream对</code>象，用于输出程序错误信息，写入到标准错误</li>
<li><code>&gt;&gt;</code>运算符，用于一个<code>istream</code>对象读取输入数据;<code>&lt;&lt;</code>运算符，用于一个<code>ostream</code>对象写入输出数据</li>
<li><code>getline()</code>,从一个给的的<code>istream</code>读取一行数据，存入一个给定的<code>string</code>对象。<code>getline(cin,s1)</code>;	读取内容，直到遇到换行符（换行符也被读取,但<code>s1</code>不存取换行符）。</li>
</ul>
<img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/IO.png" width="600">
- `iostream`定义了读写了基本类型
- `fstream`定义了读写命名文件的类型
- `sstream`定义了读写内存`string`对象的类型

<h5 id="9-2-条件状态"><a href="#9-2-条件状态" class="headerlink" title="9.2 条件状态"></a>9.2 条件状态</h5><p>以前用条件判断语句<code>while(cin&gt;&gt;i);		//EOF时结束，即达到了文件结束跳出循环（ctrl+z)</code>。来判断流是否有效，但我们无法知道流的具体状态。所以有如下IO库条件状态。<br>IO库定义了一个与机器无关的<code>iostate</code>类型。它提供了表达流状态的完整功能<code>（badbit、failbit、eofbit、goodbit</code>:</p>
<ul>
<li><code>badbit</code>表示发生系统级的错误，如不可恢复的读写错误。通常情况下一旦<code>badbit</code>被置位，流就无法再使用了–4（代表数字）。</li>
<li><code>failbit</code> 表示发生可恢复的错误，如期望读取一个数值，却读出一个字符等错误。这种问题通常是可以修改的，流还可以继续使用—2。</li>
<li>当到达文件的结束位置时，<code>eofbit</code> 和 <code>failbit</code> 都会被置位—1。</li>
<li><code>goodbit</code> 被置位表示流未发生错误。如果<code>badbit failbit 和eofbit</code> 任何一个被置位，则检查流状态的条件会失败—0。</li>
</ul>
<p>对应的<code>bad(), fail(), eof(), good()</code>能检查对应位是否被置位，返回1表示被置位。<strong>但是，<code>badbit</code>被置位时，<code>fail()</code>也会返回1。所以使用<code>good()</code>和<code>fail()</code>是确定流能否使用的正确方法</strong>。实际上，流当做条件使用的代码就等价于<code>!fail()</code>。而且<code>eof()</code> 和<code>bad()</code> 操作只能表示特定的错误.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> std::ios;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> m=ios::badbit;			<span class="comment">//4</span></span><br><span class="line">	ios::iostate n=ios::failbit;	<span class="comment">//2</span></span><br><span class="line">	ios::iostate m=ios::eofbit;		<span class="comment">//1</span></span><br><span class="line">	ios_base::iostate p=ios::goodbit;	<span class="comment">//0</span></span><br><span class="line">	<span class="type">int</span> number</span><br><span class="line">	cin&gt;&gt;number;			<span class="comment">//输入字符串 ada</span></span><br><span class="line">	<span class="keyword">auto</span> s=cin.<span class="built_in">rdstate</span>();	<span class="comment">//被置2</span></span><br><span class="line">	cin.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">auto</span> x=cin.<span class="built_in">rdstate</span>();	<span class="comment">//0</span></span><br><span class="line">	cin.<span class="built_in">setstate</span>(s);		<span class="comment">//置2</span></span><br><span class="line">	<span class="keyword">auto</span> y=cin.<span class="built_in">rdstate</span>();	<span class="comment">//为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-3-管理输出缓冲"><a href="#9-3-管理输出缓冲" class="headerlink" title="9.3 管理输出缓冲"></a>9.3 管理输出缓冲</h5><p>输出缓存刷新是指数据数据真正写到输出设备和文件，在C++中导致输出缓存刷新的的原因有：</p>
<ul>
<li>程序正常结束，作为<code>main</code>函数的<code>retrun</code>操作的一部分，缓存刷新执行</li>
<li>缓冲区满使，需要刷新，而后新的数据才能继续写入缓冲区</li>
<li>显式调用<code>endl</code>刷新缓冲区</li>
<li>每个输出操作之后，可使用操纵符<code>unitbuf</code>设置流的内部状态，来清空缓冲区。默认下，对<code>cerr</code>是设置<code>unitbuf</code>的，因此对于<code>cerr</code>来说写入到<code>cerr</code>的内容都是立即刷新的</li>
<li>一个输出流可能关联到另一个流。当读写被关联流时，关联到的流的缓冲区会被刷新。比如默认情况下，<code>cin</code>和<code>cerr</code>都被关联到<code>cout</code>,因此读<code>cin</code>或<code>cerr</code>都会导致<code>cout</code>的缓冲区被刷新</li>
</ul>
<p>每个输出流都管理一个缓冲区，最重要得是刷新缓冲区：</p>
<ul>
<li><code>endl</code>:输出操作后刷新缓冲区（会额外输出换行符）</li>
<li><code>flush</code>:输出操作后刷新缓冲区（没有额外字符）</li>
<li><code>ends</code>:输出操作后刷新缓冲区(额外输出空格符）</li>
</ul>
<p><strong>9.3.1 nitbuf操作符：每次输出都会flush</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;unitbuf;	<span class="comment">//所有输出操作后会立即刷新缓冲区</span></span><br><span class="line">cout&lt;&lt;nounitflush;	<span class="comment">//回到正常模式</span></span><br></pre></td></tr></table></figure>

<p><strong>9.3.2 关联输入输出流</strong><br>标准库默认将cout于cin关联在一起。手动关联操作<code>tie</code>，有带参和不带参两个版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带参：返回指向输出流得指针</span></span><br><span class="line"><span class="comment">//带参：接受一个ostream得指针参数，将对象关联到该输出流</span></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);</span><br></pre></td></tr></table></figure>

<h5 id="9-4-文件输入输出"><a href="#9-4-文件输入输出" class="headerlink" title="9.4 文件输入输出"></a>9.4 文件输入输出</h5><ul>
<li>ifstream从一个给定文件读取数据</li>
<li>ofstream向一个给定文件写入数据</li>
<li>fstream向给定文件读写</li>
</ul>
<p>除了继承了iostream类型的行为之外，fstream中定义的类型还增加了新的成员来管理与流关联的文件。如下：<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/fstream.png" width="600"></p>
<h6 id="9-4-1-继承关系"><a href="#9-4-1-继承关系" class="headerlink" title="9.4.1 继承关系"></a>9.4.1 继承关系</h6><p>因为<code>fstream</code>继承自<code>iostream</code>，<code>ifstream</code>继承自<code>istream</code>，<code>ofstream</code>继承自<code>ostream</code>。所以由继承机制的：<strong>派生类（继承类）的对象可以当作其基类（被继承类）的对象来使用</strong>。所以在参数为<code>ostream&amp;</code>的函数中允许我们传入一个<code>ofstream</code>型参数，同理其他两个也是一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s=<span class="string">&quot;xxx/xxxx/xxx.txt&quot;</span>;</span><br><span class="line">	<span class="function">fstream <span class="title">f</span><span class="params">(s)</span></span>;</span><br><span class="line">	<span class="built_in">func</span>(f);	<span class="comment">//允许传入一个fstream参数，派生类像基类转换</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(iostream&amp; io)</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="9-4-2-open和close"><a href="#9-4-2-open和close" class="headerlink" title="9.4.2 open和close"></a>9.4.2 open和close</h6><p>若我们定义了一个空文件流对象:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstream file;</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>open</code>来将<code>file</code>与相应的文件关联起来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">open</span>(filename);	<span class="comment">//若调用open失败，则failbit会被置位</span></span><br></pre></td></tr></table></figure>
<p>所以我们在执行open后，判断流的状态是一个好习惯，流的状态有效，才能对流执行操作。操作完后手动关闭。当流对象离开作用域域是，流对象会被销毁，结果是会自动调用<code>close</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(file)&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">if</span>(!file.failbit)&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<p><em><strong>注意：<code>ofstream</code>是对写文件，从程序写出到文件，<code>ifstream</code>是从文件读入到程序中。这点不要搞混</strong></em></p>
<h6 id="9-4-3-文件模式"><a href="#9-4-3-文件模式" class="headerlink" title="9.4.3 文件模式"></a>9.4.3 文件模式</h6><p>每个流都有关联的文件模式，用来指出如何使用文件。<code>ofstream</code>关联<code>out</code>、<code>ifstream</code>关联<code>in</code>、<code>fstream</code>关联<code>in</code>和<code>out</code>。<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/filemode.png" width="600"></p>
<ul>
<li>只可以对<code>ofstream</code>或<code>fstream</code>对象设定<code>out</code>模式;只可以对<code>ifstream</code>或<code>fstream</code>对象设定<code>in</code>模式</li>
<li>只有当<code>out</code>被设定时才可设定<code>trunc</code>模式</li>
<li><code>trunc</code>没被设定，<code>app</code>就可设定。且在<code>app</code>模式下，文件也是<code>out</code>模式下打开(open)</li>
<li>即使没有设定<code>trunc</code>模式，<code>out</code>模式打开（open)的文件也会被截断。所以为保留out模式打开的文件，需要指定<code>app</code>模式（或同时指定in模式）</li>
<li><code>ate</code>和<code>binary</code>模式可用于任何文件流，与任何模式组合。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IOFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fstream isfile;</span><br><span class="line">	ofstream out;</span><br><span class="line">	ifstream in;</span><br><span class="line">	out.<span class="built_in">open</span>(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (out) &#123;	<span class="comment">//判断是否打开成功</span></span><br><span class="line">		out &lt;&lt; <span class="string">&quot;out成功了&quot;</span> &lt;&lt; endl;</span><br><span class="line">		out.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	isfile.<span class="built_in">open</span>(<span class="string">&quot;D:\\test.txt&quot;</span>, std::fstream::app);</span><br><span class="line">	<span class="keyword">if</span> (isfile) &#123;</span><br><span class="line">		isfile &lt;&lt; <span class="string">&quot;isfile也成功了&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string s;</span><br><span class="line">		isfile &gt;&gt; s;</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;	<span class="comment">//打印换行，因为写入时已经指定app在末尾</span></span><br><span class="line">		isfile.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	in.<span class="built_in">open</span>(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (in) &#123;</span><br><span class="line">		string s;</span><br><span class="line">		in &gt;&gt; s;</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">		in.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>out会发生截断是因为每次写操作没有定位到文件末尾，所以防止截断是设定app模式</p>
<h5 id="9-5-string流"><a href="#9-5-string流" class="headerlink" title="9.5 string流"></a>9.5 string流</h5><p><strong>与<code>fstream</code>类似，<code>string</code>也分别继承于<code>iostream</code>。</strong><code>istringstream</code>从<code>string</code>读取数据，<code>ostringstream</code>向<code>string</code>写入，<code>stringstream</code>即可写入也可读取。<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/stringstream.png" width="600"></p>
<h5 id="9-6-常用成员函数"><a href="#9-6-常用成员函数" class="headerlink" title="9.6 常用成员函数"></a>9.6 常用成员函数</h5><h6 id="9-6-1-istream的成员函数"><a href="#9-6-1-istream的成员函数" class="headerlink" title="9.6.1 istream的成员函数:"></a>9.6.1 <code>istream</code>的成员函数:</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>() <span class="comment">//一次只能读取一个字符</span></span><br><span class="line">cin.<span class="built_in">get</span>(一个参数) <span class="comment">//读一个字符</span></span><br><span class="line">cin.<span class="built_in">get</span>(两个参数) <span class="comment">//可以读字符串</span></span><br><span class="line">cin.<span class="built_in">getline</span>()<span class="comment">//取一行，换行符丢弃</span></span><br><span class="line">cin.<span class="built_in">ignore</span>()<span class="comment">//忽略</span></span><br><span class="line">cin.<span class="built_in">peek</span>()<span class="comment">//偷窥，只看不从缓冲区拿走</span></span><br><span class="line">cin.<span class="built_in">putback</span>()<span class="comment">//放回缓冲区</span></span><br></pre></td></tr></table></figure>

<h6 id="9-6-2-ostream可用"><a href="#9-6-2-ostream可用" class="headerlink" title="9.6.2 ostream可用"></a>9.6.2 <code>ostream</code>可用</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过流成员函数实现格式化的输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">99</span>;</span><br><span class="line">	cout.<span class="built_in">width</span>(<span class="number">20</span>);<span class="comment">//设置宽度</span></span><br><span class="line">	cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);<span class="comment">//填充</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::left);<span class="comment">//让数据在左边</span></span><br><span class="line">	cout.<span class="built_in">unsetf</span>(ios::dec);<span class="comment">//卸载十进制</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::hex);<span class="comment">//安装十六进制</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::showbase);<span class="comment">//显示基数</span></span><br><span class="line">	cout.<span class="built_in">unsetf</span>(ios::hex);<span class="comment">//卸载十六进制</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::oct);<span class="comment">//安装八进制</span></span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过控制符来格式化输出，引入头文件iomanip</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//重载了&lt;&lt;运算符</span></span><br><span class="line">	<span class="type">int</span> num = <span class="number">99</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">20</span>);<span class="comment">//设置宽度</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;~&#x27;</span>);<span class="comment">//填充</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::showbase);<span class="comment">//显示基数</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::left);<span class="comment">//让数据在左边</span></span><br><span class="line">	cout &lt;&lt; hex;<span class="comment">//六十进制</span></span><br><span class="line">	cout &lt;&lt; oct;<span class="comment">//八进制</span></span><br><span class="line">	cout &lt;&lt; dec;<span class="comment">//十进制</span></span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="9-6-3-fstrem常用"><a href="#9-6-3-fstrem常用" class="headerlink" title="9.6.3 fstrem常用"></a>9.6.3 <code>fstrem</code>常用</h6><p>主要读写：其有write()&#x2F;read()成员函，重载&lt;&lt;&#x2F;重载&gt;&gt;运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名:悟空&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Maker <span class="title">m1</span><span class="params">(<span class="string">&quot;悟空&quot;</span>,<span class="number">18</span>)</span>；</span></span><br><span class="line"><span class="function">ofstream ofs</span>;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc | ios::binary);</span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;m1, <span class="built_in">sizeof</span>(Maker));</span><br></pre></td></tr></table></figure>
<p><em><strong>注：当文件读写时，类中的成员变量不要有string类型，因为：</strong></em></p>
<ul>
<li>①string类中有一个成员指针char*,该指针指向存储字符串的空间</li>
<li>②当我们把string类的数据存储到文件中，再读出来时，不能保证指针有效</li>
</ul>
<h4 id="10-动态内存"><a href="#10-动态内存" class="headerlink" title="10.动态内存"></a>10.动态内存</h4><h5 id="10-1-生命周期"><a href="#10-1-生命周期" class="headerlink" title="10.1 生命周期"></a>10.1 生命周期</h5><p><strong>目前的我们接触到的对象或者静态static都有着严格的生命周期：</strong></p>
<ul>
<li><strong>全局：</strong>程序启动时自动分配，程序结束时销毁</li>
<li><strong>局部对象：</strong>进入其所定义的程序时被创建，离开块时销毁</li>
<li><strong>静态：</strong>第一次使用前分配，程序结束时销毁</li>
</ul>
<p>上述中的变量只使用了静态内存和栈内存。它们会自动创建和销毁。静态内存保存局部static、类static成员以及定义在任何函数之外的变量。栈内存保存定义在函数内的非static对象</p>
<p>除了上述的自动分配外，<strong>c++还支持动态分配对象</strong>。（其生命周期与它们在哪创建无关，只有显式的被释放时，这些对象才会被销毁）。<strong>它们被分配在内存池，称作自由空间或堆。程序用堆来存储动态分配</strong>。</p>
<h5 id="10-2-new动态内存"><a href="#10-2-new动态内存" class="headerlink" title="10.2 new动态内存"></a>10.2 new动态内存</h5><h6 id="10-2-1-直接动态内存管理"><a href="#10-2-1-直接动态内存管理" class="headerlink" title="10.2.1 直接动态内存管理"></a>10.2.1 直接动态内存管理</h6><p>c++的动态内存管理是通过一对运算符来完成：</p>
<ul>
<li><code>new</code>,在动态内存中为对象分配空间并返回一个指向该对象的指针</li>
<li><code>delete</code>,接受一个动态对象的指针，销毁该对象，并释放关联的内存。</li>
</ul>
<p>不再使用的动态内存应及时释放，否则会造成内存泄漏。释放<code>delete</code>的时机要适宜，否则在还有指针引用内存的时候释放，会导致引用非法内存的指针错误.<strong>内存泄漏：分配内存使用完毕后不释放将引起内存泄漏，会榨干内存。<br>相对于智能指针，直接管理内存的类与使用智能指针的类不同，他们不能依赖类拷贝、赋值和销毁操作的任何默认定义。</strong>虽然如此，但有时候我们不得不用的<code>new与delete</code>。在后面我们还会介绍跟高级的内存分配工具<code>allocator类</code></p>
<h6 id="10-2-2-使用new动态分配和初始化对象"><a href="#10-2-2-使用new动态分配和初始化对象" class="headerlink" title="10.2.2 使用new动态分配和初始化对象"></a>10.2.2 使用new动态分配和初始化对象</h6><p>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是<strong>返回一个指向该对象的指针</strong>。默认情况下，动态分配的对象是默认初始化的，这意味着<strong>内置类型或组合类型的对象的值是未定义的，而类类型对象将默认构造函数进行初始化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *ps=<span class="keyword">new</span> string;	<span class="comment">//初始化为空的string。类类型--&gt;默认构造,等价于与值初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>;	<span class="comment">//p指向一个动态分配、未初始化的无名对象。内置类型--&gt;值初始化</span></span><br></pre></td></tr></table></figure>
<p>也可以直接初始化一个动态分配的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line">string *ps=<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;trluper&quot;</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;* pv=<span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><em><strong>注意：对于内置类型，注意值初始化和默认初始化的区别：</strong></em></p>
<ul>
<li>对于定义了自己的构造函数的类类型（如string），要求值初始化是没有意义的，因为不管采用什么形式，对象都会通过默认构造函数来初始化；</li>
<li>对于内置类型，值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。</li>
<li>对于类中那些依赖于编译器合成的默认构造函数的内置类型对象，如果它们未在类内初始化，它们的值也是未定义的</li>
</ul>
<p>如果我们提供了一个括号包围的初始化器，就可以使用auto，此时初始化器可以推断我们想要分配的对象的类型，<strong>只有当括号中仅有单一初始化器才能使用auto</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1=<span class="keyword">new</span> <span class="built_in">auto</span>(obj);</span><br><span class="line"><span class="keyword">auto</span> p2=<span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125;;	<span class="comment">//错误，括号中只能有单一初始化器</span></span><br></pre></td></tr></table></figure>

<h6 id="10-2-3-动态分片的const对象"><a href="#10-2-3-动态分片的const对象" class="headerlink" title="10.2.3 动态分片的const对象"></a>10.2.3 动态分片的const对象</h6><p><strong>动态分配的const对象必须进行初始化</strong>。对于定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* pci=<span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);		<span class="comment">//显示初始化</span></span><br><span class="line"><span class="type">const</span> string *pcs=<span class="keyword">new</span> <span class="type">const</span> string;		<span class="comment">//隐式</span></span><br></pre></td></tr></table></figure>

<h6 id="10-2-4-内存耗尽"><a href="#10-2-4-内存耗尽" class="headerlink" title="10.2.4 内存耗尽"></a>10.2.4 内存耗尽</h6><p>默认情况下，<strong>如果<code>new</code>不能分配所要求的内存空间，会抛出一个类型为<code>bad_alloc</code>的异常</strong>。我们也可以改变使用<code>new</code>的方式来阻止它抛出异常（称为定位new)。<code>bad_alloc</code>和<code>nothrow</code>都定义在头文件<code>new</code>中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> *p1=<span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//如果分配失败，会抛出一个类型为`bad_alloc`的异常</span></span><br><span class="line"><span class="type">int</span> *p2=<span class="built_in">new</span>(nothrow) <span class="type">int</span>;<span class="comment">//如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure>

<h6 id="10-2-5-释放内存"><a href="#10-2-5-释放内存" class="headerlink" title="10.2.5 释放内存"></a>10.2.5 释放内存</h6><p><code>delete</code>表达式接受一个指针，指向我们想要释放的对象:<code>delete p</code>。<br><strong>指针值和<code>delete</code>：</strong>传递给<code>delete</code>的指针必须指向动态分配的内存，或者是一个空指针。释放一块并<code>非new</code>分配的内存，或者将相同的指针值释放多次，其行为是未定义的。虽然一个<code>const对象</code>的值不能被改变，但它本身是可以被销毁的.<code>delete</code>条件有：</p>
<ul>
<li>应与<code>new</code>配对使用，既只能释放<code>new</code>分配得内存</li>
<li>不要再次释放已经释放得内存</li>
<li>如果使用<code>new[]</code>分配动态数组，应用<code>delete[]</code>释放</li>
<li>对空指针使用<code>delete</code>是安全的</li>
</ul>
<p>不需要再使用该动态分配的内存时，必须释放，否则容易内存泄漏！！以下是两个版本的use_factory函数。（p是已经new分配好的返回指针）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_factory</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//函数结束，不再需要，则释放</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">use_factory</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//函数结束，仍然需要，则返回后由调用这释放</span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="10-2-6-动态数组"><a href="#10-2-6-动态数组" class="headerlink" title="10.2.6 动态数组"></a>10.2.6 动态数组</h6><p>某些应用需要一次性为很对对象分配内存（如vector\string都是在连续内存中保存它们的元素)。为了支持这种需求，c++语言和标准库提供两者方法：</p>
<ul>
<li>分配和初始化一个对象数组</li>
<li>应用allocator类</li>
</ul>
<p>通常第二种法方会提供更好的性能和更灵活的管理内存能力，我们将在后面介绍，同时<strong>“STL源码剖析”</strong>会更详细。这类我们说说<code>new[]</code></p>
<p><strong>new和数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[size];		<span class="comment">//返回的指向第一个元素对象指针</span></span><br><span class="line"><span class="comment">//初始化动态分配对象的数组</span></span><br><span class="line"><span class="comment">//不加括号——默认初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];		<span class="comment">//默认初始化</span></span><br><span class="line"><span class="comment">//大小之后加一对空括号——值初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]();		<span class="comment">//10个值初始化为0</span></span><br><span class="line"><span class="comment">//大小之后跟一个花括号列表——初始化器初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放，使用特殊的delete来释放动态数组，在delete前加上一个空方括号对(方括号必须加上)</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>
<p>当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。但此指针不能解引用——毕竟它不指向任何元素。	</p>
<p><em><strong>注意：</strong></em>我们得到的时数组元素的指针，而不是数组的对象，所以我们不能调用标准库函数中的<code>begin()和end()</code>，也不能使用<code>范围for循环</code>。</p>
<h5 id="10-3new与C的malloc的比较"><a href="#10-3new与C的malloc的比较" class="headerlink" title="10.3new与C的malloc的比较"></a>10.3new与C的malloc的比较</h5><h5 id="10-4-shared-ptr智能指针"><a href="#10-4-shared-ptr智能指针" class="headerlink" title="10.4 shared_ptr智能指针"></a>10.4 shared_ptr智能指针</h5><p>为了更安全地使用动态内存，新标准库提供了两种智能指针。智能指针类似于常规指针，<strong>但区别是它负责自动释放所指向的对象：</strong></p>
<ul>
<li><code>shared_ptr</code>,它允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code>，独占一个对象（一个指针指向一个对象）</li>
<li><code>weak_ptr</code>,弱引用，指向<code>shared_ptr</code>所过来的对象</li>
</ul>
<p>上述的三种类型都定义在<code>memory</code>头文件中</p>
<h6 id="10-4-1-shared-ptr类"><a href="#10-4-1-shared-ptr类" class="headerlink" title="10.4.1 shared_ptr类"></a>10.4.1 shared_ptr类</h6><p>类似于vector,智能指针也是模板。使用该类的理由有以下几点：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; p1;		<span class="comment">//p1指向string</span></span><br><span class="line">shared_ptr&lt;list&lt;T&gt;&gt; p2;		<span class="comment">//指向int的list</span></span><br></pre></td></tr></table></figure>

<img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/shared_ptr.png" width="700">

<h6 id="10-4-2-make-shared函数"><a href="#10-4-2-make-shared函数" class="headerlink" title="10.4.2 make_shared函数"></a>10.4.2 make_shared函数</h6><p>最安全的分配和使用动态内存的方法是调用该函数。<code>make_shared&lt;T&gt;(args)</code>函数在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hared_ptr&lt;<span class="type">int</span>&gt; p3=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//指向一个值为42的int的shared_ptr</span></span><br><span class="line">shared_ptr&lt;string&gt; p4=<span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">//指向一个值为9999999999的string</span></span><br><span class="line">share_ptr&lt;<span class="type">int</span>&gt; p5=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//指向值初始化为0的int</span></span><br><span class="line"><span class="keyword">auto</span> p5=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//指向值初始化为0的int</span></span><br></pre></td></tr></table></figure>

<h6 id="10-4-3-shared-ptr的拷贝和赋值和释放"><a href="#10-4-3-shared-ptr的拷贝和赋值和释放" class="headerlink" title="10.4.3 shared_ptr的拷贝和赋值和释放"></a>10.4.3 shared_ptr的拷贝和赋值和释放</h6><p>（1）当进行拷贝和赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他<code>shared_ptr</code>指向相同的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;		<span class="comment">//q是p的拷贝，递增了的计数器。对象此时有俩引用者</span></span><br></pre></td></tr></table></figure>
<p>（2）当给相应的<code>shared_ptr</code>赋予一个新值，计数器递减，当为0时，自动释放自己所管理的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);		<span class="comment">//创建shared_ptr,为值43动态分配内存，拷贝</span></span><br><span class="line">p=r;		<span class="comment">//给p新赋值r,令他指向了另一个地址，此时</span></span><br><span class="line">			<span class="comment">//递增r所指向的引用计数</span></span><br><span class="line">			<span class="comment">//递减p原来的指向的对象的引用计数</span></span><br><span class="line">			<span class="comment">//若递减后为0，已没有引用者，自动释放</span></span><br></pre></td></tr></table></figure>
<p><strong>销毁\释放原理</strong>：通过一个特殊的成员函数————析构函数完成销毁工作（每个类都有一个析构函数）。<strong>析构函数一般用来来释放对象所分配的的资源</strong>。<code>shared_ptr</code>的析构函数会递减它所指向对象的引用计数，当为0时，就会销毁对象，释放内存。</p>
<p>（3）当对象被销毁时，将递减其引用引用计数并检查它是否为0，如下这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;foo&gt; <span class="title">factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line"><span class="comment">//该函数返回shared_ptr</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_shared</span>&lt;foo&gt;(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">use_factory</span>(T arg)</span><br><span class="line">&#123;	</span><br><span class="line">shared_ptr&lt;Foo&gt; p=<span class="built_in">factory</span>(arg);</span><br><span class="line"><span class="comment">//为arg用智能指针动态分配内存，达到能够自动释放的目的</span></span><br><span class="line">&#125;<span class="comment">//对象p离开了此作用域被销毁，此时计数减一（此例为0--&gt;释放内存）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">shared_ptr&lt;Foo&gt; p=<span class="built_in">factory</span>(arg)	</span><br><span class="line"><span class="comment">//为arg用智能指针动态分配内存，达到能够自动释放的目的</span></span><br><span class="line"><span class="keyword">return</span> p;	<span class="comment">//引用加1，为2</span></span><br><span class="line">&#125;	<span class="comment">//此时p减一，但不为0，不释放</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="10-4-4-shared-ptr的共享数据"><a href="#10-4-4-shared-ptr的共享数据" class="headerlink" title="10.4.4 shared_ptr的共享数据"></a>10.4.4 shared_ptr的共享数据</h6><p>到目前为止，我们使用的类中，分配的资源都与对应对象生存期一致。当我们拷贝一个<code>vector</code>时，<code>原vector</code>和<code>副本vector</code>中的元素是相互分离的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v1;</span><br><span class="line">&#123;<span class="comment">//新作用域</span></span><br><span class="line">    vector&lt;string&gt; v2=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line">    v1=v2; <span class="comment">//从v2拷贝元素到v1</span></span><br><span class="line">&#125; <span class="comment">//v2被销毁，其中的元素也被销毁</span></span><br><span class="line"><span class="comment">//v1依然有三个元素</span></span><br></pre></td></tr></table></figure>
<p>所以此时的<code>V2只是V1</code>的一份赋值过来的值。指向的不是共同地址的数据。(这里的共同是指内存地址是同一个）。为了达到这个目的，<code>shared_ptr</code>就排上了用场–&gt;多个对象共享数据。</p>
<h6 id="10-4-5-定义StrBlob类"><a href="#10-4-5-定义StrBlob类" class="headerlink" title="10.4.5 定义StrBlob类"></a>10.4.5 定义StrBlob类</h6><p>下面的是创建一个类模板（实现多个对象共享数据），每个<code>strBlob</code>对象设置一个<code>shared_ptr</code>来管理动态分配的vector。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlob</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::vector&lt;std::string&gt;::size_type size_type;</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">StrBlob</span>();</span><br><span class="line">	<span class="comment">//可变形参构造函数，内元素均为字面值且为strig</span></span><br><span class="line">	<span class="built_in">StrBlob</span>(std::initializer_list&lt;std::string&gt; il);</span><br><span class="line">	<span class="comment">//容器大小和判空</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span>  <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> std::string &amp;t)</span> </span>&#123; data-&gt;push_back; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//外部获得类的data</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;* <span class="built_in">get</span>()&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置data</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(shared_ptr&lt;std::vector&lt;std::string&gt;&gt;* p)</span></span>&#123;</span><br><span class="line">		data=p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">std::string &amp;<span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string &amp;<span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//声明智能指针data</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;</span><br><span class="line">	<span class="comment">//如果data[i]不合法，抛出一个异常</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span>()：<span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;()) &#123;&#125;</span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span>(initializer_list&lt;string&gt; il):</span><br><span class="line">       <span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125;</span><br><span class="line"><span class="comment">//检查函数，i&gt;size，抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrBlob::check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取头元素</span></span><br><span class="line"><span class="function">string &amp;<span class="title">StrBlob::front</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;front on empty StrBlob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取尾元素</span></span><br><span class="line"><span class="function">string&amp; <span class="title">StrBlob::back</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;back on empty StrBlob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弹出尾部元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrBlob::pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了该类后，我们创建类的对象，可以通过<code>get</code>函数获得智能指针，通过<code>set</code>赋给类的新对象即可.这样实现了类多个对象的数据共享。这要看很像类的静态成员，但它比静态成员有一个好处就是，当没有对象引用时，会释放，而不像静态成员持续到程序结束时才释放</p>
<h6 id="10-4-6-shared-ptr和new结合使用"><a href="#10-4-6-shared-ptr和new结合使用" class="headerlink" title="10.4.6 shared_ptr和new结合使用"></a>10.4.6 shared_ptr和new结合使用</h6><p>我们可以用<code>new</code>返回的指针来初始化智能指针。因为接受指针参数的智能指针构造函数是<code>explicit</code>的，<strong>因此我们不能将一个内置指针隐式转换成一个智能指针</strong>，必须使用直接初始化形式而且使用字面值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);    <span class="comment">//错误：必须使用直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;   <span class="comment">//正确：使用了直接初始化形式</span></span><br></pre></td></tr></table></figure>
<p>同理，一个返回<code>shared_ptr</code>的函数不能在其返回语句中隐式转换成一个普通指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(p);  <span class="comment">//错误：隐式转换为shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));  <span class="comment">//正确：显式地用int*创建shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所关联的对象。<br><em><strong>注意：</strong></em>内置指针是指内置类型<code>（如int、char)</code>的指针，一般没有默认构造函数。普通指针是普通类型的指针），一般有默认构造函数</p>
<img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/shared.png" width="700">



<h6 id="10-4-7-莫交错使用new和shared-ptr"><a href="#10-4-7-莫交错使用new和shared-ptr" class="headerlink" title="10.4.7 莫交错使用new和shared_ptr"></a>10.4.7 莫交错使用new和shared_ptr</h6><p>当将一个<code>shared_ptr</code>绑定到一个普通指针时，我们就将内存的管理责任交给了这个<code>shared_ptr</code>。一旦这么做了，我们就不应该再使用内置指针来访问<code>shared_ptr</code>所指向的内存了。如下列子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; p)</span></span>&#123;</span><br><span class="line"><span class="comment">//空函数，离开时p对象被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;  <span class="comment">//危险：x是一个普通指针，而不是一个智能指针</span></span><br><span class="line"><span class="comment">//process(x);           //错误：不能将int*转换成一个shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));   <span class="comment">//临时shared_ptr，合法的，但内存会被释放，引用计数变为0</span></span><br><span class="line"><span class="type">int</span> j=*x;   <span class="comment">//未定义的：x是一个空悬指针</span></span><br></pre></td></tr></table></figure>

<p><strong>上述代码中<code>x</code>是一个普通指针，当把<code>x</code>传给<code>process</code>时，报错，因为普通指针不能隐式的转换为智能指针。传入的实参显示转换为智能指针，此时<code>x</code>就将内存交给了<code>shared_ptr</code>管理</strong>，当该函数执行完毕时，该指针指针<code>shared_ptr</code>被销毁（x所指向的内存没了），<code>x</code>也就成了空悬指针。</p>
<p>使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。而且内置指针很可能成为空悬指针</p>
<h6 id="10-4-8-智能指针和异常"><a href="#10-4-8-智能指针和异常" class="headerlink" title="10.4.8 智能指针和异常"></a>10.4.8 智能指针和异常</h6><p>使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//如果在这里抛出了异常,其内存也会释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面这种清空就不会释放：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//如果在这里抛出了异常</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;<span class="comment">//因为抛出了异常，无法执行delete p语句</span></span><br></pre></td></tr></table></figure>

<h6 id="10-4-9-删除器"><a href="#10-4-9-删除器" class="headerlink" title="10.4.9 删除器"></a>10.4.9 删除器</h6><p>某些类没有定义析构函数，此时我们可以使用<code>shared_ptr</code>来保证该类生成的对象的内存被正确释放，首先定义一个函数（删除器）来代替得<code>delete</code>。下面以连接为例子，<code>destination</code>类是连接信息类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一些类和接口</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;		<span class="comment">//该类标识我们连接的信息，如端口，地址</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connnection</span>;		<span class="comment">//连接类，已连接信息记录</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destionatin *p)</span></span>;	<span class="comment">//请求连接,返回一个连接类记录信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnection</span><span class="params">(connection)</span></span>;		<span class="comment">//关闭连接,内含delete操作</span></span><br><span class="line"><span class="comment">//对声明的类和接口定义</span></span><br><span class="line">....</span><br><span class="line"><span class="comment">//定义删除器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connecttion</span><span class="params">(connection *p)</span></span>&#123;</span><br><span class="line">	<span class="built_in">disconnection</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shared_ptr使用删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">	connection c=<span class="built_in">connect</span>(&amp;d)；	<span class="comment">//返回一个连接类信息</span></span><br><span class="line">	shared_ptr&lt;connection&gt; <span class="built_in">p</span>(&amp;c,end_connnection);	<span class="comment">//shared_ptr的用法，自定义删除器</span></span><br><span class="line">	<span class="comment">//这样。当f函数退出时，即使是由异常引起的，Connection也会被释放关掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当对象智能指针对象p离开函数f的作用域时，自动调用end_connection函数，end_connection函数又调用disconnection函数执行delete操作，注意形参时指针类型</p>
<h6 id="10-4-10-shared-ptr与数组"><a href="#10-4-10-shared-ptr与数组" class="headerlink" title="10.4.10 shared_ptr与数组"></a>10.4.10 shared_ptr与数组</h6><p>与<code>unique_ptr</code>不同，<code>shared_ptr</code>不直接支持管理动态数组。如果我们希望使用<code>shared_ptr</code>管理一个动态数组，<strong>必须提供自己定义的删除器(因为删除是我们默认的是<code>delete</code>而不是<code>delete[]</code>)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了使用shared_ptr,必须提供一个删除器</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>],[](<span class="type">int</span> *p)&#123;<span class="keyword">delete</span> [] p;&#125;)</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>();   <span class="comment">//使用我们提供的lambda释放数组，它使用delete[]</span></span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code>未定义下标运算符，<strong>而且智能指针类型不支持指针算数运算</strong>。因此，为了访问数组中的元素，必须用<code>get</code>获取一个内置指针，然后用它来访问数组元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</span><br><span class="line">    *(sp.<span class="built_in">get</span>()+i)=i;  <span class="comment">//使用get获取一个内置指针</span></span><br></pre></td></tr></table></figure>

<h5 id="10-5-unique-ptr"><a href="#10-5-unique-ptr" class="headerlink" title="10.5 unique_ptr"></a>10.5 unique_ptr</h5><p><code>unique_ptr</code>是C++的另一个智能指针，与<code>shared_ptr</code>不同的是，任何时刻，都至多只能有一<code>unique_ptr</code>智能指针指向一个对象，当<code>unique_ptr</code>指针被销毁时，其对象也被销毁。</p>
<h6 id="10-5-1-unique-ptr的初始化"><a href="#10-5-1-unique-ptr的初始化" class="headerlink" title="10.5.1 unique_ptr的初始化"></a>10.5.1 unique_ptr的初始化</h6><p>与<code>shared_ptr</code>不同，没有类似<code>make_shared</code>的标准函数返回一个<code>unique_ptr</code>。因此，当我们定义一个<code>unique_ptr</code>时，需要将其绑定到一个<code>new</code>返回的指针上。类似于<code>shared_ptr</code>（接受参数的构造函数有<code>explicit修饰</code>），所以初始化<code>unique_ptr</code><strong>必须采用直接初始化方式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p;		<span class="comment">//定义</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;		<span class="comment">//定义并初始化，指向一个值为24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr不支持普通的拷贝和赋值：</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p2</span>(p1);		<span class="comment">//错误，不支持拷贝</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;p3;</span><br><span class="line">p3=p1;						<span class="comment">//或p3(p2)错误，不允许赋值</span></span><br></pre></td></tr></table></figure>
<img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/unique_ptr.png" width="700">


<p>虽然我们无法拷贝或者赋值，但我们可以通过调用<code>release或reset</code>将指针所有权从一个<code>（const)unique_ptr</code>转移给另一个<code>unique_ptr</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;	<span class="comment">//p1转移给p2，p1置空</span></span><br><span class="line">unique_ptr&lt;string&gt;<span class="built_in">p3</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line"><span class="comment">//p3转移给p2ertyui</span></span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">//p2释放原来的，p3被置空，p2指向的p3的</span></span><br></pre></td></tr></table></figure>
<p><strong><code>release</code>函数会切断智能指针和它原来管理的对象的联系</strong>，它返回的指针通常用来初始化另一个智能指针或给另一个智能指针赋值。<br>如果我们不用另一个智能指针来保存<code>release</code>返回的指针，我们的程序就要负责资源的释放：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=p2.<span class="built_in">release</span>();		<span class="comment">//后面程序应该有delete(p);操作</span></span><br></pre></td></tr></table></figure>

<h6 id="10-5-2-向unique-ptr传递删除器"><a href="#10-5-2-向unique-ptr传递删除器" class="headerlink" title="10.5.2 向unique_ptr传递删除器"></a>10.5.2 向unique_ptr传递删除器</h6><p>和<code>shared_ptr</code>一样，<code>unique_ptr</code>默认情况（源代码）使用<code>delete</code>释放它指向的对象。我们可和<code>shared_ptr</code>一样重载一个<code>unique_ptr</code>中的删除器。</p>
<p>重载一个<code>unique_ptr</code>中的删除器会影响到<code>unique_ptr类型</code>以及如何构造（或<code>reset</code>）该类型的对象：<strong>我们必须在尖括号中<code>unique_ptr</code>指向类型之后提供删除器类型</strong>，即在创建或<code>reset</code>一个这种<code>unique_pt</code>r类型的对象时，必须提供一个指定类型的可调用对象（删除器）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span></span><br><span class="line"><span class="comment">//它会调用一个名为fcn的delT类型对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT,delT&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> objT,fcn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(desitination &amp;d)</span></span>&#123;</span><br><span class="line">	connection c=<span class="built_in">connect</span>(&amp;d)；	<span class="comment">//返回一个连接类信息</span></span><br><span class="line">	<span class="comment">//当p被销毁时，连接会关闭</span></span><br><span class="line">	unique_ptr&lt;connection,<span class="keyword">decltype</span>(end_connection)*&gt; <span class="built_in">p</span>(&amp;c,end_connnection);</span><br><span class="line">	<span class="comment">//这样。当f函数退出时，即使是由异常引起的，Connection也会被释放关掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>注：</strong></em><code>decltype</code>是C++11新增的一个关键字，和<code>auto</code>的功能一样，用来在编译时期进行自动类型推导。引入<code>decltype</code>是因为<code>auto</code>并不适用于所有的自动类型推导场景，在某些特殊情况下auto用起来很不方便，甚至压根无法使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> varName=value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varName=value;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>auto</code>根据<code>=</code>右边的初始值推导出变量的类型，<code>decltype</code>根据<code>exp</code>表达式推导出变量的类型，跟&#96;&#96;&#x3D;右边的value没有关系</li>
<li><code>auto</code>要求变量必须初始化，这是因为<code>auto</code>根据变量的初始值来推导变量类型的，如果不初始化，变量的类型也就无法推导</li>
<li>而<code>decltype</code>不要求，因此可以写成如下形式</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varName;</span><br></pre></td></tr></table></figure>

<h6 id="10-5-3-指向数组的unique-ptr"><a href="#10-5-3-指向数组的unique-ptr" class="headerlink" title="10.5.3 指向数组的unique_ptr"></a>10.5.3 指向数组的unique_ptr</h6><p>标准库提供了一个可以管理<code>new</code>分配的数组的<code>unique_ptr</code>版本。使用<code>unique_ptr</code>管理动态数组时，我们必须在对象类型后面跟一对方括号,下面是用法介绍：<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/uniquearry.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">up.<span class="built_in">release</span>();   <span class="comment">//自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>
<p>另外一方面，当一个unique_tr指向一个数组时，我们可以使用下标运算符来访问数组中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</span><br><span class="line">    up[i]=i;  <span class="comment">//为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure>

<h5 id="10-6-weak-ptr"><a href="#10-6-weak-ptr" class="headerlink" title="10.6 weak_ptr"></a>10.6 weak_ptr</h5><p><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针,是弱用智能指针，<strong>它指向一个有<code>shared_ptr</code>管理的对象。将一个<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变<code>share_ptr</code>的引用计数。</strong><br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/weak_ptr.png" width="700"><br>当我们创建一个<code>weak_ptr</code>时，我们要用以<code>shared_ptr</code>初始化它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">43</span>);</span><br><span class="line"><span class="function">weak_ptr <span class="title">wp</span><span class="params">(p)</span></span>;		<span class="comment">//wp若共享p,p的引用计数不变</span></span><br></pre></td></tr></table></figure>
<p>由于对象可能不存在，不能直接使用<code>weak_ptr</code>直接访问对象，必须调用<code>lock(</code>)函数！该函数会检查<code>weak_ptr</code>指向的对象是否存在，若存在，则返回一个指向共享对象的<code>shared_ptr</code>。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; q=wp.<span class="built_in">lock</span>())	</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使用q访问对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-7-allocator类"><a href="#10-7-allocator类" class="headerlink" title="10.7 allocator类"></a>10.7 allocator类</h5><p>在前面我们主要介绍了<code>new,delete和智能指针</code>。但他们分配的内存不是原始的，它们在分配的时候要对内存进行构造。<strong>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</strong><br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/allocator.png" width="700"></p>
<h6 id="10-7-1-allocate：分配未构造内存"><a href="#10-7-1-allocate：分配未构造内存" class="headerlink" title="10.7.1 allocate：分配未构造内存"></a>10.7.1 allocate：分配未构造内存</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;string&gt; allco;	<span class="comment">//定义可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p=alloc.<span class="built_in">allocate</span>(n);	<span class="comment">//分配n个为初始化的string</span></span><br></pre></td></tr></table></figure>
<p><code>alloc</code>完成了分配n个<code>string</code>的连续内存的工作，并且返回一个指向这一块内存的首地址给指针<code>p</code>。我希望p记住这个首地址在哪免得我后边找不到了，所以把它设为<code>const</code>的。</p>
<h6 id="10-7-2-construct：创建对象"><a href="#10-7-2-construct：创建对象" class="headerlink" title="10.7.2 construct：创建对象"></a>10.7.2 construct：创建对象</h6><p>下面我让<code>alloc</code>为我在这些内存上构造对象：<code>alloc.construct(内存地址，参数......)</code>，括号里的“参数”是给我这块内存的对象类型的构造函数的参数，比如这里对于<code>string</code>，可以这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string *S=p;	<span class="comment">//将首地址给S</span></span><br><span class="line">alloc.<span class="built_in">constrcut</span>(S,<span class="number">10</span>,<span class="string">&#x27;A&#x27;</span>);		<span class="comment">//该内存构造string &quot;AAAAAAAAAA&quot;</span></span><br><span class="line">S++;			<span class="comment">//把内存地址往后挪，以便后续的构造</span></span><br></pre></td></tr></table></figure>
<p><em><strong>注意：使用未构造的对象的内存空间是错误</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;*p&lt;&lt;endl;		<span class="comment">//正确，p是指向首地址</span></span><br><span class="line">cout&lt;&lt;*S&lt;&lt;endl;		<span class="comment">//错误，还没构造</span></span><br></pre></td></tr></table></figure>

<h6 id="10-7-3-destroy：摧毁对象"><a href="#10-7-3-destroy：摧毁对象" class="headerlink" title="10.7.3 destroy：摧毁对象"></a>10.7.3 destroy：摧毁对象</h6><p>当我们用完对象后，必须对每个构造的元素调用<code>destory</code>来摧毁它们。我们只能对真正构造了的元素进行<code>destory</code>操作,而且只有摧毁的内存或未构造的内存才能被<code>deallocate</code>回收。<code>destroy</code>参数接受一指针，对指向的对象执行析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q!=p)</span><br><span class="line">alloc.<span class="built_in">destroy</span>(--q);</span><br></pre></td></tr></table></figure>
<p>一旦元素被销毁，我们就可以重新使用这部分内存来保存其他string,也可以将其归还给系统。释放内存通过调用dealloccate来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.<span class="built_in">dealloccate</span>(p,n);	<span class="comment">//p必须是allocate返回的指针，n必须是分配时指定的n</span></span><br></pre></td></tr></table></figure>

<h6 id="10-7-4-拷贝和填充未初始化的内存算法"><a href="#10-7-4-拷贝和填充未初始化的内存算法" class="headerlink" title="10.7.4 拷贝和填充未初始化的内存算法"></a>10.7.4 拷贝和填充未初始化的内存算法</h6><p>allocator还有两个伴随算法，可以在未初始化内存中创建对象。它们都定义在头文件<code>memory</code>中。<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/allocator_algorithm.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配动态内存</span></span><br><span class="line"><span class="keyword">auto</span> p=alloc.<span class="built_in">allocate</span>(v.<span class="built_in">size</span>()*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//拷贝vi的元素到未构造内存,返回下一个未构造地址</span></span><br><span class="line"><span class="keyword">auto</span> q=<span class="built_in">uninitialized_copy</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),p);</span><br><span class="line"><span class="comment">//将剩余空间构造为42</span></span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(q,vi.<span class="built_in">size</span>(),<span class="number">42</span>)</span><br></pre></td></tr></table></figure>

<h4 id="11-拷贝控制"><a href="#11-拷贝控制" class="headerlink" title="11.拷贝控制"></a>11.拷贝控制</h4><p>如何控制类型对象拷贝、赋值、移动和销毁，<strong>有对应的五种特殊成员函数来控制这些操作：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数</strong></p>
<h5 id="11-1-拷贝构造函数"><a href="#11-1-拷贝构造函数" class="headerlink" title="11.1 拷贝构造函数"></a>11.1 拷贝构造函数</h5><h6 id="11-1-1-拷贝构造函数"><a href="#11-1-1-拷贝构造函数" class="headerlink" title="11.1.1 拷贝构造函数"></a>11.1.1 拷贝构造函数</h6><p>个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>&#123;</span><br><span class="line"><span class="built_in">foo</span>();			<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="type">const</span> foo&amp;);	<span class="comment">//拷贝构造函数</span></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一个参数几乎总是<code>const</code>的（虽然可以不为<code>const</code>)，拷贝构造函数在几种情况下都会被隐式的调用，因此拷贝构造函数通常不应该是<code>explicit</code>(<code>explicit</code>修饰的不能拷贝初始化，只能直接初始化，不能隐式转换类类型）。</strong></p>
<h6 id="11-1-2-合成拷贝构造函"><a href="#11-1-2-合成拷贝构造函" class="headerlink" title="11.1.2 合成拷贝构造函"></a>11.1.2 合成拷贝构造函</h6><p>如果我们没有为一个类定义拷贝构造函数，<strong>编译器会为我们定义默认的拷贝构造函数（即使有其他的构造函数）</strong>。但有些类，合成的拷贝构造函数用来阻止我们拷贝该类类型的对象。<strong>但一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中（从给定对象依次将每个非static成员拷贝到正在创建的对象中）。</strong><br><strong>如何拷贝：</strong></p>
<ul>
<li>对类类型（需要include&lt;&gt;的就为类类型)的成员，会使用其拷贝构造函数来拷贝</li>
<li>内置类型的成员则直接拷贝</li>
<li>对数组，合成拷贝构造函数会逐元素拷贝数组类型成员</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...		<span class="comment">//其他构造函数</span></span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;);	<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string Book_NO;</span><br><span class="line">	<span class="type">int</span> units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data &amp;data):<span class="built_in">Book_NO</span>(data.Book_NO),<span class="built_in">units_sold</span>(data.units_sold)</span><br><span class="line">	<span class="built_in">revenue</span>(data.revenue)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="11-1-3-拷贝初始化"><a href="#11-1-3-拷贝初始化" class="headerlink" title="11.1.3 拷贝初始化"></a>11.1.3 拷贝初始化</h6><ul>
<li><strong>使用<code>=</code>进行的初始化是拷贝形式的初始化，编译器将等号右边的初始值拷贝到新创建的对象上去</strong>。这时将调用对象定义的<strong>拷贝构造函数</strong>进行操作，只要这些构造函数满足这样的调用就会被隐式的调用。但是被explicit修饰的拷贝构造函数将会禁止该构造函数进行这样隐式的调用（因为可能由隐式类型转换）。</li>
<li>不使用<code>=</code>进行初始化的操作就是直接初始化,采用<code>()</code>直接进行初始化。这里调用的构造函数就是直接使用对应的<strong>构造函数</strong>进行初始化。explicit修饰的构造函数能用于直接初始化。这种形式没有什么限制。</li>
</ul>
<p><em><strong>总结：</strong></em><br><strong>直接初始化：</strong>根据提供的参数选择最匹配的构造函数<br><strong>拷贝初始化：</strong>右侧运算对象拷贝到正在创建的对象中，通常由拷贝构造函数完成。</p>
<h6 id="11-1-4-拷贝构造函数的参数必须是引用"><a href="#11-1-4-拷贝构造函数的参数必须是引用" class="headerlink" title="11.1.4 拷贝构造函数的参数必须是引用"></a>11.1.4 拷贝构造函数的参数必须是引用</h6><p><strong>因为在函数调用中，非引用类型的的参数要进行拷贝初始化；函数返回一个非引用类型，调用方的返回结果也是一个拷贝，所以拷贝函数此时被用来初始化非引用类型的数据。如果拷贝构造函数的参数不是引用类型都是类型形参，为获得它的实参，那么它自身就会无限的调用自身的死循环。P（442）</strong></p>
<h5 id="11-2-拷贝赋值运算符"><a href="#11-2-拷贝赋值运算符" class="headerlink" title="11.2 拷贝赋值运算符"></a>11.2 拷贝赋值运算符</h5><p>与类控制对象如何初始化一样，类也可以控制对象如何赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data trans,accum;</span><br><span class="line">trans=accum;		<span class="comment">//使用Sales_data的拷贝运算符</span></span><br></pre></td></tr></table></figure>
<p><em><strong>注意区分：拷贝构造函数是在对象创建时拷贝，而赋值拷贝时在对象已经创建后进行赋值，这就是两者的区别</strong></em></p>
<h6 id="11-2-1-重载赋值运算符"><a href="#11-2-1-重载赋值运算符" class="headerlink" title="11.2.1 重载赋值运算符"></a>11.2.1 重载赋值运算符</h6><p>重载运算符的本质是函数。其名由<code>operator</code>关键字接要定义的运算符组成。赋值运算符<code>operator=</code>的函数，其也有返回类型和参数（参数表示要运算的对象），运算符如果是成员函数，则运算对象就绑定在隐式的this指针上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> foo&amp;);	<span class="comment">//赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="11-2-2-合成拷贝赋值运算符"><a href="#11-2-2-合成拷贝赋值运算符" class="headerlink" title="11.2.2 合成拷贝赋值运算符"></a>11.2.2 合成拷贝赋值运算符</h6><p>与拷贝构造函数一样，在没有定义自己的拷贝运算符时，<strong>编译器会生成一个合成拷贝赋值运算符</strong>。同样，对于某些类，合成拷贝赋值运算符会禁止该类型对象的赋值，如果不是此目的，它会赋值（非static)。</p>
<h5 id="11-3-析构函数"><a href="#11-3-析构函数" class="headerlink" title="11.3 析构函数"></a>11.3 析构函数</h5><p>析构函数释放对象使用的资源，并销毁对象的非<code>static</code>数据成员。析构函数时类的成员函数，名字由波浪号<code>~</code>接类名构成，没有返回值，也不接受参数，既不能重载但一般定义未虚函数重写，类只有一个析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">foo</span>();	<span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="11-3-1-定义析构函数"><a href="#11-3-1-定义析构函数" class="headerlink" title="11.3.1 定义析构函数"></a>11.3.1 定义析构函数</h6><p>析构函数同构造函数一样，也由一函数体和一个析构部分。在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。<strong>析构部分是隐式的，销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销魂内置类型成员什么也不需要做（隐式的）。</strong></p>
<ul>
<li>隐式销毁一个内置指针类型的成员不会delete它所指向的对象</li>
<li>智能指针式类类型的，所以具有析构函数，所以智能指针在析构阶段被自动销毁</li>
</ul>
<p><strong>什么时候调用析构函数：无论何时一个对象被销毁，就会自动调用其析构函数</strong>:</p>
<ul>
<li>变量离开作用域时被销毁</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器被销毁时，其元素被销毁</li>
<li>对于动态分配对象，当指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<p>由于析构函数的自动允许，我们程序可以按需要分配资源，无需担心何时释放这些资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">//语句块作用域</span></span><br><span class="line">	Sales_data* p=<span class="keyword">new</span> Sales_data;	<span class="comment">//p是一个普通指针</span></span><br><span class="line">	<span class="keyword">auto</span> p2=<span class="built_in">make_shared</span>&lt;Sales_data&gt;();	<span class="comment">//p2是一个智能指针</span></span><br><span class="line">	<span class="function">Sales_data <span class="title">item</span><span class="params">(*p)</span></span>;			<span class="comment">//使用拷贝构造</span></span><br><span class="line">	vector&lt;Sales_data&gt;vec;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(*p2);</span><br><span class="line">	<span class="keyword">delete</span> p;						<span class="comment">//释放p</span></span><br><span class="line">	<span class="comment">//离开作用域后，p2的计数归0，自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="11-3-2-合成析构函数"><a href="#11-3-2-合成析构函数" class="headerlink" title="11.3.2 合成析构函数"></a>11.3.2 合成析构函数</h6><p><strong>当一个类未定义析构函数时，编译器会为它定义一个合成析构函数。同时同拷贝构造函数、拷贝赋值运算符一样，对于某些类，合成析构函数被用来阻止该类型的对象被销毁</strong>。如果不是这种情况，合成析构函数的函数体就为空。<strong>析构函数体自身不直接销毁成员，而是在析构函数体之后隐含的析构阶段中被销毁</strong></p>
<h5 id="11-4-C-对这些构造函数的法则"><a href="#11-4-C-对这些构造函数的法则" class="headerlink" title="11.4 C++对这些构造函数的法则"></a>11.4 C++对这些构造函数的法则</h5><p>目前为止介绍了三个拷贝控制操作：拷贝构造函数、拷贝赋值运算符、析构函数，知道我们若是不显示定义，编译器会自动合成默认的拷贝构造和赋值构造函数以及析构函数。c++新标准还引入了：一个类还可以定义一个移动构造函数、一个移动赋值运算符。对于它们，编译器有自己的一套法则</p>
<h6 id="11-4-1-三-x2F-五法则"><a href="#11-4-1-三-x2F-五法则" class="headerlink" title="11.4.1 三&#x2F;五法则"></a>11.4.1 三&#x2F;五法则</h6><p>对于这些构造函数，我们有时候不必全部定义，有如下的法则：</p>
<ul>
<li>（1）需要析构函数的了也需要拷贝和赋值操作</li>
<li>（2）如果类需要一个析构函数，那么几乎可以肯定它也需要拷贝构造函数和拷贝赋值运算符</li>
<li>（3）需要拷贝操作的类也需要赋值操作，反之亦然</li>
</ul>
<p>总结：即一般来说类中一般以三\五整体出现</p>
<h6 id="11-4-2-x3D-default：默认合成"><a href="#11-4-2-x3D-default：默认合成" class="headerlink" title="11.4.2 &#x3D;default：默认合成"></a>11.4.2 &#x3D;default：默认合成</h6><p>同默认合成构造函数一样，可以用<code>=default</code>来显示要求合成拷贝构造函数，默认为内联的。<strong>若不要内联，则在类的外部定义为<code>=default</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;)=<span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<h6 id="11-4-3-x3D-delete：阻止拷贝"><a href="#11-4-3-x3D-delete：阻止拷贝" class="headerlink" title="11.4.3 &#x3D;delete：阻止拷贝"></a>11.4.3 &#x3D;delete：阻止拷贝</h6><p>上面我们总是讲到有些拷贝构造、赋值构造和析构会阻止它们的应用功能，这就是用<code>=delete</code>定义的函数。虽然大多数类定义了拷贝构造函数和拷贝赋值运算符，但对于某些类，这些操作没有实际意义，如<code>iostream</code>类阻止了拷贝以避免多个对象写入或读取相同的<code>IO</code>缓冲。所以这种情况就要阻止拷贝的发生。<em><strong>在新标准之前（<code>=delet</code>e前)，类是通过将其拷贝构造函数和拷贝赋值运输符声明为private来阻止拷贝：</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp;);		<span class="comment">//阻止拷贝构造</span></span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;);		<span class="comment">//阻止赋值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新标准下，我们可以将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。<br><strong>删除的函数</strong>：我们声明了它，但不能以任何方式使用它，我们在相应的拷贝构造和拷贝运算符后加<code>=delete</code>即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mm</span>&#123;</span><br><span class="line">	<span class="built_in">mm</span>()=<span class="keyword">default</span>;		<span class="comment">//合成构造函数</span></span><br><span class="line">	<span class="built_in">mm</span>(<span class="type">const</span> mm&amp;)=<span class="keyword">delete</span>;		<span class="comment">//阻止拷贝</span></span><br><span class="line">	mm &amp;<span class="keyword">operator</span>=(<span class="type">const</span> mm &amp;)=<span class="keyword">delete</span>;		<span class="comment">//阻止赋值</span></span><br><span class="line">	~<span class="built_in">mm</span>();				<span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>default</code>不同，:</p>
<ul>
<li><code>delete</code>必须出现在函数第一声明的时候；</li>
<li>还有一点不同的是我们可以对任何函数<code>=delete</code>，而<code>default</code>只能是默认合成构造函数和拷贝控制成员，但一般而言，对于析构函数我们不应该使用<code>=delete</code>(因为这样我们就无法销毁类型对象了）</li>
</ul>
<h6 id="11-4-4-合成的拷贝控制成员可能是删除的"><a href="#11-4-4-合成的拷贝控制成员可能是删除的" class="headerlink" title="11.4.4 合成的拷贝控制成员可能是删除的"></a>11.4.4 合成的拷贝控制成员可能是删除的</h6><p><strong>正如前面所将的，合成的拷贝控制操作可能是阻止类型的：</strong></p>
<ul>
<li>如果类的某个成员的析构函数是删除或不可访问的（如<code>private</code>),则类的合成析构函数被定义为删除的</li>
<li>如果类的某个成员的拷贝构造函数是删除或不可访问的，则类的合成拷贝构造函数被定义为删除。同样，析构函数是删除或不可访问，合成拷贝构造函数被定义为删除</li>
<li><strong>如果类的某个成员的拷贝赋值运算符是删除或不可访问的，或者类有一个<code>const</code>的或者引用的成员，则类的合成拷贝赋值运算符被定义为删除</strong></li>
<li><strong>如果类的某个成员的析构函数是删除或不可访问的、或者类有一个引用成员，它没有类内初始器、或是类内有一个<code>const</code>成员，他没有类内初始器且其类型为显示定义默认构造函数，则该类的默认构造函数被定义为删除的</strong></li>
</ul>
<p><em><strong>即：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数被定义为删除</strong></em></p>
<h5 id="11-5-对象移动"><a href="#11-5-对象移动" class="headerlink" title="11.5 对象移动"></a>11.5 对象移动</h5><p>新标准一个最主要的特征是可以移动而非拷贝对象的能力。使用移动而不是拷贝：</p>
<ul>
<li>①在对象较大时，进行拷贝代价很高。</li>
<li>②对于像IO类和unique_ptr这些类，这些类都包含了不能被共享的资源，因此不能拷贝但可以移动。</li>
</ul>
<p>该特性主要针对这样一种场景：<strong>一个对象在被拷贝之后就不在使用了或者马上就会被析构掉，这种情况下，使用移动操作而非拷贝操作将会大幅度提升性能。移动操作的思想是接管源对象的内容。</strong></p>
<h6 id="11-5-1-右值与左值"><a href="#11-5-1-右值与左值" class="headerlink" title="11.5.1 右值与左值"></a>11.5.1 右值与左值</h6><ul>
<li><strong>左值</strong>：返回左值引用的函数，连同赋值、下标、解引用和前置递增&#x2F;递减运算符，都是返回左值的表达式。</li>
<li><strong>右值</strong>：右值要么是字面常量，要么是在常量表达式求职过程中创建的临时对象。</li>
</ul>
<p>左值持久；右值短暂。</p>
<h6 id="11-5-2-右值引用和左值引用"><a href="#11-5-2-右值引用和左值引用" class="headerlink" title="11.5.2 右值引用和左值引用"></a>11.5.2 右值引用和左值引用</h6><p>为了支持移动，新标准引入了新类型的引用——<strong>右值引用</strong>。<strong>通过&amp;&amp;获得右值引用。右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。因此我们可以将一个右值引用资源“移动”到另一个对象去。</strong>不难知道，不管是左值引用还是右值引用都是变量的一个别名：</p>
<ul>
<li><strong>左值引用</strong>：不能将其绑定到要求转换的公式、字面常量或者是返会右值的表达式，即左值引用是绑定对象（左值）的。</li>
<li><strong>右值引用</strong>：与左值引用恰恰相反，可绑定右值，但不能绑定左值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r=i;		<span class="comment">//正确，左值引用绑定对象（左值）</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr=i;	<span class="comment">//错误，右值引用不能绑定左值</span></span><br><span class="line"><span class="type">int</span> &amp;r2=i*<span class="number">42</span>;	<span class="comment">//错误，左值引用不能绑定右值</span></span><br><span class="line"><span class="comment">//可以将一个const的左值引用或者一个右值引用绑定到这类表达式上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3=i*<span class="number">42</span>;	<span class="comment">//正确，可以将const的引用绑定到右值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;r3=i*<span class="number">42</span>;	<span class="comment">//正确</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于右值引用只能绑定到临时对象，我们可以知道：<strong>①所引用的对象将要被销毁，②该对象没有其他用户。这两个特性意味着使用右值引用的代码可以自由地接管所引用的对象的资源。</strong></p>
<p><strong>记住变量是左值，我们不能将右值引用绑定到变量上，即使这个变量本身是右值引用也不行！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  &amp;&amp;r1=<span class="number">42</span>;		<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;r2=r1;		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<h6 id="11-5-3-move函数"><a href="#11-5-3-move函数" class="headerlink" title="11.5.3 move函数"></a>11.5.3 move函数</h6><p>新标准提供了一个函数解决右值引用无法绑定左值的函数，通过调用新标准库函数move来获得绑定到左值的右值引用。该函数定义在头文件<code>utility</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;r2=std::<span class="built_in">move</span>(r1);		<span class="comment">//可行</span></span><br></pre></td></tr></table></figure>
<p>调用<code>move</code>之后，我们可以销毁一个移后员对象，也可以赋予它新值，但不能使用一个移后源对象的值。<br>有了这些知识我们就能看接下来的<strong>移动拷贝构造函数和移动赋值运算符</strong>。类似string类，自定义的类支持移动和拷贝，会十分方便。它们从指定对象“窃取”资源，而不是拷贝资源。</p>
<h6 id="11-5-4-移动拷贝构造函数"><a href="#11-5-4-移动拷贝构造函数" class="headerlink" title="11.5.4 移动拷贝构造函数"></a>11.5.4 移动拷贝构造函数</h6><p>类似于拷贝构造函数，<strong>第一个参数是该类类型的右值引用</strong>，其他额外参数必须有默认值。<strong>移动构造函数需要确保移后源对象处于这样一个状态：销毁它是无害的。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> <span class="comment">//移动操作不应抛出任何异常</span></span><br><span class="line">    <span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">    :<span class="built_in">elements</span>(s.elements), <span class="built_in">first_free</span>(s.first_free), <span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//另s进入这样一个状态——对其运行析构函数是安全的</span></span><br><span class="line">    s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面这个程序不分配任何内存，只是接管了s的内存，接管之后，将给定对象的指针都设为<code>nullptr</code>,这样就完成了移动操作</strong>。此源对象继续存在（但已经没有管理任何内存），当允许其析构函数时，源对象被销毁。<strong>注意：不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</strong></p>
<blockquote>
<p><strong>为什么要声明<code>noexcept</code></strong><br>虽然移动操作通常不会异常抛出，但抛出异常时允许的。而且标准库容器能对异常发生时其自身的行为提供保障。&gt;<code>noexcept</code>它告诉编译器该函数不会抛出异常，否则编译器会认为移动操作可能会发生异常，并且为了处理这种可&gt;能性做一些额外的工作。</p>
</blockquote>
<h6 id="11-5-5-移动赋值运算符"><a href="#11-5-5-移动赋值运算符" class="headerlink" title="11.5.5 移动赋值运算符"></a>11.5.5 移动赋值运算符</h6><p>移动赋值运算符指向析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为<code>noexcept</code>。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(); <span class="comment">//释放已有元素</span></span><br><span class="line">        elements = rhs.elements;</span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="11-5-6-移动操作的要求"><a href="#11-5-6-移动操作的要求" class="headerlink" title="11.5.6 移动操作的要求"></a>11.5.6 移动操作的要求</h6><ul>
<li><strong>移动源对象必须可析构</strong>：当我们编写一个移动操作，必须保证移动源进入一个可析构状态，如上面的例子中，我们将移动源数据置为<code>nullptr</code>。其次，还应保证，对象移动后还是有效的，既可以重新赋值。</li>
<li><strong>合成的移动操作</strong>：<strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时（指针型），编译器才会为它合成移动构造函数或移动赋值运算符。</strong></li>
<li><strong>移动右值，拷贝左值</strong>：在一个类中，既定义了移动又定义了拷贝，编译器使用匹配规则进行匹配。在定义了拷贝但没有定义移动，右值也使用拷贝构造函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器会为X和hasX合成移动操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">//内置类型可以移动</span></span><br><span class="line">    std::string s; <span class="comment">//string 定义了自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasX</span>&#123;</span><br><span class="line">    X mem;  <span class="comment">//X有合成的移动操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X x, x2 = std::<span class="built_in">move</span>(x);        <span class="comment">//使用合成的移动构造函数</span></span><br><span class="line">hasX hx, hx2 = std::<span class="built_in">move</span>(hx);  <span class="comment">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>移动操作永远不会隐式定义为删除的函数。如果我们显示地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。移动构造函数被定义为删除的函数的条件是：</p>
<ul>
<li>有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者有类成员未定义自己的拷贝构造函数且编译器不能为其合成构造函数。移动赋值运算符的情况类似。</li>
<li>如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。</li>
<li>如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。</li>
<li>如果有类成员是<code>const</code>或是引用，则类的移动赋值运算符被定义为删除的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假定Y是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasY</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">hasY</span>() = defualt;</span><br><span class="line">    <span class="built_in">hasY</span>(hasY&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Y mem;  <span class="comment">//hasY将有一个删除的移动构造函数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hasY hy, hy2 = std::move(hy); //错误，移动构造函数是删除的</span></span><br></pre></td></tr></table></figure>

<p><strong>如果类定义了一个移动构造拷贝和&#x2F;或一个移动赋值运算符，该类的合成拷贝构造函数和拷贝赋值运算符将会被定义为删除的</strong>。因此定义了一个移动构造函数或者移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员都被默认为删除的。（三&#x2F;五法则）</p>
<h6 id="11-5-7-移动迭代器"><a href="#11-5-7-移动迭代器" class="headerlink" title="11.5.7 移动迭代器"></a>11.5.7 移动迭代器</h6><p>新标准库定义了一种<strong>移动迭代器适配器</strong>。<strong>移动迭代器的解引用生成一个右值引用</strong>（其他的迭代器一般时指向元素的左值）。<br>通过调用标准库函数的<code>make_move_iterator</code>函数将以普通迭代器转换为移动迭代器。移动迭代器支持正常迭代器的工作。<strong>但值得注意的是只有在确定算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，能可以使用移动迭代器。否则使用移动迭代器销毁了原来数据，还想使用是错误的行为。</strong></p>
<h5 id="11-6-实际运用"><a href="#11-6-实际运用" class="headerlink" title="11.6 实际运用"></a>11.6 实际运用</h5><p>在我们已经运用的类中，如**<code>string</code>、标准库容器它们的对象行为像一个值，即我们拷贝这些类的对象是，副本和原对象是独立的，互不影响<strong>。<br>但像<code>shared_ptr</code>类，</strong>这些智能指针的对象的行为像一个指针，副本和原对象使用相同的底层数据，即数据共享，它们之间会互相影响。**</p>
<h6 id="11-6-1-行为像值的类"><a href="#11-6-1-行为像值的类" class="headerlink" title="11.6.1 行为像值的类"></a>11.6.1 行为像值的类</h6><p>这种行为的类，它们得对象都有着自己的一份数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span>  string&amp; s=<span class="built_in">string</span>())</span><br><span class="line">		:<span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)),<span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;		<span class="comment">//ps指向自己分配的空间,构造函数</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">		:<span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p.ps)),<span class="built_in">i</span>(p.i)&#123;&#125;		<span class="comment">//拷贝构造函数</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;);		<span class="comment">//赋值运算符</span></span><br><span class="line">	~<span class="built_in">HasPtr</span>()&#123;<span class="keyword">delete</span> ps;&#125;					<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string *ps;</span><br><span class="line">	<span class="type">int</span> i；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这个类除了拷贝赋值运算符外，其他的成员函数都定义了。**构造函数和拷贝构造函数都动态分配它们自己的<code>string</code>,以及分配自己栈内存给整型<code>i</code>**；赋值运算符通常组合了析构函数和构造函数的操作，我们编写的赋值运算符还应该是异常安全的–当异常发生时，仍能将左侧运算对象置于一个有意义的状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p)&#123;</span><br><span class="line">	<span class="keyword">auto</span> newp=<span class="keyword">new</span> <span class="built_in">string</span>(*p.ps);</span><br><span class="line">	<span class="keyword">delete</span> ps;</span><br><span class="line">	ps=newp;</span><br><span class="line">	i=p.i;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete这个对象原来的指向的<code>string</code>，再将<code>newp</code>的管理权给它。在编写赋值运算符时，需要注意：</p>
<ul>
<li>如果将一个对象赋予它自身，赋值运算符必须能正确工作</li>
<li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作</li>
</ul>
<p>一个好的赋值运算符，往往会借助一个局部零时对象拷贝，如上的<code>newp</code>。（就如在上面的程序中，如果p和this是同一个对象，如果不借助中间<code>newp</code>而直接<code>delete ps</code>将会发生错误）。你也可以增加判断语句<code>if(this!=p)</code>避免增加一个零时量</p>
<h6 id="11-6-2-行为像指针的类"><a href="#11-6-2-行为像指针的类" class="headerlink" title="11.6.2 行为像指针的类"></a>11.6.2 行为像指针的类</h6><p>令一个类展现类似指针行为的最好方法是<code>shared_ptr</code>来管理类中的资源，拷贝一个<code>shared_ptr</code>会拷贝（赋值）所指向的指针，共享数据，只要当s<code>hare_ptr</code>引用计数为0时才会释放资源。<br><strong>另一个方法是不用<code>shared_ptr</code>，而是设计自己的引用计数，这种情况下，我们可以自己直接管理资源</strong><br><strong>引用计数：</strong></p>
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还有创建一个引用计数，用来记录多少对象与正在创建的对象共享数据状态。</li>
<li>拷贝构造函数不分配计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户共享</li>
<li>析构函数递减计数器，指出gong共享状态的用户少了一个。若为0，则释放</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧。若左侧为0，则销毁释放。</li>
</ul>
<p>怎么存放计数器：将计数器保存在动态内存中，当创建一个对象时，我们分配一个计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;, HasPtr&amp;)</span></span>;	<span class="comment">//交换操作</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span>  string&amp; s=<span class="built_in">string</span>())</span><br><span class="line">		:<span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)),<span class="built_in">i</span>(<span class="number">0</span>),<span class="built_in">use</span>(<span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>))&#123;&#125;		<span class="comment">//构造函数,计数器为1</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">		:<span class="built_in">ps</span>(p.ps),<span class="built_in">i</span>(p.i),<span class="built_in">use</span>(p.use)&#123;*use++&#125;		<span class="comment">//拷贝构造函数,共享ps,use</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;);			<span class="comment">//赋值运算符</span></span><br><span class="line">	~<span class="built_in">HasPtr</span>()；					<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string *ps;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> *use;							<span class="comment">//引用计数器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数定义：</span></span><br><span class="line">HasPtr::~<span class="built_in">HasPtr</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span>(--*use==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">delete</span> ps;			<span class="comment">//计数为0时，释放</span></span><br><span class="line">		<span class="keyword">delete</span> use;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符定义：</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;p)&#123;</span><br><span class="line">	++*p.use;		<span class="comment">//递增右侧计数器</span></span><br><span class="line">	<span class="keyword">if</span>(--*use==<span class="number">0</span>)&#123;		<span class="comment">//递减左侧计数器，并判断</span></span><br><span class="line">		delele ps;</span><br><span class="line">		<span class="keyword">delete</span> use;</span><br><span class="line">	&#125;</span><br><span class="line">	ps=p.ps;			<span class="comment">//共享该堆内数据</span></span><br><span class="line">	i=p.i;</span><br><span class="line">	use=p.use;		<span class="comment">//共享计数器</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;		<span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换操作</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp; p1,HasPtr &amp;p2)</span></span>&#123;		<span class="comment">//定义该类自己的swap</span></span><br><span class="line">	<span class="keyword">using</span> std::swap;</span><br><span class="line">	<span class="built_in">swap</span>(p1.ps,p2,ps);		<span class="comment">//交换指针</span></span><br><span class="line">	<span class="built_in">swap</span>(p1.i,p2.i);			<span class="comment">//交换int成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="12-重载运算与类型转换"><a href="#12-重载运算与类型转换" class="headerlink" title="12.重载运算与类型转换"></a>12.重载运算与类型转换</h4><p>当运算符被用于类类型对象时，c++语言允许我们为其指定新的含义，同时我们也能自定义类类型转换规则。<strong>重载运算符：</strong><br><strong>它的名字由<code>operator</code>和其后要定义的运算符共同组成，它们的参数数量应该与运算符作用的运算对象数量一样多</strong>。<br><strong>调用时左侧元素对象传递给第一个参数（若为成员函数则传给隐式this指针），右侧运算对象传递给之后的参数。重载不改变运算符原有的优先级</strong><br>不能重载运算对象全为内置类型的运算符，既一定要包含至少一个类类型参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span>,<span class="type">int</span>);		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/operator.png" width="700">

<h5 id="12-1-输入和输出运算符"><a href="#12-1-输入和输出运算符" class="headerlink" title="12.1 输入和输出运算符"></a>12.1 输入和输出运算符</h5><p>类需要定义适合其对象的新版本以支持IO操作，方便！</p>
<h6 id="12-1-1-重载输出运算符-lt-lt"><a href="#12-1-1-重载输出运算符-lt-lt" class="headerlink" title="12.1.1 重载输出运算符&lt;&lt;"></a>12.1.1 重载输出运算符&lt;&lt;</h6><p>通常情况下第一个形参是<strong>非常量对象<code>ostream</code>的引用</strong>，之所以是<strong>非常量</strong>是因为向流写入对象会改变其状态，第二个参数(要IO操作的)是常量的引用.返回ostream对象。</p>
<ol>
<li>输出运算不要考虑格式化操作，尤其不会打印换行符，应当主要负责打印对象的内容。</li>
<li>与<code>iostream</code>兼容的<strong>输入输出运算符必须是普通的非成员函数</strong>，而不能是类的成员函数，否则左侧的运算对象是我们类的一个对象。因此如果想为自定义类重载IO运算符就要定义成非成员函数，但是为了读取私有数据成员，常声明为友元</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> Sales_data &amp;item)&#123;		<span class="comment">//非成员函数</span></span><br><span class="line">	os&lt;&lt;item.<span class="built_in">isbn</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.units_sold&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">	&lt;&lt;item.revenue&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line">Sales_data data;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(cout,data);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">cout&lt;&lt;data;</span><br></pre></td></tr></table></figure>
<h6 id="12-1-2-重载输入运算符-gt-gt"><a href="#12-1-2-重载输入运算符-gt-gt" class="headerlink" title="12.1.2 重载输入运算符&gt;&gt;"></a>12.1.2 重载输入运算符&gt;&gt;</h6><p>输入运算符的第一个形参是将要读取的流的引用，第二个形参是将要读取到的对象的引用，返回流的引用.输入运算符负担从流中读取数据到对象的工作，需要注意的是，应当处理输入可能失败的状态:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(ostream&amp; is, Sales_data &amp;item)&#123;		<span class="comment">//非成员函数</span></span><br><span class="line">	<span class="type">double</span> price;			<span class="comment">//临时变量</span></span><br><span class="line">	is&gt;&gt;item.units_sold&gt;&gt;item.bookNo&gt;&gt;price;	<span class="comment">//读取</span></span><br><span class="line">	<span class="keyword">if</span>(is)		<span class="comment">//检查输入是否成功</span></span><br><span class="line">		item.revenue=item.unit_sold*price;</span><br><span class="line">	<span class="keyword">else</span>			<span class="comment">//失败，则置为默认状态</span></span><br><span class="line">		item=<span class="built_in">Sales_data</span>();</span><br><span class="line">	retuen is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-2-算术和关系运算符"><a href="#12-2-算术和关系运算符" class="headerlink" title="12.2 算术和关系运算符"></a>12.2 算术和关系运算符</h5><p>我<strong>们把算术和关系运算符定义为非成员函数来允许对左侧或右侧的运算对象进行转换，因为不需要改变运算对象的状态，形参都是常量的引用。</strong><br>算术运算符计算它的两个对象并得到一个新值，有区别于任意一个运算对象，位于一个局部变量内，操作完成后返回该局部变量的副本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data&amp;,rhs)&#123;</span><br><span class="line">	Sales_data sum=lhs;</span><br><span class="line">	sum+=rhs;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="12-2-1-相等运算符"><a href="#12-2-1-相等运算符" class="headerlink" title="12.2.1 相等运算符"></a>12.2.1 相等运算符</h6><p>C++中的相等运算符应当比较每一个数据成员，当对应的成员都相等时才认为两个对象相等，所以我们的相等运算符不但应当比较<code>bookNo</code>，还应当比较具体的销售数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data&amp; rhs)&#123;</span><br><span class="line">	<span class="keyword">return</span>	lhs.<span class="built_in">isbn</span>()==rhs.<span class="built_in">isbn</span>()&amp;&amp;lhs.<span class="built_in">units_sold</span>()==rhs.<span class="built_in">units_sold</span>()</span><br><span class="line">	&amp;&amp;lhs.<span class="built_in">revenue</span>()==rhs.<span class="built_in">revenue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data&amp; rhs)&#123;</span><br><span class="line">	<span class="keyword">return</span> !lhs==rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>显然如果一个类有判断两个对象是否相等的操作，我们应当重载运算符而不是新增函数，更容易使用</li>
<li>定义了<code>operator==</code>应当能判断一组给定的对象中是否有重复数据</li>
<li>相等运算符应当具有传递性，既<code>a==b、b==c</code>为真,那么<code>a==c</code>也该为真</li>
<li>定义了<code>operator==</code>则应该定义<code>operator!=</code>并且可以利用已经重载的运算符来实现另一个运算符（如上例）</li>
</ul>
<h6 id="12-2-2-关系运算符"><a href="#12-2-2-关系运算符" class="headerlink" title="12.2.2 关系运算符"></a>12.2.2 关系运算符</h6><ul>
<li><p>关系运算符应当定义顺序关系，令其与关联容器中对关键字的要求一致 , 如果类同时含有&#x3D;&#x3D;运算符的话，应当定义关系与其保持一致，如果两个对象是<code>!=</code>的，那么一个对象应当<code>&lt;</code>另外一个</p>
</li>
<li><p>需要指出的是，<code>Sales_data</code>是不存在逻辑可靠的<code>&lt;</code>定义的，首先，我们不能只比较<code>ISBN</code>，如果<code>ISBN</code>相同但<code>revenue</code>和<code>units_sold</code>是不相等的，但一个对象<code>units_sold</code>大，一个<code>revenue</code>大，所以一个对象并不比另一个小（任意对象不比另一个小，按道理讲这两个对象是相等的），但对象其实又不是相等的，所以逻辑会出现问题。所以像这种类不定义<code>&lt;</code>比较好</p>
</li>
</ul>
<h5 id="12-3-赋值运算符"><a href="#12-3-赋值运算符" class="headerlink" title="12.3 赋值运算符"></a>12.3 赋值运算符</h5><p>将类的一个对象赋值给另一个对象，类也可以定义其他赋值运算符来使用a值运算符：它可以使用别的类型作为右值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrVec&amp; <span class="keyword">operator</span>=(Strvec&amp; li)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;li)&#123;</span><br><span class="line">			<span class="keyword">this</span>.elements=li.elements;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	StrVec&amp; <span class="keyword">operator</span>+=(Strvec&amp; li)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;li)&#123;</span><br><span class="line">			<span class="keyword">this</span>.elements+=li.elements;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="12-4-下标运算符"><a href="#12-4-下标运算符" class="headerlink" title="12.4 下标运算符"></a>12.4 下标运算符</h5><p>下标运算符必须是<strong>成员函数，通常以所访问的元素的引用作为返回值</strong>，进一步，最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，返回常量引用来确保不会对返回的对象赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index)&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.<span class="built_in">size</span>()&lt;index<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;index is out of range&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> elements[index];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.<span class="built_in">size</span>()&lt;index<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;index is out of range&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> elements[index];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="12-5-递增和递减运算符"><a href="#12-5-递增和递减运算符" class="headerlink" title="12.5 递增和递减运算符"></a>12.5 递增和递减运算符</h5><p>在迭代器类中通常会实现递增运算符<code>++</code>和递减运算符<code>--</code>，着两种运算符使得类可以在元素序列中前后移动，建议将其设为成员函数。其有前置和后置版本:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	A&amp; <span class="keyword">operator</span>++();</span><br><span class="line">	A&amp; <span class="keyword">operator</span>--();</span><br><span class="line">	A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>);		<span class="comment">//后置版本</span></span><br><span class="line">	A&amp; <span class="keyword">operator</span>--(<span class="type">int</span>);		<span class="comment">//后置版本</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">	++num;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	--num;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前置后置运算符使用同一个符号，意味着其重载版本所用的名字是相同的，并且运算对象的数量和类型也相同，为了解决这个问题，后置版本接受一个额外的int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是参加运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	A* ret=<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> *ret;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	A* ret=<span class="keyword">this</span>;</span><br><span class="line">	--*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> *ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="12-6-成员访问运算符"><a href="#12-6-成员访问运算符" class="headerlink" title="12.6 成员访问运算符"></a>12.6 成员访问运算符</h5><p>在迭代器类和智能指针类中，常常会用到解引用运算符<code>*</code>和箭头运算符。类成员访问运算符<code>*</code>和<code>-&gt;</code>可以被重载，但它较为麻烦。<strong>它被定义用于为一个类赋予”指针”行为。运算符<code> -&gt;</code> 必须是一个成员函数。如果使用了<code> -&gt;</code> 运算符，返回类型必须是指针或者是类的对象。</strong></p>
<p>运算符 -&gt; 通常与指针引用运算符 * 结合使用，用于实现”智能指针”的功能。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁时，或者当指针指向另一个对象时，会自动删除对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(vector&lt;<span class="type">int</span>&gt; vec) :<span class="built_in">vec</span>(vec) &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span>*() &#123;	<span class="comment">//返回类型</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;vec[current++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> current=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;* ve = &amp;vec;</span><br><span class="line">	<span class="function">B <span class="title">m</span><span class="params">(vec)</span></span>;</span><br><span class="line">	*m;</span><br><span class="line">	B* x = &amp;m;</span><br><span class="line">	x-&gt;<span class="keyword">operator</span>-&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运算符<code>-&gt;</code>的重载比较特别，它只能是非静态的成员函数形式，而且没有参数。如果返回值是一个原始指针，那么就将运算符的右操作数当作这个原始指针所指向类型的成员进返回；如果返回值是另一个类型的实例，那么就继续调用这个返回类型的 <code>operator-&gt;()</code> ，直到有一个调用返回一个原始指针为止，然后按第一种情况处理。</p>
</blockquote>
<p>既然<code>-&gt;</code> 的重载可以返回一个类型的实例而非指针，那如果返回本身的类型呢，它会继续调用自己的<code>operator-&gt;()</code>，永无止尽</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Joke</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Joke&amp; <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Joke j;</span><br><span class="line">    std::cout &lt;&lt; j-&gt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 j-&gt;i 会导致自身的 operator-&gt;() 被无限调用。但编译器不是傻子，在使用GCC 4.8.2编译的时候，直接报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: circular pointer delegation detected</span><br></pre></td></tr></table></figure>
<h5 id="12-7-函数调用运算符"><a href="#12-7-函数调用运算符" class="headerlink" title="12.7 函数调用运算符"></a>12.7 函数调用运算符</h5><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类得对象成员函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">absInt</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value&lt;<span class="number">0</span>?-value:value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line">absInt  abs;</span><br><span class="line"><span class="type">int</span> ui=<span class="built_in">abs</span>(<span class="number">-40</span>);		<span class="comment">//对类对象像调用函数一样调用</span></span><br></pre></td></tr></table></figure>


<h5 id="12-8-类型转换运算符"><a href="#12-8-类型转换运算符" class="headerlink" title="12.8 类型转换运算符"></a>12.8 类型转换运算符</h5><p>在讲类的时候，<strong>提到单个参数的构造函数定义了一种隐式类型转换</strong>。这里，我们通过类型转换运算符和转换构造函数共同定义类类型转换，也被称为用户定义的类型转换</p>
<h6 id="12-8-1-类型转换运算符"><a href="#12-8-1-类型转换运算符" class="headerlink" title="12.8.1 类型转换运算符"></a>12.8.1 类型转换运算符</h6><p><strong>是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型</strong>。<code>operator type()const</code>该运算符没有显式的返回类型，形参，必须定义成类的成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SmallInt</span>(<span class="type">const</span> <span class="type">int</span>&amp; i = <span class="number">0</span>) :<span class="built_in">val</span>(i) &#123;	<span class="comment">//转换构造函数</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i&gt;<span class="number">255</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Bad_int_value&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">aadd</span><span class="params">(<span class="type">const</span> SmallInt&amp; s)</span> </span>&#123; <span class="keyword">return</span> val + s.<span class="built_in">get</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;		<span class="comment">//类型转换运算符</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义了内置类型向类型的转换(转换构造函数），也定义了类类型向内置类型的转换(类型转换运算符）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SmallInt si;		<span class="comment">//构造函数 si=0,si为Smallint对象</span></span><br><span class="line">	si = <span class="number">4</span>;				<span class="comment">//合成默认赋值运算符 si=4，si为Smallint对象</span></span><br><span class="line">	<span class="type">int</span> i=si+<span class="number">3</span>;			<span class="comment">//调用类型转换运算符，si转换为int</span></span><br><span class="line">	si.<span class="built_in">aadd</span>(i);			<span class="comment">//会调用单参const构造函数构造零时对象，后在调用aadd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型转换运算符可能有意外结果，因为如果类型转换自动发生，用户可能感觉意外。我们经常会定义向bool的转换，但是类类型的对象转换为bool后就能被用在任何需要算术类型的地方<code>int i=42; cin&lt;&lt;i;</code>会造成cin转换为bool类型，然后左移位i个位置。为防止这样的情况发生，C++11&#x3D;-引入了显式类型转换运算符:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;		<span class="comment">//类型转换运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示调用</span></span><br><span class="line"><span class="type">int</span> i=si.<span class="keyword">operator</span> <span class="built_in">int</span>() + <span class="number">3</span>;			<span class="comment">//si转换为int</span></span><br></pre></td></tr></table></figure>
<p>这种情况下当显式地请求转换，才会执行类类型到内置类型的转换。但是如果表达式被用作条件，编译器将会执行显式的类型转换。<strong>即如果表达式出现在：<code>if while do的条件部分，for语句头的条件表达式，逻辑与或非</code>，显式类型转换将会被隐式执行</strong>。</p>
<h6 id="12-8-2-避免二义性的类型转换"><a href="#12-8-2-避免二义性的类型转换" class="headerlink" title="12.8.2 避免二义性的类型转换"></a>12.8.2 避免二义性的类型转换</h6><p>需要确保在类类型和目标类型之间只存在唯一一种转换方式，否则代码会有二义性。</p>
<ul>
<li>比如两个类提供了相同的类型转换方式，或者一个类定义了多个转换运算符。存在二义性，就必须显式地调用类型转换运算符或者转换构造函数。</li>
<li>如果定义了多个参数都为算术类型的构造函数和对应类型转换运算符，有可能会产生二义性，原因是在隐式类型转换时，标准类型转换级别一致，这决定了编译器选择最佳匹配的过程。如果转换级别有一个更高，则不会出现二义性错误</li>
</ul>
<h4 id="13-函数对象"><a href="#13-函数对象" class="headerlink" title="13. 函数对象"></a>13. 函数对象</h4><h5 id="13-1-lambda是函数对象"><a href="#13-1-lambda是函数对象" class="headerlink" title="13.1 lambda是函数对象"></a>13.1 lambda是函数对象</h5><p>我们编写一个<code>lambda</code>后，编译器将表达式翻译成一个未命名类的未命名对象，这个类中有一个重载的函数调用运算符。如下面这个<code>lambda</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">const</span> string&amp;a,<span class="type">const</span> string&amp;b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();&#125;);</span><br></pre></td></tr></table></figure>
<p>相似于下面类对象：由于默认情况下<code>lambda</code>不能改变它捕获的变量，因此在默认情况下<code>lambda</code>生成的类当中的函数调用运算符是<code>const</code>成员函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shorter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp;a,<span class="type">const</span> string&amp;b)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="13-2-生成类对于lambda的值捕获与引用捕获的不同"><a href="#13-2-生成类对于lambda的值捕获与引用捕获的不同" class="headerlink" title="13.2 生成类对于lambda的值捕获与引用捕获的不同"></a>13.2 生成类对于lambda的值捕获与引用捕获的不同</h5><p><strong>当<code>lambda</code>表达式通过</strong>引用捕获变量时<strong>，程序确保<code>lambda</code>执行引用时所引用的对象确实存在，编译器可以直接使用该引用而无需再<code>lambda</code>产生的类中将其存储。但是通过值捕获时，在<code>lambda</code>生成的类中需要为值捕获的变量生成数据成员，创建构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> w=<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[sz](<span class="type">const</span> string&amp;a,)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;&#125;);</span><br></pre></td></tr></table></figure>
<p>该<code>lambda</code>值捕获<code>sz</code>，则其产生的类将形如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sizecmp</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Sziecamp</span>(<span class="type">size_t</span> n):<span class="built_in">sz</span>(n)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp;a)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">size_t</span> sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>标准库定义了一组表示算术、关系、逻辑运算符的类，都被定义成模板的形式，可以为其指定具体的应用类型即调用运算符的形参类型。</p>
<h5 id="13-3-标准库定义的函数对象"><a href="#13-3-标准库定义的函数对象" class="headerlink" title="13.3 标准库定义的函数对象"></a>13.3 标准库定义的函数对象</h5><p>标准库定义了一组表示算术、关系、逻辑运算符的类，都被定义成模板的形式，可以为其指定具体的应用类型即调用运算符的形参类型。<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/func.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="type">int</span>&gt; intadd;</span><br><span class="line"><span class="type">int</span> sum=<span class="built_in">intadd</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>表示运算符的函数对象类常用来替换算法中的默认运算符，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用greater代替默认的，此时执行降序排序</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),greater&lt;string&gt;);</span><br></pre></td></tr></table></figure>
<p>第三个实参是<code>greater&lt;string&gt;</code>类型的一个未命名的对象，需要注意的是，标准库定义的函数对象也适用于指针，但不能用大于小于号而是用<code>less</code>函数对象</p>
<h5 id="13-4-可调用对象与function"><a href="#13-4-可调用对象与function" class="headerlink" title="13.4 可调用对象与function"></a>13.4 可调用对象与function</h5><p><strong><code>function</code>函数是一直通用、多态的函数封装，它的实例可以对任何可以调用的目标进行存储、赋值和调用操作。是C++现有的对可以调用实体的一种安全的包裹，简而言之，<code>function</code>就是可调用对象的容器。</strong><br>进一步讲，<code>function</code>模板类就是为了解决<code>lambda</code>表达式的存入问题，因为每个<code>lambda</code>有它自己的类型，该类型会与<code>map</code>中的定好的值的类型不匹配，步骤：</p>
<ul>
<li><strong>C++的可调用对象有：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类</strong>，其实可调用对象也有类型，每个<code>lambda</code>有它自己唯一的类类型，函数及函数指针的类型由其返回值和实参类型决定</li>
<li><strong>不同类型的可调用对象可能共享同一种调用形式</strong>，指明了返回类型和传递给调用的实参类型。例如普通函数加、<code>lambda</code>表达式减和函数对象类除法的调用方法都为:<code>mod(a,b)</code>为了利用这些可调用对象，可以定义一个函数表来存储指向这些可调用对象的指针。</li>
<li>用运算符符号的<code>string</code>对象作为关键字，<strong>用实现运算符的函数作为值构建运算符到函数指针的映射</strong><code>map&lt;string, function&lt;int(*)(int,int)&gt;&gt; binops;</code></li>
<li>再利用<code>function&lt;T&gt; f</code>来创建可放入容器中的类型，无论函数指针，<code>lambda</code>表达式，函数对象、类的对象都可保存，<strong>但也不能把重载函数的名字直接存入<code>map</code>中，而是要利用函数指针或者<code>lambda</code>表达式</strong>；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line">map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; bin;</span><br><span class="line"><span class="built_in">int</span> (*fp)(<span class="type">int</span>,<span class="type">int</span>)=add;</span><br><span class="line">bin.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,fp&#125;);</span><br></pre></td></tr></table></figure>

<img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/funcoperate.png" width="700">


<h4 id="14-容器概述"><a href="#14-容器概述" class="headerlink" title="14.容器概述"></a>14.容器概述</h4><h5 id="14-1-STL提供了六大组件"><a href="#14-1-STL提供了六大组件" class="headerlink" title="14.1 STL提供了六大组件"></a>14.1 STL提供了六大组件</h5><ul>
<li>容器：各种数据结构,如<code>vector、list、deque、set、map</code>等,用来存放数据</li>
<li>算法：各种常用的算法（冒泡，排序）,如<code>sort、find、copy、for_each</code></li>
<li>迭代器：扮演了容器与算法之间的胶合剂（类似于指针等）</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理。注意一般都伴随着重新分配空间，那么原来的迭代器就会失效</li>
</ul>
<p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p>
<h5 id="14-2-三大重点组件"><a href="#14-2-三大重点组件" class="headerlink" title="14.2 三大重点组件"></a>14.2 三大重点组件</h5><p>容器有<strong>序列式容器</strong>和<strong>关联式容器</strong>：</p>
<ul>
<li>序列式容器：序列式容器就是容器元素在容器中的位置是由元素进入容器的时间和地点来决定</li>
<li>关联式容器：关联式容器是指容器已经有了一定的规则，容器元素在容器中的位置由容器的规则来决定</li>
</ul>
<p>算法分为<strong>质变算法</strong>和<strong>非质变算法</strong>：</p>
<ul>
<li>质变算法：：是指运算过程中会更改区间内的元素的内容</li>
<li>非质变算法：是指运算过程中不会更改区间内的元素内容</li>
</ul>
<p><strong>迭代器</strong></p>
<ul>
<li><strong>输入迭代器</strong>：提供对数据的只读访问 只读，支持<code>++、==、！=</code></li>
<li><strong>输出迭代器</strong>：提供对数据的只写访问 只写，支持<code>++</code></li>
<li><strong>前向迭代器</strong>：提供读写操作，并能向前推进迭代器 读写，支持<code>++、==、！=</code></li>
<li><strong>双向迭代器</strong>：提供读写操作，并能向前和向后操作 读写，支持<code>++、--，</code></li>
<li><strong>随机访问迭代器</strong>：提供读写操作，并能在数据中随机移动 读写，支持<code>++、--、[n]、+n、-n、&lt;、&lt;=、&gt;、&gt;=</code></li>
</ul>
<p><strong>重点学习双向迭代器和随机访问迭代器</strong></p>
<ul>
<li>双向迭代器：++,–可以访问下一个元素和上一个元素(list、forward_list、关联容器set&#x2F;map）</li>
<li>随机访问迭代器：+2，可以跳2个元素访问元素、下标访问（vector、deque、string、array)</li>
</ul>
<p>三大组件的关系：容器存储数据，并且提供迭代器，算法使用迭代器来操作容器中的元素</p>
<h5 id="14-3-STL优点"><a href="#14-3-STL优点" class="headerlink" title="14.3 STL优点"></a>14.3 STL优点</h5><ul>
<li>STL是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li>
<li><strong>STL的一个重要特点是数据结构和算法的分离</strong>。尽管这是个简单的概念，但是这种分离使得 STL 变得非常通用。例如:在 STL 的<code>vector</code>容器中，可以放入元素、基础数据类型变量、元素的地址；STL 的<code>sort()</code>排序函数可以用来操作 <code>ector,list</code>等容器。</li>
<li>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就行了。这样他们就可以把精力放在程序开发的别的方面。</li>
<li>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</li>
</ul>
<p><strong>高可重用性</strong>：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知<br>识，已经给大家介绍了。<br><strong>高性能</strong>：如<code>map</code>可以高效地从十万条记录里面查找出指定的记录，因为<code>map</code>是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)<br>高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</p>
<h4 id="15-序列式式容器"><a href="#15-序列式式容器" class="headerlink" title="15. 序列式式容器"></a>15. 序列式式容器</h4><p>所有容器类都有共享公共接口，不同容器按不同方式对其进行扩展</p>
<h5 id="15-1-顺序容器种类"><a href="#15-1-顺序容器种类" class="headerlink" title="15.1 顺序容器种类"></a>15.1 顺序容器种类</h5><p>所有顺序容器都提供了快速顺序访问元素的能力。下表中的string我们已经在前面介绍，这里不重复做介绍：<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/rongqi.png" width="700"></p>
<ul>
<li><strong><code>string和vector</code>将元素保存在连续的内存空间内，因此由元素的下标来计算其地址是非常快速的</strong>。但是，在这两种容器的中间位置添加或删除元素就会非常耗时。即随机访问迭代器</li>
<li><strong><code>list</code>和<code>forward_list</code>在任何位置添加&#x2F;删除元素都非常快速</strong>。作为代价，这两个容器不支持元素的随机访问。而且，与<code>vector、array、deque</code>相比，这两个容器的额外内存开销(指针开销)也很大。另外<code>forward_list</code>没有<code>size</code>操作。</li>
</ul>
<p><strong>确定使用哪种顺序容器:</strong></p>
<ul>
<li>通常使用vector是最好的选择，除非你有更好的理由选择其他容器</li>
<li>注重空间开销的，不要使用list或forward_list</li>
<li>只在头尾，不在中间插入&#x2F;删除元素的，使用deque</li>
<li>在中间插入&#x2F;删除元素的，使用list或forward_list</li>
</ul>
<p>总之选择哪一种容器需要依据需求而决定</p>
<h5 id="15-2-序列容器支持的操作概览"><a href="#15-2-序列容器支持的操作概览" class="headerlink" title="15.2 序列容器支持的操作概览"></a>15.2 序列容器支持的操作概览</h5><h6 id="15-2-1-容器操作"><a href="#15-2-1-容器操作" class="headerlink" title="15.2.1 容器操作"></a>15.2.1 容器操作</h6><p>对与序列式容器，它们有一些公共接口，支持相同的操作方式(除特别标注)：<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/rongqioperate.png" width="600"></p>
<h6 id="15-2-2-顺序容器操作：迭代器"><a href="#15-2-2-顺序容器操作：迭代器" class="headerlink" title="15.2.2 顺序容器操作：迭代器"></a>15.2.2 顺序容器操作：迭代器</h6><p>标准容器类型上所有迭代器都允许我们访问容器中的元素（通过解引用运算符来实现），所有迭代器都定义了递增运算符。<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/iteratoroperate.png" width="700"><br>个迭代器的范围由一对迭代器表示，两个迭代器分别指向同一容器中的首元素<code>begin</code>和尾元素之后<code>end</code>的位置,其标准的数学表达为<code>[begin,end)</code>。<br><strong>对一个非常量对象调用<code>begin、end、rbegin、rend</code>（反向跌代），得到的是返回<code>iterator</code>的版本；对一个<code>const</code>对象调用这些函数时，才会得到一个const版本</strong>。但以c开头的版本还是可以获得<code>const_iterator</code>的，而不管容器的类型是什么,<strong>因此当不需要写访问时，应使用<code>cbegin</code>和<code>cend</code>.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; a=&#123;<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;making&quot;</span>,<span class="string">&quot;track&quot;</span>,<span class="string">&quot;2025&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">begin</span>();		<span class="comment">//list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">rbegin</span>();	<span class="comment">//list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">cbegin</span>();	<span class="comment">//list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">crbegin</span>();	<span class="comment">//list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure>
<h6 id="15-2-3-顺序容器操作：定义和初始化"><a href="#15-2-3-顺序容器操作：定义和初始化" class="headerlink" title="15.2.3 顺序容器操作：定义和初始化"></a>15.2.3 顺序容器操作：定义和初始化</h6><p>每个容器都定义了一个默认构造函数（除array,它按默认方式初始化）:<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/rongqichushihua.png" width="700"></p>
<p><strong>1. 当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了，元素类型也可以不同，只要能将元素类型转换即可</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; ls=&#123;<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;making&quot;</span>,<span class="string">&quot;track&quot;</span>,<span class="string">&quot;2025&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt;vec=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">ls_1</span><span class="params">(ls)</span></span>;		<span class="comment">//正确，类型匹配</span></span><br><span class="line"><span class="comment">//deque&lt;string&gt; dq(ls);		//错误，容器类型不匹配</span></span><br><span class="line"><span class="comment">//vector&lt;string&gt; ves(vec);	//错误，元素类型不匹配</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">ves</span><span class="params">(vec.begin(),vec.end())</span></span>;	<span class="comment">//正确，元素类型const char*可向string转换</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 与顺序容器大小相关的构造函数:除了有与关联容器相同的构造函数外，顺序容器（除array)还提供了另一个构造函数：它接受一个容器大小和一个（可选的）元素初始值。如果不提供元素初始值，则标准库会创建一个值初始化器</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">veci</span><span class="params">(<span class="number">10</span>,<span class="number">-1</span>)</span></span>;	<span class="comment">//10个int元素，初始值为-1</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">ls</span><span class="params">(<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>)</span></span>;	<span class="comment">//10个string元素，初始值为hi</span></span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">fls</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//10个int元素，初始值为0，注意区分()和&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>3. 标准库array具有固定大小：大小也是array类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,10&gt; ia1;		<span class="comment">//默认初始化10个int</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; ia2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;	<span class="comment">//列表初始化</span></span><br><span class="line">array&lt;<span class="type">int</span> 10&gt;ia3=&#123;<span class="number">10</span>&#125;;					<span class="comment">//第一个元素围为10，其余为0</span></span><br><span class="line"><span class="comment">//但ia3定义后在这样赋值不允许：(因为array不允许插入和删除）</span></span><br><span class="line">ia3=&#123;<span class="number">10</span>&#125;;	<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//数组类型无法拷贝和赋值，但array可以</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; ia4=ia2;		<span class="comment">//只有数组类型匹配array&lt;int,10&gt;即合法</span></span><br></pre></td></tr></table></figure>
<h6 id="15-2-4-顺序容器操作：添加元素"><a href="#15-2-4-顺序容器操作：添加元素" class="headerlink" title="15.2.4 顺序容器操作：添加元素"></a>15.2.4 顺序容器操作：添加元素</h6><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/pushback.png" width="700">
**1. 除`array`和`forward_list`之外，每个顺序容器（包括`string`类型)都支持`push_back`,它将一个元素加到容器尾部:**
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(<span class="type">size_t</span> cnt, string &amp;word)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt&gt;<span class="number">1</span>)</span><br><span class="line">word.<span class="built_in">push_back</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 除<code>string</code>和<code>vector</code>不支持<code>push_front</code>外，<code>list、forward_list、deque</code>容器都支持push_front,即将元素插入到容器头部</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> ix=<span class="number">0</span>;ix!=<span class="number">4</span>;++ix)</span><br><span class="line">p.<span class="built_in">push_front</span>(ix);</span><br></pre></td></tr></table></figure>

<p><strong>3. 特定位置插入元素<code>insert</code>。forward_list有自己版本的<code>insert</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; sece;</span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">begin</span>(),<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//插入范围元素</span></span><br><span class="line">ist&lt;string&gt; p=&#123;<span class="string">&quot;wwj&quot;</span>,<span class="string">&quot;love&quot;</span>&#125;;</span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">begin</span>(),<span class="number">10</span>,<span class="string">&quot;CRF&quot;</span>);		<span class="comment">//10个“CRF&quot;插入到容器头部</span></span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">begin</span>()+<span class="number">3</span>,p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//p容器的内容拷贝插入到了sece第四个元素前</span></span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">end</span>(),&#123;<span class="string">&quot;these&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="string">&quot;are&quot;</span>,<span class="string">&quot;finished&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//将元素值列表插入到尾部</span></span><br></pre></td></tr></table></figure>
<p>以上的insert调用后，会返回新添加的第一个元素的迭代器，若没有插入元素则返回原迭代器</p>
<p><strong>4.c++新标准引入三个新成员：<code>emplace_front</code>对应<code>push_front</code>、<code>emplace_back</code>对应<code>push_back</code>、<code>emplace</code>对应<code>insert</code>。主要区别是这些操作是构造不是拷贝元素。也就说明传入给<code>emplace</code>的参数必须与元素类型的构造函数相匹配(即个数、类型一样），先假设有定义的<code>Sales_data</code>类型有一个三参构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Sales_data&gt; c;</span><br><span class="line">c.<span class="built_in">emplace_back</span>(<span class="string">&quot;p78&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"><span class="comment">//该式子等价于c.push_back(Sales_data(&quot;p78&quot;,20,30));</span></span><br></pre></td></tr></table></figure>
<h6 id="15-2-5-顺序容器操作：访问元素"><a href="#15-2-5-顺序容器操作：访问元素" class="headerlink" title="15.2.5 顺序容器操作：访问元素"></a>15.2.5 顺序容器操作：访问元素</h6><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/fangwen.png" width="700">
这些访问操作（`back、front`、下标、`at`)返回的都是引用，如果容器是一个`const`对象，则返回的是`const`的引用，不是则返回普通的引用（可以改变元素值）。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!c.<span class="built_in">empty</span>())&#123;</span><br><span class="line">	c.<span class="built_in">front</span>()=<span class="number">42</span>;	<span class="comment">//将42赋予c的第一个元素</span></span><br><span class="line">	<span class="keyword">auto</span> &amp;v1=c.<span class="built_in">back</span>();</span><br><span class="line">	v1=<span class="number">1024</span>;		<span class="comment">//改变最后一个元素的值</span></span><br><span class="line">	<span class="keyword">auto</span> v2=c.<span class="built_in">back</span>();</span><br><span class="line">	v2=<span class="number">0</span>;		<span class="comment">//无法改变值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="15-2-6-顺序容器操作：删除元素"><a href="#15-2-6-顺序容器操作：删除元素" class="headerlink" title="15.2.6 顺序容器操作：删除元素"></a>15.2.6 顺序容器操作：删除元素</h6><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/delete.png" width="700">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除list中的所有奇数：</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it=lst.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it!=lst.<span class="built_in">end</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span>(*it%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">		it=lst.<span class="built_in">erase</span>(it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="15-2-7-顺序容器操作：赋值和swap"><a href="#15-2-7-顺序容器操作：赋值和swap" class="headerlink" title="15.2.7 顺序容器操作：赋值和swap"></a>15.2.7 顺序容器操作：赋值和swap</h6><p>该表中的赋值运算符可用于所有容器:<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/fuzhi.png" width="700"></p>
<p><strong>1. 赋值运算符<code>=</code>要求左边和右边的运算对象具有相同的类型。<code>assign</code>允许我们从一个相容<br>的类型赋值，或者从容器一个子序列赋值</strong>(由于左右两边的运算容器大小可能不同，所有<code>array</code>无法使用<code>assign</code>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一：</span></span><br><span class="line">list&lt;string&gt;names;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt;oldstyle&#123;<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>,<span class="string">&quot;man&quot;</span>&#125;;</span><br><span class="line">names.<span class="built_in">assign</span>(oldstyle.<span class="built_in">cbegin</span>(),oldstyle.<span class="built_in">cend</span>());	<span class="comment">//names的元素替换为oldstyle中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">slist</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">//1个元素且为空字符串</span></span><br><span class="line">slist.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="string">&quot;Hello&quot;</span>）；	<span class="comment">//10个元素且都为Hello</span></span><br></pre></td></tr></table></figure>

<p><strong><code>swap</code>操作交换两个相同类型容器的内容。除<code>array</code>外，交换两个容器内容的操作保证会很快——元素本身未交换，swap只是交换了两个容器的内部数据结构（即只是交换了第一次指向的指针)。即也代表着指向容器的迭代器、引用和指针在<code>swap</code>前后都不会改变（除<code>string</code>、<code>array</code>容器）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">s1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">vector&lt;string&gt;<span class="built_in">s2</span>(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">swap</span>(s1,s2);		<span class="comment">//执行完后s1指向的是30个元素，s2是（42）</span></span><br></pre></td></tr></table></figure>
<p><em><strong>注意：</strong></em>对于<code>array</code>，<code>swap</code>会真正交换它们的元素。</p>
<h6 id="15-2-8-顺序容器操作：改变容器大小"><a href="#15-2-8-顺序容器操作：改变容器大小" class="headerlink" title="15.2.8 顺序容器操作：改变容器大小"></a>15.2.8 顺序容器操作：改变容器大小</h6><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/resize.png" width="700">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst</span><span class="params">(<span class="number">10</span>,<span class="number">42</span>)</span></span>;</span><br><span class="line">lst.<span class="built_in">resize</span>(<span class="number">20</span>);		<span class="comment">//将后10个值赋值为0</span></span><br><span class="line">lst.<span class="built_in">resize</span>(<span class="number">30</span>,<span class="number">-1</span>);	<span class="comment">//将10个值为-1的添加到尾部</span></span><br><span class="line">lst.<span class="built_in">resize</span>(<span class="number">10</span>);		<span class="comment">//删除后20个元素</span></span><br></pre></td></tr></table></figure>

<h6 id="15-2-9-容器操作可能使迭代器失效"><a href="#15-2-9-容器操作可能使迭代器失效" class="headerlink" title="15.2.9 容器操作可能使迭代器失效"></a>15.2.9 容器操作可能使迭代器失效</h6><p>在对容器进行添加删除可能会使迭代器失效。一个失效的指针、引用和迭代器只是不再表示任何元素。此题的<code>vector</code>的<code>end</code>作为条件，要时时刻刻在插入或删除后更新。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>，<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter=vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(iter!=vi.<span class="built_in">end</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span>(*iter%<span class="number">2</span>)&#123;</span><br><span class="line">		iter=vi.<span class="built_in">insert</span>(iter,*iter);	<span class="comment">//返回插入后的的迭代器</span></span><br><span class="line">		iter+=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		iter=vi.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="15-2-10-关系运算符"><a href="#15-2-10-关系运算符" class="headerlink" title="15.2.10 关系运算符"></a>15.2.10 关系运算符</h6><ul>
<li>关系运算符两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素</li>
<li>比较两个容器实际上是进行元素的逐对比较，比较方式与string比较类似。</li>
<li>容器的关系运算符使用元素的关系运算符完成比较</li>
<li>只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</li>
</ul>
<h5 id="15-3vector容器"><a href="#15-3vector容器" class="headerlink" title="15.3vector容器"></a>15.3vector容器</h5><p><code>vector</code>是STL常用的容器之一，它和数组一样拥有连续的内存空间，但却比数组更好用。**<code>String</code>和<code>vector</code>均使用随机访问迭代器。<code>vector</code>在空间配置器下重新分配空间，那么原来的迭代器就会失效.**<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/vector.png" width="500"></p>
<h6 id="15-3-1-vector的扩容机制"><a href="#15-3-1-vector的扩容机制" class="headerlink" title="15.3.1 vector的扩容机制"></a>15.3.1 vector的扩容机制</h6><p><strong>对于能够快速随机访问的(下标访问），其内存是连续的，当我们的内存不够时，容器必须分配新的内存空间来保存已有的和新的元素(即将旧内存的元素拷贝到新内存，添加新元素，释放旧内存），所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为O(n)。</strong>。</p>
<p>当不得不获取新的内存空间时，<code>vector</code>和<code>string</code>的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可以来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。<strong>在不同的编译器中，vector的扩容策略不相同，msvc编译器每次是以1.5倍且向下取整的策略进行扩容，gcc编译器则是每次以2.0倍的策略进行扩容。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MSVC</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">34</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(n);</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;size:&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot;  capacity:&quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">size:<span class="number">1</span>  capacity:<span class="number">1</span></span><br><span class="line">size:<span class="number">2</span>  capacity:<span class="number">2</span></span><br><span class="line">size:<span class="number">3</span>  capacity:<span class="number">3</span></span><br><span class="line">size:<span class="number">4</span>  capacity:<span class="number">4</span></span><br><span class="line">size:<span class="number">5</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">6</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">7</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">8</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">9</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">10</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">11</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">12</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">13</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">14</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">15</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">16</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">17</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">18</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">19</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">20</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">21</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">22</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">23</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">24</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">25</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">26</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">27</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">28</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">29</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">30</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">31</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">32</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">33</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">34</span>  capacity:<span class="number">42</span></span><br></pre></td></tr></table></figure>

<h6 id="15-3-2-管理容量的成员函数"><a href="#15-3-2-管理容量的成员函数" class="headerlink" title="15.3.2 管理容量的成员函数"></a>15.3.2 管理容量的成员函数</h6><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/managercapacity.png" width="700">
- `reverse`并不改变容器中元素的数量，它仅影响`vector`预先分配多大的内存空间。
- 如果需求大小小于或等于当前容量，`reverse`什么也不做。且需求大小小于当前容量，容器不会退回内存空间。

<p><strong>源码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type __new_size)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (__new_size &gt; <span class="built_in">size</span>()) </span><br><span class="line">		  _M_default_append(__new_size - <span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">		  _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start + __new_size);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//reserve</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (__n &gt; <span class="built_in">max_size</span>())</span><br><span class="line">	__throw_length_error(__N(<span class="string">&quot;vector::reserve&quot;</span>));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">capacity</span>() &lt; __n)</span><br><span class="line">	_M_reallocate(__n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="15-3-3-vector构造函数"><a href="#15-3-3-vector构造函数" class="headerlink" title="15.3.3 vector构造函数"></a>15.3.3 vector构造函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v; <span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br><span class="line"><span class="comment">//例子 使用第二个构造函数 我们可以...</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>; </span><br></pre></td></tr></table></figure>

<h6 id="15-3-4-vector数据存取操作"><a href="#15-3-4-vector数据存取操作" class="headerlink" title="15.3.4 vector数据存取操作"></a>15.3.4 vector数据存取操作</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> idx); <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>

<h6 id="15-3-5-vector插入和删除操作"><a href="#15-3-5-vector插入和删除操作" class="headerlink" title="15.3.5 vector插入和删除操作"></a>15.3.5 vector插入和删除操作</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele);<span class="comment">//迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line"><span class="built_in">push_back</span>(ele); <span class="comment">//尾部插入元素ele</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);<span class="comment">//删除迭代器指向的元素</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure>

<h5 id="15-4-deque容器"><a href="#15-4-deque容器" class="headerlink" title="15.4 deque容器"></a>15.4 deque容器</h5><p><strong><code>Vector</code>容器是单向开口的连续内存空间，<code>deque</code>则是一种双向开口的连续线性空间</strong>。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/deque.png" width="500"></p>
<p>虽然<code>deque</code>容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和<code>vector</code>不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用<code>vector</code>，而不是<code>deque</code>。对<code>deque</code>进行的排序操作，为了最高效率，可将<code>deque</code>先完整的复制到一个<code>vector</code>中，对<code>vector</code>容器进行排序，再复制回<code>deque</code>.</p>
<h6 id="15-4-1-deque容器实现原理"><a href="#15-4-1-deque容器实现原理" class="headerlink" title="15.4.1 deque容器实现原理"></a>15.4.1 deque容器实现原理</h6><p><strong><code>deque</code>是由一段一段的定量的连续空间构成。一旦有必要在<code>deque</code>前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在<code>deque</code>的头端或者尾端。<code>deque</code>最大的工作就是维护这些分段连续的内存空间的整体性的假象</strong>，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p>
<p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。<br><strong><code>Deque</code>采取一块所谓的<code>map</code>(注意，不是STL的map容器)作为主控，这里所谓的<code>map</code>是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是<code>deque</code>的存储空间的主体。</strong><br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/dequemap.png" width="500"></p>
<h6 id="15-4-2-deque常用API"><a href="#15-4-2-deque常用API" class="headerlink" title="15.4.2 deque常用API"></a>15.4.2 deque常用API</h6><p><strong>1. deque构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;deq);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>

<p><strong>2.deque赋值操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">deque&amp;<span class="keyword">operator</span>=(<span class="type">const</span> deque &amp;deq); <span class="comment">//重载等号操作符 </span></span><br><span class="line"><span class="built_in">swap</span>(deq);<span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure>

<p><strong>3. deque双端插入和删除操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//删除容器第一个数据</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure>

<p><strong>4. deque访问操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span>(idx);<span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个数据。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure>

<p><strong>5. deque插入操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure>

<h5 id="15-5-list容器"><a href="#15-5-list容器" class="headerlink" title="15.5 list容器"></a>15.5 list容器</h5><p><strong>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</strong><br>相较于<code>vector</code>的连续线性空间，<code>list</code>就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，<code>list</code>对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，<code>list</code>永远是常数时间。</p>
<p><strong><code>list</code>和<code>vector</code>是两个最常被使用的容器。<code>list</code>容器是一个双向链表:</strong></p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
<li>链表灵活，但是空间和时间额外耗费较大<img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/list.png" width="500"></li>
</ul>
<h6 id="15-5-1-list容器的迭代器"><a href="#15-5-1-list容器的迭代器" class="headerlink" title="15.5.1 list容器的迭代器"></a>15.5.1 list容器的迭代器</h6><p><code>list</code>容器不能像<code>vector</code>一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。<code>list</code>迭代器必须有能力指向<code>list</code>的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”<code>list</code>正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员</p>
<p><strong>由于<code>list</code>是一个双向链表，迭代器必须能够具备前移、后移的能力，所以<code>list</code>容器提供的是Bidirectional Iterators.<code>list</code>有一个重要的性质，插入操作和删除操作都不会造成原有<code>list</code>迭代器的失效</strong>。这与<code>vector</code>是不同的，<code>vector</code>插入操作可能造内存重新配置导致原有的迭代器全部失效。</p>
<h6 id="15-5-2-list常用API"><a href="#15-5-2-list常用API" class="headerlink" title="15.5.2 list常用API"></a>15.5.2 list常用API</h6><p><strong>1. list构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; lstT;<span class="comment">//list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list &amp;lst);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>

<p><strong>2. list数据元素插入和删除操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器中最后一个元素</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器开头插入一个元素</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">remove</span>(elem);<span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure>

<p><strong>3. list赋值操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">list&amp;<span class="keyword">operator</span>=(<span class="type">const</span> list &amp;lst);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(lst);<span class="comment">//将lst与本身的元素互换。</span></span><br></pre></td></tr></table></figure>

<p><strong>4. list数据的存取、反转和排序</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素。</span></span><br><span class="line"><span class="built_in">reverse</span>();<span class="comment">//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span></span><br><span class="line"><span class="built_in">sort</span>(); <span class="comment">//list排序</span></span><br></pre></td></tr></table></figure>



<h4 id="16-适配器"><a href="#16-适配器" class="headerlink" title="16. 适配器"></a>16. 适配器</h4><p>除了顺序容器，还定义了三个顺序容器适配器：<code>stack（栈）、queue（队列）和priority_queue</code>。本质上，<strong>适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。</strong><br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/shipeiqi.png" width="700"></p>
<h5 id="16-1-适配器使用概览"><a href="#16-1-适配器使用概览" class="headerlink" title="16.1 适配器使用概览"></a>16.1 适配器使用概览</h5><h6 id="16-1-1-定义适配器"><a href="#16-1-1-定义适配器" class="headerlink" title="16.1.1 定义适配器"></a>16.1.1 定义适配器</h6><p>每个适配器都定义了<strong>两个构造函数：默认构造函数创建一个空对象;接受一个容器的构造函数拷贝该容器来初始化适配器。（下面的API介绍）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span>；	<span class="comment">//接受一个容器对象初始化适配器，deq是一个deque&lt;int&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>默认情况下，<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是在<code>vector</code>之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;string,vector&lt;string&gt;&gt; str_stk;	<span class="comment">//在vector上实现空栈</span></span><br><span class="line">stack&lt;string,vector&lt;string&gt;&gt; <span class="built_in">str_stk</span>(sevc);	<span class="comment">//构造在vector上实现，并初始化</span></span><br></pre></td></tr></table></figure>
<h6 id="16-1-2-适配器限制"><a href="#16-1-2-适配器限制" class="headerlink" title="16.1.2 适配器限制"></a>16.1.2 适配器限制</h6><p>所有的适配器都要求能够删除和添加元素的能力，因此适配器不能构造在array上实现：</p>
<ul>
<li><strong><code>stack</code>——要求有<code>pop、push</code>和<code>top</code>能力，所以可用（除<code>array、forward_list</code>）的容器构造</strong></li>
<li><strong><code>queue</code>——要求有<code>back、push、front、pop</code>能力，所以可构造在<code>list、deque</code>，不能<code>vector</code></strong></li>
<li><strong><code>priority_queue</code>——要求有<code>front、push、pop和top</code>，所以可用<code>vector、deque</code>，但不能<code>list</code></strong></li>
</ul>
<h5 id="16-2-stacks适配器"><a href="#16-2-stacks适配器" class="headerlink" title="16.2 stacks适配器"></a>16.2 stacks适配器</h5><p><code>stack</code>是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。<code>stack</code>容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取<code>stack</code>的其他元素。换言之，<code>stack</code>不允许有遍历行为。有元素推入栈的操作称为:<code>push</code>,将元素推出的操作称为<code>pop</code>.<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/stack.png" width="500"><br><strong>栈适配器默认基于<code>deque</code>实现，也可以在<code>list</code>和<code>vector之</code>上实现</strong>。虽然<code>stack</code>是基于<code>deque</code>实现的，但我们不能调用<code>push_back</code>等等这些操作，我们必须调用它自己的操作。</p>
<h6 id="16-2-1-stack常用API"><a href="#16-2-1-stack常用API" class="headerlink" title="16.2.1 stack常用API"></a>16.2.1 stack常用API</h6><p>Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，<strong>也不提供迭代器。</strong></p>
<p><strong>1. stack构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;<span class="comment">//stack采用模板类实现， stack对象的默认构造形式： </span></span><br><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack &amp;stk);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p><strong>2. stack数据存取操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>

<p><strong>3. stack赋值操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&amp;<span class="keyword">operator</span>=(<span class="type">const</span> stack &amp;stk);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>

<h5 id="16-3-queue适配器"><a href="#16-3-queue适配器" class="headerlink" title="16.3 queue适配器"></a>16.3 queue适配器</h5><p><code>queue</code>是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，<code>queue</code>容器允许从一端新增元素，从另一端移除元素。<code>queue</code>默认基于<code>deque</code>实现，<code>priority_queue</code>默认基于<code>vector</code>实现</p>
<img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/queue.png" width="500">

<h6 id="16-3-1-queue常用API"><a href="#16-3-1-queue常用API" class="headerlink" title="16.3.1 queue常用API"></a>16.3.1 queue常用API</h6><p><code>queue</code>所有元素的进出都必须符合”先进先出”的条件，只有<code>queue</code>的顶端元素，才有机会被外界取用。<code>queue</code><strong>不提供遍历功能，也不提供迭代器</strong>。</p>
<p><strong>1. queue构造函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：</span><br><span class="line">queue(const queue &amp;que);//拷贝构造函数</span><br></pre></td></tr></table></figure>

<p><strong>2. queue赋值操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&amp;<span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>

<p><strong>3.queue存取、插入和删除操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>与顺序容器不同，<strong>关联容器中的元素是按着元素的关键字来保存和访问的</strong>。顺序容器中的元素是按着它们在容器中的位置来顺序保存和访问。c++两个主要的关联容器是<code>map</code>和<code>set</code>。<br><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/guanlian.png" width="700"></p>
<ul>
<li><code>map</code>中的元素是关键字-值<code>key-value</code>对。关键字起到索引的作用，值则是与索引相关联的数据。</li>
<li><code>set</code>中只包含一个关键字，<code>set</code>支持高效的关键字查询操作——检查一给定关键字是否在<code>set</code>中</li>
<li>标准库提供8个关联容器，它们的不同体现在三个维度上：<strong>①每个容器或者是个set或者是个map;②或者要求不重复的关键字，或者允许重复关键字；③按顺序保存元素，或者无序保存元素</strong></li>
<li>允许重复关键字关键字的容器名字中都包含<code>multi</code>;不保持关键字按顺序存储的容器的名字都以单词<code>unordered</code>开头。<strong>无序容器使用哈希函数来组织元素</strong>。</li>
<li>类型<code>map</code>和<code>multimap</code>定义在头文件<code>map</code>中，<code>set</code>和<code>multiset</code>定义在头文件<code>set</code>中。无序容器则定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中</li>
<li><strong><code>map、multimap、set、multiset</code>都是以红黑树为底层实现机制。<code>unordered_map</code>、<code>unordered_set</code>底层哈希表的实现机理</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">python面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 18:24:44" itemprop="dateCreated datePublished" datetime="2022-06-30T18:24:44+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-07 17:25:13" itemprop="dateModified" datetime="2022-07-07T17:25:13+08:00">2022-07-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">python面向对象</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="1-类对象提供的默认行为"><a href="#1-类对象提供的默认行为" class="headerlink" title="1. 类对象提供的默认行为"></a>1. 类对象提供的默认行为</h5><p>在python的面向对象模型种，要分清<strong>类对象</strong>和<strong>实例对象</strong>。类对象就是<code>class</code>定义了一个类只会，该类提供些行为就是类对象.而实例对象就是该类的示例。每次调用类，就会生成一个示例。<br>类对象提供的默认行为：</p>
<ul>
<li><code>class</code>语句创建类对象并将其赋值给变量名。就像<code>def</code>一样，class语句也是可执行语句，执行时会产生类对象，并赋值变量名</li>
<li>class语句的赋值语句会创建类属性，像模块文件一样，class语句内的顶层的赋值语句（不在<code>def</code>内）会成为类对象的属性。</li>
<li>类属性提供对象的状态（变量）和行为（函数）</li>
<li>类仍然时模块内的属性。当<code>class</code>执行时，只是赋值语句而已，赋值了一个类对象</li>
</ul>
<h5 id="2-实例对象是具体对象"><a href="#2-实例对象是具体对象" class="headerlink" title="2.实例对象是具体对象"></a>2.实例对象是具体对象</h5><p>每当调用类对象时，就会生成示例对象：</p>
<ul>
<li>调用类对象会创建新的示例对象</li>
<li>每个示例对象有类的属性并且有自己的命名空间</li>
<li><em><strong>在方法内对self属性做赋值会产生每个实例自己的属性</strong></em>：在类函数内，第一个参数总是接受方法调用的隐形主体，通常用<code>self</code>会引用正处理的示例对象（相当于C&#x2F;C++的<code>this指针</code>)。对<code>self</code>的属性做赋值运算，会创建或修改示例内的数据，而不是类的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">firstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.data=value;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data);</span><br><span class="line">    data=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">s=firstClass();</span><br><span class="line">s.printdata();	<span class="comment">#0</span></span><br><span class="line">s.setdata(<span class="number">10</span>);</span><br><span class="line">s.printdata();	<span class="comment">#10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>self</code>会自动引用正在处理的示例对象，所以赋值语句会把值村储到实例的命名空间。因为<strong>类对象</strong>会产生多个实例，函数必须经过<code>self</code>参数才能识别获取正在处理的实例（就看出时c&#x2F;c++中隐藏的<code>this指针</code>就行了)</p>
<h5 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h5><p>面向对象的一大特性就是继承，以下时python中继承的核心观点：</p>
<ul>
<li>父类列在类开头的括号处</li>
<li>子类从父类中继承了函数和属性</li>
<li>实例会继承所有可读取类的属性：每个实例会从创建它的类中获取变量名，此外还有该类的父类</li>
<li>每个<code>object.attribute</code>都会开启新的独立搜索：python会对每个属性取出表达式进行对类树的独立搜索，包括self</li>
<li>一般来说逻辑的修改都是通过继承的子类修改，而不是直接修改父类</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">secondClass</span>(<span class="title class_ inherited__">firstClass</span>):</span><br><span class="line">	data=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这是第二个类&quot;</span>，sefl.data);</span><br><span class="line"></span><br><span class="line">a=secondClass();</span><br><span class="line">a.setdata(<span class="number">20</span>)</span><br><span class="line">a.printdata();		<span class="comment">#这是第二个类 20</span></span><br></pre></td></tr></table></figure>
<p>子类对属性的搜索会从下往上，即从子类到父类，直到所找属性名首次出现为止。上面的<code>printdata</code>函数覆盖了父类的<code>printdata</code>函数，这中覆盖叫做<code>重载</code>。</p>
<h5 id="4-类的运算符重载初识"><a href="#4-类的运算符重载初识" class="headerlink" title="4.类的运算符重载初识"></a>4.类的运算符重载初识</h5><p><strong>运算符重载</strong>就是让类写成的对象可以截获并响应内置类型上的运算，如加法、切片和打印等等，在这里我们只是片面性的列举了一些重载以做了解，更加具体的将在后面介绍。运算符重载的主要注意点：</p>
<ul>
<li>运算符重载的命名方式为<code>__x__</code></li>
<li>当实例出现内置运算时，这类方法会自动调用。比如实例有<code>__add__</code>方法，当对象出现<code>+</code>表达式时，该方法就会调用</li>
<li>类可覆盖多数内置类型运算</li>
<li>运算符重载让类变得更趋像python的对象模型<br><em><strong>注意</strong></em>：我们必须关心一个方法，那就是<code>__init__</code>方法，也称为<strong>构造函数</strong>,它用于初始化对象的状态的，***<code>__init__</code>和<code>self</code>是我们理解python面向对象特性的关键***</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdClass</span>(<span class="title class_ inherited__">secondClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.data=value;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> ThirdClass(self.data+other);</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[ThirdClass:%s]&#x27;</span>% self.data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是ThirdClass&quot;</span>,self.data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=ThirdClass(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">a.printdata();</span><br><span class="line">a=a+<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">a.printdata();</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是ThirdClass abc</span><br><span class="line">这是ThirdClass abc123</span><br><span class="line">[ThirdClass:abc123]</span><br></pre></td></tr></table></figure>
<p>从上面可以知道几点：</p>
<ol>
<li><code>ThirdClass</code>调用传入一个参数，这是传给<code>__init__</code>构造函数的参数，即在在构建实例时自动调用<code>__init__</code>构造函数来初始化属性</li>
<li>有<code>__add__</code>函数后，即<code>+</code>运算符重载，<code>ThirdClass</code>的实例对象就可出现在<code>+</code>处，对与<code>+</code>，它把左侧的对象传给<code>self</code>，右侧的给<code>other</code>。执行完后，<strong>对于<code>__add__</code>来说要返回一个新的对象实例</strong></li>
<li>重载了<code>__str__</code>方法后，可以直接调用<code>print</code>打印对象</li>
</ol>
<h5 id="5-以实例介绍类的细节"><a href="#5-以实例介绍类的细节" class="headerlink" title="5.以实例介绍类的细节"></a>5.以实例介绍类的细节</h5><p><strong>5.1.person和manager</strong><br>在本节，将会两个类<code>person</code>和<code>manager</code>来介绍类实现的一些细节。顺带一提oython的%字符串格式为<code>&quot;%s,%d&quot; %(&quot;2222&quot;,10)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,job=<span class="literal">None</span>,pay=<span class="number">0</span></span>):</span><br><span class="line">		self.name=name;</span><br><span class="line">		self.job=jon;</span><br><span class="line">		self.pay=pay;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span>  self.name.split()[-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self,percent</span>):</span><br><span class="line">		self.pay=<span class="built_in">int</span>(self.pay*(<span class="number">1</span>+percent))</span><br><span class="line">	<span class="comment">#print重载</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;[Person:%s,%s]&#x27;</span> % (self.name,self.pay)</span><br><span class="line"><span class="comment">#manager类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">	<span class="comment">#定制自己的构造函数，使用父类（超类）的构造函数构造</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,pay</span>):</span><br><span class="line">		self.person=Person.__init__(self,name,<span class="string">&#x27;mgr&#x27;</span>,pay);</span><br><span class="line">	<span class="comment">#重载函数，内部仍然使用超类的函数</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self,percent,bonus=<span class="number">1.0</span></span>):</span><br><span class="line">		person.giveRaise(self,percent+bonus);</span><br><span class="line">	<span class="comment">#改进点：</span></span><br><span class="line">	<span class="comment">#1. 使用内置的`Instance.__class__.__name__`,避免重复修改前部分的名称</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span><span class="string">&#x27;[%s:%s,%s]&#x27;</span> % (self.__class__.__name__,self.name,self.pay)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>5.2 对象持久化</strong><br>在上面我们创建的不是真正的数据库记录，如果关闭python，实例也将消失，因为它们是内存中的临时对象，这时可以使用python中<code>对象持久化</code>的功能，让对象在退出程序时依然存在。<strong>对象持久化</strong>通过3个标准库模块实现：</p>
<ul>
<li><code>pickle</code>:任意python对象和字节串之间的转化</li>
<li><code>dbm</code>：实现一个可通过键访问的文件系统，以存储字符串</li>
<li><code>shelve</code>:使用上面两个模块按照键把python对象存储到一个文件</li>
</ul>
<p>即<code>shelve</code>通过使用<code>pickle</code>将对象转为字符串，然后存储到一个<code>dbm</code>文件中键值对下，<code>shelve</code>通过键获取<code>pinkle</code>化的字符串，并用<code>pickle</code>在内存中重新创建最初对象。<code>shelve</code>就像字典一样，但是<code>shelve</code>一开始必须打开，并且在修改后关闭它</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">a=Person(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">b=Manager(<span class="string">&quot;小路&quot;</span>，<span class="number">1000</span>)</span><br><span class="line">db=shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">object</span> <span class="keyword">in</span>(a,b)</span><br><span class="line">	db[objecct.name]=<span class="built_in">object</span></span><br><span class="line">db.close();</span><br></pre></td></tr></table></figure>
<p>此时，当前目录下会生成一个或多个名为<code>persondb</code>的文件</p>
<h5 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h5><p>抽象类只是实现给继承者的一些接口，继承者类将接口实现什么功能完全由继承类决定，因此抽象接口类不能产生实例,只要类中有一个抽象方法，我们就不能创建该类的实例对象。在python3中，在<code>class</code>的头部使用一个关键字参数，以及特殊的**@装饰器**语法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCmeta,abstractmethod</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>(metaclass=ABCmeta):</span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">method_1</span>(<span class="params">self,*args</span>):</span><br><span class="line">		<span class="keyword">pass</span>;</span><br></pre></td></tr></table></figure>

<h5 id="7-命名空间"><a href="#7-命名空间" class="headerlink" title="7.命名空间"></a>7.命名空间</h5><p>我们知道点号和无点号的变量名，会用不同方式进行访问，还有一些作用域是用于对对象命名空间做初始而设定的（如模块和类），总结如下：</p>
<ul>
<li>无点号运算的变量民与作用域相对应（如普通的全局和局部赋值）</li>
<li>点号的属性名<code>object.x</code>使用的是对象的命名空间</li>
<li>有些作用域会对对象的命名空间初始化（模块和类）</li>
</ul>
<h5 id="8-运算符重载详解"><a href="#8-运算符重载详解" class="headerlink" title="8.运算符重载详解"></a>8.运算符重载详解</h5><p>运算符重载是意味着给自定义类增加操作，在类方法中拦截内置操作，当类的实例出现内置操作时，python自动调用你的方法。以下时常见的运算符重载方法：</p>
<table>
<thead>
<tr>
<th>运算符重载函数名</th>
<th>重载功能</th>
<th>调用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__init__</code></td>
<td>构造函数</td>
<td>实例创建时自动调用</td>
</tr>
<tr>
<td><code>__del__</code></td>
<td>析构函数</td>
<td>实例对象回收时自动调用</td>
</tr>
<tr>
<td><code>__add__</code></td>
<td>运算符<code>+</code></td>
<td>如果没有<code>__iadd__</code>，<code>X+Y,X+=Y</code>时会调用</td>
</tr>
<tr>
<td><code>__sub__</code></td>
<td>运算符<code>-</code></td>
<td><code>X-Y,X-=Y</code>调用</td>
</tr>
<tr>
<td><code>__repr__,__str__</code></td>
<td>打印，转换</td>
<td><code>print(x),repr(x),str(x)</code></td>
</tr>
<tr>
<td><code>__call__</code></td>
<td>函数调用</td>
<td><code>X(*args,**dargs)</code></td>
</tr>
<tr>
<td><code>__getattr__</code></td>
<td>点号运算</td>
<td><code>X.undefined</code></td>
</tr>
<tr>
<td><code>__setattr__</code></td>
<td>属性赋值语句</td>
<td><code>X.attribute=value</code></td>
</tr>
<tr>
<td><code>__delattr__</code></td>
<td>属性删除</td>
<td><code>del X.attribute</code></td>
</tr>
<tr>
<td><code>__getattribute__</code></td>
<td>属性获取</td>
<td><code>X.attribute</code></td>
</tr>
<tr>
<td><code>__getitem__</code></td>
<td>索引运算</td>
<td><code>x[key],x[i:j]</code></td>
</tr>
<tr>
<td><code>__setitem__</code></td>
<td>索引赋值语句</td>
<td><code>x[key]=value,x[i:j]=sequance</code></td>
</tr>
<tr>
<td><code>__delitem__</code></td>
<td>索引和分片删除</td>
<td><code>del x[key],del x[i:j]</code></td>
</tr>
<tr>
<td><code>__iter__</code>,<code>__next___</code></td>
<td>迭代环境</td>
<td><code>i=iter(x),next(i)</code></td>
</tr>
<tr>
<td><code>__len__</code></td>
<td>长度</td>
<td>如果没有<code>__bool__</code>，直接<code>len(x)</code></td>
</tr>
<tr>
<td><code>__bool__</code></td>
<td>布尔测试</td>
<td><code>bool(x)</code></td>
</tr>
<tr>
<td><code>__lt__</code>,<code>__gt__</code></td>
<td>比较</td>
<td>从左到右以此为<code>&lt;,&gt;</code></td>
</tr>
<tr>
<td><code>__le__</code>,<code>__ge__</code></td>
<td>比较</td>
<td><code>&lt;=,&gt;=</code></td>
</tr>
<tr>
<td><code>__eq__</code>,<code>__ne__</code></td>
<td>比较</td>
<td><code>==,!=</code></td>
</tr>
<tr>
<td><code>__contains__</code></td>
<td>成员关系测试</td>
<td><code>item in X</code></td>
</tr>
</tbody></table>
<p>由上面可知，运算符的重载前后都有两个下划线标识，以区分其他变量名函数。</p>
<p><strong>8.1 索引和分片</strong><br>如果类中定义或者继承了该运算符，则对于实例的索引运算，会自动调用<code>__getitem__</code>,会把实例传递给第一个参数，方括号内的值则传递给后面的一个参数，<code>__setitem__</code>则加了一个值value参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">operatorOverload</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		self.L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,index</span>):</span><br><span class="line">		<span class="keyword">return</span> self.L[index];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,index,value</span>):</span><br><span class="line">		self.L[index]=value;</span><br><span class="line">x=operatorOverload();</span><br><span class="line"><span class="comment">#索引操作</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">2</span>]);	<span class="comment">#9</span></span><br><span class="line"><span class="built_in">print</span>(x.L);		<span class="comment">#[1,2,3,4]</span></span><br><span class="line"><span class="comment">#分片操作</span></span><br><span class="line"><span class="built_in">print</span>(x[::<span class="number">2</span>])	<span class="comment">#[1,3]</span></span><br><span class="line"><span class="comment">#赋值</span></span><br><span class="line">x[::<span class="number">2</span>]=[<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="built_in">print</span>(x[:])</span><br></pre></td></tr></table></figure>

<p><strong>8.2 索引迭代</strong><br><code>__getitem__</code>有一个买一送一的情况，该重载不仅仅支持上面所讲的<strong>索引和分片功能</strong>,同时支持了<code>for</code>循环的迭代，**当类中未定义<code>__iter__</code>时，即<code>for</code>循环每次循环时都会调用类的<code>__getitem__</code>**。其实不仅仅指<code>for</code>循环会调用，其他的迭代环境，如<code>in成员测试，列表解析,内置函数map，列表和元组赋值运算以及类型构造方法</code>也会自动调用该方法，只有类中没有<code>__iter__</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> x:	<span class="comment">#调用了__getitem__</span></span><br><span class="line">	<span class="built_in">print</span>(item,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>8.3 迭代器对象</strong><br>尽管上面说的<code>__getitem__</code>支持迭代，但是它只是一直附加方法，真正的迭代还是要习惯用<code>__iter__</code>来获取迭代器，调用<code>__next__</code>访问，直到碰见异常<code>StopIteration</code>。python环境中所有迭代环境都是先尝试<code>__iter__</code>方法，然后再试<code>__getitem__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IterTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> self.start==self.end:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration;</span><br><span class="line">		self.start+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> self.start**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">m=IterTest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">q=<span class="built_in">iter</span>(m);</span><br><span class="line"><span class="built_in">print</span>(q);		<span class="comment">#&lt;__main__.IterTest object at 0x00000168A41CDFF0&gt;</span></span><br><span class="line"><span class="comment">#print(next(q))	#1</span></span><br><span class="line">L=<span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">	L.append(x);</span><br><span class="line"><span class="built_in">print</span>(L);		<span class="comment">#[1, 4, 9, 16, 25]，当print(next(q))未注释，输出为[4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<p>上面可以看到，迭代器对象就是实例<code>self</code>，这是因为<code>__next__</code>使类方法。且上面定义的迭代器使像<strong>生成器函数和表达式、<code>map</code>和<code>zip</code>内置函数</strong>一样的单迭代对象，要达到多个迭代器的效果，<code>__iter__</code>只需替迭代器定义新的状态对象，而不是返回<code>self</code>，带来的消耗是要创建多个迭代对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NextTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> self.start==self.end:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration;</span><br><span class="line">		self.start+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> self.start**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IterTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> NextTest(self.start,self.end);</span><br><span class="line"></span><br><span class="line">m=IterTest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">q=<span class="built_in">iter</span>(m);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(q));		<span class="comment">#1</span></span><br><span class="line">L=<span class="built_in">list</span>();</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">	L.append(x);</span><br><span class="line"><span class="built_in">print</span>(L);			<span class="comment">#[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>

<p><strong>8.4 成员关系</strong><br>再迭代领域，类通常把<code>in</code>成员关系运算符实现为一个迭代，使用<code>__iter__</code>或着<code>__getitem__</code>。要支持更加特定的成员关系，类可能要编写一个<code>__contains__</code>方法，出现是，方法优先级是<code>contains&gt;iter&gt;getitem</code>。<code>__contains__</code>方法应该把成员关系定义为对一个<strong>映射</strong>应用键，用于序列的搜索</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContainsTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.data=value;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self,x</span>):</span><br><span class="line">		<span class="keyword">return</span> x <span class="keyword">in</span> self.data;</span><br><span class="line"></span><br><span class="line">m=ContainsTest([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Contains:&quot;</span>,<span class="number">3</span> <span class="keyword">in</span> m,end=<span class="string">&#x27; &#x27;</span>);		<span class="comment">#Contains: True</span></span><br></pre></td></tr></table></figure>

<p><strong>8.5 属性引用</strong><br><code>__getattr__</code>方法是拦截属性点号运算，当通过对未定义（不存在）属性名称和实例进行点号运算时，就会用属性名称作为字符串调用这个方法，如果可以通过继承找到属性就不会调用这个方法。因此，<code>__getattr__</code>可以作为钩子通过这种方式响应属性请求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">empty</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">___getattr__</span>(<span class="params">self,attrname</span>):</span><br><span class="line">		<span class="keyword">if</span> attrname=<span class="string">&quot;age&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> AttributeError,attrname</span><br><span class="line"></span><br><span class="line">x=empty();</span><br><span class="line">x.age		<span class="comment">#40</span></span><br><span class="line">x.name		<span class="comment">#AttributeError:name</span></span><br></pre></td></tr></table></figure>
<p><code>__setattr__</code>会拦截所有属性的赋值语句,因此如果定义了这个方法要小心。除此之外，因为它对任何赋值语句都会拦截，即使是在<code>__setattr__</code>内也不例外，为防止无限递归，要使用该方法，必须通过<strong>属性字典</strong>做索引来赋值任何实例属性<code>self.__dict__[attr]=value;</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self,attrname,value</span>):</span><br><span class="line">		<span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">			self.__dict__[attr]=value;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">raise</span> AttriubteError, attrname+<span class="string">&#x27;nor allowed&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>8.6 call表达式</strong><br>当调用实例时，使用<code>__call__</code>。如果定义该方法，python1就会为实例应用函数调用表达式运行<code>__call__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,*args,**agrv</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;called:&#x27;</span>,args,argv);</span><br><span class="line">c=Test();</span><br><span class="line">c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,x=<span class="number">4</span>,y=<span class="number">5</span>);	<span class="comment">#called:(1,2,3)&#123;&#x27;x&#x27;=4,&#x27;y&#x27;=5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>8.7 布尔测试</strong><br>python首先尝试<code>__bool__</code>来直接获取一个<code>bool</code>值，如果没有该方法，就尝试<code>__len__</code>，根据对象的长度确定一个真值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.data=value;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span>(self.data!=<span class="literal">None</span>):</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span>;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(self.data);</span><br><span class="line">x=Truth(<span class="string">&quot;12314&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;bool yes!&#x27;</span>);	<span class="comment">#bool yes!</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(x):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;len yes!&#x27;</span>);	<span class="comment">#len yes!</span></span><br></pre></td></tr></table></figure>

<h5 id="9-类的设计"><a href="#9-类的设计" class="headerlink" title="9. 类的设计"></a>9. 类的设计</h5><p>无论是哪门语言，对于OOP，其重要的三个面向对象特性：继承、多态、封装。在python，这三个特性作用也是一样：</p>
<ul>
<li>继承：提高代码的复用性</li>
<li>多态：提高程序的可扩展性和可维护性</li>
<li>封装：方法和运算符实现行为，数据隐藏是一种惯例，以此提高程序安全性</li>
</ul>
<p><strong>9.1 封装</strong><br>封装提高程序的安全性。将数据（属性）和行为（方法）包装到类对象中，在方法内部对属性进行操作，在类对象的外部调用方法，这样无需关心方法内部的具体实现细节，从而隔离了复杂度；在python中没有专门的修饰符用于属性的私有，如果该属性不希望在类对象外部被访问，前边使用两个<code>_</code>修饰</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.__age=age  <span class="comment">#年龄不希望在类的外部被使用，所以加了两个__</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.__age)</span><br><span class="line">stu1=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">stu1.show()</span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br><span class="line"><span class="comment">#print(stu1.__age)   #这句话会报错，因为__age不希望在类外面使用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;如果想在类之外使用，可以用_类名__实例属性来用&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(stu1._Student__age)</span><br></pre></td></tr></table></figure>

<p><strong>9.2 继承</strong><br>在python中，如果一个类没有继承任何类，则默认继承object。python支持多继承，<strong>定义子类时，必须在其构造函数中调用父类的构造函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,stu_num</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.stu_num=stu_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,teachofyear</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.teachofyear=teachofyear</span><br><span class="line"></span><br><span class="line">stu=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>,<span class="number">1001</span>)</span><br><span class="line">teach=Teacher(<span class="string">&#x27;李四&#x27;</span>,<span class="number">40</span>,<span class="number">20</span>)</span><br><span class="line">stu.info()</span><br><span class="line">teach.info()</span><br></pre></td></tr></table></figure>
<p>如上，如果子类对继承父类中的某个属性或方法不满意，可以在子类中对其（方法体）进行重新编写.<strong>子类重写后的方法中可以通过<code>super().xxx()</code>调用父类中被重写的方法</strong>。</p>
<p>另外一点，在python中object类是所有类的父类，因此所有类都有object类的属性和方法。有内置函数dir()可以查看指定对象所有属性。object还有有一个<code>__str__()</code>方法，用于返回一个对于“对象的描述”，对应于内置函数<code>str()</code>经常用于<code>print()</code>方法，帮我们查看对象的信息，所以我们经常会对<code>__str__()</code>进行重写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我的名字是&#123;0&#125;,今年&#123;1&#125;岁&#x27;</span>.<span class="built_in">format</span>(self.name,self.age)</span><br><span class="line">stu=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(stu))</span><br><span class="line"><span class="built_in">print</span>(stu)  <span class="comment">#默认会调用__str__()这样的方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(stu))</span><br></pre></td></tr></table></figure>

<p><strong>9.3 多态</strong><br>多态就是“具有多种形态”,它指的是：即便不知道一个变量所引用的对象到底是 什么类型，仍然可以通过这个变量调用方法，在运行过程中根据变量所引用对象的类型， 动态决定调用哪个对象中的方法。实现多态必须有的三个条件：</p>
<ul>
<li>继承</li>
<li>方法重写</li>
<li>父类引用指向子类对象<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动物会吃&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;狗吃骨头&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猫吃鱼&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;人吃五谷杂粮&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.eat()</span><br><span class="line">fun(Cat())</span><br><span class="line">fun(Dog())</span><br><span class="line">fun(Animal())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;——————————&#x27;</span>)</span><br><span class="line">fun(Person())</span><br></pre></td></tr></table></figure>
<strong>9.4 类的浅拷贝和深拷贝</strong></li>
<li><strong>变量的赋值操作</strong>：只是形成两个变量，实际上还是指向同一个对象</li>
<li><strong>浅拷贝</strong>：python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，源对象与拷贝对象会引用同一个子对象</li>
<li><strong>深拷贝</strong>：使用copy模块的<code>deepcopy</code>函数，递归拷贝对象中包含的子对象，源对象和拷贝 对象所有的子对象也不相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Disk</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,cpu,disk</span>):</span><br><span class="line">        self.cpu=cpu</span><br><span class="line">        self.disk=disk</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.变量的赋值</span></span><br><span class="line">cpu1=CPU()</span><br><span class="line">cpu2=cpu1</span><br><span class="line"><span class="built_in">print</span>(cpu1)</span><br><span class="line"><span class="built_in">print</span>(cpu2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.类的浅深拷贝</span></span><br><span class="line">disk=Disk() <span class="comment">#创建一个硬盘类的对象</span></span><br><span class="line"><span class="built_in">print</span>(disk)</span><br><span class="line">computer=Computer(cpu1,disk)    <span class="comment">#创建一个计算机类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#浅拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">computer2=copy.copy(computer)</span><br><span class="line"><span class="built_in">print</span>(computer,computer.cpu,computer.disk)</span><br><span class="line"><span class="built_in">print</span>(computer2,computer2.cpu,computer2.disk)</span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝</span></span><br><span class="line">computer3=copy.deepcopy(computer)</span><br><span class="line"><span class="built_in">print</span>(computer,computer.cpu,computer.disk)</span><br><span class="line"><span class="built_in">print</span>(computer3,computer3.cpu,computer3.disk)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//赋值就是简单的变量引用同一个对象</span><br><span class="line">&lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt;</span><br><span class="line">&lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#浅拷贝，对象包含的的子对象内容不拷贝，都引用同一个内容</span></span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615ED70</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615F820</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝，子对象也拷贝了</span></span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615ED70</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615DD50</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615D450</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615D3F0</span>&gt;</span><br></pre></td></tr></table></figure>


<p><strong>9.5 设计模式之委托模式</strong><br>所谓的<strong>委托</strong>，<strong>通常就是指控制对象内嵌其他对象，而把运算请求传给这些内嵌对象处理，控制器对象只负责管理工作</strong>。在python中，委托通常用<code>__getattr__</code>钩子方法实现，因为这个方法会拦截对不存在属性的读取，因此代理类可以使用<code>__getattr__</code>把任意读取操作转给被包装对象。<br>简而言之：通过一个类来调用另一个类里的方法来处理请求，即这两个类对象参与处理同一个请求对象，只不过一个是<strong>委托者</strong>，一个是<strong>处理者</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,<span class="built_in">object</span></span>):</span><br><span class="line">		self.wrapped=<span class="built_in">object</span>;	<span class="comment">#内嵌对象</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self,attrname</span>):</span><br><span class="line">		<span class="keyword">if</span> attrname==<span class="string">&#x27;append&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped,attrname);</span><br><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">x=wrapper(L);</span><br><span class="line">x.append(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">print</span>(L)			<span class="comment">#[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，因为<code>x.append(4)</code>未在<code>wrapper</code>内定义，触发<code>__getattr__</code>函数,<code>getattr(x,y)</code>函数的作用就是点操作，即<code>x.y</code>。</p>
<p><strong>9.6 绑定和无绑定方法</strong></p>
<ul>
<li>实例的绑定方法：即有<code>self</code>，且在类中没有被任何装饰器修饰的方法就是绑定到对象的方法，这类方法专门为对象定制。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    country = <span class="string">&quot;China&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">str</span>(self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;Kitty&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p.__dict__)</span><br><span class="line">p.speak()   <span class="comment">#通过对象调用 Kitty, 18</span></span><br><span class="line">Person.speak(p)   <span class="comment">#通过类调用Kitty, 18</span></span><br></pre></td></tr></table></figure>
<p>通过对象调用绑定到对象的方法，会有一个自动传值的过程，即自动将当前对象传递给方法的第一个参数（<code>self</code>，一般都叫<code>self</code>，也可以写成别的名称）；若是使用类调用，则第一个参数需要手动传值。</p>
<ul>
<li>类的绑定方法:类中使用<code>@classmethod</code>修饰的方法就是绑定到类的方法。这类方法专门为类定制。通过类名调用绑定到类的方法时，会将类本身当做参数传给类方法的第一个参数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operate_database</span>():</span><br><span class="line">    host = <span class="string">&#x27;192.168.0.5&#x27;</span></span><br><span class="line">    port = <span class="string">&#x27;3306&#x27;</span></span><br><span class="line">    user = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">cls</span>):  <span class="comment"># 约定俗成第一个参数名为cls，也可以定义为其他参数名</span></span><br><span class="line">        <span class="built_in">print</span>(cls)</span><br><span class="line">        <span class="built_in">print</span>(cls.host + <span class="string">&#x27;:&#x27;</span> + cls.port + <span class="string">&#x27; &#x27;</span> + cls.user + <span class="string">&#x27;/&#x27;</span> + cls.password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Operate_database.connect();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Operate_database&#x27;</span>&gt;</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span>:<span class="number">3306</span> abc/<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<ul>
<li>非绑定方法:在类内部使用 @staticmethod 修饰的方法即为非绑定方法，这类方法和普通定义的函数没有区别，不与类或对象绑定，谁都可以调用(实例和类都可以)，且没有自动传值的效果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operate_database</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port, user, password</span>):</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_passwrod</span>(<span class="params">salt, password</span>):</span><br><span class="line">        m = hashlib.md5(salt.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 加盐处理</span></span><br><span class="line">        m.update(password.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">hash_password = Operate_database.get_passwrod(<span class="string">&#x27;lala&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)  <span class="comment"># 通过类来调用</span></span><br><span class="line"><span class="built_in">print</span>(hash_password)</span><br><span class="line"></span><br><span class="line">p = Operate_database(<span class="string">&#x27;192.168.0.5&#x27;</span>, <span class="string">&#x27;3306&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line">hash_password = p.get_passwrod(p.user, p.password)  <span class="comment"># 也可以通过对象调用</span></span><br><span class="line"><span class="built_in">print</span>(hash_password)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f7a1cc409ed6f51058c2b4a94a7e1956</span><br><span class="line">0659c7992e268962384eb17fafe88364</span><br></pre></td></tr></table></figure>

<h5 id="10-棱形继承"><a href="#10-棱形继承" class="headerlink" title="10. 棱形继承"></a>10. 棱形继承</h5><p>在多层继承和多继承同时使用的情况下，就会出现复杂的继承关系，即重重复继乘，常说的<strong>菱形继承</strong><br><img src="/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/lengxing.png" width="300"><br>在这种结构中，在调用顺序上就出现了疑惑，调用顺序究竟是以下哪一种顺序呢,如果是深度，那么A会重复调用，造成不必要的消耗</p>
<ul>
<li><code>D-&gt;B-&gt;A-&gt;C-&gt;A（深度优先）</code></li>
<li><code>D-&gt;B-&gt;C-&gt;A（广度优先）</code></li>
</ul>
<p>上面问题的根源都跟MRO有关,MRO(Method Resolution Order)也叫方法解析顺序，主要用于在多重继承时判断调的属性来自于哪个类，其使用了一种叫做C3的算法，其基本思想时在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则去寻找需要的属性和方法。<br><strong>要避免顶层父类某个方法被多次调用，此时就需要super()来发挥作用了,super本质上是一个类，内部记录着MRO信息，由于C3算法确保同一个类只会被搜寻一次，这样就避免了顶层父类中的方法被多次执行了</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意，这段代码是个特例，在D的注释处明显调用了B/C的构造函数，所有会执行两次A的构造函数，要使其不执行两次，则需要使用super().xxx()。这种方法很常用，应该熟记</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init A...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end A...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init B...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(B, self).__init__()</span><br><span class="line">		<span class="comment"># A.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end B...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init C...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(C, self).__init__()</span><br><span class="line">		<span class="comment"># A.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end C...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init D...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(D, self).__init__()</span><br><span class="line">		<span class="comment">#B.__init__(self)</span></span><br><span class="line">        <span class="comment">#C.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end D...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    D()</span><br></pre></td></tr></table></figure>
<p>输出：采用广度优先搜索</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init D...</span><br><span class="line">init B...</span><br><span class="line">init C...</span><br><span class="line">init A...</span><br><span class="line">end A...</span><br><span class="line">end C...</span><br><span class="line">end B...</span><br><span class="line">end D...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>值得一提的是Python类分为两种，一种叫经典类，一种叫新式类。都支持多继承，但继承方式不同：</p>
<ul>
<li><strong>新式类</strong>：从object继承来的类。（如:class A(object)），采用广度优先搜索的方式继承（即先水平搜索，再向上搜索）。</li>
<li><strong>经典类</strong>：不从object继承来的类。（如：class A()），采用深度优先搜索的方式继承（即先深入继承树的左侧，再返回，再找右侧）。</li>
</ul>
<p><em><strong>注意：Python2.x中类的是有经典类和新式类两种。Python3.x中都是新式类（类都默认继承object）。因此对于多重继承，顺序很重要，他会根据继承类在首行位置，从左到右搜索</strong></em><br>实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    attr=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    attr=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B,C):</span><br><span class="line">    <span class="keyword">pass</span>;</span><br><span class="line"></span><br><span class="line">M=D();</span><br><span class="line"><span class="built_in">print</span>(M.attr)		<span class="comment">#2</span></span><br></pre></td></tr></table></figure>
<p>上面的代码输出为2，先解释一下：因为B、C都继承自A，D继承自B\C，那么在python3.x版本以上，采用了广度优先，顺序是<code>D-&gt;B-&gt;C-&gt;A</code>,在C时遇到了属性<code>attr=2</code>，停止搜索返回，输出为2</p>
<h5 id="11-slots（可选）"><a href="#11-slots（可选）" class="headerlink" title="11. slots（可选）"></a>11. slots（可选）</h5><p>python类有一个双刃剑就是：即使我们没有在类内部创建属性，也可以在实例对象中通过<code>.</code>给实例对象创建一个属于实例的属性，这样听起来非常bug，不像java和c++这样有很好的封装性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a=A();</span><br><span class="line">a.p=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">print</span>(a.p) <span class="comment">#20</span></span><br></pre></td></tr></table></figure>
<p>之前提到过<code>__getattr__</code>能够对未在类内创建的属性提供操作。这里介绍python提供的<code>slots</code>来支持这一功能。<br>这个特殊属性一般是在类的顶层内将变量名称（字符串形式）按顺序赋值给变量<code>__slots__</code>，<strong>该属性规定：只有<code>__slots__</code>列表内的这些变量名可赋值为实例属性</strong>。它也要遵循python的规则，实例属性名必须在引用前赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>:</span><br><span class="line">	__slots__=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=limiter();</span><br><span class="line"><span class="comment">#print(x.age)		#AttributeError,未赋值就引用</span></span><br><span class="line">x.age=<span class="number">40</span></span><br><span class="line"><span class="built_in">print</span>(x.age)		<span class="comment">#40</span></span><br><span class="line">x.jk=<span class="number">2</span>;				<span class="comment">#不允许，变量名不在__slots__</span></span><br></pre></td></tr></table></figure>
<p>但是注意，类中有<code>__slots__</code>会没有<code>__dict__</code>属性，事实上，<code>__slots__</code>就是以<code>__dict__</code>的代价来起到这样一个功能的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>:</span><br><span class="line">	__slots__=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>,<span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=limiter();</span><br><span class="line">x.jk=<span class="number">2</span>;				<span class="comment">#运行成功</span></span><br></pre></td></tr></table></figure>
<p>没有<code>__dict__</code>，我们就不能在类的函数内随便起变量名，因此对于<code>__slots__</code>看情况使用</p>
<h5 id="12-函数装饰器和元函数"><a href="#12-函数装饰器和元函数" class="headerlink" title="12. 函数装饰器和元函数"></a>12. 函数装饰器和元函数</h5><p>装饰器一般有函数装饰器和类装饰器。</p>
<p><strong>11.1 函数装饰器</strong><br>函数装饰器提供了一种方式声明函数的特定运算模式，其原理是将函数包裹到另一个函数，在另一个函数的逻辑内实现。函数装饰器在def语句前一行，由**@符号、后面跟着所谓的元函数**组成。元函数就是管理另一函数（或其他可调用对象）的函数</p>
<p><strong>11.2 类装饰器</strong><br>类装饰器类似于函数装饰器（后续补充）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">python基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-24 09:07:58" itemprop="dateCreated datePublished" datetime="2022-06-24T09:07:58+08:00">2022-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-07 20:44:11" itemprop="dateModified" datetime="2022-07-07T20:44:11+08:00">2022-07-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="python的运行过程"><a href="#python的运行过程" class="headerlink" title="python的运行过程"></a>python的运行过程</h4><p><img src="https://img-blog.csdnimg.cn/9f0f1b3db22d4c1e8a5bdd455e7702a7.jpeg#pic_center"><br><strong>1. 字节码编译</strong><br>    当程序运行时,Python内部会将源代码(.py文件中的程序)编译成所谓的字节码的形式,就是将每一行源代码语句从上到下翻译过来,翻译成一组字节码的指令.这些字节码可以提高执行速度;比起源代码语句,字节码要执行快的多。<br>    它会将字节码保存为一个以pyc为扩展名的文件，Python这样保存字节码是一种作为启动速度的优化.下一次运行程序时,如果你还停留在上一次修改记录的话,就会直接跳过编译直接加载.pyc文件.</p>
<p><strong>2. PVM虚拟机</strong><br>py程序编译成字节码后，字节码文件会发送给PVM，也就是python虚拟机进行出来。PVM是python运行的引擎，从根本上讲，它才算是python解释器。python虚拟机就是去模拟可执行程序在x86机器上的运行</p>
<h4 id="python的内置对象"><a href="#python的内置对象" class="headerlink" title="python的内置对象"></a>python的内置对象</h4><p>python中没有类型声明，运行的表达式的语法决定了创建和使用对象的类型，正如以下表达式就是这些类型起源的地方。</p>
<table>
<thead>
<tr>
<th>column</th>
<th>column</th>
</tr>
</thead>
<tbody><tr>
<td>数字</td>
<td>1234，3.14159，3+4j</td>
</tr>
<tr>
<td>字符串</td>
<td>‘spaw’,”guidos”,”python”</td>
</tr>
<tr>
<td>列表</td>
<td>[1,[2,’there’],4]</td>
</tr>
<tr>
<td>字典</td>
<td>{‘food’:’spam’,’taste’:’yum’}</td>
</tr>
<tr>
<td>元组</td>
<td>(1,’spam’,4,’u’)</td>
</tr>
<tr>
<td>文件</td>
<td>my</td>
</tr>
<tr>
<td>&#x3D;open(‘eggs’,’r’)</td>
<td></td>
</tr>
<tr>
<td>集合</td>
<td>set(‘abs’),{‘a’,’b’,’s’}</td>
</tr>
</tbody></table>
<p>可迭代对象：字符串、列表、字典、元组、集合、文件对象<br>一些操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//数字整型</span><br><span class="line">s=<span class="number">546</span>;</span><br><span class="line">s=s*<span class="number">4</span>;</span><br><span class="line">//字符串</span><br><span class="line">s=<span class="string">&#x27;spam&#x27;</span>;</span><br><span class="line">k=<span class="built_in">len</span>(s); 	<span class="comment">#k=4</span></span><br><span class="line">s=s+<span class="string">&#x27;xyz&#x27;</span>;  <span class="comment">#s=&#x27;spamxyz&#x27;</span></span><br><span class="line">//序列操作</span><br><span class="line">s=<span class="string">&#x27;spam&#x27;</span>;</span><br><span class="line">q=s[<span class="number">0</span>];</span><br><span class="line">m=s[-<span class="number">1</span>];	<span class="comment">#字符串长度-1，即s[4-1]</span></span><br><span class="line">t=s[<span class="number">0</span>:<span class="number">3</span>]	<span class="comment">#从下标0开始，输出三个字符，即t=&#x27;spa&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>重要性质：</strong><br><strong>python的对象内存不可变性：</strong>在上面所写的例子中没有通过任何操作对原始字符串即spam变动，字符串在python中具有不可变性，在创建后就不可改变，但比总可以通过建立一个新的字符串并以同一个名字对其进行赋值（如<code>s=s+&#39;xyz&#39;</code>)，因为python在运行过程中会清理旧对象（动态类型）。<strong>一旦改变便意味是产生了新的对象</strong></p>
<h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p><strong>1. 一些内置的数学函数：</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>abs()</td>
<td>取绝对值</td>
</tr>
<tr>
<td>pow()</td>
<td>计算任意N次方值</td>
</tr>
<tr>
<td>min()\max()</td>
<td>取最小值\最大值</td>
</tr>
<tr>
<td>divmod()</td>
<td>同时取商和余数</td>
</tr>
<tr>
<td>sum()</td>
<td>求和</td>
</tr>
<tr>
<td>round()</td>
<td>四舍五入</td>
</tr>
<tr>
<td>hex()</td>
<td>十进制转为十六进制</td>
</tr>
</tbody></table>
<p><strong>2. 表达式操作符</strong></p>
<p>与C&#x2F;C++有些不同：<br><img src="https://img-blog.csdnimg.cn/57b3415f38e34a2a96c5b56f1dd1bffa.jpeg#pic_center"></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><strong>1. raw字符串抑制转义</strong><br>转义序列用来处理嵌入在自符串中的特殊字节编码很合适，但有些场合我们希望不要发生转义，如文件路径中<code>myfile=open(&#39;C:\new\test.txt&#39;,&#39;w&#39;)。</code>本意想打开这个文件，但是因为转义字符<code>\n</code>的存在。如果字母<code>r</code>出现在字符串第一个引号钱，意味着关闭转义：&#96;myfile&#x3D;open(R’C:\new\test.txt’,’w’)’</p>
<p><strong>2. 常见操作</strong><br>对于python的字符串，无论是<code>&quot;&quot;</code>还是<code>&#39;&#39;</code>都一样,支持串与串的相加，支持串与数的相乘，但不允许串与数的相加。同时支持负偏移和分片操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;trluper&quot;</span>;	<span class="comment">#合法</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;	<span class="comment">#合法</span></span><br><span class="line">c=<span class="built_in">str</span>[-<span class="number">1</span>];		<span class="comment">#str[len(str)-1]=str[6]</span></span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>+<span class="string">&#x27;github&#x27;</span>;</span><br><span class="line"><span class="built_in">str</span>*=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">str</span>+=<span class="number">4</span>;			<span class="comment">#error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r</span><br><span class="line">trlupergithub</span><br><span class="line">trlupergithubtrlupergithubtrlupergithubtrlupergithub</span><br></pre></td></tr></table></figure>

<p><strong>分片：</strong><code>Str[i:j]</code>i表示从下标为i的开始，小标j结束（不包括j）(i未输入时默认为0，j未说明默认为到最后一个元素)。即<code>str[1:-1]</code>,表示从r开始到e结束（<code>len(str)-1=6</code>），<strong>分片会产生新对象。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br><span class="line">s=<span class="built_in">str</span>[<span class="number">1</span>:-<span class="number">1</span>];</span><br><span class="line"><span class="built_in">print</span>(s);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlupe</span><br></pre></td></tr></table></figure>
<p><strong>扩展分片：</strong>分片表达式有可选的第三个索引，用作步进<code>str[i:j:k]</code>，未声明时k默认为1，表示隔几个元素取</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br><span class="line">s=<span class="built_in">str</span>[<span class="number">1</span>:-<span class="number">1</span>:<span class="number">2</span>];</span><br><span class="line"><span class="built_in">print</span>(s);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rue</span><br></pre></td></tr></table></figure>
<p><strong>3. 字符串转换</strong><br>上面讲到字符串和数字之间无法相加，会发生错误，为解决这方面问题，python提供了字符串和数字间的转换函数：</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>int(string s)</td>
<td>将字符串转换为数字</td>
</tr>
<tr>
<td>str(int i)</td>
<td>将数字转换为字符串</td>
</tr>
<tr>
<td>float(string s)</td>
<td>将字符串转换为浮点数</td>
</tr>
<tr>
<td>repr(object)</td>
<td>将对象转换为字符串并返回一个字符串对象</td>
</tr>
<tr>
<td>ord(char c)</td>
<td>将单个字符转为ascii码</td>
</tr>
<tr>
<td>chr(int i)</td>
<td>将数字转换为对于的ascii码</td>
</tr>
</tbody></table>
<p><strong>4. 修改&#x2F;查询字符串</strong><br>对于不可变性质，如果我们要改变原有字符串的一些值，则需要利用合并、分片这样的工具来重新建立并赋值一个新字符串或者<code>replace</code>，若有必要（程序的方便和易读），需要将结果重新赋值给原变量名。查找可以使用<code>find()</code>函数或者判断<code>“Trl&quot; in str</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;Trluper!&#x27;</span>;</span><br><span class="line"><span class="built_in">str</span>[<span class="number">0</span>]=<span class="string">&#x27;t&#x27;</span>;	<span class="comment">#error</span></span><br><span class="line">//分片合并</span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>[:<span class="number">3</span>]+<span class="string">&quot;user&quot;</span>+<span class="built_in">str</span>[-<span class="number">1</span>];</span><br><span class="line">//replace</span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>.replace(<span class="string">&quot;uper&quot;</span>,<span class="string">&quot;user&quot;</span>);</span><br><span class="line">//查找</span><br><span class="line"><span class="built_in">str</span>.find(<span class="string">&quot;trl&quot;</span>);	<span class="comment">#找到返回第一个下标，未找到则返回-1</span></span><br><span class="line">“trl” <span class="keyword">in</span> <span class="built_in">str</span>;		<span class="comment">#return True or false</span></span><br></pre></td></tr></table></figure>

<p><strong>5.字符串格式化</strong><br>字符串格式化提供了一种组合字符串处理任务的处理思想。在python中有两种形式的<em>字符串格式化表达式</em>：</p>
<ol>
<li>基于C的<code>printf模型</code>:在%左侧放置字符串，字符串中带有一个或多个嵌入目标*(即%d、%s、%c这些)*，%右侧放置一个元组或字典 。</li>
<li>python的字符串的<code>format函数</code>：通过花括号的位置或者关键字指出替换目标</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于元组的字符串格式化：</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;my name is %s,and I am %d years old&quot;</span> %(<span class="string">&quot;trluper&quot;</span>,<span class="number">24</span>);</span><br><span class="line"><span class="comment">#基于字典</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;my name is %(name)s,and I am %(age)d years old&quot;</span> % &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>&#125;;</span><br><span class="line"><span class="comment">#format函数</span></span><br><span class="line">template=<span class="string">&quot;my name is &#123;0&#125;,and i am &#123;age&#125; years old&quot;</span> ;</span><br><span class="line"><span class="built_in">str</span>=template.<span class="built_in">format</span>(<span class="string">&quot;trluper&quot;</span>,age=<span class="number">24</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> I am <span class="number">24</span> years old</span><br><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> I am <span class="number">24</span> years old</span><br><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> i am <span class="number">24</span> years old</span><br></pre></td></tr></table></figure>



<h4 id="字符串的函数接口"><a href="#字符串的函数接口" class="headerlink" title="字符串的函数接口"></a>字符串的函数接口</h4><p><strong>1. 字符串查询</strong><br>建议使用<code>find</code>，因为如果没有找到匹配的字符串，<code>index</code>方法会报异常。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>find(str, beg&#x3D;0, end&#x3D;len(string))</td>
<td>查找子串str第一次出现的位置，如果找到则返回相应的索引，否则返回-1</td>
</tr>
<tr>
<td>rfind(str, beg&#x3D;0,end&#x3D;len(string))</td>
<td>类似于 find()函数，不过是从右边开始查找</td>
</tr>
<tr>
<td>index(str, beg&#x3D;0, end&#x3D;len(string))</td>
<td>类似于find，只不过如果没找到会报异常。</td>
</tr>
<tr>
<td>rindex(str, beg&#x3D;0 end&#x3D;len(string))</td>
<td>类似于rfind，如果没有匹配的字符串会报异常</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;my name is qlee，what your name?&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2))<span class="comment">#全部查找</span></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2,<span class="number">5</span>))<span class="comment">#从第5个元素开始查找</span></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2,<span class="number">35</span>))<span class="comment"># 从第35个元素开始查找，超过元素索引或者没找到，不会报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2. 字符串大小写转换操作（upper、lower、swapcase、capitalize和title）</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>upper</td>
<td>将字符串中所有元素都转为大写</td>
</tr>
<tr>
<td>lower</td>
<td>将字符串中所有元素都转为小写</td>
</tr>
<tr>
<td>swapcase</td>
<td>交换大小写。大写转为小写，小写转为大写</td>
</tr>
<tr>
<td>capitalize</td>
<td>第一个大写，其余小写</td>
</tr>
<tr>
<td>title</td>
<td>每个单词的第一次字符大写，其余均为小写</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="string">&quot;my name is Qlee&quot;</span></span><br><span class="line"><span class="built_in">print</span>(txt.upper())</span><br><span class="line"><span class="built_in">print</span>(txt.lower())</span><br><span class="line"><span class="built_in">print</span>(txt.swapcase())</span><br><span class="line"><span class="built_in">print</span>(txt.capitalize())</span><br><span class="line"><span class="built_in">print</span>(txt.title())</span><br></pre></td></tr></table></figure>

<p><strong>3. 字符串对齐（center，just和zfill）</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>center(width, fillchar)</td>
<td>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td>
</tr>
<tr>
<td>ljust(width[, fillchar])</td>
<td>返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td>
</tr>
<tr>
<td>rjust(width,[, fillchar])</td>
<td>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td>
</tr>
<tr>
<td>zfill (width)</td>
<td>返回长度为 width 的字符串，原字符串右对齐，前面填充0</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.center(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.ljust(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.rjust(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.zfill(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*********hello world!*********</span><br><span class="line">hello world!******************</span><br><span class="line">******************hello world!</span><br><span class="line">000000000000000000hello world!</span><br></pre></td></tr></table></figure>
<p><strong>4.  分割字符串(split、splitlines和partition)</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>split(seq&#x3D;””, num&#x3D;string.count(str))</td>
<td>以 seq (默认空格)为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串(只需num个seq分隔符)。分割后得到新列表</td>
</tr>
<tr>
<td>rsplit</td>
<td>与split类似，不过是从右边开始分割</td>
</tr>
<tr>
<td>splitlines</td>
<td>按照行进行分割，得到新的列表</td>
</tr>
<tr>
<td>partition(str)</td>
<td>找到字符串中第一个str，并以str为界，将字符串分割为3部分，返回一个新的元组</td>
</tr>
<tr>
<td>rpartition(str)</td>
<td>与partition类似，只不过是反向找</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;my name is qlee, what is your name&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split())       <span class="comment"># 以空格为分隔符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split(<span class="string">&#x27;i&#x27;</span>,<span class="number">1</span>))   <span class="comment"># 以 i 为分隔符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split(<span class="string">&#x27;b&#x27;</span>))     <span class="comment"># 以b为分隔符,没找到不会报错</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.partition(<span class="string">&quot;name&quot;</span>))<span class="comment">#找到第一个name，分割为三部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.rpartition(<span class="string">&quot;name&quot;</span>))<span class="comment">#反向找到第一个name，分割为三部分</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;&quot;&quot;my name is qlee</span></span><br><span class="line"><span class="string">      what is your name&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.splitlines())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;qlee,&#x27;</span>, <span class="string">&#x27;what&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;your&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;my name &#x27;</span>, <span class="string">&#x27;s qlee, what is your name&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;my name is qlee, what is your name&#x27;</span>]</span><br><span class="line">(<span class="string">&#x27;my &#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27; is qlee, what is your name&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;my name is qlee, what is your &#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;my name is qlee&#x27;</span>, <span class="string">&#x27;      what is your name&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5. 合并与替换(join，replace)</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>join(seq)</td>
<td>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td>
</tr>
<tr>
<td>replace(old, new [, max])</td>
<td>把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------join-----------&quot;</span>)</span><br><span class="line">seq1 = (<span class="string">&quot;h&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>) <span class="comment">#元组</span></span><br><span class="line">seq2 = [<span class="string">&quot;h&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>] <span class="comment">#列表</span></span><br><span class="line">seq3 = <span class="string">&quot;hello&quot;</span> <span class="comment">#字符串</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;&quot;</span>.join(seq1)) <span class="comment">#无分隔符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot; &quot;</span>.join(seq1))<span class="comment">#空格</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;,&quot;</span>.join(seq1))<span class="comment">#&quot;,&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------replace-----------&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;my name is qlee&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.replace(<span class="string">&quot;qlee&quot;</span>, <span class="string">&quot;lq&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------join-----------</span><br><span class="line">hello</span><br><span class="line">h e l l o</span><br><span class="line">h,e,l,l,o</span><br><span class="line">----------replace-----------</span><br><span class="line">my name <span class="keyword">is</span> lq</span><br></pre></td></tr></table></figure>

<p><strong>6. 字符串的比较(&lt;,&gt;,max,min等)</strong><br>字符串的比较操作：</p>
<ul>
<li>运算符：&gt; , &gt;&#x3D;, &lt;, &lt;&#x3D;, &#x3D;&#x3D;, !&#x3D;</li>
<li>比较规则：从第一个以此往下比较。</li>
<li>比较原理：比较的是oridinal value(原始值，即ascii码值)</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>max(str)</td>
<td>返回字符串 str 中最大的字母</td>
</tr>
<tr>
<td>min(str)</td>
<td>返回字符串 str 中最小的字母</td>
</tr>
<tr>
<td>ord</td>
<td>将指定字符转换为原始值</td>
</tr>
<tr>
<td>chr</td>
<td>将原始值转换为对应的字符</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;mynameisqlee&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;max(str): &quot;</span>, <span class="built_in">max</span>(<span class="built_in">str</span>),<span class="string">&quot;min(str): &quot;</span>, <span class="built_in">min</span>(<span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> &lt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;c&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">98</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="built_in">str</span>):  y <span class="built_in">min</span>(<span class="built_in">str</span>):  a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p><strong>7. 判断字符串(isidentifier、isspace、isalpha、isdecimal、isnumeric和isalnum等)</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>isidentifier</td>
<td>判断字符串是不是合法标识符(字符、数字、下划线)</td>
</tr>
<tr>
<td>isspace</td>
<td>判断字符是否只有空白字符(回车、换行和水平制表符)</td>
</tr>
<tr>
<td>isalpha</td>
<td>判断字符串是否全部由字母组成</td>
</tr>
<tr>
<td>isdecimal</td>
<td>判断字符是否全部由十进制的数字组成，不包括中文、罗马字符</td>
</tr>
<tr>
<td>isdigit</td>
<td>判断字符串只包含数字，不包括中文数字</td>
</tr>
<tr>
<td>isnumeric</td>
<td>判断字符串是否全部由数字组成，中文数字也算</td>
</tr>
<tr>
<td>isalnum</td>
<td>判断字符串是否由字母和数字组成</td>
</tr>
<tr>
<td>islower</td>
<td>判断字符串中的字符是否全部为小写，字符串至少有一个字符</td>
</tr>
<tr>
<td>isupper</td>
<td>判断字符串中的字符是否全部为大写，字符串至少有一个字符</td>
</tr>
<tr>
<td>istitle</td>
<td>判断字符串是否标题话，见titile</td>
</tr>
<tr>
<td>isascii</td>
<td>如果字符串为空或字符串中的所有字符都是 ASCII，则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>isprintable</td>
<td>如果所有字符都是可打印的，则 isprintable() 方法返回 True，否则返回 False。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&amp;&quot;</span>.isidentifier())<span class="comment">#False,&amp;为非法标识符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   t&quot;</span>.isspace())<span class="comment">#False,&quot;t&quot;为非空</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aldflafd你好&quot;</span>.isalpha())<span class="comment">#ture,中文也可以</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isdecimal())<span class="comment">#False,中文不属于十进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isnumeric())<span class="comment">#True,中文、罗马字符的数字也算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123abc&quot;</span>.isalnum())<span class="comment">#True,只能字母和数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isdigit())<span class="comment">#False，不能包括中文</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.islower())<span class="comment"># False,不能为空字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;TLUHBH&quot;</span>.isupper())<span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My Name Is Qlee&quot;</span>.istitle())<span class="comment">#True,只有第一个字符为大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是中国人&quot;</span>.isascii())<span class="comment">#False，中文不属于ascii</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello!\nAre you ?&quot;</span>.isprintable()) <span class="comment">#False,\n不可打印</span></span><br></pre></td></tr></table></figure>
<h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><p>字符串对象的方法能够支持基于模式的文本出处理，文本的模式匹配是一个高级工具，需要导入一个re模块，这个模块包含了搜索、分割和替换等调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re;</span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;Hello  se es ra df world&quot;</span>;</span><br><span class="line">match=re.match(<span class="string">&#x27;Hello[\t]*(.*)world&#x27;</span>,<span class="built_in">str</span>);</span><br><span class="line">gr=match.group(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(gr);</span><br></pre></td></tr></table></figure>
<p>上面这个例子是在以Hello未开始，后面接这几个或零个制表符或空格的，接着将任意字符保存至组中，后以world结尾的str，<br>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">se es ra df</span><br></pre></td></tr></table></figure>

<h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h4><p>python的列表对象是一个任意类型对象的位置相关的有序集合，没有固定大小，不像C++数组那样，它没有固定类型的约束，同时python的核心数据类型一个优秀特性就是能支持任意类型的嵌套。<strong>同字符串不同，列表是可变对象，支持在原处修改</strong>，总结性质如下：</p>
<ul>
<li>列表是保持从左到右的序列，列表内存储的元素没有类型限制，也支持任意嵌套</li>
<li>列表可以像字符串一样索引、分片和合并</li>
<li>与字符串不同的是，列表是可变的，支持在原处修改。同时列表的长度可以改变</li>
<li>在python解释器内部，列表就是C数组，而不是链结构</li>
<li>存储的是对象引用，而不是拷贝，因此从这来看很像C&#x2F;C++的指针数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#包含了整型、字符串、浮点数</span></span><br><span class="line">L=[<span class="number">123</span>,<span class="string">&quot;spam&quot;</span>,<span class="number">1.23</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">#一些接口</span></span><br><span class="line">append(<span class="built_in">object</span>, /)	<span class="comment">#将任意object在列表尾部插入</span></span><br><span class="line">pop();				<span class="comment">#移除给定偏移项</span></span><br><span class="line">insert();			<span class="comment">#插入元素</span></span><br><span class="line">remove（）;			<span class="comment">#按照值移除</span></span><br><span class="line">sort();				<span class="comment">#安照默认的升序排序</span></span><br><span class="line">reverse();			<span class="comment">#翻转</span></span><br><span class="line"><span class="keyword">del</span> L[i]			<span class="comment">#删除指定位置元素</span></span><br></pre></td></tr></table></figure>

<h4 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h4><p>处理序列和列表的方法中，python还包括了一个更高级的的操作，称为列表解析表达式.<strong>列表解析最常应用迭代协议的环境之一</strong>，列表解析把任意一个表达式应用于一个迭代对象中的元素。它可提供一种处理矩阵这样的数据结构。假如现在要从矩阵中提取第二列，使用列表解析可以很简单提取出来：<code>row[1]for row in AOI_world</code>,这种表达式有许多玩法，如<code>row[1]for row in AOI_world if row[1]%2==0</code></p>
<ul>
<li>列表解析编写代码比for循环更精简</li>
<li>执行速度更快</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AOI_world=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]];</span><br><span class="line">col2=[row[<span class="number">1</span>]<span class="keyword">for</span> row <span class="keyword">in</span> AOI_world];</span><br><span class="line"><span class="built_in">print</span>(col2);</span><br><span class="line"></span><br><span class="line"><span class="comment">#更爽的用法,rstrip函数去除右边的空白，使用if滤除开头不为p的字符串</span></span><br><span class="line">lines=[line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">if</span> line[<span class="number">0</span>]==<span class="string">&#x27;p&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>当然其他相关函数内容如<code>map</code>，<code>filter</code>还未介绍，但列表解析这里可以涉及一些。列表解析说白了，就是把任意一个表达式应用于一个可迭代对象中的元素，并将结束收集到一个新列表中。列表解析能够成为比<code>filter,map</code>更有用的函数工具：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用map</span></span><br><span class="line">res=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>,<span class="string">&#x27;trluper&#x27;</span>));</span><br><span class="line"><span class="comment">#用列表解析</span></span><br><span class="line">res=[<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;trluper&#x27;</span>];</span><br><span class="line"><span class="comment">#使用if的列表解析能有与filter一样的过滤功能</span></span><br><span class="line">res=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"><span class="comment">#嵌套for循环</span></span><br><span class="line">res=[x+y <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]];</span><br></pre></td></tr></table></figure>
<p><em><strong>注意</strong></em>：列表解析会产生一个新列表对象。</p>
<h4 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典(Dictionary)"></a>字典(Dictionary)</h4><p>字典是一种映射，是一个键值对集合，通过键值获取相应的值，字典具有可变性，可以随需求增大或减小，像列表那样。字典页可以嵌套，性质总结：</p>
<ul>
<li>字典其实就是散列表也叫哈希表，通过键对生成哈希码而找到值，通过键值对映射类型</li>
<li>与列表不同，字典是无序，保存在字典中的项没有特定的顺序，因此不支持序列操作，如下标访问，是通过键值访问，键值是不可重复的</li>
<li>与列表一样，可变长，存储的元素可为任意类型，支持任意嵌套，可以在原处修改；存储的是对象引用，而不是拷贝<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keyValue_test=&#123;<span class="string">&#x27;food&#x27;</span>:<span class="string">&#x27;fish&#x27;</span>,<span class="string">&#x27;quantity&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;price&#x27;</span>:<span class="number">50</span>&#125;;</span><br><span class="line">fod_name=keyValue_test[<span class="string">&#x27;food&#x27;</span>];</span><br></pre></td></tr></table></figure>
<strong>字典常用函数：</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;fish&quot;</span> <span class="keyword">in</span> keyValue;		<span class="comment">#键存在判断</span></span><br><span class="line">D.keys();				<span class="comment">#返回所有键,可迭代对象</span></span><br><span class="line">D.values();				<span class="comment">#返回所有值,可迭代对象</span></span><br><span class="line">D.items();				<span class="comment">#键+值,可迭代对象</span></span><br><span class="line">D.copy();				<span class="comment">#拷贝</span></span><br><span class="line">D.get(key,\);			<span class="comment">#返回key对应的值，相当于D[key]</span></span><br><span class="line">D.update(D1);			<span class="comment">#合并字典</span></span><br><span class="line">D.pop(key);				<span class="comment">#删除键值对</span></span><br><span class="line"><span class="built_in">len</span>(D);					<span class="comment">#长度</span></span><br><span class="line"><span class="keyword">del</span> D[key];</span><br><span class="line"><span class="built_in">list</span>(D.keys())			<span class="comment">#生成键序列</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>1. 键的排序</strong></p>
<ul>
<li><p>因为字典不是序列，不包含任何可靠的从左到右的顺序排序方法，当我们需要强调某种顺序时，一个常用方法就是通过字典的keys方法收集一个键的列表，使用列表的<code>sort</code>方法进行排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_list=<span class="built_in">list</span>(d.keys());</span><br><span class="line"><span class="built_in">print</span>(key_list);</span><br><span class="line">key_list.sort();</span><br><span class="line"><span class="built_in">print</span>(key_list);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;quantity&#x27;</span>, <span class="string">&#x27;buyer&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;buyer&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;quantity&#x27;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种方法是通过使用最新的<code>sorted</code>内置函数可以一步完成，<code>sorted</code>调用后会返回排序后的新列表对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="built_in">sorted</span>(d);</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(key,<span class="string">&quot;==&gt;&quot;</span>,d[key]);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buyer ==&gt; TOM</span><br><span class="line">food ==&gt; fish</span><br><span class="line">price ==&gt; <span class="number">50</span></span><br><span class="line">quantity ==&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h4><p>set集合是无序的，它既不是映射也不是序列，可以说它是存储无值的键，而且键值唯一不可变</p>
<p>创建集合对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python2.6版</span></span><br><span class="line">x=<span class="built_in">set</span>(<span class="string">&#x27;abcde&#x27;</span>);</span><br><span class="line">y=<span class="built_in">set</span>(<span class="string">&#x27;bdxyz&#x27;</span>);</span><br><span class="line"></span><br><span class="line">z=x&amp;y</span><br><span class="line"><span class="built_in">print</span>(z);</span><br><span class="line"></span><br><span class="line">i=x.intersection(y);</span><br><span class="line"><span class="built_in">print</span>(i);</span><br><span class="line">x.add(<span class="string">&#x27;trluper&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line">x.update(<span class="built_in">set</span>([<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;y&#x27;</span>]));</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line">x.remove(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.0</span></span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>


<h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h4><p>元组对象是一个不可改变的列表，他有列表的有序性，但没有列表的可变性，和字符串类似。它们编写在圆括号<code>()</code>而不是<code>[]</code>和<code>&#123;&#125;</code>内,**<code>()</code>**时可选的，不是必须，。它们支持任意类型和任意嵌套。元组提供了不可变这一项约束是使用它的原因，否则使用列表。性质总结：</p>
<ul>
<li>元组是位置有序的对象集合，因此支持下标访问，支持分片。</li>
<li>与字符串一样，元组是不可比变的，不能在原处进行修改。因此元组也就是长度不可变的，在不生产一个新对象下不能增长或缩短</li>
<li>元组内的元素可为任意类型且为引用，而不是拷贝，支持任意嵌套</li>
<li>元组不支持任何方法调用，但是支持字符串和列表的一般序列操作：合并、倍乘、分块</li>
</ul>
<p>一般操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T=(elements);   <span class="comment">#创建元组</span></span><br><span class="line">T=i,j,k,l		<span class="comment">#省略()创建元组</span></span><br><span class="line">T[j];			<span class="comment">#访问</span></span><br><span class="line">T[i:j];			<span class="comment">#分块</span></span><br><span class="line"><span class="built_in">len</span>(T);			<span class="comment">#长度</span></span><br><span class="line">T1+T2;			<span class="comment">#合并</span></span><br><span class="line">T*<span class="number">3</span>;			<span class="comment">#内容倍乘</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> T:		<span class="comment">#迭代</span></span><br><span class="line">“trlupe<span class="string">r&quot; in T;	#元组内是否有该元素</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>在python3.0以上，有元组的专有调用方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index(element);		<span class="comment">#查询元素下标</span></span><br><span class="line">count(element);		<span class="comment">#统计元素出现过几次</span></span><br></pre></td></tr></table></figure>

<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>文件对象提供了python编程对外部文件操作的接口，要创建一个文件对象，就必须调用内置的<code>open</code>函数打开问文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_object=<span class="built_in">open</span>(<span class="string">&quot;*.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>除了<code>open</code>这个函数，python还有额外的类文件工具：管道、FIFO、套接字、通过键访问文件、对象吃久、基于描述符的文件、关系数据库等.</p>
<p><strong>文件常用函数接口：</strong><br><img src="/images\file.jpg" width="500"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_name=<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">lines=file_name.readlines();	<span class="comment">#读取整个文件到列表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em><strong>注意：</strong></em>在写入时，我们必须将对象转换成字符串，同样在读出时，我们也必须用转换工具将文本文件中的字符串转换乘python对象</p>
<h4 id="python的动态类型"><a href="#python的动态类型" class="headerlink" title="python的动态类型"></a>python的动态类型</h4><p><strong>1. 动态类型是什么</strong><br>python的动态类型是为什么在python不必声明变量的存在和类型的缘由。** python使用动态类型和他提供的多态性来提供python语言的简洁灵活的基础。在python中我们是不会声明所使用对象的确切类型的。所谓的python动态类型，就是在程序运行的过程中自动决定对象的类型。**</p>
<ul>
<li>与C&#x2F;C++明显不同的是，在python中，变量只是一个名字，它永远不会有任何类型约束，变量是通用的，在python中类型的概念只存在于对象中。</li>
<li>变量在赋值的时候才创建，即没有声明，当变量出现在表达式中，它会被当前引用的对象所替代，无论该对象是什么类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">就如a=<span class="number">3</span>这个简单的赋值语句，python分步：</span><br><span class="line">	<span class="number">1.</span>创建一个对象代表<span class="number">3</span>，</span><br><span class="line">　　<span class="number">2.</span>如果程序中没有变量a，则创建他。</span><br><span class="line">　　<span class="number">3.</span>将变量与对象<span class="number">3</span>连接起来。</span><br></pre></td></tr></table></figure>
<ul>
<li>变量和对象保存在内存中的不同部分，变量只是对对象的引用，这样来说变量更像是C&#x2F;C++中的vodi*指针<br>　 　1. 变量是系统表的元素，他指向对象存放的地址空间<br>　 　2. 对象是分配的一块内存，地址可被连接，有足够大空间代表对象的值，每个对象都有两个标准头部信息：一是类		型标识符（标识对象类型），二是引用计数器（垃圾回收）。<ul>
<li>2.1 <strong>类型标识符</strong>：对象知道自己的类型，一旦与变量连接，程序执行中也就知道变量是引用了哪种类型的对象。</li>
<li>2.2 <strong>引用计数</strong>每当对象被引用到一个变量是，其引用计数会+1，反之则-1，当引用计数为0是，该对象的内存空间被自动回收，这种性质很想C++的智能指针shared_ptr，意味着我们在使用过程中不需要考虑对象内存释放的问题.</li>
<li>2.3 引用的过程自动完成变量指向对象地址的过程，即从变量到对象的指针</li>
</ul>
</li>
</ul>
<p><strong>2. 共享引用</strong></p>
<ul>
<li><p>之前我们就提到过，在python中对象是不可变性的，一旦发生改变便意味这新对象的产生。共享引用也是如此：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span>; <span class="comment">#a指向对象，对象值为3，对象引用为1</span></span><br><span class="line">b=a; <span class="comment">#b也指向该对象，对象引用为2</span></span><br><span class="line">b=b+<span class="number">2</span>; <span class="comment">#产生新对象5，引用计数为1，a所引用的对象仍为3，引用计数为1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但有一些对象和操作也确实会在原处修改对象，如列表、字典以及一些通过class语句定义的对象，对列表的一个位置进行赋值会改变这个列表对象，而不是生成一个新列表（想想也是，如果每次都有生成一个新列表，那么对于数量极大的列表来说，其消耗的时间是极大的）,如果不想这样，使用copy函数进行拷贝成一个新对象，指向内容相同但内存不同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同上面一样创建了新对象42，没有影响原对象</span></span><br><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">L1=L2;</span><br><span class="line">L2=<span class="number">42</span>;</span><br><span class="line"><span class="comment">#原处修改,L1和L2均变为[42,2,3]</span></span><br><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">L1=L2;</span><br><span class="line">L1[<span class="number">0</span>]=<span class="number">42</span>;</span><br><span class="line"><span class="comment">#copy函数防止原处修改，</span></span><br><span class="line"><span class="keyword">import</span> copy;</span><br><span class="line">L2=copy.copy(L1);</span><br></pre></td></tr></table></figure></li>
<li><p>共享引用和相等：<code>==操作符</code>，测试两个引用对象值是否相同；<code>is操作符</code>,检查对象的同一性，是否内存地址一样</p>
</li>
</ul>
<p><strong>3.引用和拷贝</strong><br>到这里，应该知道了引用和拷贝的区别：</p>
<ul>
<li>引用是指变量名指向对象，多个引用都是指向同意内存地址</li>
<li>而拷贝是对原对象的一份拷贝，会在PVM中开辟一份自己的内存地址存储</li>
</ul>
<p>在python中赋值操作总是存储对象的引用，而不是拷贝。如果有些时候我们不希望因多个对象的引用中的改变而造成影响（如上面所举列表例子），那么就应该用拷贝：</p>
<ul>
<li>没有限制条件的分片语句会产生一份拷贝</li>
<li>copy方法产生一份拷贝</li>
<li>一些内置函数，如list(L)产生一份拷贝</li>
</ul>
<h4 id="python语句"><a href="#python语句" class="headerlink" title="python语句"></a>python语句</h4><p><strong>1. 与C&#x2F;C++完全不同点:</strong></p>
<ul>
<li>python中所有的嵌套语句的首行以<code>:</code>结尾</li>
<li>python中不像C&#x2F;C++,可省略嵌套语句的<code>()</code>，如<code>if x&gt;y:</code>,如果单条if\for\while语句超过，则必须加<code>()</code></li>
<li>每个语句最后的<code>;</code>不是必须的，可省略，但是当一行有多条语句用<code>;</code></li>
<li>缩进的结束就是代码块的结束，python没有用<code>&#123;&#125;</code>来标识代码块，而是看缩进</li>
</ul>
<p><strong>2. 赋值和打印</strong><br><strong>2.1 赋值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;trluper&quot;</span></span><br><span class="line"><span class="built_in">str</span>,s=<span class="string">&quot;trl&quot;</span>,<span class="string">&quot;uper&quot;</span></span><br><span class="line">a,b,c,d=<span class="string">&#x27;trlu&quot;	#a=&#x27;</span>t<span class="string">&#x27;,b=&#x27;</span><span class="string">r&#x27;,c=&#x27;</span>l<span class="string">&#x27;,d=&#x27;</span><span class="string">u&#x27;</span></span><br><span class="line"><span class="string">a,*b=&quot;trluper&quot; #a=&#x27;</span>t<span class="string">&#x27; b=[&#x27;</span><span class="string">r&#x27;,&#x27;</span>l<span class="string">&#x27;,&#x27;</span><span class="string">u&#x27;,&#x27;</span>p<span class="string">&#x27;,&#x27;</span>e<span class="string">&#x27;,&#x27;</span><span class="string">r&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>在上面的表达式可以看到，<code>*b</code>并不是C&#x2F;C++中的指针，而是告诉赋值表达式变量<code>b</code>匹配剩下的内容成列表</p>
<p><strong>2.2 打印</strong><br>python中print的语法:<code>print([object,...][,sep=&#39; &#39;][,end=&#39;\n&#39;][,file=sys.stdout]);</code>在表示中，方括号的的项是可选的，且这些参数跟在要打印的对象后面，以<code>name=value</code>形式出现。</p>
<ul>
<li>object指要打印的对象</li>
<li>sep表示没打印一个对象，都有输出一个空格。(没有显式传递，则默认<code> </code>)</li>
<li>end表示在打印末尾输出换行符（没有传递就默认<code>\n</code>）</li>
<li>file表示要将这些对象输出给文件、标准流还是其他文件对象。(没有显示说明，则默认<code>sys.stdout</code>)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log=<span class="built_in">open</span>(<span class="string">r&#x27;D:\Python_WorkSpace\test.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;唱&quot;</span>,<span class="string">&quot;跳&quot;</span>,<span class="string">&quot;rap&quot;</span>,<span class="string">&quot;篮球&quot;</span>,sep=<span class="string">&#x27;*&#x27;</span>,end=<span class="string">&#x27;\n&#x27;</span>,file=log);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3. python的布尔值</strong><br>对于python的bool类型来说，其true和false的判断：</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>True&#x2F;False</th>
<th>情况</th>
<th>True&#x2F;False</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>F</td>
<td>空map{}</td>
<td>F</td>
</tr>
<tr>
<td>数值0</td>
<td>F</td>
<td>False</td>
<td>F</td>
</tr>
<tr>
<td>空序列</td>
<td>F</td>
<td>对象为空</td>
<td>F</td>
</tr>
</tbody></table>
<p><strong>4. 判断循环语句</strong><br><strong>4.1 if&#x2F;elif&#x2F;else</strong><br>python中没有C&#x2F;C++中的<code>switch case</code>语句块，要做判断选择只有用<code>if</code>语句,在python中没有<code>&#123;&#125;</code>作为语句块边界标识，只能靠左侧的缩进来判断语句属于哪一部分:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a==b <span class="keyword">and</span> c==d <span class="keyword">and</span> d==e):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;相等&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> c==d <span class="keyword">and</span> d==e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;cde相等&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;不相等“)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#三目运算</span></span><br><span class="line"><span class="string">A=Y if X else Z;	#X为真时A=Y,false时为A=Z</span></span><br></pre></td></tr></table></figure>
<p><strong>4.2 while语句</strong><br>while语句书写格式时：首行以及测试表达式，内部有一行或多行缩进语句主题执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">0</span>;b=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> a&lt;b:</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">    a+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;a不小于b&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>4.3 for语句</strong><br>for循环不同与c&#x2F;c++，在python中，它通常是用作序列迭代器，可以遍历任何有序的序列对象内的元素，可用于字符串、列表、元组、其他内置可迭代对象；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;target&gt; <span class="keyword">in</span> &lt;<span class="built_in">object</span>&gt;:</span><br><span class="line">	&lt;Options&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	&lt;Options&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当运行<code>for</code>循环时,PVM会将序列对象中的元素赋值給<code>target</code>,然后在循环主题中对其进行操作。for循环的循环变量<code>target</code>可以是任何赋值目标(反正执行完一次后就会重新赋值，引用)。因此for对序列的任意嵌套都能解包。</p>
<p><strong>4.3 其他循环</strong><br><strong>4.3.1 range函数跳遍历</strong><br><code>range函数</code>常用在<code>for循环</code>中用来产生索引，但也可以用在任何需要整数列表的地方。<code>range</code>是一个跌代器，会根据需要产生元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">5</span>);	<span class="comment">#生成0，1，2，3，4</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>,<span class="number">5</span>);	<span class="comment">#生成2，3，4</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>); <span class="comment">#生成0，2，4，6，8</span></span><br><span class="line"><span class="comment">#应用,遍历X跳一个输出,其实就是相当与while循环，条件+2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(X),<span class="number">2</span>):</span><br><span class="line">	<span class="built_in">print</span>(X[i],end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>根据上面的解释可知：</p>
<ul>
<li>传一个参数时，会产生从0算起的整数，不包括参数值</li>
<li>传两个参数时，第一个为起始值，第二个为最大不包括值</li>
<li>传三个参数时，第三个为步进值</li>
</ul>
<p><strong>4.3.2 并行遍历zip和map</strong></p>
<p><strong><code>zip</code>函数</strong>：传入一个或多个序列对象为参数，然后返回一个元组列表（可迭代对象），该元组列表将传入的列表并排元素组成一个元组。当传入序列长度不同时，**<code>zip</code>会以最短序列长度为准截断得到元组列表。**</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">L2=[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">L3=<span class="built_in">zip</span>(L1,L2);	<span class="comment">#L3=[(1,5),(2,6),(3,7),(4,8)]</span></span><br><span class="line"><span class="comment">#并行遍历</span></span><br><span class="line"><span class="keyword">for</span> (x,y) <span class="keyword">in</span> L3:</span><br><span class="line">	<span class="built_in">print</span>(x,y,<span class="string">&quot;x+y=&quot;</span>,x+y);</span><br></pre></td></tr></table></figure>
<p>事实上，<code>zip()</code>可以接受任何类型的序列（就是任何可迭代对象）。</p>
<p><strong><code>map函数</code>:</strong> 与<code>zip</code>不同只在于不会截断，会用None补齐，python3.0不再支持该函数。一般来讲，map会带一个函数以及一个到多个序列参数，然后从序列中取出并行元素并调用函数后将结果收集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="built_in">ord</span>,<span class="string">&#x27;spam&#x27;</span>);	<span class="comment">#ord为ascii转换为数字，结果为115，112，97，109</span></span><br></pre></td></tr></table></figure>

<p><strong>4.3.3 filter和reduce</strong><br><code>filter</code>和<code>reduce</code>都会返回可迭代对象。在python3.0,需要用<code>list</code>调用来显示其所有结果。<code>filter</code>的作用是基于某一函数的过滤器。<code>reduce</code>是没对元素都应用函数得到最后结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>((<span class="keyword">lambda</span> x:x&gt;<span class="number">0</span>),<span class="built_in">range</span>(-<span class="number">5</span>,<span class="number">5</span>)));	<span class="comment">#[1,2,3,4]</span></span><br><span class="line">reduce((<span class="keyword">lambda</span> x,y:x+y),[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);			<span class="comment">#10</span></span><br></pre></td></tr></table></figure>

<h4 id="迭代器和解析"><a href="#迭代器和解析" class="headerlink" title="迭代器和解析"></a>迭代器和解析</h4><p>在上面提到的for循环和while循环能够处理重复性任务，但是序列迭代在程序中非常常见，因此python提供了额外工具来使得这项工作变得简单高效。<br><strong>1. 文件迭代器</strong><br><strong>1.1 __next()</strong><br>在文件类中，有一个方法<code>__next__()</code>,该方法每次调用时，就会返回文件的下一行，到达文件末尾时，会抛出StopIteration异常，而不是空字符串。像这样的接口就是python中所说的<em><strong>迭代协议</strong></em>.事实上，任何这类对象都认为时可迭代的，因为它们也能以<code>for循环</code>或其他迭代工具遍历，<em><strong>因为所有迭代工具内部工作原理都是调用<code>__next__()</code>，并且捕捉StopIteration异常来确定何时离开</strong></em></p>
<p><em><strong>迭代协议：Python 迭代协议由<code>__iter__</code>方法与<code>__next__</code>方法构成，若对象具有<code>__iter__</code>方法，称该对象为“可迭代对象（iterable object）”。若对象具有<code>__next__</code>方法，称该对象为“迭代器（iterator）”。<code>__iter__</code>方法必须返回一个迭代器对象，<code>__next__</code>方法不断的返回下一元素，或者抛出StopIteration。<code>__next__</code>方法是 Python 迭代协议的核心.<code>__iter__</code>方法是迭代协议的辅助——将可迭代对象转换成迭代器</strong></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		s=file.__next__();</span><br><span class="line">	<span class="keyword">except</span> StopIteration:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="built_in">print</span>(s,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>1.2 用for循环(推荐)</strong><br>读取文本文件的最佳方式就是根本不要去读，其代替的方法就是让for循环每轮自动调用<code>__next__()</code>从而前进到下一行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>):</span><br><span class="line">	<span class="built_in">print</span>(line,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>不建议使用<code>readlines</code>函数，因为<code>readlines</code>时一次性把文件加载到内存，且运行速度不如<code>for循环</code>.</p>
<p><strong>1.3 手动迭代</strong><br>为了支持手动迭代，python提供了一内置函数<code>next()</code>，他会自动调用一个对象的<code>__next__()</code>函数。即调用<code>next(X)</code>等价于<code>X.__next__()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s=<span class="built_in">next</span>(file);</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(s,end=<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>另一方面，再深一点看，当for循环开始时，通过iter内置函数获得一个迭代器，返回的迭代器对象含有需要的next或<code>__next__()</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it=<span class="built_in">iter</span>(file);	//获取迭代器</span><br><span class="line"><span class="built_in">print</span>(file <span class="keyword">is</span> it);</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s= it.__next__();</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(s,end=<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 字典迭代</strong><br><strong>2.1 获取键值列表，再由遍历列表遍历字典</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D.keys():</span><br><span class="line">	<span class="built_in">print</span>(key,D[key]);</span><br></pre></td></tr></table></figure>

<p><strong>2.2</strong> 有字典的迭代器遍历<br>字典有一个迭代器，在<em><strong>迭代的环境下（即for循环&#x2F;while循环）</strong></em>会自动一次返回一个键，这样我们就不必生成键值序列来遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it=<span class="built_in">iter</span>(D);	<span class="comment">#获得字典的迭代器</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">		<span class="comment">#s=it.__next__();</span></span><br><span class="line">        l=<span class="built_in">next</span>(it);</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(l,D[l]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此可简写for循环：（推荐）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D:</span><br><span class="line">    <span class="built_in">print</span>(key,D[key]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3. 其他迭代环境</strong><br>上面介绍的迭代环境是在<strong>for循环</strong>看的以及之前讲到过的<strong>列表解析</strong>也有迭代协议。其实，**<code>in成员测试</code>、<code>map</code>内置函数以及像<code>sorted</code>（调用后会返回排序后的列表对象）和<code>zip</code>调用这样的内置函数也使用了迭代协议<strong>。</strong><em>当应用于文件时，文件对象的迭代器都自动扫描：</em>**</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>.upper,<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>))); <span class="comment">#[&quot;ADC&quot;,&quot;DADA&quot;,&quot;SSDA&quot;]</span></span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>));				<span class="comment">#[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>作为一位C&#x2F;C++、java程序员，需要了解python函数体系下的函数相关语句和表达式,因为它们有很大的不同点:</p>
<ul>
<li><code>def</code>是可执行代码，python的函数由<code>def</code>语句编写，<strong>函数只有当<code>def</code>运行后才存在，这就意味着不能在函数未运行时就去调用</strong>。</li>
<li><code>def</code>创建了一个对象并将其赋值给某一个变量，即函数名只是函数对象的引用。</li>
<li><code>lambda</code>创建一个对象但将其作为结果返回。使用<code>lambada</code>表达式创建函数，运行将函数定义内联到语法上一条<code>def</code>语句不能工作的地方。</li>
<li><code>yield</code>向调用者发回结果对象，<strong>但会记住它离开的地方</strong></li>
<li><code>global</code>声明了一个模块的变量并被赋值。默认情况下所有在一个函数总被赋值的对象，仅在函数作用域中有效。如要使得它在整个模块中都可使用，函数需要<code>global</code>语句声明</li>
<li><code>nonlocal</code>声明了将要赋值的一个封闭函数变量</li>
</ul>
<p><strong>1. def</strong><br><code>def</code>语句将创建一个函数对象并将其赋值给一个变量名，格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(arg1,arg2,arg3,...):</span><br><span class="line">	functions-body;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>python中所有语句都是实时运行的，没有像独立编译时间这样的流程。*** python函数在程序运行之前并不需要全部定义，因为<code>def</code>在运行时评估，而<code>def</code>里面的函数体调用时才评估（与C&#x2F;C++不同) ***。一个<code>def</code>语句可以出现在任何地方，比如<code>if</code>,<code>while</code>甚至是<code>def</code>嵌套也是合法的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> test:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_func</span>():</span><br><span class="line">		....</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_func1</span>():</span><br><span class="line">		....</span><br><span class="line"></span><br><span class="line"><span class="comment">#嵌套</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">	x=<span class="number">99</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">		<span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">			<span class="built_in">print</span>(x);</span><br><span class="line">		f3();	<span class="comment">#调用</span></span><br><span class="line">	f2();		<span class="comment">#调用</span></span><br><span class="line"></span><br><span class="line">f1();</span><br></pre></td></tr></table></figure>
<p><em><strong>注意</strong></em>：当我<code>def</code>嵌套时，必须在上一层函数调用嵌套函数</p>
<p><strong>2. python中的多态</strong><br>对于python中函数的作用，会根据传入参数的不同而有些许不同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">times</span>(<span class="params">x,y</span>):</span><br><span class="line">	<span class="keyword">return</span> x*y;</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">times(<span class="number">2</span>,<span class="number">4</span>);	<span class="comment">#return 8</span></span><br><span class="line">times(<span class="string">&quot;tr&quot;</span>,<span class="number">4</span>);	<span class="comment">#return trtrtrtr</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到<code>times</code>实现的功能的意义完全依赖于参数<code>x</code>和<code>y</code>的类型，<em><strong>这种依赖类型的行为称为多态</strong></em>。可以说python的动态类型是实现python多态的前提条件。在python这种多头机制下，<strong>编写函数接口更多是为对象编写，而不是特定为一个类型</strong>，这样可以达到函数的复用，提升代码简易和高效性。</p>
<p><strong>3. 作用域</strong><br>在代码编写过程中，变量可以在三个不同地方辅助，其对应的作用域：</p>
<ul>
<li>变量在一个<code>def</code>赋值，其作用域只在该函数有效</li>
<li>变量在<code>def</code>之外赋值，从赋值地方开始到文件结尾都有效</li>
<li>变量在嵌套<code>def</code>内，只在内层<code>def</code>内有效</li>
</ul>
<p><strong>3.1 作用域法则</strong></p>
<ol>
<li>全局作用域的作用范围仅限单个文件。要是有其他模块的变量名，必须导入模块</li>
<li>导入模块的作用域是全局的</li>
<li>每次函数调用都创建一个新的本地作用域</li>
<li>在函数赋值的变量名除非声明为<code>global</code>或者<code>nonlocal</code>变量，否则默认为本地变量。<code>global</code>将位于函数内的变量变为全局（位于模块文件内部的顶部），<code>nonlocal</code>将嵌套函数内的变量声明为非本地</li>
<li>python执行过程变量搜索路径：<code>本地作用域--&gt;上一层结构def或lambda的本地作用域--&gt;全局作用域--&gt;内置作用域</code></li>
</ol>
<p><strong>3.2 global</strong><br>global不是一个类型或者大小的声明，而是<em><strong>命名空间的声明</strong></em>，它告诉编译器python函数打算生成一个或多个全局变量名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用法1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_func</span>(<span class="params">x,y</span>):</span><br><span class="line">	<span class="keyword">global</span> z;</span><br><span class="line">	z=x+y;</span><br><span class="line">func(<span class="number">2</span>,<span class="number">4</span>)；</span><br><span class="line"><span class="built_in">print</span>(z);	<span class="comment">#输出6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用法2，告诉函数x不是本地的，而是全局的（主要用法：将在函数内修改的全局变量保存）</span></span><br><span class="line">x=<span class="number">22</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">   <span class="keyword">global</span> x;</span><br><span class="line">   x=<span class="number">99</span></span><br><span class="line">f1();</span><br><span class="line"><span class="built_in">print</span>(x);	<span class="comment">#输出99</span></span><br></pre></td></tr></table></figure>

<p><strong>3.3 nonlocal</strong><br>与<code>global</code>一样，<code>nonlocal</code>也是将变量在嵌套作用中的修改保存下来。与<code>global</code>不同之处在于：<code>global</code>是对<code>def</code>之外的全局变量作用，而<code>nonlocal</code>更严格，是对嵌套的的变量，这样达到能够使内层嵌套对变量的修改能够保存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_func1</span>(<span class="params">a,<span class="built_in">str</span></span>):</span><br><span class="line">	x=a;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">		<span class="keyword">nonlocal</span> x</span><br><span class="line">		x+=<span class="number">20</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">str</span>,x);	<span class="comment">#这是一个nonlocal测试 21</span></span><br><span class="line">	_f(<span class="built_in">str</span>);</span><br><span class="line">	<span class="built_in">print</span>(x);			<span class="comment">#21</span></span><br><span class="line"></span><br><span class="line">_func1(<span class="number">1</span>,<span class="string">&quot;这是一个nonlocal测试&quot;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>1. 引用传递</strong><br>要努力区别python的传参机制和C++引用参数，对于python来说：</p>
<ul>
<li><strong>不可变参数通过“值”传递，虽然像整数、字符串这些是通过对象的引用进行传递的，但是它们的不可变性导致我们不可能在原处改变，一旦执行给变量赋新值，意味这新对象产生，变量只是新对象的一份引用。</strong>（这样来看它的效果其实就是C++中的按值传递，即发生了一份拷贝）</li>
<li><strong>可变对象时通过“指针”进行传递的。虽然列表、字典这样的对象实际上也是通过引用来传递，但效果却和不可变参数完全不同，因为它们支持原处修改，因此函数内发生的改变能够保存。</strong>（这就像C++中传递数组很像）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">2</span>;</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x</span>):</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">isinstance</span>(x,<span class="built_in">list</span>):</span><br><span class="line">		x[<span class="number">0</span>]=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">	<span class="keyword">elif</span> <span class="built_in">isinstance</span>(x,numbers.Number):</span><br><span class="line">		x=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">test(a);</span><br><span class="line"><span class="built_in">print</span>(a);	<span class="comment">#2</span></span><br><span class="line">test(b);</span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#[20,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>python通过引用来传参，意味着我们不需要进行多余的拷贝操作，能够节约内存和运行时间，同时也就支持可传递很大对象。如果我们要抑制因传入可变参数而带来的修改，可以在传入时拷贝一份作为参数<code>test(copy(b));</code></p>
<p><strong>2. 返回值</strong><br><code>return</code>语句能够返回任意种类对象，所有也能够返回多个值（指的是封装进元组或列表这样的集合里）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">	x=<span class="number">2</span>;</span><br><span class="line">	y=[<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">return</span> x,y;</span><br><span class="line"></span><br><span class="line">l=func();	<span class="comment">#(2,[3,4])</span></span><br></pre></td></tr></table></figure>
<p>上面的函数返回了元组(2,[3,4])。（因为元组的<code>()</code>不是必须的）</p>
<p><strong>3. 参数匹配模型</strong><br>这些匹配模型的底层传参机制仍有是引用赋值：</p>
<ul>
<li>位置参数：默认模式，通过从左到右参数匹配(位置：调用者)</li>
<li>关键字参数；设置传参默认值，<code>name=value</code>形式，意思是当我们执行从左到右匹配，发现某参数没有传入，则调用时使用默认值(位置：被调函数)</li>
<li>关键字参数：<code>name=value</code>还可以指定我们调用时参数传递给哪一个参数变量，破环了默认模式，即不必遵循从左到右匹配，而是按名字匹配,如<code>print(&quot;trluper&quot;,sep=&#39; &#39;,end=&#39; &#39;,file=sys,stdout);</code>（位置：调用者）</li>
<li>可变参数列表，在函数的参数中有<code>*</code>号，意味着该函数支持可变参数列表，即支持传递任意个参数。单个<code>*</code>指对元组，<code>**</code>是对字典,<strong>即指在调用的时候我们传递给函数的参数会被打包参数位置信息的元组序列或者字典对象</strong>，对函数来说它会解包</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位置参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,c</span>):</span><br><span class="line">	<span class="built_in">print</span>(a,b,c);</span><br><span class="line"><span class="comment">#关键字参数name=value形式调用</span></span><br><span class="line">f(a=<span class="number">2</span>,c=<span class="number">3</span>,b=<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#关键字参数,设置默认值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name=<span class="string">&#x27;Bob&#x27;</span>,age=<span class="string">&#x27;&#x27;</span>,jov=<span class="string">&#x27;engineer&#x27;</span></span>):</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line"><span class="comment">#*</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">*args</span>):</span><br><span class="line">	<span class="built_in">print</span>(args);</span><br><span class="line"><span class="comment">#调用时打包成元组</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)		<span class="comment">#(1,2,3,4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#**只对关键字参数有效，将关键字参数打包成字典</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">**args</span>):</span><br><span class="line">	<span class="built_in">print</span>(args);</span><br><span class="line">f(a=<span class="number">1</span>,b=<span class="number">2</span>);		<span class="comment">#&#123;&#x27;a&#x27;=1,&#x27;b&#x27;=2&#125;</span></span><br></pre></td></tr></table></figure>
<p><em><strong>注意</strong></em>：如要函数要混用这些模式，则顺序必须是<code>位置参数-&gt;关键字参数-&gt;*-&gt;**</code></p>
<h4 id="函数的高级话题"><a href="#函数的高级话题" class="headerlink" title="函数的高级话题"></a>函数的高级话题</h4><p>学习了函数，我们就必须要了解如何使函数聚合性更强，解耦合性能更好，设计函数的功能性。<br><strong>1. 递归函数</strong><br>较循环结构而言，对任意深度的嵌套，循环较难处理，而递归能够容易处理该类嵌套：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#能够处理任意嵌套</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L:<span class="string">&quot;可以是列表也可是元组&quot;</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">		<span class="keyword">if</span>  <span class="built_in">isinstance</span>(x,<span class="built_in">list</span>):</span><br><span class="line">			tot+=sumtree(x);</span><br><span class="line">		<span class="keyword">elif</span>  <span class="built_in">isinstance</span>(x,<span class="type">Tuple</span>):</span><br><span class="line">			tot+=sumtree(x);</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			tot+=x;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sumtree([<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],(<span class="number">3</span>,<span class="number">4</span>),<span class="number">5</span>,[<span class="number">7</span>,<span class="number">8</span>,[<span class="number">2</span>,<span class="number">3</span>]]])); <span class="comment">#38</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 属性存储和注解</strong><br>由于python函数是对象，函数对象可以赋值给其他的变量名、传递给其他函数、嵌入到数据结构、从一个函数返回给另一个函数等等。<br><strong>2.1 属性</strong><br>函数除了调用以外，我们还可以检查它的<strong>属性</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sumtree.__name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(sumtree));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sumtree</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__call__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__closure__&#x27;</span>, <span class="string">&#x27;__code__&#x27;</span>, <span class="string">&#x27;__defaults__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__get__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__globals__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__kwdefaults__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>2.2 注解</strong><br>python3.0以后，可以给函数对象附加注解信息—就是与函数的参数和结果相关的任意用户定义的数据。注解有它专有的语法，但它自身不做任何事情，注解是可选的，并且出现的时候只是直接附加在函数对象的<code>__annotations__</code>属性以供其他用户使用。语法：</p>
<ul>
<li>函数注解编写在def行</li>
<li>对于参数，它们出现在紧随参数名冒号的后面</li>
<li>对于返回值，它们编写于参数列表之后的<code>-&gt;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L:<span class="string">&quot;可以是列表也可是元组&quot;</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sumtree.__annotations__);	<span class="comment">#&#123;&#x27;L&#x27;: &#x27;可以是列表也可是元组&#x27;, &#x27;return&#x27;: &lt;class &#x27;int&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>3. lambda表达式</strong><br>除了<code>def</code>之外，python提供了另一种函数对象的表达式，叫<code>lambada</code>也称匿名函数。这个表达式创建了一个之后能够调用的函数，但是它返回一个函数而不是将这个函数赋值给一个变量名，这也是为啥lambda叫匿名函数。<br><strong>3.1 lambda表达式格式</strong><br>关键字lambda后面接参数列表，<code>:</code>后面为函数体</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arg1,rag2,...:</span><br><span class="line">	function_body;</span><br></pre></td></tr></table></figure>
<p><em><strong>注意：</strong></em></p>
<ul>
<li>lambda是一个表达式，而不是语句。因为是一个表达式，所有它能出现在<code>def</code>不能出现的地方，如列表中、或者函数参数中等。同时它会返回一个新函数对象，我们可以选择性的将对象赋值给一个变量，方便操作。</li>
<li>lambda的主体是一个单个的表达式，而不是一个代码块。因为lambda是为编写简单函数而设计的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_test</span>(<span class="params">L,cmp=<span class="keyword">lambda</span> x,y:x&gt;y</span>):</span><br><span class="line">	a=L[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> e <span class="keyword">in</span> L[<span class="number">1</span>:]:</span><br><span class="line">		<span class="keyword">if</span> cmp(a,e):</span><br><span class="line">			a=e;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">min_test([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>])		<span class="comment">#0</span></span><br></pre></td></tr></table></figure>

<h4 id="深入理解迭代和解析"><a href="#深入理解迭代和解析" class="headerlink" title="深入理解迭代和解析"></a>深入理解迭代和解析</h4><p><strong>1. 重访迭代器：生成器</strong><br>python对延迟提供了更多的支持，有两种方法尽可能延迟结果创建：</p>
<ul>
<li><strong>生成器函数</strong>：编写为常规的<code>def</code>，但是使用<code>yield</code>一次返回一个结果，在每个结果之间挂起和继续它们的状态</li>
<li><strong>生成器表达式</strong>：类似于列表解析，但是它们的返回是按需产生结果对象，而不是像列表解析一样构建一新列表</li>
</ul>
<p>由于二者都不会创建列表，因此节省了内存空间，并且允许计算时间分散到各个结果请求。</p>
<p><strong>1.1 生成器函数</strong><br><strong>一个送回一个值并随后从退出的地方继续的函数就叫生成器函数</strong>。<em><strong>生成器函数</strong></em>与常规函数的不同点主要在于：</p>
<ul>
<li>生成器函数自动在生成值的时刻挂起，在挂起时要保存函数的状态。</li>
<li>生成器函数代码不同是生成器<code>yield</code>一个值，而不是<code>return</code>，从该角度来看，允许生成器函数随时间产生一系列值</li>
</ul>
<p><strong>1.1.1 迭代协议</strong><br>要理解生成器，必须了解<strong>迭代协议</strong>。可迭代的对象定义了一个<code>__next__</code>方法，要么返回迭代中的下一项，要么抛出<code>StopIteration</code>异常终止迭代。一个对象的迭代器用<code>iter</code>内置函数接受。如果支持该协议，则<code>for</code>循环和其他迭代语句，使用这种迭代协议来遍历一个序列或者生成器；若不支持，迭代返回去重复序列。</p>
<p><strong>1.1.2 生成器：</strong><br>生成器函数要支持该协议，就必须得包含一条<code>yiled</code>语句，该语句被编译为生成器，一旦调用这条语句就会返回一个迭代对象，该对象支持用一个<code>__next__()</code>函数来继续执行该生成器函数接口。要终止生成器函数，可以在生成器函数末尾有一条<code>return</code>语句，终止生成，也可以引发一个<code>StopIteration</code>异常终止。<em><strong>简而言之，编写了包含<code>yiled</code>的函数称为生成器函数，<code>yield</code>语句为生成器，自动的支持迭代协议</strong></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">L</span>):</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">		<span class="keyword">yield</span> i**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]));		<span class="comment">#&lt;generator object func at 0x000001FB7F4AB450&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]):	<span class="comment">#1，4，9，16</span></span><br><span class="line">	<span class="built_in">print</span>(i);</span><br></pre></td></tr></table></figure>
<p>从上面程序可以看到，调用一个生成器函数会返回一个生成器对象，它支持迭代协议，即生成器对象有一个<code>__next__()</code>方法，它可以开始这个函数，或者从它上一次<code>yield</code>值后的地方恢复，并且得到一系列的值，到最后一个时，产生<code>StopIteration</code>异常。</p>
<p><strong>1.1.3 扩展生成器函数协议send和next</strong><br>生成器函数协议增加了一个<code>send()</code>函数，<code>send()</code>函数生成一系列结果的下一个元素，这一点像<code>__next__()</code>,但是它提供了一种调用者与生成器之间的通信。当使用这一额外协议时，值可以通过调用<code>G.send(value)</code>发生给一个生成器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g=func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="literal">None</span>));</span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>


<p><strong>1.2 生成器表达式</strong><br>生成器表达式其实跟列表解析相似，区别就是列表解析是在<code>[]</code>内，而生成器表达式是在<code>()</code>内：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#列表解析</span><br><span class="line">[x**2 for x in range(5)]; #[0,1,4,9]</span><br><span class="line">#生成器表达式</span><br><span class="line">G=(x**2 for x in range(5))	#generator</span><br><span class="line">G.__next__();</span><br><span class="line">#for循环自动迭代</span><br><span class="line">for num in(x**2 for x in range(5)):</span><br><span class="line">	print(num);</span><br></pre></td></tr></table></figure>
<p>从上面可知道，生成器表达式很不同，不是在内存种构建结果，而是返回一个生成器对象，这个对象将会支持迭代协议并在任意迭代语境的操作。</p>
<p><strong>1.3 生成器是单迭代对象</strong><br>无论是生成器函数还是生成器表达式，都只支持一次活跃迭代，即不能在不同位置的有自己的迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">G=(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">iter_1=<span class="built_in">iter</span>(G);</span><br><span class="line">iter_1.__next__();		<span class="comment">#0</span></span><br><span class="line">iter_2=<span class="built_in">iter</span>(G);</span><br><span class="line">iter_2.__next_();		<span class="comment">#1</span></span><br></pre></td></tr></table></figure>
<p>如上，两个迭代器总是在同一位置，即只能有一个活跃的迭代器</p>
<p><strong>1.4 编写自己的map和zip</strong><br><strong>mymap</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mymap</span>(<span class="params">func,*seqs</span>):</span><br><span class="line">	<span class="keyword">return</span> [func(*args) <span class="keyword">for</span> args <span class="keyword">in</span> <span class="built_in">zip</span>(*seqs)]</span><br><span class="line"><span class="built_in">print</span>(mymap(<span class="built_in">pow</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">16</span>, <span class="number">243</span>, <span class="number">4096</span>]</span><br></pre></td></tr></table></figure>

<p><strong>myzip</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myzip</span>(<span class="params">func,*seqs</span>):</span><br><span class="line">	seqs=[<span class="built_in">list</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> seqs];</span><br><span class="line">	res=[];</span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">all</span>(seqs):</span><br><span class="line">		res.append(<span class="built_in">tuple</span>(s.pop(<span class="number">0</span>)<span class="keyword">for</span> s <span class="keyword">in</span> seqs));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 解析语法概况</strong><br>除了列表解析以外，python3.0还增加了集合解析和字典解析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列表解析</span></span><br><span class="line">[f(x) <span class="keyword">for</span> x <span class="keyword">in</span> S]</span><br><span class="line"><span class="comment">#集合解析</span></span><br><span class="line">&#123;f(x) <span class="keyword">for</span> x <span class="keyword">in</span> S&#125;</span><br><span class="line"><span class="comment">#字典解析</span></span><br><span class="line">&#123;key:val <span class="keyword">for</span> (key,val) <span class="keyword">in</span> <span class="built_in">zip</span>(keys,vals)&#125;</span><br><span class="line"><span class="comment">#生成器表达式</span></span><br><span class="line">(x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br></pre></td></tr></table></figure>

<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>模块是将程序代码和数据封装起来以方便重用，其实模块就相当于是一个命名空间。模块由两个语句和一个终于的内置函数进行处理：</p>
<ul>
<li><code>import</code>:让用户导入一个模块</li>
<li><code>from</code>:允许用户从以模块文件获取特定变量名</li>
<li><code>imp.reload</code>:在不终止python程序下，提供重新载入模块文件代码的方法.</li>
</ul>
<p><strong>1. import工作机制</strong><br>乍一看，我们都会认为python的<code>import</code>很像C&#x2F;C++的<code>#include&lt;&gt;</code>，但是并不是完全一样，首先一点就是在导入时模块就已经运行了，即一旦<code>import a</code>模块，<code>a</code>模块里面的代码就会执行，如果<code>a</code>模块内有<code>print</code>语句的话就会输出。而<code>C</code>会在预处理阶段将头文件展开，同内部代码一样，执行<code>预处理编译--&gt;汇编--&gt;链接</code>过程</p>
<p><strong>import的三个过程：</strong><br><strong>1.1 找到模块文件</strong><br>在执行钱必须找到模块文件所在的位置，导入是简单的<code>import a</code>，没有路径，也没有加后缀<code>.py</code>,因为python使用**&#x3D;&#x3D;标准模块搜索路径&#x3D;&#x3D;**<br><strong>1.2 编译成字节码（如果需要）</strong><br>python会检查模块文件的时间戳，当发现字节码即后缀为<code>.pyc</code>的文件比源代码<code>.py</code>旧，就会重新编译成<code>.pyc</code>文件，覆盖原字节码文件，反之，则不。若在搜索时只有<code>.pyc</code>文件，没有<code>.py</code>文件，直接加载<code>.pyc</code>文件。通过这些算法方式来提高程序启动速度。（<em><strong>注意</strong></em>：只有被导入的文件才会有<code>.pyc</code>文件）<br><em><strong>注意</strong></em>：因此多次在一个顶层模块导入模块，导入操作只会执行一次，因为已经生成了最新的<code>.pyc</code>文件<br><strong>1.3 执行模块代码来创建其所定义的对象</strong><br>最后一步执行，不多说</p>
<p><strong>2.标准模块搜索路径</strong><br>大多数情况下，可以说依赖导入模块的搜索路径的自动特性，完全不要要配置路径。要配置你自己的路径，必须了解模块搜索路径的四个组件：</p>
<ul>
<li>程序主目录</li>
<li>pythonPATH(如果已经设置)</li>
<li>标准链接库目录</li>
<li>任何.pth文件内容</li>
</ul>
<p>这四个组件组合起来就变成了<code>sys.path</code>。第一个和第三个是自动定义，以及固定了，第二和第四个就可以用来扩展路径，从而包含你自己的外部源代码。</p>
<p><strong>3.import和from</strong><br>格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line"><span class="keyword">from</span> simple <span class="keyword">import</span> x,y</span><br><span class="line">x=<span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>在交互的模式下对<code>x</code>赋值运输,只会修改作用域内的变量x，而不是这个文件内的x，以from复制而来的变量名和其来源的文件之间没有联系，如果要修改，应该用<code>import</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line">simple.x=<span class="number">42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>4. 命名空间</strong><br>在模块的文件顶层（也就是不在函数或类的主体内）每一个赋值的变量名都会变成该模块的属性。我么们可以在模块外以<code>simple.x</code>对其属性进行引用。<br><strong>4.1 模块加载和作用域</strong></p>
<ul>
<li><strong>模块语句会在首次导入时执行</strong>：模块第一次导入无论在什么地方，<strong>都会建立空的模块对象，并逐一执行模块文件内的语句</strong></li>
<li>顶层的赋值语句创建模块属性（如def,&#x3D;)</li>
<li>模块的命名空间能够通过属性<code>__dict__</code>或<code>dir(simple)</code>获得</li>
<li>模块是一个独立的作用域（本地变量就是全局变量）：模板自己成立一个作用域，但是它的变量可看作全局变量，文件内都可使用</li>
</ul>
<p><strong>4.2 进行导入操作的文件的与被导入的文件的关系</strong><br>导入操作不会赋予被导入文件种的代码对上层代码的可见度：即被导入文件无法看见进行导入操作的文件内的变量名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#modeA.py</span></span><br><span class="line">x=<span class="number">88</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">	gloabal x;</span><br><span class="line">	x=<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#modeB.py</span></span><br><span class="line"><span class="keyword">import</span> modeA</span><br><span class="line">x=<span class="number">11</span>;</span><br><span class="line">modeA.f()</span><br><span class="line"><span class="built_in">print</span>(x,modeA.x);	<span class="comment">#11 99</span></span><br></pre></td></tr></table></figure>
<p>总结来说：</p>
<ul>
<li>函数绝对无法看见其他函数内的变量名，除非它们是嵌套的</li>
<li>模块程序代码绝对无法看见其他模块的变量名，除非明确进行了变量导入</li>
</ul>
<p><strong>4.3 模块重载</strong><br>我们之前提到，模块导入只会执行一次，要强制模块代码重新载入并执行，得要调用<code>reload</code>内置函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line">reload(simple);		<span class="comment">#重载模块</span></span><br></pre></td></tr></table></figure>
<p>重载模块有几个<em><strong>注意点：</strong></em></p>
<ul>
<li><code>reload</code>会在模块当前命名空间内执行模块文件的新代码</li>
<li>重载会影响所有使用import读取的模块属性</li>
<li>重载只会以后对以后使用from的造成影响</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">（面试）C++基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-19 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-19T00:00:00+08:00">2022-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:19:10" itemprop="dateModified" datetime="2022-06-23T16:19:10+08:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-C-知识面试版"><a href="#C-C-知识面试版" class="headerlink" title="C\C++知识面试版"></a>C\C++知识面试版</h2><h4 id="0）编译过程"><a href="#0）编译过程" class="headerlink" title="0）编译过程"></a>0）编译过程</h4><p><img src="/./%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.jpg" alt="编译原理"><br>如上所示，一个c源文件会先经过预处理，将头文件展开、宏替换和去注释；然后经过编译器生成汇编文件，再有汇编器生成二进制文件，最后再经过链接器将函数库中相应的代码组合到目标文件</p>
<h4 id="1-静态链接和动态链接"><a href="#1-静态链接和动态链接" class="headerlink" title="1)静态链接和动态链接"></a>1)静态链接和动态链接</h4><ol>
<li><strong>静态链接：由链接器在链接时将库的内容加入到可执行程序中。</strong></li>
</ol>
<ul>
<li>优点：<br>对运行环境的依赖性较小，具有较好的兼容性</li>
<li>缺点：<br>生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间<br>库函数有了更新，必须重新编译应用程序</li>
</ul>
<ol start="2">
<li><strong>动态链接</strong>：连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。</li>
</ol>
<ul>
<li>优点：<br>在需要的时候才会调入对应的资源函数<br>简化程序的升级；有着较小的程序体积<br>实现进程之间的资源共享（避免重复拷贝）</li>
<li>缺点：<br>依赖动态库，不能独立运行<br>动态库依赖版本问题严重</li>
</ul>
<p>注：前面我们编写的应用程序大量用到了标准库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入-static参数。</p>
<h4 id="2）C-C-函数调用过程"><a href="#2）C-C-函数调用过程" class="headerlink" title="2）C\C++函数调用过程"></a>2）C\C++函数调用过程</h4><p><strong>函数调用栈的基本知识</strong>：</p>
<ul>
<li>每个线程都有一个自己的函数调用栈</li>
<li>栈也是程序申请的一段内存，随着栈的使用而增长。而一般编译的时候也可以指定编译选项设置栈最大值。如果递归调用层数太深，会导致栈溢出。</li>
<li>在系统中程序执行的时候 栈都是从高地址往低地址增长的<br>函数参数压栈，一般从右向左压栈（比如 __cdecl 函数调用约定）</li>
<li>EIP寄存器存储当前执行指令的内存位置</li>
<li>EBP寄存器表明当前栈帧的栈底</li>
<li>ESP寄存器表明当前栈帧的栈顶<br><strong>调用函数过程</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//以此为例</span><br><span class="line">intFunAdd(intiPara1, intiPara2) &#123;</span><br><span class="line">    intiAdd = 7; </span><br><span class="line">    intiResult = iPara1 + iPara2 + iAdd; </span><br><span class="line">    returniResult; </span><br><span class="line">&#125;</span><br><span class="line">int main&#123;</span><br><span class="line">    intiVal1 = 5; intiVal2 = 6; </span><br><span class="line">    intiRes = FunAdd(iVal1, iVal2); </span><br><span class="line">    printf( &quot;iRes: %dn&quot;, iRes); </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将函数参数压入（push)栈中（从右到左），在跳入（call)该函数体执行前，会再压入一个数据，改数据是一个地址，是函数执行完后要返回的地址，也是我们程序中函数调用的下一条语句，即“保护现场”。</li>
<li>push ebp，进入函数后，压入一个旧ebp，该ebp是上一个函数的ebp。这样子就能通过ebp-4、ebp-8来获取参数。</li>
<li>mov ebp, esp，将此时的栈顶地址作为该函数的栈基址，确定被调函数的栈底</li>
<li>执行函数将被调函数内的一些局部变量压栈。</li>
<li>执行最后一步后，如果有返回值，将返回值存入EAX寄存器。</li>
<li>mov esp,ebp 将ebp赋给esp，此时esp指向栈底，后执行pop恢复原先的main函数栈帧</li>
<li>此时esp指向了第一步保存的下一条执行语句的地址，获取后回到main函数，此时intFunAdd函数执行完毕</li>
<li>add esp,8，将压入的两个参数去除，后将eax寄存器的返回值赋给相应变量</li>
</ul>
<p><img src="/./%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9B%BE%E8%A7%A3.jpg"></p>
<h4 id="3）内联函数与普通函数的区别"><a href="#3）内联函数与普通函数的区别" class="headerlink" title="3）内联函数与普通函数的区别"></a>3）内联函数与普通函数的区别</h4><ul>
<li>相当于把内联函数里面的内容写在调用内联函数的地方；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数</li>
</ul>
<h4 id="4）内存中的字节对齐"><a href="#4）内存中的字节对齐" class="headerlink" title="4）内存中的字节对齐"></a>4）内存中的字节对齐</h4><h4 id="5）C-的内存模型"><a href="#5）C-的内存模型" class="headerlink" title="5）C++的内存模型"></a>5）C++的内存模型</h4><ol>
<li><strong>C++分区</strong>：堆、栈、自由存储区、全局&#x2F;静态存储区、常量存储区</li>
<li><strong>c&#x2F;c++内存模型生命周期</strong>：自由存储区、动态区、静态区</li>
<li><em><strong>以下注意点：</strong></em> (a)函数体中定义的变量通常是在栈上； (b)用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上； (c)在所有函数体外定义的是全局量； (d)加了static修饰符后不管在哪里都存放在全局区（静态区）； (e)在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用； (f)在函数体内定义的static表示只在该函数体内有效； (g)另外，函数中的”adgfdf”这样的字符串存放在常量区</li>
</ol>
<p><img src="/./C++%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%9B%BE.jpg"></p>
<h4 id="6-static关键字的作用"><a href="#6-static关键字的作用" class="headerlink" title="6)static关键字的作用"></a>6)static关键字的作用</h4><ol>
<li><p><strong>全局静态变量</strong>（编译时初始化，存储在bss&#x2F;data)</p>
<p> 在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。静态存储区（未初始化bss或已初始化数据段data），在整个程序运行期间一直存在。</p>
<p> <strong>初始化</strong>：只能初始化一次。未经初始化的静态变量会被自动初始化为0</p>
<p> <strong>作用域</strong>：全局静态变量在声明他的文件之外是不可见的，准确地说是他的作用域从定义之处开始，到文件结尾。</p>
</li>
<li><p><strong>局部静态变量</strong><br> 在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。<br> <strong>内存中的位置</strong>：静态存储区<br> <strong>初始化</strong>：只能初始化一次。未经初始化的静态变量会被自动初始化为0。<br> <strong>作用域</strong>：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束，但并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
</li>
<li><p><strong>静态函数</strong></p>
<p> 在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只能在声明他的文件当中可见，不能被其他文件所用。函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突，起到一个函数隐藏的作用；<br> <strong>warning：</strong>不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
</li>
<li><p><strong>类的静态成员</strong></p>
<p> 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
</li>
<li><p><strong>类的静态函数</strong></p>
<p> 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p>
<p> <strong>在静态成员函数中没有this指针，因此无法被const修饰</strong>。实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//但可用对象.调用静态类的静态成员</span><br><span class="line">o s;</span><br><span class="line">cout &lt;&lt; s.x &lt;&lt; endl;</span><br><span class="line">s.print();</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="7-const关键字"><a href="#7-const关键字" class="headerlink" title="7)const关键字"></a>7)const关键字</h4><h4 id="8-一些seziof大小"><a href="#8-一些seziof大小" class="headerlink" title="8)一些seziof大小"></a>8)一些seziof大小</h4><p><strong>虚函数表4字节，4字节对齐！比如</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">  virtual void fun() &#123;&#125;</span><br><span class="line">  char c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sizeof(A);的大小应该是8，4+1+（对齐）3=8</span><br><span class="line">static变量虽然属于类，但并不在类内开辟空间</span><br></pre></td></tr></table></figure>






























      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">120k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:49</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
