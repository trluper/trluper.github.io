<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Trluper">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="trluper">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/" class="post-title-link" itemprop="url">Linux操作系统_2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-30 22:29:06 / 修改时间：22:31:44" itemprop="dateCreated datePublished" datetime="2022-07-30T22:29:06+08:00">2022-07-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/" class="post-title-link" itemprop="url">Linux操作系统_1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-30 22:28:49 / 修改时间：22:31:06" itemprop="dateCreated datePublished" datetime="2022-07-30T22:28:49+08:00">2022-07-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 21:59:16" itemprop="dateCreated datePublished" datetime="2022-07-30T21:59:16+08:00">2022-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-04 16:25:49" itemprop="dateModified" datetime="2022-08-04T16:25:49+08:00">2022-08-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="了解sql">1. 了解SQL</h4>
<h5 id="数据库基础">1.1 数据库基础</h5>
<p>数据库是一个以某种有组织的方式存储的数据集合。<code>MySQL</code>数据库中只有一个用户，名为<code>root</code>，但是它可以有多个数据库，如下是与<code>Oracle</code>数据库的不同之处： <img src="/2022/07/30/MySQL/different.png" width="700"></p>
<h6 id="表的概念">1.1.1 表的概念</h6>
<p>在数据库中，<strong>表是一种结构化的文件，用来存储某种特定类型的数据</strong>。数据库中的表都有一个唯一名字来标识自己，称为<strong>表名</strong>。同时表具有一些特性，这些特性定义了数据在表中如何存储，可以存储什么样的数据，数据如何分解、各部分信息如何让命名等等。</p>
<p>描述表的这组信息就是所谓的<strong>模式</strong>，模式即指关于数据库和表的布局以及特性的信息。</p>
<h6 id="列和数据类型">1.1.2 列和数据类型</h6>
<p><strong>表由列组成，列就是表中的一个字段</strong>。列中存储着表的某部分信息，数据库中的列都有相应的类型，数据类型定义了列中可以存储的数据种类。</p>
<h6 id="行">1.1.3 行</h6>
<p><strong>虽然表由列组成，但存储过程中，表中的数据是按行存储的</strong>。每次保存的记录都存储在自己所在的行中，你也可以理解为行就是表中的一个记录。</p>
<h6 id="主键">1.1.4 主键</h6>
<p><strong>表中的每一行都应该有唯一标识自己的一列，这样搜索起来才不容易出错，保证数据的完整性</strong>，就如一个顾客列表可以使用顾客编号来作为主键,如果使用顾客姓名来搜索，万一有相同姓名的顾客搜索就容易混淆。<strong>因此对于每创建一个表来说都应该至少设置一列为主键</strong>，作为主键的列必须满足：</p>
<ul>
<li>任意两行都不具有相同的主键值</li>
<li>每一行都必须具有一个主键值（主键列不允许为NULL值）</li>
</ul>
<p>主键虽然通常定义在表的一列上，但是也可以使用多个列作为主键</p>
<h6 id="外键">1.1.5 外键</h6>
<p><strong>外键就是某个表中被定义为外键的一列，它包含另一个表的主键值</strong>，定义两个表之间的关系，一个表中可以有多个外键。其作用主要有：</p>
<ul>
<li>不用重复存储另一个表中有的数据到本表，只需通过外键建立连续即可，节省了时间和空间</li>
<li>同时在删除中必须先删除外键才能删除主键，因此能保证数据的完整性</li>
</ul>
<h4 id="mysql的安装和修改">2. MySQL的安装和修改</h4>
<p>在ubuntu中可以使用<code>sudo apt install mysql-server</code>进行安装MySQL数据库。以下是对数据库的的初始化必做事项 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#进入本地数据库shell界面</span><br><span class="line">mysql -u root -p</span><br><span class="line">#进入其他主机的数据库shell</span><br><span class="line">mysql -h 192.168.18.251 -u root -p</span><br><span class="line">#修改密码</span><br><span class="line">mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<h5 id="启动和关闭mysql服务器">2.1 启动和关闭MySQL服务器</h5>
<p>MySQLS数据库分为客户端和服务器，<code>mysql-server</code>与<code>mysql-client</code>是DBMS的两个面向不同操作对象的工具。<code>server</code>是DBMS面向物理层次，包含存储数据的一系列机制、处理方法的集成；<code>client</code>是DBMS面向用户，提供一系列工具为用户所用，这些工具包括通常写的<code>sql</code>在内都要通过<code>server</code>的编译才能操作物理数据。即在连接服务器时要先开启<code>mysql-server</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种启动mysql服务器方法</span></span><br><span class="line">service mysql start</span><br><span class="line">systemctl statrt mysql</span><br><span class="line">systemctl restart mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看状态</span></span><br><span class="line">systemctl status mysql.service</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭服务器</span></span><br><span class="line">systectl stop mysql</span><br><span class="line">service mysql stop</span><br></pre></td></tr></table></figure>
<p><strong>注意数据库shell界面</strong>，<code>shell</code>界面是<code>mysql-client</code>提供了一种人与<code>mysql</code>直接交互的命令窗口，同Linux的<code>bashShell</code>是一样的。</p>
<h5 id="其他对数据库的操作">2.2 其他对数据库的操作</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#展示目前数据库目录</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.05 sec)</span><br><span class="line"></span><br><span class="line">#创建数据库:创建一个使用utf-8字符集，并带校对规则的mydb3数据库。会对存入的数据进行检查。</span><br><span class="line">mysql&gt; create database mydb3 character set utf8 collate utf8_general_ci;</span><br><span class="line">Query OK, 1 row affected, 2 warnings (0.03 sec)</span><br><span class="line"></span><br><span class="line">#修改数据库</span><br><span class="line">mysql&gt; alter database test character set utf8;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.05 sec)</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mydb3              |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">#选择test数据库</span><br><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">#删除数据库</span><br><span class="line">mysql&gt; drop database mydb3;</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="表的创建修改和删除">2.3 表的创建、修改和删除</h5>
<p>本节主要简单介绍对表的操作关键字和相应的数据库数据类型，让读者对表创建有一个总体的认识。能够简单创建表，提升性能的表创建方法后续才会介绍到。在创建表之前，必须选择对哪一个数据库操作 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure></p>
<h6 id="mysql的数据类型">2.3.1 MySQL的数据类型</h6>
<p>数据类型是定义该列可以存储的数据以及该数据实际怎样存储的法则</p>
<p><strong>1. 串数据类型</strong> <img src="/2022/07/30/MySQL/string.png" width="700"></p>
<p><strong>2. 数值数据类型</strong> <img src="/2022/07/30/MySQL/digit.png" width="700"></p>
<p><strong>3. 日期和时间数据类型</strong> <img src="/2022/07/30/MySQL/date.png" width="700"></p>
<p><strong>4. 二进制数据类型</strong>：可以存储任何数据，如图像、多媒体、字处理文档等 <img src="/2022/07/30/MySQL/binary.png" width="700"></p>
<ul>
<li><code>bit</code>：1位，可以指定位数，如：<code>bit(3)</code></li>
<li><code>int</code>：2字节可以指定最大位数，如<code>int&lt;4&gt;</code>,最大为4位的整数</li>
<li><code>float</code>：2个字节,可以指定最大的位数和最大的小数位数，如：<code>float&lt;5,2&gt;</code> 最大为一个5位的数，小数位最多2位</li>
<li><code>double</code>：4个字节,可以指定最大的位数和最大的小数位数，如：<code>float&lt;6,4&gt;</code>最大为一个6位的数，小数位最多4位</li>
<li><code>char</code>：必须指定字符数,如<code>char(5)</code>,为不可变字符　即使存储的内容为'ab',也是用5个字符的空间存储这个数据</li>
<li><code>varchar</code>：必须指定字符数,如varchar(5) 为可变字符　如果存储的内容为'ab',占用2个字符的空间；如果为'abc',则占用3个字符的空间</li>
<li><code>text</code>: 大文本(大字符串)</li>
<li><code>blob</code>：二进制大数据,如图片，音频文件，视频文件</li>
<li><code>date</code>: 日期　如：'1921-01-02'</li>
<li><code>datetime</code>: 日期+时间　如：'1921-01-02 12:23:43'</li>
<li><code>timeStamp</code>: 时间戳，自动赋值为当前日期时间</li>
</ul>
<h6 id="创建表">2.3.2 创建表</h6>
<p>创建表使用<code>create table</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#创建CUSTOMER表，以ID作为主键，同时指示除SALARY外其他都不能为NULL</span><br><span class="line">mysql&gt; CREATE TABLE IF NOT EXISTS CUSTOMER(</span><br><span class="line">    -&gt; NAME VARCHAR(20) NOT NULL, </span><br><span class="line">    -&gt; ID VARCHAR(30) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; SALARY DOUBLE NULL,</span><br><span class="line">    -&gt; HIREDATE DATE NOT NULL,</span><br><span class="line">    -&gt; PRIMARY KEY (ID)</span><br><span class="line">    -&gt; )ENGINE=InnoDB;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure> <strong>这里有几个关键字需要介绍</strong>：</p>
<ul>
<li><p><code>NULL</code>和<code>NOT NULL</code>:这两个关键字指示我们在插入记录对于该列来说，如果是<code>NOT NULL</code>,则插入记录时该列必须要有数据，否则会报错，而<code>NULL</code>修饰的列可以允许插入的记录在该列为空。</p></li>
<li><p><code>AUTO_INCREMENT</code>:在上述的表中<code>ID</code>是标识顾客的唯一编号，它们可以任意但是必须唯一，如果认为指定那么很难维护，<code>AUTO_INCREMENT</code>则是告诉MySQL本列每增加一行时自动增量，即每次执行一个<code>insert</code>,对该列增量。</p></li>
<li><p><code>PRIMARY KEY()</code>:指示使用哪一个或哪几个字段作为主键</p></li>
<li><p><code>ENGINE=InnoDB</code>:指示使用的引擎类型为<code>InnoDB</code> ，关于引擎类型后续会讲到</p></li>
</ul>
<h6 id="更新表">2.3.3 更新表</h6>
<p>有时候我们创建了表，但是对于表的字段列需要添加或者删除操作，这时候就用到了<strong>表更新</strong>这个概念，更新表使用<code>alter table CUSTOMER add/drop ID VARCHAR(40) NOT NULL</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#添加列</span><br><span class="line">mysql&gt; alter table CUSTOMER add marriage VARCHAR(5) NULL;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">#删除列</span><br><span class="line">mysql&gt; alter table CUSTOMER DROP MARRIAGE;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">#修改列</span><br><span class="line">alter table employee modify column height float;</span><br><span class="line">#修改表的字符集:</span><br><span class="line">alter table employee character set gbk;</span><br></pre></td></tr></table></figure></p>
<h6 id="删除表">2.3.4 删除表</h6>
<p>删除数据库中的表使用<code>drop table</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE CUSTOMER;</span><br></pre></td></tr></table></figure></p>
<h6 id="重命名表">2.3.5 重命名表</h6>
<p>如果相对表的名字重命名则可使用<code>rename</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; rename table CUSTOMER TO customer;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; show tables</span>;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| customer       |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="显示表结构">2.3.6 显示表结构</h6>
<p>如果想对表的结构字段名、类型等了解，可通过<code>describe</code>来显示表结构： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; describe customer;</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| NAME     | <span class="built_in">varchar</span>(<span class="number">20</span>) | NO   |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">| ID       | <span class="built_in">varchar</span>(<span class="number">30</span>) | NO   | PRI | <span class="literal">NULL</span>    |       |</span><br><span class="line">| SALARY   | <span class="type">double</span>      | YES  |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">| HIREDATE | date        | NO   |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.02</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="sql常用语句">3. SQL常用语句</h4>
<p>对于数据库来说，对数据库的操作离不开最重要的语句，而SQL语句就是对数据库操作的主流语言，可以说数据库和结构化查询语言<code>SQL</code>几乎是同义词，谈到<code>SQL</code>就当相于是在说数据库了。在数据库的操作中最常用的就是<strong>查询<code>select</code>,插入<code>insert into</code>，修改<code>update</code>和删除<code>delete</code>。</strong>也就是增删改差</p>
<h5 id="select语句">3.1 select语句</h5>
<p><code>select</code>是数据库中最常用的语句，它能从一个表或多个表中检索数据，使用<code>select</code>至少给出两个信息：一是要检索什么，从什么地方检索：<code>select what from where;</code>。<strong>你可以看作调用<code>select</code>会生成一个临时表作为结果集输出。</strong></p>
<p>如下是最简单的两句查询语句： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//产看该表所有数据</span><br><span class="line">select * from employee;</span><br><span class="line">//查看特定数据</span><br><span class="line">select name 姓名,birthday 出生日期 from employee where sal=15500;</span><br></pre></td></tr></table></figure> 上面的两条语句中：<strong>第一条既没有过滤也没有对查询结果排序</strong>，通常来说都不会使用如下低效的查询语句；<strong>第二句虽然增加了过滤条件<code>sal=15500</code>,也使用文字显示代替<code>name</code>和<code>birthday</code>作为输出界面，但是也没有对结果排序</strong></p>
<h6 id="distinct关键字">3.1.1 distinct关键字</h6>
<p>如果一个表中的一列不是主键有多个相同的值，但是我们又想查询结果只显示不同的值，这个使用就要使用到<code>distinct</code>关键字 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤表中重复数据。</span></span><br><span class="line">select DISTINCT english from student;</span><br><span class="line">select DISTINCT english,name from student;</span><br></pre></td></tr></table></figure></p>
<h6 id="limit关键字">3.1.2 limit关键字</h6>
<p>如果我们对检索的结果不要求其返回太多话，或者是限定其应该返回几行，这个时候就应该使用<code>limit</code>关键字:</p>
<ul>
<li><code>limit</code>后带一个数字的表示最多返回多少行</li>
<li><code>limit</code>后面带两个数字的表示从检索结果的的几行开始和返回的最多行数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer limit <span class="number">5</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">mysql&gt; select * from customer limit <span class="number">5</span>,<span class="number">5</span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br></pre></td></tr></table></figure>
<h6 id="order-by关键字">3.1.3 order by关键字</h6>
<p>一般来说，如果<code>select</code>语句没有对数据进行排序，则默认使用的数据在底层表中出现的顺序而显示，它可能是数据最初添加到表的顺序，但是一旦你进行过更新和删除，这个顺序就会受到MySQL重用回收存储空间的影响。因此应该采用关键字<code>order by</code>对检索结构进行排序。</p>
<ul>
<li>当<code>order by</code>后面只有一个字段名是，按该字段排序</li>
<li>当<code>order by</code>后面跟着多个字段名排序，首先是按照第一个字段排序，然后看排序后是否有相同的第一个字段值的记录，如果有，则对有相同第一个字段值的记录进行第二个字段排序。</li>
<li>默认情况下，使用的是升序排序，如果相要使用降序排序，则应该在后面添加<code>desc</code>,如<code>...order by name DESC;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name 姓名 from customer order by name;</span><br><span class="line">+---------+</span><br><span class="line">| 姓名    |</span><br><span class="line">+---------+</span><br><span class="line">| jack    |</span><br><span class="line">| lili    |</span><br><span class="line">| tom     |</span><br><span class="line">| trl     |</span><br><span class="line">| trluper |</span><br><span class="line">| 小明    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<h6 id="where关键字">3.1.4 where关键字</h6>
<p>在上面首次介绍<code>select</code>时，我们已经使用了<code>where</code>关键字，<code>where</code>关键字时对检索记录的一个筛选，只有符合<code>where</code>后面的条件才会输出这些记录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#普通条件显示</span><br><span class="line">mysql&gt; select * from customer where salary&gt;=<span class="number">15000</span> order by salary desc;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#非空显示</span></span><br><span class="line"><span class="function">mysql&gt; select * from customer where salary is <span class="keyword">not</span> null</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<p>在这里我们还需要介绍能够与<code>where</code>组合的更高级的过滤语句关键字<code>and、or</code>。上面使用<code>where</code>都是单一条件,如果要求要符合多个条件的使用怎么办？那当然是使用<code>and\or</code>来解决</p>
<ul>
<li><code>and</code>：同c++中的<code>&amp;&amp;</code>起一样的作用，优先级高于<code>or</code></li>
<li><code>or</code>：同c++中的<code>||</code>起一样的作用</li>
</ul>
<h6 id="in关键字">3.1.5 IN关键字</h6>
<p><code>IN</code>操作符用来指定条件的范围，范围中的每个条件都可以进行匹配，它的功能与<code>or</code>很相像，使用<code>IN</code>是因为：</p>
<ul>
<li>在使用长的合法选项清单是，<code>IN</code>操作符更加直观清楚，语句也不如<code>or</code>那样长冗余。</li>
<li>在使用<code>IN</code>时，计算的次序更容易管理</li>
<li><code>IN</code>操作一般比<code>or</code>操作符清单执行的更快</li>
<li><code>IN</code>操作符最多的优点是可以包含其他<code>select</code>语句，更加动态的建立<code>where</code>子句。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select * from customer where salary <span class="title">in</span><span class="params">(<span class="number">12000</span>,<span class="number">15000</span>,<span class="number">25000</span>)</span></span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<h6 id="not关键字">3.1.6 NOT关键字</h6>
<p><code>NOT</code>关键字有且只有一个功能，那就是否定它之后的紧跟的条件，NOT肯对<code>and、or</code>没什么用，但是对于<code>IN</code>来说却是绝配。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select * from customer where salary <span class="keyword">not</span> <span class="title">in</span><span class="params">(<span class="number">12000</span>,<span class="number">15000</span>,<span class="number">25000</span>)</span></span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| tom  | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="like和通配符">3.1.7 LIKE和通配符</h6>
<p><strong>通配符</strong>指的是用来匹配一部分的特殊字符；<strong>搜索模式</strong>则是指在搜索语句中使用字面值、通配符或两者组合成的搜索条件。<strong>使用通配符是必须在前面使用<code>LIKE</code>关键字，该关键字告诉MySQL后面跟着的搜索模式是使用通配符匹配而不是直接使用字面值匹配</strong></p>
<ul>
<li><code>%</code>通配符：该通配符是最常使用的，它可以表示任意字符出现任意次数，如<code>trl%</code>表示以<code>trl</code>开头的任意名称</li>
<li><code>_</code>通配符：同<code>%</code>是一样的作用，但是只匹配单个任意字符，即只匹配一次。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer where name like <span class="string">&#x27;trl%&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p>虽然通配符很有用，但是代价是很大的，它的搜索一般比前面的其他搜索所花时间更多，一般来说使用通配要遵循以下技巧：</p>
<ul>
<li>尽量不使用，如果有其他操作符能够达到相同效果，则应该使用这些操作符</li>
<li>假如一定要使用，则不要把通配符放在搜索模式的开始处，因为这样的搜索极慢</li>
</ul>
<h6 id="select支持算术运算">3.1.8 select支持算术运算</h6>
<p>对于MySQL中的数字类型，运行使用<code>* + - /</code>运算。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select salary,add_salary,salary+add_salary as finalSalary from custommer order by id;</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line">| salary | add_salary | finalSalary |</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line">|  <span class="number">12000</span> |        <span class="number">300</span> |       <span class="number">12300</span> |</span><br><span class="line">|  <span class="number">12500</span> |        <span class="number">300</span> |       <span class="number">12800</span> |</span><br><span class="line">|  <span class="number">15000</span> |        <span class="number">300</span> |       <span class="number">15300</span> |</span><br><span class="line">|  <span class="number">15000</span> |        <span class="number">300</span> |       <span class="number">15300</span> |</span><br><span class="line">|  <span class="number">25000</span> |        <span class="number">300</span> |       <span class="number">25300</span> |</span><br><span class="line">|  <span class="number">16000</span> |        <span class="number">300</span> |       <span class="number">16300</span> |</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="正则表达式进行搜索">3.2 正则表达式进行搜索</h5>
<p>前面介绍的过滤使用匹配、比较和通配符进行操作寻找符合的数据，对于一些基本情况来说足够了，但是随着过滤条件的增加，<code>where</code>子句本身的复杂性也在增加，这时候就应当使用正则表达式匹配。<strong>使用正则表达式必须在正则表达式（文本）前面使用<code>regexp</code>关键字，同·<code>like</code>一样告诉MySQL后面使用正则表达式进行匹配</strong>。</p>
<p>注意在正则表达式中，对于有特殊意义的符号，如果你不希望他被翻译成则表示里的特殊符号，应该加<code>\\</code>进行转义，如<code>. | []</code>这些通过<code>\\. \\| \\[\\]</code>经过转义后才能被认为是字符串的一部分。</p>
<h6 id="section">3.2.1 |</h6>
<p>在正则表达式中<code>|</code>上面的<code>or</code>是起到一样的作用 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer where name regexp <span class="string">&#x27;trl|tom&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<h6 id="section-1">3.2.2 []</h6>
<p><code>[]</code>的作用是匹配方括号内的字符之一，如<code>[123]</code>是指匹配1或2或3，同样为省略书写也可以写出<code>[1-3]</code>是同样的表示。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer where name regexp <span class="string">&#x27;[a-z]rl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<h6 id="section-2">3.2.3</h6>
<p><code>.</code>也是正则表达式中一个特殊字符，它表示匹配任意一个字符。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;.rl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------|</span><br></pre></td></tr></table></figure></p>
<h6 id="匹配字符类">3.2.4 匹配字符类</h6>
<p>MySQL中存在一些已经定义的字符集，这样就不用你自己手动去阻止这些字符集 <img src="/2022/07/30/MySQL/charSet.png" width="700"></p>
<h6 id="匹配多个字符">3.2.5 匹配多个字符</h6>
<p>至今为止，上面介绍的都是匹配单个字符的情况，是否有匹配多个字符的正则表达式特殊字符呢，当然是有的。 <img src="/2022/07/30/MySQL/muchChar.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;trl*&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意这里的重复元字符是指能够匹配当前元字符的前一个字符的多个重复值，如<code>trl*</code>,匹配<code>trl\trll\trll\trlll...\..</code>等</p>
<h6 id="定位符">3.2.6 定位符</h6>
<p>到目前为止，上面的匹配规则都是匹配一个串中任意一个为止的文本，为了能够指定匹配的为止，给出了定位符： <img src="/2022/07/30/MySQL/locate.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;^trl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select *from customer where name regexp &#x27;^trl$&#x27;</span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure> 一般来说，其他的正则表达式字符都应当与定位符结合使用</p>
<h5 id="insert语句">3.3 insert语句</h5>
<p>插入数据使用<code>insert into</code>，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入完整数据</span></span><br><span class="line"><span class="function">insert into employee <span class="title">values</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="number">15000</span>,<span class="string">&#x27;1998-05-09&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;2021-1-9&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//与select结合使用</span></span><br><span class="line"><span class="function">insert into  <span class="title">employee</span><span class="params">(id,name,salary,birthday,rank,hiredate)</span> select id,name,salary,birthday,rank,hiredate from employee_1 where name</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="update语句">3.4 update语句</h5>
<p>修改更新数据使用<code>update</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update customer set salary=salary+<span class="number">500</span>;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: <span class="number">6</span>  Changed: <span class="number">6</span>  Warnings: <span class="number">0</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="delete语句">3.5 delete语句</h5>
<p><code>delete</code>用来删除记录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除所有数据</span></span><br><span class="line"><span class="keyword">delete</span> from employee;</span><br><span class="line"><span class="comment">//删除指定数据</span></span><br><span class="line"><span class="keyword">delete</span> form employee where name=<span class="string">&#x27;jack&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用truncate删除表中记录。无条件 效率高</span></span><br><span class="line">truncate table employee;</span><br></pre></td></tr></table></figure></p>
<h4 id="函数">4. 函数</h4>
<p>有时候，我们对于搜索到的列的一些东西需要得到总和、平均和拼接，总之，我们不希望查找后的结果仍然是以底层表所存储的那样呈现上来,<strong>而是希望在<code>select</code>运行阶段经过处理后得到我们想要的结果，这时候就用到了想要的MySQL函数。</strong>大多数SQL支持以下函数：</p>
<ul>
<li>用于处理文本串的文本函数，如删除或填充、大小写转换等。</li>
<li>用于数值数据进行算术的操作，如绝对值、求和等</li>
<li>用于处理日期和时间值并从时间值提取特定成分</li>
<li>返回DBMS正使用的特殊信息的系统函数，如返回登录信息、检查版本细节等</li>
</ul>
<h5 id="拼接字段">4.1 拼接字段</h5>
<p>假如我们想在<code>select</code>中让输出的结果的一个字段即显示<code>name</code>又显示<code>salary</code>,而不是分开两个字段显示，这样就用到了<code>concat()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">concat</span><span class="params">(name,<span class="string">&#x27;:&#x27;</span>,salary,<span class="string">&#x27; &#x27;</span>,hiredate)</span> as &#x27;name:salary hiredate<span class="string">&#x27;&#x27; from customer order by id;</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">| name:salary hiredate     |</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">| jack:12000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| tom:12500 2022-08-03     |</span></span></span><br><span class="line"><span class="string"><span class="function">| lili:15000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| 小明:15000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| trluper:25000 2022-08-03 |</span></span></span><br><span class="line"><span class="string"><span class="function">| trl:16000 2022-08-03     |</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">6 rows in set (0.00 sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：</em></strong>在MySQL中拼接两个字段只能使用<code>concat()</code>函数，而在其他的数据库中则运行使用<code>+</code>直接拼接。</p>
<h5 id="文本处理函数">4.2 文本处理函数</h5>
<p><img src="/2022/07/30/MySQL/stringFunc.png" width="700"></p>
<h5 id="日期和时间处理函数">4.3 日期和时间处理函数</h5>
<p><img src="/2022/07/30/MySQL/dateFunc.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">now</span><span class="params">()</span>,<span class="title">year</span><span class="params">(now())</span> as 年,<span class="title">month</span><span class="params">(now() )</span>as 月,<span class="title">date</span><span class="params">(now())</span> as 日</span>; </span><br><span class="line">+---------------------+------+------+------------+</span><br><span class="line">| <span class="built_in">now</span>()               | 年   | 月   | 日         |</span><br><span class="line">+---------------------+------+------+------------+</span><br><span class="line">| <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">25</span> | <span class="number">2022</span> |    <span class="number">8</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------------------+------+------+------------+</span><br></pre></td></tr></table></figure></p>
<h5 id="数值处理函数">4.4 数值处理函数</h5>
<p><img src="/2022/07/30/MySQL/numberFunc.png" width="700"></p>
<h5 id="汇总函数">4.5 汇总函数</h5>
<p>有时候我们需要对表中的数据进行汇总，而不是把它们实际检索出来，这时候就需要这样的函数，因此MySQL专门设立了<strong>汇总函数</strong> <img src="/2022/07/30/MySQL/finalFunc.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#统计一个班级共有多少学生？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student</span>;</span><br><span class="line">#统计数学成绩大于<span class="number">90</span>的学生有多少个？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student where math&gt;90</span>;</span><br><span class="line">#统计总分大于<span class="number">250</span>的人数有多少？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student where math+chinese+english&gt;250</span>;</span><br><span class="line">#统计一个班级数学总成绩？</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span> from student</span>;</span><br><span class="line">#统计一个班级语文、英语、数学各科的总成绩</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span>, <span class="title">sum</span><span class="params">(chinese)</span>, <span class="title">sum</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#统计一个班级语文、英语、数学的成绩总和</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math+chinese+english)</span>from student</span>;</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span>+<span class="title">sum</span><span class="params">(chinese)</span>+<span class="title">sum</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#求一个班级数学平均分？</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math)</span> from student</span>;</span><br><span class="line">#求一个班级总分平均分</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math+chinese+english)</span>from student</span>;</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math)</span>+<span class="title">avg</span><span class="params">(chinese)</span>+<span class="title">avg</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#求班级最高分和最低分</span><br><span class="line"><span class="function">select <span class="title">max</span><span class="params">(math+chinese+english)</span>,<span class="title">min</span><span class="params">(math+chinese+english)</span> from student</span>;</span><br></pre></td></tr></table></figure>
<h4 id="其他查询操作">4. 其他查询操作</h4>
<p>在这里将会介绍分组查询、子查询和组合查询等查询手段，进一步掌握查询检索方法。</p>
<h5 id="分组查询">4.1 分组查询</h5>
<p>分组查询得关键字为<code>group by</code>，使用该关键字能够使得检索后得结果按照你想要得情况进行分组,<strong>下述得<code>group by</code>句子指示是按<code>salary</code>排序并分组</strong>,这样一来我们就不用一一调用<code>select salary count(*) where salary=各个数值;</code>语句，只需要以<code>group by</code>就能执行全部，同时还有附有<code>order by</code>进行排序，如下所示： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#这句sql语句相当于<span class="function">select salary <span class="title">count</span><span class="params">(*)</span> where salary</span>=各个数值 order by salary;</span><br><span class="line">mysql&gt; select salary,<span class="built_in">count</span>(*) from customer group by salary;</span><br><span class="line">+--------+----------+</span><br><span class="line">| salary | <span class="built_in">count</span>(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|  <span class="number">12500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">13000</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">15500</span> |        <span class="number">2</span> |</span><br><span class="line">|  <span class="number">25500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">16500</span> |        <span class="number">1</span> |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="number">5</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>group by</code>分组数据，还允许对分组进行过滤，但在这里使用得不是<code>where</code>，而应该使用<code>having</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select salary,<span class="built_in">count</span>(*) from customer group by salary having salary&gt;=<span class="number">13000</span>;</span><br><span class="line">+--------+----------+</span><br><span class="line">| salary | <span class="built_in">count</span>(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|  <span class="number">13000</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">15500</span> |        <span class="number">2</span> |</span><br><span class="line">|  <span class="number">25500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">16500</span> |        <span class="number">1</span> |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="子查询">4.2 子查询</h5>
<p>迄今为止，我们上面学的得<code>select</code>查询语句都是单语句得简单查询，即都是从单个数据表中检索数据得单条语句。还有一种嵌套在其他查询中查询，内部的查询语句称为<strong>子查询</strong>。有子查询的语句从内向外处理</p>
<p><strong>使用子查询是因为在实际的应用中我们总不可能用一张表来存储全部的数据，而是让每一个表存储特定的内容，这样一来，我们就极有可能会用到一个表中的数据作为另一个表的字段名称或者条件来进行查询</strong>，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为条件</span></span><br><span class="line"><span class="function">select cust_id from order_num <span class="title">in</span><span class="params">(select order_num from orderitems where prod_id=<span class="string">&#x27;TNT2&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为计算字段</span></span><br><span class="line">select cust_name,cust_state,</span><br><span class="line">(select <span class="built_in">count</span>(*) from orders where order.cust_id=customer.cust_id) as orders from customer order by cust_name;</span><br></pre></td></tr></table></figure></p>
<h5 id="组合查询">4.3 组合查询</h5>
<p><strong>组合查询是将多个<code>select</code>语句的组合成一个结果集返回，这些组合查询通常称为并<code>union</code>或复合查询</strong>。使用组合查询的情况有以下两点：</p>
<ul>
<li>在多个查询中从不同表返回类似结构的数据要形成一个结果集</li>
<li>对单个表执行多个查询，要按单个查询结果集返回</li>
</ul>
<p>这时就可使用<code>union</code>操作符来组合数条SQL查询语句，<strong>使用时只需要在各条<code>select</code>语句之间加上<code>union</code>关键字即可，返回的结果集中会自动的去重</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary from employee where name=<span class="string">&#x27;trluper&#x27;</span></span><br><span class="line">   -&gt; <span class="keyword">union</span> select name,salary froom employee where name=<span class="string">&#x27;trl&#x27;</span>;</span><br><span class="line">+---------+--------+</span><br><span class="line">| name    | salary |</span><br><span class="line">+---------+--------+</span><br><span class="line">| trluper |  <span class="number">25500</span> |</span><br><span class="line">| trl     |  <span class="number">16500</span> |</span><br><span class="line">+---------+--------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>使用<code>union</code>时的规则:</strong></p>
<ul>
<li><code>union</code>必须由两条或以上的<code>select</code>语句上才能使用</li>
<li><code>union</code>的每个查询必须包含相同的列、表达式或聚集函数（不要求相同次序列出），输出会以第一个<code>select</code>语句的列名称为准</li>
<li>列数据必须兼容：类型不必完全相同，但是DBMS可以隐式转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select salary from employee where name=<span class="string">&#x27;trluper&#x27;</span>  <span class="keyword">union</span> select job_name from employyee_job where id=<span class="number">5</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| salary    |</span><br><span class="line">+-----------+</span><br><span class="line">| <span class="number">25500</span>     |</span><br><span class="line">| c++开发   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select name,salary from employee where name</span>=<span class="string">&#x27;trluper&#x27;</span>  <span class="keyword">union</span> <span class="title class_">select</span> salary,name frmom employee where name=<span class="string">&#x27;trl&#x27;</span>;</span><br><span class="line">+---------+--------+</span><br><span class="line">| name    | salary |</span><br><span class="line">+---------+--------+</span><br><span class="line">| trluper | <span class="number">25500</span>  |</span><br><span class="line">| <span class="number">16500</span>   | trl    |</span><br><span class="line">+---------+--------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="连结表多表查询">5. 连结表（多表查询）</h4>
<p><strong>我们知道将数据分不同种类存储到不同的表能够更有效率，也更方便管理，单是我们不可能在检索的时候对单个表单个表的检索，我们希望能够将不同表但相同对象的数据放置在一起，这和时候就用到了连结表。</strong>SQL最强大的功能就是能在数据检索查询的执行中连结<code>join</code>表，连结表不存在于数据库的存储中，它是在<code>select</code>运行过程依据条件创建而成。一般来说使用连结表最好是定义<strong>主键和外键</strong>，通过主外键将两者两者连结在一起。</p>
<p>下面的例子中employee的<code>ID</code>为主键，<code>employee_job</code>的外键为<code>ID</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee,employee_job where employee.id=employee_jjob.id order by salary desc;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面使用<code>where</code>子句来建立连结，但是对于连结表这一知识点来说，最好是使用它的特定规则来实现连结比较好即使用<code>join</code>关键字。如下介绍当中的：笛卡儿积、内连结、外连结。</p>
<h5 id="笛卡儿积交叉连接">5.1 笛卡儿积（交叉连接）</h5>
<p>笛卡尔集是指两个集合<code>A</code>和<code>B</code>的乘积,如下 <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如，有 A 和 B 两个集合，它们的值如下：</span><br><span class="line">A = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">B = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">集合 A×B 和 B×A 的结果集分别表示为：</span><br><span class="line">A×B=&#123;<span class="comment">(1,3)</span>, <span class="comment">(1,4)</span>, <span class="comment">(1,5)</span>, <span class="comment">(2,3)</span>, <span class="comment">(2,4)</span>, <span class="comment">(2,5)</span> &#125;;</span><br><span class="line">B×A=&#123;<span class="comment">(3,1)</span>, <span class="comment">(3,2)</span>, <span class="comment">(4,1)</span>, <span class="comment">(4,2)</span>, <span class="comment">(5,1)</span>, <span class="comment">(5,2)</span> &#125;;</span><br></pre></td></tr></table></figure> 我们发现笛卡儿积不遵从弄个交换律即<code>A*B≠B*A</code>。多表查询遵循的算法就是以上提到的笛卡尔积，表与表之间的连接可以看成是在做乘法运算。<strong>在实际应用中，应避免使用笛卡尔积，因为笛卡尔积中容易存在大量的不合理数据，简单来说就是容易导致查询结果重复、混乱。</strong>笛卡儿积使用<code>cross join</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee cross join employee_job order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 老大         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 开发         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 技术服务     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 产品经理     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | c++开发      |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| lili    |  <span class="number">15500</span> | c++开发      |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 产品经理     |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 老大         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 销售         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | c++开发      |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 销售         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 老大         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 开发         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | c++开发      |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 开发         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 销售         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 技术服务     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 产品经理     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 开发         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 技术服务     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 产品经理     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 销售         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 产品经理     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 老大         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 销售         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">36</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="内连接">5.2 内连接</h5>
<p><strong>基于两个表直接的主键和外键相等的查询称为内部链接</strong>。只返回满足<code>on</code>后连接条件的数据（两边都有的才显示）。（对应oracle等值连接。） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee a inner join employee_job b on a.id=b.id order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br></pre></td></tr></table></figure></p>
<h5 id="外连接">5.3 外连接</h5>
<p>外连结有左外连结和右外连结，外连接与内连接的不同在于外连接对于另一个表会显示全部记录，不管符不符合后边<code>on</code>的条件，另一个表只显示符合条件的数据。</p>
<h6 id="左外连结">5.3.1 左外连结</h6>
<p><code>left join</code>是<code>left outer join</code>的简写，它的全称是左外连接，是外连接中的一种。外连接，左表<code>a</code>的记录将会全部表示出来，而右表<code>b</code>只会显示符合搜索条件的记录。右表记录不足的地方均为<code>NULL</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee a left join employee_job b on a.id=b.idorder by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| Adson   |  <span class="number">19000</span> | <span class="literal">NULL</span>         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">7</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="右外连接">5.3.2 右外连接</h6>
<p>效果同左外是相反的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ysql&gt; select name,salary,job_name from employee a right join employee_job b on a.id=b.id order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="视图">6. 视图</h4>
<p>视图是虚拟的比表，与包含数据的表不同，视图只包含使用时动态检索数据的查询<strong>。即视图是将一个查询语句包装成一个有名字的虚拟表，我们可以通过该虚拟表来使用这个查询语句</strong>。因此对于视图来说具有以下优点：</p>
<ul>
<li>重用SQL语句</li>
<li>简化了复杂的SQL操作，在编写查询后，我们可以很方便重用它，而不用知道它的细节</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据，可以给用户授予表的特定部分的权限而不是整个表的访问权限</li>
<li>更改数据格式和表示。视图可以返回与底层表不同的数据格式和表示。</li>
<li>节省空间，有了视图，不用在去创建一个同视图一样的表，在有需要的使用视图生成一个临时表即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create view employee_view as select name,salary,hiredate from employee,employee_job where employee.id=employee_job.id;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; show tables</span>;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| employee       |</span><br><span class="line">| employee_job   |</span><br><span class="line">| employee_view  |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">3</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select * from employee_view</span>;</span><br><span class="line">+---------+--------+------------+</span><br><span class="line">| name    | salary | hiredate   |</span><br><span class="line">+---------+--------+------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     |  <span class="number">13000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    |  <span class="number">15500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper |  <span class="number">25500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     |  <span class="number">16500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+--------+------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p><strong><em>注意</em></strong>：通常来说，视图是支持更新的，即可以对视图使用和表一样的<code>insert\update\delete</code>操作，因为视图只是一个包装<code>select</code>语句的虚拟表，因此更新一个视图会更新其相关的底层表，对视图的更新就是对底层表的更新。<strong>但是并不是所有的视图都支持更新，如果视图不能正确的确定被更新的基数据所在就不能更新。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">算法题解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 21:30:13" itemprop="dateCreated datePublished" datetime="2022-07-30T21:30:13+08:00">2022-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-01 23:38:57" itemprop="dateModified" datetime="2022-08-01T23:38:57+08:00">2022-08-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="动态规划类">1. 动态规划类</h4>
<h5 id="打家劫舍">1.1 打家劫舍</h5>
<p><strong>问题：</strong>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]：表示第i家房屋结尾的最多能偷窃到的最高数额</span></span><br><span class="line">        <span class="comment">//初始条件：dp[0]=nums[0]、dp[1]=nums[1]</span></span><br><span class="line">        <span class="comment">//因为对邻接房屋偷窃，则dp[i]=max(dp[x])+nums[i]，0≤x&lt;i-1</span></span><br><span class="line">        <span class="comment">//这样的算法复杂度为O(N*N)，可以通过两个变量，使得算法降为O(N)</span></span><br><span class="line">        <span class="comment">//变量maxOdd表示奇次序的最大值，maxEven表示偶次序的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="comment">//初始条件</span></span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//maxOdd初始为dp[1]，maxEven初始为dp[0]</span></span><br><span class="line">        <span class="type">int</span> maxOdd=dp[<span class="number">1</span>],maxEven=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==i%<span class="number">2</span>)      <span class="comment">//为偶下标</span></span><br><span class="line">            &#123;</span><br><span class="line">               dp[i]=nums[i]+maxEven;</span><br><span class="line">                <span class="comment">//更新奇偶的最大值</span></span><br><span class="line">                <span class="keyword">if</span>(maxOdd&lt;maxEven)</span><br><span class="line">                    maxOdd=maxEven;</span><br><span class="line">                maxEven=<span class="built_in">Max</span>(maxEven,maxOdd,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>            <span class="comment">//奇下标</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=nums[i]+maxOdd;</span><br><span class="line">                <span class="keyword">if</span>(maxOdd&gt;maxEven)</span><br><span class="line">                    maxEven=maxOdd;</span><br><span class="line">                maxOdd=<span class="built_in">Max</span>(maxEven,maxOdd,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMaxValue</span>(dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="最长回文子串">1.2 最长回文子串</h5>
<p><strong>问题：</strong>给你一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]:表示s[i]是否等于s[j],相等且回文则置为true，否则为false</span></span><br><span class="line">    <span class="comment">//初始条件：dp[i][i]=true;</span></span><br><span class="line">    <span class="comment">//状态转移方程：</span></span><br><span class="line">	<span class="comment">//①若i和j是相邻的即i+1=j且s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//②若不相邻，则判断内侧是否为true，若dp[i+1][j-1]=true&amp;&amp;s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//通过增加两变量记录当前回文串的最长长度Maxlen,初始为1,以及记录回文串的下标开始index_min，初始为最后一个元素</span></span><br><span class="line">    <span class="comment">//算法的时间复杂度为O(n*n)</span></span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>||len==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(len,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> Maxlen=<span class="number">1</span>,index_min=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])<span class="comment">//如果两元素相等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i+<span class="number">1</span>)<span class="comment">//如果相邻</span></span><br><span class="line">                    dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//不相邻，判断两元素内部是否为回文串</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;Maxlen&lt;j-i+<span class="number">1</span>)<span class="comment">//更新Maxlen和index_min</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Maxlen=j-i+<span class="number">1</span>;</span><br><span class="line">                    index_min=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ret=s.<span class="built_in">substr</span>(index_min,Maxlen);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="树类">2. 树类</h4>
<h4 id="链表类">3. 链表类</h4>
<h4 id="字符串类">4. 字符串类</h4>
<h4 id="双指针类">5. 双指针类</h4>
<h5 id="无重复字符的最长子串">5.1 无重复字符的最长子串</h5>
<p><strong>问题：</strong>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<blockquote>
<p>示例： 输入: s = &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用滑动窗口的思路，即双指针的应用，左指针first表示以该元素为起始点</span></span><br><span class="line">   <span class="comment">//右指针last表示[first,last)是以s[first]开头最长无重复子串，以first为起始</span></span><br><span class="line">   <span class="comment">//不断向右移动右指针，直到遇到重复的为止</span></span><br><span class="line">   <span class="comment">//用unordered_set记录来判断是否有重复元素</span></span><br><span class="line">   <span class="comment">//虽然是双循环，但是内部右指针不重置，移动次数为常数，因此时间复杂度为O(N)</span></span><br><span class="line">   <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">0</span>==len||<span class="number">1</span>==len)</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    <span class="type">int</span> last=<span class="number">0</span>,maxLen=<span class="number">1</span>;</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; hSet;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;len;first++)  <span class="comment">//左指针向前</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不是第一次进入循环，说明当前元素s[last]与hSet存在重复，不断去除前一个</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>!=first)</span><br><span class="line">            hSet.<span class="built_in">erase</span>(s[first<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//不断右移右指针，直到遇到重复的</span></span><br><span class="line">        <span class="keyword">while</span>(last&lt;len&amp;&amp;!hSet.<span class="built_in">count</span>(s[last]))</span><br><span class="line">        &#123;</span><br><span class="line">            hSet.<span class="built_in">insert</span>(s[last]);</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen=<span class="built_in">max</span>(maxLen,last-first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="盛最多水的容器">5.2 盛最多水的容器</h5>
<p><strong>问题</strong>：给定一个长度为<code>n</code>的整数数组<code>height</code>。有<code>n</code>条垂线，第<code>i</code>条线的两个端点是<code>(i, 0)</code>和<code>(i, height[i])</code>。找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//双指针，一头指向头，一个指向尾</span></span><br><span class="line">    <span class="comment">//原理不用多说，看代码即可知</span></span><br><span class="line">    <span class="comment">//复杂度O(N)</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> maxCap=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="built_in">Min</span>(height[left],height[right])*(right-left);</span><br><span class="line">        <span class="keyword">if</span>(maxCap&lt;tmp)</span><br><span class="line">            maxCap=tmp;</span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深度优先搜索类">6. 深度优先搜索类</h4>
<h4 id="广度优先搜索类">7. 广度优先搜索类</h4>
<h4 id="数学">8. 数学</h4>
<h4 id="矩阵">9. 矩阵</h4>
<h4 id="图类">5. 图类</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" class="post-title-link" itemprop="url">动态规划算法思想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-29 13:56:14" itemprop="dateCreated datePublished" datetime="2022-07-29T13:56:14+08:00">2022-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-31 10:25:02" itemprop="dateModified" datetime="2022-07-31T10:25:02+08:00">2022-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="动态规划">1. 动态规划</h4>
<p>我们遇到的问题中，有很大一部分可以用动态规划<code>Dynamic Programming</code>来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解题</p>
<h5 id="动态规划的原理">1.1 动态规划的原理</h5>
<p><strong>动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度</strong>， 因此它比回溯法、暴力法等要快许多。动态规划要求我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。由于单纯使用语言来描述动态规划晦涩难懂，因此采用例子来说明：</p>
<p><strong>问题1：假设有1元、3元和5元的硬币，如何用最少的的硬币凑够11元？</strong></p>
<p>学过贪心算法知道，加如使用贪心算法，每次拿面额最高的银币来逼近这个11是一个方法，但它不能保证一定是最少数量的。因此这里介绍动态规划来解答。正如上面所说，动态规划就是将问题小化，以上一次的子问题的最优解推出下一个的最优解：</p>
<ul>
<li>因此我们可想当面额为<code>i</code>时，最少的硬币数量是多少，我们使用<code>dp[i]</code>表示凑够<code>i</code>元时最少的硬币数量。</li>
<li>豪无疑问，当<code>i=0</code>时<code>dp[0]=0</code>，因为题目给出了1元、3元和5元的面额，我们需要对这些进行处理，因此能够得到其他的初始条件，<code>i=1</code>时<code>dp[i]=1</code>,i=3时<code>dp[3]=1</code>,i=5时<code>dp[5]=</code>。</li>
<li>完成了初始化条件后，我们可以继续推其他面额的情况，由提供的三种面额，可以知道当<code>i=2</code>时<code>dp[2]=2</code>，但<code>i=3</code>时，组成它的有两种选择，一种时三个1元硬币，另一种是直接选择3元，有<code>min(dp[3].dp[2]+1)</code>知道<code>dp[3]=1</code>是最优解，同样<code>dp[4]</code>，它可以有<code>4=1+3</code>或者<code>4=3+1</code>，两者的的数量是一致的，只不过是次序的不同，再到<code>dp[5]</code>可以检查<code>min(dp[4]+1,dp[2]+1,dp[5])</code>取最小</li>
<li>由上面的分析，我们可以很容易的分析到这样一个状态转移方程： <span class="math display">\[
dp[i]=
\begin{cases}
min(dp[i-1]+1,dp[i-3]+1,dp[i-5]+1),i&gt;5\\
1,i=1,3,5\\
2,i=2,4
\end{cases}
\]</span></li>
</ul>
<p>这样问题就迎刃而解，得如下代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 有面值1，3，5的硬币，试求组成39元时用到最少的硬币数量</span></span><br><span class="line"><span class="comment">* 首先定义dp[i]表示i元时用到得最少银币数</span></span><br><span class="line"><span class="comment">* 由题得初始化条件dp[0]=0,dp[1]=1,dp[3]=1,dp[5]=5</span></span><br><span class="line"><span class="comment">* 当i&gt;5时，会有状态转移方程dp[i]=min(dp[i-1].dp[i-3],do[i-5])+1;</span></span><br><span class="line"><span class="comment">*当i&lt;=5时，这个范围含的2，4未初始化，</span></span><br><span class="line"><span class="comment">*可以增加以判断条件当i-1&gt;=0,i-3&gt;=0,i-5&gt;0来决定，是否要在状态转移方程添加对应项</span></span><br><span class="line"><span class="comment">* 这里由于能够自己推段2，4的最小数量，直接当作初始化，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCoin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">40</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">5</span>] = <span class="number">1</span>;	</span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	dp[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] = <span class="built_in">Min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">3</span>], dp[i - <span class="number">5</span>]) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">39</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的案例可以知道，解决动态规划的策略最重要的三步是：</p>
<ul>
<li><strong>确定<code>dp</code>数组的含义</strong></li>
<li>确定可从题意得出的临界值</li>
<li><strong>确定状态转移方程</strong></li>
</ul>
<p>有了状态和状态转移方程，问题基本上也就解决了，接下来的问题只是如何写迭代代码而已。</p>
<h5 id="初级问题">1.2 初级问题</h5>
<p>上面的硬币问题只能说是很简单的动态规划问题，我们可以在来看看更复杂一点的。</p>
<p><strong>问题：</strong>一个序列有N个数：A[1],A[2],…,A[N]，求出最长连续非降子序列的长度</p>
<p>同样对于这个问题也能使用动态规划来解决，定义一个<code>dp[i]</code>表示包括当前下标<code>i</code>的非降子序列的长度，那么就有这样的条件：</p>
<ul>
<li>初始条件中，我们肯定可以知道<code>i=0</code>时<code>d[i]=1</code>。</li>
<li>状态转移方程则有<code>d=1+(s[i]&gt;=s[i-1]?d[i-1]:0)</code>，这个状态转移方程指示，我们只需将当前的访问的元素与上一个元素进行对比，如果是<code>&gt;=</code>，则与之前一样是一个非降子序列，反之则不是，重新计数非降子序列长度</li>
<li>最后只需要遍历一次<code>d[i]</code>就能得到最长非降子序列的长度，起始和结束位置也能递推</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">maxLength</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len)</span></span>;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] =<span class="number">1</span>+( s[i] &gt;= s[i - <span class="number">1</span>] ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getmaxValue</span>(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的问题可以进一步升级，不要求连续，如下：</p>
<p><strong>问题：</strong>一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度</p>
<p>虽然这个问题不要求连续，我们同样能够使用一维<code>dp[i]</code>尝试解决，同样要找出初始条件和状态转移方程。<strong>我们可以让<code>dp[i]</code>是表示在以<code>A[i]</code>结尾的即下标<code>0~i</code>的子序列的最长非降长度</strong>，那么就有如下策略：</p>
<ul>
<li>初始条件<code>dp[0]=1</code></li>
<li>状态转移方程有两种情况，一是必须在前面找到所有的个x,使得<code>A[i]&gt;=A[x]</code>，更新<code>dp[x]=dp[x]+1</code>,然后执行取最大值,如果没有找到则直接赋值为<code>dp[i]=1</code>。即</li>
</ul>
<p><span class="math display">\[
dp[i]=
\begin{cases}
max(dp[x]+1)     当之前序列存在A[i]&gt;=A[x]时，\\
1，           之前的序列不存在A[x]&lt;=A[i]时
\end{cases}
\]</span></p>
<ul>
<li>最后遍历一遍<code>dp</code>数组，取最大值，</li>
<li>该算法因为当<code>A[i]&lt;A[i-1]</code>时，需要从后往前遍历dp数组。外部循环为<code>n</code>，内部平均循环为<code>n/2</code>，因此时间复杂度为<code>O(N*N)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSonLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(len);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(i)</span></span>;</span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cap[i] &gt; cap[j]) &#123;</span><br><span class="line">                    tmp[index]=dp[j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> max=<span class="built_in">getmaxValue</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (max==<span class="number">0</span>)</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=max+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getmaxValue</span>(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的算法分时间复杂度达到了<code>O(N*N)</code>,是否有办法使复杂度降到<code>O(NlogN)</code>？我们可以看到上面的程序之所以变为<code>O(N*N)</code>，是因为每次对<code>A[i]</code>都要遍历之前的<code>A[x]</code>，我们是否可以通过增加一个数组来存储形成的最长非降子序列，然后进行二分查找呢，经过二分查找使得复杂度变为<code>O(NlogN)</code>:</p>
<p><strong>要这样做我们必须重新定义<code>dp[i]</code>数组的意义，<code>dp[i]</code>它表示长度为<code>i+1</code>的递增子序列中，最大的序列尾数；再定义一个<code>maxL</code>变量，指示当前最长递增子序列的长度，对数组<code>dp</code>二分查找，判断<code>cap[x]</code>要插入的位置</strong></p>
<ul>
<li>若<code>cap[x]&gt;dp[maxL]</code>,表示当前该值比递增子序列的尾数都大，将<code>cap[x]</code>添加到<code>dp</code>尾部，<code>maxL++</code></li>
<li>若<code>dp[i-1]&lt;cap[x]&lt;dp[i]</code>，更新相应<code>dp[i]</code>即可</li>
</ul>
<p>显然这种方法以及不算动态规划了，是一种特殊解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; storage)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">	<span class="type">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> lo = <span class="number">0</span>, hi = maxL;</span><br><span class="line">		<span class="comment">//二分查找</span></span><br><span class="line">		<span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (dp[mid] &lt; num)</span><br><span class="line">				lo = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				hi = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[lo] = num;</span><br><span class="line">		<span class="keyword">if</span> (lo == maxL)</span><br><span class="line">		&#123;</span><br><span class="line">			maxL++;</span><br><span class="line">			<span class="keyword">if</span>(storage[<span class="number">0</span>].size&lt;maxL)</span><br><span class="line">				storage.<span class="built_in">clear</span>();</span><br><span class="line">			storage.<span class="built_in">push_back</span>(dp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>附加：如果要你返回所有最长递增子序列或者返回最长递增子序列的个数该如何解决？</em></strong> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/solution/zui-chang-di-zeng-zi-xu-lie-de-ge-shu-by-w12f/">leetcode第673题.最长递增序列的个数</a></p>
<h5 id="中级">1.3 中级</h5>
<p>上面举的例子都是对一维<code>dp</code>来解决，接下来介绍如何解决二维<code>dp</code>的问题。</p>
<p>**问题：平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果**</p>
<p>当然了，使用动态规划<code>dp</code>就要找初始条件喝状态转移方程</p>
<ul>
<li>定义二维数组<code>dp[N][M]</code>，<code>d[i][j]</code>表示从<code>A[0][0]</code>到<code>A[i][j]</code>能收集到的最多苹果数量</li>
<li>因为只能向下喝右移动，则有状态转移方程<code>d[i][j]=max(d[i-1][j],d[i][j-1])+A[i][j]</code>，其中<code>i&gt;0,j&gt;0</code></li>
<li>为了方便实现状态转移方程，我们可以人增加隔离带，即<code>A[0][j]=0、A[i][0]=0</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxApple</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cap.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> row = cap[<span class="number">0</span>].<span class="built_in">size</span>(),</span><br><span class="line">		col = cap.<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(col+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(row+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= col; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= row; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> Max = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			dp[i][j] = Max + cap[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[col][row];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述算法复杂度为<code>O(N*M)</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-28 13:30:57" itemprop="dateCreated datePublished" datetime="2022-07-28T13:30:57+08:00">2022-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-30 22:51:26" itemprop="dateModified" datetime="2022-07-30T22:51:26+08:00">2022-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="算法总览">1. 算法总览</h4>
<p>常见的排序算法有<strong>插入排序、选择排序、希尔排序、堆排序、冒泡排序、快速排序、归并排序和基数排序</strong>。常见排序算法可以分为两大类：</p>
<ul>
<li><strong>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破<code>O(nlogn)</code>，因此称为非线性时间比较类排序</strong>。</li>
<li><strong>线性时间非比较类排序：</strong>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。排序算法的时间复杂度如下： <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort.png" width="700"></li>
</ul>
<p><strong>算法的稳定性：</strong>稳定性就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。</p>
<ul>
<li><strong>稳定排序算法</strong>：冒泡排序、插入排序、归并排序、计数排序、桶排序与基数排序</li>
<li><strong>不稳定排序算法</strong>：希尔排序、选择排序、堆排序与快速排序</li>
</ul>
<p><strong>内部排序和外部排序：</strong>内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。上面所列举的都是内部排序。像多路归并可以采用外部排序</p>
<h5 id="插入排序">1.1 插入排序</h5>
<ul>
<li><strong>基本思想：</strong>每次将当前元素插入到左侧（有序区）已经排序的数组中，使得插入之后的左侧数组依然有序。
<ul>
<li>查找出元素要插入的位置：要插的元素与之前排好的子序比较</li>
<li>将要插入位置的元素及后面的元素后移一个位置</li>
<li>将元素插入</li>
</ul></li>
<li><p><strong>复杂度</strong>：插入排序一共需要两重循环，第一重循环确定需要加入有序序列的新元素，一共n-1轮，第二重循环确定新元素在原来有序序列中的位置，平均需要<code>n/4</code>轮可以确定位<code>O(n²)</code>,空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性：</strong>每次比较时遇到第一个小于等于新元素的元素，就将新元素插入到该元素的后面，即可不破坏相等元素的相对顺序，做到算法稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len== <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = cap[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; cap[j] &gt; tmp; j--)</span><br><span class="line">            cap[j + <span class="number">1</span>] = cap[j];</span><br><span class="line">        cap[j + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="希尔排序">1.2 希尔排序</h5>
<p>通过上面对插入排序程序的编写知道，插入排序适用于基本有序和数据量不大的排序表，<strong>希尔排序</strong>是基于这两点改进而来的。</p>
<ul>
<li><p><strong>基本思想</strong>：先将待排序表分割成若干形如 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">L</span>[i,i+d,i+<span class="number">2</span>d……,i+kd]</span><br></pre></td></tr></table></figure> 既把步长相隔增量d的记录组成一个子表，对各个子表分别进行直接插入排序。当整个表的元素已呈<strong>“基本有序”</strong>时，再次对全体记录进行一次直接插入排序。一般来说，步长取<code>d=n/2</code>，之后都已<code>1/2</code>递减。</p>
<ul>
<li>1.取一步长<code>d1&lt;n</code>，把表中全部记录分发d组</li>
<li>2.所有距离为<code>d1</code>的倍数的记录放到一组。</li>
<li>3.在各组内进行直接插入排序</li>
<li>4.取第二个步长<code>d2&lt;d1</code>，重复上述过程，直到<code>d=1</code>。</li>
<li>5.<code>d=1</code>时，再进行一次直接插入排序</li>
</ul></li>
<li><p><strong>复杂度：</strong>希尔排序的时间复杂度会随着<code>d</code>选取策略的不同而发生变化，但是通常保持在<span class="math inline">\(O(n^{1.3})~O(n^{1.5})\)</span>;希尔排序依旧属于原地排序，不需要额外的空间，所以空间复杂度与插入排序一样为<code>O(1)</code></p></li>
<li><p><strong>稳定性：</strong>虽然插入排序是稳定的排序算法，但是希尔排序因为将序列进行了拆分再进行插入排序，如此不同组中的相等元素相对位置不能保证不变，所以相等元素的相对位置会发生改变，故时不稳定排序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/shellSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = len / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;len ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = cap[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; cap[j] &gt; tmp; j -= d)</span><br><span class="line">                cap[j + d] = cap[j];</span><br><span class="line">            cap[j + d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="选择排序">1.3 选择排序</h5>
<p>选择排序<code>Selection-sort</code>是一种简单直观的排序算法。它的</p>
<ul>
<li><p><strong>基本思想：</strong>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始（末尾）位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></li>
<li><p><strong>复杂度：</strong>选择排序一共需要比较<code>n-1</code>轮（每轮找到最小的元素进行交换），第<code>m</code>轮比较<code>n-m</code>次，所以比较的总次数为：$ _{i=0}^{n-1}n-i <span class="math inline">\(，即为\)</span>O(N^2)<span class="math inline">\(。选择排序不需要额外的空间，故其空间复杂度为\)</span>O(1)$</p></li>
<li><p><strong>稳定性：</strong>由于选择出的元素可能会进行跨越式的交换，所以会破坏原本的顺序，所以不稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即使终止的选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size = cap.<span class="built_in">size</span>(); !sorted &amp;&amp; size &gt; <span class="number">1</span>; size--)</span><br><span class="line">    &#123;		<span class="comment">//每一轮size-1,最大的放在后面   </span></span><br><span class="line">        <span class="type">int</span> indexOfMax = <span class="number">0</span>;</span><br><span class="line">        sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap[indexOfMax] &lt; cap[i])		<span class="comment">//找出最大的值</span></span><br><span class="line">                indexOfMax = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sorted = <span class="literal">false</span>;	<span class="comment">//无序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Swap</span>(cap[indexOfMax], cap[size - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="冒泡排序">1.4 冒泡排序</h5>
<ul>
<li><p><strong>基本思想：</strong>从后往前（从前往后），两两比较相邻元素的值。若为逆序A[i]&lt;A[i-1]，则交换他们。每一轮将最大的放到后面（即每一次减少一次内循环）</p></li>
<li><p><strong>复杂度：</strong>冒泡排序一共需要比较<code>n-1</code>轮，第<code>m</code>轮比较<code>n-m</code>次，所以其比较总次数应为：<span class="math inline">\(\displaystyle\sum_{i=0}^{n-1}n-i\)</span>，故冒泡排序的时间复杂度为<code>O(n²)</code>。冒泡排序比较和交换的过程中不消耗额外的内存，故冒泡排序的空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性</strong>：比较时如果两个元素相等则不交换，即可做到使算法稳定 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序时及时终止的冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(T&amp; cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cap.<span class="built_in">size</span>(); sorted &amp;&amp; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        sorted = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (cap[j] &gt; cap[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(cap[j], cap[j + <span class="number">1</span>]);</span><br><span class="line">                sorted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速排序">1.5 快速排序**</h5>
<ul>
<li><strong>基本思想</strong>：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。
<ul>
<li>1.选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</li>
<li>2.分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</li>
<li>3.递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</li>
</ul></li>
<li><p><strong>复杂度</strong>：<strong>快速排序的性能受到基准选择策略的影响</strong>，理论上如果每次选择基准都选择分区的第一个元素，那么这个序列越有序则时间复杂度越趋近于<code>O(n²)</code>，这是因为每次基准都是分区最大或最小的元素，那么左区间将会没有元素，而右区间将会有除了基准外的全部元素，这样就跟普通的插入排序没有区别了，<strong>因此对于快排会有优化措施</strong>。<strong>快速排序的最坏运行情况是<code>O(n²)</code>，比如说顺序数列的快排。但它的平摊期望时间是<code>O(nlogn)</code>，且<code>O(nlogn)</code> 记号中隐含的常数因子很小</strong>，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。<strong>快速排序可以实现原地排序，不需要消耗额外的内存，所以快速排序的空间复杂度为<code>O(1)</code>。</strong></p></li>
<li><p><strong>稳定性</strong>：快速排序不能保证相等元素的相对顺序不发生改变，所以不稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写自己的quickSort,没有优化，遇到最坏情况的时间复杂度会变成O(N*N)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--;</span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="快排优化">1.5.1 快排优化</h6>
<p>对于快排，其性能受到基准选择策略的影响，当出现下面两种情况时为最坏情况：</p>
<ul>
<li>在分解时每次选取的基准点为最小元素</li>
<li>在分解时每次选取的基准点为最大元素</li>
</ul>
<p>为了避免快排出现上述所说的最坏情况，选择哪一个元素作为基准点是关键，<strong>在快排过程中采用三点取中间值的优化方案。三数取中<code>median-of-three</code>指的是在挑选基准元素时，不是简单的选择数组中的第一个元素或最后一个，而是选取某三个元素，常选头、尾和中央三个元素，并且适用三个元素之中的中位数作为基准元素进行划分</strong>。这样即使在最坏的情况下将时间复杂度推进到<code>O(NlogN)</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后的快排代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">medianOfThree</span>(a, first, (first + last) / <span class="number">2</span>, last);</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--; </span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cap[first] &lt; cap[mid])</span><br><span class="line">        <span class="keyword">if</span> (cap[first] &gt;= cap[last])	<span class="comment">//last=&lt;first&lt;mid</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&lt;mid&lt;last</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[mid];</span><br><span class="line">            cap[mid] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">// first&lt;last&lt;=mid</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[last];</span><br><span class="line">            cap[last] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[first] &lt; cap[last])	<span class="comment">//last&gt;first&gt;=mid</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&gt;=mid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[last];</span><br><span class="line">        cap[last] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[mid];</span><br><span class="line">        cap[mid] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.png" width="600"> 上图对优化后和优化前的快排进行了测试，很明显三数取中后对与升序和降序数组的时间得到了大大的改善，避免了最坏情况，逼近<code>O(NlogN)</code>,<strong>但是对于重复数组的优化还不能得到很好的改善，因此可以在三数取中的快排中加入以下的策略：</strong></p>
<ul>
<li><p>优化一：当待排序序列的长度分割到一定大小后，使用插入排序，这是因为对于很小部分大致有序的数组，快排不如插排效率。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</p></li>
<li><p>优化二：当待排序序列的长度分割到一定大小后如100个，使用计数排序，这样能够很明显的提升大量重复值情况下的效率</p></li>
</ul>
<h5 id="堆排序">1.6 堆排序*</h5>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个完全二叉树的结构，并同时满足堆的的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p>
<p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
<ul>
<li><strong>基本思想</strong>：
<ul>
<li><p><strong>插入：</strong>因为<strong>堆是完全二叉树，所以当加入一个元素形时，必须维持该堆仍为完全二叉树</strong>，即该新节点位置由此定下了肯定为叶子结点。接着元素插入要依据原来是大根堆还是小根堆（即不能破环该堆的性质）。把插入的元素，沿着从新节点到根节点的路径<code>i/2</code>，执行一趟冒泡操作，将新元素与其夫节点的元素比较交换，直到后者大于前者（大根堆为例）。</p></li>
<li><p><strong>删除：在大根堆中删除一个元素，其实就是删除根节点的元素</strong>。此时就需要重新组织，以便保持性质不变 。其策略是，从删除的位置开始为一个树,向下找，找到该树的最后一个叶子节点，删除该节点但保存元素到临时量；然后比较节点的左右孩子，将大的放到该根节点；这时因为大孩子的被放到根节点而成为了空(没有元素），以此类推，直到最后一个叶子我们与之前中间量保存的元素比较，完成删除排序，</p></li>
<li><p><strong>初始化：</strong>当堆刚开始时就要有n个元素，我们就要构建非空堆，我们需要在堆中执行n次插入操作。先将元素按层次插入，取位置在i=n/2的元素，如果以这个元素为根的子树是大根堆则不做操作，如果不是大根堆则从该节点开始的树进行检测替换，依次检查i-1,i-2……1</p></li>
</ul></li>
<li><p><strong>复杂度</strong>：堆排序的时间复杂度是标准的<code>O(nlogn)</code>。用数组实现堆的功能，故空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性</strong>：堆排序并不是进行线性的比较，而是根据堆的结构进行比较，所以在交换时会破坏相等元素原本的相对顺序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/heapSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆插入</span></span><br><span class="line"><span class="comment">该方法通过查询当前堆的大小和元素比较定位插入点，进行大根堆完全二叉树形式插入即`/2`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T&amp; heap,<span class="type">const</span> T&amp; theElement)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> currentNode=++heapsize;</span><br><span class="line">	<span class="comment">//通过比较寻找插入点，比插入值小的元素下沉</span></span><br><span class="line">	<span class="keyword">while</span>(currentNode!=<span class="number">1</span>&amp;&amp;heap[currentNode/<span class="number">2</span>]&lt;theElement)</span><br><span class="line">	&#123;</span><br><span class="line">		heap[currentNode]=heap[currentNode/<span class="number">2</span>];</span><br><span class="line">		currentNode/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入新值</span></span><br><span class="line">	heap[currenNode]=theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆删除</span></span><br><span class="line"><span class="function">templaet&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; heap)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(heapsize==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	heap[<span class="number">1</span>].~<span class="built_in">T</span>();		<span class="comment">//销毁根节点元素</span></span><br><span class="line">	T lastElement=heap[heapsize];	<span class="comment">//最后一个元素保存到临时变量</span></span><br><span class="line">	heap[heapsize--].~<span class="built_in">T</span>();			<span class="comment">//销毁最后一个元素</span></span><br><span class="line">	<span class="type">int</span> currentNode=<span class="number">1</span>,child=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;heapsize)</span><br><span class="line">	&#123;	<span class="comment">//元素进行上升</span></span><br><span class="line">		<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="comment">//判断lastElement是否可以放在heap[child]上</span></span><br><span class="line">		<span class="keyword">if</span>(lastElement&gt;=heap[child])	<span class="comment">//可以就直接退出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		heap[currentNode]=heap[child];</span><br><span class="line">		currentNode=child;</span><br><span class="line">		child*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currentNode]=lastElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(T&amp; Heap,std::<span class="type">size_t</span> _heapsize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	heapsize=_heapsize;</span><br><span class="line">	<span class="comment">//从下往上进行堆化，即从heapsize/2开始，直到root=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> root=heapsize/<span class="number">2</span>;root&gt;=<span class="number">1</span>;root--)</span><br><span class="line">	&#123;</span><br><span class="line">		T rootElement=heap[root];</span><br><span class="line">		<span class="type">int</span> child=<span class="number">2</span>*root;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;=heapsize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span>(rootElement&gt;=heap[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			heap[child/<span class="number">2</span>]=heap[child];</span><br><span class="line">			child*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[child/<span class="number">2</span>]=rootElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你也可以不用写堆排序，直接使用STL当中的<code>push_heap、pop_heap、make_heap</code>进行插入、删除和初始化一个堆。</p>
<h5 id="基数排序">1.7 基数排序*</h5>
<p>基数排序是一种<strong>非比较型整数排序算法</strong>，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<ul>
<li><strong>基本思想</strong>：基数排序排序主要通过将数字分解进行排序，如三位数的925，基数排序可通过十进制分解，将925分解成9、2、5三个数，然后依次以个位、十位、百位进行排序。<strong>在这个过程中，因为数字只有0~9,所有仅仅需要10个桶就，然后调用三次箱子排序即可</strong>：
<ul>
<li>1.将无序集合中的所有元素根据个位的大小分别分配到0-9十个桶中；</li>
<li>2.从个位为0的桶开始依据每个元素的十位将元素分配到0-9十个桶中；</li>
<li>3.每次依据的位数增加一位（百位，千位，万位），直到集合中最大的数的位数为止；</li>
<li>4.最后一次分配完成后从第0个桶开始依次取出元素，直到所有的元素被取出来，这个取出的顺序可以保证元素是从小到大的；</li>
</ul></li>
<li><p><strong>复杂度</strong>：每一次散列需要对每个元素进行分配，即n次操作，最多进行最大的数的位数轮散列分配，即k轮，所以时间复杂度为<code>O(n*k)</code>。基数排序需要<code>n+m</code>个额外空间，其中<code>n</code>为待排序集合大小，<code>m</code>为10（无负数元素）或<code>20</code>（有负数元素）</p></li>
<li><p><strong>稳定性</strong>：基数排序不会破坏相等元素的相对顺序，所以是稳定的 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/radixSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(T&amp; cap,<span class="type">int</span> place)</span> </span>&#123;	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,num=<span class="number">1</span>; i &lt; place; i++,num*=<span class="number">10</span>) &#123;<span class="comment">//num指示对哪一位进行基数排序</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">tempVec</span>(<span class="number">10</span>);<span class="comment">//二维数组，内部vector的大小看数据量 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cap.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = cap[i] / num % <span class="number">10</span>;</span><br><span class="line">            tempVec[index].<span class="built_in">push_back</span>(cap[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cap.<span class="built_in">clear</span>();		<span class="comment">//清除里面的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)		<span class="comment">//放回vec</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = tempVec[i].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (it != tempVec[i].<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cap.<span class="built_in">push_back</span>(*it);</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="归并排序">1.8 归并排序**</h5>
<ul>
<li><strong>基本思想</strong>：归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法<code>Divide and Conquer</code>的一个非常典型的应用。<strong>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序</strong>。若将两个有序表合并成一个有序表，称为二路归并。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：一是自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；二是自下而上的迭代；
<ul>
<li>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>4.重复步骤 3 直到某一指针达到序列尾；</li>
<li>5.将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul></li>
<li><p><strong>复杂度</strong>：很明显归并排序需要<code>logn</code>轮合并，每轮合并需要<code>n-1~n/2</code>次比较，所以时间复杂度为<code>O(nlogn)</code>.归并排序比较占用内存，但却是一种效率高且稳定的算法，其需要临时空间存储归并后的数据，因此空间复杂度为<code>O(N)</code></p></li>
<li><p><strong>稳定性</strong>：归并排序的合并操作并不会影响相同元素的相对顺序，故稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//使用迭代实现二路归并排序</span></span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(len);       <span class="comment">//合并空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)</span><br><span class="line">    &#123;   <span class="comment">//logn趟合并</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//合并相邻两子序列</span></span><br><span class="line">            <span class="type">int</span> next = j + i;</span><br><span class="line">            <span class="type">int</span> k = j;</span><br><span class="line">            <span class="keyword">while</span>(k &lt;(j+i) &amp;&amp; k&lt;len &amp;&amp; next &lt; len &amp;&amp; next &lt; (j+<span class="number">2</span>*i) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cap[k] &lt;= cap[next])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[index] = cap[k];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[index] = cap[next];</span><br><span class="line">                    next++;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k&lt;len &amp;&amp;k &lt; j + i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[index] = cap[k];</span><br><span class="line">                index++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (next &lt; len &amp;&amp; next &lt; j + <span class="number">2</span> * i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[index] = cap[next];</span><br><span class="line">                index++;</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            j = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), cap.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计数排序">1.9 计数排序</h5>
<ul>
<li><p><strong>基本思想：</strong>计数排序的核心在于<strong>将输入的数据值转化为键存储在额外开辟的数组空间中</strong>。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<strong>确定范围的整数</strong>。当输入的元素是<code>n</code>个0到k之间的整数时，它的运行时间是<code>Θ(n + k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。<strong><em>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量内存，因此堆数据范围很大的不适用，该排序算法最号应用于数据范围不大重复值多的情况</em></strong>。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>遍历数组<code>cap</code>，对值<code>i</code>作为cap的下标存入<code>+1</code>,即<code>C[i]++</code>;</li>
<li>对所有的重复值计数累加</li>
<li>从前往后遍历数组C，将对应的下标index作为值存人<code>cap</code>，并在<code>C[index]-1</code></li>
</ul></li>
<li><p><strong>复杂度</strong>：计数排序的时间复杂度与待排序元素的范围相关，其时间复杂度为<code>O(n+k)</code>,其中<code>n</code>为元素数量，<code>k</code>为元素的范围（即最大的元素与最小的元素的差加1）。计数排序需要额外开辟k个桶的空间，所以空间复杂度为<code>(k)</code>。</p></li>
<li><p><strong>稳定性</strong>：计数排序是一个非基于比较的线性时间排序算法,所以看出是一种稳定排序 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/countingSortgif.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxValue = <span class="built_in">getMaxValue</span>(cap)+<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(maxValue)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : cap)</span><br><span class="line">        tmp[i]++;</span><br><span class="line">    <span class="type">int</span> _index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxValue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (tmp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cap[_index] = i;</span><br><span class="line">            tmp[i]--;</span><br><span class="line">            _index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="桶排序">1.10 桶排序*</h5>
<ul>
<li><strong>基本思想</strong>：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：<strong>一是在额外空间充足的情况下，尽量增大桶的数量；二是使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</strong>。同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。
<ul>
<li>1.开辟m大小的空间，生成m个桶，每个桶对应一个范围；</li>
<li>2.将待排序的所有元素依次按照范围散列到对应的桶里；</li>
<li>3.对所有的桶内的元素以桶为单位排序；</li>
<li>4.从第一个桶开始依次将排好序的元素取出；</li>
</ul></li>
<li><p><strong>复杂度</strong>：对于待排序序列大小为<code>N</code>，共分为<code>M</code>个桶，<code>N</code>次循环，将每个元素装入对应的桶中。<code>M</code>次循环，对每个桶中的数据进行排序（平均每个桶有<code>N/M</code>个元素）。一般使用较为快速的排序算法，时间复杂度为 O(N/MlogN/M)，整个桶排序的时间复杂度为：<code>O(N)+O(M∗(N/M∗log(N/M))) = O(N)+O(N∗(log(N/M)) = O(N)+O(C）= O(N∗(log(N/M)+1))</code>；桶排序需要额外的m个桶的空间和n个元素的空间，故空间复杂度为<code>O(m+n)</code>。</p></li>
<li><p><strong>稳定性</strong>：桶排序的稳定性取决于桶内排序使用的算法，所以我们通常认为桶排序是稳定排序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bucketSort.png" width="400"></p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/18/Makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/18/Makefile/" class="post-title-link" itemprop="url">Makefile</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-18 12:06:19" itemprop="dateCreated datePublished" datetime="2022-07-18T12:06:19+08:00">2022-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-23 13:20:49" itemprop="dateModified" datetime="2022-07-23T13:20:49+08:00">2022-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Makefile/" itemprop="url" rel="index"><span itemprop="name">Makefile</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="make">1. make</h4>
<h5 id="make是什么">1.1 make是什么</h5>
<p>make是一个命令，是管理文件的自动编译管理器，这里的自动是指能根据文件时间戳自动发现更新过的文件而减少编译的工作量，同时通过读取makefile的文件的内容来进行预期的编译工作，make将只编译有改动的文件，而不用完全编译。</p>
<h5 id="工作原理">1.2工作原理</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app:main.o hello.o</span><br><span class="line">        gcc -o app main.o hello.o</span><br><span class="line">main.o:main.c hello.h</span><br><span class="line">        gcc -c main.c</span><br><span class="line">hello.o:hello.c hello.h</span><br><span class="line">        gcc -c hello.c</span><br><span class="line">clean:</span><br><span class="line">        rm app main.o hello.o</span><br></pre></td></tr></table></figure>
<ul>
<li><code>make</code>在当前目录寻找<code>Makefile</code>或<code>makefile</code>文件。</li>
<li>如果找到，它会找文件中的第一个目标文件<code>target</code>，如上例它找到<code>app</code>这个目标文件，把这个文件作为最终的目标文件。如果<code>app</code>文件不存在,或是<code>app</code>所依赖的后面的<code>.o</code>文件的文件修改时间要比<code>app</code>这个文件新，那么<code>make</code>命令就会执行后面所定义的命令来生成<code>app</code>这个文件。</li>
<li><strong>如果<code>app</code>所依赖的<code>.o</code>文件也不存在，那么<code>make</code>命令会在当前文件中寻找目标为<code>.o</code>文件的依赖关系。如果找到，则再根据那一个规则生成<code>.o</code>文件，根据<code>.o</code>文件依赖的<code>.c</code>文件和<code>.h</code>文件，执行规则生成<code>.o</code>文件。</strong></li>
<li><strong>然后make再用<code>.o</code>文件生成执行文件<code>app</code></strong></li>
</ul>
<p><strong>总而远之，<code>make</code>会依据依赖关系一层一层地去找文件的依赖关系,直到最终编译出第一个目标文件</strong>。在找寻的过程中,如果出现错误,如最后被依赖的文件找不到,那么 make 就会直接退出并报错。</p>
<p>但是像<code>clean</code>这种没有被第一个目标文件直接或间接关联,那么它后面所定义的命令将不会被自动执行。不过，可以显式指定<code>make</code>执行<code>clean</code>，即<code>make　clean</code>。<strong>同时只要修改了与第一个目标文件存在直接或间接依赖关系的文件，都会发生重新编译和重新链接</strong></p>
<h5 id="make命令">1.3 make命令</h5>
<p>make是一个命令工具，它解释Makefile 中的指令（应该说是规则） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make [ -f file ][ options ][ targets ]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>-f file</code>:<code>make</code>默认在工作目录中寻找名为<code>GNUmakefile、makefile、Makefile</code>的文件作为<code>makefile</code>输入文件,但有时可能命名不是这些,则<code>-f</code>可以指定以上名字以外的文件作为makefile输入文件</p></li>
<li><code>options</code>
<ul>
<li><code>v：</code>显示make工具的版本信息</li>
<li><code>w：</code>在处理<code>makefile</code>之前和之后显示工作路径</li>
<li><code>C dir：</code>读取<code>makefile</code>之前改变工作路径至dir目录</li>
<li><code>n：</code>只打印要执行的命令但不执行</li>
<li><code>s：</code>执行但不显示执行的命令</li>
</ul></li>
<li><p><code>targets</code>:使用<code>make</code>命令时没有指定目标，则<code>make</code>工具默认会实现<code>makefile</code>文件内的第一个目标，如果指定了<code>make</code>工具要实现的目标则该目标为最终目标（目标可以是一个或多个）</p></li>
</ul>
<h4 id="makefile">2. Makefile</h4>
<p><code>Makefile</code>是一个脚本文件，其内部编写一些符和<code>make</code>工具解析的语法规则来进行执行一些命令。</p>
<h5 id="makefile是什么">2.1 Makefile是什么</h5>
<p><code>makefile</code>定义了一系列的规则来指定，<strong>哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译</strong>，甚至于进行更复杂的功能操作，因为<code>makefile</code>就像一个<code>Shell</code>脚本一样，其中也可以执行操作系统的命令。<code>Makefile</code>带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。<code>makefile</code>文件由<code>make</code>命令工具来执行。</p>
<p><strong>make主要解决两个问题：</strong></p>
<ul>
<li><strong>1) 大量代码的关系维护</strong>:大项目中源代码比较多，手工维护、编译时间长而且编译命令复杂，难以记忆及维护,把代码维护命令及编译命令写在<code>makefile</code>文件中，然后再用<code>make</code>工具解析此文件自动执行相应命令，可实现代码的合理编译</li>
<li><strong>2) 减少重复编译时间</strong>，在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有的目标文件，节省编译时间。</li>
</ul>
<p><code>Makefile</code>文件命名规则<code>makefile</code>和<code>Makefile</code>都可以，推荐使用<code>Makefile</code>,即<code>vim Makefile</code>。学号<code>Makefile</code>只需要学习他的<strong>一条规则，三个变量，两个函数</strong>就能上手了。</p>
<h5 id="一条规则">2.2 一条规则</h5>
<p><strong>一条规则</strong>即指完成单此任务所包含的要素，Makefile的一条规则三要素如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一条规则</span></span><br><span class="line">target... : prerequisites ...</span><br><span class="line">     command</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>target</code>:<strong>通常是要产生的文件名称，目标可以是可执行文件或其它obj文件，也可是一个标签</strong></li>
<li><code>prerequisites</code>：依赖文件，用来输入从而产生目标的文件，一个目标通常有几个依赖文件（也可以没有）。<code>prerequisites</code>中如果有一个以上的文件比<code>target</code>文件要新的话，<code>command</code>所定义的命令就会被执行。</li>
<li><code>command</code>：make执行的动作，一个规则可以含几个命令（可以没有）。有多个命令时，每个命令占一行。</li>
</ul>
<p><code>make</code>工具从上往下找寻<code>target</code>，<strong>根据<code>target</code>后对应的依赖关系，先去查找依赖项的文件,为索所有的目标文件创建依赖关系链</strong>。若依赖项不存在，则会报错： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make div.o</span><br><span class="line">make: *** No rule to make target <span class="string">&#x27;div.cpp&#x27;</span>, needed by <span class="string">&#x27;div.o&#x27;</span>.  Stop.</span><br></pre></td></tr></table></figure> 若存在，在检查依赖关系时，同时会检查目标与源文件的时间戳，当源文件时间戳更新时，make会更新依赖它的链路上所有文件，即调用command部分。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Makefile件</span></span><br><span class="line">sum.o:sum.cpp</span><br><span class="line">        g++ -c  sum.cpp -o sum.o</span><br><span class="line">main.o:main.cpp</span><br><span class="line">        g++ -c main.cpp -o main.o</span><br><span class="line">main:main.o sum.o</span><br><span class="line">        g++ main.o sum.o -o main</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make sum.o main.o main</span><br><span class="line">make: <span class="string">&#x27;sum.o&#x27;</span> is up to date.</span><br><span class="line">g++ -c main.cpp -o main.o</span><br><span class="line">g++ main.o sum.o -o main</span><br></pre></td></tr></table></figure></p>
<h5 id="变量">2.3 变量</h5>
<p>在<code>Makefile</code>中使用变量有点类似于C语言中的宏定义，使用该变量相当于内容替换，使用变量可以使<code>Makefile</code>易于维护,修改内容变得简单变量定义及使用。<strong>在<code>Makefile</code>中由自定义变量和自动变量</strong>。</p>
<h6 id="等号">2.3.1 等号</h6>
<p>在学习变量前需要熟悉Makefile中的等号，等号有4种<code>=，:=，?=，+=</code>。</p>
<ul>
<li><code>?=</code>表示，如果左边的变量没有被赋值，那么将等号右边的值赋给左边的变量。如果赋过值，则保持原来的值不变。</li>
<li><code>+=</code>表示将等号右边的值追加到左边变量中，但是中间会有一个空格。</li>
<li><code>=</code>与<code>:=</code>是比较不好区分的两个等号，可以将”=“理解为&quot;址传递&quot;或引用，”:=“理解为&quot;值传递”。</li>
</ul>
<p>在<code>Makefile</code>中是不允许将变量自己的值赋给自己的，也不允许出现循环引用。</p>
<h6 id="变量名的规则">2.3.2 变量名的规则</h6>
<p><strong><code>makefile</code>的变量名的起名规则：</strong></p>
<ul>
<li><code>makefile</code>变量名可以以数字开头</li>
<li>变量是大小写敏感的</li>
<li>变量一般都在<code>makefile</code>的头部定义</li>
<li>变量几乎可在<code>makefile</code>的任何地方使用</li>
</ul>
<h6 id="自定义变量">2.3.3 自定义变量</h6>
<ul>
<li>1）定义变量方法：<code>变量名=变量值</code>,<code>变量名？=变量值</code>,<code>变量名+=变量值</code>,<code>变量名:=变量值</code></li>
<li><ol start="2" type="1">
<li>使用变量名：<code>$(变量名)</code>或<code>$&#123;变量名&#125;</code></li>
</ol></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objs=add.o sum.o div.o mul.o</span><br><span class="line">target=main</span><br><span class="line">$(target):$(bgjs)</span><br><span class="line">		gcc &amp;(objs) -o $(target)</span><br></pre></td></tr></table></figure>
<h6 id="三个重要自动变量">2.3.4 三个重要自动变量</h6>
<p><code>Makefile</code>的自动变量有以下几个:</p>
<p><img src="/2022/07/18/Makefile/auto.png" width="700"></p>
<p><strong>其中重要常用的三个是：</strong></p>
<ul>
<li><code>$@:</code> 表示规则中的目标</li>
<li><code>$&lt;:</code>表示规则中依赖性的第一个</li>
<li><code>$^:</code> 表示规则中的所有依赖性, 组成一个列表, 以空格隔开,如果这个列表中有重复的项则消除重复项。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">objs=add.o sum.o div.o mul.o</span><br><span class="line">target=main</span><br><span class="line">sum.o:sum.cpp</span><br><span class="line">        g++ -c  $^ -o $@</span><br><span class="line">main.o:main.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br><span class="line">$(target):$(bgjs)</span><br><span class="line">		g++ &amp;(objs) -o $(target)</span><br><span class="line">clean:</span><br><span class="line">		rm -rf $(objs) $(target)</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：自动变量只能在规则的命令中中使用</em></strong></p>
<h5 id="模式规则">2.4 模式规则</h5>
<p>如果想要进一步的偷懒，那就必须提到<strong>模式规则</strong>，模式规则用来匹配当前目录下的符合模式匹配的所有文件。模式规则类似于普通规则，<strong>只是在模式规则中，目标名中需要包含有模式字符<code>%</code>，包含有模式字符<code>%</code>的目标被用来匹配一个文件名，<code>%</code>可以匹配任何非空字符串</strong>。看到上面你觉得很绕，让我们看实例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#%表示可以匹配当前目录下的所有以.cpp为后缀的源文件，</span><br><span class="line">#并且对应生成相应名称的.o文件（注意是使用$&lt;才能生成对应.o文件</span><br><span class="line">%.o:%.cpp</span><br><span class="line">		g++ -c $&lt; -o $@</span><br></pre></td></tr></table></figure> 单独上面的这个<code>makefile</code>不能成功执行，会出现<code>No targets.Stop</code>错误 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接make，不成功</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make</span><br><span class="line">make: *** No targets.  Stop.</span><br><span class="line"><span class="comment">//传入目标，成功</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make main.o</span><br><span class="line">g++ -c main.cpp -o main.o</span><br></pre></td></tr></table></figure> 这是很正常的，因为<code>%</code>是模式匹配规则，你如果没传入目标它就无法执行<code>make</code>的工作机制。下面来讲解对<code>%</code>的解决办法</p>
<h5 id="函数">2.5 函数</h5>
<p><code>makefile</code>中的函数有很多，在这里给大家介绍两个最常用的:</p>
<ul>
<li><p><code>wildcard</code>查找指定目录下的指定类型的文件 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src = $(wildcard *.c) <span class="comment">//找到当前目录下所有后缀为.c的文件,赋值给src</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>patsubst</code>匹配替换 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = $(patsubst %.c,%.o, $(src)) <span class="comment">//把src变量里所有后缀为.c的文件替换成.o，然后赋值给obj</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong><em>注意</em></strong>：<code>patsubst</code>不是把src里的文件的后缀改为.o，是在<code>makefile.o</code>文件内部将生成的<code>.o</code>文件替换掉<code>src</code>内的<code>.cpp</code>文件，因此在<code>make</code>的时候一定是要先生成<code>.o</code>文件（这里从两者<code>*</code>和<code>%</code>就能看出)，从两者的特性能够得到以下的解决： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all:$(patsubst %.cpp,%.o,$(wildcard *.cpp))</span><br><span class="line">%.o:%.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br></pre></td></tr></table></figure> 原理：all目标获得了目录内的<code>*.cpp</code>文件，使用<code>patsubst</code>要求将<code>*.cpp</code>替换为<code>*.o</code>,但是目录中还没有<code>*.o</code>文件，则会依据make工作原理进行到下一个目标，刚好这个目标是生成<code>.o</code>文件的，则执行。</p>
<h5 id="简单示例">2.6 简单示例</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.cpp)</span><br><span class="line">objs=$(patsubst %.cpp,%.o,$(src))</span><br><span class="line">target=main</span><br><span class="line">$(target):$(objs)</span><br><span class="line">        g++ $(objs) -o $(target)</span><br><span class="line">%.o:%.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">#PHONY伪目标，不去判断目标文件是否存在或者更新，无条件执行</span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">        rm -rf $(objs) $(target)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#执行make</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make</span><br><span class="line">g++ -c main.cpp -o main.o</span><br><span class="line">g++ -c sum.cpp -o sum.o</span><br><span class="line">g++ main.o sum.o -o main</span><br><span class="line">#执行makeclean</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">Linux操作系统基本命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-15 17:26:07" itemprop="dateCreated datePublished" datetime="2022-07-15T17:26:07+08:00">2022-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-23 12:41:17" itemprop="dateModified" datetime="2022-07-23T12:41:17+08:00">2022-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="shell">1. shell</h4>
<p><code>shell</code>是<code>Linux</code>系统中运行的一种特殊程序。在用户和内核之间之间充当“翻译官”，用户登陆<code>Linux</code>系统时，自动加载一个<code>Shell</code>程序，<code>Bash</code>是<code>Linux</code>系统中默认使用的<code>Shell</code>程序。</p>
<ul>
<li>内核：用于调用计算机硬件资源</li>
<li>shell：将用户指令转换成计算机语言让内核去调用计算机硬件资源 <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell.png" width="500"></li>
</ul>
<h4 id="bash解析器常用快捷键teminal">2. Bash解析器常用快捷键(Teminal)</h4>
<p><code>bash</code>是一个文件，linux系统中万物皆文件，<code>bash</code>文件位于<code>/bin/bash</code>，<code>bash</code>使用的快捷键：</p>
<ul>
<li><code>Tab</code>键:补齐命令，补齐路径，显示当前目录下的所有目录</li>
<li>使用快捷键<code>Ctrl + L</code> 清除终端上的显示(类似于DOS的cls清屏功能)，也可用<code>clear</code>指令</li>
<li><code>ctlr+c</code>的作用是中断终端的操作。</li>
<li>遍历输入的历史命令：从当前位置向上遍历<code>ctrl + p</code>或<code>↑</code>；从当前位置向下遍历<code>ctrl + n（↓）</code></li>
<li>光标相关操作</li>
<li>光标左移： <code>ctrl + b （←）</code></li>
<li>坐标右移： <code>ctrl + f （→）</code></li>
<li>移动到头部：<code>ctrl + a（Home）</code></li>
<li>移动到尾部：<code>ctlr + e（End）</code></li>
<li>字符删除</li>
<li>删除光标前边的字符：ctrl + h（Backspace）</li>
<li>删除光标后边的字符：ctrl + d</li>
<li>删除光标前所有内容：ctrl + u</li>
<li>删除光标后所有内容：ctrl + k</li>
</ul>
<h4 id="系统目录">3. 系统目录</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oot@trluper-<span class="keyword">virtual</span>-machine:/home/trluper<span class="meta"># cd /</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/<span class="meta"># ls</span></span><br><span class="line">bin    dev   lib    libx32      mnt   root  snap      sys  var</span><br><span class="line">boot   etc   lib32  lost+found  opt   run   srv       tmp</span><br><span class="line">cdrom  home  lib64  media       proc  sbin  swapfile  usr</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/</code>：根目录，一般根目录下只存放目录，<strong>在<code>Linux</code>下有且只有一个根目录</strong>。所有的东西都是从这里开始。当你在终端里输入<code>/home</code>，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</li>
<li><code>/bin</code>: <strong>这一目录中存放了供超级用户和一般用户都可以使用的命令，常用的命令<code>ls、tar、mv、cat</code>等</strong></li>
<li><code>/usr/bin</code>: <strong>安装的外部的命令，<code>usr</code>表示的是<code>unix software source</code>，不是user。</strong></li>
<li><code>/boot</code>：放置<code>linux</code>系统启动时用到的一些文件，如<code>Linux</code>的内核文件<code>/boot/vmlinuz</code>，系统引导管理器<code>/boot/grub</code>。</li>
<li><code>/dev</code>：存放<code>linux</code>系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，</li>
<li><code>/etc</code>：<strong>系统配置文件存放的目录，不建议在此目录下存放可执行文件</strong>，重要的配置文件有 <code>/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</code></li>
<li><code>/home</code>：<strong>系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，<code>~edu</code>表示用户<code>edu</code>的家目录。</strong></li>
<li><code>/lib</code>：<strong>内核级别</strong>,系统使用的函数库的目录，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/lib</code>: <strong>系统级别</strong>，目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录</li>
<li><code>/usr/local/lib</code>：<strong>用户级别</strong>，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/include</code>：<strong>C程序语言编译使用的头文件。<code>linux</code>下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数</strong></li>
<li><code>/lost+fount</code>：系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li><code>/mnt、/media</code>:光盘默认挂载点，通常光盘挂载<code>/mnt/cdrom</code>下，也不一定，可以选择任意位置进行挂载。</li>
<li><code>/opt</code>：给主机额外安装软件所摆放的目录。</li>
<li><code>/proc</code>：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 <code>/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*</code> 等。</li>
<li><code>/root</code>：系统管理员root的家目录。</li>
<li><code>/sbin、/usr/sbin、/usr/local/sbin</code>：<strong>放置系统管理员使用的可执行命令</strong>，如<code>fdisk、shutdown、mount</code>等。<strong>与<code>/bin</code>不同的是，这几个目录是给系统管理员root使用的命令，</strong>一般用户只能&quot;查看&quot;而不能设置和使用。</li>
<li><code>/tmp</code>：<strong>一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</strong></li>
<li><code>/srv</code>：服务启动之后需要访问的数据目录，如<code>www</code>服务需要访问的网页数据存放在<code>/srv/www</code>内。</li>
<li><code>/usr</code>：<strong>应用程序存放目录，<code>/usr/bin</code>存放应用程序，<code>/usr/share</code>存放共享数据，<code>/usr/lib</code>存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。<code>/usr/local</code>:存放软件升级包。<code>/usr/share/doc:</code>系统说明文件存放目录。<code>/usr/share/man:</code>程序说明文件存放目录。</strong></li>
<li><code>/var</code>：放置系统执行过程中经常变化的文件，如随时更改的日志文件 <code>/var/log，/var/log/message</code>所有的登录文件存放目录，<code>/var/spool/mail</code>邮件存放的目录，<code>/var/run</code>程序或服务启动后，其PID存放在该目录</li>
</ul>
<h4 id="linux的文件">4. Linux的文件</h4>
<p>在Linux世界里，一切皆文件。在Linux中，文件可分为以下几种：<strong>普通文件（普通文件、可执行文件、压缩文件）、目录文件、设备文件、链接文件和套接字</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linuxFile.png" width="400"></p>
<p><strong>文件符号标识：</strong></p>
<ul>
<li>普通文件:<code>-</code></li>
<li>目录：<code>d</code></li>
<li>字符设备：<code>c</code></li>
<li>管道：<code>p</code></li>
<li>符号链接：<code>l</code></li>
<li>套接字：<code>s</code></li>
<li>符号连结：<code>l</code></li>
<li>一般文件:<code>f</code></li>
</ul>
<h4 id="linux常用命令">5. Linux常用命令</h4>
<p>Linux的命令分为内建命令和外部命令。<code>shell</code>内建命令是指<code>bash</code>工具中集成的命令，一般有一些都会有一个与之同名的系统函数。外部命令是安装外部软件所带的命令。</p>
<h5 id="内建命令和外部命令的区别">5.1 内建命令和外部命令的区别</h5>
<ul>
<li><p><strong>内部命令</strong>：实际上是<code>shell</code>程序的一部分，其中包含的是一些比较简单的<code>linux</code>系统命令，这些命令由<code>shell</code>程序识别并在<code>shell</code>程序内部完成运行，通常在<code>linux</code>系统加载运行<code>shell</code>时就被加载并驻留在系统内存中。内部命令是写在bashy源码里面的，<strong>其执行速度比外部命令快，因为解析内部命令shell不需要创建子进程</strong>。<code>exit，history，cd，echo</code>等就是内建命令 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help 内建命令</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>外部命令</strong>：<strong>外部命令是<code>linux</code>系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存</strong>。通常外部命令的实体并不包含在<code>shell</code>中，但是其命令执行过程是由<code>shell</code>程序控制的。<code>shell</code>程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。外部命令是在<code>bash</code>之外额外安装的，通常放在<code>/bin，/sbin，/usr/bin，/usr/sbin，/usr/local/sbin</code>等等。可通过<code>echo $PATH</code>命令查看外部命令的存储路径 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是外部命令一个--help选项，不是help指令</span></span><br><span class="line">外部命令 --help</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>type</code>命令可以分辨内部命令与外部命令</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用的三个参数：-t对应-type，-a对应-all，-p对应-path，</span></span><br><span class="line">type [-a | -t | -p] name</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">type [-all | -type | -path] name</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="内建命令使用">5.2 内建命令使用</h5>
<p>所有内建命令如下：加星号的为常用项</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
<th style="text-align: center;">重要程度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>：</code></td>
<td>扩展参数列表，执行重定向操作</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>.</code></td>
<td>读取并执行指定文件中的命令（在当前shell环境中）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>alias</code></td>
<td>为指定命令定义一个别名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>bg</code></td>
<td>将作业以后台模式运行</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>bind</code></td>
<td>将键盘序列绑定到一个<code>readline</code>函数或宏</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>break</code></td>
<td>退出<code>for、while、selec</code>t或<code>until</code>循环</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>builtin</code></td>
<td>执行指定的<code>shell</code>内建命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>caller</code></td>
<td>返回活动子函数调用的上下文</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>cd</code></td>
<td>将当前目录切换为指定目录</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>command</code></td>
<td>执行指定的命令，无需进行通常的shell查找</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>compgen</code></td>
<td>为指定单词生成可能的补全匹配</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>complete</code></td>
<td>显示指定的单词是如何补全的</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>compopt</code></td>
<td>修改指定单词的补全选项</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>continue</code></td>
<td>继续执行<code>for、while、select或until</code>循环的下一次迭代</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>declare</code></td>
<td>声明一个变量或者变量类型</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>dirs</code></td>
<td>显示当前存储目录的列表</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>disown</code></td>
<td>从进程作业表中删除指定的作业</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>echo</code></td>
<td>将指定字符串输出到<code>STDOUT</code></td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>enable</code></td>
<td>启用或禁止指定的内建<code>shell</code>命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>eval</code></td>
<td>将指定的参数拼接成一个命令，然后执行该命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>exec</code></td>
<td>用指定命令替换<code>shell</code>进程</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>exit</code></td>
<td>强制<code>shell</code>以指定的退出状态码退出</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>export</code></td>
<td>设置子<code>shell</code>进程可用的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>fc</code></td>
<td>从历史记录中选择命令列表</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>fg</code></td>
<td>将作业以前台模式运行</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>getopts</code></td>
<td>分析指定的位置参数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>hash</code></td>
<td>查找并记住指定命令的全路径名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>help</code></td>
<td>显示帮助文件</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>history</code></td>
<td>显示命令历史记录</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>jobs</code></td>
<td>列出活动作业</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>kill</code></td>
<td>向指定的进程ID发送一个系统信号</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>let</code></td>
<td>计算一个数学表达式中的每个参数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>local</code></td>
<td>在函数中创建一个作用域受限的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>logout</code></td>
<td>退出登录<code>shell</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>mapfile</code></td>
<td>从<code>STDIN</code>读取数据行，并将其加入索引数组</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>popd</code></td>
<td>从目录栈中删除记录</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>printf</code></td>
<td>使用格式化字符串显示文本</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>pushd</code></td>
<td>向目录栈添加一个目录</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>pwd</code></td>
<td>显示当前工作目录的路径名</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>read</code></td>
<td>从<code>STDIN</code>读取一行数据并将其赋值给一个变量</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>readarray</code></td>
<td>从<code>STDIN</code>读取数据行并将其放入索引数组</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>readonly</code></td>
<td>从<code>STDIN</code>读取一行数据并将其赋值给一个不可修改的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>return</code></td>
<td>强制函数以某个值退出，这个值可以被调用脚本提取</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>set</code></td>
<td>设置并显示环境变量的值和shell属性</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>shift</code></td>
<td>将位置参数依次向下降一个位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>shopt</code></td>
<td>打开/关闭控制<code>shell</code>可选行为的变量值</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>source</code></td>
<td>读取并执行指定文件中的命令（在当前<code>shell</code>环境中）</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>suspend</code></td>
<td>暂停<code>shell</code>的执行，直到收到一个<code>SIGCONT</code>信号</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>test</code></td>
<td>基于指定条件返回退出状态码0或1</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>times</code></td>
<td>显示累计的用户和系统时间</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>trap</code></td>
<td>如果收到了指定的系统信号，执行指定的命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>type</code></td>
<td>显示指定的单词如果作为命令将会如何被解释</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>typeset</code></td>
<td>声明一个变量或变量类型</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>ulimit</code></td>
<td>为系统用户设置指定的资源的上限</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>umask</code></td>
<td>为新建的文件和目录设置默认权限</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>unalias</code></td>
<td>删除指定的别名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>unset</code></td>
<td>删除指定的环境变量或<code>shell</code>属性</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>wait</code></td>
<td>等待指定的进程完成，并返回退出状态码</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h6 id="cd命令">5.2.1 cd命令</h6>
<p><code>cd</code>命令是改变当前工作目录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ../	返回上一级目录</span><br><span class="line">cd /  进入根目录</span><br><span class="line">cd ~	进入用户主目录</span><br><span class="line">如：</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ cd ~</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ pwd</span><br><span class="line">/home/trluper</span><br></pre></td></tr></table></figure></p>
<h6 id="dirs命令">5.2.2 dirs命令</h6>
<p><code>dirs</code>命令用于显示<code>Shell</code>目录中的堆栈记录。不加选项时显示当前的Shell命令堆栈中的所有目录，显示时左边为最新加入的目录。</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>删除目录堆栈中的所有记录</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>以完整格式显示堆栈中的目录。显示用户宿主目录时，列出完整路径，而不是“~”</td>
</tr>
<tr class="odd">
<td><code>-n</code></td>
<td>显示右起第n个目录（n从0计数）</td>
</tr>
<tr class="even">
<td><code>+n</code></td>
<td>显示左起第n个目录 （n从0计数）</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td>以每行一个记录的方式列出堆栈中多有记录</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>以每行一个记录的方式列出堆栈中所有记录，并在每行加上序号（从0开始编号）</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ dirs -v</span><br><span class="line"> <span class="number">0</span>  ~/Documents</span><br></pre></td></tr></table></figure>
<h6 id="echo命令">5.2.3 echo命令</h6>
<p><code>echo</code>命令用于将输入的字符串送往标准输出，默认输出的字符间以空白字符隔开，并在最后加上换行号。常与重定向命令<code>&gt;</code>结合使用。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo [OPTION]... [STRING]...</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>参数选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-n</code></td>
<td>不输出行尾的换行符，不自动换行</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>允许对下面列出的加反斜线转义的字符进行解释</td>
</tr>
<tr class="odd">
<td><code>-E</code></td>
<td>默认选项，禁止对在STRINGs中的那些序列进行解释</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ echo -e <span class="string">&quot;这是echo&quot;</span></span><br><span class="line">这是echo</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ echo -e <span class="string">&quot;这是echo&quot;</span> &gt;test.txt</span><br></pre></td></tr></table></figure>
<h6 id="help命令">5.2.4 help命令</h6>
<p>help命令用于显示<code>shell</code>内部命令的帮助信息。<code>help</code>命令只能显示<code>shell</code>内部的命令帮助信息。而对于外部命令的帮助信息只能使用<code>man</code>或者<code>info</code>或者以外部命令的<code>--help</code>选项查看。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ help cd</span><br><span class="line">cd: cd [-L|[-P [-e]] [-@]] [dir]</span><br><span class="line">    Change the shell working directory.</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<h6 id="history命令">5.2.5 history命令</h6>
<p><code>Bash</code>有完善的历史命令，这对于简化管理操作、排查系统错误都有重要的作用，而且使用简单方便，建议大家多使用历史命令。系统保存的历史命令可以使用<code>history</code>命令查询。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history [选项] [历史命令保存文件]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>c</code></td>
<td>清空历史命令</td>
</tr>
<tr class="even">
<td><code>w</code></td>
<td>把缓存中的历史命令写入历史命令保存文件中。如果不手工指定历史命令保存文件，则放入默认历史命令保存文件<code>~/.bash_history</code>中</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ history</span><br><span class="line">    <span class="number">1</span>  ping baidu.com</span><br><span class="line">    <span class="number">2</span>  ifconfig</span><br><span class="line">    <span class="number">3</span>  sudo apt install net-tools</span><br><span class="line">    <span class="number">4</span>  ifconfig </span><br><span class="line">    <span class="number">5</span>  ping baidu.com</span><br><span class="line">    <span class="number">6</span>  sudu apt update</span><br><span class="line">    <span class="number">7</span>  sudo apt update</span><br><span class="line">    <span class="number">8</span>  ifconfig</span><br><span class="line">    <span class="number">9</span>  ssh</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h6 id="kill命令">5.2.6 kill命令</h6>
<p><code>kill</code>命令用于删除执行中的程序或工作。<code>kill</code>可将指定的信息送至程序。预设的信息为<code>SIGTERM(15)</code>，可将指定程序终止。若仍无法终止该程序，可使用<code>SIGKILL(9)</code>信息尝试强制删除程序。程序或工作的编号可利用 <code>ps</code>指令或<code>jobs</code>指令查看。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [信号] PID</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>信号编号</th>
<th>信号名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><code>EXIT</code></td>
<td>程序退出时收到该信息。</td>
</tr>
<tr class="even">
<td>1</td>
<td><code>HUP</code></td>
<td>挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。</td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>INT</code></td>
<td>表示结束进程，但并不是强制性的，常用的<code>Ctrl+C</code>组合键发出就是一个 <code>kill -2</code> 的信号。</td>
</tr>
<tr class="even">
<td>3</td>
<td><code>QUIT</code></td>
<td>退出。</td>
</tr>
<tr class="odd">
<td>9</td>
<td><code>KILL</code></td>
<td>杀死进程，即强制结束进程。</td>
</tr>
<tr class="even">
<td>11</td>
<td><code>SEGV</code></td>
<td>段错误。</td>
</tr>
<tr class="odd">
<td>15</td>
<td><code>TERM</code></td>
<td>正常结束进程，是<code>kill</code>命令的默认信号。</td>
</tr>
</tbody>
</table>
<h6 id="pwd命令">5.2.7 pwd命令</h6>
<p>命令用于显示工作目录。执行<code>pwd</code>指令可立刻得知您目前所在的工作目录的绝对路径名称。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ pwd</span><br><span class="line">/home/trluper/Documents</span><br></pre></td></tr></table></figure></p>
<h6 id="ulimit命令">5.2.8 ulimit命令</h6>
<p><code>ulimit</code>用来限制每个用户可使用的资源，如CPU、内存、句柄等。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]	设置limit</span><br><span class="line">ulimit [-SHabcdefiklmnpqrstuvxPT]			查询</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>S</code></td>
<td>表示软限制,超出设定的值会告警</td>
</tr>
<tr class="even">
<td><code>H</code></td>
<td>表示硬限制，超出设定的值会报错</td>
</tr>
<tr class="odd">
<td><code>a</code></td>
<td>列出系统所有资源限制的值</td>
</tr>
<tr class="even">
<td><code>d</code></td>
<td>每个进程数据段的最大值</td>
</tr>
<tr class="odd">
<td><code>f</code></td>
<td>当前<code>shell</code>可创建的最大文件容量</td>
</tr>
<tr class="even">
<td><code>l</code></td>
<td>可以锁定的物理内存的最大值</td>
</tr>
<tr class="odd">
<td><code>m</code></td>
<td>可以使用的常驻内存的最大值</td>
</tr>
<tr class="even">
<td><code>n</code></td>
<td>每个进程可以同时打开的最大文件句柄数</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>管道的最大值</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>堆栈的最大值</td>
</tr>
<tr class="odd">
<td><code>t</code></td>
<td>每个进程可以使用CPU的最大时间</td>
</tr>
<tr class="even">
<td><code>u</code></td>
<td>每个用户运行的最大进程并发数</td>
</tr>
<tr class="odd">
<td><code>v</code></td>
<td>当前<code>shell</code>可使用的最大虚拟内存</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -n</span><br><span class="line"><span class="number">1024</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -v</span><br><span class="line">unlimited</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -p</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h6 id="source命令和.命令">5.2.9 source命令和.命令</h6>
<p>.sh后缀的文件为Linux的脚本文件，里面可以写入许多执行命令语句。然后我们可以通过使用<code>source</code>命令或者<code>.</code>在当前shell环境来执行该脚本文件中的所有语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source test.sh</span><br><span class="line">或</span><br><span class="line">. test.sh</span><br></pre></td></tr></table></figure>
<p><strong>来看一下四个执行的区别：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.sh文件：</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;step 1 sleeping&quot;</span></span><br><span class="line">sleep <span class="number">200</span></span><br><span class="line">echo <span class="string">&quot;step 2 sleeping&quot;</span></span><br><span class="line">sleep <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行：</span></span><br><span class="line">./test.sh	<span class="comment">//当前shell下正常执行，这种执行方式需要test.sh的执行权限，开启两个进程一个是test.sh,一个是sleep</span></span><br><span class="line">sh test.sh	<span class="comment">//开启新的shell执行，不用执行权限，有读取权限即可，开两个新进程：一个bash，一个sleep</span></span><br><span class="line">. test.sh	<span class="comment">//当前shell下执行，只需要读取权限即可，开启一个新进程sleep</span></span><br><span class="line">source test.sh	<span class="comment">//同第三个一样</span></span><br></pre></td></tr></table></figure></p>
<h6 id="umask命令">5.3.10 umask命令</h6>
<p><code>umask</code>命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由umask设置的掩码决定。用户每次注册进入系统时，<code>umask</code>命令都被执行， 并自动设置掩码<code>mode</code>来限制新文件的权限。用户可以通过再次执行<code>umask</code>命令来改变默认值，新的权限将会把旧的覆盖掉。<strong>注意umask命令是指定哪些权限将在新文件的默认权限中被删除</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> umask [-p] [-S] [mode]</span><br><span class="line"> -p        以八进制数字表示掩码</span><br><span class="line"> -S        以符号格式表示掩码</span><br><span class="line"></span><br><span class="line">ugo：u表示当前用户权限，g为组用户权限，o为其他用户权限</span><br><span class="line">rwx：r为读权限(<span class="number">4</span>)，w为写权限(<span class="number">2</span>)，x为执行权限(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们通过<code>umask</code>查询其默认的删除权限代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前目录的umask掩码</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ umask</span><br><span class="line"><span class="number">0002</span></span><br></pre></td></tr></table></figure>
<p>因为umask的掩码表示被删除的权限，则目录拥有的权限为<code>777-002=765</code>，则以后建立的目录的权限为<code>u=rwx,g=r-x,o=r-x</code>。如果想要改变默认，则设置<code>umask</code>,那么以后新建的目录或文件会按这个来删除权限</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ umask -p <span class="number">555</span>		<span class="comment">//以后新建的目录和文件删除所有用户的读和执行权限</span></span><br></pre></td></tr></table></figure>
<h5 id="外部命令">5.3 外部命令</h5>
<h6 id="sudo命令">5.3.1 sudo命令</h6>
<p><code>sudo</code>命令以系统管理者的身份执行指令，也就是说，经由<code>sudo</code>所执行的外部指令就好像是<code>root</code>亲自执行。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo --help</span><br><span class="line">sudo - execute a command as another user</span><br></pre></td></tr></table></figure></p>
<p><code>usage: sudo -h | -K | -k | -V</code></p>
<ul>
<li><code>V</code> 显示版本编号</li>
<li><code>h</code> 会显示版本编号及指令的使用方式说明</li>
<li><code>l</code> 显示出自己（执行<code>sudo</code>的使用者）的权限</li>
<li><code>k</code> 将会强迫使用者在下一次执行<code>sudo</code>时问密码（不论有没有超过 N 分钟）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo cd /</span><br><span class="line">sudo: cd: command <span class="keyword">not</span> found</span><br><span class="line"><span class="comment">//注意，shell是一个命令解析器，sudo cd是错误的，因为cd是shell内置的，不是系统里面的，</span></span><br><span class="line"><span class="comment">//要进入root用户，先获取root权限 然后进入/root</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo -sH</span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/home/trluper<span class="meta"># cd /root</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~# </span><br></pre></td></tr></table></figure>
<h6 id="su命令">5.3.2 su命令</h6>
<p><code>su</code>（英文全拼：<code>switch user</code>）命令用于变更为其他使用者的身份，除<code>root</code>外，需要键入该使用者的密码。使用权限：所有使用者。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~<span class="meta"># su trluper	<span class="comment">//切回用户身份</span></span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:/root$ sudo su	<span class="comment">//切回root</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> trluper: </span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~# </span><br></pre></td></tr></table></figure></p>
<h6 id="ls命令">5.3.3 ls命令</h6>
<p>是英文单词<code>list</code>的简写，其功能为列出目录的内容，是用户最常用的命令之一，它类似于<code>DOS</code>下的<code>dir</code>命令。</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-a</code></td>
<td>显示所有文件及目录<code>.</code>开头的隐藏文件也会列出)</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>将文件以相反次序显示(原定依英文字母次序)</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>将文件依建立时间之先后次序列出</td>
</tr>
<tr class="odd">
<td><code>-A</code></td>
<td>同 -a ，但不列出 <code>.</code> (目前目录) 及<code>..</code>(父目录)</td>
</tr>
<tr class="even">
<td><code>-F</code></td>
<td>在列出的文件名称后加一符号；例如可执行档则加 <code>*</code>, 目录则加 <code>/</code></td>
</tr>
<tr class="odd">
<td><code>-R</code></td>
<td>若目录下有文件，则以下之文件亦皆依序列出</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ ls -l</span><br><span class="line">total <span class="number">40</span></span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Desktop</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Documents</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Downloads</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Music</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Pictures</span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">13</span> <span class="number">23</span>:<span class="number">46</span> projects</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Public</span><br><span class="line">drwx------ <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> snap</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Templates</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Videos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="man命令">5.3.4 man命令</h6>
<p>man命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息：<code>man [选项] 命令名</code> linux中各个分页的意义：</p>
<table>
<thead>
<tr class="header">
<th>分页</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>Standard commands</code>（标准命令）</td>
</tr>
<tr class="even">
<td><code>2</code></td>
<td><code>System calls</code>系统调用，如<code>open,write</code></td>
</tr>
<tr class="odd">
<td><code>3</code></td>
<td><code>Library functions</code>库函数，如<code>printf,fopen</code></td>
</tr>
<tr class="even">
<td><code>4</code></td>
<td><code>Special devices</code>（设备文件的说明，/dev下各种设备）</td>
</tr>
<tr class="odd">
<td><code>5</code></td>
<td><code>File formats</code>（文件格式，如passwd）</td>
</tr>
<tr class="even">
<td><code>6</code></td>
<td><code>Games and toys</code>（游戏和娱乐）</td>
</tr>
<tr class="odd">
<td><code>7</code></td>
<td><code>Miscellaneous</code>（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</td>
</tr>
<tr class="even">
<td><code>8</code></td>
<td><code>Administrative Commands</code>（管理员命令，如ifconfig）</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ man <span class="number">3</span> open</span><br><span class="line">NAME</span><br><span class="line">       open, openat — open file</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ...)</span></span>;</span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h6 id="makdir命令">5.3.5 makdir命令</h6>
<p>mkdir（英文全拼：<code>make directory</code>）命令用于创建目录。需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。参数<code>-p</code>可递归创建目录。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ cd ./Documents/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ mkdir -p a/b</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ mkdir mydir&#123;<span class="number">1.</span><span class="number">.3</span>&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a  mydir1  mydir2  mydir3</span><br></pre></td></tr></table></figure></p>
<h6 id="rmdir命令">5.3.6 rmdir命令</h6>
<p>rmdir删除指定的目录，一个目录被删除之前必须是空的，'-p'递归删除目录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a  mydir1  mydir2  mydir3</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ rmdir -p a/b/c</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ rmdir mydir&#123;<span class="number">1.</span><span class="number">.3</span>&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br></pre></td></tr></table></figure></p>
<h6 id="touch命令">5.3.7 touch命令</h6>
<p><strong><code>touch</code>命令用于修改文件或者目录的时间属性，包括访问时间和修改时间，若文件不存在，系统会建立一个新的文件。</strong>即：</p>
<ul>
<li>1）如果文件不存在, 创建新文件(只能是普通文件，不能是文件夹)</li>
<li>2）如果文件存在, 更新文件时间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ touch test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ ls</span><br><span class="line">test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ touch test&#123;<span class="number">1.</span><span class="number">.3</span>&#125;.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ ls</span><br><span class="line">test  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure>
<h6 id="cp命令">5.3.8 cp命令</h6>
<p><code>cp</code>命令的功能是将给出的文件或目录复制到另一个文件或目录中，即：</p>
<ul>
<li>可以将一个或多个文件复制到另一个文件夹中</li>
<li>可以将目录即目录下的文件和子目录复制到另一个目录</li>
<li>可以将一个文件复制给另一个文件</li>
</ul>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a</code></td>
<td>此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合</td>
</tr>
<tr class="even">
<td><code>d</code></td>
<td>复制时保留链接。这里所说的链接相当于<code>Windows</code>系统中的快捷方式。</td>
</tr>
<tr class="odd">
<td><code>f</code></td>
<td>覆盖已经存在的目标文件而不给出提示</td>
</tr>
<tr class="even">
<td><code>i</code></td>
<td>与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答<code>y</code>时目标文件将被覆盖</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td>
</tr>
<tr class="even">
<td><code>r</code></td>
<td>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</td>
</tr>
<tr class="odd">
<td><code>l</code></td>
<td>不复制文件，只是生成硬链接文件，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>不复制文件，创建文件的软链接，软链接就相当于windows的快捷键（即路径名）</td>
</tr>
<tr class="odd">
<td><code>u</code></td>
<td>当存在相同的文件时，只有源文件比目标文件新时，才会将源文件复制给目标文件</td>
</tr>
</tbody>
</table>
<p><strong>1.复制一个文件到另外一个文件夹</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 源文件 目标文件（夹）:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp test1.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">test1.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 复制多个文件到另外一个文件夹</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 源文件<span class="number">1</span> 源文件<span class="number">2</span> 目标文件夹 或cp 文件* 目标文件夹</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -u *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 复制目录到另一个目录</strong></p>
<p>只需要记住复制文件夹一定要加<code>-r</code>参数，否则会出现<code>cp: omitting directory</code>错误。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">未加-r出错:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$  cp /home/trluper/Documents/mydir_1 /home/trluper/Documents/mydir_2</span><br><span class="line">cp: -r <span class="keyword">not</span> specified; omitting directory <span class="string">&#x27;/home/trluper/Documents/mydir_1&#x27;</span></span><br><span class="line"></span><br><span class="line">加-r:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -r /home/trluper/Documents/mydir_1 /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">mydir_1  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cd mydir_1/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2/mydir_1$ ls</span><br><span class="line">mysondir  test  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 复制文件到另一个文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制内容到文件</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cp test.cpp test2.cp</span><br></pre></td></tr></table></figure>
<p><strong>5. -u的重要性</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test.cpp</span><br><span class="line"></span><br><span class="line">使用-u，没有更新，因为文件没有更新变动：</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -u *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test.cpp</span><br><span class="line"></span><br><span class="line">未使用-u，直接更新:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test.cpp </span><br></pre></td></tr></table></figure>
<h6 id="rm命令">5.3.9 rm命令</h6>
<p>可通过<code>rm</code>删除文件或目录。使用<code>rm</code>命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在<code>rm</code>后使用<code>-i</code>参数以逐个确认要删除的文件。</p>
<h6 id="mv命令">5.3.10 mv命令</h6>
<p>用户可以使用<code>mv</code>命令来<strong>移动文件或目录</strong>，<strong>也可以给文件或目录重命名</strong>。<code>mv</code>与<code>cp</code>时不同的，<code>mv</code>是移动，<code>cp</code>是复制一个。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [OPTION]... [-T] SOURCE DEST</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--backup</code></td>
<td>若需覆盖文件，则覆盖前先行备份</td>
</tr>
<tr class="even">
<td><code>-b</code></td>
<td>当文件存在时，覆盖前，为其创建一个备份</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录</td>
</tr>
<tr class="even">
<td><code>-i</code></td>
<td>交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入<code>y</code>，表示将覆盖目标文件</td>
</tr>
<tr class="odd">
<td><code>-S</code></td>
<td>为备份文件指定后缀，而不使用默认的后缀</td>
</tr>
<tr class="even">
<td><code>-u</code></td>
<td>当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ mv ../mydir_1 .</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">mydir_1  test  test.cpp</span><br><span class="line"><span class="comment">//对文件重命名</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ ls</span><br><span class="line">alogrithm.h  sum.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ mv alogrithm.h Alogrithm.h</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ ls</span><br><span class="line">Alogrithm.h  sum.cpp</span><br></pre></td></tr></table></figure>
<h6 id="cat命令">5.3.11 cat命令</h6>
<p>cat：将文件内容一次性输出到终端。缺点是终端显示的内容有限，如果文件太长无法全部显示</p>
<ul>
<li><code>-n</code>:对输出的所有行编号</li>
<li><code>-b</code>:输出内容并且给非空行编号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cat -n test.cpp </span><br><span class="line">     <span class="number">1</span>	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">     <span class="number">2</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">     <span class="number">3</span>	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="number">4</span>	    cout&lt;&lt;<span class="string">&quot;这里是test1.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line">     <span class="number">5</span>	&#125;</span><br></pre></td></tr></table></figure>
<h6 id="less命令">5.3.12 less命令</h6>
<p>less命令将文件内容分页显示到终端，可以自由上下浏览</p>
<h6 id="head命令">5.3.13 head命令</h6>
<p>head命令从文件头部开始查看前n行的内容。如果没有指定行数，默认显示前10行内容。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head –n [行数] 文件名</span><br><span class="line">head -n <span class="number">30</span> /etc/passwd</span><br></pre></td></tr></table></figure></p>
<h6 id="find命令">5.3.14 find命令</h6>
<p><code>find</code>命令功能非常强大也很复杂，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure> <code>option</code>多达二十多种，这里列举两个：</p>
<ul>
<li>按文件名查询，使用<code>-name</code>,如<code>find . -name &quot;test.cpp&quot;</code></li>
<li>按文件类型查找，使用<code>-type</code>,如<code>find . -type f</code></li>
</ul>
<p>举例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将当前目录及其子目录下所有最近 20 天内更新过的文件列出</span></span><br><span class="line">find . -ctime  <span class="number">20</span></span><br><span class="line"><span class="comment">//查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：</span></span><br><span class="line">find /var/log -type f -mtime +<span class="number">7</span> -ok rm &#123;&#125; \;</span><br><span class="line"><span class="comment">//找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</span></span><br><span class="line">find . -type f -perm <span class="number">644</span> -exec ls -l &#123;&#125; \;</span><br><span class="line"><span class="comment">//查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：</span></span><br><span class="line">find / -type f -size <span class="number">0</span> -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>
<h6 id="grep命令">5.3.15 grep命令</h6>
<p>很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用<code>grep</code>命令。<code>grep</code>命令是一个强大的文本搜索工具，它能使用<strong>正则表达式</strong>搜索文本，并把匹配的行打印出来.<strong>其中<code>pattern</code>为模式，它要么是字符串，要么是正则表达式，总而言之是我们检索的指定信息</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] pattern filename</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-i</code></td>
<td>不区分大小写</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>只输出匹配行的计数</td>
</tr>
<tr class="odd">
<td><code>-l</code></td>
<td>查询多文件时只输出包含匹配字符的文件名</td>
</tr>
<tr class="even">
<td><code>-n</code></td>
<td>显示匹配行及行号</td>
</tr>
<tr class="odd">
<td><code>-s</code></td>
<td>不显示不存在或无匹配文本的错误信息</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示不包含匹配文本的所有行，即反向查找</td>
</tr>
<tr class="odd">
<td><code>-o</code></td>
<td>只显示匹配字符串的部分</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>实现多个选项的匹配，逻辑<code>or</code>关系</td>
</tr>
<tr class="odd">
<td><code>-E</code></td>
<td>使用扩展正则表达式，而不是基本正则表达式，在使用<code>-E</code>选项时，相当于使用<code>egrep</code></td>
</tr>
</tbody>
</table>
<p><strong>正则表达式：</strong></p>
<ul>
<li><code>^</code>：此时匹配正则表达以“某字符串”开头的行</li>
<li><code>$</code>：匹配正则表达式的以“某字符串”结尾的行</li>
<li><code>[xyz]</code>：匹配方括号中的任意一个字符</li>
<li><code>[^xyz]</code>：匹配除方括号中字符外的所有字符</li>
<li><code>*</code>：匹配<code>*</code>前面的字符，匹配0个或无数个</li>
<li><code>[ - ]</code>: 范围匹配，如<code>[A-C]</code>，即<code>A、B、C</code>都符合要求</li>
</ul>
<p><strong>1. 查找以指定字字符串开头的行</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in ^[a,q,r,f] hell.txt</span><br><span class="line"><span class="number">2</span>:QQWEWQE</span><br><span class="line"><span class="number">5</span>:FDSST</span><br><span class="line"><span class="number">7</span>:AFASRAY</span><br><span class="line"><span class="number">12</span>:ASDSAEE</span><br><span class="line"><span class="number">13</span>:FAFSDG</span><br><span class="line"><span class="number">17</span>:FBB</span><br><span class="line"><span class="number">24</span>:R</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 查找以指定字结符串尾的行</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in [a,q,r,f]$ hell.txt</span><br><span class="line"><span class="number">1</span>:dasdfDSFSDA</span><br><span class="line"><span class="number">4</span>:KKJHFR</span><br><span class="line"><span class="number">14</span>:DAGSA</span><br><span class="line"><span class="number">24</span>:R</span><br><span class="line"><span class="number">26</span>:CZXCGA</span><br></pre></td></tr></table></figure>
<p><strong>3.在文本中搜素只有一个字符的行，且为字母或数字</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in ^[[:alnum:]]$ hell.txt</span><br><span class="line"><span class="number">20</span>:Z</span><br><span class="line"><span class="number">21</span>:D</span><br><span class="line"><span class="number">22</span>:E</span><br><span class="line"><span class="number">23</span>:W</span><br><span class="line"><span class="number">24</span>:R</span><br><span class="line"><span class="number">25</span>:T</span><br></pre></td></tr></table></figure>
<p><strong>4.匹配<code>*</code>前面的字符，匹配0个或无数个</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in <span class="string">&quot;FDSS&quot;</span>* hell.txt </span><br><span class="line"><span class="number">1</span>:dasdfDSFSDA</span><br><span class="line"><span class="number">5</span>:FDSST</span><br></pre></td></tr></table></figure>
<h6 id="命令">5.3.16 |命令</h6>
<p>管道<code>|</code>一个命令的输出可以通过管道做为另一个命令的输入。即它只能处理经由前面一个指令传出的正确输出信息，对错误信息信息没有直接处理能力。然后，传递给下一个命令，作为标准的输入. 最常用的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|gerp <span class="string">&quot;进程名&quot;</span></span><br><span class="line">ps -aux|grep <span class="string">&quot;进程名&quot;</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -ef|grep bash</span><br><span class="line">trluper     <span class="number">2755</span>    <span class="number">2754</span>  <span class="number">0</span> <span class="number">16</span>:<span class="number">03</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span> -bash</span><br><span class="line">trluper     <span class="number">4549</span>    <span class="number">4548</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">29</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> -bash</span><br><span class="line">trluper     <span class="number">4716</span>    <span class="number">4549</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">49</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> bash</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -aux|grep bash</span><br><span class="line">trluper     <span class="number">2755</span>  <span class="number">0.0</span>  <span class="number">0.2</span>  <span class="number">19972</span>  <span class="number">5956</span> pts/<span class="number">1</span>    Ss+  <span class="number">16</span>:<span class="number">03</span>   <span class="number">0</span>:<span class="number">02</span> -bash</span><br><span class="line">trluper     <span class="number">4549</span>  <span class="number">0.0</span>  <span class="number">0.2</span>  <span class="number">19864</span>  <span class="number">5956</span> pts/<span class="number">0</span>    Ss   <span class="number">20</span>:<span class="number">29</span>   <span class="number">0</span>:<span class="number">00</span> -bash</span><br><span class="line">trluper     <span class="number">4718</span>  <span class="number">0.0</span>  <span class="number">0.1</span>  <span class="number">17864</span>  <span class="number">2584</span> pts/<span class="number">0</span>    S+   <span class="number">20</span>:<span class="number">49</span>   <span class="number">0</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> bas</span><br></pre></td></tr></table></figure></p>
<h6 id="ps命令">5.3.17 ps命令</h6>
<p><code>ps</code>（英文全拼：<code>process status</code>）命令用于显示当前进程的状态，类似于<code>windows</code>的任务管理器 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [options]</span><br></pre></td></tr></table></figure> <code>ps</code>的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a</code></td>
<td>显示现行终端机下的所有程序，包括其他用户的程序</td>
</tr>
<tr class="even">
<td><code>-a</code></td>
<td>显示所有终端机下执行的程序，除了阶段作业领导者之外</td>
</tr>
<tr class="odd">
<td><code>-A</code></td>
<td>显示所有程序</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>此选项的效果和指定”A”选项相同</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>显示UID,PPIP,C与STIME栏位</td>
</tr>
<tr class="even">
<td><code>-u</code></td>
<td>此选项的效果和指定”-U”选项相同</td>
</tr>
<tr class="odd">
<td><code>u</code></td>
<td>以用户为主的格式来显示程序状况</td>
</tr>
<tr class="even">
<td><code>-U</code></td>
<td>列出属于该用户的程序的状况，也可使用用户名称来指定</td>
</tr>
<tr class="odd">
<td><code>U</code></td>
<td>列出属于该用户的程序的状况</td>
</tr>
<tr class="even">
<td><code>x</code></td>
<td>显示所有程序，不以终端机来区分</td>
</tr>
</tbody>
</table>
<p><strong>1. <code>-aux</code>输出格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           <span class="number">1</span>  <span class="number">0.0</span>  <span class="number">0.4</span> <span class="number">166516</span> <span class="number">11808</span> ?        Ss   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">06</span> /sbin/init <span class="keyword">auto</span> noprom</span><br><span class="line">root           <span class="number">2</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [kthreadd]</span><br><span class="line">root           <span class="number">3</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [rcu_gp]</span><br><span class="line">root           <span class="number">4</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [rcu_par_gp]</span><br><span class="line">root           <span class="number">5</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [netns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>USER</code>: 行程拥有者</li>
<li><code>PID: pid</code></li>
<li><code>%CPU</code>: 占用的 <code>CPU</code> 使用率</li>
<li><code>%MEM</code>: 占用的记忆体使用率</li>
<li><code>VSZ</code>: 占用的虚拟记忆体大小</li>
<li><code>RSS</code>: 占用的记忆体大小</li>
<li><code>TTY</code>: 终端的次要装置号码 (minor device number of tty)</li>
<li><code>STAT:</code> 该行程的状态:</li>
<li><code>D:</code> 无法中断的休眠状态 (通常 IO 的进程)</li>
<li><code>R:</code> 正在执行中</li>
<li><code>S:</code> 睡眠状态，可被唤醒</li>
<li><code>T:</code> 暂停执行</li>
<li><code>Z:</code> 僵尸进程</li>
<li><code>W:</code> 没有足够的记忆体分页可分配</li>
<li><code>s：</code>进程是会话首进程</li>
<li><code>&lt;:</code> 高优先序的行程</li>
<li><code>N:</code> 低优先序的行程</li>
<li><code>X：</code>死掉的进程</li>
<li><code>START:</code> 行程开始时间</li>
<li><code>TIME:</code> 执行的时间</li>
<li><code>COMMAND：</code>所执行的指令</li>
</ul>
<p><strong>2. <code>-ef</code>输出格式</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -ef</span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           <span class="number">1</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">06</span> /sbin/init <span class="keyword">auto</span> noprompt splash</span><br><span class="line">root           <span class="number">2</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [kthreadd]</span><br><span class="line">root           <span class="number">3</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [rcu_gp]</span><br><span class="line">root           <span class="number">4</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [rcu_par_gp]</span><br><span class="line">root           <span class="number">5</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [netns]</span><br></pre></td></tr></table></figure></p>
<h6 id="tar命令">5.3.18 tar命令</h6>
<p><code>tar</code>是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解压以恢复数据。<code>tar</code>这个命令并没有压缩的功能，它只是一个打包的命令，<strong>但是在<code>tar</code>命令中增加一个选项<code>-z</code>可以调用<code>gzip</code>实现了一个压缩的功能，实行一个先打包后压缩的过程</strong>。当然你可以调用其他的压缩命令来压缩。<code>tar</code>要指定扩展名 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只打包</span></span><br><span class="line">tar -cvf test.tar ./</span><br><span class="line"><span class="comment">//压缩当前文件内的所有内容打成和压缩成test.tar.gz包</span></span><br><span class="line">tar -zcvf test.tar.gz ./</span><br><span class="line"><span class="comment">//解压缩和解包</span></span><br><span class="line">tar -zxvf test.tar.gz</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>创建一个新归档</td>
</tr>
<tr class="even">
<td><code>-x</code></td>
<td>从归档中解出文件</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>使用归档文件，一定为最后一个参数</td>
</tr>
<tr class="even">
<td><code>-z</code></td>
<td>通过 gzip 过滤归档</td>
</tr>
<tr class="odd">
<td><code>-t</code></td>
<td>查看内容</td>
</tr>
<tr class="even">
<td><code>-r</code></td>
<td>向压缩归档文件末尾追加文件</td>
</tr>
<tr class="odd">
<td><code>-u</code></td>
<td>更新原压缩包中的文件</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示所有过程</td>
</tr>
</tbody>
</table>
<p><strong>-f 是必须的，切记，这个参数是最后一个参数，后面只能接档案名。</strong></p>
<p><strong><em>linux中的压缩后缀：</em></strong></p>
<ul>
<li><code>*.gz</code>：由<code>gzip</code>压缩，参数为<code>-z</code></li>
<li><code>*.bz2</code>:由<code>bzip2</code>压缩，参数为<code>-j</code></li>
<li><code>*.Z</code>:由<code>compress</code>压缩，参数为<code>-Z</code></li>
<li><code>*.rar:</code>由<code>rar</code>压缩，linux需下载<code>rar</code></li>
<li><code>*.zip</code>：由<code>zip</code>压缩，linux需下载<code>zip</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -zcvf mytar.tar.gz ./</span><br><span class="line">./</span><br><span class="line">./mymdir_2</span><br><span class="line">./mytar.tar.gz</span><br><span class="line">./mydir_2/</span><br><span class="line">./mydir_2/test.cpp</span><br><span class="line">./mydir_2/hell.txt</span><br><span class="line">./mydir_2/mydir_1/</span><br><span class="line">./mydir_2/mydir_1/test.cpp</span><br><span class="line">./mydir_2/mydir_1/test1.cpp</span><br><span class="line">./mydir_2/mydir_1/sondir/</span><br><span class="line">./mydir_2/mydir_1/mysondir/</span><br><span class="line">./mydir_2/mydir_1/test3.cpp</span><br><span class="line">./mydir_2/mydir_1/test</span><br><span class="line">./mydir_2/mydir_1/test2.cpp</span><br><span class="line">./mydir_2/test</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar.tar.gz</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -tvf mytar.tar.gz </span><br><span class="line">drwxr-xr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">31</span> ./</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">12</span> ./mymdir_2</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">31</span> ./mytar.tar.gz</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">39</span> ./mydir_2/</span><br><span class="line">-rw-rw-r-- trluper/trluper  <span class="number">93</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/test.cpp</span><br><span class="line">-rw-rw-r-- trluper/trluper <span class="number">161</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">39</span> ./mydir_2/hell.txt</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">03</span> ./mydir_2/mydir_1/</span><br><span class="line">hrw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/mydir_1/test.cpp link to ./mydir_2/test.cpp</span><br><span class="line">-rw-rw-r-- trluper/trluper  <span class="number">93</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/mydir_1/test1.cpp</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">03</span> ./mydir_2/mydir_1/sondir/</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">49</span> ./mydir_2/mydir_1/mysondir/</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">04</span> ./mydir_2/mydir_1/test3.cpp</span><br><span class="line">-rwxrwxr-x trluper/trluper <span class="number">23528</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">01</span> ./mydir_2/mydir_1/test</span><br><span class="line">-rw-rw-r-- trluper/trluper     <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">04</span> ./mydir_2/mydir_1/test2.cpp</span><br><span class="line">hrwxrwxr-x trluper/trluper     <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">01</span> ./mydir_2/test link to ./mydir_2/mydir_1/test</span><br></pre></td></tr></table></figure>
<h6 id="gzip命令">5.3.19 gzip命令</h6>
<p>其实上面的<code>tar</code>加<code>-z</code>参数就已经完成了<code>gzip</code>命令的工作了。<code>tar</code>与<code>gzip</code>命令结合使用实现文件打包、压缩。<code>gzip</code>要指定扩展名</p>
<ul>
<li><code>-d</code>:解压</li>
<li><code>-r</code>:压缩所有子目录</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -cvf mytar1.tar mydir_2</span><br><span class="line">mydir_2/</span><br><span class="line">mydir_2/test.cpp</span><br><span class="line">mydir_2/hell.txt</span><br><span class="line">mydir_2/mydir_1/</span><br><span class="line">mydir_2/mydir_1/test.cpp</span><br><span class="line">mydir_2/mydir_1/test1.cpp</span><br><span class="line">mydir_2/mydir_1/sondir/</span><br><span class="line">mydir_2/mydir_1/mysondir/</span><br><span class="line">mydir_2/mydir_1/test3.cpp</span><br><span class="line">mydir_2/mydir_1/test</span><br><span class="line">mydir_2/mydir_1/test2.cpp</span><br><span class="line">mydir_2/test</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar  mytar.tar.gz</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ gzip -r mytar1.tar</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar.gz  mytar.tar.gz</span><br></pre></td></tr></table></figure>
<h6 id="zip和unzip命令">5.3.20 zip和unzip命令</h6>
<p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">压缩文件：zip -r 目标文件(没有扩展名) 源文件</span><br><span class="line">解压文件：unzip -d 解压后目录文件 压缩文件</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ zip -r myzip mydir_2</span><br><span class="line">  adding: mydir_2/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/test.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/hell.<span class="built_in">txt</span> (deflated <span class="number">20</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test1.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/sondir/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/mysondir/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test3.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/<span class="built_in">test</span> (deflated <span class="number">79</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test2.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/<span class="built_in">test</span> (deflated <span class="number">79</span>%)</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar.gz  mytar.tar.gz  myzip.zip</span><br></pre></td></tr></table></figure></p>
<h6 id="chmod命令">5.3.21 chmod命令</h6>
<p><code>chmod</code>（英文全拼：change mode）命令是控制用户对文件的权限的命令。Linux/Unix 的文件调用权限分为三级 : 文件所有者<code>Owner</code>、用户组<code>Group</code>、其它用户<code>ther Users</code>。<strong>在内建命令中我们通过设置<code>umask</code>命令来指定新建的文件的权限，但是对于已经存在的文件的权限我们要怎么去修改呢，只能使用<code>chmod</code>命令来修改</strong> <code>chmod</code> 修改文件权限有两种使用格式<strong>字母法与数字法</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字母</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ chmod o+w mydir_2/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxrwx <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ chmod <span class="number">775</span> mydir_2/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="命令-1">5.3.22 &gt;命令</h6>
<p><code>&gt;</code>命令是重定向命令。我们在bash上运行命令，其默认输出为当前的bash终端。当我们想要看查询的东西时（如ls命令），把原来输出到终端的，可以重定向到一个文件。命令后接 <code>&gt;文件名</code>，<code>&gt;</code>会覆盖，<code>&gt;&gt;</code>不覆盖原来内容 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l &gt;text.txt</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  text.txt</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ cat text.txt </span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">17</span> <span class="number">11</span>:<span class="number">04</span> text.txt</span><br></pre></td></tr></table></figure></p>
<h6 id="ln命令">5.3.23 ln命令</h6>
<p><code>ln</code>命令是linux系统中一个非常重要命令，英文全称是“link”，即链接的意思，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 一种是<code>hard link</code>，又称为硬链接；另一种是<code>symbolic link</code>，又称为符号链接。<strong>通俗一点理解，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间。符号链接可以理解为类似windows一样的快捷方式</strong>。 符号链接 ：</p>
<ul>
<li>1.符号链接以路径的形式存在，类似于Windows操作系统中的快捷方式。</li>
<li>2.符号链接可以跨文件系统 ，硬链接不可以。</li>
<li>3.符号链接可以对一个不存在的文件名进行链接，硬链接不可以。</li>
<li>4.符号链接可以对目录进行链接，硬链接不可以。</li>
</ul>
<p><strong>硬链接：</strong></p>
<ul>
<li>1.硬链接以文件副本的形式存在，但不占用实际空间。</li>
<li>2.硬链接不允许给目录创建硬链接。</li>
<li>3.硬链接只有在同一个文件系统中才能创建。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [参数] [源文件或目录] [目标文件或目录]</span><br></pre></td></tr></table></figure>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>为每个已存在的目标文件创建备份文件</td>
</tr>
<tr class="even">
<td><code>-d</code></td>
<td>此选项允许“root”用户建立目录的硬链接</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>强制创建链接，即使目标文件已经存在</td>
</tr>
<tr class="even">
<td><code>-n</code></td>
<td>把指向目录的符号链接视为一个普通文件</td>
</tr>
<tr class="odd">
<td><code>-i</code></td>
<td>交互模式，若目标文件已经存在，则提示用户确认进行覆盖</td>
</tr>
<tr class="even">
<td><code>-s</code></td>
<td>对源文件建立符号链接，而非硬链接</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>详细信息模式，输出指令的详细执行过程</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//软连接</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ln -s /home/trluper/Documents/mydir_2 ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls</span><br><span class="line">ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cd ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file/ln_file1$ ls</span><br><span class="line">hell.txt  mydir_1  test  test.cpp</span><br><span class="line"><span class="comment">//软连接就是路径</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> trluper trluper <span class="number">31</span>  <span class="number">7</span>月 <span class="number">17</span> <span class="number">11</span>:<span class="number">15</span> ln_file1 -&gt; /home/trluper/Documents/mydir_2</span><br><span class="line"><span class="comment">//硬链接</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ln /home/trluper/Documents/mydir_2/test.cpp lntest</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls</span><br><span class="line">ln_file1  lntest</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cat lntest </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;这里时test1.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="file命令">5.3.24 file命令</h6>
<p>file命令用于辨识文件类型。通过<code>file</code>指令，我们得以辨识该文件的类型。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>列出辨识结果时，不显示文件名称。</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>详细显示指令执行过程，便于排错或分析程序执行的情形。</td>
</tr>
<tr class="odd">
<td><code>-f&lt;名称文件&gt;</code></td>
<td>指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</td>
</tr>
<tr class="even">
<td><code>-L</code></td>
<td>直接显示符号连接所指向的文件的类别。</td>
</tr>
<tr class="odd">
<td><code>-m&lt;魔法数字文件&gt;</code></td>
<td>　指定魔法数字文件。</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示版本信息。</td>
</tr>
<tr class="odd">
<td><code>-z</code></td>
<td>尝试去解读压缩文件的内容。</td>
</tr>
<tr class="even">
<td><code>[文件或目录...]</code></td>
<td>要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ file lntest1 </span><br><span class="line">lntest1: C++ source, Unicode text, UTF<span class="number">-8</span> text</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ file ln_file1</span><br><span class="line">ln_file1: symbolic link to /home/trluper/Documents/mydir_2</span><br></pre></td></tr></table></figure>
<h6 id="chgrp命令">5.3.25 chgrp命令</h6>
<p><strong><code>chgrp</code>命令用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组</strong>。其中，组名可以是用户组的<code>id</code>，也可以是用户组的组名。文件名可以是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户(root)，则不能改变该文件的组。<strong>同时必须在<code>/etc/group</code>有该组名。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项] 组名 文件...</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>效果类似<code>-v</code>参数，但仅会显示更改的部分</td>
</tr>
<tr class="even">
<td><code>-f</code></td>
<td>不显示错误信息</td>
</tr>
<tr class="odd">
<td><code>-h</code></td>
<td>只对符号连接的文件作修改，而不是该其他任何相关文件</td>
</tr>
<tr class="even">
<td><code>-R</code></td>
<td>递归处理，将指令目录下的所有文件及子目录一并处理</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>显示指令执行过程；</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cat /etc/group</span><br><span class="line">root:x:<span class="number">0</span>:</span><br><span class="line">daemon:x:<span class="number">1</span>:</span><br><span class="line">bin:x:<span class="number">2</span>:</span><br><span class="line">sys:x:<span class="number">3</span>:</span><br><span class="line">adm:x:<span class="number">4</span>:syslog,trluper</span><br><span class="line">tty:x:<span class="number">5</span>:</span><br><span class="line">disk:x:<span class="number">6</span>:</span><br><span class="line">lp:x:<span class="number">7</span>:</span><br><span class="line">mail:x:<span class="number">8</span>:</span><br><span class="line">news:x:<span class="number">9</span>:</span><br><span class="line">uucp:x:<span class="number">10</span>:</span><br><span class="line">man:x:<span class="number">12</span>:</span><br><span class="line">...</span><br><span class="line"><span class="comment">//将rumenz目录由root组改为www群组</span></span><br><span class="line">chgrp -R www rumenz</span><br></pre></td></tr></table></figure>
<h6 id="top命令">5.3.26 top命令</h6>
<p><code>top</code>命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [参数]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>批处理</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>显示完整的治命令</td>
</tr>
<tr class="odd">
<td><code>-I</code></td>
<td>忽略失效过程</td>
</tr>
<tr class="even">
<td><code>-s</code></td>
<td>保密模式</td>
</tr>
<tr class="odd">
<td><code>-S</code></td>
<td>累积模式</td>
</tr>
<tr class="even">
<td><code>-i&lt;时间&gt;</code></td>
<td>设置间隔时间</td>
</tr>
<tr class="odd">
<td><code>-u&lt;用户名&gt;</code></td>
<td>指定用户名</td>
</tr>
<tr class="even">
<td><code>-p&lt;进程号&gt;</code></td>
<td>指定进程</td>
</tr>
<tr class="odd">
<td><code>-n&lt;次数&gt;</code></td>
<td>循环显示的次数</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ top -p2567</span><br><span class="line">top - <span class="number">12</span>:<span class="number">55</span>:<span class="number">36</span> up  <span class="number">2</span>:<span class="number">23</span>,  <span class="number">2</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line">Tasks:   <span class="number">0</span> total,   <span class="number">0</span> running,   <span class="number">0</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%<span class="built_in">Cpu</span>(s):  <span class="number">0.0</span> us,  <span class="number">0.0</span> sy,  <span class="number">0.0</span> ni, <span class="number">99.9</span> id,  <span class="number">0.1</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">MiB Mem :   <span class="number">2408.3</span> total,    <span class="number">493.1</span> free,    <span class="number">655.0</span> used,   <span class="number">1260.2</span> buff/cache</span><br><span class="line">MiB Swap:   <span class="number">2048.0</span> total,   <span class="number">2048.0</span> free,      <span class="number">0.0</span> used.   <span class="number">1570.8</span> avail Mem </span><br></pre></td></tr></table></figure>
<h6 id="ar命令">5.3.27 ar命令</h6>
<p><code>ar</code>命令用于<strong>建立或修改备存文件，或是从备存文件中抽取文件。可集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar [参数]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-d</code></td>
<td>删除备存文件中的成员文件</td>
</tr>
<tr class="even">
<td><code>-m</code></td>
<td>变更成员文件在备存文件中的次序</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td>显示备存文件中的成员文件内容</td>
</tr>
<tr class="even">
<td><code>-q</code></td>
<td>将文件附加在备存文件末端</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>将文件插入备存文件中</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>显示备存文件中所包含的文件</td>
</tr>
<tr class="odd">
<td><code>-x</code></td>
<td>自备存文件中取出成员文件</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>创建</td>
</tr>
<tr class="odd">
<td><code>-s</code></td>
<td>建立索引</td>
</tr>
</tbody>
</table>
<h6 id="nm命令">5.3.28 nm命令</h6>
<p><code>nm</code>是<code>names</code>的缩写，<strong><code>nm</code>命令主要是用来列出某些文件中的符号（说白了就是一些函数和全局变量等）</strong>。 一般来说，搞linux开发的人，才会用到<code>nm</code>命令，非开发的人，应该用不到. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm [参数]</span><br></pre></td></tr></table></figure></p>
<h4 id="vim编辑器">6. vim编辑器</h4>
<p><code>vi (Visual interface)</code>编辑器是<code>Linux</code>系统中最常用的文本编辑器，<code>vi</code>工作在字符模式下，不需要图形界面，非常适合远程及嵌入式工作，是效率很高的文本编辑器。<code>vim</code>是<code>vi</code>的升级版，它不仅兼容<code>vi</code>的所有指令，而且还有一些新的特性，例如<code>vim</code>可以撤消无限次、支持关键词自动完成、可以用不同的颜色来高亮你的代码。<code>vim</code>普遍被推崇为类<code>vi</code>编辑器中最好的一个。</p>
<h5 id="vim的三种模式">6.1 vim的三种模式</h5>
<p>vi有三种基本工作模式: <strong>命令模式、文本输入模式(编辑模式)、末行模式</strong></p>
<ul>
<li><p><strong>命令模式：</strong> <strong>任何时候,不管用户处于何种模式,只要按一下<code>ESC</code>键,即可使<code>vi</code>进入命令模式</strong>。我们在<code>shell</code>环境(提示符为<code>$</code>)下输入启动<code>vim</code>命令，进入编辑器时，也是处于该模式下。在命令模式下，用户可以输入各种合法的<code>vi</code>命令，用于管理自己的文档。<strong>此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的<code>vi</code>命令，则<code>vi</code>在接受用户命令之后完成相应的动作</strong>。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是<code>vi</code>的合法命令，<code>vi</code>会响铃报警。</p></li>
<li><p>文本输入模式： 在命令模式下输入插入命令<code>i（I）、附加命令a（A） 、打开命令o（O）、替换命s（S）</code>都可以进入文本输入模式，此时vi窗口的最后一行会显示“插入”,可进行文本编辑.</p></li>
<li><p>末行模式： 末行模式下，用户可以对文件进行一些附加处理。尽管命令模式下的命令可以完成很多功能，但要执行一些如字符串查找、替换、显示行号等操作还是必须要进入末行模式的。<strong>在命令模式下，输入冒号<code>:</code>即可进入末行模式。此时vi窗口的状态行会显示出冒号，等待用户输入命令。用户输入完成后，按回车执行，之后<code>vi</code>编辑器又自动返回到命令模式下</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vi-vim.gif"></p></li>
</ul>
<h5 id="命令模式下的命令操作">6.2 命令模式下的命令操作</h5>
<h6 id="切换到编辑模式">6.2.1 切换到编辑模式</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vimbianji.png"></p>
<h6 id="光标移动">6.2.2 光标移动</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mousemove.png"></p>
<h6 id="删除">6.2.3 删除</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/delete.png"> <strong>常用：<code>D</code>、<code>dG</code>、<code>nx</code>(n为数字)、<code>ndd</code></strong></p>
<h6 id="查找">6.2.4 查找</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/find.png"></p>
<h6 id="可视模式">6.2.5 可视模式</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/copydelete.png"></p>
<h6 id="粘贴和复制">6.2.6 粘贴和复制</h6>
<ul>
<li><code>p</code>:粘贴在光标后面</li>
<li><code>P</code>:粘贴在光标前面</li>
<li><code>y</code>:拷贝行</li>
<li><code>Y</code>:拷贝行</li>
</ul>
<h5 id="末行模式下的命令操作">6.3 末行模式下的命令操作</h5>
<h6 id="保存退出">6.3.1 保存退出</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/saveexit.png"></p>
<h6 id="替换">6.3.2 替换</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/tihuan.png"> 可以从上图总结：<code>s(</code>代表本行，<code>g</code>为所有(global)都替换，<code>%</code>指本文件所有行，<code>c</code>每次替换都要求确认</p>
<h6 id="分屏">6.3.3 分屏</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fenping.png"></p>
<h6 id="其他用法扩展">6.3.4 其他用法扩展</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/others.png"></p>
<h5 id="vim的配置文件所在">6.4 vim的配置文件所在</h5>
<p>局部配置文件（推荐）：<code>~/.vimrc</code> 全局配置文件:<code>/etc/vim/vimrc</code></p>
<h4 id="gcc和gcc编译器">7. GCC和gcc++编译器</h4>
<h5 id="gcc和-gcc是两个不同的东西">7.1 gcc和 GCC是两个不同的东西</h5>
<ul>
<li><code>GCC:GNU Compiler Collection</code>(GUN 编译器集合)，它可以编译<code>C、C++、JAV、Fortran、Pascal、Object-C、Ada</code>等语言。</li>
<li>因此<code>gcc</code>是<code>GCC</code>中的<code>GUN C Compiler</code>（C 编译器）；<code>g++</code>是<code>GCC</code>中的<code>GUN C++ Compiler</code>（<code>C++</code>编译器）。二者都可以编译<code>c</code>或<code>cpp</code>文件。只不过用<code>gcc</code>编译<code>c++</code>需要手动添加链接库</li>
<li><strong>在编译阶段，<code>g++</code>会调用<code>gcc</code>，对于<code>c++</code>代码，两者是等价的，但是因为<code>gcc</code>命令不能自动和<code>C++</code>程序使用的库联接，所以通常使用用<code>g++</code>来编译以求自动完成链接。所以对于<code>C</code>语言程序的编译，我们应该使用<code>gcc</code> 指令，而编译<code>C++</code>程序则推荐使用<code>g++</code>指令</strong></li>
</ul>
<h5 id="gccg的四个步骤">7.2 gcc/g++的四个步骤</h5>
<p><code>gcc、g++</code>编译器从拿到一个c源文件到生成一个可执行程序，中间一共经历了<strong>四个步骤：</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/compile.png"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">第一步: 进行预处理</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -E <span class="number">1</span>hello.c -o <span class="number">1</span>hello.i</span><br><span class="line">第二步: 生成汇编文件</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -S <span class="number">1</span>hello.i -o <span class="number">1</span>hello.s</span><br><span class="line">第三步: 生成目标代码</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -c <span class="number">1</span>hello.s -o <span class="number">1</span>hello.o</span><br><span class="line">第四步: 生成可以执行文件</span><br><span class="line"><span class="comment">//这条指令是完成链接这个过程的，它通过链接器ld将运行程序的目标文件和库文件链接在一起，</span></span><br><span class="line"><span class="comment">//生成最后的可执行文件</span></span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc <span class="number">1</span>hello.o -o <span class="number">1</span>hello</span><br><span class="line">第五步: 执行 </span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc​$ ./<span class="number">1</span>hello</span><br><span class="line">hello itcast</span><br><span class="line"></span><br><span class="line">也可直接将源文件生成一个可以执行文件</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc <span class="number">1</span>hello.c -o <span class="number">1</span>hello</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc​$ ./<span class="number">1</span>hello</span><br><span class="line">hello itcast</span><br></pre></td></tr></table></figure></p>
<p><strong>常用选项</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/gcc.png"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello  -I /home/hello/include -L /home/hello/lib -lworld</span><br><span class="line">上面这句表示在编译hello.c时：</span><br><span class="line"></span><br><span class="line">-I /home/hello/include表示将/home/hello/include目录作为第一个寻找头文件的目录，</span><br><span class="line">寻找的顺序是：/home/hello/include--&gt;/usr/include--&gt;/usr/local/include </span><br><span class="line"></span><br><span class="line">-L /home/hello/lib表示将/home/hello/lib目录作为第一个寻找库文件的目录，</span><br><span class="line">寻找的顺序是：/home/hello/lib--&gt;/lib--&gt;/usr/lib--&gt;/usr/local/lib</span><br><span class="line"></span><br><span class="line">-lworld表示在上面的lib的路径中寻找libworld.so动态库文件或libworld.a静态库文件</span><br></pre></td></tr></table></figure></p>
<p><strong><em>附加</em></strong>：</p>
<ul>
<li><p><code>-I</code>针对头文件，未指明路径时，使用<code>#include&lt;&gt;</code>,<code>gcc/g++</code>默认目录<code>/usr/include</code>，如果使用<code>#include&lt;my.h&gt;</code>则找不到<code>my.h</code>文件，因此要通过<code>-I dir</code>参数来指定包含的头文件<code>my.h</code>的位置： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gcc hell.c -o hell -I /<span class="built_in">root</span>              (假设文件my.h存放在/root下)</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>-L</code>与<code>-I</code> 功能类似，只不过<code>-L</code>时对库文件使用，能够在指定库文件搜索路径。如果一个程序用到了目录<code>/root/lib</code>下的一个动态库<code>libsunq.so</code>，因为<code>-L dir</code>指定的是路径而没有指定文件，则需要用到 <code>-llibname</code>参数，它可以指定<code>gcc</code>去寻找<code>libsunq.so</code>或者<code>libsunq.a</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gcc hello.c -o hell -L /root/lib -lsunq</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="静态链接和动态链接">7.3 静态链接和动态链接</h5>
<h6 id="静态链接">7.3.1静态链接</h6>
<p><strong>静态链接是指由链接器在链接时将库的内容直接加入到可执行程序中。</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>对运行环境的依赖性较小，具有较好的兼容性</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间</li>
<li>库函数有了更新，必须重新编译应用程序</li>
</ul></li>
</ul>
<h6 id="动态链接">7.3.2 动态链接</h6>
<p><strong>动态链接是指连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>在需要的时候才会调入对应的资源函数</li>
<li>简化程序的升级；有着较小的程序体积</li>
<li>实现进程之间的资源共享（避免重复拷贝）</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>依赖动态库，不能独立运行</li>
<li>动态库依赖版本问题严重</li>
</ul></li>
</ul>
<p>注：前面我们编写的应用程序大量用到了标准库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入<code>-static</code>参数。</p>
<h6 id="静态库的制作">7.3.3 静态库的制作</h6>
<p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。 按照习惯,一般以<code>.a</code>做为文件后缀名。静态库的命名一般分为三个部分：</p>
<ul>
<li>前缀：<code>lib</code></li>
<li>库名称：自己定义即可</li>
<li>后缀：<code>.a</code></li>
</ul>
<p><strong>所以最终的静态库的名字应该为：<code>libxxx.a</code></strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/staticlinked.png" width="600"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：将c源文件生成对应的.o文件</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib$ gcc -c add.c -o add.o</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c sub.c -o sub.o </span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c mul.c -o mul.o </span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c div.c -o div.o</span><br><span class="line">步骤<span class="number">2</span>：使用打包工具ar将准备好的.o文件打包为.a文件 libtest.a</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib$ ar -rcs libAlogrithm.a add.o sub.o mul.o div.o</span><br></pre></td></tr></table></figure> <strong>在使用ar工具是时候需要添加参数：<code>-rcs</code></strong></p>
<ul>
<li><code>r</code>更新</li>
<li><code>c</code>创建</li>
<li><code>s</code>建立索引</li>
</ul>
<h6 id="静态库的使用">7.3.4 静态库的使用</h6>
<p>静态库制作完成之后，<strong>需要将<code>.a</code>文件和头文件一起发布给用户</strong>。假设测试文件为<code>main.c</code>，静态库文件为<code>libAlogrithm.a</code>，头文件为<code>Alogrithm.h</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ cat main.cpp </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Alogrithm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>,b=<span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ g++ -<span class="type">static</span> main.cpp -I ../staticLib/ -L ../staticLib/ -lAlogrithm -o test</span><br></pre></td></tr></table></figure></p>
<h6 id="动图库的制作">7.3.5 动图库的制作</h6>
<p>共享库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题和更新问题。 按照习惯,一般以“.so”做为文件后缀名。共享库的命名一般分为三个部分：</p>
<ul>
<li>前缀：<code>lib</code></li>
<li>库名称：自己定义即可</li>
<li>后缀：<code>.so</code></li>
</ul>
<p><strong>所以最终的动态库的名字应该为：<code>libxxx.so</code></strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/dynamiclib.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">步骤一：生成目标文件，此时要加编译选项：-fPIC（fpic）</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -fPIC -c add.c</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ gcc -fPIC -c sub.c </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -fPIC -c mul.c </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ gcc -fPIC -c div.c</span><br><span class="line">参数：-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</span><br><span class="line">步骤二：生成共享库，此时要加链接器选项: -shared（指定生成动态链接库）</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -shared add.o sub.o mul.o div.o -o libtest.so</span><br><span class="line"></span><br><span class="line">步骤三: 通过nm命令查看对应的函数</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ nm libtest.so | grep add </span><br><span class="line"><span class="number">00000000000006b</span>0 T add </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ nm libtest.so | grep sub </span><br><span class="line"><span class="number">00000000000006</span>c4 T sub</span><br></pre></td></tr></table></figure>
<h6 id="使用动态库">7.3.6 使用动态库</h6>
<p>静态库制作完后，需要在测试文件所在的目录创建<code>libxxx.so</code>的链接接，否则就会出现下面这个错误： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libtiger.so: cannot open shared object file: No such file <span class="keyword">or</span> direct</span><br></pre></td></tr></table></figure> 可以通过<code>ldd</code>命令查看哪些动态链接库没有找到： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ ldd test1</span><br><span class="line">	linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007ffc0d5fe000</span>)</span><br><span class="line">	libAlogrithm.so =&gt; <span class="keyword">not</span> found</span><br><span class="line">	libstdc++.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span> (<span class="number">0x00007fbd2317f000</span>)</span><br><span class="line">	libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007fbd22f57000</span>)</span><br><span class="line">	libm.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libm.so<span class="number">.6</span> (<span class="number">0x00007fbd22e70000</span>)</span><br><span class="line">	/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fbd233c1000</span>)</span><br><span class="line">	libgcc_s.so<span class="number">.1</span> =&gt; /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007fbd22e50000</span>)</span><br></pre></td></tr></table></figure> <strong>这是因为程序运行时没有找到动态链接库造成的。程序编译时链接动态库和运行时使用动态链接库的概念是不同的，在运行时，程序链接的动态链接库需要在系统目录下才行</strong>。方法：</p>
<ul>
<li><strong>方法一是可在系统目录创建软链接，链接文件。</strong>这是因为用·<code>-L</code>指定动态库文件路径只能保证编译通过，是否能执行还是得看<code>/lib/</code>或<code>/usr/lib</code>下面有没有该库文件（只要没有删除，永久有效）</li>
<li>方法二当然你要可以修改<code>LD_LIBRARY_PATH</code>指定的动态库搜索路径(当前shell有效)</li>
<li>方法三是配置文件<code>/etc/ld.so.conf</code>中指定的动态库搜索路径(永久有效)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deng@itcast:~/test/<span class="number">6</span>share_test$ sudo ln -s /home/trluper/Documents/staticLib/libtest.so /lib/share_test/libtest.so</span><br></pre></td></tr></table></figure>
<p>然后同静态链接一样，引用动态库去编译：（要保证能找到头文件，因此使用<code>-I</code>) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -<span class="type">static</span> main.cpp -I ../staticLib/ -lAlogrithm -o test</span><br></pre></td></tr></table></figure></p>
<h5 id="gdb调试">7.4 gdb调试</h5>
<p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具。GDB主要帮忙你完成下面四个方面的功能：</p>
<ul>
<li>启动程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>动态的改变你程序的执行环境。</li>
</ul>
<h6 id="gdb的工作步骤">7.4.1 gdb的工作步骤</h6>
<p><strong>1. 准备工作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用gcc/g++将其编译为可执行文件，同时使用-g表示该程序可调试：</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ g++ -g main.cpp sum.cpp -o main</span><br></pre></td></tr></table></figure>
<p><strong>2. 启动gdb</strong></p>
<p>输入<code>gdb -q + 可执行文件</code>，启动gdb进行调试。<code>-q</code>参数可以屏蔽一些gdb版本等相关信息，使得页面看起来干净些（我用了）。至此gdb启动完毕： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ gdb -q main</span><br><span class="line">Reading symbols from main...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p><strong>3. 查看代码（可选）</strong></p>
<p>输入<code>list（l）</code>即可查看程序源码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line"><span class="number">1</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Alogrithm.h&quot;</span></span></span><br><span class="line"><span class="number">2</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">3</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="number">4</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">5	</span>&#123;</span><br><span class="line"><span class="number">6</span>		<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="number">7</span>		cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line"><span class="number">8</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span>	&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 设置参数（可选）</strong></p>
<p><code>set args</code>可指定运行时参数（如：<code>set args 10 20 30 40 50</code>）。<code>show args</code>命令可以查看设置好的运行参数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args <span class="number">20</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">(gdb) b <span class="number">2</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b5</span>: file main.cpp, line <span class="number">6.</span></span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/trluper/Documents/staticLib/main <span class="number">20</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;20 30 50&quot;</span>.</span><br></pre></td></tr></table></figure></p>
<p><strong>5.设置断点（可选）</strong></p>
<p>输入<code>break（b）+数字</code> 可以对程序进行断点操作（数字就是设置断点的代码行数） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b <span class="number">2</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b5</span>: file main.cpp, line <span class="number">6.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>6. 启动程序</strong></p>
<p>输入<code>run（r)</code>开始运行程序，直到遇到“断点”或者“结束” <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/trluper/Documents/staticLib/main </span><br><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">6</span></span><br><span class="line"><span class="number">6</span>		<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>7.单步执行程序（可选）</strong></p>
<ul>
<li><code>next</code>单步执行程序，但是遇到函数时会直接跳过函数，不进入函数</li>
<li><code>step</code>单步执行程序，但遇到函数会进入函数</li>
<li><code>continue</code>继续执行程序，直到遇到断点或结束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;20 30 50&quot;</span>.</span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">7</span>		cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">(gdb) <span class="function">s</span></span><br><span class="line"><span class="function"><span class="title">sum</span> <span class="params">(a=<span class="number">10</span>, b=<span class="number">20</span>)</span> at sum.cpp:<span class="number">4</span></span></span><br><span class="line"><span class="function"><span class="number">4</span>		return a+b;</span></span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">5</span>	&#125;</span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="built_in">main</span> () at main.cpp:<span class="number">8</span></span><br><span class="line"><span class="number">8</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>8. 查看变量值（可选）</strong></p>
<p><code>print + 变量</code>查看变量值；<code>whatis + 变量</code>查看变量数据类型。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print a</span><br><span class="line">$<span class="number">1</span> = <span class="number">10</span></span><br><span class="line">(gdb) whatis a</span><br><span class="line">type = <span class="type">int</span></span><br></pre></td></tr></table></figure></p>
<p><strong>9. 退出</strong></p>
<p>输入<code>q</code>即可退出gdb <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) q</span><br><span class="line">A debugging session is active.</span><br><span class="line">	Inferior <span class="number">1</span> [process <span class="number">3102</span>] will be killed.</span><br><span class="line">Quit anyway? (y <span class="keyword">or</span> n) y</span><br></pre></td></tr></table></figure></p>
<h6 id="其他命令">7.4.2 其他命令</h6>
<p><strong>1. 断点</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>delete + n</code></td>
<td>删除第<code>n</code>个断点</td>
</tr>
<tr class="even">
<td><code>disable + n</code></td>
<td>暂停第<code>n</code>个断点</td>
</tr>
<tr class="odd">
<td><code>enable + n</code></td>
<td>开启第<code>n</code>个断点</td>
</tr>
<tr class="even">
<td><code>clear + n</code></td>
<td>清除第<code>n</code>行的断点</td>
</tr>
<tr class="odd">
<td><code>info b</code></td>
<td>显示当前程序的断点设置情况</td>
</tr>
<tr class="even">
<td><code>delete breakpoints</code></td>
<td>清除所有断点</td>
</tr>
</tbody>
</table>
<p><strong>2. 运行信息</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>where/bt</code></td>
<td>当前运行的堆栈列表</td>
</tr>
<tr class="even">
<td><code>bt backtrace</code></td>
<td>显示当前调用堆栈</td>
</tr>
<tr class="odd">
<td><code>up/down</code></td>
<td>改变堆栈显示的深度</td>
</tr>
<tr class="even">
<td><code>info program</code></td>
<td>查看程序是否在运行，以及进程号被暂停的原因</td>
</tr>
</tbody>
</table>
<p><strong>3. 运行命令</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>until</code></td>
<td>如果你厌倦了在一个循环内单步跟踪，它可以运行程序直到退出循环体</td>
</tr>
<tr class="even">
<td><code>until + 行号</code></td>
<td>运行至某行</td>
</tr>
<tr class="odd">
<td><code>finish</code></td>
<td>运行程序，直到当前函数返回完成，并且打印函数返回时的堆栈地址和返回值及参数值等信息</td>
</tr>
<tr class="even">
<td><code>call + 行数 + （参数）</code></td>
<td>调用程序中可见的函数，并传递参数</td>
</tr>
</tbody>
</table>
<h4 id="shell脚本">8. shell脚本</h4>
<p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。对于Linux 的 Shell 种类众多，常见的有：</p>
<ul>
<li><code>Bourne Shell（/usr/bin/sh或/bin/sh）</code></li>
<li><code>Bourne Again Shell（/bin/bash）</code></li>
<li><code>C Shell（/usr/bin/csh）</code></li>
<li><code>K Shell（/usr/bin/ksh）</code></li>
<li><code>Shell for Root（/sbin/sh）</code></li>
</ul>
<p>在一般情况下，人们并不区分<code>Bourne Shell</code>和<code>Bourne Again Shell</code>，所以，像<code>#!/bin/sh，</code>它同样也可以改为 <code>#!/bin/bash</code>。<code>#!</code>告诉系统其后路径所指定的程序即是解释此脚本文件的 <code>Shell</code> 程序。</p>
<h5 id="创建一个脚本文件">8.1 创建一个脚本文件</h5>
<p>使用<code>vi/vim</code>命令来创建文件)，新建一个文件<code>test.sh</code>，扩展名为<code>sh</code>（sh代表shell），扩展名并不影响脚本执行，见名知意就好。输入一些代码，第一行一般是这样: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;Hello World !&quot;</span></span><br></pre></td></tr></table></figure> <strong><code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种<code>Shell</code></strong>。echo 命令用于向窗口输出文本。</p>
<h5 id="运行脚本的方法">8.2 运行脚本的方法</h5>
<h6 id="作为可执行程序">8.2.1 作为可执行程序</h6>
<p>将上面的代码保存到<code>test.sh</code>，并<code>cd</code>到相应目录： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ./test.sh  <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">./test.sh  <span class="comment">#执行脚本</span></span><br></pre></td></tr></table></figure> 注意，一定要写成 <code>./test.sh</code>，而不是<code>test.sh</code>，运行其它二进制的程序也一样，直接写<code>test.sh</code>的话，<code>linux</code>系统会去<code>PATH</code>里寻找有没有叫<code>test.sh</code>的，而只有 <code>/bin, /sbin, /usr/bin，/usr/sbin</code>等在<code>PATH</code>里，你的当前目录通常不在<code>PATH</code>里，所以写成<code>test.sh</code>是会找不到命令的，要用 <code>./test.sh</code> 告诉系统说，就在当前目录找。</p>
<h6 id="作为解释器参数">8.2.2 作为解释器参数</h6>
<p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure> 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<h5 id="变量">8.3 变量</h5>
<p>变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： - 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 - 中间不能有空格，可以使用下划线 _。 - 不能使用标点符号。 - 不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<p>定义变量时，变量名不加美元符号<code>$</code>，但PHP语言中变量需要。使用变量名是需要加<code>$</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">&quot;runoob.com&quot;</span></span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br><span class="line">echo <span class="string">&quot;My name is &amp;&#123;your_name&#125;teacher&quot;</span></span><br><span class="line">your_name=<span class="string">&quot;xiaoming&quot;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>变量名外面的<code>&#123;&#125;</code>是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，</li>
<li>一般推荐使用<code>&#123;&#125;</code>,比如上面的第三节，如果不加<code>&#123;&#125;</code>，则会认为your_nameteacher为一个变量名，就出错了。</li>
<li>重新赋值是允许的，仍有不用加<code>$</code>,只有使用的时候加上<code>$</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" class="post-title-link" itemprop="url">ubuntu使用手册</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-13 16:44:21" itemprop="dateCreated datePublished" datetime="2022-07-13T16:44:21+08:00">2022-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 16:25:35" itemprop="dateModified" datetime="2022-08-02T16:25:35+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ubuntu/" itemprop="url" rel="index"><span itemprop="name">ubuntu</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ubuntu常用快捷键">1. Ubuntu常用快捷键</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、打开终端：Ctr+Alt+T</span><br><span class="line"><span class="number">2</span>、关闭终端：Ctrl + Shift + Q</span><br><span class="line"><span class="number">3</span>、复制：Ctrl + Shift + C</span><br><span class="line"><span class="number">4</span>、粘贴：Ctrl + Shift + V</span><br><span class="line"><span class="number">5</span>、跳转回主机操作:ctr+alt</span><br><span class="line"><span class="number">6</span>、跳回虚拟机：Ctr+G</span><br><span class="line"><span class="number">7</span>、新建终端窗口：Ctrl + Shift + N</span><br><span class="line"><span class="number">8</span>、运行命令：Alt + F2</span><br><span class="line"><span class="number">9</span>、全屏切换：F11</span><br></pre></td></tr></table></figure>
<h4 id="apt安装">2. apt安装</h4>
<p>对于Ubuntu安装各种软件包的命令格式使用<code>apt-get</code>或者<code>apt</code>。（centOS使用<code>yum</code>），这是在线安装。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线安装</span></span><br><span class="line">sudo apt-get update		<span class="comment">//更新软件包列表</span></span><br><span class="line">sudo apt-get install	<span class="comment">//安装软件</span></span><br><span class="line">sudo apt-get remove		<span class="comment">//删除软件</span></span><br><span class="line">sudo apt-get clean		<span class="comment">//清理安装包</span></span><br></pre></td></tr></table></figure> <strong><em>附：</em></strong>如果是从Ubuntu官网已经下载好了安装包，相应离线安装的话，因为从Ubuntu的文件为deb格式，所以</p>
<ul>
<li>软件安装<code>sudo dpkg -i xxx.deb</code></li>
<li>软件卸载<code>sudo dpkg -r 软件名</code></li>
</ul>
<h5 id="安装net-tools网络工具">2.1 安装net-tools网络工具</h5>
<p><code>net-tools</code>工具箱包括<code>arp, hostname, ifconfig, netstat, rarp, route, plipconfig, slattach, mii-tool and iptunnel and ipmaddr</code>等命令。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure></p>
<h5 id="安装ssh">2.2 安装ssh</h5>
<p><code>ssh</code>用于远程登录到<code>Linux</code>服务器来管理维护系统。<code>SSH</code>是专为远程登录会话和其他网络服务提供安全性的协议；使用<code>ssh</code>服务（指实现<code>SSH</code>协议的软件）可远程登录到服务器来管理维护系统，防止远程管理过程中的信息泄露问题。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装</span></span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"><span class="comment">//查看状态</span></span><br><span class="line">service ssh status</span><br><span class="line"><span class="comment">//查看端口</span></span><br><span class="line">netstat -anp |grep <span class="number">22</span> netstat -anp |grep sshlsof -i :<span class="number">22</span></span><br></pre></td></tr></table></figure></p>
<h5 id="aptitude">2.3 aptitude</h5>
<p><code>aptitude</code> 命令与 <code>apt-get</code> 命令一样，都是Debian Linux 及其衍生系统中功能极其强大的包管理工具。与<code>apt-get</code>不同的是，<code>aptitude</code>在处理依赖问题上更佳一些。举例来说，<code>aptitude</code> 在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。它通过文本操作菜单和命令两种方式管理软件包。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装</span></span><br><span class="line">sudo apt-get install aptitude</span><br><span class="line"><span class="comment">//命令</span></span><br><span class="line">aptitude upgrade		<span class="comment">//升级系统所有的软件包</span></span><br><span class="line">aptitude dist-upgrade	<span class="comment">//将系统升级到新的发行版</span></span><br><span class="line">aptitude safe-upgrade	<span class="comment">//安全升级系统的软件包</span></span><br><span class="line">aptitude install net-tools	<span class="comment">//安装软件包</span></span><br><span class="line">ptitude purge net-tools	<span class="comment">//彻底删除软件包</span></span><br><span class="line">aptitude search ssh	<span class="comment">//根据关键词搜索软件包</span></span><br><span class="line">aptitude show ssh	<span class="comment">//查看软件包的详细信息</span></span><br><span class="line">aptitude clean		<span class="comment">//删除缓存目录中的软件包安装文件</span></span><br></pre></td></tr></table></figure></p>
<h5 id="安装gccg">2.3 安装gcc/g++</h5>
<p><code>GCC</code>原名为 <code>GNU C</code> 语言编译器，因为它原本只能处理 C语言。GCC 快速演进，变得可处理 <code>C++、Fortran、Pascal、Objective-C、Java</code> 以及 <code>Ada</code> 等他语言。实际使用中：</p>
<ul>
<li>使用 <code>gcc</code> 指令编译 C 代码</li>
<li>使用 <code>g++</code>指令编译 C++ 代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo  apt-get insatll gcc</span><br><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure>
<h5 id="安装vim">2.4 安装vim</h5>
<p><code>vim</code>是从<code>VI</code>发展而来的一个文本编辑器，功能更强大。而<code>vim.tiny</code>是vim的精简版，所以，安装<code>vim</code>势在必行。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure></p>
<h5 id="安装cmake">2.5 安装Cmake</h5>
<p><code>Camke</code>是一个高级编译工具，当你用不同的语言或者编译器开发一个项目，各就各位code完之后要生成最终的输出（<code>dll</code>或执行文件），这时候就尴尬了，你要手动去MingGW或者GCC下配置成千上万的<code>.cpp .h .o .c</code>路劲和地址吗？这时候神器就出现了<code>CMake</code>，主要功能：</p>
<ul>
<li>配置和生成各大平台的工程（vs的vcxproj，Qt的Pro）</li>
<li>生成makefile文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure>
<h5 id="第三方线程库">2.6 第三方线程库</h5>
<p><code>pthread</code>是第三方线程库，安装如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install glibc-doc</span><br><span class="line"> sudo apt-get install manpages-posix manpages-posix-dev</span><br></pre></td></tr></table></figure></p>
<h5 id="mysql安装">2.7 MySQL安装</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server;</span><br></pre></td></tr></table></figure>
<h4 id="虚拟机网络问题">3. 虚拟机网络问题</h4>
<p>有时候我们的虚拟机会出现无法连接上网的情况，解决方法如下：</p>
<ul>
<li>检查宿主主机，能正常联网</li>
<li><p>linux的ifconfig显示，没有固定IP <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        inet6 ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0x10</span>&lt;host&gt;</span><br><span class="line">        loop  txqueuelen <span class="number">1000</span>  (Local Loopback)</span><br><span class="line">        RX packets <span class="number">2588</span>  bytes <span class="number">197004</span> (<span class="number">197.0</span> KB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">2588</span>  bytes <span class="number">197004</span> (<span class="number">197.0</span> KB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>将网络管理的缓存清除后重新开启即可 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service network-manager stop</span><br><span class="line">sudo rm /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">sudo service network-manager start</span><br></pre></td></tr></table></figure></p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">STL源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-12 22:15:12" itemprop="dateCreated datePublished" datetime="2022-07-12T22:15:12+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-28 21:46:45" itemprop="dateModified" datetime="2022-07-28T21:46:45+08:00">2022-07-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>88k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:20</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="stl概述">1.STL概述</h4>
<h5 id="六大组件">1.1 六大组件</h5>
<ul>
<li>容器：各种数据结构,如<code>vector、list、deque、set、map</code>等,用来存放数据</li>
<li>算法：各种常用的算法（冒泡，排序）,如<code>sort、find、copy、for_each、search、erase</code></li>
<li>迭代器：扮演了容器与算法之间的胶合剂，是所谓的泛型指针</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理。注意一般都伴随着重新分配空间，那么原来的迭代器就会失效</li>
</ul>
<p>六大组件的交互关系是<code>Container</code>通过<code>Allocator</code>获得数据存储空间，<code>Alogrithm</code>通过<code>Iterator</code>存取<code>Container</code>的内容，<code>Functor</code>可以协助<code>Algorithm</code>完成不同的策略变化，<code>Adapter</code>可以修饰或套接<code>Functor</code>。本笔记将会以此对这六大组件进行介绍。</p>
<p>++说在前面：STL的实现版本由HP版本、PJ版本、RW版本、STLport版本和SGISTL版本等五个主要版本++</p>
<h4 id="空间配置器">2. 空间配置器</h4>
<p>在介绍STL的其他组件尤其是<code>container</code>组件之前，空间配置器是必须要先介绍的，因为容器内存空间的开辟需要由<code>allocator</code>去申请。allocator申请的空间是为构造原始的，<code>new</code>申请的空间是已构造的。在<code>gcc</code>中的容器使用了缺省的SGI版本的空间配置器：<code>class Alloc = alloc</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, **<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc**&gt;	<span class="comment">//默认使用了alloc</span></span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="comment">/*...实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="空间配置器的标准接口">2.1 空间配置器的标准接口</h5>
<p>allocator的必要接口（无论是哪个版本的STL）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员变量</span></span><br><span class="line">allocator::value_type;</span><br><span class="line">allocator::pointer;</span><br><span class="line">allocator::const_pointer;</span><br><span class="line">allocator::reference;</span><br><span class="line">allocator::const_reference;</span><br><span class="line">allocator::size_type;</span><br><span class="line">allocator::difference_type;</span><br><span class="line">allocator::rbind;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>();</span><br><span class="line">allocator::<span class="built_in">allocator</span>(<span class="type">const</span> allocator&amp;);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;allocator：：<span class="built_in">allocator</span>(<span class="type">const</span> allocator&lt;U&gt;&amp;);</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">allocator::~<span class="built_in">allocator</span>();</span><br><span class="line"><span class="comment">//返回某个对象的地址，等同于&amp;X</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::address</span><span class="params">(reference x)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//配置空间，n个足以存储U对象</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n,<span class="type">const</span> <span class="type">void</span>*=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//回收配置的空间,p为allocate返回的指针，n为allocate分配是指定的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::deallocate</span><span class="params">(pointer p,size_type n)</span></span>;</span><br><span class="line"><span class="comment">//对分配空间进行构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::construct</span><span class="params">(pointer,<span class="type">const</span> T&amp;x)</span></span>;</span><br><span class="line"><span class="comment">//对构造空间析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::destroy</span><span class="params">(pointer p)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="设计一个简单的空间配置器">2.1.1设计一个简单的空间配置器</h6>
<p>根据上述的接口，我们可以实现一个自己的、功能简单，接口不齐全的<code>allocator</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstddef&gt;</span>	<span class="comment">//ptrdiff_t,size_t类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myallocator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">inline</span> T* _allocate()（<span class="type">ptrdiff_t</span> size,T*)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//使用全局operator new ,相当于malloc</span></span><br><span class="line">		T* tmp=(T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size*<span class="built_in">sizeof</span>(T))));	<span class="comment">//调用全局重载运算符new</span></span><br><span class="line">		<span class="keyword">if</span>(tmp==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cerr&lt;&lt;<span class="string">&quot;out_of_memory&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _deallocate(T*buffer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//相当于free</span></span><br><span class="line">		::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _construct(T* p,<span class="type">const</span> U&amp; value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span>(p) <span class="built_in">U</span>(value);		<span class="comment">//placement new，相当于realloc，并进行构造</span></span><br><span class="line">	&#125;</span><br><span class="line">	/析构</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _destroy(T* ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">allocator</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> T  value_type;</span><br><span class="line">		<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> T* const_pointer;</span><br><span class="line">		<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">		<span class="comment">//内嵌体</span></span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rebind</span>&#123;</span><br><span class="line">			<span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//函数</span></span><br><span class="line">		<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n,<span class="type">const</span> <span class="type">void</span>* hint=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _allocate((difference_type)n,(pointer)hint);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">deallocte</span><span class="params">(pointer p,size_type n)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_deallocate(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_constrcut(p,value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_destroy(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	<span class="comment">//end of namespace myallocator</span></span><br></pre></td></tr></table></figure></p>
<h5 id="sgi空间配置器">2.2 SGI空间配置器</h5>
<p>SGI版本的空间配置器与众不同，其名称是<code>alloc</code>而不是<code>allocator</code>。<code>alloc</code>不接受任何参数，即如果你的程序要采用SGI版本的配置器，则不能使用标准写法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::allocator&lt;<span class="type">int</span>&gt;&gt; iv;</span><br></pre></td></tr></table></figure> 而应当使用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::alloc&gt; iv;</span><br></pre></td></tr></table></figure> 其实这个问题不会给我们带来困扰，在<code>GCC</code>中是使用缺省的空间配置器，我们可以不用显示的去指定，编译器默认采用SGI的这个版本。</p>
<p><strong><em>附</em></strong>：虽然SGI也提供了一个<code>aloocator</code>版本，但是不建议使用，因为效率不佳，因为它只是对<code>::operator new</code>和<code>::operator delete</code>做一个简单包装而已</p>
<h5 id="sgi的alloc">2.3 SGI的alloc</h5>
<p>我们知道<strong><code>new</code>算式包含两个步骤</strong>：一是调用<code>::operator new</code>配置内存；二是调用相应的构造函数构造对象内容。同样<strong><code>delete</code>算式也包含两个步骤</strong>：一是调用对象的析构函数析构；二是调用<code>::operator delete</code>释放内存</p>
<p>为了精密加工和效率的提升，STL的allocator把这两步操作区分开来，<strong>内存配置操作由<code>alloc::allocate()</code>负责，内存释放由<code>alloc::deallocate()</code>负责；而对象的构造和析构分别是由<code>::construct()</code>和<code>::destroy()</code>负责。</strong>STL的标准中规定配置器的定义位于<code>&lt;memory&gt;</code>中，对SGI版本来说<code>&lt;memory&gt;</code>内含有关键的两个文件，这两个文件实行上面的工作划分规则 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_alloc.h&gt;</span>		<span class="comment">//负责内存的配置和释放</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_construct.h&gt;</span>	<span class="comment">//负责构造和析构</span></span></span><br></pre></td></tr></table></figure> 在<code>&lt;stl_alloc.h&gt;</code>中定义了<strong>一、二级配置器</strong>，而在<code>&lt;stl_construct.h&gt;</code>定义了<code>construct()</code>和<code>destroy()</code>函数。</p>
<h5 id="alloc的stl_constuct">2.4 alloc的stl_constuct</h5>
<p>在<code>&lt;stl_construct.h&gt;</code>定义了多个重载的<code>construct()</code>和<code>destroy()</code>函数。这里介绍接受两个迭代器版本的<code>destroy()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator lasu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_destroy(first,last,<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个函数我们可以知道它会析构掉<code>[first,last)</code>范围内对象，<strong>如果是调用一些无关痛痒得析构函数，又万一这个范围很大的话效率会极低。因此<code>_destroy()</code>利用<code>value_type()</code>获得迭代器对象所指代得类型，在<code>_destroy</code>内部利用<code>_type_traits&lt;T&gt;</code>判断该类型得析构是否对内存空间无关痛痒，若是<code>_true_type</code>，则什么也不做就结束，若是<code>_false_type</code>则只能迭代去析构这个范围得对象。</strong></p>
<h5 id="空间配置stl_alloc">2.5 空间配置stl_alloc</h5>
<p>SGI内部是以<code>malloc()</code>和<code>free()</code>完成内存得配置与释放得。考虑到小型区块可能造成内存碎片得问题，SGI设计了双层配置器，<strong>第一级直接使用<code>molloc()</code>和<code>free()</code>,第二级则看情况采用不同策略分配：</strong></p>
<ul>
<li>当配置区块超过<code>128bytes</code>时，视为足够大，直接调用第一级得配置器</li>
<li>当配置区块小于<code>128bytes</code>时，视为小，便采用复杂的<code>memory pool</code>和自由链表管理配置</li>
</ul>
<p><strong>内存池<code>memory pool</code></strong>：内存池是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样，内存池允许在运行期以常数时间规划内存块，并且尽量避免了内存破碎的情况产生，使得内存分配的效率得到提升。</p>
<p><strong><em>注意：是只开放一级配置器还是同时开放二级，由<code>_USE_MALLOC</code>是否被定义而定，当被定义是，只开放第一级配置器，当未背定义时两级都开放。</em></strong></p>
<h6 id="一级配置器">2.5.1 一级配置器</h6>
<p>一级配置器是类名为<strong><code>template&lt;int inst&gt;class _malloc_alloc_template&#123;...&#125;</code></strong>的一个类，在<code>allocate()</code>内直接使用<code>malloc()</code>,在<code>deallocate()</code>直接使用<code>free()</code>。同时<strong>模拟<code>set_new_handler()</code>来处理内存不足的情况</strong>。奉上源码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_malloc_alloc_template</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//以下函数用来处理内存不足的情况</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span>*,<span class="type">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*_malloc_alloc_oom_handler)</span><span class="params">()</span></span>;	<span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//allocate分配</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">		<span class="type">void</span> *result=<span class="built_in">malloc</span>(n);		<span class="comment">//直接使用malloc分配</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==result)</span><br><span class="line">			result=<span class="built_in">oom_malloc</span>(n);	<span class="comment">//不断尝试</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//模拟set_new_hanlder，返回函数指针</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span><span class="params">(* set_malloc_hanlder(<span class="type">void</span>(*f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">void</span> (*old)=_malloc_alloc_oom_handler;</span><br><span class="line">		<span class="comment">//设置</span></span><br><span class="line">		_malloc_alloc_oom_handler=f;</span><br><span class="line">		<span class="keyword">return</span> (old);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数为纯虚函数，需要自己编写处理函数来不断尝试释放内存、申请内存</span></span><br><span class="line"><span class="built_in">void</span> (* _malloc_alloc_template&lt;inst&gt;::_malloc_alloc_oom_handler)()=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//malloc形式的不断尝试</span></span><br><span class="line"><span class="type">void</span> *_malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n)&#123;</span><br><span class="line">	<span class="built_in">void</span> (*my_malloc_hanlder)();	<span class="comment">//函数指针</span></span><br><span class="line">	<span class="type">void</span> *result;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;<span class="comment">//不断尝试释放，配置</span></span><br><span class="line">		my_malloc_hanlder=_malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==my_malloc_handler)</span><br><span class="line">			_ThROW_BAD_ALLOC;</span><br><span class="line">		(*my_malloc_handler)();<span class="comment">//调用释放</span></span><br><span class="line">		<span class="comment">//进行分配</span></span><br><span class="line">		result=<span class="built_in">malloc</span>(n);</span><br><span class="line">		<span class="comment">//分配成功直接返回</span></span><br><span class="line">		<span class="keyword">if</span>(result)</span><br><span class="line">			<span class="keyword">return</span>(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>查看上述的部分源代码可以知道</strong></p>
<ul>
<li>第一级空间分配器以<code>malloc()、free()、realloc()</code>等C函数执行内存配置，而不是采用<code>C++</code>的<code>::operator new</code>，<strong>因此无法使用C++的<code>new hanlder</code>机制，也就不能使用<code>set_new_hanlder()</code>,必须仿真一个类似该功能的<code>set_malloc_handler()</code></strong></li>
<li><code>allocate()</code>分配不成功后会改调用<code>oom_malloc()</code>不断尝试去释放分配，其中的<code>_malloc_alloc_oom_hanlder()</code>函数是要自己去编写指定的。如果你没有传入该函数，源码也未提供，默认为纯虚函数，则进入到<code>oom_hanlder()</code>判断后直接抛异常。</li>
</ul>
<h6 id="附加知识点new-handler机制">2.5.2 附加知识点：new handler机制</h6>
<p><code>new_handler</code>是一个void*类型的函数指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">　<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;	<span class="comment">//函数指针，只是起个名字new_handler=void*</span></span><br><span class="line"> <span class="comment">//new_handler是一个typedef后void*</span></span><br><span class="line">　<span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>new_handler</code>类型内的函数将在默认内存申请函数<code>operator new</code>和<code>operator new[]</code>申请内存失败时被调用;</li>
<li>默认情况下, 当内存不能够分配时, <code>new</code>操作将抛出一个<code>bad_alloc</code>的异常。 你可以改变这个默认操作, 通过<code>set_new_handler()</code>设置<code>new_handler</code>内的函数指针。当然 你可以使用<code>set_new_handler(0)</code>, 获得一个不抛出异常的<code>new</code>.</li>
</ul>
<p><strong>用户定义的my_handler应该可以做以下几件事之一:</strong></p>
<ul>
<li>释放内存, 产生更多可以用的内存</li>
<li>抛出bad_alloc异常(或bad_alloc派生类)</li>
<li>终止程序(比如调用abort或exit)</li>
</ul>
<h6 id="二级配置器">2.5.3 二级配置器</h6>
<p>二级配置器类名为<strong><code>template&lt;bool threads,int ints&gt;class _default_alloc_template&#123;...&#125;</code>：维护16个自由链表，负责16种小型区块内存池的次配置能力，内存池<code>memory pool</code>事先由<code>malloc</code>配置而得</strong>。为了方便管理，SGI的二级配置会主动将小额的内存需求上调至8的倍数，例如我们要求分配30bytes，那么二级配置器就会分配维护多个<code>32bytes</code>的内存块。第二级配置器多了许多机制，以避免太多的小额区块造成内存碎片，从而避免内存浪费和减轻配置负担，第二级配置的做法是：</p>
<ul>
<li>当配置区块超过<code>128bytes</code>时，视为足够大，直接调用第一级得配置器</li>
<li>当配置区块小于<code>128bytes</code>时，视为小，便采用复杂的<code>memory pool</code>管理配置，又称为次层配置。</li>
</ul>
<p><strong><code>memory pool</code>的想法是</strong>：预先配置一大块内存，一般来书为需求的2倍，并维护与之对应的自由链表<code>free list</code>。<strong>下次若有对应大小的内存需求，则直接从该链表拔出给它就行；如果客户端释还从该内存池种拔出的一部分内存，则由配置器回收到该内存池中</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free list的节点结构如下所示：节点使用union而不是struct，从而达到节省内存开销的目的。</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span>&#123;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;	<span class="comment">//未被使用时，由次指针维护</span></span><br><span class="line">	<span class="type">char</span> client_data[<span class="number">1</span>];	<span class="comment">//当内存被使用时，软件开发者使用这个，执行实际区块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>下面来介绍这种机制：</strong>从内存池中取空间给<code>free list</code>是<code>chunk_alloc()</code>函数得工作。</p>
<ul>
<li>如<code>chunk_alloc(32，20)</code>会根据<code>end_free-start_free</code>来判断内存池得水量是否充足，如果水量充足，则直接调出20个相应大小的内存区块给<code>free_list</code>；如果不充足则调用<code>malloc</code>分配至少40个<code>32bytes</code>的内存块，一个直接给客户端，19个给<code>free_list</code>维护，另外的给内存池</li>
<li>如果不够20个但至少能满足一个32bytes的内存块，也会拨出至少一个；</li>
<li>如果连一个区块都拨不出去，此时便会利用<code>malloc</code>从<code>heap</code>上配置内存，从内存中为内存池注入水源以应付需求，一般来说申请的内存是需求量的2倍。</li>
</ul>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/memorypool.png" width="700"></p>
<p>如上图：</p>
<ul>
<li><strong>假设程序一开始就调用<code>chunk_alloc(32,20)</code>,那么<code>malloc</code>就会配置40个<code>32bytes</code>的区块，其中第一个交出，另外19个交给<code>free_list[3]</code>维护，剩余20个交给内存池。</strong></li>
<li>接下来客户端再调用<code>chunk_alloc(64,20)</code>,此时很明显<code>free_list[7]</code>没有内存，必须向内存池请求支持，但内存池也只够10个64<code>bytes</code>的区块，那么就会交付这10，一个直接给客户端，另外9个由<code>free_list[7]</code>维护。此时内存池已经空了，</li>
<li>如果再调用<code>chunk_alloc(96,20)</code>,不仅<code>free_list[11]</code>没有内存，就连内存池也没有，那么就会调用<code>malloc</code>配置40+n个<code>96bytes</code>区块，其中第一个给客户端，19个给<code>free_list[11]</code>，另外的给内存池。</li>
<li>如果<code>malloc()</code>也无法分配内存，就会使用第一级配置，不断尝试去释放获取。</li>
</ul>
<h4 id="迭代器与traits编程技法">3. 迭代器与traits编程技法</h4>
<p><code>iterator</code>是指提供一种方法，使之能够依序巡防某个容器所含的各个元素，而又无需暴露该容器的内部表达式。STL通过泛型化将数据容器和算法分开，采用<code>iterator</code>将两者粘合起来，以<code>find</code>为例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(first!=last&amp;&amp;*first!=value)</span><br><span class="line">		++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 迭代器是一种行为类似指针的<strong>对象</strong>，而指针最常见的应用就是<strong>内容提取和成员访问</strong>，因此对于迭代器来说最重要的编程工作就是对<code>operator *、operator-&gt;、operator++</code>进行重载</p>
<h5 id="traits编程技法-stl源码的门钥">3.1 traits编程技法-STL源码的门钥</h5>
<h6 id="为什么要使用traits编程技法">3.1.1 为什么要使用traits编程技法</h6>
<p>迭代器一般都为模板，其所指对象的的型别，称为该迭代器的<code>value type</code>。模板函数虽然带有参数类型的推导，但却不是万能的：<strong>万一<code>value type</code>用于函数的反回值，毕竟template的参数推导机制只是适用于参数，无法推导返回值</strong>。<strong>我们可能可以在类内定义内嵌型别来解决，也可以使用<code>C++11</code>的的尾置返回类型</strong><code>remove_reference&lt;decltype(beg*)&gt;::type</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内嵌类型声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myiter</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;		<span class="comment">//内嵌型别声明</span></span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> I&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> I::value_type <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾置返回类型</span></span><br><span class="line"><span class="comment">//此例中我们通知编译器fcn2的返回类型与解引用beg的参数的结果类型相同</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(T beg,T end)</span>-&gt;<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上面这个程序看起来能够解决返回值问题，但是有一个问题就是我们<strong>不能为不是类类型的定义内嵌型别</strong>，比如<strong>指针</strong>就不行，但STL又必须接受原生指针作为一种迭代器。虽然采用模板的特例化可以解决问题，但是每有需要就要特例化一个模板就很麻烦，此时就得采用<code>traits</code>的偏特例化编程。(像<code>int*,double*</code>内置类型或者自动定义的类的指针就是原生指针)</p>
<h6 id="traits和偏特例化">3.1.2 traits和偏特例化</h6>
<p><code>traits</code>单词只是说明这个类能萃取到迭代器的特性，只是一个名字的作用，告诉编程人员注意对于这种类内部会对传入的参数进行取<code>value type</code>操作，说实在就是STL当中的规范协议。如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> itrator_traits&lt;I&gt;::<span class="built_in">value_type</span>(I iter)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果I内定义了自己的<code>value type</code>，那么就会在<code>iterator_traits</code>这种类内部有取<code>value type</code>操作。这里跟我们上面提到的内嵌型别说明是一样的。上面这个类只是起到中间转换的作用，这就<code>traits</code>的特定。</p>
<p>然后我们在去实现iterator_traits的一个特例化版本即传入指针形式的偏特化版本就能取得指针的类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的机制是当我们传入T*=int*时，因为int内有定义value_type那么就肯定能获得其类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 为啥还需要const版本，引用我们最终要获取时<code>I</code>的类型，而不是<code>const+类型</code>,试想当没有const版本，调用iterator_traits&lt;const int*&gt;会获取到<code>const int</code>而不是<code>int</code>。<strong>三个版本都是需要的，后面两个版本为解决原生指针无法获取类型而采用（应用偏特例化）</strong></p>
<p>总结：</p>
<ul>
<li>实现原生指针也能推导返回值类型就是要<code>traits</code>编程技法</li>
<li><code>traits</code>不是什么C++内部关键字，它只是对STL源码编写的一个规范</li>
<li><code>traits</code>编程技法主要应用于迭代器实现，迭代器就是行为像指针的类，保证我们在使用迭代器类的<code>operator*</code>后能返回迭代器所指的元素</li>
<li><code>traits</code>编程技法的实现原理就是对类模板的偏特例化（上面的二个篇特例化模板）</li>
</ul>
<h5 id="迭代器相应型别">3.2 迭代器相应型别</h5>
<p>更加迭代器使用<code>operator*</code>时所返回的类别，一般有<code>value type,difference type,pointer,reference,itrator category</code>这五种。因此我们在对<code>traits</code>类进行<code>typedef</code>时都应当指定，以便符号STL规范，即使自己编写的迭代器类也能与STL水乳交融。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::iterator_category	iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type 		    value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::difference_type 	difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer 			pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference 			reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="value_type">3.2.1 value_type</h6>
<p><code>value_type</code>就是迭代器所指对象的型别，任何一个打算与STL算法有完美搭配的class,都应当定义自己的<code>value_type</code>内嵌型别。</p>
<h6 id="difference_type">3.2.2 difference_type</h6>
<p><code>difference_type</code>用来表示两个迭代器的距离，因此也可以用来表示一个容器的最大容量。比如STL的<code>count</code>算法统计指定值出现次数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I*&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">count</span><span class="params">(I fist,I last,<span class="type">const</span> T&amp; value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I*&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;first!=last;++first)</span><br><span class="line">		<span class="keyword">if</span>(*first==value)</span><br><span class="line">			++n;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="reference">3.2.3 reference</h6>
<p><code>reference_type</code>即我们熟知的C++当中的左值引用，这个类型允许我们通过迭代器来对容器内的元素做出改变。</p>
<h6 id="pointer">3.2.4 pointer</h6>
<p><code>pointer</code>是指指针，传回一个指针表示我们也可以通过迭代器对容器内的元素做改变。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="iterator_category">3.2.5 iterator_category</h6>
<p>这个型别是迭代器的类型型名，必须指定迭代器的分类如下： <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/iterator.png" width="300"> 我们在设计算法的时候，必须针对上图的某种迭代器提供一明确定义，比如有一个算法明确使用<code>ForwardIterator</code>，那就应当明确传递这种迭代器，虽然传递<code>RandomAccessIterator</code>和<code>BidirectionalIterator</code>也可以,但效率并不是最佳。</p>
<h5 id="iterator源代码展示">3.3.iterator源代码展示</h5>
<p>下面的源代码选自SGI版本的STL<code>&lt;stl_iterator.h&gt;</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ITERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ITERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//五种迭代器，作为标记型别（tag types）,不需要任何成员</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iteratoe_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为避免写代码时挂一漏万，自行开发的迭代器最好继承自下面这个 std::iterator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Category</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>=<span class="type">ptrdiff_t</span>,</span><br><span class="line">		<span class="keyword">class</span> Pointer=T*,<span class="keyword">class</span> Reference=T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//五种迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> input_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                   value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance            difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                  pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                  reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                     value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance              difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                    pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                    reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;榨汁机&quot;traits</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer            pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference          reference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生指针（naive pointer）而设计的traits偏特性化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对Pointer-to-const而设计的traits偏特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T*                    pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T                     reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某迭代器iterator的类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">category</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器的value_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器的distance_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type*</span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//........................整组advance函数............................................</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数重载，使迭代器能在编译时期就确定调用哪个函数*/</span>  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为input_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_InputIter&amp; __i, _Distance __n, input_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (__n--) ++__i;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为bidirectional_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_BidirectionalIterator&amp; __i, _Distance __n,   </span><br><span class="line">                      bidirectional_iterator_tag) </span><br><span class="line">&#123;  </span><br><span class="line">  __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);  </span><br><span class="line">  <span class="keyword">if</span> (__n &gt;= <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">while</span> (__n--) ++__i;</span><br><span class="line">  <span class="keyword">else</span>  </span><br><span class="line">    <span class="keyword">while</span> (__n++) --__i;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为random_access_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_RandomAccessIterator&amp; __i, _Distance __n,   </span><br><span class="line">                      random_access_iterator_tag) </span><br><span class="line">&#123;  </span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);  </span><br><span class="line">  __i += __n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*决定调用哪个函数，这是一个对外接口*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(_InputIterator&amp; __i, _Distance __n)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_InputIterator, _InputIterator);</span><br><span class="line">  __advance(__i, __n, <span class="built_in">iterator_category</span>(__i));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//............................整组distance函数........................................</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function">	<span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __distance(first, last,</span><br><span class="line">			std::iterator_traits&lt;InputIterator&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">	_distance(InputIterator first,InpuetIterator，input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">    	++first;</span><br><span class="line">		++n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::difference_type </span><br><span class="line">        __distance(InputIterator first, InputIterator last, </span><br><span class="line">		std::random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的<code>advan</code>函数<strong><em>如果</em></strong>不加第三个参数，因为型别都未定，<strong>是实打实的<code>template</code>，不是重载函数，如下：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_II</span><span class="params">(InputIterator&amp; __i, _Distance __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectinalIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_BI</span><span class="params">(BidirectinalIterator&amp; __i, _Distance __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_RI</span><span class="params">(RandomAccessIterator&amp; __i, _Distance __n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们调用的时候，如果选错使用<code>advance_II</code>来进行<code>advance_RI</code>的工作内容，则原本的O(1)时间复杂度就变成了O(n)，<strong>因此在源码中通过增加五个结构体，来给这些函数增加第三个确定的参数形成重载机制，在编译时能够使用重载确定调用哪一个版本，容错率高</strong>。<code>distance</code>函数也是这样的思想。这是一个值得借鉴的模板编写方式！</p>
<h4 id="序列式容器">4. 序列式容器</h4>
<p>序列式容器当中的元素都可序，但未必一定有序，全看编程者的操作。C++语言本身带有<code>array</code>，STL提供<code>vector、list、deque、stack、queue、priority_queue</code>等序列容器。由于<code>stack\queue</code>只是将<code>deque</code>改头换面而成，技术上被归为配接器。</p>
<h5 id="vector">4.1 vector</h5>
<p>在<code>vector</code>中最关键的在于器对大小的控制以及重新配置时数据的移动效率。这些在后面会介绍到，这里我们先对<code>vector</code>的源码进行简单介绍： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T			value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;		<span class="comment">//这个说明了迭代器就是普通指针</span></span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> 		size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> 	difference_type;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//Simple_alloc时SGI STL的空间配置器，</span></span><br><span class="line">	<span class="comment">//虽然vector使用了缺省的配置器,但Simple_alloc更方便以元素大小为配置单元</span></span><br><span class="line">	<span class="keyword">typedef</span> Simple_alloc&lt;value_type,Alloc&gt;data_allocator;</span><br><span class="line">	iterator start;						<span class="comment">//表示目前使用空间的头</span></span><br><span class="line">	iterator finissh;					<span class="comment">//表示目前使用空间的尾</span></span><br><span class="line">	iterator end_of_storage;			<span class="comment">//表示目前可用空间的尾</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_aux</span><span class="params">(iterator position,<span class="type">const</span> T&amp;x)</span></span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...<span class="comment">//一些操作接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 因为<code>vector</code>维护的一个连续空间，所有不论元素型别为哪一种，普通指针都可以作为<code>vector</code>的迭代器而满足所有必要条件，因为像<code>operator*,-&gt;,++,--,+,-,+=,-+</code>这些操作，普通的指针天生就具备。也就是说普通指针就是<code>RandomAccessIterator</code>，支持随机存取。</p>
<h6 id="扩容机制">4.1.1 扩容机制</h6>
<p>在不同的STL版本中，vector的扩容策略不相同，msvc编译器每次是以1.5倍且向下取整的策略进行扩容，gcc编译器则是SGI版本，每次以2.0倍的策略进行扩容。下图时MSVC中的扩容机制 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MSVC</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">34</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(n);</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;size:&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot;  capacity:&quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">size:<span class="number">1</span>  capacity:<span class="number">1</span></span><br><span class="line">size:<span class="number">2</span>  capacity:<span class="number">2</span></span><br><span class="line">size:<span class="number">3</span>  capacity:<span class="number">3</span></span><br><span class="line">size:<span class="number">4</span>  capacity:<span class="number">4</span></span><br><span class="line">size:<span class="number">5</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">6</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">7</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">8</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">9</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">10</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">11</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">12</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">13</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">14</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">15</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">16</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">17</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">18</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">19</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">20</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">21</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">22</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">23</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">24</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">25</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">26</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">27</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">28</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">29</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">30</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">31</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">32</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">33</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">34</span>  capacity:<span class="number">42</span></span><br></pre></td></tr></table></figure></p>
<p>所谓的动态增加，并不是在原空间之后接续新空间，因为无法保证原空间之后尚有可供配置的空间，二是以原来的2倍或1.5倍另外配置一块较大空间，然后将内容拷贝过来，然后才在原内容之后构造新元素，并释放原空间。因此对<code>vector</code>的任何操作若会影响到空间重新配置，指向<code>vector</code>的所有迭代器就都失效了。</p>
<h5 id="list">4.2 list</h5>
<p>相较于<code>vector</code>的连续线性空间，list就比较复杂，它的好处就是每次插入或删除元素，才配置或释放一个元素空间。<strong><code>list</code>是一个双向链表，它不再能够像<code>vector</code>一样以</strong>普通指针<strong>作为迭代器，因为其节点不保证再空间中连续存在，<code>list</code>迭代器必须有能指向<code>list</code>的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。</strong></p>
<h6 id="list的迭代器">4.2.1 list的迭代器</h6>
<p><strong><code>list</code>的迭代器的要求:</strong></p>
<ul>
<li>迭代器必须具备前移、后移的能力，因此对<code>list</code>提供的是<code>BidirectinalIterator</code></li>
<li>与vector不同，不论是何时的插入操作和删除操作、接合操作都不会造成原因的<code>list</code>迭代器失效</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	link_type node; <span class="comment">//迭代器内部需要一个普通指针，指向list的节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//constructor</span></span><br><span class="line">	__list_iterator(link_type x):<span class="built_in">node</span>(x)&#123;&#125;</span><br><span class="line">	__list_iterator()&#123;&#125;</span><br><span class="line">	__list_iterator(<span class="type">const</span> iterator&amp; x):<span class="built_in">node</span>(x.node)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node==x.node;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node!=x.node;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以下对迭代器取值，取的是节点的数据值</span></span><br><span class="line">	reference <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对迭代器累加</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">		node=(link_type)((*node).next);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">		self tmp=*<span class="keyword">this</span>;</span><br><span class="line">		++*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对迭代器减1</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">		node=(link_type)((*node).prev);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">		self tmp=*<span class="keyword">this</span>;</span><br><span class="line">		--*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="list的数据结构">4.2.2 list的数据结构</h6>
<p><code>list</code>是一个<strong>双向环形链表</strong>，所有它只需要一个指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> _list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	link_type node;		<span class="comment">//只需一个指针</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="deque">4.3 deque</h5>
<p><strong><code>deque</code>是一种双向开口的连续线性空间，即指能在头尾两端都支持元素的插入和删除</strong> <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/deque.png" width="500"> <code>vector</code>虽然也能支持在头尾两端进行操作，但是效率奇差，无法接受，因为在头部的插入导致后面所有元素都要后移。而<code>deque</code>则不会：</p>
<ul>
<li><code>duque</code>允许时间复杂度<code>O(1)</code>对其头端进行元素的插入和移除，<code>vector</code>为<code>O(n)</code></li>
<li><code>deque</code>没有所谓的容量概念，因为它是动态地以连续空间组合而成，随时可以增加一段新的空间并链接起来，即不会发生如<code>vector</code>那样的空间重新配置机制</li>
<li>虽然<code>deque</code>也提供<code>RandomAccessIterator</code>，但它的迭代器并不是普通指针，其复杂度和<code>vector</code>不可同道里计，因此除非必要我们应该尽量选择<code>vector</code>而不是<code>deque</code>。</li>
<li>在对<code>deque</code>进行排序操作，为了最高效率，可将<code>deque</code>先完整复制到一个<code>vector</code>身上，将<code>vector</code>排序后再复制会<code>deque</code></li>
</ul>
<h6 id="deque的中控器">4.3.1 deque的中控器</h6>
<p><code>deque</code>是逻辑上是连续空间。<code>deque</code>系由一段一段的定量空间组成，一旦必要在<code>deque</code>的前端或尾增加空间，便配置一段定量连续空间，串接在整个<code>deque</code>的头端或尾端。因此对于<code>deque</code>容器来说必须维护其整体连续的假象，并提供随机存取接口，那么必须有中央控制器和复杂的迭代架构去实现。</p>
<p><strong><code>Deque</code>采取一块所谓的<code>map</code>(注意，不是STL的map容器)作为主控，这里所谓的<code>map</code>是一小块连续的内存空间，其中每一个元素(此处成为一个结点<code>node</code>)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是<code>deque</code>的存储空间的主体。</strong><code>SGI STL</code>允许我们指定缓冲区大小，默认使用<code>512bytes</code>(<code>map</code>其实就是二重指针<code>T**</code>) <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dequemap.png" width="500"></p>
<h6 id="deque的迭代器">4.3.2 deque的迭代器</h6>
<p>对于<code>deque</code>，维持其整体连续的假象，落在了迭代器的<code>operator++</code>和<code>operator--</code>两个重载运算符上。</p>
<ul>
<li>该迭代器必须能够指出分段连续空间在哪里</li>
<li>其次他必须能够判断自己是否已经处在其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃到下一个或上一个缓冲区。</li>
</ul>
<p>因此为了能够正确跳跃，<code>deque</code>必须随时掌握管控中心<code>map</code>。如下的实现方式可行: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>,<span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span>&#123; <span class="comment">//为继承 std::iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;,T*,Bufsize&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*,Bufsize&gt; const_iterator;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> __deque_buf_size(Bufsize,<span class="built_in">sizeof</span>(T));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未继承std::iterator,所以必须自行撰写下述五个必要的迭代器相应型别</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref renference; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持与容器的联结</span></span><br><span class="line">    T* cur; <span class="comment">//此迭代器所指之缓冲区中的现行(current)元素</span></span><br><span class="line">    T* first; <span class="comment">//此迭代器所指之缓冲区中的头</span></span><br><span class="line">    T* last; <span class="comment">//此迭代器所指之缓冲区中的尾(含备用空间)</span></span><br><span class="line">    map_pointer node; <span class="comment">//指向管控中心</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n,<span class="type">size_t</span> sz)&#123;</span><br><span class="line">        <span class="keyword">return</span> n!=<span class="number">0</span>? n:(sz&lt;<span class="number">512</span>? <span class="built_in">size_t</span>(<span class="number">512</span>/sz):<span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    n!=0,返回n，表示buffer_size由	用户自定义</span></span><br><span class="line"><span class="comment">    n=0,表示buffer_size使用默认值，那么：</span></span><br><span class="line"><span class="comment">        sz&lt;512,传回512/sz;</span></span><br><span class="line"><span class="comment">        sz&gt;=512,传回1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dequeiterator.png" width="700"> 如上图，假设我们产生一个元素类型未<code>int</code>,缓冲区为8的<code>deque</code>，经过增删操作后拥有20个元素。<strong><code>deque</code>类内的<code>start</code>和<code>finish</code>分别指向<code>deque</code>的第一个缓冲区和最后一个缓冲区，20/8=3，所以map拥有3个节点，且最后一个缓冲区还有插入元素的空间。</strong>三个指针<code>cur、first、last</code>分别如图所示，`cur·指向缓冲区的最后一个元素的下一个位置。</p>
<p>下面是deque几个重要操作： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span></span>&#123;</span><br><span class="line">	node=new_node;</span><br><span class="line">    first=*new_node;</span><br><span class="line">    last=first+<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">renference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> *cur;&#125;</span><br><span class="line"></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())*</span><br><span class="line">		(node-x.node<span class="number">-1</span>)+(cur-first)+(x.last-x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">    ++cur; <span class="comment">//切换下一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(cur==last)&#123; <span class="comment">//如果已达到所在缓冲区的尾端</span></span><br><span class="line">        <span class="built_in">set_node</span>(node+<span class="number">1</span>); <span class="comment">//利用set_node方法切换到下一个缓冲区</span></span><br><span class="line">        cur=first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>; <span class="comment">//调用operator++</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==first)&#123; <span class="comment">//如果达到缓冲区的头部</span></span><br><span class="line">        <span class="built_in">set_node</span>(node<span class="number">-1</span>); <span class="comment">//利用set_node方法切换到上一个缓冲区</span></span><br><span class="line">        cur=first;</span><br><span class="line">    &#125;</span><br><span class="line">    --cur;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>; <span class="comment">//调用operator--</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)&#123; <span class="comment">//实现随机存取、迭代器可以直接跳跃n个距离</span></span><br><span class="line">    difference_type offset=n+(cur-first);</span><br><span class="line">    <span class="keyword">if</span>(offset&gt;=<span class="number">0</span>&amp;&amp;offset&lt;<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) <span class="comment">//目标位置在统一缓冲区</span></span><br><span class="line">        cur+=n;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//目标位置不在统一缓冲区</span></span><br><span class="line">       		difference_type node_offset=offset&gt;<span class="number">0</span>?</span><br><span class="line">			offset/<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">				:-<span class="built_in">difference_type</span>((-offset<span class="number">-1</span>)/<span class="built_in">buffer_size</span>())<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">set_node</span>(node+node_offset); <span class="comment">//切换至正确的节点</span></span><br><span class="line">            cur=first+(offset-node_offset*<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()); <span class="comment">//切换至正确的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp+=n; <span class="comment">//调用operator+=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>+=-n;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp-=n; <span class="comment">//调用operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机存取第n个元素</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n)<span class="type">const</span> &#123;<span class="keyword">return</span> *(*<span class="keyword">this</span>+n);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> cur==x.cur;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> !(*<span class="keyword">this</span>==x);&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="built_in">return</span> (node==x.node)?(cur&lt;x.cur):(node&lt;x.node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="deque的数据结构">4.3.3 deque的数据结构</h6>
<p>deque除了维护<code>map</code>指针外，还必须维护<code>start、finish</code>两个迭代器，分别指向第一个缓冲区的第一个元素和最后一个缓冲区的额最后一个元素。此外，它当然也必须记住目前的map大小，因为一旦<code>map</code>所提供的节点不足，就必须重新配置更大的一块<code>map</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc,<span class="type">size_t</span> BufSiz=<span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;,T*,BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//元素的指针的指针</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start; <span class="comment">//表示第一个节点</span></span><br><span class="line">    iterator finish; <span class="comment">//表示最后一个节点</span></span><br><span class="line">    map_pointer map; <span class="comment">//指向map，map是块连续空间，其每个元素都是指针，指向一个节点</span></span><br><span class="line">    size_type map_size; <span class="comment">//map内有多个指针</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n)&#123;</span><br><span class="line">        <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">//调用operator[]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *start;&#125; <span class="comment">//调用operator*</span></span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        iterator temp=finish;</span><br><span class="line">        --temp; <span class="comment">//调用operator--</span></span><br><span class="line">        <span class="keyword">return</span> *temp; <span class="comment">//调用operator*</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> finish-start;&#125; <span class="comment">//调用operator-</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> finish==start;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="heap">4.5. heap</h5>
<p><code>heap</code>不属于STL的容器组件，但我们有必要认识它的实现思想，它是实现<code>priority queue</code>的助手。<code>priority queue</code>允许用户以任何次序将元素存入容器中，但是取出时一定时从优先权最高的元素开始取。而堆正有这样的特性，适合作为<code>priority queue</code>的底层机制。</p>
<p>对于heap的虽然讲解的时候用的是<strong>完全二叉树</strong>的形式来讲解，但只是为了更直观的表达而已，一般来说实现都是采用数组的形式来实现的，同时为了达到空间可增长，采用<code>vector+heap算法</code>来实现堆。</p>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/heapSort.gif" width="500"></p>
<h6 id="push_heap算法">4.5.1 push_heap算法</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意，此函式被调用时，新元素已置于底部容器的最尾端</span></span><br><span class="line">    __push_heap_aux(first, last, <span class="built_in">distance_type</span>(first),<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap_aux</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last, Distance*, T*)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>),<span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">    <span class="comment">// 以上系根据implicit representation heap的结构特性：新值必置于底部</span></span><br><span class="line">    <span class="comment">// 容器的最尾端，此即第一个洞号：(last-first)–1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 push_back()不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __push_heap(RandomAccessIterator first, Distance holeIndex,Distance topIndex, T value) </span><br><span class="line">&#123;</span><br><span class="line">    Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 找出父节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value) &#123;</span><br><span class="line">        <span class="comment">// 当尚未到达顶端，且父节点小于新值（于是不符合 heap 的次序特性）</span></span><br><span class="line">        <span class="comment">// 由于以㆖使用 operator&lt;，可知 STL heap 是一种 max-heap（大者为父）</span></span><br><span class="line">        *(first + holeIndex) = *(first + parent); <span class="comment">//令洞值为父值</span></span><br><span class="line">        holeIndex = parent; <span class="comment">// percolate up：调整洞号，向上提升至父节点</span></span><br><span class="line">        parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 新洞的父节点</span></span><br><span class="line">    &#125; <span class="comment">// 持续至顶端，或满足heap的次序特性为止</span></span><br><span class="line">    </span><br><span class="line">    *(first + holeIndex) = value; <span class="comment">//令洞值为新值，完成插入动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pop_heap算法">4.5.2 pop_heap算法</h6>
<p><strong><code>pop_heap</code>算法思路如下：</strong></p>
<ul>
<li>1.把根节点元素取出，把最后一个节点的元素取出</li>
<li>2.将原根节点元素放在vector的最后一个节点处</li>
<li>3.将原先的最后一个节点的元素放置到原根节点处作为新根节点</li>
<li>4.将新根节点逐个与子节点比较，直到其值比子节点都大时，结束算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __pop_heap_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap_aux(RandomAccessIterator first,RandomAccessIterator last, T*) </span><br><span class="line">&#123;</span><br><span class="line">    __pop_heap(first, last<span class="number">-1</span>, last<span class="number">-1</span>, <span class="built_in">T</span>(*(last<span class="number">-1</span>)),</span><br><span class="line">    <span class="built_in">distance_type</span>(first));</span><br><span class="line">    <span class="comment">// 以上，根据 implicit representation heap 的次序特性，pop操作的结果</span></span><br><span class="line">    <span class="comment">// 应为底部容器的第一个元素。因此，首先设定欲调整值为尾值，然后将首值调至</span></span><br><span class="line">    <span class="comment">// 尾节点（所以以上将迭代器 result设为 last-1）。然后重整 [first, last-1)，</span></span><br><span class="line">    <span class="comment">// 使之重新成一个合格的 heap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 pop_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap(RandomAccessIterator first,</span><br><span class="line">        RandomAccessIterator last,</span><br><span class="line">        RandomAccessIterator result,</span><br><span class="line">        T value, Distance*) </span><br><span class="line">&#123;</span><br><span class="line">    *result = *first; <span class="comment">// 设定尾值为首值，于是尾值即为欲求结果，</span></span><br><span class="line">                      <span class="comment">// 可由客端稍后再以底层容器之 pop_back() 取出尾值</span></span><br><span class="line"> </span><br><span class="line">    __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">    <span class="comment">// 以上欲重新调整 heap，洞号为 0（亦即树根处），欲调整值为 value（原尾值）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="sort_heap算法">4.5.3 sort_heap算法</h6>
<p>既然每次<code>pop_heap</code>可获得<code>heap</code>之中键值最大的元素，如果持续对整个<code>heap</code>做<code>pop_heap</code>动作，每次将操作范围从后向前缩减一个元素（因为pop_heap会把键值最大的元素放在底部容器的最尾端），当整个程序执行完毕，我们便有了一个递增序列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [first,last) 排列为一个heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 make_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first,RandomAccessIterator last, T*,Distance*) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//如果长度为0或1，不必重新排列</span></span><br><span class="line"> </span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    <span class="comment">// 找出第一个需要重排的子树头部，以parent标示出。由于任何叶节点都不需执行</span></span><br><span class="line">    <span class="comment">// perlocate down，所以有以下计算。parent命名不佳，名为holeIndex 更好</span></span><br><span class="line">    Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 重排以 parent 为首的子树。len是为了让__adjust_heap() 判断操作范围</span></span><br><span class="line">        __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 走完根节点，就结束。</span></span><br><span class="line">        parent--; <span class="comment">// （即将重排之子树的）头部向前一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="priority_queue">4.6 priority_queue</h5>
<p><code>priority_queue</code>是一个拥有权值观念的<code>queue</code>。其内部的元素不再像<code>queue</code>依照被存入的次序排列，而是按照元素的权值排列，权值最高者，排在最前面。缺省情况下<code>proority_queue</code>利用一个<code>max-heap</code>和<code>vector</code>为底部容器。<code>priority_queue</code>没有迭代器(<code>queue</code>和<code>stack</code>也没有) <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/priorityqueue.png" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;,</span><br><span class="line">    <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line">    Compare comp; <span class="comment">// 元素大小比较标准</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : c(), comp(x) &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以下用到的 make_heap(), push_heap(), pop_heap()都是泛型算法</span></span><br><span class="line">    <span class="comment">// 注意，任一个建构式都立刻于底层容器内产生一个 implicit representation heap</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; x)</span><br><span class="line">        : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(),comp); &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last)</span><br><span class="line">        : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        __STL_TRY &#123;</span><br><span class="line">            <span class="comment">// push_heap是泛型算法，先利用底层容器的 push_back() 将新元素推入末端，再重排heap</span></span><br><span class="line">            c.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); <span class="comment">//push_heap是泛型算法</span></span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        __STL_TRY &#123;</span><br><span class="line">            <span class="comment">//pop_heap 是泛型算法，从 heap 内取出一个元素。它并不是真正将元素</span></span><br><span class="line">            <span class="comment">//弹出，而是重排 heap，然后再以底层容器的 pop_back() 取得被弹出的元素</span></span><br><span class="line">            <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">            c.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="关联式容器">5. 关联式容器</h4>
<p>标准的STL关联式容器分为<code>set</code>集合和<code>map</code>映射表两大类。以及两大衍生体<code>multiset</code>和<code>multimap</code>。这些容器的底层机制均与<code>RB-tree</code>完成。红黑树是一个独立容器，但不对外界使用。同时<code>SGI STL</code>还提供了一个不在标准规则之外的管理容器<code>hash_table</code>，以及以<code>hash_table</code>为底层机制完成的<code>hash_set、hash_map、hash_multiset、hash_multimap</code>。</p>
<p>所谓关联式容器类似于关联式数据库：每笔数据都有一个键值和一个实值，当元素插入到关联式容器时会按照键值大小以某种规则将这个元素放置于合适的位置，因此对于关联式容器没有<code>push_back、push_front、pop_back、pop_front</code>这样的行为。</p>
<h5 id="rb-tree">5.1 RB-tree</h5>
<p>关于红黑树的的定义和一些平衡原理见<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构篇</a>，这里列举一些<code>SGI STL</code>的<code>RB-tree</code>源码。</p>
<h6 id="rb-tree结构体">5.1.1 RB-tree结构体</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">RB树的节点结构:</span><br><span class="line"><span class="comment">//由于红黑树的各种操作常需要上溯其父级节点，因此特别安排一个parent指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;     <span class="comment">// 红色为0</span></span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">  color_type color;     <span class="comment">// 节点颜色，红色或黑色</span></span><br><span class="line">  base_ptr parent;      <span class="comment">// 该指针指向其父节点</span></span><br><span class="line">  base_ptr left;        <span class="comment">// 指向左节点</span></span><br><span class="line">  base_ptr right;       <span class="comment">// 指向右节点</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	 <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left; <span class="comment">//一直向左走，找到最小值</span></span><br><span class="line">	 <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right; <span class="comment">//一直向右走，找到最大值</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node</span> : <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;   <span class="comment">//节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="rb-tree迭代器">5.1.2 RB-tree迭代器</h6>
<p><code>RB-tree</code>的迭代器属于双向迭代器，但不具备随机定位的能力，与<code>list</code>较为相似，比较特殊的是他具有前进和后退的操作。<code>RB-tree</code>迭代器的<code>operator++</code>是调用了基层迭代器的<code>increment()</code>函数，其<code>operator--</code>调用<code>decrement()</code>函数。 <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/rbtreeiterator.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基层迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_tree_base_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	base_ptr node; <span class="comment">//用来与容器之间产生一个连接的关系</span></span><br><span class="line">	<span class="comment">//实现operator++</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(node-&gt;right != <span class="number">0</span>)&#123;</span><br><span class="line">	        <span class="comment">//状况1：右子结点存在，则当前可以看成是根节点,则找出右子树的最左结点</span></span><br><span class="line">	        node = node-&gt;right;</span><br><span class="line">	        <span class="keyword">while</span>(node-&gt;left != <span class="number">0</span>)</span><br><span class="line">	            node = node-&gt;left;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">	        <span class="comment">//状况2：没有右子节点,找出父节点</span></span><br><span class="line">			<span class="comment">//如果现行节点本身是个右子节点，就一直上溯，直到不为右子节点为止</span></span><br><span class="line">	        base_ptr y = node-&gt;parent;</span><br><span class="line">	        <span class="keyword">while</span>(y-&gt;right == node)&#123;</span><br><span class="line">	            node = y;</span><br><span class="line">	            y = y-&gt;parent;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">if</span>(node-&gt;right != y)</span><br><span class="line">	            <span class="comment">//状况3：如果当前的node不是根节点，则y即为所求</span></span><br><span class="line">	            node = y;</span><br><span class="line">	        <span class="comment">//状况4：如果当前的node是根节点，则node为所求</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//实现--</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(node-&gt;color == rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)</span><br><span class="line">	        <span class="comment">//状况1：如果当前结点是header结点，那么其前驱应该是mostright结点，也就是其右子结点</span></span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//状况2：也就是当前是根节点，那么其前驱应该是左子树中最右结点</span></span><br><span class="line">                base_ptr y = node-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(y-&gt;right != <span class="number">0</span>)</span><br><span class="line">                    y = y-&gt;right;</span><br><span class="line">                node = y;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//状况3：如果当前不是根节点，也没有左子节点，那么当前处于右子树的最左结点，要去找根节点</span></span><br><span class="line">                base_ptr y = node-&gt;parent;</span><br><span class="line">                <span class="keyword">while</span>(y-&gt;left == node)</span><br><span class="line">				&#123;</span><br><span class="line">                    node = y;</span><br><span class="line">                    y = y-&gt;parent;</span><br><span class="line">                &#125;</span><br><span class="line">                node = y;</span><br><span class="line">                <span class="comment">//如果当前处于root结点，y则为header结点，那么当前必定只有root一个结点</span></span><br><span class="line">                <span class="comment">//则可以得到node = header，y = root</span></span><br><span class="line">                <span class="comment">//最终得到node = y，不需要特殊处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正规迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value,<span class="keyword">typename</span> Ref,<span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_tree_iterator</span>:<span class="keyword">public</span> rb_tree_base_iterator&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,Value&amp;,Value*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,<span class="type">const</span> Value&amp;,<span class="type">const</span> Vallue*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,Ref,Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>(link_type x)&#123;node = x&#125;;</span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>(<span class="type">const</span> iterator&amp; it)&#123;node = it.node&#125;;</span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">link_type</span>(node)-&gt;value_field;</span><br><span class="line">	&#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">	    <span class="built_in">increment</span>();</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    <span class="built_in">increment</span>();</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	    <span class="built_in">decrement</span>();</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    <span class="built_in">decrement</span>();</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="rb-tree的数据结构">5.1.3 RB-tree的数据结构</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------------rb_tree类---------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node,Alloc&gt;rb_tree_node_allocator;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//没有迭代器iterator?不！会在后面声明</span></span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">link_type <span class="title">get_node</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">allocate</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span></span>&#123;<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">deallocate</span>(p);&#125;</span><br><span class="line">    <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        link_type tmp = <span class="built_in">get_node</span>(); <span class="comment">//配置空间</span></span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            Chy::allocator&lt;Key&gt;::<span class="built_in">construct</span>(&amp;tmp-&gt;value_field,x);<span class="comment">//构造内容</span></span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(<span class="built_in">put_node</span>(tmp));</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span></span>&#123;<span class="comment">//复制一个节点的颜色和数值</span></span><br><span class="line">        link_type tmp = <span class="built_in">create_node</span>(x-&gt;value_field);</span><br><span class="line">        tmp-&gt;color = x-&gt;color;</span><br><span class="line">        tmp-&gt;left = <span class="number">0</span>;</span><br><span class="line">        tmp-&gt;right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span></span>&#123;</span><br><span class="line">        Chy::allocator&lt;Key&gt;::<span class="built_in">destroy</span>(&amp;p-&gt;value_field); <span class="comment">//析构内容</span></span><br><span class="line">        <span class="built_in">put_node</span>(p); <span class="comment">//释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//RB-tree只使用三笔数据表现</span></span><br><span class="line">    size_type node_count; <span class="comment">//追踪记录树的大小 (节点的数量)</span></span><br><span class="line">    link_type header;     <span class="comment">//实现上的小技巧</span></span><br><span class="line">    Compare key_compare;  <span class="comment">//节点之间的键值大小的比较准则. 应该会是一个function object</span></span><br><span class="line">    <span class="comment">//以下三个函数用于方便获取header的成员</span></span><br><span class="line">    <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;parent;&#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">left_most</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;left;&#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">right_most</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;right;&#125;</span><br><span class="line">    <span class="comment">//以下六个函数用于方便获得节点x的成员</span></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;left;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;right;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;parent;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span> x-&gt;value_field;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x));&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span></span>&#123;<span class="keyword">return</span> (color_type&amp;) (x-&gt;color);&#125;</span><br><span class="line">    <span class="comment">//获取极大值和极小值 node class有实现此功能</span></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type,reference,pointer&gt;iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    iterator __insert(base_ptr x,base_ptr y,<span class="type">const</span> value_type&amp; v);</span><br><span class="line">    link_type __copy(link_type x,link_type p);</span><br><span class="line">    <span class="type">void</span> __erase(link_type x);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">            __erase(<span class="built_in">root</span>());</span><br><span class="line">            <span class="built_in">left_most</span>() = header;</span><br><span class="line">            <span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">right_most</span>() = header;</span><br><span class="line">            node_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        header = <span class="built_in">get_node</span>(); <span class="comment">//产生一个节点空间 令header指向它</span></span><br><span class="line">        <span class="built_in">color</span>(header) = __rb_tree_red;<span class="comment">//令header为红色 用于区分header和root,在iterator的operator++中</span></span><br><span class="line">        <span class="built_in">root</span>() == <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">left_most</span>() = header;   <span class="comment">//令header的左子节点等于自己</span></span><br><span class="line">        <span class="built_in">right_most</span>() = header;  <span class="comment">//令header的右子节点等于自己</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//allocation / deallocation</span></span><br><span class="line">    <span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">            : <span class="built_in">node_count</span>(<span class="number">0</span>),<span class="built_in">key_compare</span>(comp)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">rb_tree</span>()&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">put_node</span>(header);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp;<span class="keyword">operator</span>==(<span class="type">const</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp;x);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> key_compare;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">left_most</span>();&#125; <span class="comment">//RB树的起头为最左(最小)节点处</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> header;&#125; <span class="comment">//RB树的终点为header所指处</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> node_count == <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> node_count;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span> (<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//insert/erase</span></span><br><span class="line">    <span class="comment">//将x插入到RB-Tree中 (保持节点的独一无二)</span></span><br><span class="line">    <span class="function">std::pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//将x插入到RB-Tree中 (允许节点数值重复)</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//寻找键值为k的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> value_type&amp; k)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------rb_tree类主要函数的实现--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新的数值 节点键值允许重复</span></span><br><span class="line"><span class="comment">//注意：返回的是一个RB-Tree的迭代器，指向的是新增的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//根节点开始</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;        <span class="comment">//根节点开始 从上往下寻找适当的插入节点</span></span><br><span class="line">        y = x;</span><br><span class="line">        <span class="comment">//如果当前根节点比 输入的v大，则转向左边，否则转向右边</span></span><br><span class="line">        x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x为新值插入点 y为插入点的父节点 v为新值</span></span><br><span class="line">    <span class="keyword">return</span> __insert(x,y,v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入新的数值 节点键值不允许重复</span></span><br><span class="line"><span class="comment">//注意：返回结果是pair类型，第一个元素是一个RB-Tree的迭代器，指向的是新增的节点；第二个参数表示插入成功与否</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">std::pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator,<span class="type">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//从根节点开始</span></span><br><span class="line">    <span class="type">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123; <span class="comment">//从根节点开始 往下寻找适当的插入点</span></span><br><span class="line">        y = x;</span><br><span class="line">        comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)); <span class="comment">//v键值小于目前节点的键值</span></span><br><span class="line">        x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x); <span class="comment">//遇&quot;大&quot;则向左 遇&quot;小&quot;则向右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离开while循环之后 y所指的即 插入点之父节点（此时它必为叶子结点）</span></span><br><span class="line">    iterator j = <span class="built_in">iterator</span>(y); <span class="comment">//迭代器j指向插入点的父节点y</span></span><br><span class="line">    <span class="keyword">if</span> (comp)&#123;</span><br><span class="line">        <span class="comment">//如果while循环时候，判定comp的数值，如果comp为真(表示遇到大的元素，将插入左侧)</span></span><br><span class="line">        <span class="comment">//如果插入节点的父节点是最左侧的节点</span></span><br><span class="line">        <span class="comment">//x为插入点，y为插入节点的父节点，v表示新值</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">begin</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(__insert(x,y,v), <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//插入节点的父节点不是最左侧的节点</span></span><br><span class="line">            <span class="comment">//调整j 回头准备测试</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node),<span class="built_in">KeyOfValue</span>()(v)))&#123;</span><br><span class="line">            <span class="comment">//小于新值（表示遇到小的数值，将插在右侧）</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(__insert(x,y,v), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此 表示新值一定和树中的键值重复 就不应该插入新的数值</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//真正的插入执行程序 __insert()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::__insert(base_ptr x_, base_ptr y_, <span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    <span class="comment">//参数x_为新的插入点 参数y_为插入点的父节点 参数v为新值</span></span><br><span class="line">    link_type x = (link_type)x_;</span><br><span class="line">    link_type y = (link_type)y_;</span><br><span class="line">    link_type z ;</span><br><span class="line">    <span class="comment">//key_compare 是键值大小的比较准则，应该是一个function object</span></span><br><span class="line">    <span class="keyword">if</span> (y == header||x != <span class="number">0</span>||<span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v),<span class="built_in">key</span>(x)))&#123;</span><br><span class="line">        z = <span class="built_in">create_node</span>(v); <span class="comment">//产生一个新的节点</span></span><br><span class="line">        <span class="comment">//当y即为header的时候，leftmost = z;</span></span><br><span class="line">        <span class="keyword">if</span> (y == header)&#123;</span><br><span class="line">            <span class="built_in">root</span>() = z;</span><br><span class="line">            <span class="built_in">right_most</span>() = z;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">left_most</span>())&#123;</span><br><span class="line">            <span class="comment">//y为最左节点</span></span><br><span class="line">            <span class="comment">//维护leftmost() 使其永远指向最左节点</span></span><br><span class="line">            <span class="built_in">left_most</span>() = z;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            z = <span class="built_in">create_node</span>(v);<span class="comment">//产生一个新的节点</span></span><br><span class="line">            <span class="comment">//让新节成为插入点的父节点y的右子节点</span></span><br><span class="line">            <span class="built_in">right</span>(y) = z;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="built_in">right_most</span>())&#123; <span class="comment">//维护rightmost()让其永远指向最右的节点</span></span><br><span class="line">                <span class="built_in">right_most</span>() = z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">parent</span>(z) = y; <span class="comment">//设定新节点的父节点</span></span><br><span class="line">        <span class="built_in">left</span>(z) = <span class="number">0</span>; <span class="comment">//设定新节点的左子节点</span></span><br><span class="line">        <span class="built_in">right</span>(z) = <span class="number">0</span>; <span class="comment">//设定新节点的右子节点</span></span><br><span class="line">        <span class="comment">//修改颜色</span></span><br><span class="line">        <span class="comment">//参数一为新增节点 ；参数二 为root</span></span><br><span class="line">        __rb_tree_rebalance(z,header-&gt;parent);</span><br><span class="line">        ++node_count;</span><br><span class="line">        <span class="comment">//返回一个迭代器 指向新的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必须为红色，如果插入出父节点同样为红色，就需要进行树形旋转</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_rotate_left(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    <span class="comment">//x为旋转点</span></span><br><span class="line">    __rb_tree_node_base* y = x-&gt;right;<span class="comment">//令y为旋转点的右子节点</span></span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//回马枪设定父亲节点</span></span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="comment">//令y完全替代x的地位 (需要将x对其父节点的关系完全接收回来)</span></span><br><span class="line">    <span class="keyword">if</span> (x == root)&#123;</span><br><span class="line">        root = y; <span class="comment">//x为根节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;  <span class="comment">//x为其父节点的左子节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y; <span class="comment">//x为其父节点的右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必须为红色，如果插入出父节点同样为红色，就需要进行树形旋转</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_rotate_right(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    <span class="comment">//x为旋转点</span></span><br><span class="line">    __rb_tree_node_base* y = x-&gt;left; <span class="comment">//y为旋转点的左子节点</span></span><br><span class="line">    x-&gt;left = y-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;right != <span class="number">0</span>)&#123;</span><br><span class="line">        y-&gt;right-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="comment">//令y完全替代x的地位</span></span><br><span class="line">    <span class="keyword">if</span>(x == root)&#123;</span><br><span class="line">        root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//调整RB_tree 插入节点之后，需要进行调整(颜色/翻转)从而满足要求</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_balance(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    x-&gt;color = __rb_tree_red; <span class="comment">//新节点的颜色必须是红色的</span></span><br><span class="line">    <span class="keyword">while</span>(x!=root &amp;&amp; x-&gt;parent-&gt;color == __rb_tree_red)&#123;</span><br><span class="line">        <span class="comment">//父节点为红色的</span></span><br><span class="line">        <span class="comment">//父节点为祖父节点的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left)&#123;</span><br><span class="line">            <span class="comment">//令y为伯父节点</span></span><br><span class="line">            __rb_tree_node_base* y = x-&gt;parent-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)&#123; <span class="comment">//伯父节点存在 且为红</span></span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//更改父节点的颜色为黑</span></span><br><span class="line">                y-&gt;color = __rb_tree_black;<span class="comment">//更改父节点的颜色为黑</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//更改祖父节点的颜色为红</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无伯父节点 或者伯父节点的颜色为黑</span></span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)&#123;</span><br><span class="line">                    <span class="comment">//新节点为父节点的右子节点</span></span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    <span class="comment">//第一次参数为左旋节点</span></span><br><span class="line">                    __rb_tree_rotate_left(x,root);</span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                <span class="comment">//第一次参数为右旋节点</span></span><br><span class="line">                __rb_tree_rotate_right(x-&gt;parent-&gt;parent,root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//父节点为祖父节点的右子节点</span></span><br><span class="line">            __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left; <span class="comment">//令y为伯父节点</span></span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)&#123; <span class="comment">//存在伯父节点，且为红</span></span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//更改父节点为黑</span></span><br><span class="line">                y-&gt;color = __rb_tree_black;<span class="comment">//更改伯父节点为黑</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; <span class="comment">//更改祖父节点为红</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent; <span class="comment">//准备继续往上层检查</span></span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无伯父节点 或者伯父节点 为黑</span></span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">                    <span class="comment">//新节点 为 父节点的左子节点</span></span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    __rb_tree_rotate_right(x,root); <span class="comment">//第一参数为右旋转点</span></span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                <span class="comment">//第一参数为左旋点</span></span><br><span class="line">                __rb_tree_rotate_left(x-&gt;parent-&gt;parent,root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//while结束</span></span><br><span class="line">    root-&gt;color = __rb_tree_black;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//元素查找程序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">find</span>(<span class="type">const</span> value_type &amp;k) &#123;</span><br><span class="line">    link_type y = header; <span class="comment">//last node which is  not less than k</span></span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//current node</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//key_compare 是节点大小的比较准则 function object</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x),k))&#123;</span><br><span class="line">            <span class="comment">//进行到这里 表示x的数值大于k 。遇到大的数值向左走</span></span><br><span class="line">            y = x,x = <span class="built_in">left</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator j = <span class="built_in">iterator</span> (y);</span><br><span class="line">    <span class="keyword">return</span> (j == <span class="built_in">end</span>() || <span class="built_in">key_compare</span>(k,<span class="built_in">key</span>(j.node))) ? <span class="built_in">end</span>() : j;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/************************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//注意：以下的identify定义于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">identify</span> : <span class="keyword">public</span> std::unary_function&lt;T,T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="set">5.2 set</h5>
<ul>
<li><code>set</code>的特性是 所有的元素会按照键值自动排序</li>
<li><code>set</code>的键值等同于实值</li>
<li><strong><code>set</code>不允许涵盖两个相同的键值</strong></li>
<li><strong>不可以通过迭代器修改<code>set</code>的元素数值，这会破坏元素的排列顺序。因此<code>set&lt;T&gt;::iterator</code>被定义为底层<code>RB-tree</code>的<code>const_iterator</code>,杜绝写入。也就是<code>set</code>的<code>iterators</code>是一种<code>const iterators</code></strong></li>
<li><code>set</code>类似<code>list</code>，当客户端对其进行元素的新增或者删除操作的时候，<strong>操作之前的迭代器不会失效，但是被操作的迭代器会失效</strong></li>
<li>STL提供了一组<code>set/multiset</code>的相关算法，包括交集<code>set_intersection</code><code>set_union</code><code>set_difference</code><code>set_symmetric_difference</code></li>
<li><code>set</code>利用<code>RB-tree</code>的排序机制，因此是基于红黑树进一步的函数封装</li>
</ul>
<h6 id="set源码">5.2.1 set源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> set&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">    <span class="comment">//注意key_compare 和 value_compre 使用同一个比较函数</span></span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,identify&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">    rep_type t; <span class="comment">//使用红黑树(RB-Tree)实现set</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">    <span class="comment">//set迭代器无法执行写入操作，因为set的元素有一定的次序安排，不允许用户在任意处进行写入操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_uterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    <span class="comment">//allocation/deallocation</span></span><br><span class="line">    <span class="comment">//set使用RB-Tree的insert_unique() 要求插入的元素都不可以重复</span></span><br><span class="line">    <span class="comment">//multiset 使用 insert_equal() 允许相同键值的存在</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">set</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(InputIterator first,InputIterator last)</span> : t(Compare())&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">set</span>(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x):<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">    set&lt;Key,Compare,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">        t = x.t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//set进行函数的包装</span></span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="comment">//需要注意 set使用的value_comp 事实上为RB-Tree的key_comp()</span></span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(set&lt;Key,Compare,Alloc&gt;&amp; x)</span></span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//insert / erase</span></span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;iterator,<span class="type">bool</span>&gt;pair_iterator_bool;</span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">        std::pair&lt;<span class="keyword">typename</span> rep_type::iterator,<span class="type">bool</span>&gt; p = t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(p.first,p.second);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position,<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>((rep_iterator&amp;)position,x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first,InputIterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        t.<span class="built_in">erase</span>((rep_iterator&amp;)position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        t.<span class="built_in">erase</span>((rep_iterator&amp;)first,(rep_iterator&amp;)last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set operations</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">count</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    std::pair&lt;iterator,iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下的__STL_NULL_TMPL_ARGS 被定义为&lt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;,<span class="type">const</span> set&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;,<span class="type">const</span> set&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="map">5.3 map</h5>
<ul>
<li>所有元素会根据元素的键值自动被排序</li>
<li>元素的类型是<code>pair</code>，同时拥有键值和实值；<code>map</code>不允许两个元素出现相同的键值</li>
<li>不可以修改<code>map</code>的键值 但是可以修改实值</li>
<li><code>map</code>基于红黑树实现对应的函数</li>
<li><code>map</code>和<code>set</code>一样，操作和删除操作时，操作之前的迭代器在操作之后依然有效</li>
</ul>
<h6 id="pair类型的定义">5.3.1 pair类型的定义</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    T1 first;    <span class="comment">//public</span></span><br><span class="line">    T2 second;  <span class="comment">//public</span></span><br><span class="line">    <span class="built_in">pair</span>():<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a,<span class="type">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="map源码">5.3.2 map源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> map&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;<span class="comment">//键值型别</span></span><br><span class="line">    <span class="keyword">typedef</span> T data_type;<span class="comment">//数据(实值)型别</span></span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;<span class="type">const</span> Key,T&gt;value_type; <span class="comment">//元素型别(键值/实值)</span></span><br><span class="line">    <span class="comment">//键值比较函数</span></span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="comment">//以下定义一个functor 其作用就是调用&quot;元素比较函数&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">value_compare</span> : <span class="keyword">public</span> std::binary_function&lt;value_type,value_type,<span class="type">bool</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>&lt;Key,T,Compare,Alloc&gt;;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Compare comp;</span><br><span class="line">        <span class="built_in">value_compare</span>(Compare c):<span class="built_in">comp</span>(c)&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> value_type&amp; x,<span class="type">const</span> value_type&amp; y)</span><span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">comp</span>(x.first,y.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//定义表述型别 使用map元素的型别(pair)作为第一性别，作为红黑树节点的键值型别</span></span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,_Select1st&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">    rep_type t; <span class="comment">//使用红黑树(RB-Tree)实现map</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">    <span class="comment">//map迭代器无法执行写入操作，因为map的元素有一定的次序安排，不允许用户在任意处进行写入操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reverse_iterator reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    <span class="comment">//allocation/deallocation</span></span><br><span class="line">    <span class="comment">//map使用RB-Tree的insert_unique() 要求插入的元素都不可以重复</span></span><br><span class="line">    <span class="comment">//multimap 使用 insert_equal() 允许相同键值的存在</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">map</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">map</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">map</span><span class="params">(InputIterator first,InputIterator last)</span> : t(Compare())&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">map</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">map</span>(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x):<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">    map&lt;Key,Compare,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">        t = x.t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//map进行函数的包装</span></span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="comment">//需要注意 map使用的value_comp 事实上为RB-Tree的key_comp()</span></span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">value_compare</span>(t.<span class="built_in">key_comp</span>());&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span>  </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">    <span class="comment">//注意以下 下标操作符号</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k)&#123;</span><br><span class="line">        <span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k,<span class="built_in">T</span>()))).first)).second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(map&lt;Key,Compare,Alloc&gt;&amp; x)</span></span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//insert / erase</span></span><br><span class="line"><span class="comment">//    typedef std::pair&lt;iterator,bool&gt;pair_iterator_bool;</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position,<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(position,x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first,InputIterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map operations</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">count</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    std::pair&lt;iterator,iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;const_iterator,const_iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//以下的__STL_NULL_TMPL_ARGS 被定义为&lt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> map&amp;,<span class="type">const</span> map&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> map&amp;,<span class="type">const</span> map&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="multisetmap">5.3.3 multiset/map</h6>
<p><code>muiltiset\multimap</code>和它们对应的<code>set\map</code>特性完全相同，唯一不同点时<code>multi</code>允许键值重复，因此插入采用的时<code>RB-tree</code>的底层函数的<code>insert_equal()</code>而不是<code>insert_unique()</code>。</p>
<h5 id="hashtable">5.4 hashtable</h5>
<p>上面介绍的是以<code>RB-tree</code>为底层机制的容器，其在有序性和查找的性能(<code>logn</code>)上都不错。但还有一种在查找上的时间复杂度可在常数内完成的结构，那就是哈希表即：</p>
<ul>
<li>二叉搜索树具有对数平均时间的表现，<strong>但是这个需要满足的假设前提是输入的数据需要具备随机性</strong></li>
<li><code>hashtable</code>散列表这种结构在插入、删除、搜寻等操作层面上也具有常数平均时间的表现。<strong>而且不需要依赖元素的随机性，这种表现是以统计为基础的</strong></li>
</ul>
<p><strong>哈希表的特点：</strong></p>
<ul>
<li><code>hashtable</code>可提供对任何有名项的存取和删除操作</li>
<li>因为操作的对象是有名项，因此<code>hashtable</code>可以作为一种字典结构</li>
<li><strong>将一个元素映射成为一个 “大小可以接受的索引”简称为<code>hash function</code>散列函数</strong></li>
<li>考虑到元素的个数大于<code>array</code>的容量，<strong>可能有不同的元素被映射到相同的位置，简称为冲突</strong></li>
<li>解决冲突的方法有很多，线性探测、二次探测、<strong>开链</strong></li>
</ul>
<p>具体的hash思想可见<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构篇</a>，在<code>SGI STL</code>版本的<code>hash_table</code>使用的是<strong>开链法</strong>来解决哈希冲突,节点结构体如下： <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/hashtablelist.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_node</span>&#123;</span><br><span class="line">    __hashtable_node* next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="hashtable的迭代器">5.4.1 hashtable的迭代器</h6>
<ul>
<li><code>hashable</code>迭代器维持着与整个<code>buckets vector</code>的关系，并记录目前所指的节点</li>
<li>前进操作是从目前节点出发前进一个位置，由于节点被安置于<code>list</code>内，使用<code>next</code>进行前进操作</li>
<li><strong>如果目前是<code>list</code>的尾端，则跳转至下一个<code>bucket</code>上，正是指向下一个<code>list</code>的头部</strong></li>
<li><strong><code>hashtable</code>的迭代器没有后退操作，<code>hashtable</code>没有定义所谓的逆向迭代器</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">ExtractKey</span>,<span class="keyword">class</span> <span class="title class_">EqualKey</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_iterator</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;hashtable;</span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_iterator&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;iterator;</span><br><span class="line"><span class="comment">//    typedef __hash_const   静态迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt;node;</span><br><span class="line">    <span class="keyword">typedef</span> std::forward_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> Value* pointer;</span><br><span class="line"></span><br><span class="line">    node* cur;<span class="comment">// 迭代器目前所指的节点</span></span><br><span class="line">    hashtable* ht;<span class="comment">//保持对容器的连接关系 (因为可能需要从bucket跳到bucket)</span></span><br><span class="line">    __hashtable_iterator(node*n,hashtable* tab):<span class="built_in">cur</span>(n),<span class="built_in">ht</span>(tab)&#123;&#125;</span><br><span class="line">    __hashtable_iterator()&#123;&#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> cur-&gt;val;&#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line">    iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; it)<span class="type">const</span> &#123;<span class="keyword">return</span> cur == it.cur;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; it)<span class="type">const</span> &#123;<span class="keyword">return</span> cur != it.cur;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">HF</span>,<span class="keyword">class</span> <span class="title class_">ExK</span>,<span class="keyword">class</span> <span class="title class_">EqK</span>,<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;&amp;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="type">const</span> node* old = cur;</span><br><span class="line">    cur = cur-&gt;next; <span class="comment">//如果存在 就是他，否则进入以下的if流程</span></span><br><span class="line">    <span class="keyword">if</span> (!cur)&#123;</span><br><span class="line">        <span class="comment">//根据元素的数值，定位出下一个bucket，其起头处就是我们的目的地</span></span><br><span class="line">        size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cur = ht-&gt;buckets[bucket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">HF</span>,<span class="keyword">class</span> <span class="title class_">ExK</span>,<span class="keyword">class</span> <span class="title class_">EqK</span>,<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++<span class="keyword">this</span>; <span class="comment">//调用operator++</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="hashtable的数据结构">5.4.2 hashtable的数据结构</h6>
<ul>
<li><code>buckets</code>聚合体以<code>vector</code>完成，以利动态扩充</li>
<li><strong><code>&lt;stl_hash_fun.h&gt;</code>定义数个现成的<code>hash functions</code>全都是仿函数，<code>hash function</code>计算单元的位置，也就是元素对应的<code>bucket</code>的位置。具体调用的函数是<code>bkt_num()</code>,它调用<code>hash function</code>取得一个可以执行<code>modulus</code>(取模)运算的数值</strong>，以上的目的是出于 有些元素的型别是无法直接对其进行取模运算的，比如字符串类型 。</li>
<li>按照质数设计<code>vector</code>的大小，事先准备好<code>28</code>个质数，并设计一个函数用于查询最接近某数并大于某数的质数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Key:         节点的实值类型</span></span><br><span class="line"><span class="comment"> * Value:       节点的键值类型</span></span><br><span class="line"><span class="comment"> * HashFun:     hash function的函数型别</span></span><br><span class="line"><span class="comment"> * ExtractKey:  从节点中提取键值的方法 (函数或者仿函数)</span></span><br><span class="line"><span class="comment"> * EqualKey:    判断键值是否相同 (函数或者仿函数)</span></span><br><span class="line"><span class="comment"> * Alloc:       空间配置器 缺省使用 std::alloc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">ExtractKey</span>,<span class="keyword">class</span> <span class="title class_">EqualKey</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> HashFcn hasher;    <span class="comment">//为template型别参数重新定义一个名称</span></span><br><span class="line">    <span class="keyword">typedef</span> EqualKey key_equal;<span class="comment">//为template型别参数重新定义一个名称</span></span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//以下三者都是function objects</span></span><br><span class="line">    <span class="comment">//&lt;stl_hash_fun.h&gt; 定义有数个标准型别(如 int、c-style、string等)的hasher</span></span><br><span class="line">    hasher hash;        <span class="comment">//散列函数</span></span><br><span class="line">    key_equal equals;   <span class="comment">//判断键值是否相等</span></span><br><span class="line">    ExtractKey get_key; <span class="comment">//从节点取出键值</span></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt;node;</span><br><span class="line">    <span class="comment">//专属的节点配置器</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;node,Alloc&gt;node_allocator;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点的配置函数</span></span><br><span class="line">    <span class="function">node* <span class="title">new_node</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        node* n = node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">        n-&gt;next = <span class="number">0</span>;</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            Chy::allocator&lt;Key&gt;::<span class="built_in">construct</span>(&amp;n-&gt;val,obj);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(node_allocator::<span class="built_in">deallocate</span>(n);)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点释放函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delete_node</span><span class="params">(node* n)</span></span>&#123;</span><br><span class="line">        Chy::allocator&lt;Key&gt;::<span class="built_in">destroy</span>(n-&gt;val);</span><br><span class="line">        node_allocator::<span class="built_in">deallocate</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;node*,Alloc&gt;buckets;<span class="comment">//以vector完成桶的集合，其实值是一个node*</span></span><br><span class="line">    size_type num_elements;  <span class="comment">//node的个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bucket个数 即buckets vector的大小</span></span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buckets.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//注意假设 假设long至少有32bit</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">53</span>,         <span class="number">97</span>,         <span class="number">193</span>,       <span class="number">389</span>,       <span class="number">769</span>,</span><br><span class="line">        <span class="number">1543</span>,       <span class="number">3079</span>,       <span class="number">6151</span>,      <span class="number">12289</span>,     <span class="number">24593</span>,</span><br><span class="line">        <span class="number">49157</span>,      <span class="number">98317</span>,      <span class="number">196613</span>,    <span class="number">393241</span>,    <span class="number">786433</span>,</span><br><span class="line">        <span class="number">1572869</span>,    <span class="number">3145739</span>,    <span class="number">6291469</span>,   <span class="number">12582917</span>,  <span class="number">25165843</span>,</span><br><span class="line">        <span class="number">50331653</span>,   <span class="number">100663319</span>,  <span class="number">201326611</span>, <span class="number">402653189</span>, <span class="number">805306457</span>,</span><br><span class="line">        <span class="number">1610612741</span>, <span class="number">3221225473</span>, <span class="number">4294967291</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//找出上述28指数中，最接近并大于n的那个质数</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_next_prime(<span class="type">unsigned</span> <span class="type">long</span> n)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *first = __stl_prime_list;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *pos = std::<span class="built_in">lower_bound</span>(first,last,n);</span><br><span class="line">        <span class="comment">//使用lower_bound() 需要先进行排序</span></span><br><span class="line">        <span class="keyword">return</span> pos == last ? *(last<span class="number">-1</span>) : *pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//总共有多少个buckets。以下是hash_table的一个member function</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">//其数值将为 4294967291</span></span><br><span class="line">        <span class="keyword">return</span> __stl_prime_list[__stl_num_primes - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">hashtable</span>(size_type n,<span class="type">const</span> HashFcn&amp; hf,<span class="type">const</span> EqualKey&amp; eql)</span><br><span class="line">    :<span class="built_in">hash</span>(hf),<span class="built_in">equals</span>(eql),<span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()),<span class="built_in">num_elements</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//例子：传入50 返回53</span></span><br><span class="line">        <span class="comment">//然后保留53个元素的空间 然后将其全部填充为0</span></span><br><span class="line">        <span class="type">const</span> size_type n_buckets = <span class="built_in">next_size</span>(n);</span><br><span class="line">        buckets.<span class="built_in">reserve</span>(n_buckets);</span><br><span class="line">        <span class="comment">//设定所有的buckets的初值为0(node*)</span></span><br><span class="line">        buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">begin</span>(),n_buckets,(node*)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//------------------------------bkt_num函数---------------------------</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//版本1：接受实值（value）和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj), n); <span class="comment">//调用版本4</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本2：只接受实值（value）</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj)); <span class="comment">//调用版本3</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本3，只接受键值</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(key, buckets.<span class="built_in">size</span>()); <span class="comment">//调用版本4</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本4：接受键值和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % n; <span class="comment">//SGI的所有内建的hash()，在后面的hash functions中介绍</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//相关对应的函数</span></span><br><span class="line">    <span class="comment">//next_size()返回最接近n并大于n的质数</span></span><br><span class="line">    <span class="function">size_type <span class="title">next_size</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __stl_next_prime(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;iterator;</span><br><span class="line">    <span class="comment">//插入操作和表格重整</span></span><br><span class="line">    <span class="comment">//插入元素不允许重复</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type&amp; obj)&#123;</span><br><span class="line">        <span class="comment">//判断是否需要重建表格  如果需要就进行扩充</span></span><br><span class="line">        <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//函数判断是否需要重建表格 如果不需要立刻返回，如果需要 就重建表格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type num_elements_hint)</span></span>&#123;</span><br><span class="line">        <span class="comment">//表格重建与否的原则是：元素的个数(新增元素计入之后)和先前分配的bucket vector进行比较</span></span><br><span class="line">        <span class="comment">//如果前者的大于后者 就需要表格的重建</span></span><br><span class="line">        <span class="comment">//因此 bucket(list)的最大容量和buckets vector的大小相同</span></span><br><span class="line">        <span class="type">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (old_n &lt; num_elements_hint)&#123;</span><br><span class="line">            <span class="comment">//需要重新分配内存</span></span><br><span class="line">            <span class="comment">//计算下一个质数</span></span><br><span class="line">            <span class="type">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; old_n)&#123;</span><br><span class="line">                std::vector&lt;node*,Alloc&gt;<span class="built_in">tmp</span>(n,(node*)<span class="number">0</span>);</span><br><span class="line">                __STL_TRY&#123;</span><br><span class="line">                    <span class="comment">//处理每一个旧的bucket</span></span><br><span class="line">                    <span class="keyword">for</span> (size_type bucket=<span class="number">0</span>;bucket&lt;old_n;bucket++) &#123;</span><br><span class="line">                        <span class="comment">//指向节点所对应的的串行的起始节点</span></span><br><span class="line">                        node* first = buckets[bucket];</span><br><span class="line">                        <span class="comment">//处理每一个旧的bucket所含(串行)的每一个节点</span></span><br><span class="line">                        <span class="keyword">while</span>(first)&#123;</span><br><span class="line">                            <span class="comment">//串行节点还未结束</span></span><br><span class="line">                            <span class="comment">//找出节点落在哪一个新的bucket内部</span></span><br><span class="line">                            size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val,n);</span><br><span class="line">                            <span class="comment">//以下四个操作颇为巧妙</span></span><br><span class="line">                            <span class="comment">//(1)令旧bucket指向其所对应的串行的下一个节点(以便迭代处理)</span></span><br><span class="line">                            buckets[bucket] = first-&gt;next;</span><br><span class="line">                            <span class="comment">//(2)(3)将当前节点插入到新的bucket内部，成为其对应串行的第一个节点</span></span><br><span class="line">                            first-&gt;next = tmp[new_bucket];</span><br><span class="line">                            tmp[new_bucket] = first;</span><br><span class="line">                            <span class="comment">//(4)回到旧的bucket所指向的待处理的串行，准备处理下一个节点</span></span><br><span class="line">                            first = buckets[bucket];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//对调新旧两个buckets</span></span><br><span class="line">                    <span class="comment">//离开的时候会释放tmp的内存</span></span><br><span class="line">                    buckets.<span class="built_in">swap</span>(tmp);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要重建表格的情况下插入新的节点 键值不允许重复</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert_unique_noresize</span>(<span class="type">const</span> value_type&amp; obj)&#123;</span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj) ;<span class="comment">//决定obj应该位于 第n n bucket</span></span><br><span class="line">        node* first = buckets[n]; <span class="comment">//令first指向bucket对应的串行头部</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果Buckets[n]已经被占用 此时first不再是0 于是进入以下循环</span></span><br><span class="line">        <span class="comment">//走过bucket所对应的整个链表</span></span><br><span class="line">        <span class="keyword">for</span> (node* cur = first;cur;cur = cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val)),<span class="built_in">get_key</span>(obj))&#123;</span><br><span class="line">                <span class="comment">//如果发现和链表中的某个键值是相同的 就不插入 立刻返回</span></span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//离开上述循环(或者根本没有进入循环的时候)first指向bucket的所指链表的头部节点</span></span><br><span class="line">            node* tmp = <span class="built_in">new_node</span>(obj); <span class="comment">//产生新的节点</span></span><br><span class="line">            tmp-&gt;next = first;</span><br><span class="line">            buckets[n] = tmp; <span class="comment">//令新的节点成为链表的第一个节点</span></span><br><span class="line">            ++num_elements;   <span class="comment">//节点的个数累加</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(tmp,<span class="keyword">this</span>),<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//客户端执行的是另外一种节点的插入行为(不再是insert_unique 而是insert_equal)</span></span><br><span class="line">    <span class="comment">//插入元素 允许重复</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否需要重建表格 如果需要就进行扩充</span></span><br><span class="line">        <span class="built_in">resize</span>(num_elements+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要重建表格的情况下 插入新的节点，键值是允许重复的</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj); <span class="comment">//决定obj应该位于第 n bucket</span></span><br><span class="line">        node* first = buckets[n];<span class="comment">//令first指向的bucket对应的链表的头部</span></span><br><span class="line">        <span class="comment">//如果bucket[n]已经被占用，此时的first不为0，进入循环</span></span><br><span class="line">        <span class="comment">//遍历整个链表</span></span><br><span class="line">        <span class="keyword">for</span>(node* cur = first;cur;cur = cur-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val),<span class="built_in">get_key</span>(obj)))&#123;</span><br><span class="line">                <span class="comment">//如果发现与链表中的某个键值相同，就马上插入，然后返回</span></span><br><span class="line">                node* tmp = <span class="built_in">new_node</span>(obj);  <span class="comment">//产生新的节点</span></span><br><span class="line">                tmp-&gt;next = cur-&gt;next;<span class="comment">//新节点插入目前的位置</span></span><br><span class="line">                cur-&gt;next = tmp;</span><br><span class="line">                ++num_elements;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">iterator</span> (tmp, <span class="keyword">this</span>); <span class="comment">//返回一个迭代器 指向新增的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行到这个时候 表示没有发现重复的数值</span></span><br><span class="line">            node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">            tmp-&gt;next = first;</span><br><span class="line">            buckets[n] = tmp;</span><br><span class="line">            ++num_elements;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//针对每一个bucket</span></span><br><span class="line">        <span class="keyword">for</span>(size_type i = <span class="number">0</span>;i &lt; buckets.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            node * cur = buckets[i];</span><br><span class="line">            <span class="comment">//删除bucket list中的每一个节点</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="number">0</span>)&#123;</span><br><span class="line">                node* next = cur-&gt;next;</span><br><span class="line">                <span class="built_in">delete_node</span>(cur);</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            buckets[i] = <span class="number">0</span>; <span class="comment">//令buckets内容为null</span></span><br><span class="line">        &#125;</span><br><span class="line">        num_elements = <span class="number">0</span>; <span class="comment">//令总的节点的个数为0</span></span><br><span class="line">        <span class="comment">//需要注意 buckets vector并没有释放空间，仍然保存先前的大小</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy_from</span><span class="params">(<span class="type">const</span> hashtable&amp; ht)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先清除己方的buckets vector，此操作是调用vector::clear() 造成所有的元素都为0</span></span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">//为己方的buckets vector保留空间，使与对方相同</span></span><br><span class="line">        <span class="comment">//如果己方的空间大于对方 就不需要改变；如果己方的空间小于对方 就会增大</span></span><br><span class="line">        buckets.<span class="built_in">reserve</span>(ht.buckets.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//从己方的buckets vector尾端开始，插入n个元素，其数值为 null 指针</span></span><br><span class="line">        <span class="comment">//注意此时buckets vector为空，所谓的尾端就是起头处</span></span><br><span class="line">        buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(),ht.buckets.<span class="built_in">size</span>(),(node*)<span class="number">0</span>);</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            <span class="comment">//针对buckets vector</span></span><br><span class="line">            <span class="keyword">for</span> (size_type i = <span class="number">0</span>;i&lt;ht.buckets.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">                <span class="comment">//复制vector的每一个元素(是一个指针，指向hashtable节点)</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="type">const</span> node* cur = ht.buckets[i])&#123;</span><br><span class="line">                    node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">                    buckets[i] = copy;</span><br><span class="line">                    <span class="comment">//针对同一个 buckets list 复制每一个节点</span></span><br><span class="line">                    <span class="keyword">for</span> (node* next = cur-&gt;next;next ; cur = next,next = cur-&gt;next) &#123;</span><br><span class="line">                        copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">                        copy = copy-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新登录的节点的个数(hashtable的大小)</span></span><br><span class="line">            num_elements = ht.num_elements;</span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>STL中哈希表一般不要外部使用，它是实现<code>hash_map</code>和<code>hash_set</code>的底层机制，编程者可以使用它们。</p>
<h5 id="hash_set">5.5 hash_set</h5>
<p>同set一样，单独以键存储。<code>hash_set</code>是以<code>hashtable</code>为底层机制，因此存储数无序的，而<code>set</code>有序。同时其所供应的接口大部分都是转调用<code>hashtable</code>的函数。<code>hash_set</code>的使用方式与<code>set</code>差不多一样.</p>
<h6 id="hash_set源码">5.5.1 hash_set源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_INTERNAL_HASH_SET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SGI_STL_INTERNAL_HASH_SET_H</span></span><br><span class="line"></span><br><span class="line">__STL_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> set woff 1174</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Value&gt;,</span><br><span class="line">          <span class="keyword">class</span> EqualKey = equal_to&lt;Value&gt;,</span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> EqualKey, <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> hash_set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;Value, Value, HashFcn, identity&lt;Value&gt;, </span><br><span class="line">                    EqualKey, Alloc&gt; ht;</span><br><span class="line">  ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equal key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hash_set</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hash_set</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equal()) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_set&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_set&amp;,</span><br><span class="line">                                               <span class="type">const</span> hash_set&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique</span>(obj);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span> </span>&#123;</span><br><span class="line">    rep.<span class="built_in">insert_unique</span>(f,l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator f, const_iterator l)</span> </span>&#123;rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="hash_map">5.6 hash_map</h5>
<p>同map一样以键值对形式存储，但其底层机制为<code>hashtable</code>，因此大部分情况支持常数时间复杂度访问，存储是无序的。使用方式与<code>map</code>相差不大</p>
<h6 id="hash_map源码">5.6.1 hash_map源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> set woff 1174</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> EqualKey = equal_to&lt;Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> EqualKey, </span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> hash_map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;pair&lt;<span class="type">const</span> Key, T&gt;, Key, HashFcn,</span><br><span class="line">                    select1st&lt;pair&lt;<span class="type">const</span> Key, T&gt; &gt;, EqualKey, Alloc&gt; ht;</span><br><span class="line">  ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">  <span class="keyword">typedef</span> T data_type;</span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equal key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::iterator iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hash_map</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hash_map</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equal()) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_map&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span></span><br><span class="line">  <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_map&amp;, <span class="type">const</span> hash_map&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(obj); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span> </span>&#123;</span><br><span class="line">    rep.<span class="built_in">insert_unique</span>(f,l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator f, const_iterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique_noresize</span>(obj); &#125;    </span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; key) &#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">find_or_insert</span>(<span class="built_in">value_type</span>(key, <span class="built_in">T</span>())).second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line">  <span class="function">pair&lt;const_iterator, const_iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="各个容器的适用场景">6. 各个容器的适用场景</h4>
<ul>
<li>1）<code>vector</code>的使用场景：只查看，而不频繁插入删除的，因为频繁插入删除会造成内存的不断搬家和删除。使用场景比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录。</li>
<li>2）<code>deque</code>的使用场景：比如排队购票系统，对排队者的存储可以采用<code>deque</code>，支持头端的快速移除，尾端的快速添加。如果采用<code>vector</code>，则头端移除时会移动大量的数据，速度慢。<code>vector</code>与<code>deque</code>的比较：
<ul>
<li>一：<code>vector.at()</code>比<code>deque.at()</code>效率高，比如<code>vector.at(0)</code>是固定的，<code>deque</code>的开始位置却是不固定的。</li>
<li>二：如果有大量释放操作的话，<code>vector</code>花的时间更少，这跟二者的内部实现有关。</li>
<li>三：<code>deque</code>支持头部的快速插入与快速移除，这是<code>deque</code>的优点。</li>
</ul></li>
<li><code>list</code>的使用场景：频繁的插入删除的场景，这时也可以使用queue和deque。使用场景比如公交车乘客的存储，随时可能有乘客上下车，支持频繁的不确实位置元素的移除插入删除。</li>
<li><code>set</code>的使用场景：大部分负责查找内容且要求有序的情况下。使用场景比如对游戏中个人得分历史记录的存储，存储要求从高分到低分的顺序排列。</li>
<li><code>map</code>的使用场景：对查找有较高的要求，使用场景比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。红黑树的查找效率，这时就体现出来了。</li>
</ul>
<h4 id="算法">7. 算法</h4>
<h5 id="stl算法分类">7.1 STL算法分类</h5>
<h6 id="质变和非质变">7.1.1 质变和非质变</h6>
<ul>
<li><strong>质变算法：</strong>是指运算过程中会更改区间内的元素的内容</li>
<li><strong>非质变算法：</strong>是指运算过程中不会更改区间内的元素内容</li>
</ul>
<h6 id="stl算法的一般形式">7.1.2 STL算法的一般形式</h6>
<p><strong>大多数算法有下列4中形式：</strong></p>
<ul>
<li><code>alg(first,last,other args);</code></li>
<li><code>alg(first,last,dest,other args);</code></li>
<li><code>alg(first,last,first2,other args);</code></li>
<li><code>alg(first,last,first2,lasst2,other args);</code></li>
</ul>
<p><strong>更一般的说法是：</strong></p>
<ul>
<li><strong>所有泛型算法的前两个参数一定是一对迭代器，通常为<code>first</code>和<code>last</code>,范围为<code>[first,last)</code></strong></li>
<li><strong>许多STL算法不止只支持一个版本，可接受仿函数<code>_if</code>结尾，如<code>find()</code>函数支持传入谓词或仿函数的<code>find_if()</code>版本</strong></li>
<li>质变算法通常会有至少提供两个版本，一个是就地进行改变操作对象的版本，<strong>另一个是<code>_copy</code>版本，拷贝一份副本，在副本上改变，如<code>replace()</code>函数就有<code>replace_copy()</code>版本</strong></li>
<li>所有的数值算法实现都在<code>&lt;stl_numeric.h&gt;，用户使用时可包含</code>#include<numeric>`调用</numeric></li>
<li>其他算法实现于<code>&lt;stl_algo.h&gt;\&lt;stl_algobase.h&gt;</code>，用户使用可通过包含<code>#include&lt;algorithm&gt;</code>调用</li>
</ul>
<h6 id="算法总览">7.1.3 算法总览</h6>
<table>
<thead>
<tr class="header">
<th>算法名称</th>
<th>算法用途</th>
<th style="text-align: center;">质变？</th>
<th>所在文件</th>
<th style="text-align: center;">所属作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>accumulate</code></td>
<td>元素求和</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_numeric.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="even">
<td><code>adjacent_difference</code></td>
<td>相邻元素差额</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_numeric.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td><code>adjacent_find</code></td>
<td>查找相邻重复(或符合条件)的元素</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>binary_search</code></td>
<td>二分查找</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>copy</code></td>
<td>复制</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="even">
<td><code>copy_backward</code></td>
<td>逆向复制</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="odd">
<td><code>copy_n</code></td>
<td>复制n个元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="even">
<td><code>count</code></td>
<td>计数</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>count_if</code></td>
<td>在特定传入的谓词或仿函数条件下计数</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>equal</code></td>
<td>判断两个区间相等与否</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">关系</td>
</tr>
<tr class="odd">
<td><code>equal_range</code></td>
<td>在有序区间寻找某值，返回一个区间</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">关系</td>
</tr>
<tr class="even">
<td><code>fill</code></td>
<td>该填元素值</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>fill_n</code></td>
<td>该填元素值，n次</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>find</code></td>
<td>循序查找</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>find_if</code></td>
<td>查找符合条件的元素</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>find_end</code></td>
<td>查找某个子序列的最后一次出现点</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>find_first_of</code></td>
<td>查找某些元素首次出现点</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>for_each</code></td>
<td>对区间的每一个元素施行某操作</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>generate</code></td>
<td>以特定操作的运算结果填充特定区间内的元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>inner_product</code></td>
<td>内积</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td><code>iter_swap</code></td>
<td>元素互换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td><code>lower_bound</code></td>
<td>返回有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>max</code></td>
<td>最大值</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>max_element</code></td>
<td>最大值所在位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>min</code></td>
<td>最小值</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>min_element</code></td>
<td>最小值所在位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>merge</code></td>
<td>合并两个序列</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>inplace_merge</code></td>
<td>合并且就地替换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>random_shuffle</code></td>
<td>随机重排元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>remove</code></td>
<td>删除某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="odd">
<td><code>remove_copy</code></td>
<td>删除某类元素并将结果存储都另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="even">
<td><code>remove_if</code></td>
<td>有条件的删除某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="odd">
<td><code>remove_copy_if</code></td>
<td>有条件的删除某类元素，并将结果存储到另外一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="even">
<td><code>replace</code></td>
<td>替换某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="odd">
<td><code>replace_copy</code></td>
<td>替换某类元素，并将结果存储到另一个元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="even">
<td><code>replace_if</code></td>
<td>有条件的替换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="odd">
<td><code>replace_copy_if</code></td>
<td>有条件的替换，并将结果存储都另一个容q器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="even">
<td><code>reverse</code></td>
<td>反转</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="odd">
<td><code>reverse_copy</code></td>
<td>反转并把结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="even">
<td><code>rotate</code></td>
<td>旋转</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">旋转</td>
</tr>
<tr class="odd">
<td><code>rotate_copy</code></td>
<td>旋转，并把结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;sta_algo.h&gt;</code></td>
<td style="text-align: center;">旋转</td>
</tr>
<tr class="even">
<td><code>search</code></td>
<td>查找某个子序列</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>search_n</code></td>
<td>查找连续发生n次的某个子序列</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>sort</code></td>
<td>排序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">排序</td>
</tr>
<tr class="odd">
<td><code>stable_sort</code></td>
<td>排序并保持等值元素的相对次序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">排序</td>
</tr>
<tr class="even">
<td><code>stable_partition</code></td>
<td>分割并保存元素的相对次序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">分割</td>
</tr>
<tr class="odd">
<td><code>swap</code></td>
<td>交换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td><code>swap_ranges</code></td>
<td>指定区间的交换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="odd">
<td><code>unique</code></td>
<td>去重</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">去重</td>
</tr>
<tr class="even">
<td><code>unique_copy</code></td>
<td>去重后的结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">去重</td>
</tr>
<tr class="odd">
<td><code>upper_bound</code></td>
<td>返回有序序列范围内的可以插入指定值而不破坏容器顺序的最后位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>make_heap</code></td>
<td>创建一个堆</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="odd">
<td><code>pop_heap</code></td>
<td>从堆取元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="even">
<td><code>push_heap</code></td>
<td>将元素插入堆</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="odd">
<td><code>sort_heap</code></td>
<td>堆heap排序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
</tbody>
</table>
<h5 id="sort">7.2 sort</h5>
<h6 id="适用容器">7.2.1 适用容器</h6>
<p><code>sort()</code>算法是最复杂堆庞大的一个，<strong>这个算法接受两个<code>RandomAccessIterator</code>迭代器，然后将区间内的元素由小到大重新排列</strong>。第二个版本则允许用户传入<strong>谓词或者仿函数</strong>作为排序条件，指定按什么规则排序。适用<code>sort</code>算法的容器有<code>vecror\deque</code>。</p>
<p><strong><em>附</em></strong>：因为关联容器的底层机制，根本不需要<code>sort</code>排序，<code>stack\queue\priority_queue</code>对进出的机制也要求不需排序，而<code>list</code>的迭代器为<code>BidirectinalIterator</code>不适用。</p>
<h6 id="sort实现的原理">7.2.2 sort实现的原理</h6>
<p>早期的STL <code>sort()</code>算法都是采用<strong>快排</strong>来实现，对于快排平均的时间复杂度为<code>O(NlogN)</code>,但是最坏的情况却会达到<code>O(N*N)</code>，<strong>因此现今的<code>STL SGI</code>改用<code>IntroSort</code>即内观排序算法，极其类似于<code>median-three QuickSort</code>三数取中快速排序算法。这种算法即使在最坏的情况下推进到<code>O(NlogN)</code>。</strong>快排的最坏情况的发生与快速排序中基准点的选择是有重大的关系，当出现下面两种情况时性能最差:</p>
<ul>
<li>在分解时每次选取的基准点为最小元素</li>
<li>在分解时每次选取的基准点为最大元素</li>
</ul>
<p><strong>快排的过程：</strong></p>
<ul>
<li>如果序列中的元素个数为0或1，结束</li>
<li>取序列中的任何一个元素，一般会取该段序列的头或者尾元素作为基准点<code>pivot</code></li>
<li>将序列分类<code>L\R</code>两段子序列，使L内的每一个元素都小于或等于基准点，R内的每一个元素都大于等于基准点</li>
<li>对<code>L\R</code>递归执行<code>QuickSort</code>,重复上述操作</li>
</ul>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/quickSort.gif" width="600"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写自己的quickSort,没有优化，遇到最坏情况的时间复杂度会变成O(N*N)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--;</span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="三点取中优化方案">7.2.3 三点取中优化方案</h6>
<p>为了避免快排出现上述所说的最坏情况，选择哪一个元素作为基准点是关键，<strong>在快排过程中采用三点取中间值的优化方案。三数取中<code>median-of-three</code>指的是在挑选基准元素时，不是简单的选择数组中的第一个元素或最后一个，而是选取某三个元素，常选头、尾和中央三个元素，并且适用三个元素之中的中位数作为基准元素进行划分</strong>。这样即使在最坏的情况下将时间复杂度推进到<code>O(NlogN)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后的快排代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">medianOfThree</span>(a, first, (first + last) / <span class="number">2</span>, last);</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--; </span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cap[first] &lt; cap[mid])</span><br><span class="line">        <span class="keyword">if</span> (cap[first] &gt;= cap[last])	<span class="comment">//last=&lt;first&lt;mid</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&lt;mid&lt;last</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[mid];</span><br><span class="line">            cap[mid] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">// first&lt;last&lt;=mid</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[last];</span><br><span class="line">            cap[last] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[first] &lt; cap[last])	<span class="comment">//last&gt;first&gt;=mid</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&gt;=mid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[last];</span><br><span class="line">        cap[last] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[mid];</span><br><span class="line">        cap[mid] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数值算法">7.3 数值算法</h5>
<p>数值算法都在头文件<code>&lt;numeric&gt;</code>中，实现于<code>&lt;stl_numeric.h&gt;。 ###### 7.3.1 accumulate</code>accumulate`算法用来计算指定区间的和，需要提供额外参数指定累加到哪一个初始值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init)</span></span>;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T，<span class="keyword">class</span> BinaryOperation &gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init,</span></span></span><br><span class="line"><span class="params"><span class="function">	BinaryOperation binary_op)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="power">7.3.2 power</h6>
<p>计算某数的n次方幂，该算法四<code>SGI</code>版本特有算法。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Integer&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">power</span><span class="params">(T x,Integer n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="adjacent_difference">7.3.3 adjacent_difference</h6>
<p>算法<code>adjacent_difference</code>用来计算[first,last)中相邻元素的差额，即它会将<code>*first</code>赋值给<code>*result</code>，并针对[first,last)内的每个迭代器<code>i</code>,进行<code>*i-*(i-1)</code>，然后赋值给<code>*++result</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InpueIterator,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="基本算法">7.4 基本算法</h5>
<p>对于SGI版本,它会把常用的一些算法定义在<code>&lt;stl_algobase.h&gt;</code>,使用时包含<code>&lt;algorithm&gt;</code>即可。</p>
<h5 id="equal">7.4.1 equal</h5>
<p>如果两个序列在<code>[first,lasst)</code>区间内相等，<code>equal</code>会返回<code>true</code>。如果第二序列元素多，则剩余元素不考虑，一般调用前要先保证元素个数一样。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator1,<span class="keyword">class</span> InputIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(InpueIterator1 first1,InpueIterator1 last1,InpueIterator1 first2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="fill">7.4.2 fill</h6>
<p>将<code>[first,last)</code>内的元素该填新值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(ForwardIterator first,ForwardIterator last,<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">###### <span class="number">7.4</span><span class="number">.3</span> fill_n</span><br><span class="line">将`[first,last)`的前n个改填新值，返回的迭代器指向被填入的最后一个元素的下一个位置。</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> OutputIterator,<span class="keyword">class</span> Size,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">fill_n</span><span class="params">(OutputIterator first,Size n,<span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="iter_swap">7.4.4 iter_swap</h6>
<p>该算法将两个<code>ForwardIterator</code>所指对象对调。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1,calss ForwardIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator a,ForwardIterator2 b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="copy">7.4.5 copy</h6>
<ul>
<li><code>copy()</code>算法是最最最常用的一个算法，</li>
<li><code>copy()</code>算法将输入区间的<code>[first,last)</code>的元素复制到目标区间<code>[result,result+(last-first))</code>中，执行完后返回一个迭代器，指向<code>result+(last-first)</code>。</li>
<li><code>copy</code>函数对参数非常宽松，对输入区间只需由<code>InputIterator</code>构成即可，输出区间尾<code>OutputIterator</code>构成即可，即意味着可以将任何容器的任何一段内容复制带任何容器的任何一段上，当然这些容器要由对应的迭代器。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InpueIterator,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span></span><br></pre></td></tr></table></figure>
<h6 id="copy_backward">7.4.6 copy_backward</h6>
<p>与<code>copy</code>非常相似，只不过<code>copy_backward</code>是以逆行方向复制到<code>result</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterator1,<span class="keyword">class</span> BidirectionalIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(BidirectionalIterator1 first,</span></span></span><br><span class="line"><span class="params"><span class="function">	BidirectionalIterator1,BidirectionalIterator2 result)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="其他算法">7.5 其他算法</h5>
<p>定义与<code>&lt;stl_algo.h&gt;</code>内地算法</p>
<h6 id="adjacent_find">7.5.1 adjacent_find</h6>
<p>该算法找出第一组满足条件的相邻元素，这里所谓的条件，在版本一中是指<strong>两元素相等</strong>，在版本二中允许用户指定一个二元为谓词运算，两操作数是相邻第一个元素和第二个元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first,ForwardIterator last)</span></span>;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator,<span class="keyword">class</span> BinaryPredicate&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator last,BinaryPredicate binary_pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find">7.5.2 find</h6>
<p>在<code>[first,lasy)</code>找出第一个符合匹配条件的元素，返回该元素所在位置的迭代器，未找到则返回<code>last</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_if">7.5.3 find_if</h6>
<p>传入一原谓词，根据指定的条件<code>pred</code>元素条件查找，返回该元素所在位置的迭代器，未找到则返回<code>last</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> predicate&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,predicate pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_end">7.5.4 find_end</h6>
<p>在序列一的<code>[first1,last1)</code>区间中，查找序列二<code>[first2,last2)</code>最后一次出现点，如果不存在，则返回<code>last1</code>。由两个版本，版本一默认使用<code>==</code>,版本二允许用户传入二元运算谓词。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1,<span class="keyword">class</span> ForwardIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIterator</span><span class="params">(ForwardIterator1 first1,ForwardIterator1 last1</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator2 first2,ForwardIterator2 last2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_first_of">7.5.5 find_first_of</h6>
<p>本算法以<code>[first2,last2)</code>区间内的元素作为查找目标，寻找它们在<code>[first1,last1)</code>第一次出现的位置，<strong>只要<code>[first2,last2)</code>任何一个元素第一次出现在<code>[first1,last1)</code>就返回</strong>。两个版本，一个默认使用<code>==</code>,一个允许用户指定二元谓词传入 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIterator</span><span class="params">(InputIterator first1,InputIterator last1</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator2 first2,ForwardIterator2 last2)</span></span>;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">387k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
