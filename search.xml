<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>（面试）C++基础知识</title>
    <url>/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="c知识面试版_基础">1. C++知识面试版_基础</h3>
<h4 id="编译过程">1.1 编译过程</h4>
<p><img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/compile.png" width="700"> 如上所示，<strong>一个c源文件会先经过预处理，将头文件展开、宏替换和去注释；然后经过编译器生成汇编文件，再有汇编器生成二进制文件，最后再经过链接器将函数库中相应的代码组合到目标文件</strong></p>
<ul>
<li><p>预处理：预处理器会扫描源代码文件，根据以“#”开头的预处理指令执行一些文本替换和文件包含操作。例如，预处理器会把所有的#include指令替换为对应的头文件内容，并将定义的宏展开。生成<code>.i</code>文件</p></li>
<li><p>编译：编译器将经过预处理的源代码文件翻译成汇编代码，这是一种与具体机器体系结构相关的低级代码。生成<code>.s</code>文件</p></li>
<li><p>汇编：汇编器将汇编代码转化为机器码，并生成一个目标文件（.obj 或 .o）。目标文件包含机器指令和一些元数据，如符号表和重定位信息。生成二进制<code>.o</code>文件</p></li>
<li><strong>链接</strong>：链接器将目标文件与系统库和其他目标文件链接在一起，生成可执行文件。链接器主要完成两个任务：解析符号引用和地址重定位。
<ul>
<li><strong>符号解析：每个符号对应一个函数、一个全局变量或一个静态变量，符号解析的目的就是将每个符号引用正好和一个符号定义关联起来。那么当然在不同目标文件中引用的同一全局变量或函数，链接器需要将其解析为同一个实体。</strong></li>
<li>地址重定位指的是在链接过程中，需要将不同目标文件中的函数和变量的地址进行调整，使得它们在最终的可执行文件中能够正确地链接到一起。生成可执行文件</li>
</ul></li>
</ul>
<h4 id="静态链接和动态链接">1.2 静态链接和动态链接</h4>
<h5 id="静态链接">1.2.1 静态链接：</h5>
<p>链接器将目标文件和库文件的代码和数据全部拷贝到可执行文件中，形成一个独立的、包含所有必需代码和数据的可执行文件。在运行时，可执行文件不需要依赖外部库文件，所有需要的代码和数据都已经包含在可执行文件中</p>
<ul>
<li><strong>优点：对运行环境的依赖性较小，具有较好的兼容性,方便分发和部署，不需要外部依赖</strong></li>
<li><strong>缺点：生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间；库函数有了更新，必须重新编译应用程序</strong></li>
</ul>
<h5 id="动态链接">1.2.2 动态链接</h5>
<p>在动态链接中，库文件的代码和数据被保留在一个独立的文件中，被多个可执行文件共享。在链接时，链接器会将可执行文件中需要的库函数和数据的引用替换为动态链接库的符号表中对应的地址。在运行时，当程序调用一个需要动态链接库中的函数时，操作系统会将对应的库文件加载到内存中，并将调用转向库文件中的函数</p>
<ul>
<li><strong>优点：在需要的时候才会调入对应的资源函数；简化程序的升级；可执行文件小,节省磁盘空间；同时多个可执行文件可以共享同一个库文件，减少了内存占用</strong></li>
<li><strong>缺点：依赖动态库，不能独立运行；动态库依赖版本问题严重。如果库文件版本或路径发生变化，可能会导致程序无法正常运行</strong></li>
</ul>
<p>注：前面我们编写的应用程序大量用到了标准库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入<code>-static</code>参数。</p>
<h5 id="运行是加载和链接共享库">1.2.3 运行是加载和链接共享库</h5>
<span id="more"></span>
<h4 id="c函数调用过程">1.3 C++函数调用过程</h4>
<p><strong>函数调用栈的基本知识</strong>：</p>
<ul>
<li>每个线程都有一个自己的函数调用栈</li>
<li>栈也是程序申请的一段内存，随着栈的使用而增长。而一般编译的时候也可以指定编译选项设置栈最大值。如果递归调用层数太深，会导致栈溢出。</li>
<li>在<strong>系统中程序执行的时候 栈都是从高地址往低地址增长的&lt;函数参数压栈，一般从右向左压栈</strong>（比如<code>__cdecl</code>函数调用约定）</li>
<li><code>rip</code>寄存器存储当前执行指令的内存位置，也称为程序计数器pc</li>
<li><code>rbp</code>寄存器表明当前栈帧的栈底</li>
<li><code>rsp</code>寄存器表明当前栈帧的栈顶 <img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/registers.png" width="600"></li>
</ul>
<p><strong>在C/C++中，函数调用的过程通常包括以下步骤：</strong>比如右调用者函数P，被调用函数Q</p>
<ul>
<li><p><strong>第一步：</strong>保存调用者寄存器的值（保存现场）：在调用函数Q之前，需要将调用者P当前的寄存器状态（除了被调用者保存寄存器如<code>%rbx、%rbp、%r12~%r15</code>和栈指针<code>%rsp</code>外，其他被划分位调用者保存寄存器的要在这里保存寄存器状态）的值保存在P的栈帧起来，以便函数调用完成后能够正确地恢复。</p></li>
<li><p><strong>第二步</strong>：传递参数和保存：然后函数的参数通过栈或寄存器传递给被调用函数。对于较少的参数(前6个)，通常会使用寄存器传递，而对于较多的参数，则会使用栈传递，将剩余的参数从右向左压入P的栈帧(这也是为什么最后压如的是参数7)。将调用者P的返回地址压入栈中以保证能返回原来的地址继续执行，这个返回地址指向调用者函数在执行完被调用函数后应该返回的下一条指令的地址。</p></li>
<li><p><strong>第三步</strong>：跳转到被调用函数：在传递完参数后，通过设置程序计数器位Q的入口地址，跳转到被调用函数Q的入口地址开始执行被调用函数的代码。</p></li>
<li><p><strong>第四步</strong>：函数内部处理：被调用函数在执行时，保存需要保存的计数器值，然后将处理函数内部的逻辑，包括局部变量的分配和计算等操作，函数内部的变量通常会被分配在堆栈上。</p></li>
<li><p><strong>第五步</strong>：返回值：当Q执行完毕后，若有返回值，则会把返回值存放在寄存器<code>%rax</code>处，之后释放自己栈帧，弹出返回地址和压入参数，恢复现场的寄存器值状态，使得程序能够无错误的继续执行下一条指令。</p></li>
</ul>
<p><img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/StackofRun.png" width="600"></p>
<p><strong>调用函数具体过程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以此为例</span></span><br><span class="line"><span class="built_in">intFunAdd</span>(intiPara1, intiPara2) &#123;</span><br><span class="line">    intiAdd = <span class="number">7</span>; </span><br><span class="line">    intiResult = iPara1 + iPara2 + iAdd; </span><br><span class="line">    returniResult; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> main&#123;</span><br><span class="line">    intiVal1 = <span class="number">5</span>; intiVal2 = <span class="number">6</span>; </span><br><span class="line">    intiRes = <span class="built_in">FunAdd</span>(iVal1, iVal2); </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;iRes: %dn&quot;</span>, iRes); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/funcCall.png" width="600"></p>
<blockquote>
<p><code>call</code>指令做了哪些事情 答：<code>call</code>指令只是函数调用的一部分指令，它做了一些函数调用的部分控制，并不是全部。<code>call</code>指令做两件事，一是将当前调用函数的下一条指令地址入栈，即保证被调用函数结束后返回能够继续正常执行。二是设置程序计数器PC(<code>%rip</code>)为被调用函数的入口地址，使得能正确跳转该函数执行。 怎么知道返回时栈顶指针恢复到哪呢？ 编译器会计算当前函数需要多少空间，这样通过add指令后恢复</p>
</blockquote>
<h4 id="inline内联函数与普通函数的区别">1.4 inline内联函数与普通函数的区别</h4>
<ul>
<li>相当于把内联函数里面的内容写在调用内联函数的地方；</li>
<li>相当于不用执行调用函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数</li>
</ul>
<h5 id="内联函数与宏定义的区别">1.4.1 内联函数与宏定义的区别</h5>
<ul>
<li><p><strong>安全性</strong>：内联函数在编译期进行类型检查，因此比宏定义更安全。宏定义只是一个简单的文本替换，没有类型检查，可能会导致一些潜在的错误。</p></li>
<li><p><strong>可读性</strong>：内联函数在代码中的表现形式更像是一个普通函数，可以使用调试器和其它工具进行跟踪和分析，代码的可读性更高。而宏定义的代码片段可能比较难以理解，也难以进行调试和分析。</p></li>
<li><p><strong>换行</strong>：内联函数可以换行，而宏定义不可以。内联函数与普通函数的定义方式相同，可以在多个行中编写代码，并且可以使用代码块，使得代码更易于理解和维护。</p></li>
<li><p><strong>函数特性</strong>：内联函数是C++中的一个特性，因此可以使用C++的函数特性，如函数重载、默认参数等。而宏定义只是一个简单的文本替换，不支持这些特性。</p></li>
<li><p>对象代码生成：内联函数在编译期间将代码复制到调用点处，因此可以生成与普通函数相同的对象代码，而且比宏定义更灵活，可以根据参数类型生成不同的代码。而宏定义只是简单的文本替换，不能生成任何对象代码。</p></li>
</ul>
<p>综上所述，内联函数比宏定义更加安全、可读、易于维护，同时支持函数特性和对象代码生成，因此在C++中推荐使用内联函数来替代宏定义。</p>
<h4 id="结构体中的字节对齐">1.5 结构体中的字节对齐</h4>
<p>内存对齐的目的是为了提高CPU读写内存里数据的速度。现代的CPU读取内存并不是一个一个字节挨着读取，这样做的效率非常低。<strong>现代的CPU一般以<code>4</code>个字节(32bit数据总线）或者<code>8</code>个字节（64bit数据总线）为一组，一组一组地读写内存里的数据。为了使的计算机一次能够读完整，引入了内存对齐原则，支持计算机的快速寻址。</strong></p>
<p>内存对齐原则：</p>
<ul>
<li><strong>第一个成员在与结构体变量偏移量为0的地址处。</strong></li>
<li><strong>其他成员变量都放在对齐数（成员的大小和默认对齐数的较小值）的整数倍的偏移地址处。</strong>
<ul>
<li>对齐数=编译器默认的一个对齐数与该成员大小的较小值。（不同的编译器其默认对齐数不同，64位系统中VS默认的对齐数是8，在Linux中没有默认的对齐数）</li>
<li>可以在程序开端声明<code>#pragma pack(数字)</code>来设置默认对齐值</li>
</ul></li>
<li><strong>结构体总大小为最大对齐数(每个成员变量都有一个对齐数 )的整数倍。</strong></li>
<li><strong>如果嵌套了结构体的情况,嵌套的结构体对齐到自己的最大对齐数的整数倍处,结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍。---&gt;最大对齐数肯定不超过默认对齐数</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test1</span>&#123;</span><br><span class="line">	<span class="type">char</span> c_1;	<span class="comment">//char类型只有1字节--&gt;补齐到8字节，即0存储着c_1,另外1、2、3、4、5、6、7作为补齐字节</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> a_1;	<span class="comment">//占8</span></span><br><span class="line">&#125;;<span class="comment">//16字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span>&#123;</span><br><span class="line">	<span class="type">char</span> c_2;	<span class="comment">//1字节--&gt;4字节</span></span><br><span class="line">	<span class="type">int</span> a_2;	<span class="comment">//4字节</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">test1</span> p;	<span class="comment">//由于64位默认是8字节对齐，因此8+16=24</span></span><br><span class="line">&#125;;<span class="comment">//24字节</span></span><br></pre></td></tr></table></figure>
<p>测试： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">sizeof</span>(test1)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(test)&lt;&lt;endl;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure></p>
<h4 id="c的内存模型">1.6 C++的内存模型</h4>
<ul>
<li><strong>C++分区：堆和栈(动态数据段）、共享存储区、全局/静态存储区、常量存储区</strong></li>
<li><strong>c/c++内存模型生命周期</strong>：共享存储区、动态区、静态区</li>
</ul>
<blockquote>
<p>静态数据段：<code>.bss、.data</code>和代码段 <code>.data</code>段也称数据段，又细分为只读数据段和读写数据段 动态数据段：栈和堆（可用<code>limit</code>查看大小） <code>txt</code>：代码段，存放可执行的二进制机器指令</p>
</blockquote>
<p><strong><em>以下注意点：</em></strong></p>
<pre><code>(a)函数体中定义的变量通常是在栈上；
(b)用malloc, calloc, realloc、new等分配内存的变量和对象的是在堆上；
(c)在所有函数体外定义的是全局量,初始化的存储在.data段内，未初始化的则在.bss段；
(d)加了static修饰符后不管在哪里都存放在全局区（静态区）；
(e)在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用；</code></pre>
<p><img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++程序内存图.png" width="700"></p>
<h5 id="各中类型的变量在内存中的位置">1.6.1 各中类型的变量在内存中的位置</h5>
<ul>
<li><strong>全局/局部静态变量</strong>：而静态变量的存储位置在程序的全局数据段中，也称为<code>BSS</code>段（<code>Block Started by Symbol</code>）或者<code>Data</code>段。如果被初始化过，则存储在<code>.data</code>段，未初始化则存储在<code>.bss</code>段。<code>BSS</code>段是一段特殊的数据段，它存储所有被初始化为0或者未初始化的静态变量，这些为初始化的变量在程序启动时被自动初始化为0。
<ul>
<li>静态变量只会初始化一次</li>
<li>静态变量的生命周期是程序运行期间都存在，但其作用域范围要依据其是全局和局部才能区分。</li>
</ul></li>
<li><strong>全局变量</strong>：同全局静态变量一样，存储在<code>data</code>或者<code>bss</code>段内。不同点就是全局变量默认外部可见（即注意不能重定义，外部使用使用加<code>extern</code>），而static不可见(见1.7)。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code_1.cpp</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">2</span>;	<span class="comment">//全局变量</span></span><br><span class="line"><span class="comment">//code_2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;	<span class="comment">//使用code_1.cpp的a</span></span><br></pre></td></tr></table></figure></li>
<li>函数体中定义的局部变量存储在栈区，参数也是在栈中。</li>
<li>用<code>malloc, calloc, realloc、new</code>等分配内存的变量和对象的是在堆上</li>
<li><strong>全局常量</strong>：即<code>const</code>修饰全局变量的则存储在只读数据段</li>
<li><strong>局部常量</strong>：其分配在栈区，所以可以通过地址来修改<code>const</code>局部变量。</li>
</ul>
<h4 id="static关键字的作用">1.7 static关键字的作用</h4>
<ul>
<li>因为<code>static</code>声明的变量和函数存在程序整个生命周期，因此被<code>static</code>声明的变量和函数，它们的可见性被限制在当前源文件中，这可以提高程序的安全性和可维护性（你也不能加<code>extern</code>关键字）</li>
<li><code>static</code>修饰的变量只能初始化一次</li>
<li><code>static</code>修饰函数存储在代码段</li>
</ul>
<h5 id="全局静态变量编译时初始化存储在bssdata">1.7.1 全局静态变量（编译时初始化，存储在bss/data)</h5>
<p>在全局变量前加上关键字<code>static</code>，全局变量就定义成一个全局静态变量。<strong>存储在静态存储区（未初始化<code>bss</code>或已初始化数据段<code>data</code>），在整个程序运行期间一直存在。</strong></p>
<ul>
<li><strong>初始化：只能初始化一次。未经初始化的静态变量会被自动初始化为0</strong></li>
<li><strong>作用域</strong>：全局静态变量在声明他的文件之外是不可见的，准确地说是他的作用域从定义之处开始，到文件结尾。</li>
</ul>
<h5 id="局部静态变量">1.7.2 局部静态变量</h5>
<p>在局部变量之前加上关键字<code>static</code>，局部变量就成为一个局部静态变量。<strong>内存中的位置在静态存储区</strong></p>
<ul>
<li><strong>初始化</strong>：只能初始化一次。未经初始化的静态变量会被自动初始化为0。</li>
<li><strong>作用域</strong>：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束，但并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</li>
</ul>
<h5 id="静态函数">1.7.3 静态函数</h5>
<p><strong>在函数返回类型前加<code>static</code>，函数就定义为静态函数。函数的定义和声明在默认情况下都是<code>extern</code>的，但静态函数默认声明仅在当前文件当中可见，不能被其他文件所用</strong>。函数的实现使用<code>static</code>修饰，那么这个函数只可在本<code>cpp</code>内使用，不会同其他<code>cpp</code>中的同名函数引起冲突，起到一个函数隐藏的作用；</p>
<ul>
<li><strong>warning：</strong>不要在头文件中声明<code>static</code>的全局函数，不要在<code>cpp</code>内声明非<code>static</code>的全局函数，如果你要在多个<code>cpp</code>中复用该函数，就把它的声明提到头文件里去，否则<code>cpp</code>内部声明需加上<code>static</code>修饰；</li>
</ul>
<h5 id="类的静态成员">1.7.4 类的静态成员</h5>
<p>在类中，<strong>静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则</strong>，即保证了安全性。因此，<strong>静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</strong></p>
<h5 id="类的静态函数">1.7.5 类的静态函数</h5>
<p><strong>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</strong></p>
<p><strong>在静态成员函数中没有<code>this</code>指针，因此无法被<code>const</code>修饰</strong>。实现中不能直接引用类中声明明的非静态成员，但可以引用类中声明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，要通过对象来引用。调用静态成员函数可通过<code>object.staticfunc()</code>也可以通过<code>class::staticfunc()</code>调用</p>
<h4 id="const关键字">1.8 const关键字</h4>
<p><code>const</code>关键字是常量的意思，可以修饰变量、指针和引用，也可以修饰函数，在不同的修饰当中意思会不同,但总的意思是声明为常量，不可以更改：</p>
<ul>
<li><code>const</code>修饰变量：定义了该变量为常量，只允许初始化，不允许对其进行修改。</li>
<li><code>const</code>修饰指针时，有两种情况：
<ul>
<li><strong>低层<code>const</code></strong>：指如<code>const int *b</code>或者<code>int const *b</code>，表示可以修改b的值（即指针），但是我们不能修改其指针指向的内容。</li>
<li><strong>顶层<code>const</code></strong>:例如<code>int* const b</code>，表示我们不能修改b的值，但是我们可以修改其指针指向的内容</li>
</ul></li>
<li><code>const</code>修饰引用时：表示我们不能通过这个引用别名去修改值</li>
<li><code>const</code>修饰函数时，也有两种情况：
<ul>
<li><code>const</code>修饰返回值：表示该函数返回的是一个const常量</li>
<li><code>const</code>放在<code>()</code>后面：这种情况常用在类中，表明该成员函数不能改变成员变量的值的。（C++为了在特殊情况下也能改变值，可以将相应的成员变量声明为<code>mutable</code>)</li>
</ul></li>
<li>对于类中的常量，只允许通过初始化列表来进行初始化，不允许在函数中进行赋值初始化。</li>
<li><code>const</code>成员函数：<code>const</code>对象（成员函数）不可以调用非<code>const</code>成员函数；非<code>const</code>对象都可以调用；不可以改变非<code>mutable</code>（用该关键字声明的变量可以在const成员函数中被修改）数据的值。</li>
</ul>
<blockquote>
<p><strong>注意：运行非const赋值给const，但不允许const赋值给非const，因为如果运行const赋值给非const，那么就很容易规避const的常量不可变机制，导致未知错误</strong></p>
</blockquote>
<h5 id="const与define的区别">1.8.1 const与#define的区别</h5>
<ul>
<li><code>const</code>修饰的是该变量为常量，只能被初始化，不能被修改；在编译区间会有类型检查。</li>
<li><code>#define</code>只是对后面的表达式起一个文本替换；它发生在预处理阶段，不会做类型检查，当其所替换的式子很长时容易引发一些出人意料的错误。</li>
</ul>
<h4 id="delete和new与c的malloc区别">1.9 delete和new(与c的malloc区别)</h4>
<p><code>new</code>和<code>malloc</code>都是动态分配内存的关键字，它们之间的区别是：</p>
<ul>
<li><code>malloc</code>是一个库函数，而<code>new</code>是一个运算符重载,本质上是运算符为名称的函数。</li>
<li><code>malloc</code>按照给定的字节数去分配堆内存；而<code>new</code>是依照数据类类型大小去分配堆内存，因此对于<code>new</code>，如果我们要分配多个堆内存，就要实验数组形式去分配，如<code>new int[20]</code></li>
<li>因此，<code>malloc</code>返回的是一个原生为构造的堆内存，类型是<code>void*</code>；而<code>new</code>为运算符重载，会调用相应类型的构造函数构造相应的对象，返回的是对象指针。</li>
<li><code>malloc</code>如果分配失败，则会返回一个NULL，没有其他的反应；而<code>new</code>分配失败则会抛出一个<code>bad_alloc</code>异常，指示此次内存分配失败</li>
<li>为避免内存泄露，在使用完后必须去释放这些分配的内存。由<code>malloc</code>分配的内存必须使用<code>free</code>来释放；而<code>new</code>分配的，必须使用<code>delete</code>释放。</li>
<li><code>free</code>只是单纯的释放该空间；<code>delete</code>则会先调用对象的析构函数再去释放内存。</li>
</ul>
<h5 id="new和delete是如何实现的">1.9.1 new和delete是如何实现的？</h5>
<ul>
<li><code>new</code>的实现过程是：首先调用名为<code>operator new</code>的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针</li>
<li><code>delete</code>的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存</li>
</ul>
<h5 id="既然有了mallocfreec中为什么还需要newdelete呢直接用mallocfree不好吗">1.9.2 既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？</h5>
<ul>
<li><code>malloc/free</code>和<code>new/delete</code>都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而<code>malloc/free</code>是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给<code>malloc/free</code>，所以<code>new/delete</code>是必不可少的</li>
</ul>
<h4 id="sizeof一个空类大小即考察类的一些成员占不占类内存占多少">1.10 sizeof一个空类大小（即考察类的一些成员占不占类内存，占多少）</h4>
<ul>
<li>空类不是<code>0</code>字节，而是<code>1</code>字节。这是因为空类也是可实例化的（实例化的过程就是内存中分配一块地址），为了区分每一个实例化的对象就必须有它们对应的独一无二的地址。因此编译器会给每一个空类隐式加上一个字节。</li>
<li>类中若有虚函数则存在虚表指针，指针成员在<code>X86-64</code>会占8字节，在32位占4字节(最后一个)</li>
<li>其他成员变量按照大小给定和遵循内存对齐</li>
<li><table>
<thead>
<tr class="header">
<th>存在字节对齐(内存对齐)问题：</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>虚函数表4字节，4字节对齐！比如**</td>
</tr>
<tr class="even">
<td>--code￼4--&gt;</td>
</tr>
</tbody>
</table></li>
</ul>
<h5 id="对指针和引用sizeof有什么区别">1.10.1 对指针和引用sizeof，有什么区别</h5>
<ul>
<li>指针就是数据的地址，对指针做<code>sizeof</code>操作，返回的是指针的大小，在64位系统上，指针大小位8字节，而在32位机器上则是4字节。</li>
<li>引用只是数据对象的一个别名，因此对引用做<code>sizeof</code>就是数据对象的大小</li>
</ul>
<blockquote>
<p>引用的底层实现依然是指针，只不过在使用时没有表现出指针表现，而像是个普通变量 扩展： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> d=<span class="number">11.2</span>;</span><br><span class="line"><span class="type">int</span> a=d（<span class="number">1</span>）</span><br><span class="line"><span class="type">int</span> &amp;b=d（<span class="number">2</span>）</span><br></pre></td></tr></table></figure> 上面（1）操作合法，隐式的强制转化，向上转换。 上面（2）操作非法。如果合法，这里引用的变量其实是一块临时空间，而临时空间是右值是不能修改的，这种引用的方式本质上其实就是权限的放大，因此编译不能通过 说到隐式强制转化，必须要提到其转换机理；正如下图所示，在发生隐式类型转换的时候，需要将<code>d</code>的值存到一个<code>int</code>类型的临时变量里，然后将这个临时变量的值赋予给<code>a</code>。 <img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/reference.png" width="300"></p>
</blockquote>
<h5 id="指针为啥是4字节一定是4字节吗对指针做seziof的结果与什么相关">1.10.2 指针为啥是4字节，一定是4字节吗，对指针做seziof的结果与什么相关</h5>
<ul>
<li>指针是地址，它字节数是一定的不改变的，由不同机器而定的。这样机器才能正确依照这样长度规则的知道正确的地址。</li>
<li>不同的机器指针大小不一样，在64位系统中，指针的长度位8字节，而在32位中为4字节</li>
</ul>
<h4 id="c中指针和引用的区别">1.11 c++中指针和引用的区别</h4>
<p>共同点:</p>
<ul>
<li>引用的底层实现机制仍然是指针，因此能够像指针一样，修改变量值会影响到原值。</li>
</ul>
<p>不同点：</p>
<ul>
<li>指针是地址，有自己的一块内存，里面的内容是指向所储存的数据的地址；因此对指针做<code>sizeof</code>操作返回的是指针大小4/8字节；对于指针，被<code>const</code>修饰时有两种完全不同的意思，一个是底层<code>const</code>,一个是顶层<code>const</code></li>
<li>引用只是一个别名，对于做sizeof操作返回的是相应数据的大小；被const修饰，只有一种意思那就是，不能通过该引用变量修改原值，表明这是个引用常量。</li>
<li>指针可以被初始化为<code>NULL</code>，而引用必须被初始化且必须是一个已有对象 的引用</li>
<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变</li>
<li>指针可以有多级指针<code>**p</code>，而引用只有一级；</li>
<li>指针和引用使用<code>++</code>运算符的意义不一样</li>
</ul>
<h4 id="c中的类型转换四个">1.12 c++中的类型转换（四个）</h4>
<p>C++除了继承C的风格的<code>type Expression</code>转换外，还提供了四种cast转换：<code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code>。</p>
<ul>
<li><code>static_cast&lt;type&gt;(expression)</code>:<code>static_cast</code>一般满足各种类型的转换，但不能将底层<code>const</code>转换为非<code>const</code>。同时该运算符没有进行运行时类型检查来保证转换的安全性。
<ul>
<li>用于类层次结构中基类和派生类之间指针或引用的转换。进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类的指针或引用转换为派生类表示），<strong>由于没有动态类型检查，所以是不安全的。</strong></li>
<li>用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换为void类型。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(a);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><code>dynamic_cast&lt;type&gt;</code>:<strong>用于动态类型转换。该运算符主要用于继承中有虚函数类层次之间的上行和下行转换，或者类之间的交叉转换，只能转指针或引用，并且是同一种表达方式（引用对引用，指针对指针）。类层次间的上下行转换效果和<code>static_cast</code>一样，但是下行转换时，<code>dynamic_cast</code>具有类型检查功能，比<code>static_cast</code>更安全。</strong>。向下转化时进行类型检查，如果失败，对于指针返回NULL，对于引用抛异常<code>bad_cast</code>。
<ul>
<li><p>向下转换(从父类转换为子类指针或引用)：<code>dynamic_cast&lt;son*&gt;(father)</code>,若<code>father</code>是一个基类指针或引用，但指向的是其子类<code>son</code>指针或引用，此时将其转为<code>son*</code>是安全的；若<code>father</code>是基类指针，但指向的不是子类<code>son</code>指针或引用，而是其自己，则返回NULL。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A* a=<span class="keyword">new</span> <span class="built_in">son</span>();</span><br><span class="line">son* s=<span class="built_in">dynamic_cast</span>&lt;son*&gt;(a);	<span class="comment">//会执行动态类型检查</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>交叉转换（从一个父类转换为另一个父类的指针或引用）：在多继承当中的虚继承可以使用。</p></li>
</ul></li>
</ul>
<blockquote>
<p>向上转换：指的是子类向基类的转换 向下转换：指的是基类向子类的转换(有动态类型检查，安全)。它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换</p>
</blockquote>
<ul>
<li><code>const_cast</code>：该类型转换为只用来修改类型的const或volatile属性，除了const或volatile修饰外，其他类型要一致。只能对是 <strong>引用 或者 指针 的变量添加或移除<code>const</code>。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">11</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* b=&amp;a;</span><br><span class="line"><span class="type">int</span>* c=<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(b);</span><br><span class="line">*c=<span class="number">20</span>;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">11</span> <span class="number">00000034</span>CA9AF884</span><br><span class="line"><span class="number">20</span> <span class="number">00000034</span>CA9AF884</span><br><span class="line"><span class="number">20</span> <span class="number">00000034</span>CA9AF884</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么<code>a\b\c指向同一个地址，c修改无法影响a呢？</code>：C++primer指出一旦我们去掉了某个对象的<code>const</code>性质，编绎器就不在阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用<code>const_cast</code>执行写操作就会产生未定义的后果。</li>
<li>因此我们不要这样子做：定义一个常量，再去修改一个常量这是不正确的</li>
</ul></li>
<li><code>reinterpret_cast</code>主要有三种强制转换用途：
<ul>
<li>改变指针或引用的类型、</li>
<li>将指针或引用转换为一个足够长度的整形、</li>
<li>将整型转换为指针或引用类型。 <img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/cast.png" width="600"></li>
</ul></li>
</ul>
<h4 id="内存泄露问题如何检测解决">1.13 内存泄露问题，如何检测，解决</h4>
<p>内存泄漏（Memory Leak）指的是程序在运行过程中分配的堆内存没有被释放，从而导致系统内存资源的浪费。内存泄漏问题可能会导致程序运行缓慢，甚至崩溃。以下是检测和解决内存泄漏问题的方法：</p>
<ul>
<li><p>使用内存检测工具：可以使用一些内存检测工具，如Valgrind、Dr. Memory等，这些工具可以帮助我们检测内存泄漏问题。这些工具会对程序进行内存跟踪，检测到内存泄漏时会给出相应的警告信息，以便开发人员及时解决问题。</p></li>
<li><p>代码审查：对程序进行仔细的代码审查，查找可能存在内存泄漏的代码。可以在代码中添加跟踪内存分配和释放的日志信息，以便在程序运行时更容易定位问题。</p></li>
<li><p>使用智能指针：C++11引入了智能指针，如std::shared_ptr和std::unique_ptr等，可以自动管理内存。智能指针可以帮助我们在不需要内存时自动释放它，避免出现内存泄漏问题。</p></li>
<li><p>及时释放内存：在程序运行过程中，尽可能及时释放不需要的内存，可以通过手动释放、使用RAII（Resource Acquisition Is Initialization）等方式实现。</p></li>
<li><p>代码重构：在进行代码重构时，可以考虑使用更高级别的语言特性和数据结构，如使用容器、智能指针等，以便更好地管理内存</p></li>
</ul>
<h4 id="野指针和悬空指针">1.14 野指针和悬空指针</h4>
<p>它们都是是指向无效内存区域(这里的无效指的是&quot;不安全不可控&quot;)的指针，访问行为将会导致未定义行为。</p>
<ul>
<li><strong>野指针</strong>：野指针指的是声明为指针但是进行初始化（未定义或未置空<code>NULL\nullptr</code>）的指针，其指向不确定。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span>* p;     <span class="comment">// 未初始化</span></span><br><span class="line">    std::cout&lt;&lt; *p &lt;&lt; std::endl; <span class="comment">// 未初始化就被使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>悬空指针</strong>：指针最初指向的内存已经被释放了的一种指针，并未重新指向新内存或者置空。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> * p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">  p = p2;</span><br><span class="line">  <span class="keyword">delete</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。因此需要设置为<code>p=p2=nullptr</code>。此时再使用，编译器会直接保错。 避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，CPP智能指针的本质就是避免悬空指针的产生。</p></li>
<li><p><strong>野指针：</strong></p>
<ul>
<li><p>指针指向的内容已经无效了，而指针没有被置空，解引用一个非空的无效指针是一个未被定义的行为，也就是说不一定导致错误，野指针被定位到是哪里出现问题，在哪里指针就失效了，不好查找错误的原因。</p></li>
<li><p>规避方法： 1.初始化指针的时候将其置为nullptr，之后对其操作。 2.释放指针的时候将其置为nullptr。</p></li>
</ul></li>
</ul>
<h4 id="c中的智能指针">1.14 C++中的智能指针</h4>
<p>C++引入智能指针能够有效的解决我们在动态申请内存空间，在结束时忘记释放而造成内存泄漏问题。智能指针是模板类。</p>
<p>在C++中存在三种智能指针类型：<code>shared_ptr、unique_ptr、weak_ptr</code></p>
<ul>
<li><p><code>shared_ptr</code>：允许多个智能指针指向相同的对象，实现共享式拥有。<strong>它通过引用计数来表明当前对象被几个智能指针所共享，当计数为0时，对象被销毁</strong>。一般不允许管理动态数组，因为shared_ptr的析构函数默认时<code>delete p</code>;如果要分配要必须定义自己的删除器。</p></li>
<li><p><code>unique_ptr</code>：任何时刻，都至多只能有一个<code>unique_ptr</code>智能指针指向一个对象，当<code>unique_ptr</code>指针被销毁时，其对象也被销毁。他没像<code>shared_ptr</code>的<code>make_shared</code>函数进行初始化，也不支持赋值和普通拷贝。需要将其绑定到一个<code>new</code>返回的指针，或者也可以通过<code>release</code>和<code>reset</code>函数将指针所有权从一个<code>unique</code>移交给另一个<code>unique_ptr</code>指针。</p></li>
<li><p><code>weak_ptr</code> ：<code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针，它指向一个有<code>shared_ptr</code>管理的对象。将一个<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变<code>share_ptr</code>的引用计数。<code>weak_ptr</code>是用来解决<code>shared_ptr</code>相互引用时的死锁问题,如果说两个<code>shared_ptr</code>相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和<code>shared_ptr</code>之间可以相互转化，<code>shared_ptr</code>可以直接赋值给它，它可以通过调用<code>lock</code>函数来获得<code>shared_ptr</code>。</p></li>
</ul>
<h5 id="智能指针存在内存泄漏吗">1.14.1 智能指针存在内存泄漏吗</h5>
<p>存在！当两个对象相互使用<code>shared_ptr</code>成员变量指向对方时，就会造成循环引用，从而导致内存泄漏。</p>
<p>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，<code>weak_ptr</code>的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>
<h5 id="实现一下有shared_ptr性质的类">1.14.2 实现一下有<code>shared_ptr</code>性质的类</h5>
<p><strong>引用计数：</strong></p>
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还有创建一个引用计数，用来记录多少对象与正在创建的对象共享数据状态。</li>
<li>拷贝构造函数不分配计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户共享</li>
<li>析构函数递减计数器，指出gong共享状态的用户少了一个。若为0，则释放</li>
<li><p>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧。若左侧为0，则销毁释放。</p></li>
<li>如何存放存放计数器？
<ul>
<li>将计数器保存在动态内存中，当创建一个对象时，我们分配一个计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span>  string&amp; s=<span class="built_in">string</span>())</span><br><span class="line">		:<span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)),<span class="built_in">i</span>(<span class="number">0</span>),<span class="built_in">use</span>(<span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>))&#123;&#125;		<span class="comment">//构造函数,计数器为1</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">		:<span class="built_in">ps</span>(p.ps),<span class="built_in">i</span>(p.i),<span class="built_in">use</span>(p.use)&#123;*use++&#125;		<span class="comment">//拷贝构造函数,共享ps,use</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;);			<span class="comment">//赋值运算符</span></span><br><span class="line">	~<span class="built_in">HasPtr</span>()；					<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string *ps;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> *use;							<span class="comment">//引用计数器</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数定义：</span></span><br><span class="line">	HasPtr::~<span class="built_in">HasPtr</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span>(--*use==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> ps;			<span class="comment">//计数为0时，释放</span></span><br><span class="line">			<span class="keyword">delete</span> use;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符定义：</span></span><br><span class="line">	HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;p)&#123;</span><br><span class="line">		++*p.use;		<span class="comment">//递增右侧计数器</span></span><br><span class="line">		<span class="keyword">if</span>(--*use==<span class="number">0</span>)&#123;		<span class="comment">//递减左侧计数器，并判断</span></span><br><span class="line">			delele ps;</span><br><span class="line">			<span class="keyword">delete</span> use;</span><br><span class="line">		&#125;</span><br><span class="line">		ps=p.ps;			<span class="comment">//共享该堆内数据</span></span><br><span class="line">		i=p.i;</span><br><span class="line">		use=p.use;		<span class="comment">//共享计数器</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;		<span class="comment">//返回本对象</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指针数组和数组指针">1.15 指针数组和数组指针</h4>
<ul>
<li><strong>指针数组</strong>：它是数组，不过内部存储的值是指针，即地址。</li>
<li><strong>数组指针</strong>：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr[<span class="number">10</span>]; <span class="comment">//指针数组</span></span><br><span class="line"><span class="built_in">int</span> (*ptr)[<span class="number">10</span>];	<span class="comment">//数组指针</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="一个函数它前面的const和在后面const的区别">1.16 一个函数它前面的const和在<code>()</code>后面const的区别</h4>
<ul>
<li><code>const</code>修饰函数时，也有两种情况：
<ul>
<li><code>const</code>修饰返回值：表示该函数返回的是一个const常量</li>
<li><code>const</code>放在<code>()</code>后面：这种情况常用在类中，表明该成员函数不能改变成员变量的值的。（C++为了在特殊情况下也能改变值，可以将相应的成员变量声明为<code>mutable</code>)</li>
</ul></li>
</ul>
<h4 id="c的lambda表达式">1.17 C++的lambda表达式</h4>
<p>lambda表达式是C++1 引入的一个“语法糖”,可以方便快捷地创建一个“函数对象”。多用于在函数体内直接嵌套生成一个子函数,可以方便函数体内后续的调用。一个lambda表达式具有返回类型、参数列表、捕获列表和函数体组成。其形式如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list](argumrnt list)-&gt;retyrn type&#123;function body;&#125;;</span><br></pre></td></tr></table></figure> <strong>其中参数列表和返回类型可以忽略，但必须包含捕获列表和函数体；</strong>lambda表达式的提出，解决了：</p>
<ul>
<li>可在函数体内嵌套生成一个子函数，该lambda有函数的性质，可以多次调用使用。（可调用对象）</li>
<li>解决一些STL算法当中对谓词的限制，STL当中较多的算法对谓词的参数有限制，如<code>_if</code>结尾的只能接收一元谓词，这时候使用<code>lambda</code>表达式通过捕获列表来活动多个参数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> w=<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[sz](<span class="type">const</span> string&amp;a,)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>对于<code>lambda</code>表达式，最主要的是它的捕获列表，参数的捕获分为<strong>引用捕获<code>&amp;</code>和值捕获<code>=</code></strong>，这里主要谈论有隐式捕获时的规则：</p>
<ul>
<li><code>[&amp;]</code>：隐式的引用捕获，即lambda中所使用来自函数的实体都采用引用捕获</li>
<li><code>[=]</code>：隐式值捕获，即<code>lambda</code>中所使用来自函数的实体都采用值捕获</li>
<li><code>[&amp;,identifier_list]</code>：未出现在<code>identifier_list</code>的使用引用捕获，出现的则使用值捕获(注意<code>identifier_list</code>的显示捕获参数不能为引用捕获，只能为值捕获)</li>
<li><code>[=,identifier_list]</code>：未出现在<code>identifier_list</code>的使用值捕获，出现的则使用引用捕获(注意<code>identifier_list</code>的显示捕获参数不能为值捕获，只能为引用捕获) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = [&amp;]() &#123;a += <span class="number">2</span>; <span class="keyword">return</span> a &gt; b;  &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">c</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;引用捕获,a=&quot;</span> &lt;&lt;a&lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">引用捕获,a=<span class="number">4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="volatile">1.18 volatile</h4>
<p><code>volatile</code>同<code>const</code>一样是可用于修饰变量的关键字，它是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。 BS 在 &quot;The C++ Programming Language&quot; 对 volatile 修饰词的说明是这样子的：</p>
<blockquote>
<p>A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.</p>
</blockquote>
<ul>
<li><p>它应对的场景是这样的：<strong>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化。这是因为volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址即内存中读取数据</strong>。如果没有<code>volatile</code>关键字，则编译器可能优化读取和存储，就极有可能暂时使用寄存器中的值，此时这个变量由别的线程更新了的话，将出现不一致的现象，线程不安全。</p></li>
<li><p>示例：<code>int volatile vInt;</code> 当要求使用volatile声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p></li>
<li>有意思的示例：<code>const volatile int cvInt;</code>。首先<code>const</code>修饰<code>cvInt</code>说明它是一个常量，不会改变；而<code>volatile</code>告诉编译器这个变量极有可能改变，你不要做过于激进的优化，要在内存中进存取。我们第一眼可能感觉到这是矛盾的，但其实不然。
<ul>
<li><code>const</code>表示在本程序段不能对<code>cvInt</code>进行修改，任何修改都是非法的，编译器应该要报错，防止这种错误。</li>
<li><code>volatile</code>则是说这个变量完全有可能被另一个线程修改(比如说另一个线程使用汇编去修改)，告诉编译器不要做太过激进的优化。</li>
</ul></li>
<li><p><strong>不能保证线程安全</strong>：<code>volatile</code>对于非原子操作来说，无法保证线程安全，而对于原子操作，可以保证线程安全的，因此对于原子操作可使用<code>volatile</code>来提升并发效率，不使用锁带来的巨大开销</p></li>
</ul>
<h4 id="auto关键字">1.19 auto关键字</h4>
<p><code>auto</code>关键字是C++11的一个新特性，<code>auto</code>一般与左值进行联合使用，它通过右值的表达式来推断左值类型，定义左值变量。即以往我们需要在运行前通过显示的声明左值类型，现在可将类型的声明推迟到运行中，并自动推断。</p>
<h4 id="extern-c">1.20 extern &quot;C&quot;</h4>
<p>为了能够正确的在<code>C++</code>代码中调用C语言的代码：在程序中加上<code>extern &quot;C&quot;</code>后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是<code>C++</code>；</p>
<p>哪些情况下使用<code>extern &quot;C&quot;</code>：</p>
<ul>
<li><p>（1）C++代码中调用C语言代码；</p></li>
<li><p>（2）在C++中的头文件中使用；</p></li>
<li><p>（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；</p></li>
</ul>
<p>举个例子，C++中调用C代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MY_HANDLE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MY_HANDLE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">result_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* <span class="type">my_handle_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">my_handle_t</span> <span class="title">create_handle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">result_t</span> <span class="title">operate_on_handle</span><span class="params">(<span class="type">my_handle_t</span> handle)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close_handle</span><span class="params">(<span class="type">my_handle_t</span> handle)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 综上，总结出使用方法<strong>，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern &quot;C&quot;声明，在.c文件中包含了extern &quot;C&quot;时会出现编译语法错误。</strong>所以使用extern &quot;C&quot;全部都放在于cpp程序相关文件或其头文件中。</p>
<ul>
<li>C++调用C函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"><span class="comment">//xx.c</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xx.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C调用C++函数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xx.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="变量声明和定义的区别">1.21 变量声明和定义的区别</h4>
<ul>
<li><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</p></li>
<li><p>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</p></li>
</ul>
<h4 id="strlen和sizeof区别">1.22 strlen和sizeof区别？</h4>
<ul>
<li><p><code>sizeof</code>是运算符，并不是函数，结果在编译时得到而非运行中获得；<code>strlen</code>是字符处理的库函数。</p></li>
<li><p><code>sizeof</code>参数可以是任何数据的类型或者数据（sizeof参数不退化）；<code>strlen</code>的参数只能是字符指针且结尾是'\0'的字符串。</p></li>
<li><p>因为<code>sizeof</code>值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">    <span class="built_in">sizeof</span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">    <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="在main执行之前和之后执行的代码可能是什么">1.22 在main执行之前和之后执行的代码可能是什么？</h4>
<p><strong>main函数执行之前，主要就是初始化系统相关资源：</strong></p>
<ul>
<li>设置栈指针</li>
<li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型<code>short，int，long</code>等为<code>0，bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容</li>
<li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li>
<li>将<code>main</code>函数的参数<code>argc，argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li>
<li><code>__attribute__((constructor))</code></li>
</ul>
<p><strong>main函数执行之后：</strong></p>
<ul>
<li>全局对象的析构函数会在main函数之后执行；</li>
<li>可以用 atexit 注册一个函数，它会在main 之后执行;</li>
<li><code>__attribute__((destructor))</code></li>
</ul>
<h4 id="如何用代码判断大小端存储">1.23 如何用代码判断大小端存储？</h4>
<ul>
<li><strong>大端：</strong>指在底位存储数据的高字节。大端也称网络字节序，在网络传输中总是采用大端法来传输的，因此对于小端主机接收到的网络数据，必须完成大小端的转换。</li>
<li><strong>小端</strong>：指在底位(地址)存储数据的底字节。 <img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/bigorsmall.png" width="700"></li>
</ul>
<p>那么如何识别本机的是采用哪种方法存储数据呢，可使用一下代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bigOrSmall</span><span class="params">(<span class="type">char</span> * c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">char</span>* c=(<span class="type">char</span>*)&amp;a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bigOrSmall</span>(c);</span><br><span class="line">		c+=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 输出 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure> 很明显可知本机是采用小端法</p>
<h4 id="section">1.24</h4>
<h4 id="智能指针说下">1.25 智能指针说下?</h4>
<h4 id="你说到unique_ptr有移动语义那你说下move是吗的">1.26 你说到unique_ptr有移动语义,那你说⼀下move是⼲吗的?</h4>
<h4 id="你说move是将左值转换成右值为什么要有movemove最根本解决什么问题">1.27 你说move是将左值转换成右值为什么要有move?move最根本解决什么问题</h4>
<h4 id="你说到右值引那你说下左值右值的区别">1.28 你说到右值引⽤,那你说⼀下左值右值的区别</h4>
<h4 id="好那为什么c要有左值右值c的开发者为什么当初要设定左值右值的是什么要解决什么问题">1.29 好那为什么C要有左值右值?C的开发者为什么当初要设定左值右值⽬的是什么要解决什么问题</h4>
<h4 id="你设计下shared_ptr">1.30 你设计⼀下shared_ptr</h4>
<h3 id="c知识面试版_面向对象">2. C++知识面试版_面向对象</h3>
<h4 id="c中的面向对象是什么">2.1 C++中的面向对象是什么</h4>
<ul>
<li><p><strong>面向对象是什么：</strong>C++中的面向对象是指不再像C一样以面向结构和流程式编程，而是面向对象来编程。CPP中的对象是由于引入了类这一个概念而产生的，类指的是一类事物，在类的内部集成封装了许多了与该类有关各样的函数和成员变量。为了能够去调用这个类中的函数和变量，必须去示例化这个类，而实例化的结果就是产生了这个类的对象，然后我们可以通过这个对象去调用函数和变量了。</p></li>
<li>由上面的类和面向对象得到了其熟知的三大特征，<strong>封装、继承和多态</strong>
<ul>
<li>封装性：上面的类中集成了许多函数实现和成员变量，对于有一些数据和函数我们允许外部能够调用，但对于有一些数据和函数，我们为了保证数据的安全性，我们希望它们是不可被外部直接访问(除非提供访问接口)，因此有了关键字：<code>private</code>、<code>protected</code>和<code>public</code>，它们指示了相关数据函数的是否可访问。</li>
<li>继承性：继承为了解决在拥有多个类的情况下，一些类和类呈现了父子般关系的场景，比如<code>水果类</code>和<code>草莓类</code>，很明显<code>草莓类</code>是<code>水果类</code>的一个子类，继承好处是：
<ul>
<li>那么对于水果当中一些公共方法同样能够适用于草莓，这样通过继承能够实现代码复用，避免了代码的冗余；</li>
<li>同样，草莓类能够基于水果类进行自己的扩展，能够添加新的函数，也能够重写已有的函数。</li>
<li>继承是多态特性的前提之一。</li>
</ul></li>
<li>多态性：多态的实现主要分为<strong>静态多态</strong>和<strong>动态多态</strong>，<strong>静态多态主要是重载和模板，在编译的时候就已经确定</strong>；动态多态是用虚函数机制和继承实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了<code>virtual</code>关键字的函数，在子类中重写时候不需要加<code>virtual</code>也是虚函数。<strong>因此面向对象的多态特征是指类型在之前是不能确定，只有运行到它的时候才能确定实际的类型。</strong></li>
</ul></li>
</ul>
<h5 id="静态联编和动态联编">2.1.1 静态联编和动态联编</h5>
<ul>
<li><strong>静态联编：</strong>编译器会根据函数调用的对象类型,在编译阶段就确定函数的调用地址，这就是静态联编（早绑定）</li>
<li><p><strong>动态联编：</strong>在普通成员函数前面加<code>virtual</code>，该函数变为虚函数，是告诉编译器这个函数要晚绑定，在运行阶段才确定调用哪个函数（晚绑定），</p></li>
<li><p>1.子类转换成父类（向上转换）：编译器认为指针的寻址范围缩小了，所以是安全的</p></li>
<li><p>2.父类转换成子类（向下转换）：编译器认为指针的寻址范围扩大了，不安全</p></li>
</ul>
<h4 id="struct和class的区别struct和union的区别">2.2 struct和class的区别、struct和union的区别</h4>
<p><strong>相同点</strong></p>
<ul>
<li>两者都拥有成员函数、公有和私有部分</li>
<li>任何可以使用class完成的工作，同样可以使用struct完成</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><p>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p></li>
<li><p>class默认是private继承， 而struct默认是public继承</p></li>
</ul>
<p><strong>引申：C++和C的struct区别</strong></p>
<ul>
<li><p>C语言中：struct是用户自定义数据类型（UDT）；<code>C++</code>中struct是抽象数据类型（ADT），支持成员函数的定义，（<code>C++</code>中的struct能继承，能实现多态）</p></li>
<li><p>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数</p></li>
<li><p>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</p></li>
<li><p>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）<code>;C++</code>中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在<code>C++</code>中被当作类的一种特例</p></li>
</ul>
<h5 id="struct和union的区别">2.2.1 struct和union的区别</h5>
<ul>
<li><p>1.在存储多个成员信息时，编译器会自动给struct第个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。</p></li>
<li><p>2.都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。</p></li>
<li><p>3.对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。</p></li>
<li><p>4.<code>sizeof</code>一个结构体是其所有成员依据内存对齐后的结果；<code>sizeof</code>一个联合体是其最大成员的大小</p></li>
</ul>
<h4 id="c中为什么要有this指针哪些地方用到">2.3 C++中为什么要有this指针，哪些地方用到</h4>
<p><code>this</code>指针，它指的是对于类的内部成员函数，其参数列表的第一若不显式写出总是隐藏有一个<code>this</code>指针:</p>
<ul>
<li><strong><em>成员函数this指针：成员函数通过一个名为this的隐式参数来访问调用它的那个对象</em></strong>。<code>this</code>指针是一个指向当前对象的指针，或者说当前对象的地址。</li>
<li><strong>this指针只能在一个类的非静态成员函数中使用（全局函数、静态函数不能使用）</strong>。</li>
<li>C++的非静态成员函数的第一个默认并且被隐藏的参数是<code>T *const register this</code>。比如我们在<code>Student</code>这个类里声明这样一个函数：<code>int SetName(const char *name)</code>;其实编译器处理的时候会变为 <code>int SetName(Student *const register this, const char *name)</code>;</li>
</ul>
<h4 id="为什么要继承继承会有什么问题如何解决">2.4 为什么要继承，继承会有什么问题，如何解决？</h4>
<p>在面向对象的编程语言中，继承是极其重要的一个特性，这是因为通过继承：</p>
<ul>
<li>一是能够通过继承提高代码的复用性。在继承的基础上，子类能够复用父类的代码，并且能够在父类的代码基础上进行重写和功能扩展</li>
<li>二是继承是实现多态的必要条件之一，没有继承，那么多态的就无法实现，通过继承我们才能实现基类指针指向子类对象，在运行阶段才确定类型。</li>
</ul>
<h5 id="菱形继承问题">2.4.1 菱形继承问题</h5>
<p>继承当中存在菱形继承问题，所谓的菱形继承是指，比如我有基类<code>A</code>，子类<code>B</code>和<code>C</code>都继承于<code>A</code>，并在<code>A</code>的基础上实现一些自己的功能扩展，现在又有一个子类<code>D</code>，子类<code>D</code>为了能够得到B和C当中独有的方法，它要进行多继承，即继承<code>B</code>和<code>C</code>.如下图所示： <img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/lengxing.png" width="700"></p>
<p>那么这种继承就带来一个问题，由于<code>B</code>和<code>C</code>分别都继承于<code>A</code>，那么D就会重复继承于<code>A</code>，那么<code>D</code>会有来自<code>A</code>的两份拷贝。这不仅会占用不必要的存储空间，也会造成命名冲突。</p>
<ul>
<li><strong>虚继承：继承方式前面加上 <code>virtual</code>关键字就是虚继承</strong>。虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。 <strong>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类<code>（Virtual Base Class）</code>，本例中的<code>A</code> 就是一个虚基类</strong></li>
</ul>
<p>在C++中就存在虚继承关系的类：</p>
<p><img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/xujucheng.png" width="700"></p>
<ul>
<li><strong>原理：</strong>虚继承底层实现原理与编译器相关，一般通过<strong>虚基类表指针<code>vbptr</code>和虚基类表实现</strong>，每个虚继承的子类都有一个虚基类表指针（占用一个指针的存储空间）和虚基类表（虚基类表在只读数据端内所以不占用类对象的存储空间，）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类表指针也会被继承，其指向虚基类表。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">        虚继承（虚基类） </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 基类A  </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="type">int</span> dataA;  </span><br><span class="line">    &#125;;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="type">int</span> dataB;  </span><br><span class="line">    &#125;;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="type">int</span> dataC;  </span><br><span class="line">    &#125;;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="type">int</span> dataD;  </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面展示了无虚继承和有虚继承时的情况类D的内存消耗：(32位系统指针大小为4)24字节，注意有两个虚基类表指针。当<code>A</code>的数据多时，能够节省内存空间 <img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/vbptr.png" width="700"></p>
<blockquote>
<p>虚函数表指针、虚函数表和虚基类表指针、虚基类表是两码事，不要搞混，但它们的实现原理是相似的。 因此，对拥有虚函数表指针和虚基类表指针的类其会多消耗两个指针空间的大小</p>
</blockquote>
<h4 id="什么是纯虚函数作用">2.5 什么是纯虚函数，作用</h4>
<p>纯虚函数是指在类中用<code>virtual</code>修饰，并用<code>=0</code>做声明的函数，即形式像<code>virtual coid func()=0;</code>的函数，这种虚函数就是纯虚函数。</p>
<p>纯虚函数指示该函数并未定义，那么就指定该类不能被实例化，话句话说就是有纯虚函数的的类就是抽象基类，抽象基类不能实例化对象，必须通过继承重所有的纯虚函数后才能实例化对象。因此由纯虚函数构成的类只起到声明作用，告诉编程人员后续的继承工作要实现这些纯虚接口。因此纯虚函数更像是提供了一个模板规范，需要编程者自己实现逻辑功能</p>
<h4 id="c空类默认函数">2.6 C++空类默认函数</h4>
<p>在CPP类中存在一些合成的默认行为：</p>
<ul>
<li>如果没有显示的定义任何构造函数，也没有声明构造函数是删除的，那么就会合成默认的构造函数，该合成默认构造函数每有参数。</li>
<li>如果没有实现拷贝构造函数，也没有声明是删除的，那么也会合成默认的拷贝构造函数</li>
<li>与拷贝构造函数一样，在没有定义自己的拷贝运算符时，编译器会生成一个合成拷贝赋值运算符。</li>
<li>如果没有显示定义析构函数，编译器会为它定义一个合成析构函数。</li>
</ul>
<p>在上面中是类中的一些默认合成的规则，但有时候也会存在合成拷贝赋值运算符会禁止该类型对象的赋值，这就要提到CPP中的<code>三五发法则</code>，三是指<strong>拷贝构造、拷贝赋值和析构</strong>,五是在三的基础上还有<strong>移动构造函数和移动赋值函数</strong></p>
<p>一般来说，规范的编程中，在CPP的类中不是满足三就是满足五:</p>
<ul>
<li>当析构没有时，无法释放，那么其他的构造函数必定都是删除的，即禁止该对象进行拷贝、移动操作</li>
<li>当有移动时，规范的类必是处于五法则，即5个构造函数都实现，能够拷贝、移动也能释放</li>
<li>当有拷贝是，不是处于三就是处于五法则</li>
</ul>
<h4 id="深拷贝和浅拷贝">2.7 深拷贝和浅拷贝</h4>
<ul>
<li><p><strong>浅拷贝</strong>：浅拷贝是指在拷贝的过程中只是做简单的赋值操作，并未开辟新的内存空间。新变量和旧变量都指向的是一个内存区域，这样就会带来一个问题，那就是当多个纤拷贝构造函数，析构时会多次释放同一个分配的内存空间，这是不被编译器所运行的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> age)&#123;</span><br><span class="line">		pName=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName,name);</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Student</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(pName);</span><br><span class="line">			pName=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;小明&quot;</span>，<span class="number">22</span>)</span>；</span></span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;		<span class="comment">//执行默认拷贝构造函数</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>深拷贝：解决浅拷贝带来的问题就是使用深拷贝，在拷贝过程中申请自己的内存空间，把值存 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> Student &amp;stu)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//1.申请空间</span></span><br><span class="line">	pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(stu.pName) + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//2.拷贝数据</span></span><br><span class="line">	<span class="built_in">strcpy</span>(pName, stu.pName);</span><br><span class="line">	age = stu.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="封装特征封装整体的目的是">2.8 封装特征，封装整体的目的是</h4>
<ul>
<li><p><strong>封装：</strong>每个对象够包含它能进行操作所需的所有信息，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。在CPP中涉及封装的三个关键字有<code>pibilc\private\protected</code></p></li>
<li><strong>封装的目的：</strong>
<ul>
<li>(1)封装是对象的一种隐藏技术，其目的是将对象中的属性和方法组织起来。同时隐藏不想暴露的属性和方法及实现细节。</li>
<li>(2)用户或其它对象不能看到也无法修改其实现。只能通过接口去调用对象的方法，达到互相通信的目的。</li>
<li>(3)封装的目的在于将设计者与使用者分开。使用者不必知道实现的细节，只需要设计者提供的方法来访问对象。</li>
</ul></li>
<li><strong>封装的好处 ：</strong>
<ul>
<li>(1)良好的封装能减少耦合。</li>
<li>(2)类内部的实现可以自由地修改。</li>
<li>(3)类具有清晰的对外接口。</li>
</ul></li>
</ul>
<h5 id="继承当中的pibilcprivateprotected限定词">2.8.1 继承当中的<code>pibilc\private\protected</code>限定词</h5>
<p>派生类需要使用类派生列表来指出它是从哪个基类继承而来的，每个基类前面可以有三种访问说明符<code>public、private、protected</code>中的一个。它们不会对基类造成影响，这是限定该继承的子类：</p>
<ul>
<li><strong><code>pubulic</code>：子类的封装程度同基类一样</strong></li>
<li><strong><code>protected</code>：如果基类当中存在<code>public</code>修饰的变量或函数，那么在子类当中会成为<code>protected</code>，<code>protected\private</code>不会改变</strong></li>
<li><strong><code>private</code>：如果基类当中存在<code>public\proteced</code>修饰的变量或函数，那么在子类当中会成为<code>private</code>，<code>private</code>不会改变</strong></li>
</ul>
<p>即继承的三个访问说明符是限制子类的变量和函数，它们的可访问程度是依次递减调整的。</p>
<h4 id="析构函数调用时机">2.9 析构函数调用时机</h4>
<ul>
<li>对象生命周期结束被销毁时</li>
<li>delete指向对象的指针时，或者delete指向对象的基类类型的指针，而基类析构函数是虚函数</li>
<li>对象<code>A</code>是对象<code>B</code>的成员，<code>B</code>的析构函数被调用时，对象<code>A</code>的析构函数也会被调用</li>
</ul>
<p><strong>什么时候调用析构函数：</strong></p>
<ul>
<li>无论何时一个对象被销毁，就会自动调用其析构函数</li>
<li>变量离开作用域时被销毁</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器被销毁时，其元素被销毁</li>
<li>对于动态分配对象，当指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<h4 id="构造函数和析构函数再有子类情况下子类的构造和析构顺序">2.10 构造函数和析构函数再有子类情况下，子类的构造和析构顺序</h4>
<ul>
<li><strong>构造函数</strong>：先执行父类的构造，再执行子类的构造</li>
<li><strong>析构函数</strong>：先执行子类析构，再执行父类析构</li>
</ul>
<h4 id="c的多态机制实现原理虚函数和虚表">2.10 c++的多态机制实现原理（虚函数和虚表）</h4>
<p>谈到多态，多态的实现主要分为<strong>静态多态和动态多态</strong>，<strong>静态多态主要是重载和模板</strong>，在编译的时候就已经确定；<strong>动态多态是用虚函数机制实现的</strong>，在运行期间动态绑定。</p>
<ul>
<li><p><strong>多态：</strong>动态多态是面向对象的一大特性，CPP中多态指的是指针所指向的的类型在编译时候是无法确定的，只有在运行的时候才能确定，执行的是动态绑定的机制，即同一个操作作用于不同的对象，可以有不同的解释，会产生不同的效果，这就是多态。多态的应用场景，举个例子就是一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</p></li>
<li><strong>实现原理：</strong>多态的实现原理依赖于<strong>继承</strong>和<strong>虚函数</strong>。 在有虚函数的类中，类的最开始部分都会维护一个<strong>虚函数表指针<code>vptr</code></strong>，这个指针指向一个虚函数表(该虚函数表存储在只读数据端中），表中放了虚函数的地址（虚函数指针），实际的虚函数在代码段<code>.text</code>中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。 <img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/vptr.png" width="300"></li>
<li><strong>作用：</strong>
<ul>
<li>可以解决项目中的紧耦合问题,提供程序的可扩展性</li>
<li>应用程序不必为每一个子类的功能调用编写代码，只需要对抽象的父类进行处理，这样能够更好的实现接口重用</li>
</ul></li>
<li><strong>条件</strong>：
<ul>
<li>有继承</li>
<li>重写父类的虚函数</li>
<li>父类指针或引用指向子类对象</li>
</ul></li>
</ul>
<h4 id="重载重写和多态区别实现机制">2.11 重载、重写和多态区别，实现机制。</h4>
<ul>
<li><strong>重载</strong>：是指在同一范围定义中的同名成员函数才存在重载关系。主<strong>要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同</strong>。也不能仅仅依靠返回值不同来区分的函数，<strong>说到底就是函数名一样，参数个数或类型不同就是重载，返回值没有要求，可相同也可不同</strong>。重载和函数成员是否是虚函数无关。举个例子： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>重写</strong>：重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要<strong>求基类函数必须是虚函数且，在CPP中可用<code>override</code>进行标志该函数是重写函数</strong>
<ul>
<li>与基类的虚函数有相同的参数个数</li>
<li>与基类的虚函数有相同的参数类型</li>
<li>与基类的虚函数有相同的返回值类型</li>
</ul></li>
<li><strong>重载与重写的区别：</strong>
<ul>
<li>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</li>
<li>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</li>
<li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li>
</ul></li>
<li><strong>隐藏（hide）</strong>：隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：
<ul>
<li><p>两个函数参数相同，但是基类函数不是虚函数。<strong>和重写的区别在于基类函数是否是虚函数</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//隐藏父类的fun函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//隐藏父类的fun函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* a)</span></span>&#123;</span><br><span class="line">	   cout &lt;&lt; <span class="string">&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h4 id="构造函数能不能是虚函数什么函数为建议为虚函数什么函数不能为虚">2.12 构造函数能不能是虚函数（什么函数为建议为虚函数，什么函数不能为虚）</h4>
<p>我们知道，<strong>每个有虚函数的类都有属于自己的虚函数表<code>vtbl</code>，虚函数表在编译器构建好。当我们的派生类重写了虚函数，那么在虚表中就会替换掉父类的虚函数指针为子类的虚函数指针。当我们创建一个对象时，会在对象的内存模型中有自己的指向虚表的指针<code>vtpr</code>，对象通过虚表才知道调用的是哪一版本的虚函数</strong> <img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/vtpr.png" width="500"></p>
<p>如果构造函数是虚函数,那么也会如上面的机制一样在虚表有一个指向自己构造函数版本的虚函数指针。现在有两个类<code>A</code>和<code>B</code>,<code>B</code>是<code>A</code>的派生类，在构造<code>B</code>的对象的时候发现继承于<code>A</code>的部分要先构造，它就要求调用<code>A</code>的构造函数，但是这些构造函数已经是虚函数了，而虚表指针必须是在构造一个对象的时候分配了内存才能得到，而你正在调用构造函数，<strong>这就陷入了一个矛盾的处境：你要用虚表指针<code>vtpr</code>去调用构造函数，而虚表指针<code>vtpr</code>只有当年调用构造申请了内存后才能得到，这形成了一个死结。</strong></p>
<blockquote>
<p><strong>附加：<code>vptr</code>的初始化工作早于构造函数中的初始化列表</strong></p>
</blockquote>
<h5 id="什么函数建议为虚函数什么函数不能为虚">2.12.1 什么函数建议为虚函数，什么函数不能为虚</h5>
<ul>
<li>析构函数我们都会在有继承的时候定义为虚函数，这是因为这样在动态晚绑定的时候才能准确的知道是析构哪个类的对象，调用哪个子类的析构函数去释放内存。</li>
<li>构造函数不能为虚函数、普通非成员函数不能为虚函数、内联<code>inline</code>函数蹦年为虚函数、静态成员函数不能为虚函数，友元函数不能为虚函数</li>
</ul>
<h4 id="为什么拷贝构造函数的参数要为引用">2.13 为什么拷贝构造函数的参数要为引用</h4>
<p><strong>因为在函数调用中，非引用类型的的参数要进行拷贝初始化；函数返回一个非引用类型，调用方的返回结果也是一个拷贝，所以拷贝函数此时被用来初始化非引用类型的数据。如果拷贝构造函数的参数不是引用类型都是类型形参，为获得它的实参，那么它自身就会无限的调用自身的死循环</strong>。P（442）</p>
<h4 id="inline能不能是虚函友元函数呢">2.14 inline能不能是虚函、友元函数呢</h4>
<p><strong>不能！</strong>，这是因为</p>
<ul>
<li>内联函数的存在是为了省掉函数调用时的开销，它会在编译的时候进行展开，二虚函数的实现是为了多态进行运行时的晚绑定。即内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后进行晚绑定，在运行时对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的邦定函数）</li>
<li>因为友元函数（友元类）是不能被继承的（没有传递性）、是单向的，对于没有继承这一特性的函数来说没有虚函数这一种说法。</li>
<li>普通函数（非成员函数）只能被<code>overload</code>，不能被<code>override</code>，声明为虚函数也没有什么意思，因此编译器会在编译时邦定函数。</li>
</ul>
<h4 id="什么是静态联编和动态联编">2.15 什么是静态联编和动态联编</h4>
<ul>
<li><strong>静态联编：</strong>编译器会根据函数调用的对象类型,在编译阶段就确定函数的调用地址，这就是静态联编（早绑定）</li>
<li><p><strong>动态联编：</strong>在普通成员函数前面加<code>virtual</code>，该函数变为虚函数，是告诉编译器这个函数要晚绑定，在运行阶段才确定调用哪个函数（晚绑定），</p></li>
<li><p>1.子类转换成父类（向上转换）：编译器认为指针的寻址范围缩小了，所以是安全的</p></li>
<li><p>2.父类转换成子类（向下转换）：编译器认为指针的寻址范围扩大了，不安全</p></li>
</ul>
<h4 id="说一下初始化列表">2.16 说一下初始化列表</h4>
<ul>
<li><strong>初始化列表</strong>：冒号和花括号之间的部分。其负责为新创建的对象的一个或几个数据成员进行初始化。列表是是类内置成员的名字，其()括号内就为初始值（注意不是赋值而是初始化）。</li>
<li><strong>注意：列表对成员变量的初始化是按其类内声明顺序初始化，而不是列表顺序</strong>。</li>
<li><strong>使用初始化列表是直接初始化,因此具有更高的效率，而在函数体内是先初始化再赋值。存在效率的差异，如果是类对象，那么效率更低</strong></li>
<li>构造函数的初始值列表解决了初始值必不可少的三种情况：
<ul>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况1\2</span></span><br><span class="line">Class  Test&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Test</span>(<span class="type">int</span> ii);	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> ci;		<span class="comment">//未被初始化</span></span><br><span class="line">		<span class="type">int</span> &amp;ri;			<span class="comment">//未被初始化</span></span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> cr=<span class="number">10</span>;	<span class="comment">//已类内初始化</span></span><br><span class="line">&#125;;</span><br><span class="line">Test:<span class="built_in">Test</span>(<span class="type">int</span> ii)&#123;</span><br><span class="line">	i=ii;</span><br><span class="line">	ci=ii;		<span class="comment">//错误，不能给const赋值</span></span><br><span class="line">	ri=i;			<span class="comment">//错误，引用必须创建时被初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化。<strong>进入构造函数后，<code>test</code>就会首先被默认初始化然后赋值</strong>，但是Test类没有默认的构造函数从而出现错误，所以初始化只能放在列表中。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;	<span class="comment">//无默认构造函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Test&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mytest</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mytest</span>():<span class="built_in">test</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#123;       <span class="comment">//初始化ok</span></span><br><span class="line">        <span class="comment">//test(Test(1,2,3));//error: no match for call to &#x27;Test()&#x27;</span></span><br><span class="line">        <span class="comment">//test=Test(12,3,4);//error: no matching function for call to &#x27;Test::Test()&#x27;</span></span><br><span class="line">        <span class="comment">//test(1,2,3);//error: no match for call to &#x27;Test()&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Test test; <span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="c和c的区别">2.17 C++和C的区别</h4>
<p>C++虽然是由C产生出来的，但是具有很多不同点：</p>
<ul>
<li>首先，C++是面向对象的编程语言，具有封装、继承和多态三大特性；而C是面向过程的结构化语言</li>
<li>C++中引入了许多关键字，比如用<code>new/delete</code>作为分配堆内存的的运算符，取代了C当中的<code>malloc</code>和<code>free</code>库函数</li>
<li>C++中使用<code>iostream</code>类库替代表中c中的<code>stdio</code>函数库</li>
<li><strong>在CPP中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是CPP可以重载，C语言不允许</strong></li>
<li>在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li>
<li>在C++中为了防止内存泄露，引入了三大智能指针模板类；为了类型安全，出来继续使用C当风格的强制类型转换以外，还引入了四中强制类型转换<code>const_cast、static_cast、dynamic_cast和reinterpret_cast</code></li>
<li>C++还增加了一些关键子如<code>auto、using、namespace</code>等</li>
</ul>
<h4 id="friend友元类和友元函数">2.18 friend友元类和友元函数</h4>
<p>在类中，我们通过封装修饰符<code>private/protected</code>修饰相应的成员变量和函数，告诉编译器这些变量和函数不能被外部访问，<strong>但是，在某些情况，我们又希望这些变量和函数对特定的某个类或函数是可访问的，这时候就用到了友元函数和友元类。</strong></p>
<ul>
<li>通过在类中声明<code>friend class xxx</code>告诉编译器，<code>xxx</code>类是该类的友类，可以访问任一类中的变量，它的形式就好像这个<code>xxx</code>类在该类中一样</li>
<li>通过在类声明<code>friend [returntype] funcName(args);</code>，告诉编译器<code>funcName</code>是友元函数</li>
</ul>
<p>因此对于友元其特性是：</p>
<ul>
<li><strong>能访问私有成员</strong></li>
<li>破坏封装性</li>
<li><strong>友元关系不可传递</strong></li>
<li><strong>友元关系的单向性</strong></li>
<li>友元声明的形式及数量不受限</li>
</ul>
<h4 id="模板类和类模板">2.19 模板类和类模板</h4>
<ul>
<li><p><strong>模板类</strong>：在编写中用<code>template</code>修饰，明白模板类他不是一个类，而是一个模板，只有实例化后的模板类才能是类。未实例化的模板类，编译器是无法知道其大小的，所以会略过编译。只有在实例化后，才会编译，在编译时会检查一些与模板无关的错误。同时，因为我们的编译器无法给为实例化的模板编译，如果把模板的声明放置<code>.h</code>，把实现发在<code>.cpp</code>文件，会发生链接错误，因为链接起找不到相应模板的实现，因为模板没有被实例化，当然也就找不到它的二进制文件。</p></li>
<li><p><strong>类模板</strong>：类模板就是实例化后的模板类，通过传入任意符合要求的类型，最后实例化成一个具体的类。</p></li>
</ul>
<h3 id="c知识面试版_stl容器">3. C++知识面试版_STL容器</h3>
<h4 id="vector为什么会迭代器失效">3.1 vector为什么会迭代器失效？</h4>
<h4 id="vector和list的区别">3.2 vector和list的区别</h4>
<h4 id="说一下map和set">3.3 说一下map和set。</h4>
<h4 id="红黑树了解吗说一下它的机制">3.4 红黑树了解吗，说一下它的机制</h4>
<h4 id="unordered_map和unordered_set呢">3.5 unordered_map和unordered_set呢</h4>
<h4 id="迭代器相关">3.6 迭代器相关</h4>
<h3 id="c知识面试版_c11新特性">4. C++知识面试版_c++11新特性</h3>
<h3 id="c知识面试版_并发">5. C++知识面试版_并发</h3>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C#基础</title>
    <url>/2023/03/23/C-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>C++并发编程(一):简介与线程</title>
    <url>/2023/02/19/C-%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p><strong>读者注意：本博客是关于C++11新标准下的并发和多线程编程(C++多线程有C++11、Boost线程库和POSIX多线程三大版本) </strong></p>
<ul>
<li>POSIX的线程相关更多的是函数形式，这也理所当然，因此底层是C</li>
<li>C++标准多线程和Boost线程是类形式，这点要注意。</li>
</ul>
<h3 id="概览">1 概览</h3>
<h4 id="认识并发">1.1 认识并发</h4>
<p>如下图，<strong>在单核处理器中我们可看到AB两任务是以“这个任务做一会，再切换到别的任务，再做一会儿”的方式，让任务看起来是并行执行的</strong>。这种方式称为“任务切换(task switching)”。但是，实际上是并发形式的，因为任务切换得太快，以至于无法感觉到任务在何时会被暂时挂起 <img src="/2023/02/19/C-%E5%B9%B6%E5%8F%91/computer.png" width="500"> 系统每次从一个任务切换到另一个时都需要切换一次上下文(context switch)，任务切换也有时间开销。</p>
<span id="more"></span>
<ul>
<li>进行上下文的切换时，操作系统必须为当前运行的任务保存CPU的状态和指令指针，并计算出要切换到哪个任务，并为即将切换到的任务重新加载处理器状态。</li>
<li>然后，CPU可能要将新任务的指令和数据的内存载入到缓存中，这会阻止CPU执行任何指令，从而造成的更多的延迟</li>
</ul>
<h4 id="并发途径">1.2 并发途径</h4>
<ul>
<li><strong>多进程并发</strong>：应用程序分为多个独立的进程，它们在同一时刻运行，就像同时进行网页浏览和文字处理一样。
<ul>
<li>独立的进程需要通过进程间常规的通信渠道传递讯息(信号、套接字、文件、管道等等)。</li>
<li>运行多个进程所需的固定开销：需要时间启动进程，操作系统需要内部资源来管理进程，需要分配维护独立的一份进程内存。</li>
<li>进程并发一般不需要注意并发带来的安全问题，因为各个进程独立拥有自己的内存空间；</li>
</ul></li>
<li><strong>多线程并发</strong>：在单个进程中运行多个线程，线程各自允许自己的任务。
<ul>
<li><strong>进程中的所有线程都共享地址空间，并且所有线程能访问到大部分数据———全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。</strong></li>
<li>地址空间共享，因此使用多线程相关的开销远远小于使用多个进程。</li>
<li>但是这种线程间内存共享也有代价，当数据要被多个线程访问，那么程序员必须确保每个线程所访问到的数据是一致的，即要<strong>保证线程安全。</strong></li>
</ul></li>
</ul>
<h4 id="为何要使用并发">1.3为何要使用并发</h4>
<p>使用并发的两个主要原因就是使<strong>关注点分离(SOC)和提升性能</strong></p>
<ul>
<li><p><strong>分离关注点</strong>：通过将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能性。使得代码解耦合。</p></li>
<li><p><strong>提升性能：</strong>随着计算机的发展，现在的计算机中央处理单元CPU一般都是多核的，充分利用这种硬件资源能够很好的提升程序性能。</p></li>
</ul>
<p><strong><em>不使用并发场景</em></strong>：当<strong>发现<code>收益&lt;成本</code>时就不能使用。把新线程加入调度器、启动线程(线程的上下文切换)需要耗费CPU资源，当发现这些线程间的切换比处理时间还长，降低了效率，此时就不应该使用或者说不应该使用这么大熟练的线程。</strong>而且若你为每个线程分配一个1M的堆栈，只需要4098个线程就会用尽所有地址空间。</p>
<h4 id="与-c11-多线程相关的头文件">1.4 与 C++11 多线程相关的头文件</h4>
<h5 id="总览">1.4.1 总览</h5>
<p><strong>以下是C++的一些并发编程相关的特性和工具：</strong></p>
<ul>
<li><p>线程：C++11引入了线程库，允许开发人员创建和管理线程。通过线程库，开发人员可以创建、启动和停止线程，并在线程之间共享数据。</p></li>
<li><p>互斥量：互斥量是一种用于保护共享资源免受并发访问的机制。C++的互斥量可以通过std::mutex类来创建和管理，开发人员可以使用它来实现对共享资源的互斥访问。</p></li>
<li><p>条件变量：条件变量是一种线程间同步的机制，允许线程等待某个特定条件的出现。C++的条件变量可以通过std::condition_variable类来创建和管理，开发人员可以使用它来实现线程之间的通信。</p></li>
<li><p>原子操作：原子操作是一种线程间同步的机制，可以确保操作的原子性和可见性。C++的原子操作可以通过std::atomic类来创建和管理，开发人员可以使用它来实现对共享资源的原子操作。</p></li>
<li><p>Futures和Promises：Futures和Promises是一种异步编程的机制，允许开发人员在一个线程中执行一个操作，并在另一个线程中等待操作完成。C++的Futures和Promises可以通过std::future和std::promise类来创建和管理。</p></li>
<li><p>并行算法：C++标准库提供了一些并行算法，允许开发人员在多个线程上并行执行某些操作。其中一些算法包括std::for_each、std::accumulate、std::sort等。</p></li>
</ul>
<p>在并发编程时，开发人员需要特别注意避免数据竞争、死锁等问题，以确保程序的正确性和可靠性。</p>
<h5 id="头文件总览">1.4.2 头文件总览</h5>
<p>首先熟悉一下 C++11 的多线程模块的头文件吧。C++11 新标准中引入了多个头文件来支持多线程编程，他们分别是 <code>&lt;atomic&gt;</code>，<code>&lt;thread&gt;</code>，<code>&lt;mutex&gt;</code>，<code>&lt;condition_variable&gt;</code> 和 <code>&lt;future&gt;</code>。</p>
<ul>
<li><code>&lt;atomic&gt;</code>：该头文件用于原子操作，主要声明了两个类，<code>std::atomic</code> 和 <code>std::atomic_flag</code>，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</li>
<li><code>&lt;thread&gt;</code>：该头文件用于线程操作，主要声明了 <code>std::thread</code> 类，另外 <code>std::this_thread</code> 命名空间也在该头文件中，包含一些线程的操作函数。</li>
<li><code>&lt;mutex&gt;</code>：该头文件用于互斥量操作，主要声明了与互斥量相关的类，包括 <code>std::mutex</code> 系列类，<code>std::lock_guard</code>，<code>std::unique_lock</code>，以及其他的类型和函数。</li>
<li><code>&lt;condition_variable&gt;</code>：该头文件用于条件变量操作，主要声明了与条件变量相关的类，包括 <code>std::condition_variable</code> 和 <code>std::condition_variable_any</code>。</li>
<li><code>&lt;future&gt;</code>：该头文件用于异步调用操作，主要声明了 <code>std::promise</code>，<code>std::package_task</code> 两个 <code>Provider</code> 类，以及 <code>std::future</code> 和 <code>std::shared_future</code> 两个 <code>Future</code> 类，另外还有一些与之相关的类型和函数，<code>std::async()</code> 函数就声明在此头文件中。</li>
</ul>
<h3 id="线程管理">2 线程管理</h3>
<p>在本节主要讲述线程管理，涉及启动一个线程，等待这个线程结束，或放在后台运行；怎么给已经启动的线程函数传递参数，以及怎么将一个线程的所有权从当前<code>std::thread</code>对象移交给另一个。最后，再来确定线程数，以及识别特殊线程。线程头文件为<code>&lt;thread&gt;</code></p>
<h4 id="thread对象启动线程">2.1 thread对象:启动线程</h4>
<p><strong>线程在<code>std::thread</code>对象创建(为线程指定任务)时启动</strong>。即使用C++线程库启动线程，可以归结为构造 <code>std::thread</code> 对像。因此对于创建一个线程对象来说，可以调用不同的构造函数，因此这里不会做详细的构造函数阐述，只举示例,其构造函数如下：</p>
<table>
<thead>
<tr class="header">
<th>次序</th>
<th>构造函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>default (1)</code></td>
<td><code>thread() noexcept;</code></td>
</tr>
<tr class="even">
<td><code>initialization (2)</code></td>
<td><code>template explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;… args);</code></td>
</tr>
<tr class="odd">
<td><code>copy [deleted] (3)</code></td>
<td><code>thread (const thread&amp;) = delete;</code></td>
</tr>
<tr class="even">
<td><code>move (4)</code></td>
<td><code>thread (thread&amp;&amp; x) noexcept;</code></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>默认构造函数</strong>，创建一个空的 thread 执行对象。</li>
<li><strong>初始化构造函数，创建一个 thread 对象，该 thread 对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。</strong></li>
<li><strong>拷贝构造函数(被禁用)，意味着 thread 不可被拷贝构造。</strong></li>
<li><strong>move 构造函数</strong>，move 构造函数，调用成功之后 x 不代表任何 thread 执行对象。</li>
</ul>
<p>下面这个例子创建了一个<code>my_thread</code>多线程对象，传入的为可调用对象进去作为线程的处理函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">do_something</span>();</span><br><span class="line">	<span class="built_in">do_something_else</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">background_task f;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="启动线程时易错点">2.1.1 启动线程时易错点</h6>
<ul>
<li><p>注意，当把函数对象传入到线程构造函数时，需要避免下述的“语法解析”：<strong>如果你传入的是一个零时变量，而不是一个命名变量</strong>，C++会将器解析为函数声明，而不是创建类型对象 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(background_task())</span></span>;</span><br><span class="line"><span class="comment">//background_task()使用默认构造创建了一个background_task零时对象</span></span><br><span class="line"><span class="comment">//那么此时my_thread就会被解析为一个函数声明</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">((background_task()))</span></span>;	<span class="comment">//1</span></span><br><span class="line">std::thread my_thread&#123;<span class="built_in">background_task</span>()&#125;;	<span class="comment">//2</span></span><br><span class="line">background_task f;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;			<span class="comment">//3</span></span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">do_something();</span></span></span><br><span class="line"><span class="params"><span class="function">do_something_else();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;					 	<span class="comment">//4,使用lambda</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>启动了线程，在对象销毁之前必须明确是等待线程结束（join加入式）还是自主运行（detach分离式）。如果在<code>std::thread</code>对象销毁之前还没做出决定，<strong>整个程序</strong>会终止（<code>std::thread</code>的析构会调用<code>std::terminate</code>），<strong>因此，即便有异常存在，也必须确保线程能够在<code>join</code>或<code>detach</code>。</strong></p></li>
<li>如果采用分离式而不是加入式，必须保证线程结束之前可访问数据的有效性。比如下面这种情况是很糟糕的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清单2.1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>&amp; i;</span><br><span class="line">	<span class="built_in">func</span>(<span class="type">int</span>&amp; _i):<span class="built_in">i</span>(_i)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100000</span>;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">do_something_else</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">	<span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;		<span class="comment">//新线程对象，入口函数为func()</span></span><br><span class="line">	my_thread.<span class="built_in">detach</span>();			<span class="comment">//2. 不等待新线程的结束，采用分离式</span></span><br><span class="line">&#125;			<span class="comment">//3.调用线程到这里执行完毕退出</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面我们可看到，我们在函数<code>oops</code>创建线程，线程使用可调用对象作为线程的函数入口，线程处在运行式就会调用<code>do_something_else</code>。</li>
<li>因为新线程采用分离式，把么旧线程在执行完<code>oops</code>函数后就会退出，那么my_func对象就会被销毁，内部的成员变量i也就被销毁了,然而新线程还在运行中，此时调用发现<code>i</code>被销毁，访问<code>i</code>是一个未定义的行为。</li>
<li>解决方法：
<ul>
<li>编写代码时规避这样的易出错的地方，即避免主线程退出时，子线程正在调用主线程的局部变量做参数进入处理函数。</li>
<li>通过加入式的方式确保线程在函数退出前结束。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="join等待线程完成">2.2 join:等待线程完成</h4>
<p>如果需要等待线程，相关的 <code>std::thread</code> 实例需要使用join()回收线程。在这种情况下，因为原始线程会阻塞，那么在其生命周期中并没有做什么事，使得用一个独立的线程去执行函数变得收益甚微。因此但在实际编程中，原始线程要么有自己的工作要做；要么会启动多个子线程来做一些有用的工作，并等待这些线程结束</p>
<h5 id="特殊情况下的等待">2.2.1 特殊情况下的等待</h5>
<p>我们必须对一个还未销毁的 std::thread 对象使用<code>join()</code>或<code>detach()</code>。</p>
<p>如果想要分离一个线程，可以在线程启动后，直接使用<code>detach()</code>进行分离。如果打算等待对应线程，则需要细心挑选调用<code>join()</code>的位置</p>
<p>在上面我们提到，当采用join等待线程结束，但是调用前出现异常，join就会失败，必须处理这样的特殊情况：</p>
<ul>
<li><p>发生异常时，保证在异常处理中也能调用<code>join()</code>,一种方法时采用下述代码使用了 try/catch 块确保访问本地状态的线程退出后，函数才退出 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>; <span class="comment">// 定义在清单2.1中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">	<span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(...)</span><br><span class="line">	&#123;</span><br><span class="line">		t.<span class="built_in">join</span>(); <span class="comment">// 1</span></span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	t.<span class="built_in">join</span>(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>另一种是使用RAII机制(资源获取即初始化)，即提供一个类，在析构函数中使用join()： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span></span><br><span class="line">&#123;</span><br><span class="line">	std::thread&amp; t;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread&amp; t_)</span>:</span></span><br><span class="line"><span class="function">	t(t_)</span></span><br><span class="line"><span class="function">	&#123;</span>&#125;</span><br><span class="line">	~<span class="built_in">thread_guard</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t.<span class="built_in">joinable</span>()) <span class="comment">// 1</span></span><br><span class="line">		&#123;</span><br><span class="line">			t.<span class="built_in">join</span>(); <span class="comment">// 2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 拷贝构造和赋值声明为删除，避免类自动合成默认的，这样避免使得回收的线程赋值产生错误</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span>&amp;)=<span class="keyword">delete</span>; <span class="comment">// 3</span></span><br><span class="line">	thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="type">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>; <span class="comment">// 定义在清单2.1中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">	<span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">	<span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">	<span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<blockquote>
<p>RAII机制：RAII是C++语法体系中的一种常用的合理管理资源避免出现内存泄漏的常用方法。以对象管理资源，<strong>利用的就是C++构造的对象最终会被对象的析构函数销毁的原则</strong>。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源</p>
</blockquote>
<blockquote>
<p>优点 不需要显式地释放资源。 采用这种方式，对象所需的资源只在其生命期内始终保持有效。</p>
</blockquote>
<h4 id="detach后台运行线程">2.3 detach:后台运行线程</h4>
<ul>
<li><p>使用<code>detach()</code>会让线程在后台运行，这就意味着主线程不能与之产生直接交互.不会等待这个线程结束；如果线程分离，那么就不可能有 <code>std::thread</code> 对象能引用它，因为它已经于当前对象分离了，同样分离线程不能被<code>join</code>。因此<strong>通常称分离线程为守护线程(daemon threads)。</strong></p></li>
<li><p>不过C++运行库保证，当线程退出时，相关资源的能够正确回收，后台线程的归属和控制C++运行库都会处理</p></li>
<li><p>一般进行检查当线程对象使用t.<code>joinable()</code>返回的是<code>true</code>，就可以使用<code>t.detach()</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(do_background_work)</span></span>;	<span class="comment">//t是执行线程的对象，可分离</span></span><br><span class="line"><span class="built_in">assert</span>(t.<span class="built_in">joinable</span>())		<span class="comment">//t.joinable()返回true,t未分离</span></span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line"><span class="built_in">assert</span>(t.<span class="built_in">joinable</span>())		<span class="comment">//t.joinable()返回false,t已经分离</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="使用分离线程处理文档">2.3.1 使用分离线程处理文档</h5>
<p>试想如何能让一个文字处理应用同时编辑多个文档。无论是用户界面，还是在内部应用内部进行，都有很多的解决方法。虽然，这些窗口看起来是完全独立的，每个窗口都有自己独立的菜单选项，但他们却运行在同一个应用实例中。一种<strong>内部处理方式是，让每个文档处理窗口拥有自己的线程；每个线程运行同样的的代码，并隔离不同窗口处理的数据。如此这般，打开一个文档就要启动一个新线程。因为是对独立的文档进行操作，所以没有必要等待其他线程完成。因此，这里就可以让文档处理窗口运行在分离的线程上。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">edit_document</span><span class="params">(std::string <span class="type">const</span>&amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">open_document_and_display_gui</span>(filename);</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">done_editing</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		user_command cmd=<span class="built_in">get_user_input</span>();</span><br><span class="line">		<span class="keyword">if</span>(cmd.type==open_new_document)</span><br><span class="line">		&#123;</span><br><span class="line">			std::string <span class="type">const</span> new_name=<span class="built_in">get_filename_from_user</span>();</span><br><span class="line">			<span class="function">std::thread <span class="title">t</span><span class="params">(edit_document,new_name)</span></span>; <span class="comment">// 1</span></span><br><span class="line">			t.<span class="built_in">detach</span>(); <span class="comment">// 2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">process_user_input</span>(cmd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中如果用户选择打开一个新文档，为需要启动一个新线程去打开新文档①，并分离线程②。与当前线程做出的操作一样，新线程只不过是打开另一个文件而已。所以，<code>edit_document</code>函数可以复用，通过传参的形式打开新的文件</p>
<h4 id="向线程函数传递参数">2.4 向线程函数传递参数</h4>
<p>线程函数传递参数是在<code>std::thread</code> 构造函数中传递的，即线程对象创建时。</p>
<ul>
<li>当线程创建时，<code>std::thread</code>的参数都会拷贝到线程内存栈中（标准规定）。这种情况，当主线程使用<code>join()</code>时，不会出现任何情况，；<strong>但是当主线程使用<code>detach()</code>分离子线程时，旧必须保证子线程在完成线程间上下切换前（拷贝和类型转换前）主线程还未退出，否则会发生错误</strong></li>
<li>按地址传递的指针，虽然是拷贝，但是指向同一个内存地址，因此对于指针参数，自然能够改变原值，必须保证主线程要在子线程结束后退出，否则会导致访问一个悬空指针出现错误</li>
</ul>
<p>如下面代码就是上面提到的<code>detach</code>情况，因传入为<code>const char*</code>，若线程还未完成切换，主线程就退出了，那么在字面值转化成 std::string 对象之前崩溃(oops)，从而导致线程的一些未定义行为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i,std::string <span class="type">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">(<span class="type">int</span> some_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>]; <span class="comment">// 1</span></span><br><span class="line">	<span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%i&quot;</span>,some_param);</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,buffer)</span></span>; <span class="comment">// 2</span></span><br><span class="line">	t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i,std::string <span class="type">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">not_oops</span><span class="params">(<span class="type">int</span> some_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%i&quot;</span>,some_param);</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,std::string(buffer))</span></span>; <span class="comment">// 使用std::string，避免悬垂指针</span></span><br><span class="line">	t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>标准约定std::thread构造时向函数对象传递实际参数的拷贝（支持移动语义），而不是转发实际参数。即fun的形式参数是被a拷贝初始化的引用，而不是a的引用，所以形式参数a并不是main函数内a的引用，在fun内赋值自然不会改变main函数内a的值。<strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a =<span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a =<span class="number">0</span> ;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(fun,a)</span> </span>;</span><br><span class="line">    t.<span class="built_in">join</span> () ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </strong>如果你希望像c++以往“以引用的方式传参”，常用解决方案之一是使用<code>std::ref</code>，即<code>std::thread(fun, std::ref(a))</code>;。参数要拷贝到线程独立内存中是默认的，即使参数是引用的形式，也可以在新线程中进行访问。但必须保证a在子线程执行完前a未被销毁** <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时fun函数收到就是a的引用，而不是a拷贝初始化的引用，能够改变院长</span></span><br><span class="line">std::<span class="built_in">thread</span>(fun, std::<span class="built_in">ref</span>(a));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="线程传递局部参数">2.5.1 线程传递局部参数</h4>
<p>如果要给各个线程传递局部参数，<code>thread::local_data</code> 是 C++20 新增的一个类模板，它提供了一种在多线程程序中为每个线程分配私有数据的方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="keyword">thread_local</span> <span class="type">int</span> local_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    local_data += <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; local_data: &quot;</span> &lt;&lt; local_data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_func, <span class="string">&quot;A&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_func, <span class="string">&quot;B&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序创建了两个线程，它们都调用了 <code>thread_func</code> 函数。在 <code>thread_func</code> 中，我们对 <code>local_data</code> 进行了自增并输出了当前线程的 <code>local_data</code> 值。由于 <code>local_data</code> 是使用 <code>thread_local</code> 修饰的，因此每个线程都会有一个独立的拷贝。</p>
<blockquote>
<p>需要注意的是，<code>thread_local</code> 变量的初始化是延迟的。这意味着在首次访问变量之前，它不会被初始化。这个特性有时候会带来一些麻烦，需要特别注意。 此外，由于 <code>thread_local</code> 变量的生命周期与线程相同，因此需要注意避免出现悬垂指针的情况。</p>
</blockquote>
<h4 id="转移线程所有权move">2.5 转移线程所有权<code>move</code></h4>
<p>转移线程所有权是指<code>std::thread</code>支持移动<code>std::move</code>.执行线程的所有权可以在 <code>std::thread</code> 实例中移动，下面将展示一个例子。例子中，创建了两个执行线程，并且在 <code>std::thread</code> 实例之间(t1,t2和t3)转移所有权：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>; <span class="comment">// 1</span></span><br><span class="line">std::thread t2=std::<span class="built_in">move</span>(t1); <span class="comment">// 2</span></span><br><span class="line">t1=std::<span class="built_in">thread</span>(some_other_function); <span class="comment">// 3</span></span><br><span class="line">std::thread t3; <span class="comment">// 4</span></span><br><span class="line">t3=std::<span class="built_in">move</span>(t2); <span class="comment">// 5</span></span><br><span class="line">t1=std::<span class="built_in">move</span>(t3); <span class="comment">// 6 赋值操作将使程序崩溃</span></span><br></pre></td></tr></table></figure>
<p><strong>详解：</strong></p>
<ul>
<li><strong>首先<code>t1</code>与执行<code>some_function</code>的启动线程相关联</strong></li>
<li>然后执行<code>std::move(t1)</code>后将<code>t1</code>的所有权给了<code>t2</code>，<code>t1</code>此时没有任何关联启动线程</li>
<li>接着<code>t1</code>接受零时启动线程<code>std::thread(some_other_function)</code></li>
<li>然后使用默认构造函数创建了一个<code>t3</code>线程对象，<code>t3</code>与任何执行线程都没有关联</li>
<li>接着<code>t2</code>将<code>some_function</code>的执行线程给了<code>t3</code>，截至目前以前正常，<code>t1</code>关联<code>some_other_function</code>执行线程，而<code>t2</code>未关联，<code>t3</code>关联刚刚拿到的<code>some_function</code>的执行线程</li>
<li>第⑥步发送错误，因此<code>t1</code>已经关联了<code>some_other_function</code>,又想把<code>some_function</code>的执行线程给它，就会发送错误</li>
</ul>
<h4 id="查看线程数量和线程标识id">2.6 查看线程数量和线程标识id</h4>
<ul>
<li><code>std::thread::hardware_concurrency()</code>在新版C++标准库中是一个很有用的函数。<strong>这个函数将 返回能同时并发在一个程序中的线程数量</strong></li>
<li><p>线程标识类型是 <code>std::thread::id</code> ，可以通过两种方式进行检索。第一种，可以通过调用 <code>std::thread</code>对象的成员函数<code>get_id()</code> 来直接获取。如果 <code>std::thread</code> 对象没有与任何执行线程相关联， <code>get_id()</code> 将返回<code>std::thread::type</code> 默认构造值，这个值表示“没有线程”。</p></li>
<li><p>第二种，当前线程中调用 <code>std::this_thread::get_id()</code> (这个函数定义在<code>&lt;thread&gt;</code>头文件中)也可以获得线程标识。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line">std::thread::<span class="built_in">hardware_concurrency</span>();	<span class="comment">//1</span></span><br><span class="line">std::this_thread::<span class="built_in">get_id</span>()				<span class="comment">//`</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(func,x)</span></span>;</span><br><span class="line">std::thread::id t_id=x.<span class="built_in">get_id</span>();		<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h4 id="其他函数">2.7 其他函数</h4>
<p>除了 <code>join，detach，joinable</code> 之外，<code>std::thread</code> 头文件还在 <code>std::this_thread</code> 命名空间下提供了一些辅助函数：</p>
<ul>
<li><code>get_id</code>: 返回当前线程的 id</li>
<li><code>yield</code>: 函数让出当前线程的执行权，让其他线程运行,即告知调度器运行其他线程，可用于当前处于繁忙的等待状态</li>
<li><code>sleep_for</code>：给定时长，阻塞当前线程</li>
<li><code>sleep_until</code>：阻塞当前线程至给定时间点</li>
</ul>
<p>其中 <code>yield</code> 是一个特殊的“线程睡眠”函数：</p>
<ul>
<li><p><code>std::this_thread::yield()</code> 是将当前线程所抢到的 CPU ”时间片A”让渡给其他线程(其他线程会争抢”时间片A”，注意。此时”当前线程”不参与争抢。等到其他线程使用完”时间片A”后，再由操作系统调度，当前线程再和其他线程一起开始抢 CPU 时间片。</p></li>
<li><p>如果将<code>std::this_thread::yield()</code> 上述语句修改为: <code>return</code>;，则将未使用完的 CPU ”时间片A”还给操作系统，再由操作系统调度，当前线程和其他线程一起开始抢CPU时间片。</p></li>
</ul>
<p><strong>因此 <code>yield</code> 使用的场景就是当当前线程运行条件不满足时调用，避免一个线程频繁与其他线程争抢 CPU 时间片, 从而导致多线程处理性能下降</strong>。sleep_for 也是让线程等待，需要等待若干时间</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程(三):同步</title>
    <url>/2023/03/04/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%89-%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="condition_variable同步">1 condition_variable：同步</h3>
<p>上面的互斥锁只是在共享数据处执行保护操作，但是数据的同步，即线程对数据的操作的先后次序并不确定，当我们还想对线程同步时，必须采取一定的同步操作。条件变量是达到这个目的方法。</p>
<p>C++标准库对条件变量有两套实现：</p>
<ul>
<li><code>std::condition_variable</code>和 <code>std::condition_variable_any</code> 。这两个实现都包含在<code>&lt;condition_variable&gt;</code>头文件的声明中。两者都需要与一个互斥量一起才能工作(互斥量是 为了同步)
<ul>
<li>前者仅限于与<code>std::mutex</code>一起工作，</li>
<li>而后者可以和任何满足最低标准的互斥量一起工作，从而加上了<code>_any</code>的后缀，因此从体积、性能，以及系统资源的使用方面产生额外的开销.</li>
<li>所以 <code>std::condition_variable</code> 一般作为首选的类型，当对灵活性有硬性要求时，我们才会去考虑 <code>std::condition_variable_any</code></li>
</ul></li>
</ul>
<span id="more"></span>
<p>在上面的例子中，10 个线程被同时唤醒，因此打印的时候是乱序的。值得注意的是 <code>while(!ready)</code>，实际上，正常情况下，<code>cv.wait</code> 只会被调用一次，然后等待唤醒，因为线程在调用 wait() 之后就被阻塞了。但是通过一个 <code>while</code> 循环来判断全局标志位是否正确，这样可以防止被误唤醒，这也是条件变量中的常见写法。</p>
<h4 id="接口概览">1.1 接口概览</h4>
<h5 id="构造函数">1.1.1 构造函数</h5>
<p><code>std::condition_variable</code> 的拷贝构造函数被禁用，只提供了默认构造函数。</p>
<h5 id="wait操作">1.1.2 wait操作</h5>
<p><code>std::condition_variable</code> 提供了两种 <code>wait()</code> 函数，一个是不带条件的，一个是可传入条件，通常为lambda表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无条件等待</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">//有条件等待</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>当线程调用<code>wait (unique_lock&lt;mutex&gt;&amp; lck)</code>时，当前线程会阻塞并释放当前获得的锁<code>lck</code>,以提醒其他线程可以获得这个自由锁了。因此对于<code>wait (unique_lock&lt;mutex&gt;&amp; lck)</code>只要一调用就会阻塞，那么在外部必须给它价格条件判断，判断线程是否执行<code>wait</code></li>
<li><p>而<code>wait (unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</code>是当<code>pred</code>返回<code>false</code>时线程会阻塞，即其自带了条件判断，我们只需传入即可。</p></li>
<li><p>另外，当阻塞在wait的线程被唤醒时，会再次获得相应的锁。</p></li>
</ul>
<blockquote>
<p>注意<code>wait()</code>函数一定要搭配<code>unique_lock类模板使用，而不是</code>lock_guard<code>。这是因为</code>lock_guard<code>在线程调用wait阻塞时，不会自动释放当前线程所获的的锁，这样就会导致死锁的发生。</code>unique_lock`是一个灵活性的锁机制</p>
</blockquote>
<blockquote>
<p>和<code>mutex</code> 的 <code>lock</code>类似，<code>std::condition_variable</code> 也提供了相应的两种（带 <code>Predicate</code> 和不带<code>Predicate</code>） <code>wait_for()</code> 函数，与 <code>std::condition_variable::wait()</code> 类似，不过 <code>wait_for</code> 可以指定一个时间段，在当前线程收到通知或者指定的时间超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，<code>wait_for</code> 返回，剩下的处理步骤和 <code>wait()</code> 类似。还有 <code>wait_util()</code>，用法也类似</p>
</blockquote>
<h5 id="notify-操作">1.1.3 notify 操作</h5>
<ul>
<li><p><code>std::condition_variable::notify_one()</code></p>
<p>唤醒某个等待（<code>wait</code>）线程。如果当前没有等待线程，则该函数什么也不做，如果同时存在多个等待线程，则唤醒某个线程是不确定的（<code>unspecified</code>）。</p></li>
<li><p><code>std::condition_variable::notify_all()</code> 唤醒所有的等待（wait）线程。如果当前没有等待线程，则该函数什么也不做。</p></li>
</ul>
<h4 id="示例">1.2 示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mut;</span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue; <span class="comment">// 1</span></span><br><span class="line">std::condition_variable data_cond;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		data_chunk <span class="type">const</span> data=<span class="built_in">prepare_data</span>();</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">		data_queue.<span class="built_in">push</span>(data); <span class="comment">// 2</span></span><br><span class="line">		data_cond.<span class="built_in">notify_one</span>(); <span class="comment">// 3</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>; <span class="comment">// 4</span></span><br><span class="line">		data_cond.<span class="built_in">wait</span>(</span><br><span class="line">			lk,[]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;); <span class="comment">// 5</span></span><br><span class="line">		data_chunk data=data_queue.<span class="built_in">front</span>();</span><br><span class="line">		data_queue.<span class="built_in">pop</span>();</span><br><span class="line">		lk.<span class="built_in">unlock</span>(); <span class="comment">// 6</span></span><br><span class="line">		<span class="built_in">process</span>(data);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="condition_variable_any-介绍">1.3 <code>condition_variable_any</code> 介绍</h4>
<p>与 <code>std::condition_variable</code> 类似，只不过 <code>std::condition_variable_any</code> 的 <code>wait</code> 函数可以接受任何 <code>lockable</code> 参数，而 <code>std::condition_variable</code> 只能接受 <code>std::unique_lock&lt;std::mutex&gt;</code> 类型的参数，除此以外，和 s<code>td::condition_variable</code> 几乎完全一样。</p>
<h4 id="生成者消费者模型">1.4 生成者消费者模型</h4>
<p>一般来说，生产者消费者模型可以通过 <code>queue</code>， <code>mutex</code> 和 <code>condition_variable</code> 来实现。下面是一个简单实现： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_cariable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::queue&lt;<span class="type">int</span>&gt; production;</span><br><span class="line">  std::mutex mtx;</span><br><span class="line">  std::condition_variable cv;</span><br><span class="line">  <span class="type">bool</span> ready = <span class="literal">false</span>;  <span class="comment">// 是否有产品可供消费</span></span><br><span class="line">  <span class="type">bool</span> done = <span class="literal">false</span>;   <span class="comment">// 生产结束</span></span><br><span class="line"></span><br><span class="line">  <span class="function">std::thread <span class="title">producer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [&amp;] () -&gt; <span class="type">void</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">      &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 模拟实际生产过程</span></span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread ::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;producing &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        std::unique_lock&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">        production.push(i);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 有产品可以消费了</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ready = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        cv.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">      &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// 生产结束了</span></span></span></span><br><span class="line"><span class="params"><span class="function">      done = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::thread <span class="title">consumer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [&amp;] () -&gt; <span class="type">void</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      std::unique_lock&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// 如果生成没有结束或者队列中还有产品没有消费，则继续消费，否则结束消费</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">while</span>(!done || !production.empty())</span></span></span><br><span class="line"><span class="params"><span class="function">      &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 防止误唤醒</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span>(!ready)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">          cv.wait(lock);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span>(!production.empty())</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="comment">// 模拟消费过程</span></span></span></span><br><span class="line"><span class="params"><span class="function">          std::cout &lt;&lt; <span class="string">&quot;consuming &quot;</span> &lt;&lt; production.front() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">          production.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 没有产品了</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ready = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line"></span><br><span class="line">  producer.<span class="built_in">join</span>();</span><br><span class="line">  consumer.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程(二):锁</title>
    <url>/2023/03/04/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%BA%8C-%E9%94%81/</url>
    <content><![CDATA[<h3 id="c中的锁">1 C++中的锁</h3>
<h4 id="c中的锁机制">1.1 C++中的锁机制</h4>
<p><strong>C++中的锁机制以下几种：</strong></p>
<ul>
<li><p>互斥锁：包括std::mutex、std::recursive_mutex、std::timed_mutex、std::recursive_timed_mutex等。互斥锁用于保护共享资源，可以保证同一时刻只有一个线程访问共享资源。</p></li>
<li><p>读写锁：包括std::shared_mutex、std::shared_timed_mutex等。读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。</p></li>
<li><p>条件变量：包括std::condition_variable、std::condition_variable_any等。条件变量允许线程等待某个条件发生变化，只有当条件满足时才能继续执行。</p></li>
<li><p>原子操作：包括std::atomic、std::atomic_flag等。原子操作用于保证某个操作的执行不会被其他线程中断，从而避免了数据竞争的发生。</p></li>
<li><p>自旋锁：包括std::spin_lock、std::atomic_flag等。自旋锁在等待锁的过程中不断地循环检查锁是否可用，而不是放弃CPU，从而避免了线程上下文切换带来的开销。</p></li>
<li><p>信号量：包括std::binary_semaphore、std::counting_semaphore等。信号量用于控制同时访问某个资源的线程数量，可以实现线程的互斥和同步。</p></li>
</ul>
<h4 id="悲观锁和乐观锁">1.2 悲观锁和乐观锁</h4>
<p>在C++中，锁通常被分为两种类型：<strong>悲观锁和乐观锁</strong></p>
<ul>
<li>其中悲观锁是指在访问共享资源时先获取锁，防止其他线程同时修改该资源，适用于写操作多的场景。C++中的互斥锁就是一种悲观锁。</li>
<li>而乐观锁则是在不加锁的情况下，尝试去读取和修改共享资源，如果遇到冲突，再使用重试等机制解决冲突，适用于读操作多于写操作的场景。
<ul>
<li>在C++中，可以使用atomic类型来实现乐观锁。atomic类型提供了对基本类型的原子操作，包括读、写、比较交换等。在进行原子操作时，它使用硬件原语实现同步，避免了使用锁所带来的额外开销和死锁的问题。</li>
<li>除了atomic类型，C++11还引入了一些使用乐观锁的算法，如无锁队列和无锁哈希表等。这些算法使用原子操作来实现线程安全，同时充分利用了乐观锁的优势，避免了使用锁所带来的开销。</li>
</ul></li>
</ul>
<h3 id="mutex互斥">2 Mutex：互斥</h3>
<p>所有线程间共享数据的问题，都<strong>是修改数据导致的（竞争条件）</strong>。如果所有的共享数据都是只读的，就没问题，因为一个线程所读取的数据不受另一个线程是否正在读取相同的数据而影响</p>
<h4 id="恶性条件竞争">2.1 恶性条件竞争</h4>
<p>恶性条件竞争通常发生于多线程对多于一个的数据块的修改时，产生了非预想的执行效果，即竞态条件是多个线程同时访问共享资源，导致结果依赖于线程执行的顺序和时间。</p>
<ul>
<li><p>竞态条件（Race Condition）指的是多个线程访问共享变量时，最终的结果取决于多个线程的执行顺序。竞态条件不一定总是错误的，但它们可能导致非预期的结果。</p></li>
<li><p>数据竞争（Data Race）指的是多个线程同时访问同一个共享变量，并且至少有一个线程对该变量进行了写操作。数据竞争是一种错误，因为它可能导致未定义的行为。</p></li>
</ul>
<p>在多线程编程中，竞态条件和数据竞争是常见的问题。解决这些问题的关键是使用同步机制。</p>
<p><strong>避免恶性条件竞争：</strong></p>
<ul>
<li>要避免恶性的条件竞争，一种方法是就使用一定的手段，对线程共享的内存区域的数据结构采用某种保护机制，如使用锁</li>
<li>另一种就是选择对该区域的数据结构和不变量的设计进行修改，如保证该区域为原子操作，，修改完的结构必须能完成一系列不可分割的变化，但是这种无锁的方法很难一定保证线程安全</li>
<li>另一种处理条件竞争的方式是，<strong>使用事务(transacting)的方式去处理</strong>该数据共享区域</li>
</ul>
<span id="more"></span>
<h4 id="mutex-头文件介绍">2.2 mutex 头文件介绍</h4>
<p>mutex 又称互斥量，C++11 中与 mutex 相关的类（包括锁类型）和函数都声明在 <code>&lt;mutex&gt;</code> 头文件中，所以如果你需要使用 <code>std::mutex</code>，就必须包含<code>&lt;mutex&gt;</code>头文件。</p>
<h5 id="mutex系列类四种">2.2.1 mutex系列类(四种)</h5>
<ul>
<li><code>std::mutex：</code>基本的 mutex 类。</li>
<li><code>std::recursive_mutex：</code>递归 mutex 类。</li>
<li><code>std::time_mutex：</code>定时 mutex 类。</li>
<li><code>std::recursive_timed_mutex：</code>定时递归 mutex 类。</li>
</ul>
<h5 id="函数">2.2.2 函数</h5>
<ul>
<li><code>std::try_lock</code>：尝试同时对多个互斥量上锁。</li>
<li><code>std::lock</code>：可以同时对多个互斥量上锁。</li>
<li><code>std::call_once</code>：如果多个线程需要同时调用某个函数，<code>call_once</code> 可以保证多个线程对该函数只调用一次。</li>
</ul>
<h4 id="mutexc互斥锁">2.3 mutex:C++互斥锁</h4>
<p>C++中通过实例化 <code>std::mutex</code> 创建互斥量，通过调用成员函数<code>lock()</code>进行上锁，<code>unlock()</code>进行解锁。对于互斥量，必须记住在每个线程执行完毕后必须去<code>unlock()</code>释放已获得的锁。</p>
<p>值得一提的是，C++标准库为互斥量提供了一个RAII语法的模板类<code>std::lock_guard</code>和<code>std::unique_lock</code>。 - <code>std::lock_guard</code> ：其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，此时就不用手动去解锁<code>unlock</code>，即使发生异常也会释放，从而保证了一个已锁的互斥量总是会被正确的解锁。 - <code>std::unique_lock</code>：<code>unique_lock</code>更加灵活，可以在任意的时候加锁或者解锁，因此其资源消耗也更大，通常是在有需要的时候（比如和条件变量配合使用，我们将在介绍条件变量的时候介绍这个用法）才会使用，否则用<code>lock_guard</code>。</p>
<p><strong>std::mutex 的成员函数：</strong></p>
<ul>
<li><p>构造函数：<code>std::mutex</code>不允许拷贝构造，也不允许 <code>move</code> 拷贝，最初产生的 <code>mutex</code> 对象是处于 unlocked 状态的。</p></li>
<li><code>lock()</code>：调用线程将锁住该互斥量。线程调用该函数会发生下面3种情况：
<ul>
<li>如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock 之前，该线程一直拥有该锁；</li>
<li>如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住，直到 mutex 被释放；</li>
<li>如果当前互斥量被当前调用线程锁住，则会产生死锁（deadlock）。</li>
</ul></li>
<li><p><code>unlock()</code>：释放对互斥量的所有权。</p></li>
<li><code>try_lock()</code>：尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面3种情况：
<ul>
<li>如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 <code>unlock</code> 释放互斥量。</li>
<li>如果当前互斥量被其他线程锁住，则当前调用线程返回 <code>false</code>，<strong>而并不会被阻塞掉。</strong></li>
<li>如果当前互斥量被当前调用线程锁住，则会产生死锁（<code>deadlock</code>）。</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; my_list;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">std::mutex my_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_list</span><span class="params">(<span class="type">int</span> new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="comment">//使用std::lock_guard类模板，使用RAII机制</span></span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">		sum++;</span><br><span class="line">		my_list.<span class="built_in">push_back</span>(new_value);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;线程插入值为：&quot;</span> &lt;&lt; new_value &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::vector&lt;std::thread&gt; <span class="title">thr</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		thr[i] = std::<span class="built_in">thread</span>(add_to_list, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t:thr) &#123;</span><br><span class="line">		t.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> j : my_list)</span><br><span class="line">		std::cout &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用互斥量保护数据，保证线程安全绝不简单，不是简简单单的在共享数据区域内加<code>lock</code>或<code>try_lock</code>或者<code>std::lock_guard</code>那样。<strong>一个迷失的指针或引用，将会让这种保护形同虚设</strong>：</p>
<ul>
<li>比如你的函数返回的是指针或者引用，这时候就得小心，</li>
<li>同样当你成员函数指针或引用的方式来调用，也要小心</li>
</ul>
<h5 id="锁的粒度">2.3.1 锁的粒度</h5>
<p>锁的粒度是用来描述通过一个锁保护着的数据量大小。一个细粒度锁(a fine-grained lock)能够保护较小的数据量，一个粗粒度锁(a coarse-grained lock)能够保护较多的数据量。选择粒度对于锁来说很重要：</p>
<ul>
<li><strong>为了保护对应的数据，保证锁有能力保护这些数据也很重要，</strong></li>
<li><strong>但是锁的粒度太粗，就会导致锁竞争频繁，消耗不必要的资源，也会导致多线程并发收益不高</strong></li>
</ul>
<p>因此<strong>必须保证锁的粒度既可以保证线程安全也能保证并发的执行效率。</strong></p>
<h4 id="死锁">2.4 死锁</h4>
<p>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<h5 id="死锁引起的原因">2.4.1 死锁引起的原因</h5>
<ul>
<li><p>竞争不可抢占资源引起死锁（不可抢占是指没有使用完的资源，不能被抢占）</p></li>
<li><p>竞争可消耗资源引起死锁：有p1，p2，p3三个进程，p1向p2发送消息并接受p3发送的消息，p2向p3发送消息并接受p1的消息，p3向p1发送消息并接受p2的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成死锁。</p></li>
<li><p>进程推进顺序不当引起死锁：有进程p1，p2，都需要资源A，B，本来可以p1运行A --&gt; p1运行B --&gt; p2运行A --&gt; p2运行B，但是顺序换了，p1运行A时p2运行B，容易发生第一种死锁。互相抢占资源。</p></li>
</ul>
<h5 id="死锁的必要条件">2.4.2 死锁的必要条件</h5>
<ul>
<li><strong>互斥条件</strong>：某资源只能被一个进程使用，其他进程请求该资源时，只能等待，直到资源使用完毕后释放资源。</li>
<li><strong>请求和保持条件</strong>：程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。</li>
<li><strong>不可抢占条件</strong>：进程已获得的资源没有使用完，不能被抢占。</li>
<li><strong>循环等待条件</strong>：必然存在一个循环链。</li>
</ul>
<h5 id="预防死锁的思路">2.4.3 预防死锁的思路</h5>
<ul>
<li><strong>预防死锁：</strong>破坏死锁的四个必要条件中的一个或多个来预防死锁。</li>
<li><strong>避免死锁：</strong>和预防死锁的区别就是，在资源动态分配过程中，用某种方式防止系统进入不安全的状态。</li>
<li><strong>检测死锁：</strong>运行时出现死锁，能及时发现死锁，把程序解脱出来</li>
<li><strong>解除死锁</strong>：发生死锁后，解脱进程，通常撤销进程，回收资源，再分配给正处于阻塞状态的进程。</li>
</ul>
<h5 id="预防死锁的方法">2.4.4 预防死锁的方法</h5>
<ul>
<li><strong>破坏请求和保持条件</strong>
<ul>
<li><p><strong>协议1：</strong>所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生。</p></li>
<li><p><strong>协议2：</strong>允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来。然后再请求新的资源。</p></li>
</ul></li>
<li><p>** 破坏不可抢占条件**：当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请 。</p></li>
<li><p><strong>破坏循环等待条件：</strong>对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</p></li>
</ul>
<h4 id="recursive_mutex-介绍">2.5 <code>recursive_mutex</code> 介绍</h4>
<p><code>std::recursive_mutex</code> 与 <code>std::mutex</code> 一样，也是一种可以被上锁的对象，但是和 <code>std::mutex</code> 不同的是，<strong><code>std::recursive_mutex</code> 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，<code>std::recursive_mutex</code> 释放互斥量时需要调用与该锁层次深度相同次数的 <code>unlock()</code>，可理解为 <code>lock()</code> 次数和 <code>unlock()</code> 次数相同</strong>，除此之外，<code>std::recursive_mutex</code> 的特性和 <code>std::mutex</code> 大致相同。</p>
<h4 id="time_mutex-介绍">2.6 time_mutex 介绍</h4>
<p><code>std::time_mutex</code> 比 <code>std::mutex</code> 多了两个成员函数，<code>try_lock_for()</code>，<code>try_lock_until()</code>。</p>
<ul>
<li><p><code>try_lock_for</code>：函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 <code>std::mutex</code> 的 <code>try_lock()</code> 不同，<code>try_lock()</code> 如果被调用时没有获得锁则直接返回 <code>false</code>），如果在此期间其他线程释放了锁，则该线程可以获得对斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 <code>false</code>。</p></li>
<li><p><code>try_lock_until</code>：函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 <code>false</code>。</p></li>
</ul>
<h4 id="recursive_timed_mutex-介绍">2.7 <code>recursive_timed_mutex</code> 介绍</h4>
<p>和 <code>std:recursive_mutex</code> 与 <code>std::mutex</code> 的关系一样，<code>std::recursive_timed_mutex</code> 的特性也可以从 <code>std::timed_mutex</code> 推导出来，感兴趣的同鞋可以自行查阅。</p>
<h4 id="自旋锁">2.8 自旋锁</h4>
<p><strong>自旋锁（spin lock）是一种多线程同步机制，它是在等待锁的过程中不断地循环检查锁是否可用，而不是放弃CPU，从而避免了线程上下文切换带来的开销。自旋锁适用于锁被占用的时间很短的场景，因为自旋锁在等待锁的过程中会一直占用CPU，当锁被占用的时间较长时，这种方式会浪费大量的CPU资源。在锁的持有时间较短的情况下，自旋锁可以在等待锁的过程中避免线程上下文切换的开销，从而提高性能。</strong></p>
<p>自旋锁<code>std::spin_mutex</code>是C++17中的新特性，定义在<code>&lt;mutex&gt;</code>头文件中。需要使用编译器支持C++17的特性才能使用<code>std::spin_mutex</code>。</p>
<p>在C++11中，可以使用std::atomic_flag来实现自旋锁，它是一个布尔类型的原子变量，但是在使用时需要注意以下几点：</p>
<ul>
<li><p>必须用 ATOMIC_FLAG_INIT 初始化 std::atomic_flag。</p></li>
<li><p>由于 std::atomic_flag 只有两种状态（被设置或未被设置），所以我们可以使用 test_and_set 成员函数来实现自旋锁的加锁和解锁操作。</p></li>
<li><p>由于自旋锁是一种忙等的锁，所以在使用 std::atomic_flag 实现自旋锁时需要避免死锁。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SpinLock</span>() : <span class="built_in">flag_</span>(ATOMIC_FLAG_INIT) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag_.<span class="built_in">test_and_set</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">      <span class="comment">// 自旋等待</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; flag_.<span class="built_in">clear</span>(std::memory_order_release); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::atomic_flag flag_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>test_and_set</code> 成员函数将 <code>flag_</code> 设置为<code>true</code> 并返回之前的值，如果返回的值为 <code>true</code>，则表示自旋等待；如果返回的值为 <code>false</code>，则表示自旋锁已经被当前线程占用，可以执行加锁操作。<code>clear</code> 成员函数将 <code>flag_</code> 设置为 <code>false</code>。</p>
<p>需要注意的是，<code>std::atomic_flag</code> 对象的默认内存顺序是 <code>std::memory_order_seq_cst</code>，在使用时需要根据具体情况进行调整，例如在加锁时使用 <code>std::memory_order_acquire</code>，在解锁时使用 <code>std::memory_order_release</code>。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象&amp;模板</title>
    <url>/2022/07/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="面向对象程序设计">1. 面向对象程序设计</h3>
<p>面向对象程序设计的核心思想是<strong>数据抽象、继承和动态绑定</strong>。通过数据抽象，我们可以将类的接口与实现相分离；使用继承。可以使用相似的类型对其关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别。</p>
<ul>
<li>1）继承：根部类为基类（相似于java的父类），其他继承于基类的类为派生类。</li>
<li>2）虚函数：某些函数，基类希望它的派生类各自定义适合其自生的函数</li>
<li>3）动态绑定：能使用同一代码分别处理基类和派生类。如虚函数运行版本由实参决定。</li>
</ul>
<h4 id="定义基类">1.1 定义基类</h4>
<ul>
<li>作为继承关系中根结点的类<strong>通常有定义了一个虚析构函数</strong>。</li>
<li>基类中的成员函数分为两种：<strong>一是派生类要进行重写覆盖的函数，称为虚函数</strong>；<strong>二是希望直接继承而不改变的函数</strong>。当我们使用指针或引用调用虚函数时，该调用将被<strong>动态绑定</strong>。</li>
<li>基类通过在其成员函数的声明语句之前加上关键字<code>virtual</code>使得函数执行<strong>动态绑定</strong>。其只能出现在类内部声明或定义中。</li>
<li>派生类可以继承定义在基类中的成员，但是派生类的的成员函数不一定有权访问从基类继承而来的成员。派生类能访问公有成员，但不能访问私有成员。为解决这一问题，引入了新访问运算符：<code>protected</code>(派生类有权访问，禁止用户访问）</li>
</ul>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;		<span class="comment">//定义基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Quote</span>(<span class="type">const</span> Quote&amp; q):<span class="built_in">bookNo</span>(q.bookNo),<span class="built_in">price</span>(q.price)&#123;&#125;</span><br><span class="line">	<span class="built_in">Quote</span>(<span class="type">const</span> string&amp; _book,<span class="type">const</span> <span class="type">double</span> _price):<span class="built_in">bookNo</span>(_book),<span class="built_in">price</span>(_price)&#123;&#125;</span><br><span class="line">	<span class="function">string <span class="title">isbn</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> n*price;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string bookNo;		<span class="comment">//派生类无权访问</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">double</span> price=<span class="number">0</span>;		<span class="comment">//派生类可访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义派生类">1.2 定义派生类</h4>
<p>派生类需要使用类派生列表来指出它是从哪个基类继承而来的，每个基类前面可以有三种访问说明符<code>public、private、protected</code>中的一个。<strong>派生类需要将继承来的成员函数需要覆盖的进行重新声明。如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分，也能将公有类型的对象绑定到基类的引用或者指针上。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_Book</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="built_in">Bulk_Book</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Bulk_Book</span>(<span class="type">const</span> Bulk_Book&amp; bb):<span class="built_in">Quote</span>(bb.<span class="built_in">isbn</span>(),bb.price),</span><br><span class="line">			<span class="built_in">min_qty</span>(bb.<span class="built_in">getMin_qty</span>()),<span class="built_in">discount</span>(bb.<span class="built_in">getDiscount</span>())&#123;&#125;</span><br><span class="line">	<span class="built_in">Bulk_Book</span>(<span class="type">const</span> string&amp; _book,<span class="type">double</span> p,<span class="type">size_t</span> qty,<span class="type">double</span> disc):<span class="built_in">Quote</span>(_book,p),<span class="built_in">min_qyt</span>(qyt),<span class="built_in">discount</span>(disc)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span> n)</span><span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;min_qyt)</span><br><span class="line">			<span class="keyword">return</span> n*price*discount;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> n*price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">getMin_qty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> min_qty;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getDiscpunt</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> discount;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Bulk_Book</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">size_t</span> min_qty=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> discount=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>派生类经常(但不总是)覆盖虚函数，派生类如果没有覆盖虚函数，则会直接继承其在基类中的版本。</li>
<li>派生类可以在它要覆盖的函数前面使用<code>virtual</code>,但不是非得这样做。C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数，既添加一个<code>override</code>。</li>
<li><strong>因为派生类对象中含有与基类对应得组成部分，所以我们能把派生类对象当成基类对象来使用（java的多态），同时也可把基类的指针或引用绑定到派生类对象得基类部分上。这种转换被称为派生类到基类的转换</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Quote item;			<span class="comment">//基类对象</span></span><br><span class="line">Bulk_Book bulk;		<span class="comment">//派生类对象</span></span><br><span class="line">Quote *p=&amp;item;		<span class="comment">//基类指针绑定带基类对象</span></span><br><span class="line">p=&amp;bulk;			<span class="comment">//基类指针也可绑定到派生类对象，反之不行（不安全）</span></span><br><span class="line">Quote &amp;r=bulk;		<span class="comment">//基类引用绑定带派生类上</span></span><br></pre></td></tr></table></figure>
<h5 id="派生类构造函数">1.2.1 派生类构造函数</h5>
<p><strong>派生类需要用基类的构造函数来初始化,每个类控制它自己的成员初始化过程</strong>。基类部分和自己的数据成员都在构造函数初始化阶段执行初始化操作，只不过由基类构造函数来初始化Bulk_quote的基类部分 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Bulk_Book</span>(<span class="type">const</span> Bulk_Book&amp; bb):<span class="built_in">Quote</span>(bb.<span class="built_in">isbn</span>(),bb.price),</span><br><span class="line">			<span class="built_in">min_qty</span>(bb.<span class="built_in">getMin_qty</span>()),<span class="built_in">discount</span>(bb.<span class="built_in">getDiscount</span>())&#123;&#125;</span><br><span class="line"><span class="built_in">Bulk_Book</span>(<span class="type">const</span> string&amp; _book,<span class="type">double</span> p,<span class="type">size_t</span> qty,<span class="type">double</span> disc):<span class="built_in">Quote</span>(_book,p),<span class="built_in">min_qyt</span>(qyt),<span class="built_in">discount</span>(disc)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="派生类使用基类成员">1.2.2 派生类使用基类成员</h5>
<p>派生类<strong>可以访问由基类继承来的的公有成员和受保护成员</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span> n)</span><span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;min_qyt)</span><br><span class="line">			<span class="keyword">return</span> n*price*discount;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> n*price;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="继承与静态成员">1.2.3 继承与静态成员</h5>
<p><strong>如果基类定义了一个静态成员，则在整个继承体系中都只存在该成员的唯一定义</strong>，无论从基类中派生出多少个类，<strong>对每个静态成员来说都只存在唯一的实例,属于一个类</strong>。静态成员遵循同样的访问控制规则，<strong>如果基类中成员private，派生类无权访问（只能由接口访问、或将该派生类声明为友元）</strong>，如果可访问，那么可通过基类或者派生类使用它。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">statmen</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::f</span><span class="params">(<span class="type">const</span> Derived &amp;s)</span></span>&#123;</span><br><span class="line">	Base::<span class="built_in">statmen</span>();		<span class="comment">//Base定义了statmen</span></span><br><span class="line">	Derived::<span class="built_in">statmen</span>();	<span class="comment">//Derived继承了statmen</span></span><br><span class="line">	s.<span class="built_in">statmen</span>();			<span class="comment">//通过Derived对象调用</span></span><br><span class="line">	<span class="built_in">statmen</span>();			<span class="comment">//通过this对象调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>其他规则：</strong></p>
<ul>
<li><strong>如果想将某个类用作基类，那么这个类必须已经定义而非仅仅声明，因为派生类要使用基类当中的成员，另外，这个规定隐含表示了：一个类不能派生它本身。</strong></li>
<li>一个类可以同时是基类和派生类。</li>
<li>可以通过<code>class Base final &#123;&#125;;</code>来阻止其他类来继承该类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Base是D1的直接基类，是D2的间接基类（D1既是派生类又是基类）。</span></span><br><span class="line"><span class="comment">//最终的派生链末端的类会包含直接基类的子对象以及每个间接基类的子对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>:<span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>:<span class="keyword">public</span> D1&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="类型转换与继承">1.3 类型转换与继承</h4>
<ul>
<li><p><strong>存在继承关系，我们可以将一个基类的引用或者指针绑定到派生类对象上</strong>。<strong><em>当使用存在继承关系的类型时，需将静态类型与动态类型区分开来：表达式的静态类型在编译时总是已知的，是变量声明时的类型或表达式生成的类型；动态类型是变量或者表达式表示的内存中对象的类型。但如果表达式既不是引用也不是指针，那么静态类型永远与动态类型一致。</em></strong></p></li>
<li><strong>不存在从基类向派生类的隐式类型转换(不安全)</strong>。
<ul>
<li><p>每个派生类对象包含一个基类部分，才能实现派生类向基类的隐式转换，所以一个基类不能隐式地转换为派生类： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_Book&amp; bulkr=base;		<span class="comment">//错误</span></span><br><span class="line">Bulk_Book* bulkp=&amp;base;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>另外一个特殊的是即使一个基类指针绑定在派生类对象上，我们也不能执行基类向派生类的转换，因为编译器判断的是指针或者引用的静态类型： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Bulk_Book bulk;</span><br><span class="line">Quote *itemp=&amp;bulk;		<span class="comment">//正确</span></span><br><span class="line">Bulk_Book *bulkp=itemp;	<span class="comment">//错误，不允许</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>对象之间不存在类型转换。派生类向基类的自动类型转换只针对指针或者引用</strong>，我们初始化或者赋值一个类类型的对象，实际上是在调用某个函数，这些函数可以接受一个引用作为参数，允许我们向基类形参传递一个派生类的对象，但又由于这些不是虚函数，显然这些函数只能处理基类的对象，派生类自有的成员被切掉了。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为拷贝和赋值的参数为const Quote&amp;的引用类型</span></span><br><span class="line">Bulk_Book bulk;		<span class="comment">//派生类对象</span></span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;	<span class="comment">//允许，只不过在Bulk_Book上新增的被切掉</span></span><br><span class="line">item=bulk;			<span class="comment">//允许</span></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h4 id="虚函数">1.4 虚函数</h4>
<p><strong>当我们使用基类的引用或指针调用虚函数时会执行动态绑定(直到运行时，我们才会知道调用的是哪个版本---动态类型）。</strong></p>
<p><strong>1. 某个虚函数(参数）通过指针或者引用调用时，直到运行时才能确定调用哪个版本的函数，被调用的是与指针或者引用的动态类型匹配的哪个，需要注意的是只有通过指针或者引用调用虚函数才会发生动态绑定。通过对象调用的虚函数版本在编译时确定。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,<span class="type">const</span> Quote &amp;items,<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">//根据传入的items调用net_price,允许时才知道时基类的net_price还是派生类的</span></span><br><span class="line">	<span class="type">double</span> ret= items.<span class="built_in">net_price</span>(n);</span><br><span class="line">	os&lt;&lt;<span class="string">&quot;isbn:&quot;</span>&lt;&lt;items.<span class="built_in">isbn</span>()&lt;&lt;<span class="string">&quot; sold_num:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; total_price:&quot;</span>&lt;&lt;ret&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function">Quote <span class="title">base</span><span class="params">(<span class="string">&quot;0-2121-755&quot;</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout,base,<span class="number">10</span>);		<span class="comment">//item引用调用的是quote版本的net_price</span></span><br><span class="line"><span class="function">Bulk_quote <span class="title">bu_base</span><span class="params">(<span class="string">&quot;021-1141-143&quot;</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">0.9</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout,bu_base,<span class="number">10</span>);	<span class="comment">//item引用调用的是Bulk_quote版本的net_price</span></span><br></pre></td></tr></table></figure> <strong><em>注意：既当且仅当对通过引用或者指针调用虚函数时，才会出现运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同（这时支持多态性的根本所在）。</em></strong></p>
<p><strong>2. 一旦某个函数被声明为虚函数，则在所有派生类中都是虚函数（可加virtual也可不加），覆盖的版本形参类型、返回类型必须一致，(但如果返回的是类的引用或者指针时，可以不一样,但须保证基类和派生类的类型是可转换的，这将在后面简述：注意处)</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> )</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> B&amp; <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>;		<span class="comment">//可覆盖，但是不能加override</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span><span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="comment">//void f2(int)override;	//错误，参数不一样</span></span><br><span class="line">	<span class="function">D1&amp; <span class="title">f3</span><span class="params">()</span><span class="keyword">override</span></span>;		<span class="comment">//正确</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.final和override说名符：</strong>c++新标准中的<code>override</code>是为了说明派生类的中的虚函数，能让编译器为程序员发现一些错误：如参数并不匹配，返回类型不一致等，同时也让编译者知道它是一个（基类虚函数）到派生类重写的虚函数。<strong>函数被指定为<code>final</code>,则之后任何尝试覆盖该函数的操作都将引发错误</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span><span class="type">const</span> <span class="keyword">final</span></span>;		<span class="comment">//不允许后续的其他继承类覆盖</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.虚函数运行默认实参</strong>：虚函数也可以有默认实参，但是实参值由该次调用的<strong>静态类型决定</strong>，也就是如果通过基类的引用或指针调用虚函数，则使用基类虚函数定义的默认实参，不管动态类型如何。<strong>因此虚函数如果使用实参，最好基类和派生类的中定义的默认实参是一致的。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a=<span class="number">1</span>,<span class="type">int</span> b=<span class="number">4</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">B b;</span><br><span class="line">A *P=&amp;B;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();		<span class="comment">//调用B中的f，但是传入参数为A的默认参数，即B::f(0,3);</span></span><br></pre></td></tr></table></figure></p>
<p><strong>5. 回避虚函数的动态绑定机制：</strong>有些情况下希望强制执行虚函数的某个特定版本，可以使用作用域运算符，强制调用某个派生类或者基类的虚函数。如上述的<code>item</code>,如果是要<code>Quote</code>的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">doeble ret=item.Queto::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="抽象基类">1.5 抽象基类</h4>
<p>含有<strong>纯虚函数</strong>的类是抽象基类。纯虚函数无需定义，通过在函数声明语句的分号之前书写=0就可以将一个虚函数说明为纯虚函数，它告诉用户该函数对于该类没有实际意义。不能在类的内部为一个=0的函数提供函数体。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Disc_quote</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Disc_quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Dis_quote</span>(<span class="type">const</span> string&amp; book,<span class="type">double</span> price,std::<span class="type">size_t</span> qty,<span class="type">double</span> disc):</span><br><span class="line">	<span class="built_in">Queto</span>(book,price),<span class="built_in">quantity</span>(qty),<span class="built_in">discount</span>(disc)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">net_prince</span><span class="params">(std::<span class="type">size_t</span> n)</span></span>=<span class="number">0</span>;		<span class="comment">//纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std:<span class="type">size_t</span> quantity=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> discount=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 这种抽象基类负责定义接口，后续的其他类可以覆盖该接口。<strong>我们不能实例化一个抽象基类的对象，但可以定义它的派生类（前提是该派生类覆盖定义了该纯虚函数）</strong>。</p>
<p>这个时候我们讲<code>Bulk_queto</code>直接继承与<code>Disc_quote</code>,而不是<code>Quot</code>e,值得一提的是，派生类构造函数只初始化它的直接基类： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> :<span class="keyword">public</span> Disc_quote</span><br><span class="line">&#123;	<span class="comment">//继承了isbn,prince,bookNo</span></span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">		:<span class="built_in">Disc_quote</span>(book,p,qty,disc) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span><span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="访问控制与继承">1.6 访问控制与继承</h5>
<p>每个类分别控制自己成员的初始化过程和成员可访问特性</p>
<h5 id="protected">1.6.1 protected</h5>
<p><code>protected</code>受保护的成员，对类用户来说是不可访问的，对于派生类和友元来说是可访问的。派生类的成员或者友元只能通过派生类对象来访问基类的受保护成员！ <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;		<span class="comment">//能访问Sneaky::port_mem</span></span><br><span class="line">	<span class="comment">//friend void clobber(Base&amp;);			//不能访问Base::port_,e,</span></span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp; s)</span></span>&#123;s.j=s.port_mem=<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure> 为什么第二条<code>friend void clobber(Base&amp;)</code>；是不允许的，<strong>因为<code>void clobber(Base&amp;)</code>；不是<code>Base</code>类的友员</strong>，试想一下如果这种方法可行，那么就意味着用户可以自己制作一个派生类，此时就很容易规避了protected不能被用户访问的特性，这是一个弊端，所以说派生类的成员或者友元只能通过派生类对象来访问继承自基类的受保护成员！</p>
<h5 id="公有私有和受保护继承">1.6.2 公有、私有和受保护继承</h5>
<p>类对其继承而来的成员的访问权限收到两个因素影响：<strong>一是基类中该成员的访问说明符；二是派生类的派生列表中的说明符。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> port_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 如果继承是<code>public</code>的，则尊循原来的访问说明符，如果继承是<code>private</code>的，则所有继承成员都是私有的，如果继承是受保护的，则继承的公有成员都是受保护的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pub_exam</span>:<span class="keyword">public</span>  Base&#123;</span><br><span class="line"><span class="comment">//成员性质保持不变</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> port_mem;&#125;	<span class="comment">//可被访问</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> priv_mem;&#125;	<span class="comment">//错误，private不可访问（可用基类接口、或声明为友员）</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">priv_exam</span>:<span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="comment">//private只是不会影响派生类对基类的原有访问。</span></span><br><span class="line"><span class="comment">//该继承类的成员都是private</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> port_mem;&#125;	<span class="comment">//可被访问</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> priv_mem;&#125;	<span class="comment">//错误，private不可访问（可用基类接口、或声明为友员）</span></span><br><span class="line">&#125;；</span><br><span class="line">使用：</span><br><span class="line">pub_exam d1;</span><br><span class="line">priv_exam d2;</span><br><span class="line">d1.<span class="built_in">pub_mem</span>();		<span class="comment">//正确，该函数再派生类中是public</span></span><br><span class="line">d2.<span class="built_in">pub_mem</span>();		<span class="comment">//错误，该函数再派生类中是private</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以派生访问说明符对于派生类的成员能否访问其直接基类的成员没什么影响，</span></span><br><span class="line"><span class="comment">//只是影响派生类用户对于基类成员的访问权限。同时也可控制继承自派生类的新类的访问权限。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ds</span>:<span class="keyword">public</span> pub_exam&#123;</span><br><span class="line"><span class="comment">//成员性质不变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">as</span>:<span class="keyword">public</span> priv_exam&#123;</span><br><span class="line"><span class="comment">//都是private,无法直接访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：</em></strong></p>
<ul>
<li><strong>当派生类公有继承基类时，用户代码才能实现派生类向基类的转换，否则不能；</strong></li>
<li>无论什么方式继承，派生类的成员函数和友元都可以使用派生类向基类的转换；</li>
<li>如果D是公有或者受保护继承B，则D的派生类的成员和友元可以使用向基类B的类型转换，否则不能</li>
</ul>
<h5 id="友员和继承">1.6.3 友员和继承</h5>
<p>就如友员关系无法传递一样，友员关系同样无法被继承。既基类的友员再访问派生类成员时不具有特殊性，同理派生类的友员也不买随意访问基类成员。</p>
<h5 id="改变个别成员的可访问性">1.6.4 改变个别成员的可访问性</h5>
<p>当需要改变派生类继承的某个名字的访问级别，通过使用using声明： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">private</span> Base&#123;		<span class="comment">//private继承，则默认下的继承类成员为私有</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	usnig Base::size;		<span class="comment">//保持与Base基类一样的public</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::n;			<span class="comment">//保持与基类一样的protected</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="继承中类的作用域">1.7 继承中类的作用域</h4>
<p>每个类都有自己的作用域，在这个域中我们声明和定义类的成员。<strong>当存在继承时，派生类的作用域嵌套在其基类作用域之内。如果有多次继承，则一环一环嵌套下去。</strong></p>
<h5 id="编译时进行名字查找">1.7.1 编译时进行名字查找</h5>
<p><strong>一个对象、引用和指针的静态类型决定了该对象的哪些成员是可见的，我们使用哪些成员仍然是由静态成员类型所决定的</strong>：如我们在上面的Disc_quote添加一新成员： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Disc_quote</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::pair&lt;<span class="type">size_t</span>,<span class="type">double</span>&gt; <span class="title">discount_policy</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;quanlity,discount&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用：Quote不包含有新成员;而Bulk_quote继承自Disc_quote</span></span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Bulk_quote* blukp=&amp;bulk;			<span class="comment">//静态类型于动态类型一致</span></span><br><span class="line">Quote* itemp=&amp;bulk;					<span class="comment">//基类指针指向派生类对象，即静态与动态不一致</span></span><br><span class="line">bulkp-&gt;<span class="built_in">discount_policy</span>();			<span class="comment">//正确</span></span><br><span class="line">itemp-&gt;<span class="built_in">discount_policy</span>();			<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p>
<h5 id="名字冲突与继承">1.7.2 名字冲突与继承</h5>
<p>与其他作用域一样，派生类也能重用定义在其直接或间接基类中的名字，此时定义在内存作用域的名字将会隐藏定义在外层（即基类）的名字: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">punlic:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getMem</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> mem;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getMem</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> mem;&#125;		<span class="comment">//隐藏了基类中的getMem</span></span><br><span class="line">	<span class="comment">//那么我们在需要被隐藏成员时，可以通过**使用域作用运算符**获取：</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get_A_mem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> A::mem&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mem;		<span class="comment">//隐藏了基类中的mem</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>理解c++继承中函数解析过程：假定我们调用<code>p-&gt;getMem()</code>或者<code>obj.getMem()</code>,则以此执行下面四个步骤:</strong></p>
<blockquote>
<ol type="1">
<li>首先确定<code>p</code>或<code>obj</code>的静态类型。因为我们调用的是一个成员，所有它们必定是类类型</li>
<li>在<code>p</code>或<code>obj</code>的静态类型对应的类中寻找<code>getMem</code>成员，如果找不到则以此在它的基类中寻找，直到继承链的顶端。若到顶端都没找到，则编译器报错。</li>
<li>一旦找到了<code>getMmem</code>，就进行常规的类型检查（参数个数和类型）以确认找到的<code>getMem</code>，对于本次调用是否合法。</li>
<li>假设调用合法，则编译器将根据调用是否是虚函数而产生不同代码：如果<code>getMem</code>是虚函数且我们是通过引用或指针形式进行调用，则编译器产生的代码将在运行时确定到底是运行该虚函数的哪一个版本。反之，则常规调用函数</li>
</ol>
</blockquote>
<h5 id="名字查找先于类型检查">1.7.3 名字查找先于类型检查</h5>
<p>声明在内层作用域中的函数不会重载声明在外层作用域的函数。因此派生类的成员也不会重载基类中的成员，而是隐藏掉外层作用域成员。所以下面的调用是错误的: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">memfcn</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">B d;</span><br><span class="line">A c;</span><br><span class="line">c.<span class="built_in">memfvn</span>();		<span class="comment">//正确</span></span><br><span class="line">d.<span class="built_in">memfcn</span>(<span class="number">10</span>);	<span class="comment">//正确</span></span><br><span class="line">d.<span class="built_in">memfcn</span>();		<span class="comment">//错误，参数列表为空的memcn被隐藏了</span></span><br><span class="line">d.A::<span class="built_in">memfcn</span>();	<span class="comment">//正确，通过作用域访问</span></span><br></pre></td></tr></table></figure></p>
<h5 id="虚函数与作用域">1.7.4 虚函数与作用域</h5>
<p>现<strong>在我们应该能够理解为什么虚函数必须要有相同的形参列表。因为假如不同,就会被隐藏，我们就无法通过基类引用或指针调用派生类的虚函数了</strong>，而是通过作用域运算符<code>::</code>访问，这就失去了多态这个重要性质。</p>
<h4 id="构造函数与拷贝控制">1.8 构造函数与拷贝控制</h4>
<p>继承体系中的类也需要控制当其对象执行一系列操作时发生什么样的行为。</p>
<h5 id="虚析构函数">1.8.1 虚析构函数</h5>
<p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个<strong>虚析构函数</strong>，这样我们就能动态分配继承体系中的对象了：<strong>假如当我们要<code>delete</code>一个动态<code>Quote*</code>指针时，该指针实际可能是<code>Bulk_quote</code>类型的对象。那么此时编译器就必须清楚它应该执行的是<code>Bulk_quote</code>的析构函数，所以应该在基类定义一个虚析构函数</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 之前我们介绍过一条经验准则<strong>：若一个类有析构函数，则必应当需要拷贝和赋值操作。</strong>一般基类的析构函数并不需要遵循这条经验准则，这是一个重要例外。同时虚析构函数会阻止类合成移动操作。</p>
<h5 id="基类合成拷贝控制与继承">1.8.2 基类合成拷贝控制与继承</h5>
<p>基类或者派生类的合成拷贝控制成员的行为与其他类似：</p>
<ul>
<li><strong>合成派生类默认构造函数运行了直接基类的默认构造函数，直接基类又运行了间接基类的构造函数</strong>（如上面的<code>Quote、Disc_quote、Bulk_quote</code>的构造函数）,<strong>顺序时会先先执行基类的默认构造函数，再执行派生类构造函数</strong></li>
<li>在上文继承体系中所有类都使用合成的析构函数，派生类隐式使用，基类显式使用，<strong>派生类的析构函数释放成员，销毁直接基类</strong></li>
</ul>
<p><strong>1. 派生类中删除的拷贝控制与基类的关系：</strong></p>
<ul>
<li><strong>如果基类的默认构造函数、拷贝控制成员、析构函数是删除或者不可访问，则派生类中对应的成员也是删除的，因为没办法执行对基类的操作；</strong></li>
<li><strong>如果基类的析构函数是删除的，则派生类拷贝控制成员和移动构造函数是删除的，因为没法销毁基类对象</strong></li>
<li>编译器不会合成删除掉的移动操作。如果基类的移动操作是删除的，则派生类当中的也是删除的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">const</span> B&amp;)=<span class="keyword">delete</span>;	<span class="comment">//拷贝构造是删除的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">D d;		<span class="comment">//正确，使用合成的默认构造哈桑农户</span></span><br><span class="line"><span class="function">D <span class="title">d1</span><span class="params">(d)</span></span>;	<span class="comment">//错误，基类的拷贝构造函数时删除的，那么派生类的拷贝构造也被删除了</span></span><br><span class="line"><span class="function">D <span class="title">d3</span><span class="params">(std::move(d))</span></span>;	<span class="comment">//错误，编译器不会合成删除掉移动操作，会隐式调用拷贝构造，但它也被删除，</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 移动操作与继承</strong></p>
<p><strong>多数基类定义一个虚析构函数，因此默认下基类不含合成的移动操作，这导致派生类也没有移动操作</strong>（没有移动操作，但使用的时候用到移动操会默认使用拷贝构造函数）。当确实需要移动操作时应在基类中定义，并同时定义拷贝操作 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Quote</span>(<span class="type">const</span> Quote&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Quote</span>(Quote&amp;&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Quote&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="派生类的拷贝控制成员">1.8.3 派生类的拷贝控制成员</h5>
<p>正如派生类构造函数一样要初始化基类部分的成员，<strong>派生类的拷贝控制成员不仅拷贝自身成员，也负责了拷贝基类部分的成员。</strong> <strong>1. 当为派生类定义拷贝或移动构造函数时，我们通常使用对应得函数初始化对象得基类部分。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">calss base&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">D</span>(<span class="type">const</span> D&amp; d):<span class="built_in">Base</span>(d)&#123;&#125;</span><br><span class="line">	<span class="built_in">D</span>(D&amp;&amp; d):<span class="built_in">Base</span>(std::<span class="built_in">move</span>(d))&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 派生类赋值运算符,与拷贝和移动构造函数一样，派生类赋值运算符也必须显式地为其基类部分赋值。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">calss base&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">D</span>(<span class="type">const</span> D&amp; d):<span class="built_in">Base</span>(d)&#123;&#125;</span><br><span class="line">	<span class="built_in">D</span>(D&amp;&amp; d):<span class="built_in">Base</span>(std::<span class="built_in">move</span>(d))&#123;&#125;</span><br><span class="line">	D&amp; <span class="keyword">operator</span>=(<span class="type">const</span> D&amp; d)&#123;</span><br><span class="line">		Base::<span class="keyword">operator</span>=(d);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 继承的构造函数.在c++新标准中，允许派生类能够直接用基类定义的构造函数,但不能继承默认构造函数和拷贝，移动构造函数，如果不定义，编译器负责合成。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>:<span class="keyword">public</span> Disc_qupte&#123;</span><br><span class="line">	<span class="keyword">using</span> Disc_quote::Disc_quote;		<span class="comment">//继承Disc_Quot的构造函数</span></span><br><span class="line">	<span class="function"><span class="type">double</span> 	<span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span><span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>using（起到注明作用，提示用户有继承构造函数）作用于编译器时令其产生代码</strong>，对于基类的每个构造函数，派生类都生成一个形参列表完全对应的：</p>
<ul>
<li>构造函数的<code>using</code>不会改变构造函数的访问级别；</li>
<li><strong>当基类构造函数含有默认实参，实参不会被继承，而是生成一个形参列表中除去默认实参的构造函数</strong>（例如，若基类有一个接受两个形参的构造函数，其中第二个有默认实参，则派生类将获得两个构造函数：一个是构造函数接受两个形参，另一个只接受一个形参，该形参是没有默认实参的那个）。P558 ；</li>
<li>如果派生类定义了与基类构造函数形参相同的构造函数，则不会继承该构造函数，而是替换</li>
</ul>
<h4 id="单例模式">1.9 单例模式</h4>
<p><strong>定义：单例模式是一个类只能实例化一个对象,实现单例模式的思路:</strong></p>
<ul>
<li>1）.把无参构造函数和拷贝构造函数私有化</li>
<li>2）.定义一个类内的类静态成员指针</li>
<li>3）在类外初始化时，<code>new</code>一个对象</li>
<li>4）把指针的权限设置为私有，然后提供一个静态成员函数让外面获取这个指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Maker</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.把构造函数私有化</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Maker</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Maker</span>(<span class="type">const</span> Maker &amp;m)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员函数，访问静态成员变量</span></span><br><span class="line">	<span class="comment">//4.把指针的权限设置为私有，然后提供一个静态成员函数让外面获取这个指针</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Maker* <span class="title">getMaker</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pMaker;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//2.定义一个类内的静态成员指针</span></span><br><span class="line">	<span class="type">static</span> Maker *pMaker;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//3.在类外初始化时，new一个对象</span></span><br><span class="line">Maker *Maker::pMaker = <span class="keyword">new</span> Maker;<span class="comment">//这里可以new是因为在Maker::作用域，编译器把它当成在类内</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Maker *m = Maker::<span class="built_in">getMaker</span>();</span><br><span class="line">	Maker *m2 = Maker::<span class="built_in">getMaker</span>();		<span class="comment">//m和m2是同一对象</span></span><br><span class="line">	<span class="comment">//Maker m3 = *m;//调用拷贝构造，这里会产生新对象，所以要把拷贝构造也私有化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板与泛型编程">2. 模板与泛型编程</h3>
<p>面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况，不同之处在于：<strong>OOP能处理类型在程序运行之前都未知的情况；而泛型编程，在编译时就能知道类型。之前介绍过的容器、迭代器和泛型算法都是泛型编程的例子</strong></p>
<p><strong><em>必须知道的原理</em></strong>：<strong>模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义</strong>，这个过程叫做<strong>模板实例化</strong>。编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。即模板类在没有调用之前是不会生成代码的。 <strong><em>注意：</em></strong>要区分类实例化和模板实例化，类实例即为创建对象，模板实例化为定义一个实例类</p>
<h4 id="函数模板">2.1 函数模板</h4>
<p>一个函数模板就是一个公式，可以用来针对特定类型的函数版本。比如我们定义一个比较函数模板： <strong>1. 定义函数模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">int</span>  <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;v1,<span class="type">const</span> T&amp; v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v1&lt;v2) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v1&gt;v2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板定义以关键字<code>template</code>开始，后跟一模板参数类型列表（由逗号分隔的一个或多个模板参数，由&lt;&gt;括起）。 当我们使用模板时，显式或隐式的指定模板实参，将其绑定到模板参数上。</p>
<p><strong>2.模板实例</strong></p>
<p>我们调用该模板时候编译器就会根据我们提供的实参来实例化一个特定版本的函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;&lt;endl;		<span class="comment">//实例化了一int compare(const int&amp; v1,const int&amp; v2)函数</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3.模板类型参数</strong></p>
<p>上面自定义的模板函数有模板参数列表,<strong>这些参数可以指定函数参数列表、返回类型、函数体内的变量声明和类型转换</strong>，其内的类型参数前必须使用<code>class</code>或者<code>typename</code>,在这里两个的含义完全相同。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">class</span> U&gt; <span class="title">T</span><span class="params">(<span class="type">const</span> T&amp; v1,<span class="type">const</span> U&amp; v2)</span></span>&#123;</span><br><span class="line">	T tep=v1;</span><br><span class="line">	U up=v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 非类型模板参数</strong></p>
<p>除了定义模板类型参数，还可以定义<strong>非类型模板参数</strong>。<strong>非类型参数表示一个值而非一个类型，通过一个特定的类型名而不是关键字<code>typename</code>、<code>class</code>来指定非类型参数</strong>。例如：编写一个<code>compare</code>版本处理字符串字面常量，这种字面常量是<code>const char</code>数组：（因为数组是无法拷贝的，所以采用引用），该非类型模板定义了两个非类型参数，第一个将要表示第一个数组长度，第二个表示第二个数组长度: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非类型模板参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N,<span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N],<span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>当非类型模板被实例化时，非类型参数被一个用户提供的或编译器推断的值所替代。这些值必须是常量表达式，绑定到指针或引用的非类型实参必须具有静态生存周期（static)</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;Hi&quot;</span>,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//编译器会将字面常量大小代替`N\M`，从而实例模板。</span></span><br><span class="line"><span class="comment">//编译器会在字符串字面常量末尾插入一个空字符作为终结符，所以编译器实例的版本是：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[<span class="number">3</span>],<span class="type">const</span> <span class="type">char</span> (&amp;p2)[<span class="number">6</span>])</span></span>;</span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong>一个非类型参数可以是整型、指向对象或函数的指针或者左值引用。</p>
<h4 id="类模板">2.2 类模板</h4>
<p>函数模板不同的是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后面的&lt;&gt;中提供额外信息----作为类模板参数的实参</p>
<ul>
<li><p><strong>类模板中的声明和实现必须放在同一头文件</strong>，因为链接器（linker）会找不到实例化的函数模板的入口地址。链接器之所以会去找这个函数入口，是因为编译器（compiler）告诉他这里有一个函数入口。“因为C++标准明确表示，当一个模板不被用到的时侯它就不该被实例化出来”。模板分离编译（分别放在.h和.cpp中），VS会报错：<code>error LNK2001: unresolved external symbol</code>。没有报错的，要么是没有使用这个模板，要么是在实现的.cpp文件中有实际使用。</p>
<a href="https://blog.csdn.net/bichenggui/article/details/4207084">c++编译器为什么不支持模板的分离式编译</a></li>
<li>C++支持<strong>类模板虚函数</strong>，但是不支持<strong>模板虚函数</strong>
<ul>
<li>①这是由C++多态的实现机制决定的：**每个有虚函数的类都拥有一张虚函数表(虚函数表的大小取决于类内有多少个虚函数，比如有N个，就是4*N)，虚函数表内存储着指向各自的虚函数入口地址；当我们实例化一个类的对象时，就会对该对象生成一个虚表指针，指向这个类的虚函数表，这样我们就能够知道在继承中子类调用子类的虚函数，而不是父类的虚函数。**</li>
<li>②我们知道类模板不是类的实例化，模板类只要在我们显示定义类时，才会实例化一个类。</li>
<li>因此知道上面的①②点，很容易知道为什么。因为类模板不是实例化类，那么当然就不会有虚函数表，它的虚函数表只要在类实例化后才生成，并不会冲突，因此类模板可以有虚函数；但是，当我们在一个实例化类定义一个模板函数是不可行的，因为编译器在编译的时候就得确定虚函数表的大小，而模板函数只又在实例化后才会生成一个真正的函数。</li>
</ul></li>
</ul>
<h5 id="定义类模板">2.2.1 定义类模板</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">BlobPtr</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;		<span class="comment">//value_type=T</span></span><br><span class="line">	<span class="comment">//typename 告诉编译器size_type是个类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BlobPtr</span>&lt;T&gt;;		<span class="comment">//类BlobPtr&lt;T&gt;为友员</span></span><br><span class="line">	<span class="built_in">Blob</span>() :<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;()) &#123;<span class="built_in">addStatic</span>();&#125;	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il) :<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)) </span><br><span class="line">		&#123;<span class="built_in">addStatic</span>();&#125;	<span class="comment">//含参构造函数</span></span><br><span class="line">	~<span class="built_in">Blob</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">Size</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;					<span class="comment">//元素数量</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;						<span class="comment">//判空</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T&amp; e)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(e); &#125;				<span class="comment">//尾部添加</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T&amp;&amp; e)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(e)); &#125;	<span class="comment">//右值引用尾部添加</span></span><br><span class="line">	<span class="comment">//静态接口</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addStatic</span><span class="params">()</span> </span>&#123; count_object++; &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">getStatic</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count_object; &#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">Pop_back</span><span class="params">()</span></span>;													<span class="comment">//删除尾部元素</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">Back</span><span class="params">()</span></span>;														<span class="comment">//取尾部元素</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">Front</span><span class="params">()</span></span>;														<span class="comment">//取头部元素</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);									<span class="comment">//下标访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string&amp; msg)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="type">static</span> count_object=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">void</span>  Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="type">const</span> string&amp; msg)<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= <span class="built_in">Size</span>() || i &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="built_in">Pop_back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="built_in">Back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="built_in">Front</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;front on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;[] on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (*data)[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">size_t</span> Blob&lt;T&gt;::count_object = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类通过弱引用智能指针控制Blob的shared_ptr指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">M</span>&gt;<span class="keyword">class</span> <span class="title class_">BlobPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() :<span class="built_in">current_location</span>(<span class="number">0</span>) &#123;  &#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;M&gt;&amp; a, <span class="type">size_t</span> si = <span class="number">0</span>) :<span class="built_in">wptr</span>(a.data), <span class="built_in">current_location</span>(si) &#123;  &#125;</span><br><span class="line">	M&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(current_location, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (*p)[current_location];</span><br><span class="line">	&#125;</span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		++current_location;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">		--current_location;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setWptr</span><span class="params">(Blob&lt;M&gt;&amp; a)</span> </span>&#123; wptr = a.data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;vector&lt;M&gt;&gt; <span class="built_in">check</span>(std::<span class="type">size_t</span>, <span class="type">const</span> string&amp;)<span class="type">const</span>;</span><br><span class="line">	std::weak_ptr&lt;vector&lt;M&gt;&gt; wptr;</span><br><span class="line">	<span class="type">size_t</span> current_location;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">M</span>&gt; <span class="keyword">inline</span> std::shared_ptr&lt;vector&lt;M&gt;&gt; BlobPtr&lt;M&gt;::</span><br><span class="line"><span class="built_in">check</span>(std::<span class="type">size_t</span> i, <span class="type">const</span> string&amp; msg)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> q = wptr.<span class="built_in">lock</span>();</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= q-&gt;<span class="built_in">size</span>())</span><br><span class="line">			<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">		<span class="keyword">return</span> q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用示例</span></span><br><span class="line">Blob&lt;string&gt; blob;</span><br><span class="line">Blob&lt;string&gt; blob2;</span><br><span class="line">Blob&lt;<span class="type">int</span>&gt;blob3;</span><br><span class="line">cout &lt;&lt; blob.<span class="built_in">getStatic</span>()&lt;&lt;blob3.<span class="built_in">getStatic</span>() &lt;&lt; endl;	<span class="comment">//2 1</span></span><br><span class="line">blob.<span class="built_in">Push_back</span>(<span class="string">&quot;trluper&quot;</span>);</span><br><span class="line">blob.<span class="built_in">Push_back</span>(<span class="string">&quot;github&quot;</span>);</span><br><span class="line">BlobPtr&lt;string&gt; bp;</span><br><span class="line">bp.<span class="built_in">setWptr</span>(blob);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!blob.<span class="built_in">Empty</span>()) &#123;</span><br><span class="line">	string s = blob.<span class="built_in">Front</span>();</span><br><span class="line">	s = blob.<span class="built_in">Back</span>();</span><br><span class="line">	++bp;</span><br><span class="line">	s = *bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从上面一个完整的类模板可以看到：</strong></p>
<ul>
<li><strong>类模板的成员函数可定义在类内也可在类外，类内定义的成员函数默认内联（inline)</strong>。类模板成员函数具有和模板相同的模板参数。因此，<strong>在类外定义成员函数必须以关键字<code>template</code>关键字开始，后接类模板参数列表</strong>：<code>template&lt;class T&gt;</code></li>
<li><code>inline</code>关键字放在模板之后，函数之前即可</li>
<li>我们使用一个类模板类型必须提供模板参数。但有一个例外：在模板类内作用域可以直接使用模板名而不需要要提供参数<code>&lt;T&gt;</code>，但在类外定义的时候需要提供参数<code>&lt;T&gt;</code></li>
<li>在函数体内，我们进入了类作用域，所以可以不用再提供模板参数。</li>
<li><strong>模板和非模板友类：如果一类模板包含了一个非类模板友元，则友元被授权可以访问所有模板实例；如果是包含模板友元，类可以授权给所有友元模板实例，也可以只授权特定实例：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">C2</span>&#123;</span><br><span class="line">	<span class="comment">//只要pal和C2的实例类型是一致的，那么实例化后的pal就是它的友类,</span></span><br><span class="line">	<span class="comment">//跟friend class BlobPtr&lt;T&gt;;一样</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">pal</span>&lt;T&gt;;</span><br><span class="line">	<span class="comment">//pal2的所有实例都是C2的友类，不管类型是否一样</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">x</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">pal2</span>;</span><br><span class="line">	<span class="comment">//对于非模板类，时C2所有实例的友类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">pal3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="类模板的静态成员">2.2.2 类模板的静态成员</h5>
<ul>
<li>对于任意给定的模板参数<code>X</code>，其都有<code>count_object、getStatic、addStatic</code>成员，所有的<code>foo&lt;x&gt;</code>类型对象都共享相同的<code>count_object、getStatic、addStatic</code>。注意时相同的类型参数<code>X</code>情况下共享，不同类型各自拥有</li>
<li>类外初始化要加上<code>tempalte&lt;class T&gt;</code>,如<code>template&lt;class T&gt;size_t Blob&lt;T&gt;::count_object = 0;</code></li>
<li>可以使用实例类访问<code>Blob&lt;String&gt;::getStatic()</code>，也可以使用实例化的对象访问<code>blob.getStatic()</code></li>
</ul>
<h4 id="模板参数">2.3 模板参数</h4>
<p>摸版参数（如上面一直用到的<code>T</code>）遵循普通作用域规则，一个模板参数的可用范围是其声明之后至模板声明或定义结束之前。它也会隐藏外层作用域中声明的相同的名字。</p>
<ul>
<li>模板声明需要包含模板参数，如：<code>template &lt;typename T&gt;int compare(const T&amp;, const T&amp;);</code></li>
<li>由于我们通过作用域运算符来访问静态成员和类型成员，但是在模板中，编译器无法区分访问的是类型还是静态成员。如<code>T::size_type *p</code>;到底是定义<code>p</code>变量还是将<code>size_type</code>这个静态成员与<code>p</code>相乘。为了区分，<strong>编译器是认为在模板中通过作用域访问的是变量。所以必须通过关键字<code>typename</code>来告诉编译器现在使用的是个类型</strong>，如前面类模板中的<code>typedef typename std::vector&lt;T&gt;::size_type size_type;</code></li>
</ul>
<p><strong>1. 默认模板实参</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tempalte&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">F</span>=less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b,F f=<span class="built_in">F</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(a,b))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(b,a))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为模板参数提供了<strong>默认实参</strong>，<strong>指出<code>compare</code>默认将使用标准库的<code>less</code>函数对象类，但用户调用该函数时可以提供自己的比较操作，但该操作接受的实参类型应当与<code>compare</code>的前两个类型兼容。</strong>对于一个模板参数，只有当它右侧所有参数都有默认实参时，它才可以有默认实参</p>
<p>如果一个类模板为其所有模板参数提供了默认实参，<strong>且希望使用默认实参，那么就必须在模板名后跟一个空尖括号</strong>。用int实例化的average_precision模板名后跟的是尖括号。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt;<span class="keyword">class</span> Numbers&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Numbers&lt;doubel&gt; los;</span><br><span class="line">Numebers&lt;&gt;average_precision;		<span class="comment">//使用默认实参</span></span><br></pre></td></tr></table></figure></p>
<h4 id="控制实例化">2.4 控制实例化</h4>
<p>当多个或多个独立的编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件就都会有该模板的一个实例类。在多个文件<strong>实例化相同模板类的额外开销可能非常严重</strong>。我们可以通过<strong>显式实例化来避免这种开销</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;	<span class="comment">//声明</span></span><br></pre></td></tr></table></figure> <strong><code>declaration</code>是一个类或函数的声明，其中所有模板参数已被替换为实参</strong>。遇到<code>extern</code>模板声明，编译不会在本文件中生成实例化代码，而是去别处寻找。声明必须出现在使用实例化版本的代码，否则会自动实例化，对于一个给定的实例化版本，可能有多个<code>extern</code>声明但只有一个定义。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extern声明，那么接下来实例化一个对应对象和函数并不会在本文件生成一个实例化类和函数</span></span><br><span class="line"><span class="comment">//简而言之，就是我这些类型的类和函数在别的地方定义，在这只是调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">int</span> <span class="title">conpare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;,<span class="type">const</span> <span class="type">int</span> &amp;)</span></span>;</span><br><span class="line">Blob&lt;String&gt; sa1,sa2;</span><br><span class="line"><span class="comment">//下面会在本文件生成一个int类型的实例化类（你看不到，但是编译器生成知道）</span></span><br><span class="line">Blob&lt;<span class="type">int</span>&gt; a1&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">Blob&lt;<span class="type">int</span>&gt; <span class="title">a2</span><span class="params">(a1)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="模板参数和返回值的推断">2.5 模板参数和返回值的推断</h4>
<p>从<strong>函数实参来确定模板实参的过程称为模板实参推断</strong>，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参生成的函数版本，与给定的函数调用最为匹配。</p>
<h5 id="类型转换与模板类型参数">2.5.1 类型转换与模板类型参数</h5>
<ul>
<li><strong>模板函数对const的转换要求很低</strong>。向函数模板传递参数时允许<code>const</code>转换：可以将<code>非const对象</code>的引用（或指针）传递给一个<code>const</code>引用（或指针）形参,也可以将<code>const</code>传递给<code>非const</code>，只不过const会被忽略</li>
<li>数组或函数指针转换，如果函数形参不是引用类型，数组实参转换为指向数组首元素的指针，函数实参转换为指向该函数的指针</li>
<li><strong>其他算术类型转换、派生类到基类的转换</strong>不能应用于函数模板。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">fobj</span><span class="params">(T,T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; T <span class="title">fref</span><span class="params">(<span class="type">const</span> T&amp;,<span class="type">const</span>&amp; T)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">s2</span><span class="params">(<span class="string">&quot;another value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1,s2);		<span class="comment">//调用fobj(string,string),const会被忽略</span></span><br><span class="line"><span class="built_in">fref</span>(s1,s2);		<span class="comment">//调用fref(const string&amp;,const string&amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a,b);			<span class="comment">//调用fobj(int*,int*)</span></span><br><span class="line"><span class="built_in">fobj</span>(a,b)/			<span class="comment">//错误，数字类型不能与引用匹配</span></span><br></pre></td></tr></table></figure>
<h5 id="函数模板必需显示实参情况">2.5.2 函数模板必需显示实参情况</h5>
<p>某些情况，编译器无法推断类型，我们希望用户指定<code>template &lt;typename T1, typename T2, typename T3&gt; T1 sum(T2, T3)</code>; 每次调用sum时调用者必须为<code>T1</code>提供一个显式模板实参(因为我们在实例化这个模板函数时，提供的实参只是<code>T2、T3</code>的，<strong>编译器能推断它们的类型，但无法推断T1的</strong>. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val3 = <span class="built_in">sum</span>&lt;<span class="type">long</span>  <span class="type">long</span>&gt;(i,lng);	<span class="comment">//此时T1是long long型的，</span></span><br></pre></td></tr></table></figure></p>
<h5 id="尾置返回类型与转换">2.5.3 尾置返回类型与转换</h5>
<p><strong>有时需返回一个元素的值，但是迭代器操作只能生成元素的引用而不是元素</strong>。为了获得元素类型，可以使用标准库的类型转换：<code>remove_reference&lt;int&amp;&gt;</code>则它的<code>type</code>成员会是<code>int</code> 。更一般地<code>remove_reference&lt;decltype(beg*)&gt;::type</code> 将获得beg引用元素的类型，组合使用<code>remove_reference</code>尾置返回和<code>decltyp</code>e，就可以在函数中返回元素值的拷贝: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此例中我们通知编译器fcn2的返回类型与解引用beg的参数的结果类型相同</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(T beg,T end)</span>-&gt;<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于下面这个，但是不能用，因为此时*beg标识符未定义，只能后置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">typename remove_reference&lt;decltype(*beg)&gt;::type fcn(T beg,T end)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	return *beg;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>type</code>是一个类的成员，所以必须在返回类型的声明中用<code>typename</code>显式告知编译器返回的是一个类型。</li>
<li><code>decltype</code>关键字，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值</li>
</ul>
<h5 id="模板函数的例外规则即对称对move的支持">2.5.4 模板函数的例外规则（即对称）对move的支持</h5>
<p><strong>模板库例外规则支持move标准库的正确工作：</strong> - 第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值<code>i</code>传递给函数的右值引用参数，且此右值引用为模板参数类型<code>T&amp;&amp;</code>时，编译器推断模板类型参数为实参的左值引用类型（<strong>即右值引用的这种函数模板支持传入左值</strong>） - 在第一例外规则的基础上，第二个例外绑定规则：如果我们间接创建一个引用的引用（实参传入形参），则这些引用形成“折叠”：在所有情况下（除一个例外），引用会折叠成一个普通左值引用类型： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="title">func</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="comment">//实参传入为左值引用X&amp;</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; m=i;</span><br><span class="line"><span class="type">int</span>&amp;&amp; a=<span class="built_in">move</span>(i);</span><br><span class="line"><span class="built_in">func</span>(i);		<span class="comment">//传入左值i,则int&amp;和int&amp;&amp;折叠成int&amp;</span></span><br><span class="line"><span class="built_in">func</span>(a);		<span class="comment">//传入右值a,则int&amp;&amp;和int&amp;&amp;折叠成int&amp;&amp;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>即函数参数时<code>T&amp;&amp;</code>，就意味着我们既可以传递给move一个右值，也可以是左值</strong>，下面以<code>move</code>函数源码为例子探索模板函数的该原理：</p>
<ul>
<li><code>std::move(string(&quot;byte&quot;))</code>向<code>move</code>传递的是一个<strong>右值</strong>，推断出的<code>T</code>的类型为<code>string</code>因此将模板实例化，<code>type</code>类型为<code>string</code>, <code>t</code>的类型为<code>string&amp;&amp;</code>，move的返回类型为<code>string&amp;&amp;</code>,函数体返回<code>static_cast&lt;string&amp;&amp;&gt; (t)</code> 然而<code>t</code>的类型已经是<code>string&amp;&amp;</code>所以类型转换什么都不做，因此调用结果就是右值引用。</li>
<li>如果向<code>move</code>传递一个左值，推断出T类型为<code>string&amp;</code> ,<code>remove_reference</code>用<code>string&amp;</code>进行实例化，故其<code>type</code>成员为<code>string</code>，返回类型<code>string&amp;&amp;</code>,<code>t</code>实例化为<code>string&amp;</code>,<code>string&amp; string&amp;&amp;</code>折叠为<code>string&amp;</code> 故,<code>string&amp;&amp; move(string&amp; t)</code>这也正是我们希望的：将一个右值引用绑定到一个左值，返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code></li>
<li>通常情况下，<code>static_cast</code>只能用于合法的类型转换，但是针对右值引用，可以显式地将左值转换为右值引用，而对于操作右值的代码来说，将右值绑定到左值特性允许它们截断左值，尽管编译器允许这种用法，但是要求我们<code>static_cast</code>以防止意外地转换。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;<span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载与模板">2.6 重载与模板</h4>
<p><strong>函数模板可以被另一个模板或一个普通非模板函数重载</strong>，名字相同的函数必须有不同数量或类型的参数。<strong>匹配规则：</strong></p>
<ul>
<li>和往常一样，如果恰有一个函数提供比任何其他函数更好的匹配，则选择此函数，但是，如果有多个函数提供同样好的匹配，则：</li>
<li>如果同样好的函数中只有一个是非模板函数，则选在此函数</li>
<li>如果同样好的函数中没有非模板，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板，否则，此调用有歧义</li>
</ul>
<p><strong><em>注意：</em></strong>在定义任何函数之前，记得声明所有重载的函数版本，这样就不必担心编译器由于未遇到希望调用的函数而实例化一个并非你所需的版本</p>
<h4 id="可变参数模板">2.7 可变参数模板</h4>
<p><strong>可变参数模板，即一个接受可变数目参数的模板函数或模板类</strong>。可变数目的参数被称为<strong>参数包</strong>，存在两种参数包，一是模板参数包，表示零个或多个模板参数；二是函数参数包，表示零个或多个函数参数。通过用一个省略号来指出一个模板参数或函数参数表示一个包:</p>
<ul>
<li><code>class…</code> 或<code>typename…</code>指出接下来表示零个或多个类型的列表；</li>
<li>一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表</li>
<li>在一个函数参数列表中，如果一个参数的类型是模板参数包，则此参数也是一个函数参数包</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Args 是一个模板参数包；rest 是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args 表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest 表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp; ... rest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="type">double</span> d = <span class="number">3.14</span>; string s = <span class="string">&quot;how now brown cow&quot;</span>;</span><br><span class="line"><span class="built_in">foo</span>(i, s, <span class="number">42</span>, d);	<span class="comment">//相当于void foo(const int&amp;, const string&amp;, const int&amp;, const double&amp;);</span></span><br><span class="line"><span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);	<span class="comment">//相当于void foo(const string&amp;， const int&amp;, const char[3]&amp;);</span></span><br><span class="line"><span class="built_in">foo</span>(d, s);			<span class="comment">//相当于void foo(const double&amp;, const string&amp;);</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>);			<span class="comment">//相当于void foo(const char[3]&amp;);</span></span><br></pre></td></tr></table></figure>
<h5 id="sizeof运算符">2.7.1 sizeof…运算符</h5>
<p>当想要知道包中有多少元素时，可以使用 sizeof… 运算符，其返回一个常量表达式，且不会对其实参求值 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Args&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(Args...args)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; endl;	<span class="comment">//类型参数的数目</span></span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;	<span class="comment">//函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="编写可变参数函数模板">2.7.2 编写可变参数函数模板</h5>
<ul>
<li>可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身</li>
<li>为了终止递归，还需要定义一个非可变参数的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来终止递归并打印最后一个元素的函数，其实可变参数模板也能匹配，但是非可变模板更特例化，因此编译器会选择非可变参数版本</span></span><br><span class="line"><span class="comment">//此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包中除了最后一个元素之外的其他元素都会调用这个版本的 print</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;...rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;			  <span class="comment">//打印第一个实参</span></span><br><span class="line">	<span class="comment">//递归调用，打印其他实参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);<span class="comment">//递归传参时，rest 的第一个参数赋给形参的 const T&amp; t，剩下的参数继续以参数包 rest 存在，并继续递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到了一个专业化名词<strong>包扩展</strong>，即是指可变参数函数模版在一次次<strong>调归后对模板参数包和函数参数包的展开</strong>，下列代码是对上述的解释： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;...rest)</span>	<span class="comment">//扩展Args，为print生成函数参数列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);								<span class="comment">//扩展rest，为print递归调用生成实参列表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于Args的扩展</span></span><br><span class="line"><span class="built_in">print</span>(cout, i, s, <span class="number">42</span>);	<span class="comment">//包中有两个参数</span></span><br><span class="line"><span class="comment">//实例化为ostream&amp; print(ostream&amp;, const int&amp;, const string&amp;, const int&amp;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于第二个扩展，发生在对print的递归调用中</span></span><br><span class="line"><span class="comment">//模式是函数参数包的名字（即rest），此模式扩展出一个由包中元素组成的、逗号分隔的列表，因此等价于</span></span><br><span class="line"><span class="built_in">print</span>(os, s, <span class="number">42</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="函数模板特例化">2.8 函数模板特例化</h4>
<p>在某些情况下，通用模板的定义对特定类型是不适合的，但通用定义又可能编译失败或做得不正确。因此，有时可以利用特定知识编写更高效的代码，而非从通用模板实例化，因此当不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本。</p>
<p><strong><em>注意</em></strong>函数模板只有全特例化，不存在偏特化，你认为的偏特化只是重载函数模板</p>
<h5 id="定义函数模板特例化">2.8.1 定义函数模板特例化</h5>
<ul>
<li>当特例化一个函数模板时，<strong>必须为原模板中的每一个模板参数提供实参</strong>。</li>
<li>为了指出正在实例化一个模板，应该使用关键字<code>template&lt;&gt;</code>,指出将为原模板所有模板参数提供实参</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;	<span class="comment">//声明放前面</span></span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; p1, <span class="type">const</span> T&amp; p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compare 的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p1, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;typname T&gt;<span class="function"><span class="type">int</span> <span class="title">campare</span><span class="params">(<span class="type">const</span> T* p1,<span class="type">const</span> T* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(*p1,*p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="函数重载与模板特例化">2.8.2 函数重载与模板特例化</h5>
<ul>
<li>当定义函数模板的特例化版本时，本质上是接管了编译器的工作，为原模板的一个特殊实例提供了定义</li>
<li>特例化的本质是实例化一个模板，而非重载，因此特例化影响象函数匹配</li>
<li>为了特例化一个模板，原模板的声明必须在作用域中，而且，在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中</li>
<li>模板及其特例化版本应该声明在同一个头文件中，所有同名模板的声明应该放在前面，然后是这些模板的特例化版本</li>
</ul>
<h4 id="类模板部分特例化">2.9 类模板部分特例化</h4>
<ul>
<li>与函数模板不同，<strong>类模板的特例化不必为所有模板参数提供实参，可以只指定一部分而非所有模板参数</strong>，或是参数的一部分而非全部特性,即类模板支持偏特化。</li>
<li>我们只能部分特例化类模板，而不能部分特例化函数模板，函数模板不支持偏特化</li>
<li><strong>我们可以只特例化特定成员函数而不是特例化整个类模板</strong></li>
<li><strong>类模板即可以全特化，也可以偏特化</strong></li>
</ul>
<h6 id="类全特化">2.9.1 类全特化</h6>
<p>类模板全特化比较好理解，跟函数模板一样，全特化已经是一个类实例了，当编译器匹配时会优先匹配参数一致的实例 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">	<span class="built_in">Foo</span>(<span class="type">const</span> T &amp;t ): <span class="built_in">mem</span>(t)&#123; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">	T mem;</span><br><span class="line">	<span class="comment">//Foo的其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全特化类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">struct</span> <span class="title class_">Foo</span>(string*)</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;	<span class="comment">//实例化Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();		<span class="comment">//实例化Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo fi;			<span class="comment">//调用全特化实例化Foo&lt;string*&gt;::Foo()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();		<span class="comment">//使用全特化的类</span></span><br></pre></td></tr></table></figure></p>
<h5 id="类偏特化">2.9.2 类偏特化</h5>
<p>对类模板我们可以进行偏特化，比如下面这个类 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;      <span class="comment">// 普通类模板，有两个模板参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定一部分参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;　　　         <span class="comment">// 偏特化版本，指定其中一个参数，即指定了部分类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&lt;<span class="type">int</span> , T2&gt; &#123; ..... &#125;;　　<span class="comment">// 当实例化时的第一个参数为int 则会优先调用这个版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者只特化里面的函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;			<span class="comment">//正在特例化一个函数成员模板</span></span><br><span class="line"><span class="type">void</span> B&lt;<span class="type">int</span>&gt;::Bar	<span class="comment">//正在特例化B&lt;int&gt;的成员Bar</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//进行应用于int的特例化处理</span></span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">还有一种更为重要的特例化形式，在traits编程技法中会用到，以达到完美解决对于原生指针无法进行返回值说明的问题（详间STL源码剖析中的迭代器部分）</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;　　　<span class="comment">//这个偏特化版本只接收指针类型的模板实参 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&lt;T*&gt; &#123; ..... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&lt;T&amp;&gt; &#123; ..... &#125;;     <span class="comment">// 这个偏特化版本只接受引用类型的模板实参</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU15-445-FALL2022-PROJECT_0</title>
    <url>/2023/05/22/CMU15-445-FALL2023-PROJECT-0/</url>
    <content><![CDATA[<h3 id="介绍">1 介绍</h3>
<p>此次project0项目是实现一个键值对存储，数据结构由<strong>写时复制的字典树</strong>构成。实现的键-值存储可以存储映射到任何类型值的字符串键。键的值存储在表示该键的最后一个字符的节点中(又称终端节点)。例如，考虑在trie中插入kv对(&quot;ab&quot;， 1)和(&quot;ac&quot;， &quot;val&quot;)。 <img src="/2023/05/22/CMU15-445-FALL2023-PROJECT-0/keyvalue.png" width="500"></p>
<h3 id="task1copy-on-write-trie">2 Task1:Copy-On-Write trie</h3>
<ul>
<li><p>在本任务中，只需要修改<code>trie .h</code>和<code>trie .cpp</code>来实现写时复制(copy-on-write) tree。<strong>在写即复制tree中，操作不会直接修改原始tree中的节点。相反，将为修改后的数据创建新节点，并为新修改的trie返回一个新根</strong>。写时复制(Copy-on-write)使我们能够在每次操作之后随时以最小的开销访问该树。考虑在上面的例子中插入<code>(&quot;ad&quot;， 2)</code>。我们通过重用原始树中的两个子节点来创建一个新的Node2，并创建一个新的值节点2。(见下图) <img src="/2023/05/22/CMU15-445-FALL2023-PROJECT-0/new1.png" width="700"></p></li>
<li><p>插入<code>(&quot;b&quot;， 3)</code>，我们将创建一个新的根，一个新的节点，并重用以前的节点。通过这种方式，我们可以在每次插入操作之前和之后获得树的内容。只要我们有根对象(Trie类)，我们就可以访问当时Trie中的数据。(见下图) <img src="/2023/05/22/CMU15-445-FALL2023-PROJECT-0/new2.png" width="700"></p></li>
<li><p>插入<code>(“a”，“abc”)</code>并删除<code>(“ab”，1)</code>，我们可以得到下面的trie。注意，父节点可以有值，并且在删除后需要清除所有不必要的节点。 <img src="/2023/05/22/CMU15-445-FALL2023-PROJECT-0/new3.png" width="700"></p></li>
</ul>
<p>因此，在这里你需要实现三个函数：</p>
<ul>
<li><p><code>Get(key)</code>:获取键对应的值。</p></li>
<li><p><code>Put(key, value)</code>:设置键对应的值。如果键已经存在，则覆盖现有值。注意，值的类型可能是不可复制的(即<code>std::unique_ptr&lt;int&gt;</code>)。这个方法返回一个新的树。</p></li>
<li><p><code>Delete(key)</code>:删除键的值。这个方法返回一个新的树。</p></li>
</ul>
<blockquote>
<p>这些操作都不应该直接在trie本身上执行。您应该创建新的树节点，并尽可能重用现有的树节点。 要创建一个新节点，您应该使用<code>TrieNode</code>类上的<code>Clone</code>函数。要重用新树中的现有节点，可以复制<code>std::shared_pt&lt;TrieNode&gt;</code>复制共享指针不会复制底层数据。您不应该在此项目中通过使用<code>new</code>和<code>delete</code>手动分配内存。当没有人有对底层对象的引用时，<code>std::shared_ptr</code>将释放对象。</p>
</blockquote>
<p>分析：</p>
<ul>
<li><strong>节点类<code>TrieNode</code>使用<code>map&lt;char, std::shared_ptr&lt;const TrieNode&gt;&gt;</code>来存储这种键值结构，</strong>，在这里另一个重要的函数是<code>Clone</code>函数（使用了C++类的构造函数的隐式转换)，<code>Clone</code>函数实现新建树中现有节点</li>
<li><strong>叶子类<code>TrieNodeWithValue</code></strong>，继承于<code>TrieNode</code>，增加了叶子节点存值功能</li>
<li><code>Trie</code>类，内部声明了<code>root</code>（初始为NULL),三个上述待实现的功能</li>
</ul>
]]></content>
      <tags>
        <tag>CMU15-445 lab</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU15-445-FALL2022-HOMEWORK1</title>
    <url>/2023/05/21/CMU15-445-FALL2023-HOMEWORK1/</url>
    <content><![CDATA[<h3 id="实验准备">1 实验准备</h3>
<p><a href="https://15445.courses.cs.cmu.edu/fall2022/homework1/">作业地址</a></p>
<p>实验当中提供的数据库，其中表关系如下： <img src="/2023/05/21/CMU15-445-FALL2023-HOMEWORK1/schema.png" width="700"></p>
<p>索引创建如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE INDEX ix_people_name ON <span class="title">people</span> <span class="params">(name)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_titles_type ON <span class="title">titles</span> <span class="params">(type)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_titles_primary_title ON <span class="title">titles</span> <span class="params">(primary_title)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_titles_original_title ON <span class="title">titles</span> <span class="params">(original_title)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_akas_title_id ON <span class="title">akas</span> <span class="params">(title_id)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_akas_title ON <span class="title">akas</span> <span class="params">(title)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_crew_title_id ON <span class="title">crew</span> <span class="params">(title_id)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_crew_person_id ON <span class="title">crew</span> <span class="params">(person_id)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="sqlite3的一些特性">2 SQLite3的一些特性</h3>
<ul>
<li><p><code>SQLite3</code>与<code>MySQL</code>的一些不同是一些命另和函数，其数据库的使用直接采用： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">imdb-cmudb2022.db  placeholder</span><br><span class="line">$ sqlite3 imdb-cmudb2022.db</span><br></pre></td></tr></table></figure></p></li>
<li><p>查看表： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .tables</span><br><span class="line">akas      crew      episodes  people    ratings   titles</span><br></pre></td></tr></table></figure></p></li>
<li><p>查看表结构 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .<span class="function">schema people</span></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">people</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  person_id VARCHAR PRIMARY KEY,</span></span></span><br><span class="line"><span class="params"><span class="function">  name VARCHAR,</span></span></span><br><span class="line"><span class="params"><span class="function">  born INTEGER,</span></span></span><br><span class="line"><span class="params"><span class="function">  died INTEGER</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">CREATE INDEX ix_people_name ON <span class="title">people</span> <span class="params">(name)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>更大命令使用<code>.help</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .help</span><br></pre></td></tr></table></figure></p></li>
</ul>
<blockquote>
<p>注意，MySQL当中的一些函数，SQLite未必有，就如<code>concat</code>我就发现没有，SQLite使用<code>||</code>替代字符串拼接</p>
</blockquote>
<h3 id="实验问题">3 实验问题</h3>
<blockquote>
<p>2022 #### 3.1 <code>Q2 [5 points] (q2_sci_fi)</code> <code>Find the 10</code>Sci-Fi<code>works with the longest runtimes.</code> <strong><code>Details:</code></strong> <code>Print the title of the work, the premiere date, and the runtime. The column listing the runtime should be suffixed with the string &quot; (mins)&quot;, for example, if the runtime_mins value is</code>12<code>, you should output 12 (mins). Note a work is Sci-Fi even if it is categorized in multiple genres, as long as Sci-Fi is one of the genres.</code> <code>Your first row should look like this: Cicak-Man 2: Planet Hitam|2008|999 (mins)</code></p>
</blockquote>
<blockquote>
<p>找出10个运行时间最长的“科幻”作品。输出其<code>primary_title、primiered、runtime_minutes</code>，其中<code>runtime_minutes</code>后边要接<code>(mins)</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SELECT PRIMARY_TITLE,PREMIERED,(RUNTIME_MINUTES||<span class="string">&#x27; (mins)&#x27;</span> )</span><br><span class="line">FROM TITLES </span><br><span class="line">WHERE GENRES LIKE <span class="string">&#x27;%Sci-Fi&#x27;</span> </span><br><span class="line">order by RUNTIME_MINUTES DESC LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<h4 id="q3_oldest_people">3.2 <code>q3_oldest_people</code></h4>
<p><code>Determine the oldest people in the dataset who were born in or after 1900. You should assume that a person without a known death year is still alive.</code> <strong>Details:</strong> <code>Print the name and age of each person. People should be ordered by a compound value of their age and secondly their name in alphabetical order. Return the first 20 results.</code></p>
</blockquote>
<blockquote>
<p>Your output should have the format: <code>NAME|AGE</code></p>
</blockquote>
<blockquote>
<p>找出出生于1900后（包含1900），年龄最大的20个人，按照年龄年龄和姓名的字母联合排序。注意没有死亡日期，证明还活着，你要能够处理这类数据 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">select name,</span><br><span class="line"><span class="keyword">case</span></span><br><span class="line">    when died is null then <span class="number">2022</span>-born</span><br><span class="line">    <span class="keyword">else</span> died-born</span><br><span class="line">end as age</span><br><span class="line">from people</span><br><span class="line">where born&gt;=<span class="number">1900</span> order by age desc,name limit <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>2023</p>
</blockquote>
<h4 id="q2_not_the_same_title">3.1 <code>q2_not_the_same_title</code></h4>
<p><code>Find the 10 Action movies with the newest premiere date whose original title is not the same as its primary title.</code></p>
<p><strong>Details:</strong> Print the premiere year, followed by the two titles in a special format. The column listing the two titles should be in the format of primary_title (original_title) Note a work is Action even if it is categorized in multiple genres, as long as Action is one of the genres. Also note that it's possible for the premiered year to be in the future. If multiple movies premiered in the same year, order them alphabetically. Your first row should look like this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SELECT PREMIERED,(PRIMARY_TITLE||<span class="string">&#x27; (&#x27;</span>||ORIGINAL_TITLE||<span class="string">&#x27;)&#x27;</span>) AS T </span><br><span class="line">FROM TITLES </span><br><span class="line">WHERE PRIMARY_TITLE!=ORIGINAL_TITLE </span><br><span class="line">	AND GENRES LIKE <span class="string">&#x27;%Action%&#x27;</span> </span><br><span class="line">order by PREMIERED DESC,T LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="q3_longest_running_tv">3.2 <code>q3_longest_running_tv</code></h4>
<p><code>Find the top 20 longest running tv series.</code></p>
<p><strong><code>Details</code>: </strong><code>Print the title and the years the series has been running for. The series must have a non NULL premiered year. If the ended date is NULL, assume it to be the current year (2023). If multiple tv series have been running the same number of years, order them alphabetically. Print the top 20 results.</code></p>
<p>Your output should have the format: TITLE|YEARS_RUNNING Your first row should look like this:<code>Looney Tunes|93</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SELECT PRIMARY_TITLE,</span><br><span class="line">CASE </span><br><span class="line">	WHEN ENDED IS <span class="literal">NULL</span> THEN <span class="number">2023</span>-PREMIERED </span><br><span class="line">	ELSE ENDED-PREMIERED </span><br><span class="line">END AS YEARS_RUNNING </span><br><span class="line">FROM TITLES </span><br><span class="line">WHERE PREMIERED IS NOT <span class="literal">NULL</span> </span><br><span class="line">	AND TYPE=<span class="string">&#x27;tvSeries&#x27;</span> </span><br><span class="line">ORDER BY YEARS_RUNNING DESC,PRIMARY_TITLE LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<h4 id="q4_directors_in_each_decade">3.3 <code>q4_directors_in_each_decade</code></h4>
<p>List the number directors born in each decade since 1900.(计算自1900年以来每10年出生的导演人数)</p>
<p><strong>Details:</strong> Print the decade in a fancier format by constructing a string that looks like this: 1990s. Order the results by decade.</p>
<p>Your output should look like this: <code>DECADE|NUM_DIRECTORS</code> Your first row should look like this: <code>1900s|376</code></p>
<p><strong>分析：从事领域存储在<code>crew</code>表的<code>category</code>,其中人的出生时期存储在<code>people</code>表，两表通过<code>person_id</code>联结，<code>people</code>的为主键，<code>crew</code>的为外键</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SELECT decade || <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">    <span class="built_in">COUNT</span>(*)</span><br><span class="line"><span class="built_in">FROM</span> (</span><br><span class="line">        SELECT <span class="built_in">DISTINCT</span>(people.person_id),</span><br><span class="line">            <span class="built_in">FLOOR</span>(people.born / <span class="number">10</span>) * <span class="number">10</span> AS decade</span><br><span class="line">        FROM people</span><br><span class="line">            INNER JOIN crew ON crew.person_id = people.person_id</span><br><span class="line">        WHERE crew.category = <span class="string">&#x27;director&#x27;</span></span><br><span class="line">            AND people.born &gt;= <span class="number">1900</span></span><br><span class="line">    )</span><br><span class="line">GROUP BY decade</span><br><span class="line">ORDER BY decade;</span><br></pre></td></tr></table></figure>
<p><strong>上面的group by decade1</strong>最重要，这样<code>count()</code>会以<code>decade</code>组区分进行统计</p>
<h4 id="q5_german_type_ratings">3.4 <code>q5_german_type_ratings</code></h4>
<p><code>Compute statistics about different type of works that has a German title</code>.(计算具有德语标题的不同类型作品的统计数据。) <strong><code>Details:</code></strong> <code>Compute the average (rounded to 2 decimal places), min, and max rating for each type of work that has a German title and the akas types is either imdbDisplay or original. Sort the output by the average rating of each title type.</code>(计算具有德语标题且<code>akas</code>类型为<code>imdbDisplay</code>或<code>original</code>的每种类型的作品的平均值(舍入到小数点后2位)、最小值和最大值。按每个标题类型的平均评分对输出进行排序。)</p>
<p>Your output should have the format: <code>TITLE_TYPE|AVG_RATING|MIN_RATING|MAX_RATING</code> Your first row should look like this:<code>movie|6.65|3.4|8.2</code></p>
<p><strong>分析：<code>titles</code>表、<code>akas</code>和<code>ratings</code>表通过<code>title_id</code>进行联结，其中<code>titles</code>中作为主键，<code>akas</code>和<code>ratings</code>作为外键。要求<code>akas.types in ('imdbDisplay','original') and akas.language='de'</code>,计算平均值、最大值、最小值</strong>。为三表查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SELECT T.TYPE, <span class="built_in">ROUND</span>(<span class="built_in">AVG</span>(R.RATING),<span class="number">2</span>),<span class="built_in">MIN</span>(R.RATING),<span class="built_in">MAX</span>(R.RATING)</span><br><span class="line">FROM TITLES AS T</span><br><span class="line">	INNER JOIN AKAS AS A ON T.TITLE_ID=A.TITLE_ID</span><br><span class="line">	INNER JOIN RATINGS AS R ON T.TITLE_ID=R.TITLE_ID</span><br><span class="line">WHERE A.TYPES <span class="built_in">IN</span> (<span class="string">&#x27;imdbDisplay&#x27;</span>,<span class="string">&#x27;original&#x27;</span>)</span><br><span class="line">	AND A.LANGUAGE=<span class="string">&#x27;de&#x27;</span></span><br><span class="line">GROUP BY T.TYPE</span><br><span class="line">ORDER BY T.TYPE;</span><br></pre></td></tr></table></figure>
<h4 id="q6_who_played_a_batman">3.5 <code>q6_who_played_a_batman</code></h4>
<p><code>List the 10 highest rated actors who played a character named &quot;Batman&quot;.</code>(请列出出演过“蝙蝠侠”角色的10位评价最高的演员) <strong><code>Details:</code> </strong><code>Calculate the actor rating by taking the average rating of all their works. Return both the name of the actor and their rating and only list the top 10 results in order from highest to lowest rating. Round average rating to the nearest hundredth.</code>(通过取所有作品的平均评分来计算演员的评分。返回演员的名字和他们的评分，并且只按评分从高到低的顺序列出前10个结果。四舍五入平均评级到最接近的百分之一。)</p>
<p>Make sure your output is formatted as follows: <code>Kayd Currier|8.05</code></p>
<p><strong>分析</strong>：<code>name</code>在<code>people</code>表，<code>rating</code>在<code>ratings</code>表，<code>characters</code>在<code>crew</code>表，其中三者的联结依赖主外键，<code>ratings</code>和<code>crew</code>通过<code>title_id</code>联结，<code>crew</code>和<code>people</code>通过<code>person_id</code>联结，要求<code>crew.characters like '%Batman%'</code>。<strong>可将<code>people</code>和<code>crew</code>先用<code>person_id</code>进行内连接得到actor,然后利用actor与<code>ratings</code>连接</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">WITH actors <span class="title">AS</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SELECT DISTINCT(crew.person_id) AS person_id,</span></span></span><br><span class="line"><span class="params"><span class="function">        people.name AS person_name</span></span></span><br><span class="line"><span class="params"><span class="function">    FROM crew</span></span></span><br><span class="line"><span class="params"><span class="function">        INNER JOIN people ON people.person_id = crew.person_id</span></span></span><br><span class="line"><span class="params"><span class="function">    WHERE crew.characters LIKE <span class="string">&#x27;%&quot;Batman&quot;%&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        AND crew.category = <span class="string">&quot;actor&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function">SELECT a.person_name,</span></span><br><span class="line"><span class="function">    <span class="title">ROUND</span><span class="params">(AVG(rating), <span class="number">2</span>)</span> AS average</span></span><br><span class="line"><span class="function">FROM actors AS a</span></span><br><span class="line"><span class="function">    INNER JOIN crew AS c ON c.person_id </span>= a.person_id</span><br><span class="line">    INNER JOIN ratings AS r ON c.title_id = r.title_id</span><br><span class="line">GROUP BY a.person_id</span><br><span class="line">ORDER BY average DESC</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>上述等价于： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SELECT A.name,<span class="built_in">ROUND</span>(<span class="built_in">AVG</span>(R.rating),<span class="number">2</span>) <span class="function">AS SCORE</span></span><br><span class="line"><span class="function"><span class="title">FROM</span> <span class="params">(SELECT DISTINCT(C.person_id),P.name,C.title_id</span></span></span><br><span class="line"><span class="params"><span class="function">	FROM crew AS C</span></span></span><br><span class="line"><span class="params"><span class="function">	INNER JOIN people AS P ON C.person_id=P.person_id</span></span></span><br><span class="line"><span class="params"><span class="function">	WHERE C.characters LIKE <span class="string">&#x27;%&quot;Batman&quot;%&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">		AND C.category = <span class="string">&#x27;actor&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span> AS A</span></span><br><span class="line"><span class="function">	INNER JOIN crew AS C ON C.person_id</span>=A.person_id</span><br><span class="line">	INNER JOIN ratings AS R ON C.title_id=R.title_id</span><br><span class="line">GROUP BY A.person_id</span><br><span class="line">ORDER BY SCORE DESC</span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="q7_born_with_prestige">3.6 <code>q7_born_with_prestige</code></h4>
<p><code>List the number of actors or actress who were born on the year that &quot;The Prestige&quot; was premiered.</code>(列出在《致命魔术》首映那一年出生的演员人数。) <strong><code>Details</code>:</strong> <code>Print only the total number of actors born that year. For this question, determine distinct people by their person_id, not their names. Do not hard code the query.</code>(只打印当年出生的演员总数。对于这个问题，确定不同的人通过他们的person_id，而不是他们的名字。不要硬编码查询。)</p>
<p><strong>分析</strong>：<code>born</code>在<code>people</code>表，<code>primary_title</code>在<code>title</code>表，因此需要将<code>crew</code>与<code>people</code>联结起来。加上条件<code>category IN ('actor', 'actress')和primary_title = 'The Prestige'</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">COUNT</span><span class="params">(DISTINCT(p.person_id))</span></span></span><br><span class="line"><span class="function">FROM people AS p</span></span><br><span class="line"><span class="function">    INNER JOIN crew AS c ON p.person_id </span>= c.person_id</span><br><span class="line">WHERE c.<span class="function">category <span class="title">IN</span> <span class="params">(<span class="string">&#x27;actor&#x27;</span>, <span class="string">&#x27;actress&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    AND p.born <span class="title">IN</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        SELECT premiered</span></span></span><br><span class="line"><span class="params"><span class="function">        FROM titles</span></span></span><br><span class="line"><span class="params"><span class="function">        WHERE primary_title = <span class="string">&#x27;The Prestige&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="q8_directing_rose.sql">3.7 <code>q8_directing_rose.sql</code></h4>
<p><code>Find all the directors who have worked with an actress with first name &quot;Rose&quot;.</code>(找出所有与名字为“Rose”的女演员合作过的导演。) <strong><code>Details:</code></strong> <code>Print only the names of the directors in alphabetical order. Each name should only appear once in the output.</code></p>
<p><strong>分析：</strong><code>category</code>在表<code>crew</code>,<code>name</code>在<code>people</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> title_ids <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> c.title_id <span class="keyword">AS</span> title_id</span><br><span class="line">    <span class="keyword">FROM</span> crew <span class="keyword">AS</span> c</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span> people <span class="keyword">AS</span> p <span class="keyword">ON</span> p.person_id = c.person_id</span><br><span class="line">    <span class="keyword">WHERE</span> p.name <span class="keyword">like</span> <span class="string">&#x27;Rose%&#x27;</span></span><br><span class="line">        <span class="keyword">AND</span> c.category = <span class="string">&#x27;actress&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(p.name) <span class="keyword">AS</span> <span class="type">name</span></span><br><span class="line"><span class="keyword">FROM</span> title_ids <span class="keyword">AS</span> t</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> crew <span class="keyword">AS</span> c <span class="keyword">ON</span> t.title_id = c.title_id</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> people <span class="keyword">AS</span> p <span class="keyword">ON</span> p.person_id = c.person_id</span><br><span class="line"><span class="keyword">WHERE</span> c.category = <span class="string">&#x27;director&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">name</span>;</span><br></pre></td></tr></table></figure>
<h4 id="section">3.8</h4>
]]></content>
      <tags>
        <tag>CMU15-445 lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++</title>
    <url>/2022/10/29/Effective-C/</url>
    <content><![CDATA[<p><strong>在本笔记中主要对《Effective C++》一书中的重要条款做学习笔记，提取当中主要的知识点和面试考点，读者在进行<code>C plus plus</code>岗位面试前可细读该篇文章的（重要）部分。</strong></p>
<h5 id="条款1视c为一个语言联邦">1 条款1：视C++为一个语言联邦</h5>
<p>在C++中我们总会有一种错觉，那就是人为C++主要就是面向对象的编程，但是这是不全面的，作为从C中延伸的语言，它保留了C的特性，也集成了许多新的功能，你可理解成:</p>
<ul>
<li>C：以C为基础。</li>
<li>面向对象的C++：添加面向对象特性。</li>
<li>模板C++：泛型编程概念，使用模板。</li>
<li>STL：使用STL的容器、迭代器、算法、及函数对象。</li>
</ul>
<p>四者的集合</p>
<span id="more"></span>
<h5 id="条款2尽量用编译器替换预处理器">2 条款2：尽量用编译器替换预处理器</h5>
<p>在C/C++中，我们明白一个程序流程为<code>预处理--&gt;编译--&gt;汇编--&gt;链接</code>，在预处理阶段中，我们对文件内的进行<strong>头文件展开、宏替换和去注释</strong>等预处理操作。那么也就是说<strong>像宏定义相关的定义从未被编译器看见</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.645</span></span><br></pre></td></tr></table></figure> 上面的记号名称<code>ASPECT_RATIO</code>也许在编译器开始处理源码之前它就被预处理器移走了，于是该记号就没有进入<strong>记号表（在二进制文件即生成的<code>.o</code>文件中）</strong>。那么当你运用此常量但获得一个编译错误信息时，这个错误信息也许只会提到<code>1.653</code>而不是<code>ASPECT_ARTIO</code>，而它又被定义在一个非你所写的头文件，那么你对<code>1.635</code>来自何处毫无概念，你要耗费大量时间寻找它。</p>
<p>用<code>const</code>替换<code>#define</code>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> AspectRatio=<span class="number">1.635</span>;</span><br></pre></td></tr></table></figure> 作为一个常量，它肯定能被编译器看到并放到符号表内。</p>
<p>基于上述的一个讲解，因此对于条款2有一下准则：</p>
<ul>
<li>对于单纯常量，尽量以<code>const</code>对象或<code>enums</code>枚举来代替#define。</li>
<li>若用<code>define</code>的可能会导致程序出出现多份目标码，而常量不会出现这种情况</li>
<li>取一<code>enum</code>的地址就不合法，这种行为和<code>define</code>类似因此可以用此来代替<code>define</code> ，如果你不想让别人获得一个<code>pointer</code>或<code>reference</code>指向你的某个整数常量，<code>enum</code>可以帮助你实现这个约束。</li>
<li>对于函数宏，用<code>inline</code>函数代替<code>#define</code>（<code>define</code>是死板的替换，容易产生传递计算式类似累加多次的问题）</li>
</ul>
<h5 id="条款3尽可能使用const重要">3. 条款3：尽可能使用const(重要)</h5>
<p><code>const</code>是C++中最为常用、也是最为强大的一个关键字，也是面试过程中极有可能问到的。<strong><code>const</code>可以修饰变量、指针、引用、函数、static</strong>。在说其详细应用时，我们必须先去了解<code>const</code>规则：</p>
<ul>
<li><code>const</code>修饰指针时分为底层<code>const</code>和顶层<code>const</code>。</li>
<li>非<code>const</code>变量可以赋值给<code>const</code>变量，反之不行。</li>
<li><code>const</code>常量必须被初始化</li>
<li>后续不能对<code>const</code>常量做改变</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础</title>
    <url>/2023/08/30/Go%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2023/08/06/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="什么是kmp算法">什么是KMP算法</h2>
<p>KMP算法一种改进的模式匹配算法，是D.E.Knuth、J.H.Morris、V.R.Pratt于1977年联合 发表。<strong>KMP算法的作用是在一个已知字符串中查找子串的位置,也叫做串的模式匹配，后文主串和模式串匹配， 子串和模板串匹配。先在开头约定，本文用<code>pat</code>表示模式串，长度为 <code>M</code>，<code>txt</code> 表示文本串，长度为<code>N</code>。KMP 算法是在 <code>txt</code> 中查找子串 <code>pat</code>，如果存在，返回这个子串的起始索引，否则返回 <code>-1</code>。</strong></p>
<p><strong>几个最基本的概念：</strong></p>
<ul>
<li>字符串的前缀：<strong>从主串下标0开始的子串称为主串的前缀</strong></li>
<li>字符串的后缀：<strong>从主串下标大于0的位置到结尾的子串称为主串的后缀</strong></li>
<li>目标串：也就是主串，简单说就是那条比较长的串<code>txt</code></li>
<li>模式串：也就是那条短的，用来匹配的串<code>pat</code></li>
<li>kmp算法的目的：在<span class="math inline">\(O(m+n)\)</span>的时间复杂度的内进行串匹配，也就是在目标串中找到模式串，并返回目标串中模式串的第一个字符下标</li>
</ul>
<span id="more"></span>
<h2 id="暴力做法">暴力做法</h2>
<p>KMP可以解决串的模式匹配，但是一般我们解决这个问题首先想到的是暴力做，什么 也不管，直接两个for循环。暴力匹配也叫<strong>朴素的模式匹配</strong>。</p>
<p>从主串和子串的第一个字符开始，将两字符串的字符一一比对，如果出现某个字符 不匹配，主串指针<code>i</code>回溯到第二个字符，子串指针<code>j</code>回溯到第一个字符再进行一一比对。如果出 现某个字符不匹配，主串回溯到第三个字符，子串回溯到第一个字符再进行一一比对…，一直到子串字符全部匹配成功。这样时间复杂度为<span class="math inline">\(O(N*M)\)</span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">	<span class="type">int</span> cursor=i,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;j&lt;M;++j)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pat[j]!=txt[cursor]) <span class="keyword">break</span>;</span><br><span class="line">		++cursor;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(j==M) <span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="kmp算法">KMP算法</h2>
<p>暴力解发的时间复杂度为<span class="math inline">\(O(N*M)\)</span>，是因为做了许多不必要的位置<code>i</code>的回溯。KMP算法正是对该暴力解的优化。它的改进在于：<strong>每当从某个起始位置开始一趟比较后，在匹配过程中出现失配，不回溯位置<code>i</code>，只回溯<code>j</code>指针</strong></p>
<p>那么问题就是<strong>如果发生失配时，<code>j</code>进行回溯，<code>j</code>应该回溯到什么位置才能保证算法的正确性?</strong></p>
<p>看到上述的解释，有点<strong>动态规划</strong>的味道了，但是在实际的过程中我们是对匹配串<code>pat</code>做相应的预处理来达到这种效果的。如果说，<code>j</code>不是回溯到<code>0</code>，而是回溯到模式串<code>pat</code>中间的某一个位置，<strong>那么怎么知道在应该回溯到<code>pat</code>的哪个位置呢</strong>，我们不先介绍<code>KMP</code>算法的<code>next</code>数组（KMP算法最核心的部分就是<code>next</code>数组了），因为直接介绍代码会很难理解。</p>
<p>首先，得明白构造<code>next</code>数组的<strong>原理</strong>：<strong>其实就是从<code>pat</code>串出发，确定<code>pat</code>中出现的重复公共串，利用先前遍历的结果避免<code>j</code>回溯不必要的位置，</strong>这样就能在回溯中确定位置。换句话说就是利用前后缀的相同字符处理。</p>
<h3 id="next数组的构建">next数组的构建</h3>
<p>next数组的构建是从其<code>pat</code>的前缀和后缀相同串长度确定，换一句话说，<code>next[i]</code>指的是当前<code>pat[0:i]</code>范围内的前缀和后缀相同串的最长值，举个例子由<code>pat=abcabcd</code>:</p>
<ul>
<li>就比如<code>abcabcd</code>,此时<code>next</code>数组的长度是7，<code>next[0]</code>毫无疑问是<code>0</code>，因为它没有后缀</li>
<li>要确定<code>next[2]</code>，可以清楚知道<code>abc</code>的其各前缀和各后缀都没有相同子串，因此<code>next[2]=0</code></li>
<li>要确定<code>next[3]</code>，可以清楚知道<code>abca</code>存在前缀<code>abc</code>和后缀<code>a</code>的相同子串<code>a</code>，因此<code>next[3]=1</code>。这就是<code>next</code>数组的含义</li>
</ul>
<p>上面对每个<code>next[i]</code>数组的处理,要前缀和后缀相同串长度，需要经过多次比较确定，就比如<code>pat=abcabcd</code>,要确定<code>next[3]</code>:</p>
<ul>
<li>①前缀<code>a</code>,后缀<code>bca</code>的相同长度为<code>1</code></li>
<li>②前缀<code>ab</code>,后缀<code>ca</code>的相同长度<code>1</code></li>
<li>③前缀<code>abc</code>，后缀<code>a</code>的相同长度为1`</li>
</ul>
<p>因此<code>next</code>数组的确定，按暴力方法时间复杂度会达到<span class="math inline">\(O(M^2)\)</span>，这以暴力匹配没什么区别，因此必须想办法看是否有<code>O(m)</code>的方法来确定<code>next</code>数组</p>
<h4 id="快速构建next">快速构建next</h4>
<p>假设我们已经求得了<code>next[i-1]</code>的值，并且<code>next[i-1]=now</code>对应的最长前缀和后缀相等长度为<code>now</code>，那么我们再求<code>next[i]</code>的时候也会有两种情况,就比如<code>pat=abcabdddabcabc</code>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pat匹配串</span></span><br><span class="line">      <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span></span><br><span class="line">      a b c a b d d d a b c  a  b  c</span><br><span class="line">next  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>情况1：<code>pat[now]==pat[i]</code>，这种情况直接<code>next[i]=now+1</code></li>
<li>情况2：<code>pat[now]!=pat[i]</code>。
<ul>
<li>这种情况，就比如要确定<code>next[13]</code>，由于<code>next[12]=5</code>,由于<code>pat[5]!=pat[13]</code>，因此不能为情况1，但也不能直接设置为0，需要沿着next回溯分析，这是因为前缀<code>pat[0:now-1]</code>一定有重复。</li>
<li><strong>分析：</strong>当我们跳到<code>now=next[12]=5</code>时候，发现<code>pat[5]!=pat[13]</code>，这就说明<code>pat[now]</code>不符合，但是<code>pat[0:now-1]</code>前可能存在一个符合长度<code>0&lt;k&lt;5</code>的子串，那么我们得沿着next跳到下一个<code>now=next[now-1]</code>,比较<code>pat[now]是否与pat[13]相等</code>，上述步骤循环，直到<code>=(pat[now]==pat[i])时，next[i]=now+1</code>；或者<code>now=0且pat[now]!=pat[i]</code>,则<code>next[i]=0</code>。</li>
<li><strong>示例1</strong>：就比如要确定<code>next[13]</code>，此时<code>now=pat[12]=5</code>，因为<code>pat[13]!=pat[now]</code>，更新<code>now=next[now-1]=2</code>,此时<code>now=2</code>,且<code>pat[13]==pat[now]</code>，所以<code>next[13]=now+1=3</code></li>
<li><strong>示例2</strong>：再比如要确定<code>next[5]</code>，此时<code>now[4]=2</code>,然而<code>pat[5]!=pat[now]</code>，因此更新<code>now=next[now-1]=0</code>,因为<code>now=0且pat[5]!=pat[now]</code>，因此<code>pat[5]=0</code></li>
</ul></li>
</ul>
<p><strong>这样构建<code>next</code>数组的复杂度只有<code>O(M)</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//确定next数组代码</span></span><br><span class="line">	<span class="type">int</span> m=pat.<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">next</span>(m,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,now=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		<span class="keyword">while</span>(now&gt;<span class="number">0</span>&amp;&amp;pat[i]!=pat[now])&#123;</span><br><span class="line">			now=next[now<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pat[i]==pat[now]) ++now;</span><br><span class="line">		next[i]=now;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="kmp算法完整代码">KMP算法完整代码</h3>
<p>有了上述的分析，我们可以较容易的写出KMP的完整代码，<strong>利用next数组进行匹配</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxReapting</span><span class="params">(string txt,string pat)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=txt.<span class="built_in">size</span>(),m=pat.<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">next</span>(m,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,now=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">		<span class="keyword">while</span>(now&gt;<span class="number">0</span>&amp;&amp;pat[i]!=pat[now])&#123;</span><br><span class="line">			now=next[now<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pat[i]==pat[now]) ++now;</span><br><span class="line">		next[i]=now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> startIndex=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j&amp;&amp;txt[i]!=pat[j]) j=next[j<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(txt[i]==pat[j])&#123;</span><br><span class="line">			++j;</span><br><span class="line">			<span class="keyword">if</span>(j==m) <span class="keyword">return</span> i-m+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是<code>for</code>循环，最多循环<code>m</code>次，对于<code>++j</code>这行代码，每次最多加一次，所以在这<code>m</code>次循环中，<code>j</code>最多加上<code>m</code>.下面再看其中的<code>while</code>循环。</p>
<p><code>while</code>循环的功能就是把<code>j</code>往回跳，而由于最后<code>j &gt;= 0</code>所以，<strong>在<code>m</code>次<code>for</code>循环中，<code>j</code>最多回跳了<code>m</code>次，所以总的复杂度最多是<code>O(2m)</code>也就是<code>O(m)</code></strong></p>
<p>从而kmp算法的整体复杂度就是<code>O(n + m)</code></p>
<p>题目：</p>
<ol type="1">
<li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">leetcode 28KMP算法</a></li>
<li><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">leetcode 459重复子字符串</a></li>
<li><a href="https://leetcode.cn/problems/shortest-palindrome/description/">leetcode 214最短回文串</a></li>
</ol>
<p><strong>文章来源：</strong></p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/83334559">KMP算法详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/576363046">算法基础（六）：KMP算法详解（next数组详解</a></p>
<p><a href="https://blog.csdn.net/weixin_45746505/article/details/127676153">KMP算法详解</a></p>
</blockquote>
<p>ps：东哥的KMP算法解析更像有限状态机的解题，容易理解，但总觉得失去了KMP原汁原味的解题思路以及最优的复杂度</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本命令</title>
    <url>/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="shell">1. shell</h4>
<p><code>shell</code>是<code>Linux</code>系统中运行的一种特殊程序。在用户和内核之间之间充当“翻译官”，用户登陆<code>Linux</code>系统时，自动加载一个<code>Shell</code>程序，<code>Bash</code>是<code>Linux</code>系统中默认使用的<code>Shell</code>程序。</p>
<ul>
<li>内核：用于调用计算机硬件资源</li>
<li>shell：将用户指令转换成计算机语言让内核去调用计算机硬件资源 <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell.png" width="500"></li>
</ul>
<span id="more"></span>
<h4 id="bash解析器常用快捷键teminal">2. Bash解析器常用快捷键(Teminal)</h4>
<p><code>bash</code>是一个文件，linux系统中万物皆文件，<code>bash</code>文件位于<code>/bin/bash</code>，<code>bash</code>使用的快捷键：</p>
<ul>
<li><code>Tab</code>键:补齐命令，补齐路径，显示当前目录下的所有目录</li>
<li>使用快捷键<code>Ctrl + L</code> 清除终端上的显示(类似于DOS的cls清屏功能)，也可用<code>clear</code>指令</li>
<li><code>ctlr+c</code>的作用是中断终端的操作。</li>
<li>遍历输入的历史命令：从当前位置向上遍历<code>ctrl + p</code>或<code>↑</code>；从当前位置向下遍历<code>ctrl + n（↓）</code></li>
<li>光标相关操作</li>
<li>光标左移： <code>ctrl + b （←）</code></li>
<li>坐标右移： <code>ctrl + f （→）</code></li>
<li>移动到头部：<code>ctrl + a（Home）</code></li>
<li>移动到尾部：<code>ctlr + e（End）</code></li>
<li>字符删除</li>
<li>删除光标前边的字符：ctrl + h（Backspace）</li>
<li>删除光标后边的字符：ctrl + d</li>
<li>删除光标前所有内容：ctrl + u</li>
<li>删除光标后所有内容：ctrl + k</li>
</ul>
<h4 id="系统目录">3. 系统目录</h4>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux目录结构.png" width="700"></p>
<ul>
<li><code>/</code>：根目录，一般根目录下只存放目录，<strong>在<code>Linux</code>下有且只有一个根目录</strong>。所有的东西都是从这里开始。当你在终端里输入<code>/home</code>，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</li>
<li><code>/bin</code>: <strong>这一目录中存放了供超级用户和一般用户都可以使用的命令，常用的命令<code>ls、tar、mv、cat</code>等</strong></li>
<li><code>/usr/bin</code>: <strong>安装的外部的命令，<code>usr</code>表示的是<code>unix software source</code>，不是user。</strong></li>
<li><code>/boot</code>：放置<code>linux</code>系统启动时用到的一些文件，如<code>Linux</code>的内核文件<code>/boot/vmlinuz</code>，系统引导管理器<code>/boot/grub</code>。</li>
<li><code>/dev</code>：存放<code>linux</code>系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，</li>
<li><code>/etc</code>：<strong>系统配置文件存放的目录，不建议在此目录下存放可执行文件</strong>，重要的配置文件有 <code>/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</code></li>
<li><code>/home</code>：<strong>系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，<code>~edu</code>表示用户<code>edu</code>的家目录。</strong></li>
<li><code>/lib</code>：<strong>内核级别</strong>,系统使用的函数库的目录，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/lib</code>: <strong>系统级别</strong>，目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录</li>
<li><code>/usr/local/lib</code>：<strong>用户级别</strong>，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/include</code>：<strong>C程序语言编译使用的头文件。<code>linux</code>下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数</strong></li>
<li><code>/lost+fount</code>：系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li><code>/mnt、/media</code>:光盘默认挂载点，通常光盘挂载<code>/mnt/cdrom</code>下，也不一定，可以选择任意位置进行挂载。</li>
<li><code>/opt</code>：给主机额外安装软件所摆放的目录。</li>
<li><code>/proc</code>：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 <code>/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*</code> 等。</li>
<li><code>/root</code>：系统管理员root的家目录。</li>
<li><code>/sbin、/usr/sbin、/usr/local/sbin</code>：<strong>放置系统管理员使用的可执行命令</strong>，如<code>fdisk、shutdown、mount</code>等。<strong>与<code>/bin</code>不同的是，这几个目录是给系统管理员root使用的命令，</strong>一般用户只能&quot;查看&quot;而不能设置和使用。</li>
<li><code>/tmp</code>：<strong>一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</strong></li>
<li><code>/srv</code>：服务启动之后需要访问的数据目录，如<code>www</code>服务需要访问的网页数据存放在<code>/srv/www</code>内。</li>
<li><code>/usr</code>：<strong>应用程序存放目录，<code>/usr/bin</code>存放应用程序，<code>/usr/share</code>存放共享数据，<code>/usr/lib</code>存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。<code>/usr/local</code>:存放软件升级包。<code>/usr/share/doc:</code>系统说明文件存放目录。<code>/usr/share/man:</code>程序说明文件存放目录。</strong></li>
<li><code>/var</code>：放置系统执行过程中经常变化的文件，如随时更改的日志文件 <code>/var/log，/var/log/message</code>所有的登录文件存放目录，<code>/var/spool/mail</code>邮件存放的目录，<code>/var/run</code>程序或服务启动后，其PID存放在该目录</li>
</ul>
<h4 id="linux的文件">4. Linux的文件</h4>
<p>在Linux世界里，一切皆文件。在Linux中，文件可分为以下几种：<strong>普通文件（普通文件、可执行文件、压缩文件）、目录文件、设备文件、链接文件和套接字</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linuxFile.png" width="400"></p>
<p><strong>文件符号标识：</strong></p>
<ul>
<li>普通文件:<code>-</code></li>
<li>目录：<code>d</code></li>
<li>字符设备：<code>c</code></li>
<li>管道：<code>p</code></li>
<li>符号链接：<code>l</code></li>
<li>套接字：<code>s</code></li>
<li>符号连结：<code>l</code></li>
<li>一般文件:<code>f</code></li>
</ul>
<h4 id="linux常用命令">5. Linux常用命令</h4>
<p>Linux的命令分为内建命令和外部命令。<code>shell</code>内建命令是指<code>bash</code>工具中集成的命令，一般有一些都会有一个与之同名的系统函数。外部命令是安装外部软件所带的命令。</p>
<h5 id="内建命令和外部命令的区别">5.1 内建命令和外部命令的区别</h5>
<ul>
<li><p><strong>内部命令</strong>：实际上是<code>shell</code>程序的一部分，其中包含的是一些比较简单的<code>linux</code>系统命令，这些命令由<code>shell</code>程序识别并在<code>shell</code>程序内部完成运行，通常在<code>linux</code>系统加载运行<code>shell</code>时就被加载并驻留在系统内存中。内部命令是写在bashy源码里面的，<strong>其执行速度比外部命令快，因为解析内部命令shell不需要创建子进程</strong>。<code>exit，history，cd，echo</code>等就是内建命令 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">help 内建命令</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>外部命令</strong>：<strong>外部命令是<code>linux</code>系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存</strong>。通常外部命令的实体并不包含在<code>shell</code>中，但是其命令执行过程是由<code>shell</code>程序控制的。<code>shell</code>程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。外部命令是在<code>bash</code>之外额外安装的，通常放在<code>/bin，/sbin，/usr/bin，/usr/sbin，/usr/local/sbin</code>等等。可通过<code>echo $PATH</code>命令查看外部命令的存储路径 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是外部命令一个--help选项，不是help指令</span></span><br><span class="line">外部命令 --help</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>type</code>命令可以分辨内部命令与外部命令</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用的三个参数：-t对应-type，-a对应-all，-p对应-path，</span></span><br><span class="line">type [-a | -t | -p] name</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">type [-all | -type | -path] name</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="内建命令使用">5.2 内建命令使用</h5>
<p>所有内建命令如下：加星号的为常用项</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
<th style="text-align: center;">重要程度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>：</code></td>
<td>扩展参数列表，执行重定向操作</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>.</code></td>
<td>读取并执行指定文件中的命令（在当前shell环境中）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>alias</code></td>
<td>为指定命令定义一个别名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>bg</code></td>
<td>将作业以后台模式运行</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>bind</code></td>
<td>将键盘序列绑定到一个<code>readline</code>函数或宏</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>break</code></td>
<td>退出<code>for、while、selec</code>t或<code>until</code>循环</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>builtin</code></td>
<td>执行指定的<code>shell</code>内建命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>caller</code></td>
<td>返回活动子函数调用的上下文</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>cd</code></td>
<td>将当前目录切换为指定目录</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>command</code></td>
<td>执行指定的命令，无需进行通常的shell查找</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>compgen</code></td>
<td>为指定单词生成可能的补全匹配</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>complete</code></td>
<td>显示指定的单词是如何补全的</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>compopt</code></td>
<td>修改指定单词的补全选项</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>continue</code></td>
<td>继续执行<code>for、while、select或until</code>循环的下一次迭代</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>declare</code></td>
<td>声明一个变量或者变量类型</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>dirs</code></td>
<td>显示当前存储目录的列表</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>disown</code></td>
<td>从进程作业表中删除指定的作业</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>echo</code></td>
<td>将指定字符串输出到<code>STDOUT</code></td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>enable</code></td>
<td>启用或禁止指定的内建<code>shell</code>命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>eval</code></td>
<td>将指定的参数拼接成一个命令，然后执行该命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>exec</code></td>
<td>用指定命令替换<code>shell</code>进程</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>exit</code></td>
<td>强制<code>shell</code>以指定的退出状态码退出</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>export</code></td>
<td>设置子<code>shell</code>进程可用的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>fc</code></td>
<td>从历史记录中选择命令列表</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>fg</code></td>
<td>将作业以前台模式运行</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>getopts</code></td>
<td>分析指定的位置参数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>hash</code></td>
<td>查找并记住指定命令的全路径名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>help</code></td>
<td>显示帮助文件</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>history</code></td>
<td>显示命令历史记录</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>jobs</code></td>
<td>列出活动作业</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>kill</code></td>
<td>向指定的进程ID发送一个系统信号</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>let</code></td>
<td>计算一个数学表达式中的每个参数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>local</code></td>
<td>在函数中创建一个作用域受限的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>logout</code></td>
<td>退出登录<code>shell</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>mapfile</code></td>
<td>从<code>STDIN</code>读取数据行，并将其加入索引数组</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>popd</code></td>
<td>从目录栈中删除记录</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>printf</code></td>
<td>使用格式化字符串显示文本</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>pushd</code></td>
<td>向目录栈添加一个目录</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>pwd</code></td>
<td>显示当前工作目录的路径名</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>read</code></td>
<td>从<code>STDIN</code>读取一行数据并将其赋值给一个变量</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>readarray</code></td>
<td>从<code>STDIN</code>读取数据行并将其放入索引数组</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>readonly</code></td>
<td>从<code>STDIN</code>读取一行数据并将其赋值给一个不可修改的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>return</code></td>
<td>强制函数以某个值退出，这个值可以被调用脚本提取</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>set</code></td>
<td>设置并显示环境变量的值和shell属性</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>shift</code></td>
<td>将位置参数依次向下降一个位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>shopt</code></td>
<td>打开/关闭控制<code>shell</code>可选行为的变量值</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>source</code></td>
<td>读取并执行指定文件中的命令（在当前<code>shell</code>环境中）</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>suspend</code></td>
<td>暂停<code>shell</code>的执行，直到收到一个<code>SIGCONT</code>信号</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>test</code></td>
<td>基于指定条件返回退出状态码0或1</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>times</code></td>
<td>显示累计的用户和系统时间</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>trap</code></td>
<td>如果收到了指定的系统信号，执行指定的命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>type</code></td>
<td>显示指定的单词如果作为命令将会如何被解释</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>typeset</code></td>
<td>声明一个变量或变量类型</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>ulimit</code></td>
<td>为系统用户设置指定的资源的上限</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>umask</code></td>
<td>为新建的文件和目录设置默认权限</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>unalias</code></td>
<td>删除指定的别名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>unset</code></td>
<td>删除指定的环境变量或<code>shell</code>属性</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>wait</code></td>
<td>等待指定的进程完成，并返回退出状态码</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h6 id="cd命令">5.2.1 cd命令</h6>
<p><code>cd</code>命令是改变当前工作目录 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd ../	返回上一级目录</span><br><span class="line">cd /  进入根目录</span><br><span class="line">cd ~	进入用户主目录</span><br><span class="line">如：</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ cd ~</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ pwd</span><br><span class="line">/home/trluper</span><br></pre></td></tr></table></figure></p>
<h6 id="dirs命令">5.2.2 dirs命令</h6>
<p><code>dirs</code>命令用于显示<code>Shell</code>目录中的堆栈记录。不加选项时显示当前的Shell命令堆栈中的所有目录，显示时左边为最新加入的目录。</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>删除目录堆栈中的所有记录</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>以完整格式显示堆栈中的目录。显示用户宿主目录时，列出完整路径，而不是“~”</td>
</tr>
<tr class="odd">
<td><code>-n</code></td>
<td>显示右起第n个目录（n从0计数）</td>
</tr>
<tr class="even">
<td><code>+n</code></td>
<td>显示左起第n个目录 （n从0计数）</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td>以每行一个记录的方式列出堆栈中多有记录</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>以每行一个记录的方式列出堆栈中所有记录，并在每行加上序号（从0开始编号）</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ dirs -v</span><br><span class="line"> <span class="number">0</span>  ~/Documents</span><br></pre></td></tr></table></figure>
<h6 id="echo命令">5.2.3 echo命令</h6>
<p><code>echo</code>命令用于将输入的字符串送往标准输出，默认输出的字符间以空白字符隔开，并在最后加上换行号。常与重定向命令<code>&gt;</code>结合使用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">echo [OPTION]... [STRING]...</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>参数选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-n</code></td>
<td>不输出行尾的换行符，不自动换行</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>允许对下面列出的加反斜线转义的字符进行解释</td>
</tr>
<tr class="odd">
<td><code>-E</code></td>
<td>默认选项，禁止对在STRINGs中的那些序列进行解释</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ echo -e <span class="string">&quot;这是echo&quot;</span></span><br><span class="line">这是echo</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ echo -e <span class="string">&quot;这是echo&quot;</span> &gt;test.txt</span><br></pre></td></tr></table></figure>
<h6 id="help命令">5.2.4 help命令</h6>
<p>help命令用于显示<code>shell</code>内部命令的帮助信息。<code>help</code>命令只能显示<code>shell</code>内部的命令帮助信息。而对于外部命令的帮助信息只能使用<code>man</code>或者<code>info</code>或者以外部命令的<code>--help</code>选项查看。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ help cd</span><br><span class="line">cd: cd [-L|[-P [-e]] [-@]] [dir]</span><br><span class="line">    Change the shell working directory.</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<h6 id="history命令">5.2.5 history命令</h6>
<p><code>Bash</code>有完善的历史命令，这对于简化管理操作、排查系统错误都有重要的作用，而且使用简单方便，建议大家多使用历史命令。系统保存的历史命令可以使用<code>history</code>命令查询。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">history [选项] [历史命令保存文件]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>c</code></td>
<td>清空历史命令</td>
</tr>
<tr class="even">
<td><code>w</code></td>
<td>把缓存中的历史命令写入历史命令保存文件中。如果不手工指定历史命令保存文件，则放入默认历史命令保存文件<code>~/.bash_history</code>中</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ history</span><br><span class="line">    <span class="number">1</span>  ping baidu.com</span><br><span class="line">    <span class="number">2</span>  ifconfig</span><br><span class="line">    <span class="number">3</span>  sudo apt install net-tools</span><br><span class="line">    <span class="number">4</span>  ifconfig </span><br><span class="line">    <span class="number">5</span>  ping baidu.com</span><br><span class="line">    <span class="number">6</span>  sudu apt update</span><br><span class="line">    <span class="number">7</span>  sudo apt update</span><br><span class="line">    <span class="number">8</span>  ifconfig</span><br><span class="line">    <span class="number">9</span>  ssh</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h6 id="kill命令">5.2.6 kill命令</h6>
<p><code>kill</code>命令用于删除执行中的程序或工作。<code>kill</code>可将指定的信息送至程序。预设的信息为<code>SIGTERM(15)</code>，可将指定程序终止。若仍无法终止该程序，可使用<code>SIGKILL(9)</code>信息尝试强制删除程序。程序或工作的编号可利用 <code>ps</code>指令或<code>jobs</code>指令查看。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kill [信号] PID</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>信号编号</th>
<th>信号名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><code>EXIT</code></td>
<td>程序退出时收到该信息。</td>
</tr>
<tr class="even">
<td>1</td>
<td><code>HUP</code></td>
<td>挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。</td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>INT</code></td>
<td>表示结束进程，但并不是强制性的，常用的<code>Ctrl+C</code>组合键发出就是一个 <code>kill -2</code> 的信号。</td>
</tr>
<tr class="even">
<td>3</td>
<td><code>QUIT</code></td>
<td>退出。</td>
</tr>
<tr class="odd">
<td>9</td>
<td><code>KILL</code></td>
<td>杀死进程，即强制结束进程。</td>
</tr>
<tr class="even">
<td>11</td>
<td><code>SEGV</code></td>
<td>段错误。</td>
</tr>
<tr class="odd">
<td>15</td>
<td><code>TERM</code></td>
<td>正常结束进程，是<code>kill</code>命令的默认信号。</td>
</tr>
</tbody>
</table>
<h6 id="pwd命令">5.2.7 pwd命令</h6>
<p>命令用于显示工作目录。执行<code>pwd</code>指令可立刻得知您目前所在的工作目录的绝对路径名称。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ pwd</span><br><span class="line">/home/trluper/Documents</span><br></pre></td></tr></table></figure></p>
<h6 id="ulimit命令">5.2.8 ulimit命令</h6>
<p><code>ulimit</code>用来限制每个用户可使用的资源，如CPU、内存、句柄等。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]	设置limit</span><br><span class="line">ulimit [-SHabcdefiklmnpqrstuvxPT]			查询</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>S</code></td>
<td>表示软限制,超出设定的值会告警</td>
</tr>
<tr class="even">
<td><code>H</code></td>
<td>表示硬限制，超出设定的值会报错</td>
</tr>
<tr class="odd">
<td><code>a</code></td>
<td>列出系统所有资源限制的值</td>
</tr>
<tr class="even">
<td><code>d</code></td>
<td>每个进程数据段的最大值</td>
</tr>
<tr class="odd">
<td><code>f</code></td>
<td>当前<code>shell</code>可创建的最大文件容量</td>
</tr>
<tr class="even">
<td><code>l</code></td>
<td>可以锁定的物理内存的最大值</td>
</tr>
<tr class="odd">
<td><code>m</code></td>
<td>可以使用的常驻内存的最大值</td>
</tr>
<tr class="even">
<td><code>n</code></td>
<td>每个进程可以同时打开的最大文件句柄数</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>管道的最大值</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>堆栈的最大值</td>
</tr>
<tr class="odd">
<td><code>t</code></td>
<td>每个进程可以使用CPU的最大时间</td>
</tr>
<tr class="even">
<td><code>u</code></td>
<td>每个用户运行的最大进程并发数</td>
</tr>
<tr class="odd">
<td><code>v</code></td>
<td>当前<code>shell</code>可使用的最大虚拟内存</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -n</span><br><span class="line"><span class="number">1024</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -v</span><br><span class="line">unlimited</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -p</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h6 id="source命令和.命令">5.2.9 source命令和.命令</h6>
<p>.sh后缀的文件为Linux的脚本文件，里面可以写入许多执行命令语句。然后我们可以通过使用<code>source</code>命令或者<code>.</code>在当前shell环境来执行该脚本文件中的所有语句。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">source test.sh</span><br><span class="line">或</span><br><span class="line">. test.sh</span><br></pre></td></tr></table></figure>
<p><strong>来看一下四个执行的区别：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.sh文件：</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;step 1 sleeping&quot;</span></span><br><span class="line">sleep <span class="number">200</span></span><br><span class="line">echo <span class="string">&quot;step 2 sleeping&quot;</span></span><br><span class="line">sleep <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行：</span></span><br><span class="line">./test.sh	<span class="comment">//当前shell下正常执行，这种执行方式需要test.sh的执行权限，开启两个进程一个是test.sh,一个是sleep</span></span><br><span class="line">sh test.sh	<span class="comment">//开启新的shell执行，不用执行权限，有读取权限即可，开两个新进程：一个bash，一个sleep</span></span><br><span class="line">. test.sh	<span class="comment">//当前shell下执行，只需要读取权限即可，开启一个新进程sleep</span></span><br><span class="line">source test.sh	<span class="comment">//同第三个一样</span></span><br></pre></td></tr></table></figure></p>
<h6 id="umask命令">5.3.10 umask命令</h6>
<p><code>umask</code>命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由umask设置的掩码决定。用户每次注册进入系统时，<code>umask</code>命令都被执行， 并自动设置掩码<code>mode</code>来限制新文件的权限。用户可以通过再次执行<code>umask</code>命令来改变默认值，新的权限将会把旧的覆盖掉。<strong>注意umask命令是指定哪些权限将在新文件的默认权限中被删除</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> umask [-p] [-S] [mode]</span><br><span class="line"> -p        以八进制数字表示掩码</span><br><span class="line"> -S        以符号格式表示掩码</span><br><span class="line"></span><br><span class="line">ugo：u表示当前用户权限，g为组用户权限，o为其他用户权限</span><br><span class="line">rwx：r为读权限(<span class="number">4</span>)，w为写权限(<span class="number">2</span>)，x为执行权限(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们通过<code>umask</code>查询其默认的删除权限代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前目录的umask掩码</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ umask</span><br><span class="line"><span class="number">0002</span></span><br></pre></td></tr></table></figure>
<p>因为umask的掩码表示被删除的权限，则目录拥有的权限为<code>777-002=765</code>，则以后建立的目录的权限为<code>u=rwx,g=r-x,o=r-x</code>。如果想要改变默认，则设置<code>umask</code>,那么以后新建的目录或文件会按这个来删除权限</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ umask -p <span class="number">555</span>		<span class="comment">//以后新建的目录和文件删除所有用户的读和执行权限</span></span><br></pre></td></tr></table></figure>
<h5 id="外部命令">5.3 外部命令</h5>
<h6 id="sudo命令">5.3.1 sudo命令</h6>
<p><code>sudo</code>命令以系统管理者的身份执行指令，也就是说，经由<code>sudo</code>所执行的外部指令就好像是<code>root</code>亲自执行。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo --help</span><br><span class="line">sudo - execute a command as another user</span><br></pre></td></tr></table></figure></p>
<p><code>usage: sudo -h | -K | -k | -V</code></p>
<ul>
<li><code>V</code> 显示版本编号</li>
<li><code>h</code> 会显示版本编号及指令的使用方式说明</li>
<li><code>l</code> 显示出自己（执行<code>sudo</code>的使用者）的权限</li>
<li><code>k</code> 将会强迫使用者在下一次执行<code>sudo</code>时问密码（不论有没有超过 N 分钟）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo cd /</span><br><span class="line">sudo: cd: command <span class="keyword">not</span> found</span><br><span class="line"><span class="comment">//注意，shell是一个命令解析器，sudo cd是错误的，因为cd是shell内置的，不是系统里面的，</span></span><br><span class="line"><span class="comment">//要进入root用户，先获取root权限 然后进入/root</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo -sH</span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/home/trluper<span class="meta"># cd /root</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~# </span><br></pre></td></tr></table></figure>
<h6 id="su命令">5.3.2 su命令</h6>
<p><code>su</code>（英文全拼：<code>switch user</code>）命令用于变更为其他使用者的身份，除<code>root</code>外，需要键入该使用者的密码。使用权限：所有使用者。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~<span class="meta"># su trluper	<span class="comment">//切回用户身份</span></span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:/root$ sudo su	<span class="comment">//切回root</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> trluper: </span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~# </span><br></pre></td></tr></table></figure></p>
<h6 id="ls命令">5.3.3 ls命令</h6>
<p>是英文单词<code>list</code>的简写，其功能为列出目录的内容，是用户最常用的命令之一，它类似于<code>DOS</code>下的<code>dir</code>命令。</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-a</code></td>
<td>显示所有文件及目录<code>.</code>开头的隐藏文件也会列出)</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>将文件以相反次序显示(原定依英文字母次序)</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>将文件依建立时间之先后次序列出</td>
</tr>
<tr class="odd">
<td><code>-A</code></td>
<td>同 -a ，但不列出 <code>.</code> (目前目录) 及<code>..</code>(父目录)</td>
</tr>
<tr class="even">
<td><code>-F</code></td>
<td>在列出的文件名称后加一符号；例如可执行档则加 <code>*</code>, 目录则加 <code>/</code></td>
</tr>
<tr class="odd">
<td><code>-R</code></td>
<td>若目录下有文件，则以下之文件亦皆依序列出</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ ls -l</span><br><span class="line">total <span class="number">40</span></span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Desktop</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Documents</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Downloads</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Music</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Pictures</span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">13</span> <span class="number">23</span>:<span class="number">46</span> projects</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Public</span><br><span class="line">drwx------ <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> snap</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Templates</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Videos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="man命令">5.3.4 man命令</h6>
<p>man命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息：<code>man [选项] 命令名</code> linux中各个分页的意义：</p>
<table>
<thead>
<tr class="header">
<th>分页</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>Standard commands</code>（标准命令）</td>
</tr>
<tr class="even">
<td><code>2</code></td>
<td><code>System calls</code>系统调用，如<code>open,write</code></td>
</tr>
<tr class="odd">
<td><code>3</code></td>
<td><code>Library functions</code>库函数，如<code>printf,fopen</code></td>
</tr>
<tr class="even">
<td><code>4</code></td>
<td><code>Special devices</code>（设备文件的说明，/dev下各种设备）</td>
</tr>
<tr class="odd">
<td><code>5</code></td>
<td><code>File formats</code>（文件格式，如passwd）</td>
</tr>
<tr class="even">
<td><code>6</code></td>
<td><code>Games and toys</code>（游戏和娱乐）</td>
</tr>
<tr class="odd">
<td><code>7</code></td>
<td><code>Miscellaneous</code>（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</td>
</tr>
<tr class="even">
<td><code>8</code></td>
<td><code>Administrative Commands</code>（管理员命令，如ifconfig）</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ man <span class="number">3</span> open</span><br><span class="line">NAME</span><br><span class="line">       open, openat — open file</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ...)</span></span>;</span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h6 id="makdir命令">5.3.5 makdir命令</h6>
<p>mkdir（英文全拼：<code>make directory</code>）命令用于创建目录。需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。参数<code>-p</code>可递归创建目录。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ cd ./Documents/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ mkdir -p a/b</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ mkdir mydir&#123;<span class="number">1.</span><span class="number">.3</span>&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a  mydir1  mydir2  mydir3</span><br></pre></td></tr></table></figure></p>
<h6 id="rmdir命令">5.3.6 rmdir命令</h6>
<p>rmdir删除指定的目录，一个目录被删除之前必须是空的，'-p'递归删除目录 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a  mydir1  mydir2  mydir3</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ rmdir -p a/b/c</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ rmdir mydir&#123;<span class="number">1.</span><span class="number">.3</span>&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br></pre></td></tr></table></figure></p>
<h6 id="touch命令">5.3.7 touch命令</h6>
<p><strong><code>touch</code>命令用于修改文件或者目录的时间属性，包括访问时间和修改时间，若文件不存在，系统会建立一个新的文件。</strong>即：</p>
<ul>
<li>1）如果文件不存在, 创建新文件(只能是普通文件，不能是文件夹)</li>
<li>2）如果文件存在, 更新文件时间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ touch test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ ls</span><br><span class="line">test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ touch test&#123;<span class="number">1.</span><span class="number">.3</span>&#125;.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ ls</span><br><span class="line">test  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure>
<h6 id="cp命令">5.3.8 cp命令</h6>
<p><code>cp</code>命令的功能是将给出的文件或目录复制到另一个文件或目录中，即：</p>
<ul>
<li>可以将一个或多个文件复制到另一个文件夹中</li>
<li>可以将目录即目录下的文件和子目录复制到另一个目录</li>
<li>可以将一个文件复制给另一个文件</li>
</ul>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a</code></td>
<td>此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合</td>
</tr>
<tr class="even">
<td><code>d</code></td>
<td>复制时保留链接。这里所说的链接相当于<code>Windows</code>系统中的快捷方式。</td>
</tr>
<tr class="odd">
<td><code>f</code></td>
<td>覆盖已经存在的目标文件而不给出提示</td>
</tr>
<tr class="even">
<td><code>i</code></td>
<td>与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答<code>y</code>时目标文件将被覆盖</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td>
</tr>
<tr class="even">
<td><code>r</code></td>
<td>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</td>
</tr>
<tr class="odd">
<td><code>l</code></td>
<td>不复制文件，只是生成硬链接文件，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>不复制文件，创建文件的软链接，软链接就相当于windows的快捷键（即路径名）</td>
</tr>
<tr class="odd">
<td><code>u</code></td>
<td>当存在相同的文件时，只有源文件比目标文件新时，才会将源文件复制给目标文件</td>
</tr>
</tbody>
</table>
<p><strong>1.复制一个文件到另外一个文件夹</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cp 源文件 目标文件（夹）:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp test1.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">test1.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 复制多个文件到另外一个文件夹</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cp 源文件<span class="number">1</span> 源文件<span class="number">2</span> 目标文件夹 或cp 文件* 目标文件夹</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -u *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 复制目录到另一个目录</strong></p>
<p>只需要记住复制文件夹一定要加<code>-r</code>参数，否则会出现<code>cp: omitting directory</code>错误。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">未加-r出错:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$  cp /home/trluper/Documents/mydir_1 /home/trluper/Documents/mydir_2</span><br><span class="line">cp: -r <span class="keyword">not</span> specified; omitting directory <span class="string">&#x27;/home/trluper/Documents/mydir_1&#x27;</span></span><br><span class="line"></span><br><span class="line">加-r:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -r /home/trluper/Documents/mydir_1 /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">mydir_1  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cd mydir_1/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2/mydir_1$ ls</span><br><span class="line">mysondir  test  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 复制文件到另一个文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">复制内容到文件</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cp test.cpp test2.cp</span><br></pre></td></tr></table></figure>
<p><strong>5. -u的重要性</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test.cpp</span><br><span class="line"></span><br><span class="line">使用-u，没有更新，因为文件没有更新变动：</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -u *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test.cpp</span><br><span class="line"></span><br><span class="line">未使用-u，直接更新:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test.cpp </span><br></pre></td></tr></table></figure>
<h6 id="rm命令">5.3.9 rm命令</h6>
<p>可通过<code>rm</code>删除文件或目录。使用<code>rm</code>命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在<code>rm</code>后使用<code>-i</code>参数以逐个确认要删除的文件。</p>
<h6 id="mv命令">5.3.10 mv命令</h6>
<p>用户可以使用<code>mv</code>命令来<strong>移动文件或目录</strong>，<strong>也可以给文件或目录重命名</strong>。<code>mv</code>与<code>cp</code>时不同的，<code>mv</code>是移动，<code>cp</code>是复制一个。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mv [OPTION]... [-T] SOURCE DEST</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--backup</code></td>
<td>若需覆盖文件，则覆盖前先行备份</td>
</tr>
<tr class="even">
<td><code>-b</code></td>
<td>当文件存在时，覆盖前，为其创建一个备份</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录</td>
</tr>
<tr class="even">
<td><code>-i</code></td>
<td>交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入<code>y</code>，表示将覆盖目标文件</td>
</tr>
<tr class="odd">
<td><code>-S</code></td>
<td>为备份文件指定后缀，而不使用默认的后缀</td>
</tr>
<tr class="even">
<td><code>-u</code></td>
<td>当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ mv ../mydir_1 .</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">mydir_1  test  test.cpp</span><br><span class="line"><span class="comment">//对文件重命名</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ ls</span><br><span class="line">alogrithm.h  sum.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ mv alogrithm.h Alogrithm.h</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ ls</span><br><span class="line">Alogrithm.h  sum.cpp</span><br></pre></td></tr></table></figure>
<h6 id="cat命令">5.3.11 cat命令</h6>
<p>cat：将文件内容一次性输出到终端。缺点是终端显示的内容有限，如果文件太长无法全部显示</p>
<ul>
<li><code>-n</code>:对输出的所有行编号</li>
<li><code>-b</code>:输出内容并且给非空行编号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cat -n test.cpp </span><br><span class="line">     <span class="number">1</span>	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">     <span class="number">2</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">     <span class="number">3</span>	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="number">4</span>	    cout&lt;&lt;<span class="string">&quot;这里是test1.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line">     <span class="number">5</span>	&#125;</span><br></pre></td></tr></table></figure>
<h6 id="less命令">5.3.12 less命令</h6>
<p>less命令将文件内容分页显示到终端，可以自由上下浏览</p>
<h6 id="head命令">5.3.13 head命令</h6>
<p>head命令从文件头部开始查看前n行的内容。如果没有指定行数，默认显示前10行内容。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">head –n [行数] 文件名</span><br><span class="line">head -n <span class="number">30</span> /etc/passwd</span><br></pre></td></tr></table></figure></p>
<h6 id="find命令">5.3.14 find命令</h6>
<p><code>find</code>命令功能非常强大也很复杂，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure> <code>option</code>多达二十多种，这里列举两个：</p>
<ul>
<li>按文件名查询，使用<code>-name</code>,如<code>find . -name &quot;test.cpp&quot;</code></li>
<li>按文件类型查找，使用<code>-type</code>,如<code>find . -type f</code></li>
</ul>
<p>举例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将当前目录及其子目录下所有最近 20 天内更新过的文件列出</span></span><br><span class="line">find . -ctime  <span class="number">20</span></span><br><span class="line"><span class="comment">//查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：</span></span><br><span class="line">find /var/log -type f -mtime +<span class="number">7</span> -ok rm &#123;&#125; \;</span><br><span class="line"><span class="comment">//找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</span></span><br><span class="line">find . -type f -perm <span class="number">644</span> -exec ls -l &#123;&#125; \;</span><br><span class="line"><span class="comment">//查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：</span></span><br><span class="line">find / -type f -size <span class="number">0</span> -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>
<h6 id="grep命令">5.3.15 grep命令</h6>
<p>很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用<code>grep</code>命令。<code>grep</code>命令是一个强大的文本搜索工具，它能使用<strong>正则表达式</strong>搜索文本，并把匹配的行打印出来.<strong>其中<code>pattern</code>为模式，它要么是字符串，要么是正则表达式，总而言之是我们检索的指定信息</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">grep [options] pattern filename</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-i</code></td>
<td>不区分大小写</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>只输出匹配行的计数</td>
</tr>
<tr class="odd">
<td><code>-l</code></td>
<td>查询多文件时只输出包含匹配字符的文件名</td>
</tr>
<tr class="even">
<td><code>-n</code></td>
<td>显示匹配行及行号</td>
</tr>
<tr class="odd">
<td><code>-s</code></td>
<td>不显示不存在或无匹配文本的错误信息</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示不包含匹配文本的所有行，即反向查找</td>
</tr>
<tr class="odd">
<td><code>-o</code></td>
<td>只显示匹配字符串的部分</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>实现多个选项的匹配，逻辑<code>or</code>关系</td>
</tr>
<tr class="odd">
<td><code>-E</code></td>
<td>使用扩展正则表达式，而不是基本正则表达式，在使用<code>-E</code>选项时，相当于使用<code>egrep</code></td>
</tr>
</tbody>
</table>
<p><strong>正则表达式：</strong></p>
<ul>
<li><code>^</code>：此时匹配正则表达以“某字符串”开头的行</li>
<li><code>$</code>：匹配正则表达式的以“某字符串”结尾的行</li>
<li><code>[xyz]</code>：匹配方括号中的任意一个字符</li>
<li><code>[^xyz]</code>：匹配除方括号中字符外的所有字符</li>
<li><code>*</code>：匹配<code>*</code>前面的字符，匹配0个或无数个</li>
<li><code>[ - ]</code>: 范围匹配，如<code>[A-C]</code>，即<code>A、B、C</code>都符合要求</li>
</ul>
<p><strong>1. 查找以指定字字符串开头的行</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in ^[a,q,r,f] hell.txt</span><br><span class="line"><span class="number">2</span>:QQWEWQE</span><br><span class="line"><span class="number">5</span>:FDSST</span><br><span class="line"><span class="number">7</span>:AFASRAY</span><br><span class="line"><span class="number">12</span>:ASDSAEE</span><br><span class="line"><span class="number">13</span>:FAFSDG</span><br><span class="line"><span class="number">17</span>:FBB</span><br><span class="line"><span class="number">24</span>:R</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 查找以指定字结符串尾的行</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in [a,q,r,f]$ hell.txt</span><br><span class="line"><span class="number">1</span>:dasdfDSFSDA</span><br><span class="line"><span class="number">4</span>:KKJHFR</span><br><span class="line"><span class="number">14</span>:DAGSA</span><br><span class="line"><span class="number">24</span>:R</span><br><span class="line"><span class="number">26</span>:CZXCGA</span><br></pre></td></tr></table></figure>
<p><strong>3.在文本中搜素只有一个字符的行，且为字母或数字</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in ^[[:alnum:]]$ hell.txt</span><br><span class="line"><span class="number">20</span>:Z</span><br><span class="line"><span class="number">21</span>:D</span><br><span class="line"><span class="number">22</span>:E</span><br><span class="line"><span class="number">23</span>:W</span><br><span class="line"><span class="number">24</span>:R</span><br><span class="line"><span class="number">25</span>:T</span><br></pre></td></tr></table></figure>
<p><strong>4.匹配<code>*</code>前面的字符，匹配0个或无数个</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in <span class="string">&quot;FDSS&quot;</span>* hell.txt </span><br><span class="line"><span class="number">1</span>:dasdfDSFSDA</span><br><span class="line"><span class="number">5</span>:FDSST</span><br></pre></td></tr></table></figure>
<h6 id="命令">5.3.16 |命令</h6>
<p>管道<code>|</code>一个命令的输出可以通过管道做为另一个命令的输入。即它只能处理经由前面一个指令传出的正确输出信息，对错误信息信息没有直接处理能力。然后，传递给下一个命令，作为标准的输入. 最常用的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ps -ef|gerp <span class="string">&quot;进程名&quot;</span></span><br><span class="line">ps -aux|grep <span class="string">&quot;进程名&quot;</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -ef|grep bash</span><br><span class="line">trluper     <span class="number">2755</span>    <span class="number">2754</span>  <span class="number">0</span> <span class="number">16</span>:<span class="number">03</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span> -bash</span><br><span class="line">trluper     <span class="number">4549</span>    <span class="number">4548</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">29</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> -bash</span><br><span class="line">trluper     <span class="number">4716</span>    <span class="number">4549</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">49</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> bash</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -aux|grep bash</span><br><span class="line">trluper     <span class="number">2755</span>  <span class="number">0.0</span>  <span class="number">0.2</span>  <span class="number">19972</span>  <span class="number">5956</span> pts/<span class="number">1</span>    Ss+  <span class="number">16</span>:<span class="number">03</span>   <span class="number">0</span>:<span class="number">02</span> -bash</span><br><span class="line">trluper     <span class="number">4549</span>  <span class="number">0.0</span>  <span class="number">0.2</span>  <span class="number">19864</span>  <span class="number">5956</span> pts/<span class="number">0</span>    Ss   <span class="number">20</span>:<span class="number">29</span>   <span class="number">0</span>:<span class="number">00</span> -bash</span><br><span class="line">trluper     <span class="number">4718</span>  <span class="number">0.0</span>  <span class="number">0.1</span>  <span class="number">17864</span>  <span class="number">2584</span> pts/<span class="number">0</span>    S+   <span class="number">20</span>:<span class="number">49</span>   <span class="number">0</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> bas</span><br></pre></td></tr></table></figure></p>
<h6 id="ps命令">5.3.17 ps命令</h6>
<p><code>ps</code>（英文全拼：<code>process status</code>）命令用于显示当前进程的状态，类似于<code>windows</code>的任务管理器 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ps [options]</span><br></pre></td></tr></table></figure> <code>ps</code>的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a</code></td>
<td>显示现行终端机下的所有程序，包括其他用户的程序</td>
</tr>
<tr class="even">
<td><code>-a</code></td>
<td>显示所有终端机下执行的程序，除了阶段作业领导者之外</td>
</tr>
<tr class="odd">
<td><code>-A</code></td>
<td>显示所有程序</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>此选项的效果和指定”A”选项相同</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>显示UID,PPIP,C与STIME栏位</td>
</tr>
<tr class="even">
<td><code>-u</code></td>
<td>此选项的效果和指定”-U”选项相同</td>
</tr>
<tr class="odd">
<td><code>u</code></td>
<td>以用户为主的格式来显示程序状况</td>
</tr>
<tr class="even">
<td><code>-U</code></td>
<td>列出属于该用户的程序的状况，也可使用用户名称来指定</td>
</tr>
<tr class="odd">
<td><code>U</code></td>
<td>列出属于该用户的程序的状况</td>
</tr>
<tr class="even">
<td><code>x</code></td>
<td>显示所有程序，不以终端机来区分</td>
</tr>
</tbody>
</table>
<p><strong>1. <code>-aux</code>输出格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           <span class="number">1</span>  <span class="number">0.0</span>  <span class="number">0.4</span> <span class="number">166516</span> <span class="number">11808</span> ?        Ss   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">06</span> /sbin/init <span class="keyword">auto</span> noprom</span><br><span class="line">root           <span class="number">2</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [kthreadd]</span><br><span class="line">root           <span class="number">3</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [rcu_gp]</span><br><span class="line">root           <span class="number">4</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [rcu_par_gp]</span><br><span class="line">root           <span class="number">5</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [netns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>USER</code>: 行程拥有者</li>
<li><code>PID: pid</code></li>
<li><code>%CPU</code>: 占用的 <code>CPU</code> 使用率</li>
<li><code>%MEM</code>: 占用的记忆体使用率</li>
<li><code>VSZ</code>: 占用的虚拟记忆体大小</li>
<li><code>RSS</code>: 占用的记忆体大小</li>
<li><code>TTY</code>: 终端的次要装置号码 (minor device number of tty)</li>
<li><code>STAT:</code> 该行程的状态:</li>
<li><code>D:</code> 无法中断的休眠状态 (通常 IO 的进程)</li>
<li><code>R:</code> 正在执行中</li>
<li><code>S:</code> 睡眠状态，可被唤醒</li>
<li><code>T:</code> 暂停执行</li>
<li><code>Z:</code> 僵尸进程</li>
<li><code>W:</code> 没有足够的记忆体分页可分配</li>
<li><code>s：</code>进程是会话首进程</li>
<li><code>&lt;:</code> 高优先序的行程</li>
<li><code>N:</code> 低优先序的行程</li>
<li><code>X：</code>死掉的进程</li>
<li><code>START:</code> 行程开始时间</li>
<li><code>TIME:</code> 执行的时间</li>
<li><code>COMMAND：</code>所执行的指令</li>
</ul>
<p><strong>2. <code>-ef</code>输出格式</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -ef</span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           <span class="number">1</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">06</span> /sbin/init <span class="keyword">auto</span> noprompt splash</span><br><span class="line">root           <span class="number">2</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [kthreadd]</span><br><span class="line">root           <span class="number">3</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [rcu_gp]</span><br><span class="line">root           <span class="number">4</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [rcu_par_gp]</span><br><span class="line">root           <span class="number">5</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [netns]</span><br></pre></td></tr></table></figure></p>
<h6 id="tar命令">5.3.18 tar命令</h6>
<p><code>tar</code>是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解压以恢复数据。<code>tar</code>这个命令并没有压缩的功能，它只是一个打包的命令，<strong>但是在<code>tar</code>命令中增加一个选项<code>-z</code>可以调用<code>gzip</code>实现了一个压缩的功能，实行一个先打包后压缩的过程</strong>。当然你可以调用其他的压缩命令来压缩。<code>tar</code>要指定扩展名 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只打包</span></span><br><span class="line">tar -cvf test.tar ./</span><br><span class="line"><span class="comment">//压缩当前文件内的所有内容打成和压缩成test.tar.gz包</span></span><br><span class="line">tar -zcvf test.tar.gz ./</span><br><span class="line"><span class="comment">//解压缩和解包</span></span><br><span class="line">tar -zxvf test.tar.gz</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>创建一个新归档</td>
</tr>
<tr class="even">
<td><code>-x</code></td>
<td>从归档中解出文件</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>使用归档文件，一定为最后一个参数</td>
</tr>
<tr class="even">
<td><code>-z</code></td>
<td>通过 gzip 过滤归档</td>
</tr>
<tr class="odd">
<td><code>-t</code></td>
<td>查看内容</td>
</tr>
<tr class="even">
<td><code>-r</code></td>
<td>向压缩归档文件末尾追加文件</td>
</tr>
<tr class="odd">
<td><code>-u</code></td>
<td>更新原压缩包中的文件</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示所有过程</td>
</tr>
</tbody>
</table>
<p><strong>-f 是必须的，切记，这个参数是最后一个参数，后面只能接档案名。</strong></p>
<p><strong><em>linux中的压缩后缀：</em></strong></p>
<ul>
<li><code>*.gz</code>：由<code>gzip</code>压缩，参数为<code>-z</code></li>
<li><code>*.bz2</code>:由<code>bzip2</code>压缩，参数为<code>-j</code></li>
<li><code>*.Z</code>:由<code>compress</code>压缩，参数为<code>-Z</code></li>
<li><code>*.rar:</code>由<code>rar</code>压缩，linux需下载<code>rar</code></li>
<li><code>*.zip</code>：由<code>zip</code>压缩，linux需下载<code>zip</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -zcvf mytar.tar.gz ./</span><br><span class="line">./</span><br><span class="line">./mymdir_2</span><br><span class="line">./mytar.tar.gz</span><br><span class="line">./mydir_2/</span><br><span class="line">./mydir_2/test.cpp</span><br><span class="line">./mydir_2/hell.txt</span><br><span class="line">./mydir_2/mydir_1/</span><br><span class="line">./mydir_2/mydir_1/test.cpp</span><br><span class="line">./mydir_2/mydir_1/test1.cpp</span><br><span class="line">./mydir_2/mydir_1/sondir/</span><br><span class="line">./mydir_2/mydir_1/mysondir/</span><br><span class="line">./mydir_2/mydir_1/test3.cpp</span><br><span class="line">./mydir_2/mydir_1/test</span><br><span class="line">./mydir_2/mydir_1/test2.cpp</span><br><span class="line">./mydir_2/test</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar.tar.gz</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -tvf mytar.tar.gz </span><br><span class="line">drwxr-xr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">31</span> ./</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">12</span> ./mymdir_2</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">31</span> ./mytar.tar.gz</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">39</span> ./mydir_2/</span><br><span class="line">-rw-rw-r-- trluper/trluper  <span class="number">93</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/test.cpp</span><br><span class="line">-rw-rw-r-- trluper/trluper <span class="number">161</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">39</span> ./mydir_2/hell.txt</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">03</span> ./mydir_2/mydir_1/</span><br><span class="line">hrw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/mydir_1/test.cpp link to ./mydir_2/test.cpp</span><br><span class="line">-rw-rw-r-- trluper/trluper  <span class="number">93</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/mydir_1/test1.cpp</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">03</span> ./mydir_2/mydir_1/sondir/</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">49</span> ./mydir_2/mydir_1/mysondir/</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">04</span> ./mydir_2/mydir_1/test3.cpp</span><br><span class="line">-rwxrwxr-x trluper/trluper <span class="number">23528</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">01</span> ./mydir_2/mydir_1/test</span><br><span class="line">-rw-rw-r-- trluper/trluper     <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">04</span> ./mydir_2/mydir_1/test2.cpp</span><br><span class="line">hrwxrwxr-x trluper/trluper     <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">01</span> ./mydir_2/test link to ./mydir_2/mydir_1/test</span><br></pre></td></tr></table></figure>
<h6 id="gzip命令">5.3.19 gzip命令</h6>
<p>其实上面的<code>tar</code>加<code>-z</code>参数就已经完成了<code>gzip</code>命令的工作了。<code>tar</code>与<code>gzip</code>命令结合使用实现文件打包、压缩。<code>gzip</code>要指定扩展名</p>
<ul>
<li><code>-d</code>:解压</li>
<li><code>-r</code>:压缩所有子目录</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -cvf mytar1.tar mydir_2</span><br><span class="line">mydir_2/</span><br><span class="line">mydir_2/test.cpp</span><br><span class="line">mydir_2/hell.txt</span><br><span class="line">mydir_2/mydir_1/</span><br><span class="line">mydir_2/mydir_1/test.cpp</span><br><span class="line">mydir_2/mydir_1/test1.cpp</span><br><span class="line">mydir_2/mydir_1/sondir/</span><br><span class="line">mydir_2/mydir_1/mysondir/</span><br><span class="line">mydir_2/mydir_1/test3.cpp</span><br><span class="line">mydir_2/mydir_1/test</span><br><span class="line">mydir_2/mydir_1/test2.cpp</span><br><span class="line">mydir_2/test</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar  mytar.tar.gz</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ gzip -r mytar1.tar</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar.gz  mytar.tar.gz</span><br></pre></td></tr></table></figure>
<h6 id="zip和unzip命令">5.3.20 zip和unzip命令</h6>
<p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">压缩文件：zip -r 目标文件(没有扩展名) 源文件</span><br><span class="line">解压文件：unzip -d 解压后目录文件 压缩文件</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ zip -r myzip mydir_2</span><br><span class="line">  adding: mydir_2/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/test.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/hell.<span class="built_in">txt</span> (deflated <span class="number">20</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test1.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/sondir/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/mysondir/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test3.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/<span class="built_in">test</span> (deflated <span class="number">79</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test2.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/<span class="built_in">test</span> (deflated <span class="number">79</span>%)</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar.gz  mytar.tar.gz  myzip.zip</span><br></pre></td></tr></table></figure></p>
<h6 id="chmod命令">5.3.21 chmod命令</h6>
<p><code>chmod</code>（英文全拼：change mode）命令是控制用户对文件的权限的命令。Linux/Unix 的文件调用权限分为三级 : 文件所有者<code>Owner</code>、用户组<code>Group</code>、其它用户<code>ther Users</code>。<strong>在内建命令中我们通过设置<code>umask</code>命令来指定新建的文件的权限，但是对于已经存在的文件的权限我们要怎么去修改呢，只能使用<code>chmod</code>命令来修改</strong> <code>chmod</code> 修改文件权限有两种使用格式<strong>字母法与数字法</strong>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字母</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ chmod o+w mydir_2/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxrwx <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ chmod <span class="number">775</span> mydir_2/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="命令-1">5.3.22 &gt;命令</h6>
<p><code>&gt;</code>命令是重定向命令。我们在bash上运行命令，其默认输出为当前的bash终端。当我们想要看查询的东西时（如ls命令），把原来输出到终端的，可以重定向到一个文件。命令后接 <code>&gt;文件名</code>，<code>&gt;</code>会覆盖，<code>&gt;&gt;</code>不覆盖原来内容 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l &gt;text.txt</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  text.txt</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ cat text.txt </span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">17</span> <span class="number">11</span>:<span class="number">04</span> text.txt</span><br></pre></td></tr></table></figure></p>
<h6 id="ln命令">5.3.23 ln命令</h6>
<p><code>ln</code>命令是linux系统中一个非常重要命令，英文全称是“link”，即链接的意思，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 一种是<code>hard link</code>，又称为硬链接；另一种是<code>symbolic link</code>，又称为符号链接。<strong>通俗一点理解，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间。符号链接可以理解为类似windows一样的快捷方式</strong>。 符号链接 ：</p>
<ul>
<li>1.符号链接以路径的形式存在，类似于Windows操作系统中的快捷方式。</li>
<li>2.符号链接可以跨文件系统 ，硬链接不可以。</li>
<li>3.符号链接可以对一个不存在的文件名进行链接，硬链接不可以。</li>
<li>4.符号链接可以对目录进行链接，硬链接不可以。</li>
</ul>
<p><strong>硬链接：</strong></p>
<ul>
<li>1.硬链接以文件副本的形式存在，但不占用实际空间。</li>
<li>2.硬链接不允许给目录创建硬链接。</li>
<li>3.硬链接只有在同一个文件系统中才能创建。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ln [参数] [源文件或目录] [目标文件或目录]</span><br></pre></td></tr></table></figure>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>为每个已存在的目标文件创建备份文件</td>
</tr>
<tr class="even">
<td><code>-d</code></td>
<td>此选项允许“root”用户建立目录的硬链接</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>强制创建链接，即使目标文件已经存在</td>
</tr>
<tr class="even">
<td><code>-n</code></td>
<td>把指向目录的符号链接视为一个普通文件</td>
</tr>
<tr class="odd">
<td><code>-i</code></td>
<td>交互模式，若目标文件已经存在，则提示用户确认进行覆盖</td>
</tr>
<tr class="even">
<td><code>-s</code></td>
<td>对源文件建立符号链接，而非硬链接</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>详细信息模式，输出指令的详细执行过程</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//软连接</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ln -s /home/trluper/Documents/mydir_2 ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls</span><br><span class="line">ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cd ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file/ln_file1$ ls</span><br><span class="line">hell.txt  mydir_1  test  test.cpp</span><br><span class="line"><span class="comment">//软连接就是路径</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> trluper trluper <span class="number">31</span>  <span class="number">7</span>月 <span class="number">17</span> <span class="number">11</span>:<span class="number">15</span> ln_file1 -&gt; /home/trluper/Documents/mydir_2</span><br><span class="line"><span class="comment">//硬链接</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ln /home/trluper/Documents/mydir_2/test.cpp lntest</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls</span><br><span class="line">ln_file1  lntest</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cat lntest </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;这里时test1.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="file命令">5.3.24 file命令</h6>
<p>file命令用于辨识文件类型。通过<code>file</code>指令，我们得以辨识该文件的类型。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>列出辨识结果时，不显示文件名称。</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>详细显示指令执行过程，便于排错或分析程序执行的情形。</td>
</tr>
<tr class="odd">
<td><code>-f&lt;名称文件&gt;</code></td>
<td>指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</td>
</tr>
<tr class="even">
<td><code>-L</code></td>
<td>直接显示符号连接所指向的文件的类别。</td>
</tr>
<tr class="odd">
<td><code>-m&lt;魔法数字文件&gt;</code></td>
<td>　指定魔法数字文件。</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示版本信息。</td>
</tr>
<tr class="odd">
<td><code>-z</code></td>
<td>尝试去解读压缩文件的内容。</td>
</tr>
<tr class="even">
<td><code>[文件或目录...]</code></td>
<td>要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ file lntest1 </span><br><span class="line">lntest1: C++ source, Unicode text, UTF<span class="number">-8</span> text</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ file ln_file1</span><br><span class="line">ln_file1: symbolic link to /home/trluper/Documents/mydir_2</span><br></pre></td></tr></table></figure>
<h6 id="chgrp命令chown命令">5.3.25 chgrp命令/chown命令</h6>
<p><strong><code>chgrp</code>命令用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组</strong>。其中，组名可以是用户组的<code>id</code>，也可以是用户组的组名。文件名可以是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户(root)，则不能改变该文件的组。<strong>同时必须在<code>/etc/group</code>有该组名。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chgrp [选项] 组名 文件...</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>效果类似<code>-v</code>参数，但仅会显示更改的部分</td>
</tr>
<tr class="even">
<td><code>-f</code></td>
<td>不显示错误信息</td>
</tr>
<tr class="odd">
<td><code>-h</code></td>
<td>只对符号连接的文件作修改，而不是该其他任何相关文件</td>
</tr>
<tr class="even">
<td><code>-R</code></td>
<td>递归处理，将指令目录下的所有文件及子目录一并处理</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>显示指令执行过程；</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cat /etc/group</span><br><span class="line">root:x:<span class="number">0</span>:</span><br><span class="line">daemon:x:<span class="number">1</span>:</span><br><span class="line">bin:x:<span class="number">2</span>:</span><br><span class="line">sys:x:<span class="number">3</span>:</span><br><span class="line">adm:x:<span class="number">4</span>:syslog,trluper</span><br><span class="line">tty:x:<span class="number">5</span>:</span><br><span class="line">disk:x:<span class="number">6</span>:</span><br><span class="line">lp:x:<span class="number">7</span>:</span><br><span class="line">mail:x:<span class="number">8</span>:</span><br><span class="line">news:x:<span class="number">9</span>:</span><br><span class="line">uucp:x:<span class="number">10</span>:</span><br><span class="line">man:x:<span class="number">12</span>:</span><br><span class="line">...</span><br><span class="line"><span class="comment">//将rumenz目录由root组改为www群组</span></span><br><span class="line">chgrp -R www rumenz</span><br></pre></td></tr></table></figure>
<h6 id="top命令">5.3.26 top命令</h6>
<p><code>top</code>命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">top [参数]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>批处理</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>显示完整的治命令</td>
</tr>
<tr class="odd">
<td><code>-I</code></td>
<td>忽略失效过程</td>
</tr>
<tr class="even">
<td><code>-s</code></td>
<td>保密模式</td>
</tr>
<tr class="odd">
<td><code>-S</code></td>
<td>累积模式</td>
</tr>
<tr class="even">
<td><code>-i&lt;时间&gt;</code></td>
<td>设置间隔时间</td>
</tr>
<tr class="odd">
<td><code>-u&lt;用户名&gt;</code></td>
<td>指定用户名</td>
</tr>
<tr class="even">
<td><code>-p&lt;进程号&gt;</code></td>
<td>指定进程</td>
</tr>
<tr class="odd">
<td><code>-n&lt;次数&gt;</code></td>
<td>循环显示的次数</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ top -p2567</span><br><span class="line">top - <span class="number">12</span>:<span class="number">55</span>:<span class="number">36</span> up  <span class="number">2</span>:<span class="number">23</span>,  <span class="number">2</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line">Tasks:   <span class="number">0</span> total,   <span class="number">0</span> running,   <span class="number">0</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%<span class="built_in">Cpu</span>(s):  <span class="number">0.0</span> us,  <span class="number">0.0</span> sy,  <span class="number">0.0</span> ni, <span class="number">99.9</span> id,  <span class="number">0.1</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">MiB Mem :   <span class="number">2408.3</span> total,    <span class="number">493.1</span> free,    <span class="number">655.0</span> used,   <span class="number">1260.2</span> buff/cache</span><br><span class="line">MiB Swap:   <span class="number">2048.0</span> total,   <span class="number">2048.0</span> free,      <span class="number">0.0</span> used.   <span class="number">1570.8</span> avail Mem </span><br></pre></td></tr></table></figure>
<h6 id="ar命令">5.3.27 ar命令</h6>
<p><code>ar</code>命令用于<strong>建立或修改备存文件，或是从备存文件中抽取文件。可集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ar [参数]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-d</code></td>
<td>删除备存文件中的成员文件</td>
</tr>
<tr class="even">
<td><code>-m</code></td>
<td>变更成员文件在备存文件中的次序</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td>显示备存文件中的成员文件内容</td>
</tr>
<tr class="even">
<td><code>-q</code></td>
<td>将文件附加在备存文件末端</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>将文件插入备存文件中</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>显示备存文件中所包含的文件</td>
</tr>
<tr class="odd">
<td><code>-x</code></td>
<td>自备存文件中取出成员文件</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>创建</td>
</tr>
<tr class="odd">
<td><code>-s</code></td>
<td>建立索引</td>
</tr>
</tbody>
</table>
<h6 id="nm命令">5.3.28 nm命令</h6>
<p><code>nm</code>是<code>names</code>的缩写，<strong><code>nm</code>命令主要是用来列出某些文件中的符号（说白了就是一些函数和全局变量等）</strong>。 一般来说，搞linux开发的人，才会用到<code>nm</code>命令，非开发的人，应该用不到. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nm [参数]</span><br></pre></td></tr></table></figure></p>
<h6 id="查看端口使用">5.3.29 查看端口使用</h6>
<p>有时候我们需要知道某些应用使用的端口号，避免端口冲突，可使用下述命令 1. <code>netstat</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">netstat -anp</span><br><span class="line">#通过与|和grep结合使用，可以查找任一个应用的端口使用情况</span><br><span class="line">netstat -anp | grep redis</span><br></pre></td></tr></table></figure> 2. <code>lsof</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#这个命令可以列出正在使用指定端口号的进程和它们的详细信息。</span><br><span class="line">lsof -i :<span class="number">6379</span></span><br></pre></td></tr></table></figure></p>
<h4 id="vim编辑器">6. vim编辑器</h4>
<p><code>vi (Visual interface)</code>编辑器是<code>Linux</code>系统中最常用的文本编辑器，<code>vi</code>工作在字符模式下，不需要图形界面，非常适合远程及嵌入式工作，是效率很高的文本编辑器。<code>vim</code>是<code>vi</code>的升级版，它不仅兼容<code>vi</code>的所有指令，而且还有一些新的特性，例如<code>vim</code>可以撤消无限次、支持关键词自动完成、可以用不同的颜色来高亮你的代码。<code>vim</code>普遍被推崇为类<code>vi</code>编辑器中最好的一个。</p>
<h5 id="vim的三种模式">6.1 vim的三种模式</h5>
<p>vi有三种基本工作模式: <strong>命令模式、文本输入模式(编辑模式)、末行模式</strong></p>
<ul>
<li><p><strong>命令模式：</strong> <strong>任何时候,不管用户处于何种模式,只要按一下<code>ESC</code>键,即可使<code>vi</code>进入命令模式</strong>。我们在<code>shell</code>环境(提示符为<code>$</code>)下输入启动<code>vim</code>命令，进入编辑器时，也是处于该模式下。在命令模式下，用户可以输入各种合法的<code>vi</code>命令，用于管理自己的文档。<strong>此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的<code>vi</code>命令，则<code>vi</code>在接受用户命令之后完成相应的动作</strong>。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是<code>vi</code>的合法命令，<code>vi</code>会响铃报警。</p></li>
<li><p>文本输入模式： 在命令模式下输入插入命令<code>i（I）、附加命令a（A） 、打开命令o（O）、替换命s（S）</code>都可以进入文本输入模式，此时vi窗口的最后一行会显示“插入”,可进行文本编辑.</p></li>
<li><p>末行模式： 末行模式下，用户可以对文件进行一些附加处理。尽管命令模式下的命令可以完成很多功能，但要执行一些如字符串查找、替换、显示行号等操作还是必须要进入末行模式的。<strong>在命令模式下，输入冒号<code>:</code>即可进入末行模式。此时vi窗口的状态行会显示出冒号，等待用户输入命令。用户输入完成后，按回车执行，之后<code>vi</code>编辑器又自动返回到命令模式下</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vi-vim.gif"></p></li>
</ul>
<h5 id="命令模式下的命令操作">6.2 命令模式下的命令操作</h5>
<h6 id="切换到编辑模式">6.2.1 切换到编辑模式</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vimbianji.png"></p>
<h6 id="光标移动">6.2.2 光标移动</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mousemove.png"></p>
<h6 id="删除">6.2.3 删除</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/delete.png"> <strong>常用：<code>D</code>、<code>dG</code>、<code>nx</code>(n为数字)、<code>ndd</code></strong></p>
<h6 id="查找">6.2.4 查找</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/find.png"></p>
<h6 id="可视模式">6.2.5 可视模式</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/copydelete.png"></p>
<h6 id="粘贴和复制">6.2.6 粘贴和复制</h6>
<ul>
<li><code>p</code>:粘贴在光标后面</li>
<li><code>P</code>:粘贴在光标前面</li>
<li><code>y</code>:拷贝行</li>
<li><code>Y</code>:拷贝行</li>
</ul>
<h5 id="末行模式下的命令操作">6.3 末行模式下的命令操作</h5>
<h6 id="保存退出">6.3.1 保存退出</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/saveexit.png"></p>
<h6 id="替换">6.3.2 替换</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/tihuan.png"> 可以从上图总结：<code>s(</code>代表本行，<code>g</code>为所有(global)都替换，<code>%</code>指本文件所有行，<code>c</code>每次替换都要求确认</p>
<h6 id="分屏">6.3.3 分屏</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fenping.png"></p>
<h6 id="其他用法扩展">6.3.4 其他用法扩展</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/others.png"></p>
<h5 id="vim的配置文件所在">6.4 vim的配置文件所在</h5>
<p>局部配置文件（推荐）：<code>~/.vimrc</code> 全局配置文件:<code>/etc/vim/vimrc</code></p>
<h4 id="gcc和gcc编译器">7. GCC和gcc++编译器</h4>
<h5 id="gcc和-gcc是两个不同的东西">7.1 gcc和 GCC是两个不同的东西</h5>
<ul>
<li><code>GCC:GNU Compiler Collection</code>(GUN 编译器集合)，它可以编译<code>C、C++、JAV、Fortran、Pascal、Object-C、Ada</code>等语言。</li>
<li>因此<code>gcc</code>是<code>GCC</code>中的<code>GUN C Compiler</code>（C 编译器）；<code>g++</code>是<code>GCC</code>中的<code>GUN C++ Compiler</code>（<code>C++</code>编译器）。二者都可以编译<code>c</code>或<code>cpp</code>文件。只不过用<code>gcc</code>编译<code>c++</code>需要手动添加链接库</li>
<li><strong>在编译阶段，<code>g++</code>会调用<code>gcc</code>，对于<code>c++</code>代码，两者是等价的，但是因为<code>gcc</code>命令不能自动和<code>C++</code>程序使用的库联接，所以通常使用用<code>g++</code>来编译以求自动完成链接。所以对于<code>C</code>语言程序的编译，我们应该使用<code>gcc</code> 指令，而编译<code>C++</code>程序则推荐使用<code>g++</code>指令</strong></li>
</ul>
<h5 id="gccg的四个步骤">7.2 gcc/g++的四个步骤</h5>
<p><code>gcc、g++</code>编译器从拿到一个c源文件到生成一个可执行程序，中间一共经历了<strong>四个步骤：</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/compile.png"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">第一步: 进行预处理</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -E <span class="number">1</span>hello.c -o <span class="number">1</span>hello.i</span><br><span class="line">第二步: 生成汇编文件</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -S <span class="number">1</span>hello.i -o <span class="number">1</span>hello.s</span><br><span class="line">第三步: 生成目标代码</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -c <span class="number">1</span>hello.s -o <span class="number">1</span>hello.o</span><br><span class="line">第四步: 生成可以执行文件</span><br><span class="line"><span class="comment">//这条指令是完成链接这个过程的，它通过链接器ld将运行程序的目标文件和库文件链接在一起，</span></span><br><span class="line"><span class="comment">//生成最后的可执行文件</span></span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc <span class="number">1</span>hello.o -o <span class="number">1</span>hello</span><br><span class="line">第五步: 执行 </span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc​$ ./<span class="number">1</span>hello</span><br><span class="line">hello itcast</span><br><span class="line"></span><br><span class="line">也可直接将源文件生成一个可以执行文件</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc <span class="number">1</span>hello.c -o <span class="number">1</span>hello</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc​$ ./<span class="number">1</span>hello</span><br><span class="line">hello itcast</span><br></pre></td></tr></table></figure></p>
<p><strong>常用选项</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/gcc.png"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello  -I /home/hello/include -L /home/hello/lib -lworld</span><br><span class="line">上面这句表示在编译hello.c时：</span><br><span class="line"></span><br><span class="line">-I /home/hello/include表示将/home/hello/include目录作为第一个寻找头文件的目录，</span><br><span class="line">寻找的顺序是：/home/hello/include--&gt;/usr/include--&gt;/usr/local/include </span><br><span class="line"></span><br><span class="line">-L /home/hello/lib表示将/home/hello/lib目录作为第一个寻找库文件的目录，</span><br><span class="line">寻找的顺序是：/home/hello/lib--&gt;/lib--&gt;/usr/lib--&gt;/usr/local/lib</span><br><span class="line"></span><br><span class="line">-lworld表示在上面的lib的路径中寻找libworld.so动态库文件或libworld.a静态库文件</span><br></pre></td></tr></table></figure></p>
<p><strong><em>附加</em></strong>：</p>
<ul>
<li><p><code>-I</code>针对头文件，未指明路径时，使用<code>#include&lt;&gt;</code>,<code>gcc/g++</code>默认目录<code>/usr/include</code>，如果使用<code>#include&lt;my.h&gt;</code>则找不到<code>my.h</code>文件，因此要通过<code>-I dir</code>参数来指定包含的头文件<code>my.h</code>的位置： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$gcc hell.c -o hell -I /<span class="built_in">root</span>              (假设文件my.h存放在/root下)</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>-L</code>与<code>-I</code> 功能类似，只不过<code>-L</code>时对库文件使用，能够在指定库文件搜索路径。如果一个程序用到了目录<code>/root/lib</code>下的一个动态库<code>libsunq.so</code>，因为<code>-L dir</code>指定的是路径而没有指定文件，则需要用到 <code>-llibname</code>参数，它可以指定<code>gcc</code>去寻找<code>libsunq.so</code>或者<code>libsunq.a</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$gcc hello.c -o hell -L /root/lib -lsunq</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="静态链接和动态链接">7.3 静态链接和动态链接</h5>
<h6 id="静态链接">7.3.1静态链接</h6>
<p><strong>静态链接是指由链接器在链接时将库的内容直接加入到可执行程序中。</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>对运行环境的依赖性较小，具有较好的兼容性</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间</li>
<li>库函数有了更新，必须重新编译应用程序</li>
</ul></li>
</ul>
<h6 id="动态链接">7.3.2 动态链接</h6>
<p><strong>动态链接是指连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>在需要的时候才会调入对应的资源函数</li>
<li>简化程序的升级；有着较小的程序体积</li>
<li>实现进程之间的资源共享（避免重复拷贝）</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>依赖动态库，不能独立运行</li>
<li>动态库依赖版本问题严重</li>
</ul></li>
</ul>
<p>注：前面我们编写的应用程序大量用到了标准库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入<code>-static</code>参数。</p>
<h6 id="静态库的制作">7.3.3 静态库的制作</h6>
<p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。 按照习惯,一般以<code>.a</code>做为文件后缀名。静态库的命名一般分为三个部分：</p>
<ul>
<li>前缀：<code>lib</code></li>
<li>库名称：自己定义即可</li>
<li>后缀：<code>.a</code></li>
</ul>
<p><strong>所以最终的静态库的名字应该为：<code>libxxx.a</code></strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/staticlinked.png" width="600"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">步骤<span class="number">1</span>：将c源文件生成对应的.o文件</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib$ gcc -c add.c -o add.o</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c sub.c -o sub.o </span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c mul.c -o mul.o </span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c div.c -o div.o</span><br><span class="line">步骤<span class="number">2</span>：使用打包工具ar将准备好的.o文件打包为.a文件 libtest.a</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib$ ar -rcs libAlogrithm.a add.o sub.o mul.o div.o</span><br></pre></td></tr></table></figure> <strong>在使用ar工具是时候需要添加参数：<code>-rcs</code></strong></p>
<ul>
<li><code>r</code>更新</li>
<li><code>c</code>创建</li>
<li><code>s</code>建立索引</li>
</ul>
<h6 id="静态库的使用">7.3.4 静态库的使用</h6>
<p>静态库制作完成之后，<strong>需要将<code>.a</code>文件和头文件一起发布给用户</strong>。假设测试文件为<code>main.c</code>，静态库文件为<code>libAlogrithm.a</code>，头文件为<code>Alogrithm.h</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ cat main.cpp </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Alogrithm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>,b=<span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ g++ -<span class="type">static</span> main.cpp -I ../staticLib/ -L ../staticLib/ -lAlogrithm -o test</span><br></pre></td></tr></table></figure></p>
<h6 id="动图库的制作">7.3.5 动图库的制作</h6>
<p>共享库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题和更新问题。 按照习惯,一般以“.so”做为文件后缀名。共享库的命名一般分为三个部分：</p>
<ul>
<li>前缀：<code>lib</code></li>
<li>库名称：自己定义即可</li>
<li>后缀：<code>.so</code></li>
</ul>
<p><strong>所以最终的动态库的名字应该为：<code>libxxx.so</code></strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/dynamiclib.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">步骤一：生成目标文件，此时要加编译选项：-fPIC（fpic）</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -fPIC -c add.c</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ gcc -fPIC -c sub.c </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -fPIC -c mul.c </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ gcc -fPIC -c div.c</span><br><span class="line">参数：-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</span><br><span class="line">步骤二：生成共享库，此时要加链接器选项: -shared（指定生成动态链接库）</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -shared add.o sub.o mul.o div.o -o libtest.so</span><br><span class="line"></span><br><span class="line">步骤三: 通过nm命令查看对应的函数</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ nm libtest.so | grep add </span><br><span class="line"><span class="number">00000000000006b</span>0 T add </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ nm libtest.so | grep sub </span><br><span class="line"><span class="number">00000000000006</span>c4 T sub</span><br></pre></td></tr></table></figure>
<h6 id="使用动态库">7.3.6 使用动态库</h6>
<p>静态库制作完后，需要在测试文件所在的目录创建<code>libxxx.so</code>的链接接，否则就会出现下面这个错误： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libtiger.so: cannot open shared object file: No such file <span class="keyword">or</span> direct</span><br></pre></td></tr></table></figure> 可以通过<code>ldd</code>命令查看哪些动态链接库没有找到： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ ldd test1</span><br><span class="line">	linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007ffc0d5fe000</span>)</span><br><span class="line">	libAlogrithm.so =&gt; <span class="keyword">not</span> found</span><br><span class="line">	libstdc++.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span> (<span class="number">0x00007fbd2317f000</span>)</span><br><span class="line">	libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007fbd22f57000</span>)</span><br><span class="line">	libm.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libm.so<span class="number">.6</span> (<span class="number">0x00007fbd22e70000</span>)</span><br><span class="line">	/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fbd233c1000</span>)</span><br><span class="line">	libgcc_s.so<span class="number">.1</span> =&gt; /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007fbd22e50000</span>)</span><br></pre></td></tr></table></figure> <strong>这是因为程序运行时没有找到动态链接库造成的。程序编译时链接动态库和运行时使用动态链接库的概念是不同的，在运行时，程序链接的动态链接库需要在系统目录下才行</strong>。方法：</p>
<ul>
<li><strong>方法一是可在系统目录创建软链接，链接文件。</strong>这是因为用·<code>-L</code>指定动态库文件路径只能保证编译通过，是否能执行还是得看<code>/lib/</code>或<code>/usr/lib</code>下面有没有该库文件（只要没有删除，永久有效）</li>
<li>方法二当然你要可以修改<code>LD_LIBRARY_PATH</code>指定的动态库搜索路径(当前shell有效)</li>
<li>方法三是配置文件<code>/etc/ld.so.conf</code>中指定的动态库搜索路径(永久有效)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deng@itcast:~/test/<span class="number">6</span>share_test$ sudo ln -s /home/trluper/Documents/staticLib/libtest.so /lib/share_test/libtest.so</span><br></pre></td></tr></table></figure>
<p>然后同静态链接一样，引用动态库去编译：（要保证能找到头文件，因此使用<code>-I</code>) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ -<span class="type">static</span> main.cpp -I ../staticLib/ -lAlogrithm -o test</span><br></pre></td></tr></table></figure></p>
<h5 id="gdb调试">7.4 gdb调试</h5>
<p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具。GDB主要帮忙你完成下面四个方面的功能：</p>
<ul>
<li>启动程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>动态的改变你程序的执行环境。</li>
</ul>
<h6 id="gdb的工作步骤">7.4.1 gdb的工作步骤</h6>
<p><strong>1. 准备工作</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用gcc/g++将其编译为可执行文件，同时使用-g表示该程序可调试：</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ g++ -g main.cpp sum.cpp -o main</span><br></pre></td></tr></table></figure>
<p><strong>2. 启动gdb</strong></p>
<p>输入<code>gdb -q + 可执行文件</code>，启动gdb进行调试。<code>-q</code>参数可以屏蔽一些gdb版本等相关信息，使得页面看起来干净些（我用了）。至此gdb启动完毕： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ gdb -q main</span><br><span class="line">Reading symbols from main...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p><strong>3. 查看代码（可选）</strong></p>
<p>输入<code>list（l）</code>即可查看程序源码 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line"><span class="number">1</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Alogrithm.h&quot;</span></span></span><br><span class="line"><span class="number">2</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">3</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="number">4</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">5	</span>&#123;</span><br><span class="line"><span class="number">6</span>		<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="number">7</span>		cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line"><span class="number">8</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span>	&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 设置参数（可选）</strong></p>
<p><code>set args</code>可指定运行时参数（如：<code>set args 10 20 30 40 50</code>）。<code>show args</code>命令可以查看设置好的运行参数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) set args <span class="number">20</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">(gdb) b <span class="number">2</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b5</span>: file main.cpp, line <span class="number">6.</span></span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/trluper/Documents/staticLib/main <span class="number">20</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;20 30 50&quot;</span>.</span><br></pre></td></tr></table></figure></p>
<p><strong>5.设置断点（可选）</strong></p>
<p>输入<code>break（b）+数字</code> 可以对程序进行断点操作（数字就是设置断点的代码行数） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) b <span class="number">2</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b5</span>: file main.cpp, line <span class="number">6.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>6. 启动程序</strong></p>
<p>输入<code>run（r)</code>开始运行程序，直到遇到“断点”或者“结束” <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/trluper/Documents/staticLib/main </span><br><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">6</span></span><br><span class="line"><span class="number">6</span>		<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>7.单步执行程序（可选）</strong></p>
<ul>
<li><code>next</code>单步执行程序，但是遇到函数时会直接跳过函数，不进入函数</li>
<li><code>step</code>单步执行程序，但遇到函数会进入函数</li>
<li><code>continue</code>继续执行程序，直到遇到断点或结束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;20 30 50&quot;</span>.</span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">7</span>		cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">(gdb) <span class="function">s</span></span><br><span class="line"><span class="function"><span class="title">sum</span> <span class="params">(a=<span class="number">10</span>, b=<span class="number">20</span>)</span> at sum.cpp:<span class="number">4</span></span></span><br><span class="line"><span class="function"><span class="number">4</span>		return a+b;</span></span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">5</span>	&#125;</span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="built_in">main</span> () at main.cpp:<span class="number">8</span></span><br><span class="line"><span class="number">8</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>8. 查看变量值（可选）</strong></p>
<p><code>print + 变量</code>查看变量值；<code>whatis + 变量</code>查看变量数据类型。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) print a</span><br><span class="line">$<span class="number">1</span> = <span class="number">10</span></span><br><span class="line">(gdb) whatis a</span><br><span class="line">type = <span class="type">int</span></span><br></pre></td></tr></table></figure></p>
<p><strong>9. 退出</strong></p>
<p>输入<code>q</code>即可退出gdb <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) q</span><br><span class="line">A debugging session is active.</span><br><span class="line">	Inferior <span class="number">1</span> [process <span class="number">3102</span>] will be killed.</span><br><span class="line">Quit anyway? (y <span class="keyword">or</span> n) y</span><br></pre></td></tr></table></figure></p>
<h6 id="其他命令">7.4.2 其他命令</h6>
<p><strong>1. 断点</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>delete + n</code></td>
<td>删除第<code>n</code>个断点</td>
</tr>
<tr class="even">
<td><code>disable + n</code></td>
<td>暂停第<code>n</code>个断点</td>
</tr>
<tr class="odd">
<td><code>enable + n</code></td>
<td>开启第<code>n</code>个断点</td>
</tr>
<tr class="even">
<td><code>clear + n</code></td>
<td>清除第<code>n</code>行的断点</td>
</tr>
<tr class="odd">
<td><code>info b</code></td>
<td>显示当前程序的断点设置情况</td>
</tr>
<tr class="even">
<td><code>delete breakpoints</code></td>
<td>清除所有断点</td>
</tr>
</tbody>
</table>
<p><strong>2. 运行信息</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>where/bt</code></td>
<td>当前运行的堆栈列表</td>
</tr>
<tr class="even">
<td><code>bt backtrace</code></td>
<td>显示当前调用堆栈</td>
</tr>
<tr class="odd">
<td><code>up/down</code></td>
<td>改变堆栈显示的深度</td>
</tr>
<tr class="even">
<td><code>info program</code></td>
<td>查看程序是否在运行，以及进程号被暂停的原因</td>
</tr>
</tbody>
</table>
<p><strong>3. 运行命令</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>until</code></td>
<td>如果你厌倦了在一个循环内单步跟踪，它可以运行程序直到退出循环体</td>
</tr>
<tr class="even">
<td><code>until + 行号</code></td>
<td>运行至某行</td>
</tr>
<tr class="odd">
<td><code>finish</code></td>
<td>运行程序，直到当前函数返回完成，并且打印函数返回时的堆栈地址和返回值及参数值等信息</td>
</tr>
<tr class="even">
<td><code>call + 行数 + （参数）</code></td>
<td>调用程序中可见的函数，并传递参数</td>
</tr>
</tbody>
</table>
<h4 id="shell脚本">8. shell脚本</h4>
<p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。对于Linux 的 Shell 种类众多，常见的有：</p>
<ul>
<li><code>Bourne Shell（/usr/bin/sh或/bin/sh）</code></li>
<li><code>Bourne Again Shell（/bin/bash）</code></li>
<li><code>C Shell（/usr/bin/csh）</code></li>
<li><code>K Shell（/usr/bin/ksh）</code></li>
<li><code>Shell for Root（/sbin/sh）</code></li>
</ul>
<p>在一般情况下，人们并不区分<code>Bourne Shell</code>和<code>Bourne Again Shell</code>，所以，像<code>#!/bin/sh，</code>它同样也可以改为 <code>#!/bin/bash</code>。<code>#!</code>告诉系统其后路径所指定的程序即是解释此脚本文件的 <code>Shell</code> 程序。</p>
<h5 id="创建一个脚本文件">8.1 创建一个脚本文件</h5>
<p>使用<code>vi/vim</code>命令来创建文件)，新建一个文件<code>test.sh</code>，扩展名为<code>sh</code>（sh代表shell），扩展名并不影响脚本执行，见名知意就好。输入一些代码，第一行一般是这样: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;Hello World !&quot;</span></span><br></pre></td></tr></table></figure> <strong><code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种<code>Shell</code></strong>。echo 命令用于向窗口输出文本。</p>
<h5 id="运行脚本的方法">8.2 运行脚本的方法</h5>
<h6 id="作为可执行程序">8.2.1 作为可执行程序</h6>
<p>将上面的代码保存到<code>test.sh</code>，并<code>cd</code>到相应目录： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ./test.sh  <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">./test.sh  <span class="comment">#执行脚本</span></span><br></pre></td></tr></table></figure> 注意，一定要写成 <code>./test.sh</code>，而不是<code>test.sh</code>，运行其它二进制的程序也一样，直接写<code>test.sh</code>的话，<code>linux</code>系统会去<code>PATH</code>里寻找有没有叫<code>test.sh</code>的，而只有 <code>/bin, /sbin, /usr/bin，/usr/sbin</code>等在<code>PATH</code>里，你的当前目录通常不在<code>PATH</code>里，所以写成<code>test.sh</code>是会找不到命令的，要用 <code>./test.sh</code> 告诉系统说，就在当前目录找。</p>
<h6 id="作为解释器参数">8.2.2 作为解释器参数</h6>
<p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure> 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<h5 id="变量">8.3 变量</h5>
<p>变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： - 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 - 中间不能有空格，可以使用下划线 _。 - 不能使用标点符号。 - 不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<p>定义变量时，变量名不加美元符号<code>$</code>，但PHP语言中变量需要。使用变量名是需要加<code>$</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">&quot;runoob.com&quot;</span></span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br><span class="line">echo <span class="string">&quot;My name is &amp;&#123;your_name&#125;teacher&quot;</span></span><br><span class="line">your_name=<span class="string">&quot;xiaoming&quot;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>变量名外面的<code>&#123;&#125;</code>是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，</li>
<li>一般推荐使用<code>&#123;&#125;</code>,比如上面的第三节，如果不加<code>&#123;&#125;</code>，则会认为your_nameteacher为一个变量名，就出错了。</li>
<li>重新赋值是允许的，仍有不用加<code>$</code>,只有使用的时候加上<code>$</code></li>
</ul>
<h4 id="ssh">9. ssh</h4>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程_基础函数</title>
    <url>/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/</url>
    <content><![CDATA[<h4 id="基本概念">1.基本概念</h4>
<p>这里我们只对一些概念做简单介绍，让第一次接触的读者有一个大概的映像。后续会进行详细的讲述 ##### 1.1 操作系统的核心-内核 操作系统是指完整的软件包，它包括了用来管理和分配计算机资源的核心层软件，以及附带所有标准软件工具，诸如命令行解释器、图形用户界面、文件操作工具和文件编辑器等。其中最为重要的是其核心层软件——内核：</p>
<p><strong>内核</strong>：内核执行的主要任务是<strong>进程调度、内存管理</strong>、提供系统文件、创建和终止进程、对设备的访问、联网、提供系统调用应用编程接口(API)</p>
<ul>
<li><strong>进程调度</strong>：计算机均配备一个或多个CPU以执行程序指令，<strong>Linux与其他系统如Windows一样属于抢占式多任务操作系统</strong>，即多个任务（进程）可同时驻留在CPU中，每个进程都可以获得对CPU的使用权，那么内核就得规定什么时候哪个进程占有CPU进行处理。</li>
<li><strong>内存管理</strong>：linux当中采用了<strong>虚拟内存管理机制</strong>，这种机制有两个优点：<strong>一</strong>是使得进程与进程之间，进程与内核之间彼此隔离，一个进程无法读取或修改内核或其他进程的内存内容；<strong>二</strong>是只需将进程的一部分保存在内存中，降低了每个进程对内存的需求量，使得RAM能够加载更多的进程。</li>
<li><strong>系统调用</strong>：内核提供了系统调用应用编程接口，这样进程可以利用内核入口点（系统调用）请求内核去执行各种任务，如<code>epoll</code></li>
</ul>
<span id="more"></span>
<p><strong><em>注意：</em></strong>必须得理解并行并发，在多核CPU中可以做到并行</p>
<ul>
<li>并行：真正的同一时刻</li>
<li>并发：同一时间周期（我们感觉是同时执行，但是计算机执行周期是毫秒单位级别的，我们感觉不到）</li>
</ul>
<h5 id="内核态和用户态">1.2 内核态和用户态</h5>
<ul>
<li><strong>用户态：</strong>当在用户态运行时，CPU只能访问进程中被标记为用户空间的内存，试图访问内核空间会引发硬件异常。</li>
<li><strong>内核态</strong>：当处于内核态时，CPU既能访问用户内存空间，也能访问内核空间内存。一个用户态要切换到内核态，唯一方法是通过<strong>中断、故障、或者陷入系统调用</strong>这样的异常。处理后返回时，又变为用户模式。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/system.png" width="400"></li>
</ul>
<h5 id="shell">1.3 shell</h5>
<p>shell时一种具有特殊用途的的程序，主要用于读取用户输入的命令，并执行相应的程序以响应命令</p>
<h5 id="用户和组">1.4 用户和组</h5>
<ul>
<li><p><strong>用户</strong>：系统的每一个用户都有唯一的登录名和相应的整型用户UID</p></li>
<li><p><strong>组</strong>：为了管理方便，控制对文件和其它资源的访问，将多个用户分组。每个组都有相应的组ID（GID）。</p></li>
</ul>
<p>每个文件都有与之相应的用户ID和组ID，分别定义文件的属主和属组。系统根据所有权来判定用户对文件的访问权。</p>
<h5 id="单根目录层级目录链接及文件">1.5 单根目录层级、目录、链接及文件</h5>
<p>Linux内核维护着一套<strong>单根目录结构</strong>,以放置系统的所有文件，这与windows形成鲜明对比（windows分硬盘区映射）。Linux的目录层级的根未<code>/</code>，其余的所有目录均为其子孙： <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/root.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/home/trluper<span class="meta"># cd /</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/<span class="meta"># ls</span></span><br><span class="line">bin    dev   lib    libx32      mnt   root  snap      sys  var</span><br><span class="line">boot   etc   lib32  lost+found  opt   run   srv       tmp</span><br><span class="line">cdrom  home  lib64  media       proc  sbin  swapfile  usr</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/</code>：根目录，一般根目录下只存放目录，<strong>在<code>Linux</code>下有且只有一个根目录</strong>。所有的东西都是从这里开始。当你在终端里输入<code>/home</code>，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</li>
<li><code>/bin</code>: <strong>这一目录中存放了供超级用户和一般用户都可以使用的命令，常用的命令<code>ls、tar、mv、cat</code>等</strong></li>
<li><code>/usr/bin</code>: <strong>安装的外部的命令，<code>usr</code>表示的是<code>unix software source</code>，不是user。</strong></li>
<li><code>/boot</code>：放置<code>linux</code>系统启动时用到的一些文件，如<code>Linux</code>的内核文件<code>/boot/vmlinuz</code>，系统引导管理器<code>/boot/grub</code>。</li>
<li><code>/dev</code>：存放<code>linux</code>系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，</li>
<li><code>/etc</code>：<strong>系统配置文件存放的目录，不建议在此目录下存放可执行文件</strong>，重要的配置文件有 <code>/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</code></li>
<li><code>/home</code>：<strong>系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，<code>~edu</code>表示用户<code>edu</code>的家目录。</strong></li>
<li><code>/lib</code>：<strong>内核级别</strong>,系统使用的函数库的目录，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/lib</code>: <strong>系统级别</strong>，目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录</li>
<li><code>/usr/local/lib</code>：<strong>用户级别</strong>，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/include</code>：<strong>C程序语言编译使用的头文件。<code>linux</code>下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数</strong></li>
<li><code>/lost+fount</code>：系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li><code>/mnt、/media</code>:光盘默认挂载点，通常光盘挂载<code>/mnt/cdrom</code>下，也不一定，可以选择任意位置进行挂载。</li>
<li><code>/opt</code>：给主机额外安装软件所摆放的目录。</li>
<li><code>/proc</code>：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 <code>/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*</code> 等。</li>
<li><code>/root</code>：系统管理员root的家目录。</li>
<li><code>/sbin、/usr/sbin、/usr/local/sbin</code>：<strong>放置系统管理员使用的可执行命令</strong>，如<code>fdisk、shutdown、mount</code>等。<strong>与<code>/bin</code>不同的是，这几个目录是给系统管理员root使用的命令，</strong>一般用户只能&quot;查看&quot;而不能设置和使用。</li>
<li><code>/tmp</code>：<strong>一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</strong></li>
<li><code>/srv</code>：服务启动之后需要访问的数据目录，如<code>www</code>服务需要访问的网页数据存放在<code>/srv/www</code>内。</li>
<li><code>/usr</code>：<strong>应用程序存放目录，<code>/usr/bin</code>存放应用程序，<code>/usr/share</code>存放共享数据，<code>/usr/lib</code>存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。<code>/usr/local</code>:存放软件升级包。<code>/usr/share/doc:</code>系统说明文件存放目录。<code>/usr/share/man:</code>程序说明文件存放目录。</strong></li>
<li><code>/var</code>：放置系统执行过程中经常变化的文件，如随时更改的日志文件 <code>/var/log，/var/log/message</code>所有的登录文件存放目录，<code>/var/spool/mail</code>邮件存放的目录，<code>/var/run</code>程序或服务启动后，其PID存放在该目录</li>
</ul>
<p>Linux世界里，一切皆文件。在Linux中，文件可分为以下几种：<strong>普通文件（普通文件、可执行文件、压缩文件）、目录文件、设备文件、链接文件和套接字</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/linuxFile.png" width="400"></p>
<p><strong>文件符号标识：</strong></p>
<ul>
<li>普通文件:<code>-</code></li>
<li>目录：<code>d</code></li>
<li>字符设备：<code>c</code></li>
<li>管道：<code>p</code></li>
<li>符号链接：<code>l</code></li>
<li>套接字：<code>s</code></li>
<li>符号连结：<code>l</code></li>
<li>一般文件:<code>f</code></li>
</ul>
<h5 id="文件io">1.6 文件IO</h5>
<p>unix系统I/0模型具有通用性，即对任何文件采用<code>open()、read()、write()、close()</code>等这些系统调用的程序能够处理任何类型的文件。</p>
<p><strong><em>附</em></strong>：<code>stdio</code>函数库的I<code>fopen()、fclose()、scanf()、print()、fputs()、fgets()</code>等，这些函数位于系统调用<code>open()、read()、write()、close()</code>之上</p>
<h5 id="进程">1.7 进程</h5>
<p>进程是正在执行的程序的实例，当我们运行一个程序时就创建了一个进程。在执行过程中，内核会将程序代码载入虚拟内存，未程序变量分配空间<strong>(Linux中分配4G的虚拟内存映射)</strong>。</p>
<ul>
<li><p>因此在一个系统可同时运行多个进程，而每个进程都好像独占地使用硬件。</p></li>
<li><p>对于单核CPU来说进程是并发运行，则是说一个进程的指令和另一个进程的指令是交错执行（有重叠）的。传统的系统在一个时刻只能执行一个程序，但多核处理器能同时执行多个程序，即并行。</p></li>
<li><p>并发的实现是通过进程间切换来实现的（上下文切换），上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。</p></li>
<li><p>一个进程实际上可以由多个称为线程的执行单元组成。每个线程都运行在进程的上下文中，共享同样的代码、全局数据和堆。但它们有自己的栈，用来装载本地变量和函数调用链接信息。</p></li>
</ul>
<p><strong><em>特殊进程介绍</em></strong>： - <strong>init进程</strong>：init进程是Linux当中所有进程之父，当我们启动Linux系统时，它就已经在运行，后续的所有进程不是有init亲自创建<code>fork()</code>，就是尤其子孙创建的。init进程的<strong>ID号为1</strong>，以超级用户<code>root</code>权限运行，谁都无法杀死init进程，其任务是创建并监控系统运行过程中的一系列进程。</p>
<ul>
<li><strong>守护进程</strong>：守护进程也称为<strong>精灵进程</strong>，守护进程在后台运行，没有控制终端供其读取或写入数据的能力，只有在系统主动关闭是他才会消失，否则一直健在。有着它特殊的作用。</li>
</ul>
<h5 id="静态库和共享库">1.8 静态库和共享库</h5>
<ul>
<li><p><strong>静态链接</strong>：静态库时一种目标库，如果一个程序引用了静态库的函数，那么链接器在解析了引用之后，会从库中抽取所需目标模块，将其复制到最重可执行目标文件中，这就是静态链接。<strong>静态链接需要更多内存和静态库版本依赖严重</strong></p></li>
<li><p><strong>动态链接</strong>：共享库是一目标模块，在运行或加载时，可以加载到任意内存地址，并和一个内存中的程序链接起来，实施<strong>运行时链接。这个过程称为动态链接</strong></p></li>
</ul>
<h5 id="内存映射">1.9 内存映射</h5>
<p>调用系统函数<code>mmap()</code>的进程，会在指定进程的虚拟地址空间中创建一个新的内存映射，映射有两种：</p>
<ul>
<li><p><strong>文件映射：</strong>将文件的<strong>部分区域</strong>映射入调用进程的虚拟内存。映射一旦完成，对文件映射内容的访问则转化为对相应内存区域的字节操作（<strong>即将数据放入内存缓存中，避免磁盘反复I/O影响速率，这样就能加快执行效率</strong>）。注意映射不是一次性映射，而是按需自动从文件加载</p></li>
<li><p><strong>匿名映射</strong>：没有文件与之对应映射时，映射页面的内容会被初始化为0</p></li>
</ul>
<h5 id="进程间的通信和同步">1.10 进程间的通信和同步</h5>
<p>Linux上有许多进程在运行，有些时独立的，但有一些是相互合作的，Linux提供了丰富的进程间通信（IPC)机制：</p>
<ul>
<li>信号（signal),用来表示事件的发生</li>
<li>管道（shell当中的<code>|</code>操作）和FIFO，用于进程间的数据传递。</li>
<li>套接字，提供了一台主机或是联网的不同主机所运行进程之间的数据传递（服务端----客户端）</li>
<li>消息队列，用于进程间交换信息</li>
<li>信号量，用来同步进程动作</li>
<li>共享内存，运行两个及以上的进程共享一块内存，当某一进程改变了共享内存的内容，其他进程会知道。</li>
</ul>
<h5 id="信号">1.11 信号</h5>
<p>尽管信号被认为是IPC的一种，但是它运用于其他更为广泛，往往会将信号作为<strong>‘软件中断’</strong>，进程收到信号，就意味着某一事件或异常发生（如定时任务，<code>ctrl+c</code>中断）</p>
<p>信号的类型有很多，以<code>SIGXXX</code>标识，</p>
<p><strong><em>接下来就正式进入Linux系统编程的学习</em></strong></p>
<h4 id="系统调用">2. 系统调用</h4>
<p><strong>系统调用</strong>是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务</p>
<p>相应的操作系统也有不同的运行级别，<strong>用户态和内核态</strong>。</p>
<ul>
<li><strong>运行在内核态的进程可以毫无限制的访问各种资源，</strong></li>
<li>** 而在用户态下的用户进程的各种操作都有着限制，比如不能随意的访问内存、不能开闭中断以及切换运行的特权级别。**</li>
</ul>
<p>操作系统一般是通过软件中断从用户态切换到内核态。</p>
<h5 id="库函数和系统调用区别">2.1 库函数和系统调用区别</h5>
<p>Linux 下对文件操作有两种方式：<strong>系统调用（<code>system call</code>）和库函数调用（<code>Library functions</code>）。</strong></p>
<ul>
<li><strong>系统调用</strong>：系统调用是需要时间的，程序中频繁的使用系统调用会降低程序的运行效率。当运行内核代码时，CPU工作在内核态，在系统调用发生前需要保存用户态的栈和内存环境，然后转入内核态工作。系统调用结束后，又要切换回用户态。这种环境的切换会消耗掉许多时间 。</li>
</ul>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/libraryfunctions.png" width="100"></p>
<h5 id="文件描述符">2.2 文件描述符</h5>
<p>对文件进行相应的操作<code>open()、close()、write() 、read()</code>等）。打开现存文件或新建文件时，<strong>系统（内核）会返回一个文件描述符，文件描述符用来指定已打开的文件</strong></p>
<p>程序运行起来后（每个进程）都有一张文件描述符的表，标准输入、标准输出、标准错误输出设备文件被打开，对应的文件描述符 <code>0、1、2</code>记录在表中。程序运行起来后这三个文件描述符是默认打开的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN_FILENO 0  <span class="comment">//标准输入的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT_FILENO 1 <span class="comment">//标准输出的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR_FILENO 2 <span class="comment">//标准错误的文件描述符</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Linux 中一个进程默认最多只能打开的文件是1024个。</strong></p>
<h5 id="相关文件函数系统调用版">2.3 相关文件函数（系统调用版）</h5>
<h6 id="open函数">2.3.1 open函数</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">int</span> flags,<span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">	打开文件，如果文件不存在则可以选择创建，并返回一个文件描述符</span><br><span class="line">参数：</span><br><span class="line">	pathname:文件路径及文件名</span><br><span class="line">	flags:打开文件的行为标志，必选项有O_RDONLY,O_WRONLY,O_RDWR</span><br><span class="line">	mode:该参数只在文件不存时创建文件时有效，指新建文件时指定的文件权限</span><br></pre></td></tr></table></figure>
<p><strong>flages详细说明：</strong></p>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/statopen.png" width="500"></p>
<p><strong>mode说明：</strong>： <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/mode.png" width="500"></p>
<h6 id="close函数">2.3.2 close函数</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">	关闭已打开的文件</span><br><span class="line">参数：</span><br><span class="line">	fd:文件描述符，<span class="built_in">open</span>()返回值</span><br><span class="line">返回值：</span><br><span class="line">	成功：<span class="number">0</span></span><br><span class="line">	失败：<span class="number">-1</span>，并设置errno</span><br></pre></td></tr></table></figure>
<p>需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用<code>close</code>关闭，所以即使用户程序不调用<code>close</code>，在终止时内核也会自动关闭它打开的所有文件。</p>
<h6 id="write函数">2.3.3 write函数</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">sszie_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">void</span>* buf,<span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">	把指定数目的数据写到文件fd</span><br><span class="line">参数：</span><br><span class="line">	fd：文件描述符</span><br><span class="line">	buf：数据首地址</span><br><span class="line">	count：写入数据长度</span><br><span class="line">返回值：</span><br><span class="line">	成功：实写入数据的字节数</span><br><span class="line">	失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h6 id="read函数">2.3.4 read函数</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span>* buf,<span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">	把指定数目的数据读到内存（缓冲区）</span><br><span class="line">参数：</span><br><span class="line">	fd：文件描述符</span><br><span class="line">	buf：内存首地址</span><br><span class="line">	count：读取的字节数</span><br><span class="line">返回值：</span><br><span class="line">	成功：实际读取到的字节数</span><br><span class="line">	失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h6 id="lseek函数文件偏移量">2.3.5 lseek()函数:文件偏移量</h6>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/lseek.png" width="600"></p>
<p>所有打开的文件都有一个当前文件偏移量(current file offset)，以下简称为<code>cfo</code>。<code>cfo</code> 通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。</p>
<p><strong><em>示例：</em></strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd =<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> ret =<span class="number">-1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *str=<span class="string">&quot;trluper&quot;</span></span><br><span class="line">	<span class="type">char</span> buf[SIZE];</span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">&quot;txt&quot;</span>,O_WRONLY|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">	<span class="comment">//写入</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span>==fd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fd=%d\n&quot;</span>,fd);</span><br><span class="line">	ret= <span class="built_in">write</span>(fd,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span> == ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;write len:%d\n&quot;</span>,ret);</span><br><span class="line">	<span class="comment">//设置偏移量</span></span><br><span class="line">	ret=<span class="built_in">lseek</span>(fd,<span class="number">7</span>,SEEK_SET);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span> == ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">write</span>(fd,<span class="string">&quot; github&quot;</span>,<span class="number">6</span>);</span><br><span class="line">	<span class="comment">//将文件位置指针指向文件开头，读取</span></span><br><span class="line">	<span class="built_in">lseek</span>(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">	ret= <span class="built_in">read</span>(fd,buf,SIZE)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read ret:%d buf:%s\n&quot;</span>,ret,buf);</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="perror">2.3.6 perror</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="comment">//输出函数调用失败的错误消息 会在你输入的字符串后面拼接错误信息 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> sys_errlist[];</span><br><span class="line"><span class="type">int</span> sys_nerr;</span><br><span class="line"><span class="comment">//error是一个全局变量 通过他获得错误码</span></span><br><span class="line"><span class="type">int</span> errno;</span><br></pre></td></tr></table></figure>
<p><strong>错误码</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	EPERM		 1	<span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOENT		 2	<span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESRCH		 3	<span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINTR		 4	<span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EIO		 5	<span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENXIO		 6	<span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	E2BIG		 7	<span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOEXEC		 8	<span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBADF		 9	<span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ECHILD		10	<span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EAGAIN		11	<span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOMEM		12	<span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EACCES		13	<span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFAULT		14	<span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTBLK		15	<span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EBUSY		16	<span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EEXIST		17	<span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXDEV		18	<span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENODEV		19	<span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTDIR		20	<span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EISDIR		21	<span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EINVAL		22	<span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENFILE		23	<span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMFILE		24	<span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOTTY		25	<span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ETXTBSY		26	<span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EFBIG		27	<span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ENOSPC		28	<span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ESPIPE		29	<span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EROFS		30	<span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EMLINK		31	<span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EPIPE		32	<span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EDOM		33	<span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ERANGE		34	<span class="comment">/* Math result not representable */</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="阻塞和非阻塞">2.4 阻塞和非阻塞</h5>
<ul>
<li><p><strong>读常规文件是不会阻塞的，不管读多少字节，<code>read</code>一定会在有限的时间内返回。</strong></p></li>
<li><p><strong>从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用<code>read</code>读终端设备就会阻塞</strong>，如果网络上没有接收到数据包，调用<code>read</code>从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。</p></li>
<li><p><strong>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定</strong></p></li>
</ul>
<h5 id="stat函数">2.5 stat()函数</h5>
<p>stat函数在之后的编程中会经常用到，可以了解一下 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/stat.png" width="600"> <code>struct stat</code>结构体说明：buf传出，获取指定文件信息 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/statbuf.png" width="600"> 使用实例1：判断文件类型（先明白如何判断，用man 2 stat查看st_mode的使用）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(s-&gt;st_mode&amp;S_IFMT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> S_IFREG:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是普通文件\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFDIR:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是目录\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFCHR:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是字符设备\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFBLK:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是块设备\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是套接字\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFFIFO:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;该文件是管道\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>文件类型和权限解释：</strong></p>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/filetype.png" width="600"></p>
<h5 id="文件描述符的复制">2.6 文件描述符的复制</h5>
<p>dup() 和 dup2() 是两个非常有用的系统调用，都是用来复制一个文件的描述符，使新的文件描述符也标识旧的文件描述符所标识的文件。</p>
<h6 id="dup函数">2.6.1 dup()函数</h6>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/dup.png" width="600"></p>
<h6 id="dup2函数">2.6.2 dup2()函数</h6>
<p>dup2函数：应用于重定向 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/dup2.png" width="600"></p>
<h5 id="fcnlt函数改变打开文件的性质">2.7 fcnlt函数：改变打开文件的性质</h5>
<p><strong><code>fcntl</code>函数有5种功能：</strong></p>
<ul>
<li><ol type="1">
<li>复制一个现有的描述符（cmd=F_DUPFD）</li>
</ol></li>
<li><ol start="2" type="1">
<li>获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD)</li>
</ol></li>
<li><ol start="3" type="1">
<li>获得／设置文件状态标记(cmd=F_GETFL或F_SETFL)</li>
</ol></li>
<li><ol start="4" type="1">
<li>获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN)</li>
</ol></li>
<li><ol start="5" type="1">
<li>获得／设置记录锁(cmd=F_GETLK, F_SETLK或F_SETLKW) <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/fcntl.png" width="600"></li>
</ol></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcnlt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//等价于dup()</span></span><br><span class="line">	<span class="type">int</span> new_fd=<span class="built_in">fcnlt</span>(fd,F_DUPFD,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//获取文件状态标记</span></span><br><span class="line">	<span class="type">int</span> flag=<span class="built_in">fcnlt</span>(fd,F_GETFD,<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">switch</span>(flag&amp;O_ACCMODE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> O_RDONLY:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;read only\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag&amp;O_APPEND)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;append\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flag|=O_APPEND;	<span class="comment">//追加flag</span></span><br><span class="line">	<span class="built_in">fcnlt</span>(new_fd,F_SETFT,flag);	<span class="comment">//设置状态标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="目录的相关函数">2.8 目录的相关函数</h5>
<h6 id="getcwd函数">2.8.1 getcwd函数</h6>
<p>getcwd函数：获取当前进程的工作目录 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/getcwd.png" width="600"></p>
<h6 id="chdir函数">2.8.2 chdir函数</h6>
<p><code>chdir</code>函数：修改当前进程的路径 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/chdir.png" width="500"></p>
<h6 id="opendir函数">2.8.3 opendir函数</h6>
<p><code>opendir</code>函数：打开一个目录，相当于cd命令 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/opendir.png" width="500"></p>
<h6 id="closedir函数">2.8.4 closedir函数</h6>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/closedir.png" width="500"></p>
<h6 id="readdir函数">2.8.5 readdir函数</h6>
<p><code>readdir</code>函数:读取目录 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/readdir.png" width="500"></p>
<p><strong>相关结构体说明：</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/dirent.png" width="500"></p>
<p>d_type文件类型说明： <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/d_type.png" width="500"></p>
]]></content>
      <categories>
        <category>Linux coding</category>
      </categories>
      <tags>
        <tag>Linux coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程_线程</title>
    <url>/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="线程熟悉">1 线程（熟悉）</h4>
<ul>
<li><p><strong>进程：</strong>程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。因此程序是静态的，进程是动态的。是CPU分配资源的最小单位</p></li>
<li><p><strong>线程：</strong>线程（thread）是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。线程是CPU调度的最小单位</p></li>
</ul>
<h5 id="进程和线程的区别">1.1 进程和线程的区别</h5>
<ul>
<li><strong>进程</strong>，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源，所以我们也说，进程是CPU分配资源的最小单位。</li>
</ul>
<span id="more"></span>
<ul>
<li><p><strong>线程：</strong>线程存在与进程当中(进程可以认为是线程的容器)，<strong>线程是操作系统调度执行的最小单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源，共享全局内存区域，包括初始话数据段data、未初始化数据段bss和堆内存段。（是为避免进程fork()产生写时拷贝的不必要时间和内存支出）</strong> <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread.png" width="400"></p></li>
<li><strong>关系：</strong>
<ul>
<li>一个进程可有多个线程</li>
<li>进程间的共享数据要依靠进程间通信工具，而线程在共享的全局内存区域很容易实现数据共享</li>
<li>进程比线程消耗更多的计算机资源</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>进程间不会相互影响，而一个线程挂掉将导致整个进程挂掉</li>
</ul></li>
</ul>
<h5 id="线程概览">1.2 线程概览</h5>
<p>POSIX C的线程库<code>pthread</code>API定义了一干数据类型，下面列出了其中的一部分： <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/typeofpthread.png" width="500"> 进程可蜕变为线程。实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数<code>clone</code>。</p>
<ul>
<li>** Ø 如果复制对方的地址空间，那么就产出一个“进程”；---&gt;深拷贝**</li>
<li>** Ø 如果共享对方的地址空间，就产生一个“线程”。---&gt;浅拷贝**</li>
</ul>
<p>Linux内核是不区分进程和线程的, 只在用户层面上进行区分。所以，线程所有操作函数<code>pthread_*</code>是库函数，而非系统调用。</p>
<ul>
<li><strong>线程共享资源包括有：</strong>
<ul>
<li><ol type="1">
<li>文件描述符表</li>
</ol></li>
<li><ol start="2" type="1">
<li>每种信号的处理方式</li>
</ol></li>
<li><ol start="3" type="1">
<li>当前工作目录</li>
</ol></li>
<li><ol start="4" type="1">
<li>用户ID和组ID</li>
</ol></li>
<li>5）内存地址空间<code>(.text/.data/.bss/heap/共享库)</code></li>
</ul></li>
<li><strong>线程非共享资源:</strong>
<ul>
<li><ol type="1">
<li>线程id</li>
</ol></li>
<li><ol start="2" type="1">
<li>处理器现场和栈指针(内核栈)</li>
</ol></li>
<li><ol start="3" type="1">
<li>独立的线程栈空间(用户空间栈)</li>
</ol></li>
<li><ol start="4" type="1">
<li>errno变量</li>
</ol></li>
<li><ol start="5" type="1">
<li>信号屏蔽字</li>
</ol></li>
<li><ol start="6" type="1">
<li>调度优先级</li>
</ol></li>
</ul></li>
</ul>
<p><strong><em>注：</em></strong>Linux中系统调用的错误都存储于<code>errno</code>中，<code>errno</code>由操作系统维护是一个全局整型变量，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。<strong><code>errno</code>是一个包含在<code>&lt;errno.h&gt;</code>中的预定义的外部int变量，用于表示最近一个函数调用是否产生了错误</strong>。但是显然，<code>errno</code>在多线程上会发生竞争，因此为适应多线程，各个线程独立拥有<code>errno</code>。简言概之，就是errno机制在保留Linux的报错方式同时，也是适应了多线程环境。</p>
<h5 id="线程优缺点">1.3 线程优缺点</h5>
<ul>
<li><strong>优点：</strong>
<ul>
<li>Ø 提高程序并发性。</li>
<li>Ø 开销小，共享全局内存区域</li>
<li>Ø 数据通信、共享数据方便</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>Ø 库函数，不稳定</li>
<li>Ø 调试、编写困难、gdb不支持</li>
<li>Ø 对信号支持不好</li>
</ul></li>
</ul>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。 <strong><em>注意：gcc编译时要链接 -pthread</em></strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc <span class="number">5</span>pthread_self.c -pthread</span><br></pre></td></tr></table></figure></p>
<h5 id="线程常用api">1.4 线程常用API</h5>
<h6 id="pthread_self获取线程号">1.4.1 pthread_self：获取线程号</h6>
<p>线程号只在它所属的进程环境中有效。一般来说应把<code>pthread_t</code>当作一结构体，而不是整型 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/*功能：</span></span><br><span class="line"><span class="comment">	获取线程号</span></span><br><span class="line"><span class="comment">	返回值：调用线程的线程ID</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h6 id="pthread_equal线程号比较">1.4.2 pthread_equal：线程号比较</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1,<span class="type">pthread_t</span> t2)</span></span>;</span><br><span class="line"><span class="comment">/*功能：</span></span><br><span class="line"><span class="comment">	判断线程号t1、t2是否相等，</span></span><br><span class="line"><span class="comment">	返回值：相等为非0，不等为0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h6 id="pthread_create线程创建">1.4.3 pthread_create:线程创建</h6>
<p>在一个线程中调用<code>pthread_create()</code>创建新的线程后，当前线程从<code>pthread_create()</code>返回继续往下执行，而新的线程所执行的代码由我们传给<code>pthread_create</code>的函数指针<code>start_routine</code>决定。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_create.png" width="600"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_fun</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> num=*((<span class="type">int</span> *)arg);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;int the new thread:num=%d\n&quot;</span>,num);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="type">int</span> test =<span class="number">100</span>;</span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid,<span class="literal">NULL</span>,thread_fun,(<span class="type">void</span>*)&amp;test);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error number:%d\n&quot;</span>,ret);</span><br><span class="line">		<span class="comment">//根据错误信号打印错误信息</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error information:%s\n&quot;</span>,<span class="built_in">strerror</span>(ret));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong><em>注：注：由于<code>pthread_create</code>的错误码不保存在<code>errno</code>中，因此不能直接用<code>perror()</code>打印错误信息，可以先用<code>strerror()</code>把错误码转换成错误信息再打印。</em></strong></p>
<h6 id="pthread_join线程资源回收">1.4.4 pthread_join线程资源回收</h6>
<p><strong>调用该函数的线程将挂起等待，直到id为tid的线程终止</strong>。tid线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</p>
<ul>
<li><ol type="1">
<li>如果<code>tid</code>线程通过return返回，<code>retval</code>所指向的单元里存放的是<code>tid</code>线程函数的返回值。</li>
</ol></li>
<li><ol start="2" type="1">
<li>如果<code>thread</code>线程被别的线程调用<code>pthread_cancel</code>异常终止掉，<code>retval</code>所指向的单元里存放的是常数PTHREAD_CANCELED。</li>
</ol></li>
<li><ol start="3" type="1">
<li>如果<code>thread</code>线程是自己调用<code>pthread_exit</code>终止的，<code>retval</code>所指向的单元存放的是传给<code>pthread_exit</code>的参数。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_join.png" width="600"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">thead</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num =<span class="number">123</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;after 2 seconds, thread will return\n&quot;</span>);</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> &amp;num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="type">void</span> * value=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;tid,<span class="literal">NULL</span>,thread_fun,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//等待线程号为tid的线程，如果此线程结束就回收其资源</span></span><br><span class="line">	<span class="comment">//&amp;value保存线程退出的返回值</span></span><br><span class="line">	<span class="built_in">pthread_join</span>(tid,&amp;value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value=%d\n&quot;</span>,*(<span class="type">int</span>*)value);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
<h6 id="pthread_detach线程分离">1.4.5 pthread_detach:线程分离</h6>
<p><strong>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态</strong></p>
<p>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_detach.png" width="600"></p>
<h6 id="pthread_exit线程退出">1.4.6 pthread_exit线程退出</h6>
<p>在进程中我们可以调用exit函数或_exit函数来结束进程，在一个线程中我们可以通过以下三种在不终止整个进程的情况下停止它的控制流。</p>
<ul>
<li>线程从执行函数中返回。</li>
<li>线程调用<code>pthread_exit</code>退出线程。</li>
<li>线程可以被同一进程中的其它线程取消。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_exit.png" width="600"></li>
</ul>
<h6 id="pthread_cancle">1.4.7 pthread_cancle</h6>
<p>线程的取消并不是实时的，而又一定的延时。需要等待线程到达某个取消点(检查点)。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：杀死线程</span></span><br><span class="line"><span class="comment">参数：thread:目标线程ID</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功：0</span></span><br><span class="line"><span class="comment">	失败：错误编号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure> <strong>取消点：</strong>是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write..... 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。可粗略认为一个系统调用(进入内核)即为一个取消点。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/quxiao.png" width="600"></p>
<h5 id="线程属性">1.5 线程属性</h5>
<p>Linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。</p>
<p>如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/shuxing.png" width="600"> <strong>主要结构体成员：</strong></p>
<ul>
<li><ol type="1">
<li>线程分离状态</li>
</ol></li>
<li><ol start="2" type="1">
<li>线程栈大小（默认平均分配）</li>
</ol></li>
<li><ol start="3" type="1">
<li>线程栈警戒缓冲区大小（位于栈末尾）</li>
</ol></li>
<li><ol start="4" type="1">
<li>线程栈最低地址</li>
</ol></li>
</ul>
<p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为<code>pthread_attr_init</code>，这个函数必须在<code>pthread_create</code>函数之前调用。之后须用<code>pthread_attr_destroy</code>函数来释放资源。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_attr.png" width="600"></p>
<h6 id="线程分离状态">1.5.1 线程分离状态</h6>
<p><strong>线程的分离状态决定一个线程以什么样的方式来终止自己。</strong></p>
<ul>
<li><p><strong>非分离状态</strong>：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</p></li>
<li><p><strong>分离状态</strong>：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/fengli.png" width="600"></p></li>
</ul>
<h4 id="线程同步之互斥锁">2. 线程同步之互斥锁</h4>
<p>在多核CPU中，同时运行的多个任务可能：</p>
<ul>
<li>都需要访问/使用同一种资源，但对该资源操作不是原子操作，可能出现不可预知的错误</li>
<li>多个任务之间有依赖关系，某个任务的运行依赖于另一个任务</li>
</ul>
<p><strong>同步和互斥就是用于解决这两个问题的。</strong></p>
<ul>
<li><p><strong>互斥：是指散步在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行</strong>。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</p></li>
<li><p><strong>同步：是指散步在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。</strong>最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。</p></li>
</ul>
<h5 id="互斥锁保护对共享变量的访问">2.1 互斥锁：保护对共享变量的访问</h5>
<p>在上面我们介绍过线程的<strong>主要优势就是能通过全局变量来共享信息，但是必须保证多个线程不会同时修改同一变量或者某一线程不会读取正由其他线程修改的变量</strong>。临界区即指访问某一共享资源代码片段时，这段代码片段的执行应为<strong>原子操作，即其他线程不能终止该片段执行</strong>，否则在没有进行互斥机制下会出错： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> glob=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> loops =*((<span class="type">int</span>*)arg);</span><br><span class="line">	<span class="type">int</span> loc,j;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;loops;j++)&#123;</span><br><span class="line">		loc=glob;</span><br><span class="line">		loc++;</span><br><span class="line">		glob=loc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,cahr* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> t1,t2;</span><br><span class="line">	<span class="type">int</span> loops,s;</span><br><span class="line">	loops=<span class="number">10000</span>;</span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">NULL</span>,threadFunc,&amp;loops);</span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">NULL</span>,threadFunc,&amp;loops);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;glob=%d\n&quot;</span>,glob);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>上述代码中<code>glob</code>按正常来说应该输出为20000，但是输出却是少于这个数的，就是因为多线程对共享区域执行非原子操作时出现的问题，必须使用互斥量</strong></p>
<p>线程里有这么一把锁叫互斥锁（<code>mutex</code>），也叫互斥量，互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即加锁(<code>lock</code>)和解锁(<code>unlock</code>)。互斥锁的操作流程如下：</p>
<ul>
<li>1）在访问共享资源后临界区域前，对互斥锁进行加锁。</li>
<li>2）在访问完成后释放互斥锁导上的锁。</li>
<li>3）对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。</li>
</ul>
<p>互斥锁的数据类型是： <code>pthread_mutex_t</code></p>
<h5 id="互斥锁常用函数">2.2 互斥锁常用函数</h5>
<h6 id="pthread_mutex_init函数初始化一个互斥锁">2.2.1 pthread_mutex_init()函数：初始化一个互斥锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_mutex_init.png" width="600"> <strong><em><code>restrict</code>，C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</em></strong></p>
<h6 id="pthread_mutex_destroy函数销毁互斥锁">2.2.2 pthread_mutex_destroy函数:销毁互斥锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_mutex_destroy.png" width="600"></p>
<h6 id="pthread_mutex_lock函数上锁">2.2.3 pthread_mutex_lock函数：上锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_mutex_lock.png" width="600"></p>
<h6 id="pthread_mutex_unlock函数解锁">2.2.4 pthread_mutex_unlock函数：解锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_mutex_unlock.png" width="600"></p>
<h6 id="示例打印机">2.2.5 示例：打印机</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;		<span class="comment">//互斥量</span></span><br><span class="line"><span class="comment">//打印机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printer</span><span class="params">(<span class="type">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);		<span class="comment">//上锁</span></span><br><span class="line">	<span class="keyword">while</span>(*str!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(*str);</span><br><span class="line">		<span class="built_in">fflush</span>(stdout);</span><br><span class="line">		str++;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);	<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程一</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread_fun_1</span><span class="params">(<span class="type">void</span>*arg)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str =<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="built_in">printer</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程二</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread_fun_2</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">	<span class="built_in">printer</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> t1,t2;</span><br><span class="line">	<span class="comment">//初始化一个互斥锁</span></span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//创建两个线程，处理函数分别为thread_fun_1\thread_fun_2</span></span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">NULL</span>,thread_fun_1,<span class="literal">NULL</span>);</span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">NULL</span>,thread_fun_2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="死锁">2.3 死锁</h5>
<p><strong>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</strong></p>
<h6 id="死锁引起的原因">2.3.1 死锁引起的原因</h6>
<ul>
<li><strong>竞争不可抢占资源引起死锁（</strong>不可抢占是指没有使用完的资源，不能被抢占）</li>
<li><strong>竞争可消耗资源引起死锁</strong>：有p1，p2，p3三个进程，p1向p2发送消息并接受p3发送的消息，p2向p3发送消息并接受p1的消息，p3向p1发送消息并接受p2的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成死锁。</li>
<li><strong>进程推进顺序不当引起死锁</strong>：有进程p1，p2，都需要资源A，B，本来可以p1运行A --&gt; p1运行B --&gt; p2运行A --&gt; p2运行B，但是顺序换了，p1运行A时p2运行B，容易发生第一种死锁。互相抢占资源。</li>
</ul>
<h6 id="死锁的必要条件">2.3.2 死锁的必要条件</h6>
<ul>
<li><strong>互斥条件：</strong>某资源只能被一个进程使用，其他进程请求该资源时，只能等待，直到资源使用完毕后释放资源。</li>
<li><strong>请求和保持条件</strong>：程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。</li>
<li><strong>不可抢占条件：</strong>进程已获得的资源没有使用完，不能被抢占。</li>
<li><strong>循环等待条件：</strong>必然存在一个循环链。</li>
</ul>
<h6 id="预防死锁的思路">2.3.3 预防死锁的思路</h6>
<ul>
<li><strong>预防死锁：</strong>破坏死锁的四个必要条件中的一个或多个来预防死锁。</li>
<li><strong>避免死锁</strong>：和预防死锁的区别就是，在资源动态分配过程中，用某种方式防止系统进入不安全的状态。</li>
<li><strong>检测死锁</strong>：运行时出现死锁，能及时发现死锁，把程序解脱出来</li>
<li><strong>解除死锁</strong>：发生死锁后，解脱进程，通常撤销进程，回收资源，再分配给正处于阻塞状态的进程。</li>
</ul>
<h6 id="预防死锁的方法">2.3.4 预防死锁的方法</h6>
<ul>
<li><strong>破坏请求和保持条件</strong>
<ul>
<li><strong>协议1：</strong>所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生。</li>
<li><strong>协议2：</strong>允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来。然后再请求新的资源。</li>
</ul></li>
<li><p>** 破坏不可抢占条件**：当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请 。</p></li>
<li><p><strong>破坏循环等待条件：</strong>对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</p></li>
</ul>
<h4 id="线程同步之读写锁">3 线程同步之读写锁</h4>
<p>实际上多个线程同时读访问共享资源并不会导致问题。但互斥锁的排他性，导致其它进程或线程无法读取，为克服这个缺陷，就引入了读写锁。 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了<strong>读写锁</strong>来实现。</p>
<h5 id="读写锁的特点">3.1 读写锁的特点</h5>
<ul>
<li>1）如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。</li>
<li>2）如果有其它线程写数据，则其它线程都不允许读、写操作。</li>
</ul>
<p><strong>读写锁分为读锁和写锁，规则如下：</strong></p>
<ul>
<li>1）如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁。</li>
<li>2）如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁。</li>
</ul>
<p>POSIX 定义的读写锁的数据类型是： <code>pthread_rwlock_t</code></p>
<h5 id="读写锁常用函数">3.2 读写锁常用函数</h5>
<h6 id="pthread_rwlock_init函数初始化读写锁">3.2.1 pthread_rwlock_init函数：初始化读写锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_rwlock_init.png" width="600"></p>
<h6 id="pthread_rwlock_destroy函数销毁读写锁">3.2.2 pthread_rwlock_destroy函数：销毁读写锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_rwlock_destroy.png" width="600"></p>
<h6 id="pthread_rwlock_rdlock函数在读写锁上获取读锁">3.2.3 pthread_rwlock_rdlock函数：在读写锁上获取读锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_rwlock_rdlock.png" width="600"></p>
<h6 id="pthread_rwlock_wrlock函数获取写锁">3.2.4 pthread_rwlock_wrlock函数：获取写锁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_rwlock_wrlock.png" width="600"></p>
<h5 id="pthread_rwlock_unlock函数解锁">3.2.5 pthread_rwlock_unlock函数：解锁</h5>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_rwlock_unlock.png" width="600"></p>
<h4 id="线程同步之条件变量">4 线程同步之条件变量</h4>
<p><strong>与互斥锁不同，条件变量是用来等待而不是用来上锁的，条件变量本身不是锁！条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。条件变量就共享变量的状态改变发出通知，而互斥量则提供对该共享变量访问的互斥</strong>。条件变量的类型: <code>pthread_cond_t</code></p>
<p>条件变量的两个动作：</p>
<ul>
<li>条件不满, 阻塞线程</li>
<li>当条件满足, 通知阻塞的线程开始工作</li>
</ul>
<p><strong>条件变量的优点是相较于mutex而言，条件变量可以减少竞争提升效率。如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，且如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的还会浪费CPU资源。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</strong></p>
<h5 id="条件变量常用函数">4.1 条件变量常用函数</h5>
<h6 id="pthread_cond_init函数初始化条件变量">4.1.1 pthread_cond_init函数：初始化条件变量</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_cond_init.png" width="600"></p>
<h6 id="pthread_cond_destroy函数销毁条件变量">4.1.2 pthread_cond_destroy函数：销毁条件变量</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_cond_destroy.png" width="600"></p>
<h6 id="pthread_cond_wait函数阻塞等待">4.1.3 pthread_cond_wait函数：阻塞等待</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_cond_wait.png" width="600"> <strong>abstime补充说明：</strong> <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/abstime.png" width="600"></p>
<h6 id="pthread_cond_signal函数唤醒至少一个阻塞在条件变量上的线程">4.1.4 pthread_cond_signal函数：唤醒至少一个阻塞在条件变量上的线程</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_cond_signal.png" width="600"></p>
<h5 id="示例生产者消费者模型">4.2 示例：生产者消费者模型</h5>
<p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。 <strong>假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//永远指向链表头部的指针</span></span><br><span class="line">Node* head=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//线程同步-互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">//阻塞线程-条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//创建一个链表的节点</span></span><br><span class="line">		Node* pnew =(Node*)<span class="built_in">malloc</span>(<span class="built_in">seziof</span>(Node));</span><br><span class="line">		<span class="comment">//节点初始化</span></span><br><span class="line">		pnew-&gt;data=<span class="built_in">rand</span>()%<span class="number">1000</span>;</span><br><span class="line">		<span class="comment">//使用互斥锁保护共享数据</span></span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">		pnew-&gt;next=head;</span><br><span class="line">		head=pnew;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;=====produce:%lu,%d\n&quot;</span>,<span class="built_in">pthread_self</span>(),pnew-&gt;data);</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//通知条件变量阻塞线程，解除阻塞</span></span><br><span class="line">		<span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="built_in">rand</span>()%<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">customer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">		<span class="comment">//判断链表是否为空，空则阻塞等待</span></span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//线程阻塞，释放互斥锁</span></span><br><span class="line">			<span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex);</span><br><span class="line">			<span class="comment">//解除阻塞后，对互斥锁进行加锁</span></span><br><span class="line">		&#125;</span><br><span class="line">		Node* pdel=head;</span><br><span class="line">		head=head-&gt;next;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----customer:%lu,&amp;d\n&quot;</span>,<span class="built_in">pthread_self</span>(),pdel-&gt;data);</span><br><span class="line">		<span class="built_in">free</span>(pdel);</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数入口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> p1,p2;</span><br><span class="line">	<span class="comment">//init</span></span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_cond_init</span>(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//创建生产者线程</span></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;p1,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//消费者线程</span></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;p2,<span class="literal">NULL</span>,customer,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//阻塞回收子线程</span></span><br><span class="line">	<span class="built_in">pthread_join</span>(p1,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_join</span>(p2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//销毁互斥锁、条件变量</span></span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">	<span class="built_in">pthread_mutex_destory</span>(&amp;cond);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="信号量">5 信号量</h4>
<p>在进程模块我们已经介绍了POSIX信号量，这里我们再做一次介绍。</p>
<ul>
<li><p><strong>信号量广泛用于进程或线程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号量值大于 0 时，则可以访问，否则将阻塞。</strong></p></li>
<li><p>PV原语是对信号量的操作，一次 P 操作使信号量减１，一次 V 操作使信号量加１。信号量主要用于进程或线程间的同步和互斥这两种典型情况。</p></li>
<li><p>信号量数据类型为：sem_t</p></li>
</ul>
<h5 id="信号量用于同步和互斥">5.1 信号量用于同步和互斥</h5>
<p>信号量可用于同步和互斥情况，其用于两种环境分别如下所示：</p>
<ul>
<li>互斥 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/signal_mutex.png" width="400"></li>
<li>同步 <img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/signal_sync.png" width="400"></li>
</ul>
<h5 id="未命名信号量常用函数">5.2 未命名信号量常用函数</h5>
<h6 id="sem_init函数初始化">5.2.1 sem_init函数：初始化</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/sem_init.png" width="600"></p>
<h6 id="sem_destroy函数销毁">5.2.2 sem_destroy函数：销毁</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/sem_destroy.png" width="600"></p>
<h6 id="sem_wait函数信号量p操作减1">5.2.3 sem_wait函数：信号量p操作减1</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/sem_wait.png" width="600"> <code>abs_timeout</code>补充说明： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span>&#123;</span><br><span class="line">	<span class="type">time_t</span> tv_sec;		<span class="comment">//秒</span></span><br><span class="line">	<span class="type">long</span> tv_nsec;		<span class="comment">//纳秒</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="type">time_t</span> cur=<span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> t;</span><br><span class="line">t.tv_sec=cur+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">sem_timedwait</span>(&amp;cond,&amp;t);</span><br></pre></td></tr></table></figure></p>
<h6 id="sem_post函数信号量v操作">5.2.4 sem_post函数：信号量v操作</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/sem_post.png" width="600"></p>
<h6 id="sem_getvalue获取信号量的值">5.2.5 sem_getvalue:获取信号量的值</h6>
<p><img src="/2023/02/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/sem_getvalue.png" width="600"></p>
<h5 id="示例打印机-1">5.3 示例：打印机</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;		<span class="comment">//信号量</span></span><br><span class="line"><span class="comment">//打印机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printer</span><span class="params">(<span class="type">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="built_in">sem_wait</span>(&amp;sem);		<span class="comment">//上锁</span></span><br><span class="line">	<span class="keyword">while</span>(*str!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(*str);</span><br><span class="line">		<span class="built_in">fflush</span>(stdout);</span><br><span class="line">		str++;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">sem_post</span>(&amp;sem);	<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程一</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread_fun_1</span><span class="params">(<span class="type">void</span>*arg)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str =<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="built_in">printer</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程二</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread_fun_2</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span>* str=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">	<span class="built_in">printer</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> t1,t2;</span><br><span class="line">	<span class="comment">//初始化一个未命名信号量,在线程间使用，初始值为1</span></span><br><span class="line">	<span class="built_in">sem_init</span>(&amp;sem,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//创建两个线程</span></span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t1,<span class="literal">NULL</span>,thread_fun_1,<span class="literal">NULL</span>);</span><br><span class="line">	s=<span class="built_in">pthread_create</span>(&amp;t2,<span class="literal">NULL</span>,thread_fun_2,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t1);</span><br><span class="line">	<span class="built_in">pthread_detach</span>(t2);</span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自旋锁">6 自旋锁</h4>
<ul>
<li>自旋锁：<code>spinlock</code>，<strong>在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。 </strong></li>
</ul>
<h4 id="线程安全">7 线程安全</h4>
<ul>
<li><strong>线程安全</strong>：当一个执行区域可供多个线程同时执行，没有出现错误时，我们成为线程安全的。换句话说就是函数可同时供多个线程同时调用，则为线程安全函数。</li>
</ul>
<p>下面代码就不是线程安全，因为当多个线程并发调用该函数时，<code>glob</code>的最终值不得而知，<strong>通常出现线程不安全的原因是因为使用了全局或静态变量</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> glob=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> loops =*((<span class="type">int</span>*)arg);</span><br><span class="line">	<span class="type">int</span> loc,j;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;loops;j++)&#123;</span><br><span class="line">		loc=glob;</span><br><span class="line">		loc++;</span><br><span class="line">		glob=loc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在多线程中保证线程安全的方法有：</p>
<ul>
<li>仅在函数中操作共享变量的代码前后加入互斥量，这样能实现大部分的线程安全；但由于互斥锁的加、解锁开销，也就带来了性能的下降。</li>
<li>如果能避免使用全局或静态变量，可重入函数则无需使用互斥量即可实现线程安全</li>
<li>对于单核CPU时，只需要保证对共享变量是原子操作即可保证线程安全；但多核CPU，则不行</li>
</ul>
<h5 id="可重入不不可重入">7.1 可重入不不可重入</h5>
<ul>
<li><p><strong>不可重入函数：</strong>不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数。如使用了静态的数据解够、malloc()和free、以及标准的I/O函数（因为带缓冲区）都是不可重入函数。</p></li>
<li><p><strong>可重入函数</strong>：函数在被多个进程调度时，不必担心数据出错</p></li>
<li><strong>保证函数的可重入性的方法：</strong>
<ul>
<li>在写函数时候尽量使用局部变量（例如寄存器、栈中的变量）；</li>
<li>对于要使用的全局变量要加以保护（如采取关中断、信号量等互斥方法），这样构成的函数就一定是一个可重入的函数。</li>
</ul></li>
</ul>
<h4 id="线程池">8 线程池</h4>
]]></content>
      <categories>
        <category>Linux coding</category>
      </categories>
      <tags>
        <tag>Linux coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程_网络</title>
    <url>/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h4 id="tcpip协议">1 TCP/IP协议</h4>
<p>TCP/IP协议套件是一个分层联网协议，它包括因特网协议(ip)和位于其上层的各个协议层。</p>
<h5 id="osi七层模型和tcpip模型">1.1 OSI七层模型和TCP/IP模型</h5>
<p><img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/osi.png" width="500"> 各层协议主要有：</p>
<ul>
<li>应用层协议: FTP（文件传输协议）<strong>、HTTP（超文本传输协议）</strong>、NFS（网络文件系统）</li>
<li><strong>传输层协议： TCP （传输控制协议）、UDP（用户数据报协议）</strong></li>
<li>网络层：<strong>IP（英特网互联协议）</strong>、<strong>ICMP（英特网控制报文协议ping）</strong> 、IGMP（英特网组管理协议）</li>
<li>链路层协议：ARP（地址解析协议 通过ip找mac地址）、RARP:（反向地址解析协议 通过mac找ip）</li>
</ul>
<span id="more"></span>
<h5 id="tcp报文格式">1.2 TCP报文格式</h5>
<p><img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/TCP.png" width="500"></p>
<ul>
<li>序列号：该报文的序列号，标识TCP发端向TCP接收端发送的数据字节流</li>
<li><strong>确认序列号</strong>：如果设定了<code>ACK</code>,那么从这个字段包含了接收放期望从发送方接收到的下一个数据字节的序列号</li>
<li>首部长度：该字段标识了TCP报文首部长度，该字段4个比特网位，则表示首部长度最大可达60字节</li>
<li>保留位：该字段有4位未使用的比特位</li>
<li>控制位：
<ul>
<li><code>CWR</code>：拥塞窗口减小标记</li>
<li><code>ECE</code>：显示的拥塞通知回显标记</li>
<li><code>URG</code>：若设置了该位，则紧急指针字段包含的信息有效</li>
<li><strong><code>ACK</code>：若设置了该位，则确认序列号字段包含的信息有效</strong></li>
<li><code>PSH</code>：将所有收到的数据发送接收的进程</li>
<li><code>RST</code>：重置连接</li>
<li><strong><code>SYN</code>：同步序列号</strong></li>
<li><strong><code>FIN</code>：发送端提示已经完成了发送任务</strong></li>
</ul></li>
<li>窗口大小：该字段用在接收端发送ACK确认时提示自己可接受数据的空间大小</li>
<li>校验和：16位的检验</li>
</ul>
<h5 id="tcp和udp的区别">1.3 TCP和UDP的区别</h5>
<ul>
<li><strong>连接</strong>
<ul>
<li><strong>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</strong></li>
<li>UDP则是无连接。</li>
</ul></li>
<li><strong>服务对象</strong>
<ul>
<li>TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</li>
<li>UDP支持一对一，一对多，多对一，多对多的交互通信。</li>
</ul></li>
<li><strong>可靠性</strong>
<ul>
<li><strong>TCP是可靠交付，无差错，不丢失，不重复，按序到达。</strong></li>
<li>UDP是尽最大努力交付，不保证可靠交付。</li>
</ul></li>
<li><strong>拥塞控制，流量控制机制</strong>
<ul>
<li><strong>TCP有拥塞控制和流量控制保证数据传输的安全性。</strong></li>
<li>UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li>
</ul></li>
<li><strong>报文长度</strong>
<ul>
<li><strong>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</strong></li>
<li>UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li>
</ul></li>
<li><strong>首部开销</strong>
<ul>
<li>TCP首部开销大，首部20个字节。</li>
<li>UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</li>
</ul></li>
<li><strong>TCP和UDP适用场景</strong>
<ul>
<li><strong>从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</strong></li>
</ul></li>
</ul>
<h5 id="tcp三次握手四次挥手">1.4 TCP三次握手/四次挥手</h5>
<ul>
<li><strong>只有SYN位置1表示连接请求。</strong></li>
<li><strong>只有ACK置1表示ACK报文段，携带数据时会消耗序号seq，不携带则不消耗</strong></li>
<li><strong>ACK和SYN都置1，不能携带数据，但消耗1个序号seq</strong> <img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/TCP_connect.png" width="400"></li>
</ul>
<h6 id="三次握手">1.4.1 三次握手</h6>
<ul>
<li>1、Client将标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，并将该数据包发送给Server，Client进入<strong>SYN_SENT</strong>状态，等待Server确认。</li>
<li>2、Server收到数据包后由标志位<code>SYN=1</code>知道Client请求建立连接，Server将标志位<code>SYN</code>和<code>ACK</code>都置为1，<code>ack=J+1</code>，随机产生一个值<code>seq=K</code>，并将该数据包发送给Client以确认连接请求，Server进入<strong><code>SYN_RCVD</code></strong>状态。</li>
<li>3、Client收到确认后，检查<code>ack</code>是否为J+1，<code>ACK</code>是否为1，如果正确则将标志位<code>ACK</code>置为1，<code>ack=K+1</code>，并将该数据包发送给Server，Server检查<code>ack</code>是否为K+1，<code>ACK</code>是否为1，如果正确则连接建立成功，Client和Server进入<strong><code>ESTABLISHED</code></strong>状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<p><strong>三次握手的原因：</strong></p>
<ul>
<li>建立连接</li>
<li>第三次要回ACK的原因：如果没有第三次回ACK，会导致已经失效的连接请求报文突然又传输到服务器端，又建立客户端与服务器的连接，但客户端又不发送数据，此时导致的服务器资源浪费。所谓已经失效的连接请求是指客户端发出的连接请求滞留在网络中，超时后但又被服务器接收到。</li>
</ul>
<h6 id="四次挥手">1.4.2 四次挥手</h6>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个<code>FIN</code>来终止这一方向的连接，收到一个<code>FIN</code>只是意味着这一方向上没有数据流动了，即不会再发送到数据了，但是在这个<code>TCP</code>连接上仍然能够收数据，直到另一方也发送了<code>FIN</code>。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p><strong>过程：</strong></p>
<ul>
<li>1.数据传输结束后，客户端的应用进程发出连接释放FIN报文段，并停止发送数据，客户端进入<code>FIN_WAIT_1</code>状态，此时客户端依然可以接收服务器发送来的数据。</li>
<li>2.服务器接收到<code>FIN</code>后，发送一个ACK给客户端，确认序号为收到的序号<code>+1</code>，服务器进入<code>CLOSE_WAIT</code>状态。客户端收到后进入<code>FIN_WAIT_2</code>状态。</li>
<li>3.当服务器没有数据要发送时，服务器发送一个<code>FIN</code>报文，此时服务器进入<code>LAST_ACK</code>状态，等待客户端的确认</li>
<li>4.客户端收到服务器的<code>FIN</code>报文后，给服务器发送一个<code>ACK</code>报文，确认序列号为收到的序号<code>+1</code>。此时客户端进入<code>TIME_WAIT</code>状态，等待<code>2MSL</code>（MSL：报文段最大生存时间），然后关闭连接。</li>
</ul>
<p><strong>应用层可以使用系统调用函数read函数==0来判断对端是否关闭连接。</strong>为什么要等待2MSL才关闭链接:</p>
<ul>
<li>为保证客户端发送的最后一个ACK报文段能够到达服务器。超时重传</li>
<li>经过2MSL时间，可以使本次连接持续时间内所以产生的报文段(主要针对滞留在网络中的）都失效，这样就可避免已失效的本次链接请求影响下一次链接请求。</li>
</ul>
<h6 id="tcp状态转换图">1.4.3 TCP状态转换图</h6>
<p><img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/TCP_stat.png" width="500"></p>
<ul>
<li><code>CLOSED</code>：表示初始状态。</li>
<li><code>LISTEN</code>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li>
<li><code>SYN_SENT</code>：这个状态与<code>SYN_RCVD</code>遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送<code>SYN</code>报文，随即进入到了<code>SYN_SENT</code>状态，并等待服务端的发送三次握手中的第2个报文。<code>SYN_SENT</code>状态表示客户端已发送SYN报文。</li>
<li><code>SYN_RCVD</code>: 该状态表示接收到<code>SYN</code>报文，在正常情况下，这个状态是服务器端的<code>SOCKET</code>在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到<code>ESTABLISHED</code>状态。</li>
<li><code>ESTABLISHED</code>：表示连接已经建立。</li>
<li><code>FIN_WAIT_1</code>: <code>FIN_WAIT_1</code>和<code>FIN_WAIT_2</code>状态的真正含义都是表示等待对方的FIN报文。区别是：
<ul>
<li><code>FIN_WAIT_1</code>状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。</li>
<li><code>FIN_WAIT_2</code>状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</li>
</ul></li>
<li><p><code>FIN_WAIT_2</code>：主动关闭链接的一方，发出<code>FIN</code>收到<code>ACK</code>以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发，既socket上还有数据流动。</p></li>
<li><p><strong><code>TIME_WAIT</code></strong>: 表示收到了对方的<code>FIN</code>报文，并发送出了<code>ACK</code>报文，等2MSL后即可回到<code>CLOSED</code>可用状态。如果<code>FIN_WAIT_1</code>状态下，收到对方同时带 <code>FIN</code>标志和<code>ACK</code>标志的报文时，可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code>状态。</p></li>
<li><p><strong><code>CLOSING</code></strong>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送<code>FIN</code>报文后，按理来说是应该先收到（或同时收到）对方的<code>ACK</code>报文，再收到对方的<code>FIN</code>报文。但是<code>CLOSING</code>状态表示你发送<code>FIN</code>报文后，并没有收到对方的<code>ACK</code>报文，反而却也收到了对方的<code>FIN</code>报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现<code>CLOSING</code>状态，表示双方都正在关闭<code>SOCKET</code>连接。</p></li>
<li><strong><code>CLOSE_WAIT</code></strong>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送<code>FIN</code>报文给自己，系统会回应一个ACK报文给对方，此时则进入到<code>CLOSE_WAIT</code>状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在<code>CLOSE_WAIT</code>状态下，需要关闭连接。（服务器）</li>
<li><p><strong><code>LAST_ACK</code></strong>: 该状态是被动关闭一方在发送<code>FIN</code>报文后，最后等待对方的<code>ACK</code>报文。当收到ACK报文后，即可以进入到<code>CLOSED</code>可用状态。（服务器）</p></li>
</ul>
<h4 id="网络socket先备知识点">2. 网络socket先备知识点</h4>
<h5 id="端口">2.1 端口</h5>
<p><strong>传输层协议的任务是向位于不同主机上的应用程序提供端到端的通信服务。为完成这个任务，传输层需要采用一中方法来区分主机上的应用程序，这种区分工作就由一个16位端口号来完成，即用来标识应用程序(进程)。</strong>众所周知，一些端口已经固定分配给一些应用，如<code>22——ssh</code>、<code>80-HTTP</code>，</p>
<ul>
<li>port：2个字节 0-65535。</li>
<li>0-1023为 知名端口（不可更改）。</li>
<li>自定义端口 1024 - 65535</li>
<li>查看端口使用情况：<code>netstat</code></li>
</ul>
<h5 id="字节序">2.2 字节序</h5>
<p>IP地址和端口号是整数值，这些值在网络传递中的一个问题是不同的硬件结构会以不同的顺序来存储一个多字节整数的字节：</p>
<ul>
<li>存储整数时在最小内存地址先存储最高位的称为大端，<strong>低位存低地址，高位存高地址</strong>（也叫网络字节序）</li>
<li>存储整数时在最小内存地址先存储最低位的称为小端，<strong>低位存高地址，高位存低地址</strong></li>
</ul>
<p><img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/bigorsmall.png" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unit32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">unit32_t</span> hostlong)</span>	<span class="comment">//host to newwork long</span></span></span><br><span class="line"><span class="function"><span class="type">unit16_t</span> <span class="title">htons</span><span class="params">(<span class="type">unit16_t</span> hostshort)</span></span></span><br><span class="line"><span class="function"><span class="type">unit32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">unit32_t</span> netlong)</span></span></span><br><span class="line"><span class="function"><span class="type">nuit16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">unit16_t</span> netshort)</span></span></span><br></pre></td></tr></table></figure> 示例deamon: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="string">&lt;apra/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">4</span>]=&#123;<span class="number">192</span>,<span class="number">168</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	<span class="comment">//int is 4B,char is 1B,can cover by int just right</span></span><br><span class="line">	<span class="type">int</span> num =*(<span class="type">int</span>*)buf;</span><br><span class="line">	<span class="type">int</span> sum=<span class="built_in">htonl</span>(num);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *p=&amp;num;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p=<span class="number">3</span>));</span><br><span class="line">	<span class="type">int</span> sum1=<span class="built_in">ntohl</span>(num);</span><br><span class="line">	p=&amp;sum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p=<span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="ip转换">2.3 ip转换</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;</span><br><span class="line">功能: 将点分十进制串 转成<span class="number">32</span>位网络大端的数据(<span class="string">&quot;192.168.1.2&quot;</span>  ==&gt;   )</span><br><span class="line">参数:</span><br><span class="line">    af : </span><br><span class="line">        AF_INET         IPV4</span><br><span class="line">        AF_INET6        IPV6</span><br><span class="line">  src: 点分十进制串的首地址 </span><br><span class="line">  dst : <span class="number">32</span>位网络数据的地址 </span><br><span class="line">成功返回<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br><span class="line">功能: 将<span class="number">32</span>位大端的网络数据转成点分十进制串</span><br><span class="line">参数:</span><br><span class="line">    af : AF_INET</span><br><span class="line">    src : <span class="number">32</span>位大端的网络数 地址</span><br><span class="line">    dst : 存储点分十进制串 地址</span><br><span class="line">    size : 存储点分制串数组的大小  ，一般为<span class="number">16</span></span><br><span class="line">返回值: 存储点分制串数组首地址</span><br></pre></td></tr></table></figure>
<p>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[]=<span class="string">&quot;192.16.1.2&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET,buf,&amp;num);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* p=(<span class="type">unsigned</span> <span class="type">char</span>*)&amp;num;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p=<span class="number">3</span>));</span><br><span class="line">	cahr ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">inet_ntop</span>(AF_INET,&amp;num,ip,<span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="套接字结构体">2.4 套接字结构体</h5>
<p>网络通信只需解决3个问题（其它组包过程协议会帮我们完成）：协议、ip、端口。而在三个统一在对应的结构体封装，我们只需要创建一个已初始化的结构体即可。</p>
<h6 id="ipv4结构体">2.4.1 IPv4结构体</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strcut in_addr&#123;				<span class="comment">//地址结构体，存储ip地址</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;		<span class="comment">//无符号32位整型</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">	<span class="type">sa_family_t</span> sin_family;		<span class="comment">//协议类型：AF_INET</span></span><br><span class="line">	<span class="type">in_port_t</span>	sin_port;		<span class="comment">//端口</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;	<span class="comment">//ip地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="ipv6结构体">2.4.2 IPv6结构体</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span>&#123;</span><br><span class="line">	<span class="type">uint8_t</span> s6_addr[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span>&#123;</span><br><span class="line">	<span class="type">sa_family_t</span> sin6_family;	<span class="comment">//AF_INET6</span></span><br><span class="line">	<span class="type">in_port_t</span> sin6_port;</span><br><span class="line">	<span class="type">unit32_t</span> sin6_flowinfo;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;</span><br><span class="line">	<span class="type">uint32_t</span> sin6_scope_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="unix-domain结构体">2.4.3 Unix domain结构体</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span>&#123;</span><br><span class="line">	<span class="type">sa_family_t</span> sun_family;		<span class="comment">//AF_UNIX</span></span><br><span class="line">	<span class="type">char</span> sun_path[<span class="number">108</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="通用结构体">2.4.4 通用结构体</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;     <span class="comment">/* address family, AF_xxx */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];          <span class="comment">/* 14 bytes of protocol address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="socket套接字">3 socket套接字</h4>
<p>socket是一钟IPC方法，它允许位于同一主机或使用网络连接起来的不同主机上的应用程序之间能够交换数据。常见的就是： - UNIX domain(AF_UNIX)允许在同一主机上的应用程序之间通信。 - <strong>IPv4(AF_INET)domain允许在使用因特网协议第四版(IPv4)网络连接起来的应用程序之间通信</strong> - <strong>IPv6(AF_INET6)domain允许在使用因特网协议第六版(IPv6)网络连接起来的应用程序之间通信</strong></p>
<p>这里我们主要对网络间通信做说明 <img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/socket_domain.png" width="600"></p>
<p>同样在网络通信中socket支持两种形式的传输一个是<strong>流socket(TCP socket)</strong>，另一个是<strong>数据报socket(UDP socket)</strong>，顾名思义，<strong>它们在传输层走的协议分别是TCP和UDP</strong> <img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/socket_type.png" width="600"></p>
<h5 id="sockettcpudp服务器通信步骤">3.1 socket：TCP/UDP服务器通信步骤</h5>
<p><strong>TCP服务器通信步骤：</strong></p>
<ul>
<li><strong>服务器：</strong>创建套接字 socket-&gt; 绑定 bind-&gt;监听 listen-&gt;提取 accept-&gt;读写-&gt;关闭</li>
<li><strong>客户端</strong>：创建套接字 socket-&gt; 建立连接 connect <img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/client_server.png" width="500"></li>
</ul>
<p><strong>UDP服务器通信步骤：</strong></p>
<ul>
<li>服务器: 创建报式套接字socket-&gt; 绑定bind-&gt; 读写-&gt; 关闭</li>
<li>客户端: 创建报式套接字socket-&gt; 读写-&gt; 关闭 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">发数据：</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">dest_addr: 目的地的地址信息</span><br><span class="line">addrlen: 结构体大小</span><br><span class="line">收数据:</span><br><span class="line">  <span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">src_addr: 对方的地址信息</span><br><span class="line">addrlen: 结构体大小的地址</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="创建套接字api">3.1.1 创建套接字API</h6>
<p>无论是服务器还是客户端都要创建socket</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line">创建套接字</span><br><span class="line">参数:</span><br><span class="line">domain:AF_INET</span><br><span class="line">type: SOCK_STREAM 流式套接字 用于tcp通信</span><br><span class="line">protocol: <span class="number">0</span></span><br><span class="line">成功返回文件描述符,失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h6 id="bind绑定">3.1.2 bind绑定</h6>
<p>给套接字绑定固定的端口和ip</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">成功返回<span class="number">0</span> 失败返回;<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h6 id="listen使服务器处于监听状态">3.1.3 listen：使服务器处于监听状态</h6>
<p>服务器在创建完socket和绑定了相应的端口和ip地址后，要置于监听状态，监听网络中客户端的连接请求：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">    backlog :  已完成连接队列和未完成连接队里数之和的最大值  <span class="number">128</span></span><br></pre></td></tr></table></figure>
<h6 id="accept响应连接请求并建立连接">3.1.4 accept:响应连接请求，并建立连接</h6>
<p>如果连接队列没有新的连接,accept会阻塞</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> socket, <span class="keyword">struct</span> sockaddr *restrict address,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">socklen_t</span> *restrict address_len)</span></span>;</span><br><span class="line">功能: 从已完成连接队列提取新的连接</span><br><span class="line">参数:</span><br><span class="line">    socket : 套接字</span><br><span class="line">    address : 获取的客户端的的ip和端口信息  iPv4套接字结构体地址</span><br><span class="line">    address_len: iPv4套接字结构体的大小的地址</span><br><span class="line">返回值:  新的已连接套接字的文件描述符</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr );</span><br></pre></td></tr></table></figure>
<h6 id="connect客户端连接服务器">3.1.5 connect：客户端连接服务器</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd , <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">功能: 连接服务器</span><br><span class="line">sockfd:  socket套接字</span><br><span class="line">addr:  ipv4套接字结构体的地址</span><br><span class="line">addrlen: ipv4套接字结构体的长</span><br></pre></td></tr></table></figure>
<h6 id="socket的发送接收函数">3.1.6 socket的发送接收函数</h6>
<p>除了常用的<code>read</code>和<code>write</code>函数以外，还有专用于套接字的I/O系统调用<code>recv()</code>和<code>send()</code>(这些一般来说适用于TCP socket) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;<span class="comment">//flags==MSG_PEEK 读数据不会删除缓冲区的数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;<span class="comment">//flags=1 紧急数据</span></span><br></pre></td></tr></table></figure> <strong>flag参数</strong>：(详细请查书)</p>
<ul>
<li><code>MSG_DONTAIT：</code>让<code>recv</code>以非阻塞形式执行</li>
<li><code>MSG_OOB</code>：在套接字上接收带外数据</li>
</ul>
<h5 id="示例简易客户端实现">3.2 示例：简易客户端实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sock_fd;</span><br><span class="line">	sock_fd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//建立连接</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port=<span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET,<span class="string">&quot;169.254.128.147&quot;</span>,&amp;addr.sin_addr.s_addr);</span><br><span class="line">	<span class="type">int</span> ero=<span class="built_in">connect</span>(sock_fd,(<span class="keyword">struct</span> sockaddr*)&amp;addr,<span class="built_in">seziof</span>(addr));</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>!=ero)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;连接失败\n&quot;</span>);</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n =<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">seziof</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(sock_fd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		n= <span class="built_in">read</span>(sock_fd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(STDOUT_FIFLENO,buf,n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(sock_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="示例简易服务器实现">3.3 示例：简易服务器实现</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	<span class="type">int</span> sfd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//绑定</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">	addr.sin_family=AF_INET;</span><br><span class="line">	addr.sin_port=<span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET,<span class="string">&quot;192,168.3.8&quot;</span>,&amp;addr.sin_addr.s_addr);</span><br><span class="line">	<span class="built_in">bind</span>(sfd,(<span class="keyword">struct</span> sockaddr*)&amp;addr,<span class="built_in">sizeof</span>(addr));</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	<span class="built_in">listen</span>(sfd,<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//提取</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">	<span class="type">socklen_t</span> len=<span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">	<span class="type">int</span> cfd=<span class="built_in">accept</span>(sfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">	<span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;建立连接，对端ip：%s\n&quot;</span>,<span class="built_in">inet_ntop</span>(AF_INET,&amp;(cliaddr.sin_addr.s_addr),ip,<span class="number">16</span>));</span><br><span class="line">	<span class="comment">//读写</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">sezifo</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(cfd,buf,n);</span><br><span class="line">		n=<span class="built_in">read</span>(cfd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//关闭</span></span><br><span class="line">	<span class="built_in">close</span>(sfd);</span><br><span class="line">	<span class="built_in">close</span>(cfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务器示例">4 服务器示例</h4>
<h5 id="setsockopt函数">4.1 setsockopt函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">( <span class="type">int</span> socket, <span class="type">int</span> level, <span class="type">int</span> option_name,<span class="type">const</span> <span class="type">void</span> *option_value, <span class="type">size_t</span> ，ption_len)</span></span>;</span><br><span class="line">第一个参数socket是套接字描述符。</span><br><span class="line">第二个参数level是被设置的选项的级别，如果想要在套接字级别上设置选项，就必须把level设置为 SOL_SOCKET。 </span><br><span class="line">option_name指定准备设置的选项，option_name可以有哪些取值，这取决于level</span><br></pre></td></tr></table></figure>
<p><strong><code>option_name</code>:</strong></p>
<ul>
<li><p><code>SO_DEBUG</code>，打开或关闭调试信息。当option_value不等于0时，打开，否则，关闭</p></li>
<li><p><code>SO_REUSEADDR</code>，打开或关闭地址端口复用功能，当option_value不等于0时，打开，否则，关闭。</p></li>
<li><p><code>SO_DONTROUTE</code>，打开或关闭路由查找功能。</p></li>
<li><p><code>SO_BROADCAST</code>，允许或禁止发送广播数据。</p></li>
<li><p><code>SO_SNDBUF</code>，设置发送缓冲区的大小。发送缓冲区的大小是有上下限的，其上限为256 * (sizeof(struct sk_buff) + 256)，下限为2048字节。</p></li>
<li><p><code>SO_RCVBUF</code>，设置接收缓冲区的大小。接收缓冲区大小的上下限分别是：256 * (sizeof(struct sk_buff) + 256)和256字节。</p></li>
<li><p><code>SO_KEEPALIVE</code>，套接字保活。如果协议是TCP，并且当前的套接字状态不是侦听(listen)或关闭(close)，那么，当option_value不是零时，启用TCP保活定时 器，否则关闭保活定时器。</p></li>
<li><p><code>SO_OOBINLINE</code>，紧急数据放入普通数据流。</p></li>
<li><p><code>SO_NO_CHECK</code>，打开或关闭校验和。</p></li>
</ul>
<h5 id="心跳包">4.1 心跳包</h5>
<p>在TCP网络通信中，<strong>经常会出现客户端和服务器之间的非正常断开，需要实时检测查询链接状态。常用的解决方法就是在程序中加入心跳机制。</strong>如果对方异常断开,本机检测不到,一直等待,浪费资源。需要设置tcp的保持连接,作用就是每隔一定的时间间隔发送探测分节,如果连续发送多个探测分节对方还未回,就将次连接断开 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//心跳包</span></span><br><span class="line"><span class="type">int</span>  keepAlive = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="type">void</span>*)&amp;keepAlive, <span class="built_in">sizeof</span>(keepAlive));</span><br></pre></td></tr></table></figure> <strong><em>注：</em></strong> - 心跳包: 最小粒度 - 乒乓包: 携带比较多的数据的心跳包</p>
<h5 id="io端口复用">4.2 IO端口复用</h5>
<p>实际上，默认的情况下，如果一个网络应用程序的一个套接字 绑定了一个端口( 占用了 8000 )，这时候，别的套接字就无法使用这个端口( 8000 )。或者关闭了这个应用程序，但处于TIME_WAIT需等待2MSL，为避免等待，就要使用IO端口复用。 设置端口复用的办法：在套接字绑定前，加以下两句： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> opt=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="type">void</span>*)&amp;opt, <span class="built_in">sizeof</span>(opt));</span><br></pre></td></tr></table></figure> SO_REUSEADDR可以用在以下四种情况下。 (摘自《Unix网络编程》卷一，即UNPv1)</p>
<ul>
<li>1、当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。</li>
<li>2、SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可以测试这种情况。</li>
<li>3、SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。这和2很相似，区别请看UNPv1。</li>
<li>4、SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。</li>
</ul>
<h5 id="多进程版服务器">4.3 多进程版服务器</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_process</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pid=<span class="built_in">waitpid</span>(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">		<span class="keyword">if</span>(pid&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;	<span class="comment">//小于0，代表子进程全部退出，等于0，没有子进程退出</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child pid=%d\n&quot;</span>,pid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用已包裹函数实现socket</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//crtl+c率先于信号注册杀死进程，SIGCHLD信号默认是忽略的</span></span><br><span class="line">	<span class="comment">//导致无法捕捉该信号，因此先屏蔽</span></span><br><span class="line">	<span class="type">sigset_t</span> set;</span><br><span class="line">	<span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;set,SIGCHLD);</span><br><span class="line">	<span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;set,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//创建套接字，绑定</span></span><br><span class="line">	<span class="type">int</span> lfd=<span class="built_in">tcp4bind</span>(<span class="number">8000</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	<span class="built_in">Listen</span>(lfd,<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//提取，回摄服务器</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_int</span> cliaddr;</span><br><span class="line">	<span class="type">socklen_t</span> len=<span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">int</span> cfd=<span class="built_in">Accept</span>(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;建立连接，对端ip:%s\n&quot;</span>,<span class="built_in">inet_ntop</span>(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,<span class="number">16</span>))</span><br><span class="line">		<span class="comment">//创建子进程</span></span><br><span class="line">		<span class="type">pid_t</span> pid;</span><br><span class="line">		pid=fork();</span><br><span class="line">		<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>==pid)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//子进程</span></span><br><span class="line">			<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="type">int</span> n=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">sezifo</span>(buf));</span><br><span class="line">			<span class="built_in">write</span>(cfd,buf,n);</span><br><span class="line">			n=<span class="built_in">read</span>(cfd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">			<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">perror</span>(”read<span class="string">&quot;);</span></span><br><span class="line"><span class="string">				close(cfd);</span></span><br><span class="line"><span class="string">				exit(0);</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			else if(0==n)</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				printf(&quot;</span>客户端已关闭\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">				eixt(0)</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		else&#123;</span></span><br><span class="line"><span class="string">			//父进程</span></span><br><span class="line"><span class="string">			close(fd);</span></span><br><span class="line"><span class="string">			//回收，注册信号，避免父进程粗赛无法提取连接进程</span></span><br><span class="line"><span class="string">			strcut sigcation art;</span></span><br><span class="line"><span class="string">			act.sa.hindler=0;</span></span><br><span class="line"><span class="string">			sigemptyset(&amp;act,sa_fmask);</span></span><br><span class="line"><span class="string">			sigaction(SIGCHLD,&amp;Aact,NULL);</span></span><br><span class="line"><span class="string">			//基础屏蔽</span></span><br><span class="line"><span class="string">			sigcrocmask(SIG_UNBLOCK,%SET,null);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="多线程版实现服务器">4.4 多线程版实现服务器</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">client_info</span>&#123;</span><br><span class="line">	<span class="type">int</span> c_cfd;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> c_addr;</span><br><span class="line">&#125;INFO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Client_fun</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用已包裹函数实现socket</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//分离线程，让系统回收</span></span><br><span class="line">	<span class="type">pthread_attr_t</span> attr;</span><br><span class="line">	<span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">	<span class="type">int</span> m= <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">	<span class="keyword">if</span>(m!=<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;setdetachstate failed\n&quot;</span>);</span><br><span class="line">	<span class="comment">//创建套接字，绑定</span></span><br><span class="line">	<span class="type">int</span> lfd=<span class="built_in">tcp4bind</span>(<span class="number">8000</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	<span class="built_in">Listen</span>(lfd,<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//提取，回摄服务器</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_int</span> cliaddr;</span><br><span class="line">	<span class="type">socklen_t</span> len=<span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">	INFO* c_info;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> cfd=<span class="built_in">Accept</span>(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">		<span class="comment">//要传入线程的参数</span></span><br><span class="line">		c_info=(INFO*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(INFO));</span><br><span class="line">		c_info-&gt;c_cfd=cfd;</span><br><span class="line">		c_info-&gt;c_addr=cliaddr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建线程</span></span><br><span class="line">		<span class="type">pthread_t</span> pth;</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">pthread_create</span>(&amp;pth,&amp;attr,Client_fun,c_info);</span><br><span class="line">		<span class="keyword">if</span>(n!=<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Client_fun</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INFO* info=(INFO*)arg;</span><br><span class="line">	<span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;client ip:%s,port:%d\n&quot;</span>,<span class="built_in">inet_ntop</span>(AP_INET,</span><br><span class="line">	&amp;(info-&gt;c_addr.sin_addr.s_addr),ip,<span class="number">16</span>),<span class="built_in">ntohs</span>(info-&gt;c_addr.sin_port));</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cfd=info-&gt;c_cfd;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">write</span>(cfd,buf,n);</span><br><span class="line">		n=<span class="built_in">read</span>(cfd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;client close\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(cfd);</span><br><span class="line">	<span class="built_in">free</span>(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="高并发技术io多路复用">5 高并发技术(IO多路复用)</h4>
<h5 id="多路io转接复用服务器">5.1 多路IO转接(复用)服务器</h5>
<p>多路IO转接服务器也叫做多任务IO服务器。<strong>该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件描述符的属性变化，查看它们是否准备好执行I/O。</strong></p>
<p>主要使用的方法有三种：select、poll、epoll <img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/compare.png" width="500"></p>
<h5 id="select">5.2 select</h5>
<h6 id="select原理">5.2.1 select原理</h6>
<p><img src="/2023/02/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/select.png" width="600"> select拜托内核去监听<code>cfd</code>和<code>lfd</code>，在应用层上<strong>我们需要人为的备份一份<code>fd_set</code>集合称为<code>oldset</code>，用于每次监听传入的集合。</strong></p>
<p><strong>select进入内核中后，将只会保留那些发生改变的文件描述符，并返回给应用层，此时，我们只需遍历一下返回的集合，就知道要做哪些操作（是读还是写，还是提取新<code>cfd</code>)。后再将更新后（既发生了lfd提取，如上图可增加7之后的文件描述符）或无需更新（未发生提取）的备份<code>oldset</code>传入select</strong>,再次监听。循环如此</p>
<h6 id="select接口">5.2.2 select接口</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">select的API</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">                  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line">功能: 监听多个文件描述符的属性变化(读,写,异常)</span><br><span class="line">     参数:</span><br><span class="line">    nfds  : 最大文件描述符+<span class="number">1</span>(select会遍历的文件描述符的取值范围，因为文件描述符是位图存储（默认共<span class="number">1024</span>个，<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>默认是标准输入输出错误输出占有））</span><br><span class="line">    readfds : 需要监听的读的文件描述符存放集合</span><br><span class="line">    writefds :需要监听的写的文件描述符存放集合 </span><br><span class="line">    exceptfds : 需要监听的异常的文件描述符存放集合  </span><br><span class="line">    timeout: 多长时间监听一次   固定的时间,限时等待   <span class="literal">NULL</span> 永久监听</span><br><span class="line">    <span class="keyword">struct</span> timeval &#123;</span><br><span class="line">               <span class="type">long</span>    tv_sec;         <span class="comment">/* seconds */</span> 秒</span><br><span class="line">               <span class="type">long</span>    tv_usec;        <span class="comment">/* microseconds */</span>微妙</span><br><span class="line">           &#125;;</span><br><span class="line">返回值: 返回的是变化的文件描述符的个数</span><br><span class="line">注意: 变化的文件描述符会存在监听的集合中,未变化的文件描述符会从集合中删除</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">FD_CLR</span>(<span class="type">int</span> fd, fd_set *set);</span><br><span class="line"><span class="type">int</span>  <span class="built_in">FD_ISSET</span>(<span class="type">int</span> fd, fd_set *set);</span><br><span class="line"><span class="type">void</span> <span class="built_in">FD_SET</span>(<span class="type">int</span> fd, fd_set *set);</span><br><span class="line"><span class="type">void</span> <span class="built_in">FD_ZERO</span>(fd_set *set);</span><br></pre></td></tr></table></figure>
<h6 id="select的优缺点">5.2.3 select的优缺点</h6>
<p><strong>优点</strong>：</p>
<ul>
<li>select使用的较为广泛，在unix和windows上都标准化了，<strong>支持跨平台，移植性较好</strong>。</li>
<li>select的超市精度可为微妙级，比poll和epoll的秒级好。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>由于 FD_SETSIZE的限制，文监听的件描述符有1024数量的限制，若要修改，要重新编译程序</strong></li>
<li><strong>只是返回变化的文件描述符的个数,具体哪个那个变化需要完整遍历集合</strong>。</li>
<li>** select和poll一样，每次都需要将需要监听的文件描述集合由应用层符拷贝到内核。当应对大量的文件描述符时，这种从用户空间到内核空间的来回拷贝数据回耗费大量时间。（select和poll共同点）**</li>
<li>** select必须额外维护一个数据结构，这样在再次调用select时才能将其重新传入内核。**</li>
<li><strong>select调用完成后，程序必须按顺序在集合查找发生变化的文件描述符，效率低</strong>
<ul>
<li>假设现在 4-1023个文件描述符需要监听,5-1000这些文件描述发来消息，ok,这种情况没问题</li>
<li>假设现在 4-1023个文件描述符需要监听,但是只有 5,1002 发来消息，无解，只能一一遍历</li>
</ul></li>
</ul>
<h5 id="epoll">5.3 epoll</h5>
<p>epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，<strong>因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</strong></p>
<p>epoll除了提供select/poll那种IO事件的<strong>水平触发</strong>（Level Triggered）外，还提供了<strong>边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</strong></p>
<p><strong>简而言之，epoll具有的特点：</strong></p>
<ul>
<li>同poll一样没有文件描述符的限制</li>
<li>下次监听不需要将需要监听的文件描述符从应用层再次拷贝到核</li>
<li>会返回已经变化的的文件描述符，不用我们去遍历红黑树</li>
</ul>
<h6 id="epoll的api">5.3.1 epoll的API</h6>
<p><strong>①创建一颗红黑树的句柄</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">	size：监听数目</span></span><br><span class="line"><span class="function">	返回值：成功：非负文件描述符，失败：-1，设置响应的errno</span></span><br></pre></td></tr></table></figure></p>
<p><strong>②将需要监听的文件描述符上树，下树、修改操作</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">    epfd : 树的句柄</span><br><span class="line">    op : EPOLL_CTL_ADD 上树   EPOLL_CTL_DEL 下树 EPOLL_CTL_MOD 修改</span><br><span class="line">    fd : 上树,下树的文件描述符</span><br><span class="line">    event :   上树的节点</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">               <span class="type">uint32_t</span>  events;      <span class="comment">/* Epoll events */</span>  需要监听的事件</span><br><span class="line">               <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span> 需要监听的文件描述符</span><br><span class="line">           &#125;;</span><br><span class="line">相应联合体：</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">               <span class="type">void</span>        *ptr;</span><br><span class="line">               <span class="type">int</span>          fd;</span><br><span class="line">               <span class="type">uint32_t</span>     u32;</span><br><span class="line">               <span class="type">uint64_t</span>     u64;</span><br><span class="line">           &#125; <span class="type">epoll_data_t</span>;</span><br><span class="line">例：</span><br><span class="line">将cfd上树</span><br><span class="line"><span class="type">int</span> epfd =  <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev. data.fd = cfd;</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD,cfd, &amp;ev);</span><br></pre></td></tr></table></figure> <code>struct epoll_event</code>结构中，events可以是以下几个宏的集合：</p>
<ul>
<li><strong><code>EPOLLIN</code> ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</strong></li>
<li><strong><code>EPOLLOUT</code>：表示对应的文件描述符可以写；</strong></li>
<li><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li><code>EPOLLERR</code>：表示对应的文件描述符发生错误；</li>
<li><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；</li>
<li><strong><code>EPOLLET</code>： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</strong></li>
<li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</li>
</ul>
<p><strong>③监听：timeout=-1时阻塞</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line">    功能: 监听树上文件描述符的变化</span><br><span class="line">    epfd : 数的句柄</span><br><span class="line">    events : 接收变化的节点（结构体）的数组的首地址，所以我们要创建一个数组去接收他</span><br><span class="line">    maxevents :  数组元素的个数</span><br><span class="line">    timeout : <span class="number">-1</span> 永久监听,阻塞直到有文件描述符发生变化  大于等于<span class="number">0</span> 限时等待</span><br><span class="line">返回值: 返回的是变化的文件描述符个数</span><br></pre></td></tr></table></figure></p>
<h6 id="epoll_wait的两个工作方式">5.3.2 epoll_wait的两个工作方式</h6>
<p>epoll除了提供<code>select/poll</code>那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），<strong>这就使得用户空间程序有可能缓存IO状态，减少<code>epoll_wait/epoll_pwait</code>的调用，提高应用程序效率</strong>。(<code>epoll_wait</code>是一个系统调用,尽量少调用。所以尽量使用边沿触发)</p>
<ul>
<li><strong>水平触发(level-trggered):</strong>
<ul>
<li>只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，</li>
<li>当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知</li>
<li>LT模式支持<strong>阻塞和非阻塞两种方式</strong>，即设置<code>timeout</code>的值。epoll默认的模式是LT</li>
</ul></li>
<li><strong>边缘触发(edge-triggered)</strong>：
<ul>
<li>当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知</li>
<li>当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知</li>
</ul></li>
</ul>
<p>epoll默认为水平触发，若改为边沿，则只需<code>ev.events=EPOLLIN | EPOLLET</code>。水平触发,只要缓存区有数据<code>epoll_wait</code>就会被触发，边沿触发数据来一次只触发一次。</p>
<ul>
<li><strong>水平触发和边缘触发模式区别</strong>
<ul>
<li>读缓冲区刚开始是空的，然后读缓冲区写入2KB数据，水平触发和边缘触发模式此时都会发出可读信号，收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据，水平触发会再次进行通知，而边缘触发不会再进行通知。所以，边缘触发需要一次性的把缓冲区的数据读完为止，也就是一直读，直到读到EGAIN为止，EGAIN说明缓冲区已经空了<strong>，因为这一点，边缘触发需要设置文件句柄为非阻塞</strong></li>
</ul></li>
</ul>
<p><strong><em>注：（即指在使用边缘触发时，由于读数据只触发一次，这个时候要求一次性将数据读完,所以while循环读,读到最后。又因为read默认带阻塞,为不能让read阻塞（因为阻塞的话不能再去监听）,因此设置cfd为非阻塞,这样read读到最后一次返回值为-1.判断errno的值为EAGAIN,代表数据读干净，然后再进行监听）</em></strong></p>
<p><strong><em>工作中： 一般来说，cfd采用边沿触发 + 非阻塞 = 高速模式；lfd采用水平触发</em></strong> <strong><em>注意：边缘触发，目的是减少epoll_wait的调用次数，提升程序效率</em></strong></p>
<h6 id="边缘触发时文件描述符饥饿现象">5.3.3 边缘触发时文件描述符饥饿现象</h6>
<ul>
<li><strong>什么是文件描述符饥饿现象：</strong>现在我么使用边缘触发通知监视多个文件描述符，其中一个就绪态的描述符上有着大量的输入存在，此时我们的程序通过非阻塞的式的读操作将所有输入都读取，那么此时就会使其他文件描述符处于饥饿状态的风险，即我们再次检查文件描述符之前有很长一段处理时间）</li>
<li>解决方法；
<ul>
<li>应用程序维护一个列表，调用epoll_wait监视描述符时，将处于就绪状态的描述符添加到应用程序维护的列表中；然后对列表中的文件描述符进行一定限度的I/O操作(可以采用轮转调度方式循环处理)，当相关非阻塞I/O系统调用出现EAGAIN时，这些文件描述符就能从列表删除，这样就避免了单个文件描述符长时间占有CPU资源导致其他文件描述符的饥饿现象。</li>
</ul></li>
</ul>
<h6 id="epoll监听管道读描述符">5.3.4 epoll监听管道读描述符</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建无名管道,fd[0]为读，fd[1]为写</span></span><br><span class="line">	<span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> ret =<span class="built_in">pipe</span>(fd);</span><br><span class="line">	<span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建epoll,fd[0]上树</span></span><br><span class="line">	<span class="type">int</span> epollfd=<span class="built_in">epoll_create</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="keyword">if</span>(epollfd&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;epoll&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">	ev.events=EPOLLIN;</span><br><span class="line">	ev.data.fd=fd[<span class="number">0</span>];</span><br><span class="line">	ret=<span class="built_in">epoll_ctl</span>(epollfd,EPOLL_CTL_ADD,fd[<span class="number">0</span>],&amp;ev);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>!=ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//监听数组</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> change fd[<span class="number">64</span>];</span><br><span class="line">	<span class="comment">//创建子进程</span></span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>==pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//子进程</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="type">int</span> m=<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">			<span class="built_in">write</span>(fs[<span class="number">1</span>],buf,m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//epoll监听</span></span><br><span class="line">		<span class="type">int</span> nfds=<span class="built_in">epoll_wait</span>(epollfd,change_fd,<span class="number">3</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">-1</span>==nfds)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(change_fd[i].data.fd==fd[<span class="number">0</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">				<span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="epoll应用于服务器">5.3.5 epoll应用于服务器</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcnlt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建套接字，绑定</span></span><br><span class="line">	<span class="type">int</span> lfd=<span class="built_in">tec4bind</span>(<span class="number">8000</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	<span class="built_in">Listen</span>(lfd,<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//创建epoll句柄</span></span><br><span class="line">	<span class="type">int</span> epfd=<span class="built_in">epoll_create</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//将lfd上述</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev,evs[<span class="number">1024</span>;</span><br><span class="line">	ev.data.fd=lfd;</span><br><span class="line">	ev.events=EPOLLIN;</span><br><span class="line">	<span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);</span><br><span class="line">	<span class="comment">//while监听</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> nready=<span class="built_in">epoll_wait</span>(epfd,evs,<span class="number">1024</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-----epoll_wait-----\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(nready&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;epoll_wait failed\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(nready==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//文件描述符有变化</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nready;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//判断lfd变化，并且时读事件变化</span></span><br><span class="line">				<span class="keyword">if</span>(evs[i].data.fd==lfd&amp;&amp;evs[i].events&amp;EPOLLIN)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">					<span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">					<span class="type">socklen_t</span> len=<span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">					<span class="comment">//提取新连接</span></span><br><span class="line">					<span class="type">int</span> cfd=<span class="built_in">Accepet</span>(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);	</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;new connect from ip:%s port:%d\n&quot;</span>,</span><br><span class="line">					<span class="built_in">inet_ntop</span>(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,<span class="number">16</span>),</span><br><span class="line">					<span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line">					<span class="comment">//设置cfd为非阻塞</span></span><br><span class="line">					in flags=<span class="built_in">fcnlt</span>(cfd,F_GETFL);	<span class="comment">//获取cfd的标志位</span></span><br><span class="line">					flags|=O_NONBLOCK;</span><br><span class="line">					<span class="built_in">fcnlt</span>(cfd,F_SETFL,flags);</span><br><span class="line">					<span class="comment">//将cfd上树且为边缘触发</span></span><br><span class="line">					ev.data.fd=cfd;</span><br><span class="line">					ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">					<span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(evs[i].events&amp;EPOLLIN)&#123;</span><br><span class="line">					<span class="comment">//cdf发生变化</span></span><br><span class="line">					<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">						<span class="type">int</span> n=<span class="built_in">read</span>(evs[i].data.fd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">						<span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="comment">//出错</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">//若缓存区是无数据的，跳出while，继续监听</span></span><br><span class="line">							<span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							<span class="comment">//普通错误,cfd该下树</span></span><br><span class="line">							<span class="built_in">perror</span>(<span class="string">&quot;else error\n&quot;</span>);</span><br><span class="line">							<span class="built_in">close</span>(evs[i].data.fd);	<span class="comment">//关闭cfd</span></span><br><span class="line">							<span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&amp;evs[i]);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="comment">//客户端关闭</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="built_in">printf</span>(<span class="string">&quot;client close\n&quot;</span>);</span><br><span class="line">							<span class="built_in">close</span>(evs[i].data.fd);	<span class="comment">//关闭cfd</span></span><br><span class="line">							<span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&amp;evs[i]);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span>&#123;</span><br><span class="line">							<span class="built_in">write</span>(STDIN_FILENO,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">							<span class="built_in">write</span>(evs[i].data.fd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="epoll反应堆">6 epoll反应堆</h4>
]]></content>
      <categories>
        <category>Linux coding</category>
      </categories>
      <tags>
        <tag>Linux coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程_进程</title>
    <url>/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="进程概念">1 进程概念</h4>
<h5 id="进程和线程的区别">1.1 进程和线程的区别</h5>
<ul>
<li><strong>进程：</strong>程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。程序是静态的，进程是动态的。是CPU分配资源的最小单位</li>
<li><strong>线程：</strong>线程（thread）是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。线程是CPU调度的最小单位</li>
</ul>
<span id="more"></span>
<p><strong>关系：</strong></p>
<ul>
<li>一个进程可有多个线程</li>
<li>进程间很难共享数据，线程很容易实现数据共享</li>
<li>进程比线程消耗更多的计算机资源</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li><p>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉</p></li>
<li><p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源，所以我们也说，进程是CPU分配资源的最小单位。</p></li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>线程存在与进程当中(进程可以认为是线程的容器)，是操作系统调度执行的最小单位。说通俗点，线程就是干活的，轻量级进程。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。（是为避免进程fork()产生写时拷贝的不必要时间和内存支出） <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/memory.png" width="400"></li>
</ul>
<h5 id="并行和并发">1.2 并行和并发</h5>
<ul>
<li><strong>并行(parallel)</strong>：指在同一时刻，有多条指令在多个处理器上同时执行。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/parallel.png" width="400"></li>
<li><strong>并发(concurrency)：</strong>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/concurrency.png" width="400"></li>
</ul>
<h5 id="进程的状态">1.3 进程的状态</h5>
<p>在五态模型中，进程分为<strong>新建态、终止态，运行态，就绪态，阻塞态</strong>. <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/process.png" width="500"></p>
<ul>
<li><p><strong>创建状态：</strong>进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</p></li>
<li><p><strong>就绪状态</strong>：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行</p></li>
<li><p><strong>执行状态</strong>：进程处于就绪状态被调度后，进程进入执行状态</p></li>
<li><p><strong>阻塞状态</strong>：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用</p></li>
<li><p><strong>终止状态</strong>：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</p></li>
</ul>
<h5 id="孤儿进程和僵尸进程">1.4 孤儿进程和僵尸进程</h5>
<ul>
<li><p><strong>孤儿进程</strong>：父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程（Orphan Process）。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 <code>init</code> ，而 <code>init</code> 进程会循环地 <code>wait()</code> 它的已经退出的子进程。孤儿进程不会有什么危害。</p></li>
<li><p><strong>僵尸进程：</strong>进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。这样就会导致一个问题，如果进程不调用<code>wait()</code> 或 <code>waitpid()</code> 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用。因此一定要回收进程号。</p></li>
</ul>
<h6 id="避免僵尸进程的方法">1.4.1 避免僵尸进程的方法</h6>
<ul>
<li><strong>SIGCHID产生条件</strong>：
<ul>
<li>子进程终止时</li>
<li>子进程接收到SIGSTOP信号停止时</li>
<li>子进程处在停止态，接受到SIGCONT后唤醒时</li>
</ul></li>
<li><strong>避免方法</strong>
<ul>
<li>最简单的方法，父进程通过<code>wait()</code>和 <code>waitpid()</code> 等函数等待子进程结束，但是，这会导致父进程挂起。</li>
<li>如果父进程要处理的事情很多，不能够挂起，通过<code>signal()</code>函数人为处理信号 SIGCHLD ， 只要有子进程退出自动调用指定好的回调函数，因为子进程结束后， 父进程会收到该信号 SIGCHLD ，可以在其回调函数里调用<code>wait()</code>或<code>waitpid()</code>回收。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_child</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="comment">//处理僵尸进程，-1代表等待任意一个子进程，WNOHANG代表不阻塞</span></span><br><span class="line">	<span class="keyword">while</span>((pid=<span class="built_in">waitpid</span>(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>,pid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//捕捉子进程退出信号，只有子进程退出，触犯SIGCHLD,自动调用sig_child</span></span><br><span class="line">	<span class="built_in">signal</span>(SIGCHLD,sig_child);</span><br><span class="line">	<span class="comment">//创建子进程，执行相应任务</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>交由内核处理</strong>：如果父进程不关心子进程什么时候结束，那么可以用<code>signal(SIGCHLD, SIG_IGN)</code>通知内核，自己对子进程的结束不感兴趣，父进程忽略此信号，那么子进程结束后，内核会回收，并不再给父进程发送信号。</li>
</ul></li>
</ul>
<h5 id="进程相关命令">1.5 进程相关命令</h5>
<h6 id="ps命令">1.5.1 ps命令</h6>
<p>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。<code>ps</code>命令可以查看进程的详细状况，常用选项(选项可以不加<code>“-”</code>)如下: <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/ps.png" width="600"></p>
<p>进程的状态表示： <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/status_ps.png" width="600"></p>
<h6 id="top命令">1.5.2 top命令</h6>
<p><code>top</code>命令用来动态显示运行中的进程。<code>top</code>命令能够在运行后，在指定的时间间隔更新显示信息。可以在使用<code>top</code>命令时加上<code>-d</code>来指定显示信息更新的时间间隔。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/top.png" width="600"></p>
<h6 id="kill命令">1.5.3 kill命令</h6>
<p><code>kill</code>命令指定进程号的进程，需要配合<code>ps</code>使用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure> 信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。</p>
<h6 id="killall命令">1.5.4 killall命令</h6>
<p>通过进程名字杀死进程 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">killall [选项]  name</span><br><span class="line"><span class="meta"># killall -9 php-fpm          <span class="comment">//结束所有的 php-fpm 进程</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="进程函数">2 进程函数</h4>
<h5 id="进程号">2.1 进程号</h5>
<p>每个进程都要唯一标识号码，我们称为进程号，后续的许多工作我们都要使用到进程号来指定哪个进程。</p>
<ul>
<li>** 进程号（PID）：**标识进程的一个非负整型数。</li>
<li><strong>父进程号（PPID）</strong>：任何进程（ 除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。如，A 进程创建了 B 进程，A 的进程号就是 B 进程的父进程号。</li>
<li>** 进程组号（PGID）：**进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID） ，默认的情况下，当前的进程号会当做当前的进程组号</li>
</ul>
<h6 id="getpid函数">2.1.1 getpid函数</h6>
<p><code>getpdid</code>函数的作用是获取当前进程的进程号 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/getpid.png" width="600"></p>
<h6 id="getppid函数">2.1.2 getppid函数</h6>
<p><code>getppid</code>函数作用是获取当前调用该函数进程的父进程号。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/getppid.png" width="500"></p>
<h6 id="getpgid函数">2.1.3 getpgid函数</h6>
<p><code>getpgid</code>函数获取指定进程的进程组号 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/getpgid.png" width="600"></p>
<h5 id="进程创建">2.2 进程创建</h5>
<p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/fork.png" width="600"></p>
<h6 id="父子进程的关系">2.2.1 父子进程的关系</h6>
<p>使用<code>fork()</code>函数得到的子进程是父进程的一个复制品，它从父进程处拷贝整个进程的虚拟内存空间：<strong>包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。</strong>子进程所独有的只有它的<strong>进程号，计时器等（只有小量信息）</strong>。因此，使用 fork() 函数的代价是很大的。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/relations.png" width="400"></p>
<p><strong>幸运的是，Linux 的<code>fork()</code>使用是通过</strong>写时拷贝 (copy- on-write) *实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个内存地址空间。只用在需要写入的时候才会复制地址空间从而使各个进程拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享同一物理内存。** <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/writecopy.png" width="500"></p>
<p><code>fork</code>之后父子进程共享文件，<code>fork</code>产生的子进程与父进程具有相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件的偏移指针。(后面会讲到父子进程的地址空间)</p>
<h6 id="区分父子进程">2.2.2 区分父子进程</h6>
<p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样的。利用<code>fork()</code>函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是<code>0</code>，而父进程的返回值则是新子进程的进程<code>ID</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">		<span class="comment">//子进程</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;I am son\n&quot;</span>);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//父进程</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;I am father\n&quot;</span>);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 注意的是，在子进程的地址空间里，子进程是从 fork() 这个函数后才开始执行代码 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/runson.png" width="500"></p>
<h6 id="父子进程的地址空间">2.2.3 父子进程的地址空间</h6>
<p>父子进程各自的地址空间是独立的。通过上面的写时拷贝/读时共享机制介绍得知，在子进程修改变量 a，b 的值，并不影响到父进程 a，b 的值。（写时拷贝） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b= <span class="number">20</span>;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;son: a=%d, b=%d\n&quot;</span>,a,b); <span class="comment">//son: a=10，b=20</span></span><br><span class="line">		a=<span class="number">111</span>;</span><br><span class="line">		b=<span class="number">222</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;son: a=%d, b=%d\n&quot;</span>,a,b); <span class="comment">//son: a=111，b=222</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);	<span class="comment">//保证子进程先运行</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;father: a=%d, b=%d\n&quot;</span>,a,b);<span class="comment">//father: a=10，b=20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 同理，子进程睡眠，父进程写也是如此。<strong>堆区分配空间也一样，但要注意，要释放两次：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>==p)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc failed...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*p=<span class="number">200</span>;</span><br><span class="line">num=<span class="number">100</span>;</span><br><span class="line">var=<span class="number">88</span>;</span><br><span class="line">pid=fork();</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">	<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子进程睡醒之后 *p=%d&quot;</span> num=%d var=%d\n<span class="string">&quot;,*p,num,var); //200 100 88</span></span><br><span class="line"><span class="string">	free(p);</span></span><br><span class="line"><span class="string">	p=NULL;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else if(pid&gt;0)&#123;</span></span><br><span class="line"><span class="string">	printf(&quot;</span>父进程执行前：*p=%d<span class="string">&quot; num=%d var=%d\n&quot;</span>,*p,num,var);<span class="comment">//200 100 88</span></span><br><span class="line">	<span class="comment">//执行写入，会进行拷贝</span></span><br><span class="line">	var++;</span><br><span class="line">	num++;</span><br><span class="line">	*p++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;父进程执行后：*p=%d&quot;</span> num=%d var=%d\n<span class="string">&quot;,*p,num,var); //201 101 89</span></span><br><span class="line"><span class="string">	free(p);</span></span><br><span class="line"><span class="string">	p=NULL;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>2次分配，2次释放<code>（valgrind 查看)</code> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/malloc.png" width="500"></p>
<h5 id="进程退出">2.3 进程退出</h5>
<h6 id="进程退出函数">2.3.1 进程退出函数</h6>
<p><code>exit()</code>和<code>exit()</code>函数功能和用法是一样的，无非时所包含的头文件不一样，还有的区别就是：<code>exit()</code>属于标准库函数，<code>_exit()</code>属于系统调用函数。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/exit.png" width="600"></p>
<h6 id="等待子进程退出函数">2.3.2 等待子进程退出函数</h6>
<p><code>wait()</code> 和 <code>waitpid()</code> 函数的功能一样，区别在于，<code>wait()</code> 函数会阻塞，<code>waitpid()</code> 可以设置不阻塞，<code>waitpid()</code> 还可以指定等待哪个子进程结束。</p>
<ul>
<li><p>①wait函数 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/wait.png" width="600"> <strong>调用 <code>wait()</code> 函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒（相当于继续往下执行）</strong>。若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。所以，<code>wait()</code>函数的主要功能为回收已经结束子进程的资源。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">sleep</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">		<span class="comment">//子进程</span></span><br><span class="line">		<span class="type">int</span> i=<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">while</span>(i)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;I am son,i am doing something\n&quot;</span>);</span><br><span class="line">			i--;</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//子进程终止</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//父进程执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;I am waiting for son\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now,son has done all thing\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 对于<code>wait(&amp;status)</code>函数获取到的<code>status</code>状态，我们可使用已定义好的宏查看其子进程返回的是什么状态(分为三种）：</p>
<ul>
<li><ol type="1">
<li><code>WIFEXITED(status)</code>：判断进程是否正常结束，若正常结束；使用此宏<code>WEXITSTATUS(status)</code>获取进程退出状态 (exit的参数)</li>
</ol></li>
<li><ol start="2" type="1">
<li><code>WIFSIGNALED(status)</code>：判断进程是否异常终止，若是；使用此宏<code>WTERMSIG(status)</code>取得使进程终止的那个信号的编号。</li>
</ol></li>
<li><ol start="3" type="1">
<li><code>WIFSTOPPED(status)</code>:判断进程是否处于暂停状态，若是；使用此宏<code>WSTOPSIG(status)</code>取得使进程暂停的那个信号的编号。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子进程退出状态码：%d\n&quot;</span>,<span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">WIFSIGNALED</span>(status))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子进程被信号%d杀死了\n&quot;</span>,<span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">WIFSTOPPED</span>(status))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子进程被信号%d暂停了\n&quot;</span>,<span class="built_in">WSTOPSIG</span>(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul></li>
<li><p>②waitpid函数 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/waitpid.png" width="600"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父进程执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am waiting for son\n&quot;</span>);</span><br><span class="line">ret=<span class="built_in">waitpid</span>(<span class="number">-1</span>,&amp;status,WNOHANG);</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="进程替换">2.3.3 进程替换</h6>
<p>Linux 平台，我们可以通过<code>./</code> 运行，让一个可执行程序成为一个进程。但是，如果我们本来就运行着一个程序（进程），我们如何在这个进程内部启动一个外部程序，由内核将这个外部程序读入内存，使其执行起来成为一个进程？这里我们通过 <code>exec</code> 函数族实现。</p>
<p><code>exec</code> 指的是一组函数，一共有 6个 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/exec.png" width="600"></p>
<ul>
<li><strong>其中只有 <code>execve()</code> 是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</strong></li>
<li><code>exec</code>函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</li>
<li>进程调用一种 <code>exec</code>函数时，该进程完全由新程序替换，而新程序则从其<code>main</code>函数开始执行。因为调用 <code>exec</code> 并不创建新进程，所以前后的进程 ID （当然还有父进程号、进程组号、当前工作目录……）并未改变。<code>exec</code> 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换）。</li>
</ul>
<h4 id="进程间通信重要">3 进程间通信(重要)</h4>
<p>进程间通信主要包括管道、FIFO、系统IPC（消息队列、共享内存、信号量）、Socket、；进程同步主要有信号量、文件锁、互斥锁、条件变量； <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/IPC.png" width="500"></p>
<h5 id="通信方式的选择">3.1 通信方式的选择</h5>
<p>要依据应用选择进程间的通信方式，就必须了解各个进程通信方式的特点。在数据传输工具当中，有几点要注意：</p>
<ul>
<li>一些数据传输工具主要以字节流形式传输(如管道、流socket、FIFO)，另一些则是面向消息的(如消息队列、数据报socket)。</li>
<li>System V和POSIX消息队列特有的一个特性就是它们能够给消息赋一个数值类型或优先级，这样传递消息的顺序可以与发生消息的顺序不同了。</li>
<li>管道、FIFO、Socket使用文件描述符来实现，这样这些传输工具就能够使用I/O多路复用进行控制，而那些使用标识符的则无法使用该技术。（注意区分文件描述符和IPC标识符，文件描述符是一个进程特性，标识符则是对象的一个属性并且全局可见）</li>
<li>POSIX消息队列提供了一个通知工具，当一条消息进入一个之前为空的队列中时可以使用它来向进程发送信号或实例化一个新线程</li>
<li>管道、匿名内存映射等一些IPC工具只允许有关系的进程进行互相通信</li>
</ul>
<h5 id="管道">3.2 管道</h5>
<p>管道主要包括<strong>无名管道(pipe)和命名管道(FIFO)</strong>。</p>
<ul>
<li>无名管道：可用于具有亲缘关系的父子进程间的通信，</li>
<li>有名管道：除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</li>
</ul>
<h6 id="无名管道pipe">3.2.1 无名管道PIPE</h6>
<p>管道也叫无名管道，所有的 UNIX 系统都支持这种通信机制。 具有如下特点：</p>
<ul>
<li><ol type="1">
<li>半双工，数据在同一时刻只能在一个方向上流动。</li>
</ol></li>
<li><ol start="2" type="1">
<li>数据只能从管道的一端写入，从另一端读出。</li>
</ol></li>
<li><ol start="3" type="1">
<li>写入管道中的数据遵循先入先出的规则。</li>
</ol></li>
<li><ol start="4" type="1">
<li>管道所传送的数据是无格式的，它是字节流形式，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息等。</li>
</ol></li>
<li><ol start="5" type="1">
<li>管道不是普通的文件，不属于某个文件系统，其只存在于内存中。</li>
</ol></li>
<li><ol start="6" type="1">
<li>管道在内存中对应一个缓冲区，有其容量限制。不同的系统其大小不一定相同。</li>
</ol></li>
<li><ol start="7" type="1">
<li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据。</li>
</ol></li>
<li><ol start="8" type="1">
<li>管道没有名字，只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</li>
</ol></li>
<li>9）可以确保在多进程中，当写入数据量不超过PIPE_BUF时，写入<code>write</code>为原子操作，否则可能不是。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/pipe.png" width="600"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例：子进程通过无名管道给父进程传递一个字符串数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd_pipe[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">pipe</span>(fd_pipe)&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;create pipe failed..\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> buf[]=<span class="string">&quot;I am son&quot;</span>;</span><br><span class="line">		<span class="built_in">write</span>(fd_pipe[<span class="number">1</span>],buf,strlen[buf]);</span><br><span class="line">		_exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wait</span>(<span class="literal">NULL</span>);<span class="comment">//等待子进程结束，回收其资源</span></span><br><span class="line">		<span class="type">char</span> str[<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="built_in">read</span>(fd_pipe[<span class="number">0</span>],str,<span class="built_in">sizeof</span>(str));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str=[%s]\n&quot;</span>,str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>读写特点:</strong></li>
<li>读管道：
<ul>
<li>1、管道中有数据，read返回实际读到的字节数。</li>
<li>2、 管道中无数据：
<ul>
<li>管道写端被全部关闭，read返回0 (相当于读到文件结尾)</li>
<li>写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</li>
</ul></li>
</ul></li>
<li>写管道：
<ul>
<li>1、 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程终止)</li>
<li>2、 管道读端没有全部关闭：
<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ul></li>
</ul></li>
</ul>
<p><strong>设置非阻塞的方法：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先获取原来的flag</span></span><br><span class="line"><span class="type">int</span> flags=<span class="built_in">fcnlt</span>(fd[<span class="number">0</span>],F_GETFL);</span><br><span class="line"><span class="comment">//设置新的flags</span></span><br><span class="line">flags |=O_NONBLOCK;</span><br><span class="line"><span class="built_in">fcnlt</span>(fd[<span class="number">0</span>],F_SETFL,flags);</span><br></pre></td></tr></table></figure> 此时如果写端没有关闭，读端因为设置为非阻塞， 如果没有数据，直接返回-1</p>
<p><strong>获取缓冲区大小函数/命令</strong>： <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/fpathconf.png" width="600"></p>
<p>命令：可以使用ulimit -a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。</p>
<h6 id="有名管道fifo">3.2.2 有名管道FIFO</h6>
<p>命名管道<code>FIFO</code>，也叫有名管道、FIFO文件。<strong>FIFO支持不相关的进程也可以进行通信。</strong>命名管道（FIFO)和无名管道（pipe）有一些特点是相同的，不一样的地方在于：</p>
<ul>
<li><ol type="1">
<li>FIFO 在文件系统中作为一个特殊的文件而存在，但 FIFO 中的内容却存放在内存中。</li>
</ol></li>
<li><ol start="2" type="1">
<li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。</li>
</ol></li>
<li><ol start="3" type="1">
<li>FIFO 有名字，不相关的进程可以通过打开命名管道进行通信。</li>
</ol></li>
</ul>
<p><strong>创建FIFO的函数<code>mkfifo()</code></strong>: <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/mkfifo.png" width="600"> 也可以通过命令<code>mkfifo</code>管道名，创建一个<code>fifo</code></p>
<p><strong>读写操作</strong>： 一旦使用<code>mkfifo</code>创建了一个FIFO，就可以使用<code>open</code>打开它，常见的文件I/O函数都可用于fifo。如：<code>close、read、write</code>等。FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进程1，执行写</span></span><br><span class="line"><span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;my_fifo&quot;</span>,O_WRONLY);</span><br><span class="line"><span class="type">char</span> send[<span class="number">1000</span>]=<span class="string">&quot;HELLO WORLD&quot;</span>;</span><br><span class="line"><span class="built_in">write</span>(fd,send,<span class="built_in">strlen</span>(send));</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程2，执行读</span></span><br><span class="line"><span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;my_fifo&quot;</span>,O_RDONLY);</span><br><span class="line"><span class="type">char</span> recv[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//读数据时，命名管道没数据时会堵塞，有数据时就读出来</span></span><br><span class="line"><span class="built_in">read</span>(fd,recv,<span class="built_in">seziof</span>(recv));</span><br><span class="line"><span class="built_in">printf</span>(read from my_fifo buf=[%s]\n<span class="string">&quot;,recv);</span></span><br></pre></td></tr></table></figure> - 1) 一个为只读而打开一个管道的进程会阻塞直到另外一个进程为只写打开该管道 - 2）一个为只写而打开一个管道的进程会阻塞直到另外一个进程为只读打开该管道</p>
<h5 id="system-v-ipc通信和posix-ipc通信概览">3.3 system V IPC通信和POSIX IPC通信概览</h5>
<p>不管是system V IPC通信，还是POSIX IPC通信，两种形式的IPC通信都只适合在同一主机下进行进程通信。其中包含的消息队列、信号和共享内存三者作用是：</p>
<ul>
<li><strong>消息队列可以用来在进程间传递消息。</strong></li>
<li><strong>信号量允许多个进程同步各自的动作。</strong></li>
<li><strong>共享内存使得多个进程能够共享同一块内存区域</strong></li>
</ul>
<h6 id="system-v-ipc通信">3.3.1 System V IPC通信</h6>
<p>System V IPC的接口如下所示 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/system v ipc.png" width="600"></p>
<ul>
<li>每钟system V IPC机制都要相关的<code>get</code>调用，其完成作用有（<strong>注意区分文件描述符和IPC标识符，文件描述符是一个进程特性，标识符则是对象的一个属性并且全局可见</strong> ）：
<ul>
<li>使用给的key创建一个新IPC对象并返回一个唯一标识符来标识该对象</li>
<li>返回一个给定key的既有的IPC对象标识符</li>
</ul></li>
<li>System V 提供的进程间通信机制需要一个唯一 key 值，通过 key 值就可在系统内获得一个唯一标识符。key 值可以是人为指定的，也可以通过 <code>ftok()</code> 函数获得。key获得有两种方法：
<ul>
<li>使用IPC_PRIVATE产生一个唯一key：如<code>id=msgget(IPC_PRIVATE,S_IRUSR|S_IWUSR)</code>，此时，代码无需指定<code>IPC_CREAT</code>和<code>IPC_EXCL</code>标识</li>
<li>使用<code>ftok()</code>产生一个唯一key：<code>ftok()</code>函数会返回一个适合在后续对某个System V IPC get系统调用进行调用时的key值 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">key_t</span> key;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">key=<span class="built_in">ftok</span>(<span class="string">&quot;/mydir/mylife&quot;</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span>==key)</span><br><span class="line">	<span class="built_in">errExit</span>(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">id=<span class="built_in">msgget</span>(key,IPC_CREAT|S_IRUSR|S_IWUSR);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span>==id)</span><br><span class="line">	<span class="built_in">errExiit</span>(<span class="string">&quot;msgget&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><code>ipcs</code>和<code>ipcrm</code>命令：<code>ipcs</code>和<code>ipcrm</code>命令是System v IPC领域中类似ls和rm文件命令，使用ipcs能够获取系统上的IPC对象信息,而ipcrm则删除一个ipc对象，主要有两种形式<code>ipcrm -X key</code>和<code>ipcrm -x id</code> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/ipcs.png" width="500"></li>
</ul>
<h6 id="posix-ipc通信">3.3.2 POSIX IPC通信</h6>
<p>POSIX IPC的接口如下所示 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/POSIX.png" width="500"></p>
<ul>
<li>每种POSIX IPC机制都有一个关联的<code>open()</code>调用，其完成两个任务中的一个
<ul>
<li>使用给定名字创建一个新对象，打开该对象并返回该对象的一个<strong>文件描述符</strong>（与System V不同之处，这时候就可以使用I/O多路复用机制，如poll、select、epoll等）</li>
<li>打开一个既有对象并返回该对象的一个句柄</li>
</ul></li>
<li>同样，与System V一样，创建时使用<code>O_CREAT</code>和<code>O_EXCL</code>标识,作用与<code>IPC_CREAT</code>和<code>IPC_EXCL</code>标识一样。
<ul>
<li><code>O_CREAT</code>：若对象不存在，就创建；若存在但未指定这个标记，则会返回错误<code>ENOENT</code></li>
<li><code>O_EXCL</code>：只能与<code>O_CREAT</code>结合使用。若同时指定<code>O_CREAT</code>且对象存在，则会返回错误<code>EEXIST</code>，这个标识符检查&quot;是否存在和创建”是原子操作，</li>
</ul></li>
<li>所有<code>open()</code>至少接收三个参数——<code>name、oflag和mode</code>,如<code>fd=shm_open(&quot;/mymem&quot;,O_CREAT|O_RDWR,S_IRUSR|S_IWUSR);</code></li>
</ul>
<h6 id="区别">3.3.3 区别</h6>
<p>system V是早期实践中弄出来的，posix是后来标准化之后的产物，因此：</p>
<ul>
<li>system V的移植性更强，几乎所有Unix实现都支持System V；而POSIX 移植性弱一些</li>
<li>POSIX使用文件描述符，因此可以使用I/O多路复用技术，而System V使用标识符，不能使用</li>
<li>因为创建的System V IPC使用标识符，因此内核不会维护引用System V的进程数，那么应用程序就不知道何时应该删除一个System V IPC通信方式；而POSIX IPC的对象是引用计数的，当所有进程都关闭该对象后计数为0，对象就会被销毁。</li>
</ul>
<p>就经验来说：在使用IPC的场景下，一般进程间的消息传递和同步上，使用POSIX较为普遍，而共享内存则是system V笔记多。</p>
<h5 id="system-v消息队列">3.4 system V消息队列</h5>
<h6 id="消息队列的特点">3.4.1 消息队列的特点</h6>
<p>消息队列虽然在某些方面与FIFO类似，但也有不同：</p>
<ul>
<li><p>1）消息队列可以实现消息的随机查询。消息不一定要以先进先出的次序读取，编程时可以按消息的类型读取，即有优先级。</p></li>
<li><p>2）消息队列允许一个或多个进程向它写入或者读取消息。</p></li>
<li><p>3）与无名管道、命名管道一样，从消息队列中读出消息，消息队列中对应的数据都会被删除。</p></li>
<li><p>4）不同的是消息队列是面向消息的，即接收和写入都是整条消息，读取一条消息的一部分而让剩余的遗留在队列中是不可能的。</p></li>
<li><p>5）每个消息队列都有消息队列标识符，不是文件描述符，消息队列的标识符在整个系统中也是唯一的。</p></li>
<li><p>6）消息队列是消息的链表，存放在内存中，由内核维护。<strong>只有内核重启或人工删除消息队列时，该消息队列才会被删除。</strong>若不人工删除消息队列，消息队列会一直存在于系统中。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="创建或打开一个消息队列">3.4.2 创建或打开一个消息队列</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建一个新的或打开一个已经存在的消息队列。不同的进程调用此函数，只要用相同的 key 值就能得到同一个消息队列的标识符</span></span><br><span class="line"><span class="comment">//key: ftok() 返回的 key 值</span></span><br><span class="line"><span class="comment">//msgflg: 标识函数的行为及消息队列的权限，其取值如下：</span></span><br><span class="line"><span class="comment">//	IPC_CREAT：创建消息队列。</span></span><br><span class="line"><span class="comment">//	IPC_EXCL： 检测消息队列是否存在。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>
<h6 id="交换消息">3.4.3 交换消息</h6>
<p><code>msgsnd()</code>和<code>msgrcv()</code>系统调用执行消息队列上的I/O，这两个系统调用接收的第一个参数是队列标识符<code>msqid</code>。第二个参数是由调用者定义的结构体指针，该结构用来存放消息，结构可为： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mymsg</span>&#123;</span><br><span class="line">	<span class="type">long</span> mtype;</span><br><span class="line">	<span class="type">char</span> mtext[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 发送信息：<code>msgsnd()</code>将新消息添加到消息队列。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include &lt;sys/msg.h&gt;</span><br><span class="line"><span class="comment">//msqid： 消息队列的标识符。</span></span><br><span class="line"><span class="comment">//msgp：  待发送消息结构体的地址。</span></span><br><span class="line"><span class="comment">//msgsz： 消息正文的字节数。</span></span><br><span class="line"><span class="comment">//msgflg：函数的控制属性，其取值如下：</span></span><br><span class="line"><span class="comment">//0：msgsnd() 调用阻塞直到条件满足为止。</span></span><br><span class="line"><span class="comment">//IPC_NOWAIT: 若消息没有立即发送则调用该函数的进程会立即返回。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(  <span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure> 接收信息：<code>msgrcv()</code>从消息队列中读取（以及删除）一条消息并将内容复制进<code>msgp</code>指向的缓冲区中 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">//msqid：消息队列的标识符，代表要从哪个消息列中获取消息。</span></span><br><span class="line"><span class="comment">//msgp： 存放消息结构体的地址。</span></span><br><span class="line"><span class="comment">//msgsz：消息正文的字节数。</span></span><br><span class="line"><span class="comment">//msgtyp：消息的类型。可以有以下几种类型：</span></span><br><span class="line">	msgtyp = <span class="number">0</span>：返回队列中的第一个消息。</span><br><span class="line">	msgtyp &gt; <span class="number">0</span>：返回队列中消息类型为 msgtyp 的消息（常用）。</span><br><span class="line">	msgtyp &lt; <span class="number">0</span>：返回队列中消息类型值小于或等于 msgtyp 绝对值的消息，如果这种消息有若干个，则取类型值最小的消息。</span><br><span class="line"><span class="comment">//msgflg：函数的控制属性。其取值如下：</span></span><br><span class="line">	<span class="number">0</span>：<span class="built_in">msgrcv</span>() 调用阻塞直到接收消息成功为止。</span><br><span class="line">	MSG_NOERROR: 若返回的消息字节数比 nbytes 字节数多,则消息就会截短到 nbytes 字节，且不通知消息发送进程。</span><br><span class="line">	IPC_NOWAIT: 调用进程会立即返回。若没有收到消息则立即返回 <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="built_in">msgrcv</span>( <span class="type">int</span> msqid, <span class="type">void</span> *msgp,  <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg );</span><br><span class="line"></span><br></pre></td></tr></table></figure> <strong><em>注意：在获取某类型消息的时候，若队列中有多条此类型的消息，则获取最先添加的消息，即先进先出原则。</em></strong></p>
<ul>
<li>成功：读取消息的长度</li>
<li>失败：-1</li>
</ul>
<h6 id="消息队列的控制">3.4.4 消息队列的控制</h6>
<p>对消息队列进行各种控制，如修改消息队列的属性，或删除消息消息队列。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">//msqid：消息队列的标识符。</span></span><br><span class="line"><span class="comment">//cmd：函数功能的控制。其取值如下：</span></span><br><span class="line">	IPC_RMID：删除由 msqid 指示的消息队列，将它从系统中删除并破坏相关数据结构。</span><br><span class="line">	IPC_STAT：将 msqid 相关的数据结构中各个元素的当前值存入到由 buf 指向的结构中。相对于，把消息队列的属性备份到 buf </span><br><span class="line">	IPC_SET：将 msqid 相关的数据结构中的元素设置为由 buf 指向的结构中的对应值。相当于，消息队列原来的属性值清空，再由 buf 来替换。</span><br><span class="line"><span class="comment">//buf：msqid_ds 数据类型的地址，用来存放或更改消息队列的属性。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure> <strong><em>注意：<code>struct msqid_ds</code>为消息队列的关联数据结构，具体内容其自行查询</em></strong></p>
<h6 id="消息队列在服务器-客户端的应用">3.4.5 消息队列在服务器-客户端的应用</h6>
<p>本节主要介绍System V消息队列的方式有很多种，这里介绍两种：</p>
<ul>
<li>在服务器和客户端之间使用单个消息队列进行双向的消息交换</li>
<li>服务器和各个客户端使用单独的消息队列，服务端上的队列用来接收进入客户端请求，相应的响应则通过各个客户端队列来发送给客户端</li>
</ul>
<p><strong>1. 服务器和客户端使用一个消息队列</strong> 这种情况是可以的，但是要注意一下几点：</p>
<ul>
<li><p><strong>由于多个进程可能会同时读取消息，因此必须使用消息类型字段来让各个进程只选择那些发送给自己的消息</strong>。如服务器向客户端响应时，发送的信息中以客户端进程的ID号作为消息类型，这样各个客户端能在消息队列中找到自己的消息；同理客户端向服务器发生请求时，将服务器的ID作为消息类型。</p></li>
<li>消息队列的容量是有限的，因此
<ul>
<li>问题一就是多个并行的客户端可能会填满消息队列，从而导致死锁发生，即所有客户端都无法提交请求，服务器在写入任何响应时都发生阻塞。（<strong>解决方法</strong>：使用两个队列，一个用于存放客户端发送给服务器的消息，另一个用于存放服务器发送给客户端的消息）</li>
<li>问题二就是不良或恶意的客户端只发送请求而不读取服务器响应，从而导致队列充满未被读取的消息。（<strong>解决方法</strong>：一个客户端使用一个的消息队列）</li>
</ul></li>
</ul>
<p><strong>2.一个客户端使用一个消息队列</strong> 一个客户端各自使用一个消息队列能够解决服务器和客户端使用一个消息队列所出现的问题，但是也需要注意：</p>
<ul>
<li>每个客户端要创建自己的消息队列并通知服务器队列的标识符。</li>
<li>系统对消息队列的数量是有限制的(MSGMNI)，如果客户端数量多，要提高该限制值。</li>
<li>服务器应该允许出现客户端的消息队列不再存在的情况</li>
</ul>
<h6 id="消息队列实现文件服务器应用程序一个客户端使用一个消息队列">3.4.6 消息队列实现文件服务器应用程序（一个客户端使用一个消息队列）</h6>
<ul>
<li>这是一个简单的文件服务器，首先客户端向服务器的消息队列发送一个请求，请求指定文件内容；然后服务器收到该请求后，将响应的文件内容作为一系列消息作为响应。</li>
<li>由于服务器对客户端不做任何鉴权操作，因此所有客户端都能获得服务器的文件内容 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/onetoone.png" width="500"></li>
</ul>
<p><strong>1.公共头文件</strong></p>
<ul>
<li>该文件是客户端和服务器都需要用到的头文件，这个头文件为服务器消息队列定义了一个众所周知的<code>SERVER_KEY</code>。并且定义了客户端和服务器之间传递消息的格式</li>
<li><code>requestMsg</code>结构定义了客户端发送给服务器的请求格式。<code>mtest</code>由两个字段构成，分别是客户端消息队列的标识符和客户端请求的文件的路径名。</li>
<li><code>responseMsg</code>结构定义了服务器返回给客户端的响应消息格式。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件名称svmg_file.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_KEY 0x1aaaaaa1	<span class="comment">//服务器消息队列标识符</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">requsetMsg</span>&#123;				<span class="comment">//客户端到服务器的请求格式</span></span><br><span class="line">	<span class="type">long</span> mtype;					<span class="comment">//未使用</span></span><br><span class="line">	<span class="type">int</span> clientID;				<span class="comment">//客户端消息队列的标识符</span></span><br><span class="line">	<span class="type">char</span> pathname[PATH_MAX];	<span class="comment">//请求的文件</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQ_MSG_SIZE (offsetof(struct requestMsg,pathname)-\</span></span><br><span class="line"><span class="meta">					offsetof(struct requestMSg,clientID)+PATH_MAX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESP_MSG_SIZE 8192</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">responseMsg</span>&#123;				<span class="comment">//服务启的响应格式</span></span><br><span class="line">	<span class="type">long</span> mtype;					<span class="comment">//三种类型</span></span><br><span class="line">	<span class="type">char</span> data[RESP_MSG_SIZE];	<span class="comment">//文件内容</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESP_MT_FAILURE 1  <span class="comment">//文件无法打开</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESP_MT_DATA 2     <span class="comment">//可发送</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESP_MT_END 3	   <span class="comment">//文件传输完成</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2.服务器程序</strong> - 服务器能够并发处理请求 - 每个客户端请求都会创建一个子进程来执行相应的响应 - 要避免僵尸进程，父进程应该有回收，即为SIGCHLD建立一个处理器并在其中调用<code>wait/waitpid</code> - 父服务器进程中的<code>msgrcv</code>调用可能会阻塞，这样就可能会被SIGCHLD处理器中断。为解决该情况，需要使用循环来完成EINTR错误发生之后的重启操作(用到了信号的知识) - 服务器子进程执行<code>serveRequest()</code>函数，该函数向客户端返回三种信息（头文件中的宏<code>RESP_MT_FAILURE</code>等）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;svmg_file.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">grimReaper</span><span class="params">(<span class="type">int</span> sig)</span>		<span class="comment">//SIGCHLD 处理器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> savedErrno;</span><br><span class="line">	savedError=errno</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">waitpid</span>(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG)&gt;<span class="number">0</span>)	</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	errno=savedErrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">serveRequest</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> requestMsg* req)</span><span class="comment">//消息发送</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">ssize_t</span> numRead;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">responseMsg</span> resp;</span><br><span class="line">	fd=<span class="built_in">open</span>(req-&gt;pathname,O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span>==fd)&#123;</span><br><span class="line">		resp.mtype=RESP_MT_FAILUER;</span><br><span class="line">		<span class="built_in">snprintf</span>(resp.data,<span class="built_in">sizeof</span>(resp.data),<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;Counldn&#x27;t open&quot;</span>);</span><br><span class="line">		msgsnd（req-&gt;clientID,&amp;resp,<span class="built_in">strlen</span>(resp.data)+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE)</span><br><span class="line">	&#125;</span><br><span class="line">	resp.mtype=RESP_MT_DATA;</span><br><span class="line">	<span class="keyword">while</span>((numRead=<span class="built_in">read</span>(fd,resp.data,RESP_MSG_SIZE))&gt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">msgsnd</span>(req-&gt;clientID,&amp;resp,numRead,<span class="number">0</span>)==<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	resp.mtype=RESP_MT_END;</span><br><span class="line">	<span class="built_in">msgsnd</span>(req-&gt;clientID,&amp;resp,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">requestMsg</span> req;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">ssize_t</span> msgLen;</span><br><span class="line">	<span class="type">int</span> serverId;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">	<span class="comment">//建立服务器消息队列</span></span><br><span class="line">	serverId=<span class="built_in">msgget</span>(SERVER_KEY,IPC_CREAT|IPC_EXCL|S_IRUSR|S_IWUSR|S_IWGRP);</span><br><span class="line">	<span class="keyword">if</span>(serverId==<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">errExit</span>(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">	<span class="comment">//使用信号建立SIGCHLD的处理器</span></span><br><span class="line">	<span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">	sa.sa_flags=SA_RESTART;</span><br><span class="line">	sa.sa_hanlder=grimReaper;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">sigaction</span>(SIGCHLD,&amp;sa,<span class="literal">NULL</span>)==<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">errExit</span>(<span class="string">&quot;sigcation&quot;</span>);</span><br><span class="line">	<span class="comment">//读取客户端请求，创建子进程取处理</span></span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		msgLen=<span class="built_in">msgrcv</span>(serverId,&amp;req,REQ_MSG_SIZE,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">-1</span>==msgLen)&#123;</span><br><span class="line">			<span class="keyword">if</span>(errno==EINTR)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">errMsg</span>(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pid=fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="built_in">errMsg</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">serveRequest</span>(&amp;req);</span><br><span class="line">			_exit(EXIT_SUCCESS);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="system消息队列的缺点">3.4.6 System消息队列的缺点</h6>
<p>消息队列一个最与众不同的特性就是能够为每个消息加上一个数字类型，这样读取进程就可以<strong>根据类型来选择消息，或者可以采用一种优先策略以便优先读取高优先级的消息</strong>。但，消息队列也有相应的缺点：</p>
<ul>
<li>消息队列通过标识符引用，而不像管道、FIFO、socket使用文件描述符，因此无法使用I/O多路复用技术。</li>
<li>消息队列是无连接的，内核不会像对待管道、FIFO、socket那样维护引用队列的进程数。</li>
<li>消息队列的总数、消息的大小以及单个队列的容量都是有限制的，虽然它们可配置，但需要做一些额外的工作取配置它们。</li>
</ul>
<p><strong>因此，一般避免使用System V消息队列，而使用POSIX消息队列，也应当考虑其他技术替代（如文件描述符类的）</strong></p>
<p><strong><em>system v共享内存和信号量略（着重介绍POSIX系列）</em></strong></p>
<h5 id="system-v共享内存">3.5 System V共享内存</h5>
<p><strong>共享内存允许两个或多个进程共享物理内存的同一块区域(通常称为段)，由于一个共享内存段会成为一个进程用户空间内存的一部分，因此这种IPC无需内核介入</strong>，因此它有一下两点要注意：</p>
<ul>
<li><p>共享内存是进程间共享数据的一种最快的方法。 一个进程向共享的内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。</p></li>
<li><p>不使用内核控制意味着使用共享内存时要注意的是多个进程之间对一个给定存储区访问的互斥。若一个进程正在向共享内存区写数据，则在它做完这一步操作前，别的进程不应当去读、写这些数据。</p></li>
</ul>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/sharedmemory.png" width="300"></p>
<h6 id="共享内存段">3.5.1 共享内存段</h6>
<p><strong>使用System V共享内存的步骤：</strong></p>
<ul>
<li><strong>调用<code>shmget()</code>创建一个新的共享内存段或取得一个既有共享内存段的标识符。</strong></li>
<li>使用<code>shmat()</code>来附上贡献内存段，即使该段成为调用进程的虚拟内存的一部分</li>
<li><strong>此刻在程序中就可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存段，程序需要使用由<code>shmat()</code>调用返回的地址值<code>addr</code>，它是一个指向进程虚拟地址空间该共享内存段的起点指针</strong></li>
<li>调用<code>shmdt()</code>来分离共享内存段，之后进程无法引用这块共享内存</li>
<li>调用<code>shmctl()</code>来销毁共享内存段</li>
</ul>
<p>一般来说，其内存布局如下图所示，<strong>共享内存段被附加在向上增长的堆和向下增长的栈之间的未被分配的空间中</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/location.png" width="500"></p>
<h5 id="poxis的消息队列">3.6 POXIS的消息队列</h5>
<p>POSIX消息队列与System消息队列的相似之处在于数据的交换单位都是整体消息。不同点是：</p>
<ul>
<li><p><strong>POSIX消息队列使用引用计数，所有使用该队列的进程关闭后队列就删除，而System消息队列则不确定</strong>。</p></li>
<li><p><strong>POSIX消息队列使用文件描述符，因此可使用epoll等技术</strong></p></li>
<li><p><strong>POSIX队列提供了一个<code>mq_notify()</code>函数允许队列中的一条消息可用时异步地通知进程</strong></p></li>
<li><p><strong>System消息队列使用一个整数来标识优先级，而POSIX消息队列有一个关联的优先级，并且消息之间是严格按照优先级顺序排列的，灵活性不如System消息队列</strong>。</p></li>
<li><p>POSIX的移植性不如System</p></li>
</ul>
<h6 id="接口概览">3.6.1 接口概览</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcnlt.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys.stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mqueue.h&gt;</span> <span class="comment">//消息队列头文件</span></span></span><br><span class="line"><span class="built_in">mq_open</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> oflag,...); <span class="comment">//创建一个新消息队列或打开已有队列，返回其文件描述符。</span></span><br><span class="line"><span class="built_in">mq_send</span>(<span class="type">mqd_t</span> mqdes,<span class="type">const</span> <span class="type">char</span>* msg_ptr,<span class="type">size_t</span> msg_len,<span class="type">unsigned</span> <span class="type">int</span> msg_prio);       <span class="comment">//向队列写入一条消息</span></span><br><span class="line"><span class="built_in">mq_receive</span>(<span class="type">mqd_t</span> mqdes,<span class="type">const</span> <span class="type">char</span>* msg_ptr,<span class="type">size_t</span> msg_len,<span class="type">unsigned</span> <span class="type">int</span> msg_prio)	<span class="comment">//从队列读取一条消息,会阻塞</span></span><br><span class="line"><span class="built_in">mq_close</span>(<span class="type">mqd_t</span> mqdes)	<span class="comment">//关闭该进程之前打开的一个对应消息队列</span></span><br><span class="line"><span class="built_in">mq_unlink</span>(<span class="type">const</span> <span class="type">char</span>* name)		<span class="comment">//删除一个消息队列名并当所有进程关闭该队列时对队列进行标记以便删除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mq_getattr</span>(<span class="type">mqd_t</span> mqdes,<span class="keyword">struct</span> mq_attr* attr)</span><br><span class="line"><span class="built_in">mq_setattr</span>(<span class="type">mqd_t</span> mqdes,<span class="keyword">struct</span> mq_attr* newattr,<span class="keyword">struct</span> mq_attr* oldattr)	<span class="comment">//每个消息队列都有一组关联特性，可通过这两个函数获取/设置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mq_notify</span>(<span class="type">mqd_t</span> mqdes,<span class="type">const</span> <span class="keyword">struct</span> sigevent* notification)    </span><br><span class="line"><span class="comment">//允许一个进程向一个队列注册接收消息通知。在注册之后，当一条消息可用时会通过发送一个信号或在一个单独的线程调用一个函数来通知进程。**</span></span><br></pre></td></tr></table></figure>
<h6 id="消息队列的特性">3.6.2 消息队列的特性</h6>
<p>该结构体也定义在<code>&lt;mqueue.h&gt;</code>中。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mq_attr</span>&#123;</span><br><span class="line">	<span class="type">long</span> mq_flags;		<span class="comment">//消息队列描述</span></span><br><span class="line">	<span class="type">long</span> mq_msgsize;	</span><br><span class="line">	<span class="comment">//maxmsg和msgsize在mq_open阶段设置，指示消息队列添加消息的上限和每条消息的大小上限，不可更改</span></span><br><span class="line">	<span class="type">long</span> mq_maxmsg;</span><br><span class="line">	<span class="type">long</span> mq_curmsgs;	<span class="comment">//当前状态的相关信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="消息通知">3.5.3 消息通知</h6>
<p><strong>允许一个进程向一个队列注册接收消息通知。在注册之后，当一条消息可用时会通过发送一个信号或在一个单独的线程调用一个函数来通知进程</strong>。这个特性意味着<strong><em>在接受消息时，该进程已经无需执行一个阻塞的<code>mq_receive()</code>调用，或者说该特性使得消息队列描述符能够标记为非阻塞并在队列上定期执行<code>mq_receive()</code>。</em></strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mq_notify</span>(<span class="type">mqd_t</span> mqdes,<span class="type">const</span> <span class="keyword">struct</span> sigevent* notification) </span><br></pre></td></tr></table></figure> notifcation参数指定了进程接收通知的机制。对应消息通知，其细节有：</p>
<ul>
<li><p>任何一个时刻，对于消息队列来说，有且只有一个进程（“注册进程”）能够注册接收通知，即同一时刻最多只有一个注册进程。</p></li>
<li><p>只有当一条新消息进入之前为空的队列时注册进程才会收到通知。</p></li>
<li><p><strong>当向注册进程发送一个通知后就会删除注册信息。因此，之后任一进程可公平竞争该消息队列的注册通知。话句话说，若一个进程想要持续的接收通知，那么它必须在每次接收通知后再次调用<code>mq_notify()</code>来注册自己</strong></p></li>
<li><p>其他进程（非注册进程）在消息队列调用<code>mq_receive()</code>而阻塞（说明此时消息是被注册进程读取），那么注册进程会读取消息，而且还会保持注册状态。</p></li>
<li><p>进程可将notifcation置为<code>NULL</code>来撤销注册信息</p></li>
</ul>
<h5 id="posix信号量">3.7 POSIX信号量</h5>
<p>信号量不做进程间数据的通信，<strong>而是允许进程或线程同步对共享资源的访问</strong>。对于POSIX信号量有两种类型：</p>
<ul>
<li><p><strong>命名信号量</strong>：拥有名字。<strong>通过使用相同的名字调用<code>sem_open()</code>,不相关进程能够访问同一个信号量</strong></p></li>
<li><strong>未命名信号量</strong>：没有名字。<strong>因此它位于内存中预先商定的位置处，未命名信号量可以在进程之间或一组线程之间共享</strong>。
<ul>
<li>当进程间共享时，必须位于一个共享区域（System V、POSIX或mmap())。</li>
<li>当线程之间共享时，信号量可以位于被这些线程共享的内存区域，如堆或全局变量中。</li>
</ul></li>
</ul>
<h6 id="命名信号量接口概览">3.7.1 命名信号量接口概览</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcnlt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys.stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="built_in">sem_open</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> oflag,...);	<span class="comment">//创建或打开一个信号量并返回一个文件描述符</span></span><br><span class="line"><span class="built_in">sem_post</span>(<span class="type">sem_t</span>* sem);		<span class="comment">//递增sem引用的信号量的值</span></span><br><span class="line"><span class="built_in">sem_wait</span>(<span class="type">sem_t</span>* sem);		<span class="comment">//递减sem引用的信号量的值</span></span><br><span class="line"><span class="built_in">sem_close</span>(<span class="type">sem_t</span>* sem);		<span class="comment">//删除调用进程与它之前打开的一个信号量的关联关系</span></span><br><span class="line"><span class="built_in">sem_getvalue</span>(<span class="type">sem_t</span>* sem,<span class="type">int</span>* sval);				<span class="comment">//获取信号量的当前值</span></span><br><span class="line"><span class="built_in">sem_unlink</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br></pre></td></tr></table></figure>
<h6 id="posix和system的信号量操作">3.7.2 POSIX和system的信号量操作</h6>
<p>与System V信号量一样，<strong>一个POSIX信号量也是一个整数且系统不会允许其值小于0</strong>。</p>
<ul>
<li>修改信号量值的函数是<code>sem_post()</code>和<code>sem_wait()</code>,一次只操作一个信号量。而形成对比的是，System V的<code>semop()</code>能够操作一个集合中的多个信号量</li>
<li><code>sem_post()</code>和<code>sem_wait()</code>只对信号量增1或减1；而形成对比的是，<code>semop()</code>能够加或减任一个数</li>
<li>system V信号量没有提供一个<code>wait for zero</code>的操作（即将sops.sem_op字段指定为0的semop()调用）</li>
</ul>
<h6 id="信号量操作之sem_wait">3.7.3 信号量操作之sem_wait()</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行<code>sem_wait</code>函数会递减sem引用的信号量的值。</li>
<li><strong>如果信号量值为0，则<code>sem_wait()</code>不会执行，阻塞直到信号量大于0。</strong></li>
<li><strong>当信号量大于0时，<code>sem_wait()</code>会立即返回，并且递减信号量操作。</strong></li>
<li>若一个阻塞的<code>sem_wait()</code>调用被一个信号处理器中断了，那么他会失败且返回EINTR错误</li>
</ul>
<p>该函数有两个变体，一个是<code>sem_trywait()</code>,另一个是<code>sem_timedwait()</code>:</p>
<ul>
<li><code>sem_trywait()</code>是非阻塞版本，如果递减操作无法立即执行，就会失败并返回EAGAIN错误</li>
<li><code>sem_timedwait()</code>调用若在规定时间内无法递减，则会失败并返回ETIMEDOUT错误</li>
</ul>
<h6 id="信号操作之sem_post">3.7.4 信号操作之sem_post()</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在<code>sem_post</code>调用之前信号量值为0，并且其他某个进程或线程正在因等待递减这个信号量而阻塞，则该进程会被唤醒，它的<code>sem_wait()</code>调用会继续往前执行来递减这个信号量</li>
</ul>
<h6 id="未命名信号量">3.7.5 未命名信号量</h6>
<p><strong>未命名信号量是类型<code>sem_t</code>并存储在应用程序分配的内存变量中。通过将这个信号量放在由几个进程或线程共享道的内存区域就能够使用</strong>。操作未命名信号量所使用的函数与命名信号量一样都是<code>sem_wait、sem_post、sem_getvalue</code>，只有两个不同：</p>
<ul>
<li><code>sem_init()</code>:对一个未命名信号量初始化并通知系统该信号量会在进程间共享还是单个进程中的线程共享</li>
<li><code>sem_destroy()</code>:销毁一个未命名信号量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">int</span> pshared,<span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pshared</code>指示这个信号量是在线程共享还是进程间共享
<ul>
<li>为0时，信号量会在调用进程的线程间共享。此时<code>sem</code>通常被指定为一个全局变量或分配到堆的一个地址</li>
<li>为非0时，即为进程间共享，此时<code>sem</code>必须是（System V、POSIX或mmap())共享区域</li>
</ul></li>
</ul>
<h5 id="内存映射">3.8 内存映射</h5>
<p><code>mmap()</code>系统调用在调用进程的虚拟地址空间创建一个新内存映射，映射分为两种：</p>
<ul>
<li><strong>文件映射：文件映射将一个文件的一部分直接映射到调用进程的虚拟内存中。</strong>一旦一个文件被映射之后就可以通过在相应的内存区域中操作字节来访问文件内容，此时映射的分页会在需要的时候从文件加载。</li>
<li><strong>匿名映射：匿名映射没有对应文件，因此这种映射的分页会被初始化为0</strong></li>
</ul>
<p>上面介绍中我们并没有看到进程间的通信作用，但是<strong>一个进程的映射中的内存可以与其他进程中的映射共享</strong>，此时就体现了进程间的通信作用：<strong>此时映射为共享模式时，多个进程共享相同分页时，每个进程都会看到其他进程对分页做出的改变。</strong></p>
<ul>
<li><strong>私有映射(<code>MAP_PRIVATE</code>):其变更不会影响到底层文件，因此映射内容上发送的变更对其他进程是不可见的。</strong></li>
<li><strong>共享映射(<code>MAP_SHARED</code>):其变更会影响到底层文件，因此映射内容上发送的变更对其他进程是可见的</strong>。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/map.png" width="500"></li>
</ul>
<p><strong><em>注意：共享文件映射可用于不同进程通信，而共享匿名映射只能用于具有关系的进程通信</em></strong></p>
<h6 id="原理详解共享文件为例">3.8.1 原理详解（共享文件为例）</h6>
<p><strong>当多个进程创建了同一个文件区域的共享映射时，它们会共享同样的内存物理分页。此时，对映射内容所做出的变更都会自动反应到文件上。</strong></p>
<p>此时，内存映射一个最大的优势就是<strong>可以简单通过访问内存中的映射内容就能实现文件I/O，依靠内核来确保对内存的变更会被传递到映射文件上</strong>。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/filemmap.png" width="500"> 内存映射I/O优势：</p>
<ul>
<li>正常的<code>read()</code>和<code>write()</code>需要两次I/O,一次时文件内核高速缓存区和之间，另一次是内核高速缓存区和用户空间缓冲区。而<code>mmap()</code>只需要一次，一旦将相应文件块映射进用户内存之后用户进程就能够使用它们，只进行一次I/O，节省了一次内核空间和用户空间的传输。</li>
<li>同样，mmap跨过了内核态这个中间状态，文件内容不用存储在内核态，只需存储在用户内存空间中，节省了空间。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/cross.png" width="500"></li>
</ul>
<h6 id="映射函数mmap">3.8.2 映射函数mmap()</h6>
<p><img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/mmap.png" width="600"></p>
<p><strong><em>注意：关于mmap函数的使用总结：</em></strong> - 1) 第一个参数写成<code>NULL</code> - 2) 第二个参数要映射的文件大小<code>&gt; 0</code> - 3) 第三个参数：<code>PROT_READ 、PROT_WRITE</code> - 4) 第四个参数：<code>MAP_SHARED</code> 或者 <code>MAP_PRIVATE</code> - 5) 第五个参数：打开的文件对应的文件描述符 - 6) 第六个参数：4k的整数倍，通常为0</p>
<h6 id="解除映射munmap">3.8.3 解除映射munmap</h6>
<p><code>munmap()</code>系统调用执行<code>mmap()</code>相反的操作，即从调用进程虚拟地址空间中删除一个映射 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">/*参数</span></span><br><span class="line"><span class="comment">addr：使用mmap函数创建的映射区首地址</span></span><br><span class="line"><span class="comment">length：映射区大小</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h6 id="举例以共享文件映射进行父子进程通信">3.8.4 举例：以共享文件映射进行父子进程通信</h6>
<p>文件映射的缺陷是，每次创建映射区一定要依赖一个文件才能实现。使用MAP_ANONYMOUS (或MAP_ANON)可实现无需文件就可进行通信的匿名映射。<code>int *p = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></p>
<ul>
<li><code>MAP_ANONYMOUS</code>和<code>MAP_ANON</code>这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcnlt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd=<span class="built_in">open</span>(<span class="string">&quot;trluper.txt&quot;</span>,O_RDWR);	</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">lseek</span>(fd,<span class="number">0</span>,SEEK_END);	<span class="comment">//文件大小</span></span><br><span class="line">	<span class="comment">//创建文件映射区</span></span><br><span class="line">	<span class="type">void</span>* ptr=<span class="built_in">mmap</span>(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//void *ptr=mmap(NULL,len,PROT_READ|PORT_WRITE,MAP_SHARED,-1,0);	//匿名映射区</span></span><br><span class="line">	<span class="keyword">if</span>(ptr==MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">clsoe</span>(fd);</span><br><span class="line">	<span class="comment">//创建子进程</span></span><br><span class="line">	<span class="type">pid_t</span> pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//读数据</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr,<span class="string">&quot;i am u father!!&quot;</span>);</span><br><span class="line">		<span class="comment">//回收子进程资源</span></span><br><span class="line">		<span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放内存映射区</span></span><br><span class="line">	<span class="type">int</span> ret=<span class="built_in">munmap</span>(ptr,len);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;munmap failed&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="信号">3.9 信号</h5>
<p><strong>信号是 Linux 进程间通信的最古老的方式。信号是软件中断。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断</strong>，转而处理某一个突发事件。信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。在Linux中1-31为常规信号；34-64为实时信号，用户可自定义，默认动作是终止进程。</p>
<p>信号的特点：</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特设条件才发送</li>
</ul>
<p>一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数。如下图所示：（这里的产生、注册、注销是指系统的内部机制中信号的完整周期，而不是单指信号函数产生） <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/signal.png" width="600"></p>
<p>Linux 可使用命令：<code>kill -l</code>（&quot;l&quot; 为字母），查看相应的信号编号。（详情查看文件资料）</p>
<h6 id="信号四要素及状态">3.9.1 信号四要素及状态</h6>
<p>每个信号必备4要素，分别是：编号、名称 、事件 、默认处理动作。可通过<code>man 7 signal</code>查看帮助文档获取</p>
<p>信号的状态：产生、未决状态（没有被处理）、递达状态（信号被处理了）。Linux内核的进程控制块PCB是一个结构体<code>task_struct</code>, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集。</strong></p>
<ul>
<li>阻塞信号集(信号屏蔽字)：将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(处理发生在解除屏蔽后)。（类似黑名单）</li>
<li>未决信号集：信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回为0。</li>
</ul>
<h6 id="信号相关函数">3.9.2 信号相关函数</h6>
<ul>
<li><p><strong>1.kill函数：信号产生函数</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/kill.png" width="600"> <strong><em>注:super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。用户只能向自己创建的进程发生信号。（父进程可向子进程发送信号，子进程也可向父进程发送信号） 例：</em></strong></p></li>
<li><p>raise函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="comment">//功能：给当前进程发送指定信号，等价于kill(getpid(),sig)</span></span><br><span class="line"><span class="comment">//参数：sig为信号编号</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>abort函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//功能：给自己发送异常终止信号6）SIGABRT，并产生core文件，等价于kill(getpid(),SIGABRT)</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>alarm函数 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/alarm.png" width="600"> 定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸……无论进程处于何种状态，alarm都计时。</p></li>
<li><p>setitimer函数 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/setitimer.png" width="600"> <strong>实例：setitimer默认动作是终止进程，所有要加信号捕捉signal函数，实现周期定时。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">itimerval</span> new_value;</span><br><span class="line">	<span class="comment">//触发周期</span></span><br><span class="line">	new_value.it_interval.tv_sec=<span class="number">1</span>;</span><br><span class="line">	new_value.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//第一次触发时间</span></span><br><span class="line">	new_value.it_value.tv_sec=<span class="number">2</span>;</span><br><span class="line">	new_value.it_value.tv.usec=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">signal</span>(SIGALRM,function);</span><br><span class="line">	<span class="built_in">setitimer</span>(ITIMER_REAL,&amp;new_value,<span class="literal">NULL</span>);<span class="comment">//定时器设置</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="信号集">3.9.3 信号集</h6>
<p>在PCB中有两个非常重要的信号集。<strong>一个为“阻塞信号集”，另一个为“未决信号集”</strong>。这两个信号集都是内核使用位图机制来实现的<strong>。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。 </strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/signalset.png" width="600"></p>
<p>信号集是一个能表示多个信号的数据类型<code>sigset_t set</code>，<code>set</code>即一个信号集。既然是一个集合，就需要对集合进行添加/删除等操作。<strong>信号集主要作用是方便我们操作<code>sigprocmask</code>和<code>sigpending</code>函数对阻塞信号集和未决信号集的添加删除信号管理</strong>。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/operateset.png" width="600"></p>
<ul>
<li><p><code>sigprocmask</code>函数:信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞。<strong>我们可以通过 sigprocmask() 修改当前的阻塞信号集中包含的信号（即设置要被阻塞的信号种类的添加、删除） </strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/sigprocmask.png" width="600"></p></li>
<li><p>sigpending函数：读取未决信号集（未决由内核管理，用户只要读权限，没有写权限） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigpending</span><span class="params">(sigset* set)</span></span>;</span><br><span class="line"><span class="comment">//功能：读取当前进程的未决信号集</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//自定义信号集</span></span><br><span class="line">	<span class="type">sigset_t</span> myset,old;</span><br><span class="line">	<span class="built_in">sigemptyset</span>(&amp;myset);	<span class="comment">//清空</span></span><br><span class="line">	<span class="comment">//添加阻塞信号</span></span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;myset,SIGINT);</span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;myset,SIGQUIT);</span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;myset,SIGKILL);</span><br><span class="line">	<span class="comment">//自定义信号集设置到内核中的阻塞信号集</span></span><br><span class="line">	<span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;myset,&amp;old);</span><br><span class="line">	<span class="type">sigset_t</span> pend; </span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//读未决信号集的状态</span></span><br><span class="line">		<span class="built_in">sigpending</span>(&amp;pend);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">sigismember</span>(&amp;pend,i))</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sigusmember</span>(&amp;pend,i)==<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		i++;</span><br><span class="line">		<span class="comment">//10s后解除阻塞</span></span><br><span class="line">		<span class="keyword">if</span>(i&gt;<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;old,<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="信号捕捉">3.9.4 信号捕捉</h6>
<p>如上所示，一些函数的默认动作不是我们想要，而要改变这些动作，就必须依靠信号捕捉来实现自定义信号处理函数。 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/signalhunter.png" width="600"> <strong><em>【注意】：SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。</em></strong></p>
<ul>
<li><p>signal函数（了解） <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/func_signal.png" width="600"></p></li>
<li>sigaction函数 <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/sigaction.png" width="600"> <strong><code>struct sigaction</code>结构体：</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/sigas.png" width="600">
<ul>
<li><ol type="1">
<li>sa_handler、sa_sigaction：信号处理函数指针，和 signal() 里的函数指针用法一样，应根据情况给sa_sigaction、sa_handler 两者之一赋值，其取值如下：</li>
</ol>
<ul>
<li><ol type="a">
<li>SIG_IGN：忽略该信号</li>
</ol></li>
<li><ol start="2" type="a">
<li>SIG_DFL：执行系统默认动作</li>
</ol></li>
<li><ol start="3" type="a">
<li>处理函数名：自定义信号处理函数</li>
</ol></li>
</ul></li>
<li><ol start="2" type="1">
<li>sa_mask：信号阻塞集，在信号处理函数执行过程中，临时屏蔽指定的信号。</li>
</ol></li>
<li><ol start="3" type="1">
<li>sa_flags：用于指定信号处理的行为，通常设置为0，表使用默认属性。它可以是一下值的“按位或”组合：</li>
</ol>
<ul>
<li>Ø SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。</li>
<li>Ø SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程（因为由init进程回收）。</li>
<li>Ø SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。</li>
<li>Ø SA_RESETHAND：信号处理之后重新设置为默认的处理方式。</li>
<li>Ø SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="进程组和守护进程">4 进程组和守护进程</h4>
<h5 id="进程组">4.1 进程组</h5>
<p>当父进程创建子进程的时候，默认子进程与父进程属于同一进程组。**进程组ID为第一个进程的ID(组长进程)。进程组的出现是为了方便管理多个进程： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kill <span class="number">-9</span> -进程组ID    <span class="comment">//杀死整个进程组内的进程全部杀死</span></span><br></pre></td></tr></table></figure></p>
<p><strong>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。一个进程可以为自己或子进程设置进程组ID。 </strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/gprocess.png" width="600"></p>
<h5 id="会话">4.2 会话</h5>
<p><strong>会话是一个或多个进程组的集合。一个会话可以有一个控制终端。这通常是终端设备或伪终端设备；</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/hui.png" width="600"></p>
<ul>
<li><strong>建立与控制终端连接的会话首进程被称为控制进程；</strong></li>
<li><strong>一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组；</strong></li>
<li><strong>如果一个会话有一个控制终端，则它有一个前台进程组，其它进程组为后台进程组</strong>；</li>
<li><strong>如果终端接口检测到断开连接，则将挂断信号发送至控制进程（会话首进程）。</strong> <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/huihua.png" width="600"></li>
</ul>
<p><strong>创建会话的注意事项：</strong></p>
<ul>
<li><ol type="1">
<li>调用进程不能是进程组组长，若调用进程是组长进程，则出错返回</li>
</ol></li>
<li><ol start="2" type="1">
<li>调用进程会成为一个新进程组的组长进程，同时该进程变成新会话首进程(session header)既控制进程</li>
</ol></li>
<li><ol start="3" type="1">
<li>需有root权限(ubuntu不需要)</li>
</ol></li>
<li><ol start="4" type="1">
<li><strong>新会话丢弃原有的控制终端，该会话没有控制终端（能成为守护进程的关键）</strong></li>
</ol></li>
<li><ol start="5" type="1">
<li>建立新会话时，先调用fork, 父进程终止，子进程调用setsid <img src="/2022/12/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/setsid.png" width="600"></li>
</ol></li>
</ul>
<h5 id="守护进程">4.3 守护进程</h5>
<p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。守护进程是个特殊的孤儿进程，<strong>这种进程脱离终端，以避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。Linux 的大多数服务器就是用守护进程实现的</strong></p>
<p><strong>守护进程的创建流程：</strong></p>
<ul>
<li><ol type="1">
<li>创建子进程，父进程退出(必须)：所有工作在子进程中进行形式上脱离了控制终端</li>
</ol></li>
<li><ol start="2" type="1">
<li>在子进程中创建新会话(必须)：<code>setsid()</code>函数，使子进程完全独立出来，脱离控制</li>
</ol></li>
<li><ol start="3" type="1">
<li>改变当前目录为根目录(不是必须)---&gt;chdir(char *path)函数，防止占用可卸载的文件系统</li>
</ol></li>
<li><ol start="4" type="1">
<li>重设文件权限掩码(不是必须)：umask()函数，防止继承的文件创建屏蔽字拒绝某些权限，增加守护进程灵活性</li>
</ol></li>
<li><ol start="5" type="1">
<li>关闭文件描述符(不是必须)：继承的打开文件不会用到，浪费系统资源，无法卸载</li>
</ol></li>
<li><ol start="6" type="1">
<li>开始执行守护进程核心工作(必须)：守护进程退出处理程序模型 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建子进程，父进程退出</span></span><br><span class="line">	<span class="type">pid_t</span> pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span>==pid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;父进程退\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">		<span class="comment">//在子进程创建会话，脱离终端</span></span><br><span class="line">		<span class="type">pid_t</span> hpid=<span class="built_in">setsid</span>();</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">-1</span>==hpid)&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;setsid\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//改变工作目录</span></span><br><span class="line">		<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">		<span class="comment">//改变权限掩码，0没有屏蔽任何权限</span></span><br><span class="line">		<span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//关闭文件描述符</span></span><br><span class="line">		<span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line">		<span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">		<span class="built_in">close</span>(STDERR_FILENO);</span><br><span class="line">		<span class="comment">//防止子进程退出，执行核心任务</span></span><br><span class="line">		<span class="built_in">task</span>();</span><br><span class="line">		<span class="comment">//每隔1s输出当前时间到temp/txt.log</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">system</span>(<span class="string">&quot;date&gt;&gt;/temp/txt.log&quot;</span>);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>Linux coding</category>
      </categories>
      <tags>
        <tag>Linux coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile</title>
    <url>/2022/07/18/Makefile/</url>
    <content><![CDATA[<h4 id="make">1. make</h4>
<h5 id="make是什么">1.1 make是什么</h5>
<p>make是一个命令，是管理文件的自动编译管理器，这里的自动是指能根据文件时间戳自动发现更新过的文件而减少编译的工作量，同时通过读取makefile的文件的内容来进行预期的编译工作，make将只编译有改动的文件，而不用完全编译。</p>
<span id="more"></span>
<h5 id="工作原理">1.2工作原理</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">app:main.o hello.o</span><br><span class="line">        gcc -o app main.o hello.o</span><br><span class="line">main.o:main.c hello.h</span><br><span class="line">        gcc -c main.c</span><br><span class="line">hello.o:hello.c hello.h</span><br><span class="line">        gcc -c hello.c</span><br><span class="line">clean:</span><br><span class="line">        rm app main.o hello.o</span><br></pre></td></tr></table></figure>
<ul>
<li><code>make</code>在当前目录寻找<code>Makefile</code>或<code>makefile</code>文件。</li>
<li>如果找到，它会找文件中的第一个目标文件<code>target</code>，如上例它找到<code>app</code>这个目标文件，把这个文件作为最终的目标文件。如果<code>app</code>文件不存在,或是<code>app</code>所依赖的后面的<code>.o</code>文件的文件修改时间要比<code>app</code>这个文件新，那么<code>make</code>命令就会执行后面所定义的命令来生成<code>app</code>这个文件。</li>
<li><strong>如果<code>app</code>所依赖的<code>.o</code>文件也不存在，那么<code>make</code>命令会在当前文件中寻找目标为<code>.o</code>文件的依赖关系。如果找到，则再根据那一个规则生成<code>.o</code>文件，根据<code>.o</code>文件依赖的<code>.c</code>文件和<code>.h</code>文件，执行规则生成<code>.o</code>文件。</strong></li>
<li><strong>然后make再用<code>.o</code>文件生成执行文件<code>app</code></strong></li>
</ul>
<p><strong>总而远之，<code>make</code>会依据依赖关系一层一层地去找文件的依赖关系,直到最终编译出第一个目标文件</strong>。在找寻的过程中,如果出现错误,如最后被依赖的文件找不到,那么 make 就会直接退出并报错。</p>
<p>但是像<code>clean</code>这种没有被第一个目标文件直接或间接关联,那么它后面所定义的命令将不会被自动执行。不过，可以显式指定<code>make</code>执行<code>clean</code>，即<code>make　clean</code>。<strong>同时只要修改了与第一个目标文件存在直接或间接依赖关系的文件，都会发生重新编译和重新链接</strong></p>
<h5 id="make命令">1.3 make命令</h5>
<p>make是一个命令工具，它解释Makefile 中的指令（应该说是规则） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">make [ -f file ][ options ][ targets ]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>-f file</code>:<code>make</code>默认在工作目录中寻找名为<code>GNUmakefile、makefile、Makefile</code>的文件作为<code>makefile</code>输入文件,但有时可能命名不是这些,则<code>-f</code>可以指定以上名字以外的文件作为makefile输入文件</p></li>
<li><code>options</code>
<ul>
<li><code>v：</code>显示make工具的版本信息</li>
<li><code>w：</code>在处理<code>makefile</code>之前和之后显示工作路径</li>
<li><code>C dir：</code>读取<code>makefile</code>之前改变工作路径至dir目录</li>
<li><code>n：</code>只打印要执行的命令但不执行</li>
<li><code>s：</code>执行但不显示执行的命令</li>
</ul></li>
<li><p><code>targets</code>:使用<code>make</code>命令时没有指定目标，则<code>make</code>工具默认会实现<code>makefile</code>文件内的第一个目标，如果指定了<code>make</code>工具要实现的目标则该目标为最终目标（目标可以是一个或多个）</p></li>
</ul>
<h4 id="makefile">2. Makefile</h4>
<p><code>Makefile</code>是一个脚本文件，其内部编写一些符和<code>make</code>工具解析的语法规则来进行执行一些命令。</p>
<h5 id="makefile是什么">2.1 Makefile是什么</h5>
<p><code>makefile</code>定义了一系列的规则来指定，<strong>哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译</strong>，甚至于进行更复杂的功能操作，因为<code>makefile</code>就像一个<code>Shell</code>脚本一样，其中也可以执行操作系统的命令。<code>Makefile</code>带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。<code>makefile</code>文件由<code>make</code>命令工具来执行。</p>
<p><strong>make主要解决两个问题：</strong></p>
<ul>
<li><strong>1) 大量代码的关系维护</strong>:大项目中源代码比较多，手工维护、编译时间长而且编译命令复杂，难以记忆及维护,把代码维护命令及编译命令写在<code>makefile</code>文件中，然后再用<code>make</code>工具解析此文件自动执行相应命令，可实现代码的合理编译</li>
<li><strong>2) 减少重复编译时间</strong>，在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有的目标文件，节省编译时间。</li>
</ul>
<p><code>Makefile</code>文件命名规则<code>makefile</code>和<code>Makefile</code>都可以，推荐使用<code>Makefile</code>,即<code>vim Makefile</code>。学号<code>Makefile</code>只需要学习他的<strong>一条规则，三个变量，两个函数</strong>就能上手了。</p>
<h5 id="一条规则">2.2 一条规则</h5>
<p><strong>一条规则</strong>即指完成单此任务所包含的要素，Makefile的一条规则三要素如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一条规则</span></span><br><span class="line">target... : prerequisites ...</span><br><span class="line">     command</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>target</code>:<strong>通常是要产生的文件名称，目标可以是可执行文件或其它obj文件，也可是一个标签</strong></li>
<li><code>prerequisites</code>：依赖文件，用来输入从而产生目标的文件，一个目标通常有几个依赖文件（也可以没有）。<code>prerequisites</code>中如果有一个以上的文件比<code>target</code>文件要新的话，<code>command</code>所定义的命令就会被执行。</li>
<li><code>command</code>：make执行的动作，一个规则可以含几个命令（可以没有）。有多个命令时，每个命令占一行。</li>
</ul>
<p><code>make</code>工具从上往下找寻<code>target</code>，<strong>根据<code>target</code>后对应的依赖关系，先去查找依赖项的文件,为索所有的目标文件创建依赖关系链</strong>。若依赖项不存在，则会报错： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make div.o</span><br><span class="line">make: *** No rule to make target <span class="string">&#x27;div.cpp&#x27;</span>, needed by <span class="string">&#x27;div.o&#x27;</span>.  Stop.</span><br></pre></td></tr></table></figure> 若存在，在检查依赖关系时，同时会检查目标与源文件的时间戳，当源文件时间戳更新时，make会更新依赖它的链路上所有文件，即调用command部分。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Makefile件</span></span><br><span class="line">sum.o:sum.cpp</span><br><span class="line">        g++ -c  sum.cpp -o sum.o</span><br><span class="line">main.o:main.cpp</span><br><span class="line">        g++ -c main.cpp -o main.o</span><br><span class="line">main:main.o sum.o</span><br><span class="line">        g++ main.o sum.o -o main</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make sum.o main.o main</span><br><span class="line">make: <span class="string">&#x27;sum.o&#x27;</span> is up to date.</span><br><span class="line">g++ -c main.cpp -o main.o</span><br><span class="line">g++ main.o sum.o -o main</span><br></pre></td></tr></table></figure></p>
<h5 id="变量">2.3 变量</h5>
<p>在<code>Makefile</code>中使用变量有点类似于C语言中的宏定义，使用该变量相当于内容替换，使用变量可以使<code>Makefile</code>易于维护,修改内容变得简单变量定义及使用。<strong>在<code>Makefile</code>中由自定义变量和自动变量</strong>。</p>
<h6 id="等号">2.3.1 等号</h6>
<p>在学习变量前需要熟悉Makefile中的等号，等号有4种<code>=，:=，?=，+=</code>。</p>
<ul>
<li><code>?=</code>表示，如果左边的变量没有被赋值，那么将等号右边的值赋给左边的变量。如果赋过值，则保持原来的值不变。</li>
<li><code>+=</code>表示将等号右边的值追加到左边变量中，但是中间会有一个空格。</li>
<li><code>=</code>与<code>:=</code>是比较不好区分的两个等号，可以将”=“理解为&quot;址传递&quot;或引用，”:=“理解为&quot;值传递”。</li>
</ul>
<p>在<code>Makefile</code>中是不允许将变量自己的值赋给自己的，也不允许出现循环引用。</p>
<h6 id="变量名的规则">2.3.2 变量名的规则</h6>
<p><strong><code>makefile</code>的变量名的起名规则：</strong></p>
<ul>
<li><code>makefile</code>变量名可以以数字开头</li>
<li>变量是大小写敏感的</li>
<li>变量一般都在<code>makefile</code>的头部定义</li>
<li>变量几乎可在<code>makefile</code>的任何地方使用</li>
</ul>
<h6 id="自定义变量">2.3.3 自定义变量</h6>
<ul>
<li>1）定义变量方法：<code>变量名=变量值</code>,<code>变量名？=变量值</code>,<code>变量名+=变量值</code>,<code>变量名:=变量值</code></li>
<li><ol start="2" type="1">
<li>使用变量名：<code>$(变量名)</code>或<code>$&#123;变量名&#125;</code></li>
</ol></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objs=add.o sum.o div.o mul.o</span><br><span class="line">target=main</span><br><span class="line">$(target):$(bgjs)</span><br><span class="line">		gcc &amp;(objs) -o $(target)</span><br></pre></td></tr></table></figure>
<h6 id="三个重要自动变量">2.3.4 三个重要自动变量</h6>
<p><code>Makefile</code>的自动变量有以下几个:</p>
<p><img src="/2022/07/18/Makefile/auto.png" width="700"></p>
<p><strong>其中重要常用的三个是：</strong></p>
<ul>
<li><code>$@:</code> 表示规则中的目标</li>
<li><code>$&lt;:</code>表示规则中依赖性的第一个</li>
<li><code>$^:</code> 表示规则中的所有依赖性, 组成一个列表, 以空格隔开,如果这个列表中有重复的项则消除重复项。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objs=add.o sum.o div.o mul.o</span><br><span class="line">target=main</span><br><span class="line">sum.o:sum.cpp</span><br><span class="line">        g++ -c  $^ -o $@</span><br><span class="line">main.o:main.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br><span class="line">$(target):$(bgjs)</span><br><span class="line">		g++ &amp;(objs) -o $(target)</span><br><span class="line">clean:</span><br><span class="line">		rm -rf $(objs) $(target)</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：自动变量只能在规则的命令中中使用</em></strong></p>
<h5 id="模式规则">2.4 模式规则</h5>
<p>如果想要进一步的偷懒，那就必须提到<strong>模式规则</strong>，模式规则用来匹配当前目录下的符合模式匹配的所有文件。模式规则类似于普通规则，<strong>只是在模式规则中，目标名中需要包含有模式字符<code>%</code>，包含有模式字符<code>%</code>的目标被用来匹配一个文件名，<code>%</code>可以匹配任何非空字符串</strong>。看到上面你觉得很绕，让我们看实例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#%表示可以匹配当前目录下的所有以.cpp为后缀的源文件，</span><br><span class="line">#并且对应生成相应名称的.o文件（注意是使用$&lt;才能生成对应.o文件</span><br><span class="line">%.o:%.cpp</span><br><span class="line">		g++ -c $&lt; -o $@</span><br></pre></td></tr></table></figure> 单独上面的这个<code>makefile</code>不能成功执行，会出现<code>No targets.Stop</code>错误 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接make，不成功</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make</span><br><span class="line">make: *** No targets.  Stop.</span><br><span class="line"><span class="comment">//传入目标，成功</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make main.o</span><br><span class="line">g++ -c main.cpp -o main.o</span><br></pre></td></tr></table></figure> 这是很正常的，因为<code>%</code>是模式匹配规则，你如果没传入目标它就无法执行<code>make</code>的工作机制。下面来讲解对<code>%</code>的解决办法</p>
<h5 id="函数">2.5 函数</h5>
<p><code>makefile</code>中的函数有很多，在这里给大家介绍两个最常用的:</p>
<ul>
<li><p><code>wildcard</code>查找指定目录下的指定类型的文件 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">src = $(wildcard *.c) <span class="comment">//找到当前目录下所有后缀为.c的文件,赋值给src</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>patsubst</code>匹配替换 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">obj = $(patsubst %.c,%.o, $(src)) <span class="comment">//把src变量里所有后缀为.c的文件替换成.o，然后赋值给obj</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong><em>注意</em></strong>：<code>patsubst</code>不是把src里的文件的后缀改为.o，是在<code>makefile.o</code>文件内部将生成的<code>.o</code>文件替换掉<code>src</code>内的<code>.cpp</code>文件，因此在<code>make</code>的时候一定是要先生成<code>.o</code>文件（这里从两者<code>*</code>和<code>%</code>就能看出)，从两者的特性能够得到以下的解决： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">all:$(patsubst %.cpp,%.o,$(wildcard *.cpp))</span><br><span class="line">%.o:%.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br></pre></td></tr></table></figure> 原理：all目标获得了目录内的<code>*.cpp</code>文件，使用<code>patsubst</code>要求将<code>*.cpp</code>替换为<code>*.o</code>,但是目录中还没有<code>*.o</code>文件，则会依据make工作原理进行到下一个目标，刚好这个目标是生成<code>.o</code>文件的，则执行。</p>
<h5 id="简单示例">2.6 简单示例</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">src=$(wildcard *.cpp)</span><br><span class="line">objs=$(patsubst %.cpp,%.o,$(src))</span><br><span class="line">target=main</span><br><span class="line">$(target):$(objs)</span><br><span class="line">        g++ $(objs) -o $(target)</span><br><span class="line">%.o:%.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">#PHONY伪目标，不去判断目标文件是否存在或者更新，无条件执行</span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">        rm -rf $(objs) $(target)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#执行make</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make</span><br><span class="line">g++ -c main.cpp -o main.o</span><br><span class="line">g++ -c sum.cpp -o sum.o</span><br><span class="line">g++ main.o sum.o -o main</span><br><span class="line">#执行makeclean</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher算法</title>
    <url>/2023/08/11/Manacher%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="什么是manacher算法马拉车算法">什么是Manacher算法(马拉车算法)</h2>
<p>Manachar算法主要是处理字符串中关于回文串的问题的，<strong>它本质上是对枚举中心法确定回文串的优化，使得算法可以在 <code>O（n）</code> 的时间处理出以字符串中每一个字符为中心的回文串半径。</strong></p>
<p>由于回文字符串以其长度来分，可以分为奇回文（其长度为奇数）、偶回文（其长度为偶数），一般情况下需要分两种情况来寻找回文，<strong>马拉车算法为了简化这一步，对原始字符串进行了处理，在每一个字符的左右两边都加上特殊字符（肯定不存在于原字符串中的字符），让字符串变成一个奇回文简化算法</strong></p>
<span id="more"></span>
<h2 id="暴力解法">暴力解法</h2>
<p>对于寻找最长回文串，我们能想到的就是枚举每一个子串，看这些子串是否为回文串，但这个时候算法的时间复杂度为<span class="math inline">\(O(N^3)\)</span>，是无法接受的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n=s.<span class="built_in">size</span>()</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">		<span class="type">int</span> l= i,r=j;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r&amp;&amp;s[l]==s[j])&#123;</span><br><span class="line">			++l;</span><br><span class="line">			--r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> len=j-i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&gt;=r) maxLen=len&gt;maxLen?len:maxLen;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="中心枚举法">中心枚举法</h2>
<p>枚举以每个元素为中心时，找到中心位置（可能是一个位置，也可能是两个位置）往左右两端进行扩展； 时间复杂度<span class="math inline">\(O(n^2)\)</span>;我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">expaned</span><span class="params">(string&amp; s,<span class="type">int</span> r,intl)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&gt;=<span class="number">0</span>&amp;&amp;r&lt;s.<span class="built_in">size</span>()&amp;&amp;s[i]==s[j])&#123;</span><br><span class="line">		++r;</span><br><span class="line">		--l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r-l+i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(sring&amp; s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">	<span class="type">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> len_1=<span class="built_in">expand</span>(s,i,i);</span><br><span class="line">		<span class="type">int</span> len_2=<span class="built_in">expand</span>(s,i,i+<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> len=<span class="built_in">max</span>(len_1,len_2);</span><br><span class="line">		<span class="keyword">if</span>(len&gt;end-start)&#123;</span><br><span class="line">			start=i-((len<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">			end=i+(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">substr</span>(start,end-start+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="动态规划">动态规划</h2>
<p>回文串问题同样能使用动态规划问题解决，其主要思想也是从中心枚举法得出，但是能够省略较多的重复比较，但是为了维护二维<code>dp</code>数组也要加入其<code>O(n)</code>的复杂度，因此总的时间复杂度为<span class="math inline">\(O(N^2)\)</span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]:表示s[i]是否等于s[j],相等且回文则置为true，否则为false</span></span><br><span class="line">    <span class="comment">//初始条件：dp[i][i]=true;</span></span><br><span class="line">    <span class="comment">//状态转移方程：</span></span><br><span class="line">	<span class="comment">//①若i和j是相邻的即i+1=j且s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//②若不相邻，则判断内侧是否为true，若dp[i+1][j-1]=true&amp;&amp;s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//通过增加两变量记录当前回文串的最长长度Maxlen,初始为1,以及记录回文串的下标开始index_min，初始为最后一个元素</span></span><br><span class="line">    <span class="comment">//算法的时间复杂度为O(n*n)</span></span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>||len==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(len,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> Maxlen=<span class="number">1</span>,index_min=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])<span class="comment">//如果两元素相等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i+<span class="number">1</span>)<span class="comment">//如果相邻</span></span><br><span class="line">                    dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//不相邻，判断两元素内部是否为回文串</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;Maxlen&lt;j-i+<span class="number">1</span>)<span class="comment">//更新Maxlen和index_min</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Maxlen=j-i+<span class="number">1</span>;</span><br><span class="line">                    index_min=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ret=s.<span class="built_in">substr</span>(index_min,Maxlen);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="manacher算法">Manacher算法</h2>
<p>Manacher算法的思路有点像dp，但比dp高明的多，它利用一个一维辅助数组<code>L[i]</code>，来求得以<code>s[i]</code>为对称中心的回文串长度。<strong><code>L[i]</code>的含义是表述以<code>s[i]</code>为对称中心的最长回串的最右边到<code>s[i]</code>的距离</strong>。如<code>aabab</code>，经过预处理后变成<code>#a#a#b#a#b#</code>,那么可得如下的<strong>L数组</strong>：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">%</td>
<td style="text-align: center;">#</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">#</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">#</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">#</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">#</td>
<td style="text-align: center;">b</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p><strong>我们发现：当<code>L[i]</code>就是以<code>s[i]</code>为对称中心的最长回文子串。</strong></p>
<blockquote>
<p><strong>证明：</strong>首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那 么对于以T[i]为中心的最长回文字串，其长度就为2*Len[i]-1,经过观察可知，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多 1，也就是有Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为<code>Len[i]-1</code>。这里我们对内部的数组预先-1，那么回文串长度就是<code>L[i]</code></p>
</blockquote>
<h3 id="构造li">构造L[i]</h3>
<p>Manacher最重要的思想上面已经提到，利用<code>L[i]</code>能够的推出回文串，<strong>那么最重要的如何去快速的构造<code>L[i]</code>，最好以<span class="math inline">\(O(n)\)</span>的方式。</strong></p>
<p>为了降低复杂度，Manacher利用前面已经求好的L[0:i-1].同时维护两个值<code>r</code>和<code>k</code>来求出下一个L[i]，这也是为啥说Manacher也有dp的味道。因此最重要的三个元素：</p>
<ul>
<li>假定要求位置<span class="math inline">\(i\)</span>，那么i之前的记录已经求出并存储在L中</li>
<li><strong>还有维护两个遍历<code>r</code>和<code>k</code></strong>。其中r表示，i之前所有位置求出来到右端点的最大值（即L数组的最大值对应的下标），k表示r最大时所在的位置</li>
</ul>
<p><strong>有了这些前提条件后，可以分为以下情况讨论</strong>：</p>
<ul>
<li><p><strong><span class="math inline">\(i&lt;r\)</span></strong>时，<strong>说明目前所求<span class="math inline">\(L[i]\)</span>在以<span class="math inline">\(s[k]\)</span>为对称中心的回文串内，我们就可以利用已有记录去求<span class="math inline">\(L[i]\)</span>。找到<code>i</code>关于<code>k</code>的对称点<span class="math inline">\(j=k-(i-k)=2k-i\)</span></strong>。比较<span class="math inline">\(L[j]\)</span>与<span class="math inline">\(r-i\)</span>的关系</p>
<ul>
<li><span class="math inline">\(L[j]&lt;r-i\)</span>：说明<span class="math inline">\(L[j]\)</span>的回文串在<span class="math inline">\(L[k]\)</span>内，由对称性推导就可以知道<span class="math inline">\(L[i]=L[j]\)</span>。如下图： <img src="/2023/08/11/Manacher%E7%AE%97%E6%B3%95/情况1.png" wdith="400"></li>
<li><span class="math inline">\(L[j]&gt;=r-i\)</span>：说明<span class="math inline">\(L[j]\)</span>的一部分回文串在<span class="math inline">\(L[k]\)</span>内，但超出的部分无法知道，需要一一暴力匹配，如下图： <img src="/2023/08/11/Manacher%E7%AE%97%E6%B3%95/情况2.png" wdith="400"></li>
</ul></li>
<li><p><strong><span class="math inline">\(i&gt;=r\)</span></strong>时，<strong>说明目前所求<span class="math inline">\(L[i]\)</span>不在以<span class="math inline">\(s[k]\)</span>为对称中心的回文串内，因此需暴力匹配</strong></p></li>
</ul>
<p><strong>注意：记得在这个过程中更新k,r的值。</strong></p>
<p>一些技巧：可以在字符串首尾放置两个&quot;哨兵&quot;，它们和其他字符串均不同，这样暴力更新时不用考虑边界问题，如用<code>%</code>和<code>@</code>取代<code>#</code></p>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">	string str=<span class="string">&quot;@&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">		str+=<span class="string">&quot;#&quot;</span>+s.<span class="built_in">substr</span>(i,<span class="number">1</span>);</span><br><span class="line">	str+=<span class="string">&quot;#%&quot;</span>;</span><br><span class="line">	n=str.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> r=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//构造L</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;r) L[i]=<span class="built_in">min</span>(L[(k*<span class="number">2</span>)-i],r-i);</span><br><span class="line">		<span class="keyword">else</span> L[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//执行暴力匹配</span></span><br><span class="line">		<span class="keyword">while</span>(str[i-L[i]<span class="number">-1</span>]==str[i+L[i]+<span class="number">1</span>]) ++L[i];</span><br><span class="line">		<span class="comment">//更新k,r</span></span><br><span class="line">		<span class="type">int</span> R=L[i]+i;</span><br><span class="line">		<span class="keyword">if</span>(R&gt;r)&#123;</span><br><span class="line">			r=R,k=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//找最长回文串</span></span><br><span class="line">	<span class="type">int</span> Max=<span class="number">0</span>,idx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(L[i]&gt;Max)&#123;</span><br><span class="line">			Max=L[i];</span><br><span class="line">			idx=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> start=(idx-Max)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">substr</span>(start,Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Msys2</title>
    <url>/2023/03/10/Msys2/</url>
    <content><![CDATA[<h3 id="msys2是什么">msys2是什么</h3>
<ul>
<li><p>Cygwin是运行于Windows平台的POSIX“子系统”，提供Windows下的类Unix环境，并提供将部分 Linux 应用“移植”到Windows平台的开发环境的一套软件。按照我经常开玩笑的话来讲，Cygwin 基本上就是传说中的 GNU/NT 系统（对照 GNU/Linux，GNU/BSD，GNU/HURD）。</p></li>
<li><p>MinGW，Minimalist GNU for Windows，用于开发原生（32位） Windows 应用的开发环境。它主要提供了针对 win32 应用的 GCC、GNU binutils 等工具，以及对等于 Windows SDK（的子集）的头文件和用于 MinGW 版本 linker 的库文件（so、a等，而不是 VC 的 lib）</p></li>
<li><p>MSYS2 （Minimal SYStem 2） 是一个MSYS的独立改写版本，主要用于 shell 命令行开发环境。同时它也是一个在Cygwin （POSIX 兼容性层） 和 MinGW-w64（从&quot;MinGW-生成&quot;）基础上产生的，追求更好的互操作性的 Windows 软件；</p>
<p>MSYS2 是MSYS的一个升级版,是集成了pacman和Mingw-w64的Cygwin升级版, 提供了bash shell等linux环境、版本控制软件（git/hg）和MinGW-w64 工具链。与MSYS最大的区别是移植了 Arch Linux的软件包管理系统 Pacman(其实是与Cygwin的区别)。就是说MSYS2是Cygwin的升级版本</p>
<p>它的一个优点就在于利用<code>pacman</code>包管理器，msys2可以使用<code>pacman</code>来安装软件包，我们可以比较轻松的使用Linux包管理器的方式来安装一整套可以在Windows上运行的Linux工具。<strong>显而易见，你可以在Msys shell执行Linux相关命令</strong></p></li>
</ul>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//万能命令</span></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH UCRT64 ~</span><br><span class="line">$ pacman -S --help</span><br><span class="line">usage:  pacman &#123;-S --sync&#125; [options] [<span class="built_in">package</span>(s)]</span><br><span class="line">options:</span><br><span class="line">  -b, --dbpath &lt;path&gt;  set an alternate database location</span><br><span class="line">  -c, --<span class="function">clean          remove old packages from cache <span class="title">directory</span> <span class="params">(-cc <span class="keyword">for</span> all)</span></span></span><br><span class="line"><span class="function">  -d, --nodeps         skip dependency version <span class="title">checks</span> <span class="params">(-dd to skip all checks)</span></span></span><br><span class="line"><span class="function">  -g, --groups         view all members of a package <span class="title">group</span></span></span><br><span class="line"><span class="function">                       <span class="params">(-gg to view all groups <span class="keyword">and</span> members)</span></span></span><br><span class="line"><span class="function">  -i, --info           view package <span class="title">information</span> <span class="params">(-ii <span class="keyword">for</span> extended information)</span></span></span><br><span class="line"><span class="function">  -l, --list &lt;repo&gt;    view a list of packages in a repo</span></span><br><span class="line"><span class="function">  -p, --print          print the targets instead of performing the operation</span></span><br><span class="line"><span class="function">  -q, --quiet          show less information <span class="keyword">for</span> query <span class="keyword">and</span> search</span></span><br><span class="line"><span class="function">  -r, --root &lt;path&gt;    set an alternate installation root</span></span><br><span class="line"><span class="function">  -s, --search &lt;regex&gt; search remote repositories <span class="keyword">for</span> matching strings</span></span><br><span class="line"><span class="function">  -u, --sysupgrade     upgrade installed <span class="title">packages</span> <span class="params">(-uu enables downgrades)</span></span></span><br><span class="line"><span class="function">  -v, --verbose        be verbose</span></span><br><span class="line"><span class="function">  -w, --downloadonly   download packages but <span class="keyword">do</span> <span class="keyword">not</span> install/upgrade anything</span></span><br><span class="line"><span class="function">  -y, --refresh        download fresh package databases from the <span class="title">server</span></span></span><br><span class="line"><span class="function">                       <span class="params">(-yy to force a refresh even <span class="keyword">if</span> up to date)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>重点：任何 Linux 的软件都可以用 --help 找到一些关键的使用资料，而且大多数的 --help 是支持子文档查询，例如上面加了 -S， 只看这个 -S 的相关文档</p>
</blockquote>
<h3 id="命令">命令</h3>
<p>安装完成后，有对应的各个<code>Msys *</code>应用程序，这是指定相应的的<code>shell</code>，比如你运行<code>Msys mingw64</code>版本是安装gcc++，那么它们会被安装在<code>msys\mingw64</code>，刚开始只要目录，下载就有文件了： <img src="/2023/03/10/Msys2/file.png" width="600"></p>
<ul>
<li>1，mingw32，MinGW 的32位环境的软件</li>
<li>2，mingw64，MinGW的64位环境的软件</li>
<li>3，ucrt64，微软的通用运行时环境，u 代表 universe（通用）。</li>
<li>4，clang32，clang 32位环境，clang 是一个编译器。</li>
<li>5，clang64，clang 64位环境</li>
<li>6，clangarm64，arm架构的CPU 的 clang 环境。</li>
<li>7，msys</li>
</ul>
<p>你可以把上面的 7个 东西都理解成一个 子系统。mingw32 跟 mingw64 是比较常用的子系统。</p>
<blockquote>
<p>其中<code>Msys2 MSYS</code>版本我们不做任何安装操作，一般只为同步更新软件库使用 #### 同步更新软件库 使用pacman -Syu同步更新软件库 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pacman -Sys</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="搜索想要的软件包">搜索想要的软件包</h4>
<p><code>pacman -Ss *</code>查询云端仓库是否有某个软件，他会返回一些了该软件不同版本列表,<code>*</code>可为正则表达式字符串，指一个软件包名称。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pacman -Ss *</span><br><span class="line">如</span><br><span class="line">pacman -Ss gcc</span><br><span class="line">pacman -Ss gdb</span><br></pre></td></tr></table></figure></p>
<h4 id="查看云端软件的具体信息">查看云端软件的具体信息</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pacman -Si mingw-w64-x86_64-*</span><br><span class="line">如</span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~</span><br><span class="line">$ pacman -Si mingw-w64-x86_64-gcc</span><br></pre></td></tr></table></figure>
<h4 id="查询一个软件是否安装">查询一个软件是否安装</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pacman -Qs mingw-w64-x86_64-*</span><br></pre></td></tr></table></figure>
<h4 id="查询本地已安装软件的具体信息">查询本地已安装软件的具体信息</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pacman -Qi mingw-w64-x86_64-*</span><br></pre></td></tr></table></figure>
<h4 id="查询本地已安装软件包所包含文件的列表">查询本地已安装软件包所包含文件的列表</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pacman -Ql mingw-w64-x86_64-*</span><br></pre></td></tr></table></figure>
<h4 id="删除一个软件">删除一个软件</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pacman -R mingw-w64-x86_64-*</span><br></pre></td></tr></table></figure>
<h4 id="安装gcc">安装gcc</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装64位</span></span><br><span class="line">pacman -S mingw-w64-x86_64-gcc</span><br></pre></td></tr></table></figure>
<h4 id="安装gdb">安装gdb</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pacman -S mingw-w64-x86_64-gdb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>packman 安装一个软件的过程就是下载 已经编译好的 静态库，动态库或者 exe，跟一些配置相关的文件，放在指定的位置。</p>
</blockquote>
<h4 id="查缺失的文件">查缺失的文件</h4>
<p>pacman 还有一个 命令比较常用，就是支持查找当前软件包缺失的文件。比如不小心删除了SDL 的 SDL2.dll 文件，怎么知道哪个文件不见了，可以用以下命令。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pacman -Qk mingw-w64-x86_64-SDL2</span><br></pre></td></tr></table></figure></p>
<p>pacman 通常会自动帮我们处理软件的依赖，但如果想看一下 软件的依赖，可以使用以下命令。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pactree mingw-w64-x86_64-SDL2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>文章来源： <a href="https://juejin.cn/post/7108972340410581023">msys2包管理介绍</a> <a href="https://blog.csdn.net/bcbobo21cn/article/details/129096275">初步使用msys2</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Msys2</category>
      </categories>
      <tags>
        <tag>Msys2</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/06/10/Redis/</url>
    <content><![CDATA[<h2 id="准备工作">准备工作</h2>
<h3 id="安装redis">安装Redis</h3>
<ol type="1">
<li>在ubuntu安装Redis <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure></li>
<li>Redis服务器连接默认没有密码，可通过更改<code>/etc/redis/redis.conf</code>内的<code># requirepass foobared</code>来指定登录密码,比如去掉注释后更改密码为<code>requirepass 123456</code>，指定了密码为<code>123456</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/redis/redis.conf</span><br><span class="line">#修改密码</span><br><span class="line">requirepass <span class="number">123456</span></span><br></pre></td></tr></table></figure></li>
<li>运行远程连接redis，redis默认只允许本地连接，你可以通过注释掉<code>bind 127.0.0.1::1</code>来支持远程登录。</li>
</ol>
<span id="more"></span>
<h3 id="redis服务器启动关闭和重启">Redis服务器启动、关闭和重启</h3>
<p><strong>每次启动虚拟机，Redis服务器和MySQL服务器都不会启动，因此你需要手动启动</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#Redis</span><br><span class="line">/etc/init.d/redis-server start</span><br><span class="line">/etc/init.d/redis-server stop</span><br><span class="line">/etc/init.d/redis-server restart</span><br><span class="line">#Mysql</span><br><span class="line">service mysql start</span><br><span class="line">service mysql stop</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure></p>
<h3 id="进入数据库">进入数据库</h3>
<p>进入数据库说白了就是通过客户端进入，无论时Mysql还是Redis下载server时都会自带本地的客户端 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">#由于更改了密码登录，因此需要先密码认证</span><br><span class="line">auth <span class="number">123456</span></span><br><span class="line"><span class="meta">#ping测试是否连接，ping后会返回pong</span></span><br><span class="line">ping</span><br></pre></td></tr></table></figure></p>
<h3 id="配置数据库">配置数据库</h3>
<p><strong>当然，上面的密码配置和远程连接也可以在你进入数据库后配置,当然前提时你知道redis的语法</strong>。Redis 的配置文件位于 Redis 安装目录下，文件名为 <code>/etc/redis/redis.conf</code>。你可以通过<code>CONFIG</code>命令查看或设置配置项。</p>
<ol type="1">
<li><code>CONFIG get *</code>获取当前的配置 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CONFIG get *</span><br></pre></td></tr></table></figure></li>
<li><code>CONFIG set</code>命令来修改配置 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CONFIG set requirepass <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>其各配置含义见<a href="https://www.runoob.com/redis/redis-conf.html">Redis菜鸟教程</a></p>
<h2 id="redis的特点">Redis的特点</h2>
<p>Redis是一个键值（key-value）存储系统，即键值对非关系型数据库。Redis作为一个高性能的键值数据库，不仅在很大程度上弥补了memcached这类键值存储的不足，而且在部分场合下可以对关系数据库如Mysql起到很好的补充作用。Redis提供了Python、Ruby、Erlang、PHP客户端，使用很方便。</p>
<p>Redis支持存储的值（value）类型包<strong>括string(字符串)、list(链表)、set(集合)和zset(有序集合)</strong>。这些数据类型都支持<code>push/pop、add/remove</code>以及<code>取交集、并集和差集</code>等丰富的操作，而且这些操作都是<strong>原子性的</strong>。在此基础上，Redis支持<strong>各种不同方式的排序</strong>。与memcached一样，<strong>为了保证效率，Redis中的数据都是缓存在内存中的，它会周期性地把更新的数据写入磁盘，或者把修改操作写入追加的记录文件；此外，Redis还实现了主从（master-slave）同步</strong></p>
<h3 id="redis-与其他-key---value-缓存产品有以下三个特点">Redis 与其他 key - value 缓存产品有以下三个特点</h3>
<ul>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</strong></li>
<li><strong>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</strong></li>
<li><strong>Redis支持数据的备份，即master-slave模式的数据备份。</strong></li>
</ul>
<h3 id="redis-优势">Redis 优势</h3>
<ul>
<li>性能极高 。Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li><strong>丰富的数据类型</strong>。 Redis支持二进制案例的 <code>Strings, Lists, Hashes, Sets 及 Ordered Sets</code>数据类型操作。</li>
<li><strong>操作的原子性。 Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</strong></li>
<li><strong>丰富的特性。Redis还支持 publish/subscribe, 通知, key 过期等等特性</strong></li>
</ul>
<h3 id="redis与其他key-value存储有什么不同">Redis与其他key-value存储有什么不同？</h3>
<ul>
<li><p><strong>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径</strong>。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p></li>
<li><p><strong>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存</strong>。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p></li>
</ul>
<h2 id="redis的数据结构">Redis的数据结构</h2>
<p>Redis的低层数据结构：简单动态字符串、双向链表、字典、跳跃表、压缩列表等</p>
<h3 id="简单动态字符串">简单动态字符串</h3>
<p>Redis不是直接使用C语言传统的字符串表示，而是构建了一种名为<strong>简单动态字符串</strong>。说白了就是一结构体，里面提供<code>char[]、len、free</code>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sdshdr</span>&#123;</span><br><span class="line">	<span class="comment">//记录buf数组中已经使用的字节数量</span></span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="comment">//记录buf数组中未使用的字节数量</span></span><br><span class="line">	<span class="type">int</span> free;</span><br><span class="line">	<span class="comment">//字节数组，保存字符串</span></span><br><span class="line">	<span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 依据上面的结构，SDS与C的字符数组相比，有： <img src="/2023/06/10/Redis/sds.png" width="700"> 因为SDS即使读取到空字符也能通过<code>len</code>识别是不是读到字符串末尾，因此时二进制安全的。对Redis来说，字符串：</p>
<ul>
<li><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p></li>
<li><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p></li>
<li><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p></li>
</ul>
<p>举例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SET trluper <span class="string">&quot;加油努力&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="链表">链表</h3>
<p><strong>当有一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的额字符串时，Redis就会使用链表作为列表建的底层实现</strong>。</p>
<p><strong>节点层结构：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">listNode</span> &#123;</span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *prev;</span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *next;</span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure></p>
<p><strong>list底层结构</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">list</span> &#123;</span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值是放过函数</span></span><br><span class="line">    <span class="built_in">void</span> (*free)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="type">int</span>（*match）(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure> <strong>特性</strong></p>
<ul>
<li>链表被广泛用于实现Redis的各种功能，比如列表建、发布与订阅、慢查询、监视器等。</li>
<li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li>
<li>每个链表使用一个list结构表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li>
<li>因为链表表头的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值</li>
</ul>
<h3 id="字典">字典</h3>
<p>Redis hash 是一个<code>string</code>类型的 <code>field（字段）</code> 和 <code>value（值）</code> 的映射表，hash 特别适合用于存储对象。Redis 中每个 hash 可以存储$ 2^{32} - 1 $键值对（40多亿）。</p>
<p><strong>Redis的字典使用哈希表作为低层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典的一个键值对。</strong></p>
<p><strong>字典结构</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dict</span>&#123;</span><br><span class="line">	<span class="comment">//类型特定函数</span></span><br><span class="line">	dictType *type;</span><br><span class="line">	<span class="comment">//私有数据</span></span><br><span class="line">	<span class="type">void</span>* privdata;</span><br><span class="line">	<span class="comment">//哈希表</span></span><br><span class="line">	dictht ht[<span class="number">2</span>];</span><br><span class="line">	<span class="comment">//rehash索引</span></span><br><span class="line">	<span class="comment">//当rehash不能存在时，值为-1</span></span><br><span class="line">	<span class="type">int</span> trehashidx;</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure></p>
<p><strong>哈希表结构</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictht</span>&#123;</span><br><span class="line">	<span class="comment">//哈希表数组</span></span><br><span class="line">	dictEntry **table;</span><br><span class="line">	<span class="comment">//哈希表大小</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">	<span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">	usigned <span class="type">long</span> sizemask;</span><br><span class="line">	<span class="comment">//该哈希表已有节点数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure></p>
<p><strong>哈希节点结构</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictEntry</span>&#123;</span><br><span class="line">	<span class="comment">//键</span></span><br><span class="line">	<span class="type">void</span>* key;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="type">void</span>* value;</span><br><span class="line">		uint64_ tu64;</span><br><span class="line">		int64_ ts64;</span><br><span class="line">	&#125;v;</span><br><span class="line">	<span class="comment">//指向下一个哈希表节点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dictEntry</span> *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure> 通过上面的两个结构定义就可以知道，字典以哈希表作为低层实现，首先通过传入的<code>key</code>值通过哈希计算，计算这个键值对应在<code>table</code>的哪个下标索引位置，之后采用<strong>链地址法</strong>来解决哈希冲突。 <img src="/2023/06/10/Redis/dict.png" width="700"></p>
<p><strong>特性</strong></p>
<ul>
<li>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。</li>
<li>Redis中的字典使用哈希表作为底层结构实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</li>
<li>Redis使用MurmurHash2算法来计算键的哈希值。</li>
<li>哈希表使用链地址法来解决键冲突</li>
</ul>
<h3 id="跳表">跳表</h3>
<p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合的元素数量较多，或是比较长的字符串时，Redis就会使用跳表来作为有序集合键的底层实现。Redis跳表由<code>zskiplistNode</code>定义节点，<code>zskiplist</code>保存跳跃表节点的信息 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> &#123;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *backward;</span><br><span class="line">    <span class="comment">// 分值 权重</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistLevel</span> &#123;</span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *forward;</span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; leval[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure> zskipList <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplist</span> &#123;</span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *header, *tail;</span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> leval;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure> <strong>特性</strong></p>
<ul>
<li>跳跃表是有序集合的底层实现之一</li>
<li>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点</li>
<li>每个跳跃表节点的层高都是1至32之间的随机数</li>
<li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li>
<li>跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现。</li>
</ul>
<h3 id="压缩列表">压缩列表</h3>
<p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<p><strong>特性</strong></p>
<ul>
<li>看他的名字就能看出来，是为了节省内存造的列表结构，由连续内存块组成的顺序型数据结构</li>
</ul>
<h2 id="对象redis的数据类型">对象（Redis的数据类型）</h2>
<p>在上面，我们提到了Redis的五种数据结构，有<strong>简单动态字符串（SDS)、双端链表、字典、压缩列表、整数集合</strong>等。Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个<strong>对象系统，</strong>这个系统包含五种数据类型<strong><code>string（字符串）</code>，<code>hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)</code></strong>。 数据库之所以使用对象，是因为：</p>
<ul>
<li>Redis执行命令前，根据对象的类型判断一个对象是否可以执行给定的命令。</li>
<li>另一个好处是，针对不同的使用场景，为对象设置了多种不同的数据结构实现，从而优化不同场景下的使用效率</li>
<li>Redis对象系统还实现了基于引用计数的内存回收和对象共享机制，从而节省内存和及时回收内存。 <img src="/2023/06/10/Redis/five.png" width="700"></li>
</ul>
<p>Redis支持五种数据类型：<code>string（字符串）</code>，<code>hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)</code>。</p>
<h3 id="对象编码">对象编码</h3>
<p>Redis使用对象来表示数据库中的键和值，每次当在Redis的数据库中新建一个键值对时，我们至少会创建两个对象，一个<strong>对象用作键值的键，另一个对象用作键值的值</strong>。Redis中每个对象都由一个<code>redisObject</code>结构表示，有三个属性： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span>&#123;</span><br><span class="line">	<span class="comment">//类型</span></span><br><span class="line">	<span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">	<span class="comment">//编码</span></span><br><span class="line">	<span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">	<span class="comment">//指向低层实现数据结构的指针</span></span><br><span class="line">	<span class="type">void</span>* ptr;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>type</code>属性：记录对象类型，这个属性的值可为<code>REDIS_STRING\REDIS_LIST\REDIS_HASH\REDIS_SET\REDIS_ZSET</code>中的一个。对于Redis的键值来说，键总是一个<code>REDIS_STRING</code>类型即字符串类型，而值是可为5种中的一种。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">redis&gt;SET msg <span class="string">&quot;hello redis&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt;TYPE msg</span><br><span class="line">string</span><br></pre></td></tr></table></figure></li>
<li><code>ptr</code>:指向对象的底层实现数据结构，而这些数据结构由对象的<code>encoding</code>属性决定。<code>encoding</code>属性记录对象所使用的编码，也就是这个对象用什么数据结构作为对象的底层实现。 <img src="/2023/06/10/Redis/encoding.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Redis&gt;SET msg <span class="string">&quot;hello redis&quot;</span></span><br><span class="line">redis&gt;OBJECT ENCODING msg</span><br><span class="line"><span class="string">&quot;embstr&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>通过<code>encoding</code>属性决定对象所使用的编码，而不是关联固定的数据结构作为底层实现，极大提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景的效率，比如**在列表对象包含的元素较少时，Redis使用压缩列表作为底层实现</p>
</blockquote>
<blockquote>
<ul>
<li>因为压缩列表比双端链表更节省内存，并且在元素较少时，在内存中以连续快的方式保持压缩列表比双端链表可以更快的被载入缓存中</li>
<li>随着列表对象的包含的元素越来越多，使用压缩列表来保存元素的优势消失时，对象会将底层实现从压缩列表转为功能更强，也更适合保存大量元素的双端链表上面。</li>
</ul>
</blockquote>
<h3 id="字符串">字符串</h3>
<p>底层实现（内部编码）有3种:int（8字节长整型）/embstr（小于等于39字节字符串）/raw（大于39个字节字符串）</p>
<h4 id="常用命令">常用命令</h4>
<p>依据该数据结构，Redis支持字符串对象，Redis中每个对象的命令都有细微差异，因此你使用哪种命令就是使用哪个数据结构对象存储值。下列是字符串对象的命令：</p>
<table style="width:86%;">
<colgroup>
<col style="width: 5%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>SET key value</code>：设置指定 key 的值。</td>
</tr>
<tr class="even">
<td>2</td>
<td><code>GET key</code>获取指定 key 的值。</td>
</tr>
<tr class="odd">
<td>3</td>
<td><code>GETRANGE key start end</code>返回 key 中字符串值的子字符</td>
</tr>
<tr class="even">
<td>4</td>
<td><code>GETSET key value</code>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
</tr>
<tr class="odd">
<td>5</td>
<td><code>GETBIT key offset</code>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td>
</tr>
<tr class="even">
<td>6</td>
<td><code>MGET key1 [key2..]</code>获取所有(一个或多个)给定 key 的值。</td>
</tr>
<tr class="odd">
<td>7</td>
<td><code>SETBIT key offset value</code>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
</tr>
<tr class="even">
<td>8</td>
<td><code>SETEX key seconds value</code>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>
</tr>
<tr class="odd">
<td>9</td>
<td><code>SETNX key value</code>只有在 key 不存在时设置 key 的值。</td>
</tr>
<tr class="even">
<td>10</td>
<td><code>SETRANGE key offset value</code>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
</tr>
<tr class="odd">
<td>11</td>
<td><code>STRLEN key</code>返回 key 所储存的字符串值的长度。</td>
</tr>
<tr class="even">
<td>12</td>
<td><code>MSET key value [key value ...]</code>同时设置一个或多个 key-value 对。</td>
</tr>
<tr class="odd">
<td>13</td>
<td><code>MSETNX key value [key value ...]</code>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>
</tr>
<tr class="even">
<td>14</td>
<td><code>PSETEX key milliseconds value</code>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td>
</tr>
<tr class="odd">
<td>15</td>
<td><code>INCR key</code>将 key 中储存的数字值增一。</td>
</tr>
<tr class="even">
<td>16</td>
<td><code>INCRBY key increment</code>将 key 所储存的值加上给定的增量值（increment） 。</td>
</tr>
<tr class="odd">
<td>17</td>
<td><code>INCRBYFLOAT key increment</code>将 key 所储存的值加上给定的浮点增量值（increment） 。</td>
</tr>
<tr class="even">
<td>18</td>
<td><code>DECR key</code>将 key 中储存的数字值减一。</td>
</tr>
<tr class="odd">
<td>19</td>
<td><code>DECRBY key decrementkey</code>所储存的值减去给定的减量值（decrement） 。</td>
</tr>
<tr class="even">
<td>20</td>
<td><code>APPEND key value如果 key</code> 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>应用场景：共享session、分布式锁，计数器、限流。</p>
</blockquote>
<blockquote>
<p><strong>Redis为什么选择SDS结构，而C语言原生的char[]不香吗？</strong></p>
</blockquote>
<blockquote>
<ul>
<li>SDS中，O(1)时间复杂度，就可以获取字符串长度；而C 字符串，需要遍历整个字符串，时间复杂度为O(n)</li>
<li>SDS中，是二进制安全的，因此Redis的字符串可以存储任何序列。</li>
</ul>
</blockquote>
<h3 id="列表">列表</h3>
<p>底层实现（内部编码）：<code>ziplist</code>（压缩列表）、<code>linkedlist（</code>链表）</p>
<h4 id="常用命令-1">常用命令</h4>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>LPUSH key value1 [value2]</code></td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr class="even">
<td><code>LPUSHX key value</code></td>
<td>将一个值插入到已存在的列表头部</td>
</tr>
<tr class="odd">
<td><code>RPUSH key value1 [value2]</code></td>
<td>在列表中添加一个或多个值到列表尾部</td>
</tr>
<tr class="even">
<td><code>RPUSHX key value</code></td>
<td>为已存在的列表添加值</td>
</tr>
<tr class="odd">
<td><code>LSET key index value</code></td>
<td>通过索引设置列表元素的值</td>
</tr>
<tr class="even">
<td><code>BLPOP key1 [key2 ] timeout</code></td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr class="odd">
<td><code>LINDEX key index</code></td>
<td>通过索引获取列表中的元素</td>
</tr>
<tr class="even">
<td><code>BRPOP key1 [key2 ] timeout</code></td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr class="odd">
<td><code>LREM key count value</code></td>
<td>移除列表元素</td>
</tr>
<tr class="even">
<td><code>LRANGE key start stop</code></td>
<td>获取列表指定范围内的元素</td>
</tr>
<tr class="odd">
<td><code>LPOP key</code></td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr class="even">
<td><code>RPOP key</code></td>
<td>移除列表的最后一个元素，返回值为移除的元素。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>应用场景：消息队列，文章列表,</p>
</blockquote>
<h3 id="哈希表">哈希表</h3>
<h4 id="常用命令-2">常用命令</h4>
<table style="width:100%;">
<colgroup>
<col style="width: 28%">
<col style="width: 71%">
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>HMSET key field1 value1 [field2 value2 ]</code></td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr class="even">
<td><code>HMSET key field1 value1 [field2 value2 ]</code></td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr class="odd">
<td><code>HMGET key field1 [field2]</code></td>
<td>获取所有给定字段的值</td>
</tr>
<tr class="even">
<td><code>HDEL key field1 [field2]</code></td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr class="odd">
<td><code>HEXISTS key field</code></td>
<td>查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr class="even">
<td><code>HKEYS key</code></td>
<td>获取哈希表中的所有字段</td>
</tr>
</tbody>
</table>
<blockquote>
<p>内部编码：<code>ziplist</code>（压缩列表） 、<code>hashtable</code>（哈希表）</p>
<p>应用场景：缓存用户信息等。</p>
<p>注意点：如果开发使用<code>hgetall</code>，哈希元素比较多的话，可能导致Redis阻塞，可以使用<code>hscan</code>。而如果只是获取部分field，建议使用<code>hmget</code>。</p>
</blockquote>
<h3 id="集合">集合</h3>
<p>集合（set）可以保存多个字符串元素，但是不允许有重复元素，并且集合中的元素是无序的，一个集合最多可以存储<span class="math inline">\(2^{32}-1\)</span>个元素，集合可以进行内部的增删改查和多个集合取交集，并集，差集.Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>底层实现（内部编码）：<code>intset</code>（整数集合）、<code>hashtable</code>（哈希表）</p>
<h4 id="常用命令-3">常用命令</h4>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>SADD key member1 [member2]</code></td>
<td>向集合添加一个或多个成员</td>
</tr>
<tr class="even">
<td><code>SREM key member1 [member2]</code></td>
<td>移除集合中一个或多个成员</td>
</tr>
<tr class="odd">
<td><code>SISMEMBER key member</code></td>
<td>判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr class="even">
<td><code>SPOP key</code></td>
<td>移除并返回集合中的一个随机元素</td>
</tr>
<tr class="odd">
<td><code>SDIFF key1 [key2]</code></td>
<td>返回第一个集合与其他集合之间的差集。</td>
</tr>
<tr class="even">
<td><code>SINTER key1 [key2]</code></td>
<td>返回给定所有集合的交集</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意点：<code>smembers</code>和<code>lrange、hgetall</code>都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，可以使用<code>sscan</code>来完成。</p>
<p>应用场景：用户标签,生成随机数抽奖、社交需求。</p>
</blockquote>
<h3 id="有序集合">有序集合</h3>
<p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
<p><strong>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。适合做排行榜系统</strong></p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 <span class="math inline">\(2^{32} - 1\)</span> (4294967295, 每个集合可存储40多亿个成员)。</p>
<blockquote>
<p>在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知： 添加和删除都需要修改skiplist，所以复杂度为O(log(n))。 但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1) 其他的range操作复杂度一般为O(log(n)) 当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)</p>
</blockquote>
<h4 id="常用命令-4">常用命令</h4>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ZADD key score1 member1 [score2 member2]</code></td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr class="even">
<td><code>ZSCORE key member</code></td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr class="odd">
<td><code>ZCARD key</code></td>
<td>获取有序集合的成员数</td>
</tr>
<tr class="even">
<td><code>ZCOUNT key min max</code></td>
<td>计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr class="odd">
<td><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</code></td>
<td>通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr class="even">
<td><code>ZRANK key member</code></td>
<td>返回有序集合中指定成员的索引</td>
</tr>
<tr class="odd">
<td><code>ZREM key member [member ...]</code></td>
<td>移除有序集合中的一个或多个成员</td>
</tr>
</tbody>
</table>
<blockquote>
<p>底层内部编码：<code>ziplist</code>（压缩列表）、<code>skiplist</code>（跳跃表） <strong>应用场景：排行榜，社交需求（如用户点赞）。</strong></p>
</blockquote>
<h3 id="键">键</h3>
<p>Redis 键命令用于管理 redis 的键。</p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 89%">
</colgroup>
<thead>
<tr class="header">
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>DEL key</code>该命令用于在 <code>key</code> 存在时删除 key。</td>
</tr>
<tr class="even">
<td>2</td>
<td><code>DUMP key</code>序列化给定 key ，并返回被序列化的值。</td>
</tr>
<tr class="odd">
<td>3</td>
<td><code>EXISTS key</code>检查给定 key 是否存在。</td>
</tr>
<tr class="even">
<td>4</td>
<td><code>EXPIRE key seconds</code>为给定 key 设置过期时间，以秒计。</td>
</tr>
<tr class="odd">
<td>5</td>
<td><code>EXPIREAT key timestamp</code> EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td>
</tr>
<tr class="even">
<td>6</td>
<td><code>PEXPIRE key milliseconds</code>设置 key 的过期时间以毫秒计。</td>
</tr>
<tr class="odd">
<td>7</td>
<td><code>PEXPIREAT key milliseconds-timestamp</code>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td>
</tr>
<tr class="even">
<td>8</td>
<td><code>KEYS pattern</code>查找所有符合给定模式( pattern)的 key 。</td>
</tr>
<tr class="odd">
<td>9</td>
<td><code>MOVE key db</code>将当前数据库的 key 移动到给定的数据库 db 当中。</td>
</tr>
<tr class="even">
<td>10</td>
<td><code>PERSIST key</code>移除 key 的过期时间，key 将持久保持。</td>
</tr>
<tr class="odd">
<td>11</td>
<td><code>PTTL key</code>以毫秒为单位返回 key 的剩余的过期时间。</td>
</tr>
<tr class="even">
<td>12</td>
<td><code>TTL key</code>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td>
</tr>
<tr class="odd">
<td>13</td>
<td><code>RANDOMKEY</code>从当前数据库中随机返回一个 key 。</td>
</tr>
<tr class="even">
<td>14</td>
<td><code>RENAME key newkey</code>修改 key 的名称</td>
</tr>
<tr class="odd">
<td>15</td>
<td><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</td>
</tr>
<tr class="even">
<td>16</td>
<td><code>SCAN cursor [MATCH pattern] [COUNT count]</code>迭代数据库中的数据库键。</td>
</tr>
<tr class="odd">
<td>17</td>
<td><code>TYPE key</code>返回 key 所储存的值的类型。</td>
</tr>
</tbody>
</table>
<h2 id="数据库">数据库</h2>
<p>要熟悉Redis数据库，就必须理解Redis数据库的组织形式，这样才能建立对Redis的扎实概念，从理解出发认识Redsi。本节主要说明Redis服务器如何保存数据库、数据库如何管理键值对、服务器如何管理保存键的过期时间</p>
<h3 id="服务器的数据库">服务器的数据库</h3>
<p>Reids服务器将所有数据库都保存在服务器<code>redis.h/redisSever</code>结构体的<code>db</code>数组中。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">redisSever</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//指示服务器的数据库数量</span></span><br><span class="line">	<span class="type">int</span> dbnum;</span><br><span class="line">	<span class="comment">//一个数组，保存服务器中所有的数据库</span></span><br><span class="line">	redisDB* db;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Redis客户端切换数据库，在RedisClient结构的db属性记录了客户端当前的目标数据库， <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisClient</span>&#123;</span><br><span class="line">&gt;<span class="comment">//...</span></span><br><span class="line">&gt;<span class="comment">//记录当前客户端正在使用的db数据库</span></span><br><span class="line">&gt;redisDB* db;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure> 我们可以通过<code>SELECT 数字</code>来切换至第几号数据库 <img src="/2023/06/10/Redis/db.png" width="700"></p>
</blockquote>
<h3 id="数据库的键空间">数据库的键空间</h3>
<p>Redis是一个键值对数据库服务器，因此服务器中每个数据库中都由一个redis/redisDB结构体表示，<strong>其中的<code>dict</code>字典保存了数据库的所有键值对，我们将这个字典称为键空间</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisDb</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//数据库的键空间</span></span><br><span class="line">	dict* dict;</span><br><span class="line">	<span class="comment">//过期字典</span></span><br><span class="line">	dice* expires;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></p>
<ul>
<li>键空间的键也就是数据库的键也，每一个键都是一个字符串对象</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串、列表、哈希、集合和有序集合对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">redis&gt;SET msg <span class="string">&quot;hello world&quot;</span></span><br><span class="line">redis&gt;RPUSH alphabet <span class="string">&quot;a&quot;</span> <span class="string">&quot;b&quot;</span> <span class="string">&quot;c&quot;</span></span><br><span class="line">redis&gt;HSET book name <span class="string">&quot;Redis in Action&quot;</span></span><br><span class="line">redis&gt;HSET book author <span class="string">&quot;Josiah L. Carlson&quot;</span></span><br><span class="line">redis&gt;HSET book publisher <span class="string">&quot;Manning&quot;</span></span><br></pre></td></tr></table></figure>
<p>在执行这些命令后，对应的数据库库键空间如下： <img src="/2023/06/10/Redis/keyspace.png" width="700"></p>
<h3 id="键的生存时间">键的生存时间</h3>
<p>为什么要设置键的生存时间，键的生存时间指的是再内存中的存在时间：</p>
<ul>
<li>如果缓存没有失效时间，对于读多写少的场景，如果产生脏数据会永远没有机会更新，还会存在冷数据的问题，一段时间内没有被访问过的数据也会持续占据内存空间，造成空间浪费。（空间使用率）</li>
<li>如果时间设置的很短，缓存频繁失效，高并发下数据库压力会上升，严重情况可能会宕机。</li>
<li>缓存失效时间要随机。如果所有的key失效时间同时失效，大量的请求直接落到DB上，这就是常说的缓存雪崩。</li>
</ul>
<p>Redis有四种不同的命令来设置键的生存时间：</p>
<ul>
<li><code>EXPIRE &lt;KEY&gt; &lt;TTL&gt;</code>命令将键KEY的生存时间设置为TTL秒</li>
<li><code>PEXPIRE &lt;KEY&gt; &lt;TTL&gt;</code>命令将键KEY的生存时间设置为TTL毫秒</li>
<li>`EXPIREAT <KEY> <timestamp>命令将key的过期时间设置为指定timestamp秒数时间戳</timestamp></KEY></li>
<li><code>PEXPIRAT &lt;KEY&gt; &lt;timestam&gt;</code>命令将key的过期时间设置为指定timestamp毫秒数时间戳</li>
</ul>
<p>redisDb结构体还有一个名为<code>expires</code>字典保存数据库中所有键的过期时间，<code>expires</code>被称为过期字典：</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间的某个键对象</li>
<li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间。 <img src="/2023/06/10/Redis/livetime.png" width="700"></li>
</ul>
<h4 id="过期删除策略">过期删除策略</h4>
<p>一个键过期了，redis服务器是采用什么策略将这些键从内存删除呢，一共有三个策略，<strong>redis采用了惰性删除和定期删除策略</strong>：</p>
<ul>
<li><strong>定时删除</strong>：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
<ul>
<li>定时删除策略对内存最友好，因为该策略是尽可能快的删除键；但缺点是对CPU最不友好，在过期键比较多的时候，删除过期键可能会占用CPU相当一部分时间。</li>
</ul></li>
<li><strong>惰性删除</strong>：放任键的过期不管，但是每次从键空间中获取键时，都会检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键
<ul>
<li>惰性删除对CPU的来说是最友好的，因为程序只有在取出键时才对键进行过期检查，这保证了键的删除操作只在非做不可的时候进行，并且删除的键时当前处理的目标键。缺点是对内存最不友好，如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。</li>
</ul></li>
<li><strong>定期删除</strong>：每隔一段时间，程序就对数据库进行一次检查，删除里面过期的键。至于要删除多少个过期键，以及检查多少个数据库，由算法决定。
<ul>
<li><strong>定期删除是对定时删除和惰性删除的折中选择</strong>，</li>
</ul></li>
</ul>
<blockquote>
<p>参考文献 菜鸟教程 《Redis设计与实现》</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/07/30/MySQL/</url>
    <content><![CDATA[<h2 id="了解sql">1. 了解SQL</h2>
<h3 id="数据库基础">1.1 数据库基础</h3>
<p>数据库是一个以某种有组织的方式存储的数据集合。<code>MySQL</code>数据库中只有一个用户，名为<code>root</code>，但是它可以有多个数据库，如下是与<code>Oracle</code>数据库的不同之处： <img src="/2022/07/30/MySQL/different.png" width="700"></p>
<span id="more"></span>
<h4 id="表的概念">1.1.1 表的概念</h4>
<p>在数据库中，<strong>表是一种结构化的文件，用来存储某种特定类型的数据</strong>。数据库中的表都有一个唯一名字来标识自己，称为<strong>表名</strong>。同时表具有一些特性，这些特性定义了数据在表中如何存储，可以存储什么样的数据，数据如何分解、各部分信息如何让命名等等。</p>
<p>描述表的这组信息就是所谓的<strong>模式</strong>，模式即指关于数据库和表的布局以及特性的信息。</p>
<h4 id="列和数据类型">1.1.2 列和数据类型</h4>
<p><strong>表由列组成，列就是表中的一个字段</strong>。列中存储着表的某部分信息，数据库中的列都有相应的类型，数据类型定义了列中可以存储的数据种类。</p>
<h4 id="行">1.1.3 行</h4>
<p><strong>虽然表由列组成，但存储过程中，表中的数据是按行存储的</strong>。每次保存的记录都存储在自己所在的行中，你也可以理解为行就是表中的一个记录。</p>
<h4 id="主键">1.1.4 主键</h4>
<p><strong>表中的每一行都应该有唯一标识自己的一列，这样搜索起来才不容易出错，保证数据的完整性</strong>，就如一个顾客列表可以使用顾客编号来作为主键,如果使用顾客姓名来搜索，万一有相同姓名的顾客搜索就容易混淆。<strong>因此对于每创建一个表来说都应该至少设置一列为主键</strong>，作为主键的列必须满足：</p>
<ul>
<li>任意两行都不具有相同的主键值</li>
<li>每一行都必须具有一个主键值（主键列不允许为NULL值）</li>
</ul>
<p>主键虽然通常定义在表的一列上，但是也可以使用多个列作为主键</p>
<h4 id="外键">1.1.5 外键</h4>
<p><strong>外键就是某个表中被定义为外键的一列，它包含另一个表的主键值</strong>，定义两个表之间的关系，一个表中可以有多个外键。其作用主要有：</p>
<ul>
<li>不用重复存储另一个表中有的数据到本表，只需通过外键建立连续即可，节省了时间和空间</li>
<li>同时在删除中必须先删除外键才能删除主键，因此能保证数据的完整性</li>
</ul>
<h2 id="mysql的安装和修改">2. MySQL的安装和修改</h2>
<p>在ubuntu中可以使用<code>sudo apt install mysql-server</code>进行安装MySQL数据库。以下是对数据库的的初始化必做事项 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入本地数据库shell界面</span><br><span class="line">mysql -u root -p</span><br><span class="line">#进入其他主机的数据库shell</span><br><span class="line">mysql -h 192.168.18.251 -u root -p</span><br><span class="line">#修改密码</span><br><span class="line">mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<h3 id="启动和关闭mysql服务器">2.1 启动和关闭MySQL服务器</h3>
<p>MySQLS数据库分为客户端和服务器，<code>mysql-server</code>与<code>mysql-client</code>是DBMS的两个面向不同操作对象的工具。<code>server</code>是DBMS面向物理层次，包含存储数据的一系列机制、处理方法的集成；<code>client</code>是DBMS面向用户，提供一系列工具为用户所用，这些工具包括通常写的<code>sql</code>在内都要通过<code>server</code>的编译才能操作物理数据。即在连接服务器时要先开启<code>mysql-server</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种启动mysql服务器方法</span></span><br><span class="line">service mysql start</span><br><span class="line">systemctl statrt mysql</span><br><span class="line">systemctl restart mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看状态</span></span><br><span class="line">systemctl status mysql.service</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭服务器</span></span><br><span class="line">systectl stop mysql</span><br><span class="line">service mysql stop</span><br></pre></td></tr></table></figure>
<p><strong>注意数据库shell界面</strong>，<code>shell</code>界面是<code>mysql-client</code>提供了一种人与<code>mysql</code>直接交互的命令窗口，同Linux的<code>bashShell</code>是一样的。</p>
<h2 id="数据库的基本命令">3 数据库的基本命令</h2>
<ul>
<li><p>查看当前实例下包含多少个数据库： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#展示目前数据库目录</span><br><span class="line">show databases；</span><br><span class="line">show CREATE DATABASE 数据库名；#查看创建库的信息</span><br></pre></td></tr></table></figure></p></li>
<li><p>用户需要创建新的数据库： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database [IF NOT EXISTS]数据库名；</span><br><span class="line">create database 数据库名 character set GBK/UTF-8/...;#指定编码</span><br><span class="line">show variables like &#x27;character%&#x27;;#查看编码</span><br><span class="line">#创建数据库:创建一个使用utf-8字符集，并带校对规则的mydb3数据库。会对存入的数据进行检查。</span><br><span class="line">mysql&gt; create database mydb3 character set utf8 collate utf8_general_ci;</span><br><span class="line">Query OK, 1 row affected, 2 warnings (0.03 sec)</span><br></pre></td></tr></table></figure></p></li>
<li><p>删除指定数据库： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database 数据库名；</span><br></pre></td></tr></table></figure></p></li>
<li><p>进入该数据库 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">use 数据库名；</span><br><span class="line"><span class="function">select <span class="title">database</span><span class="params">()</span></span>;#查看当前选择的数据库</span><br></pre></td></tr></table></figure></p></li>
<li><p>修改数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter database test character set utf8;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.05 sec)</span><br></pre></td></tr></table></figure></p></li>
<li><p>进入数据库后，查询该数据库下包含多少个数据表： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure></p></li>
<li><p>查看指定数据表的表结构（查看该表有多少列，每列的数据类型等信息）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc 表名；</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="mysql数据库存储机制">4 MySQL数据库存储机制</h2>
<ul>
<li><code>MySAM</code>：对事务支持不够好</li>
<li><code>InnoDB</code>：系统默认机制 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENGING=MyISAM——强制使用第一种机制</span><br><span class="line">ENGING=InnoDB——强制使用第二种机制</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="sql语句基础">5 SQL语句基础</h2>
<p>SQL语句主要由<code>DDL</code>语句，<code>DML</code>数据库操作语句、<code>DQL</code>数据库查询语句、<code>DCL</code>数据库控制语句 ### 5.1 DDL语句：数据定义语句 - <strong>DDL语句是用于操作数据库对象的，用来定义数据库对象,包括创建（create）、删除（drop）、修改（alter）数据库对象</strong></p>
<ul>
<li>其中数据库对象包含数据库本身<code>database</code>，表<code>table</code>、列<code>column</code>、索引<code>index</code>、约束<code>constraint</code>、视图<code>view</code>、触发器<code>trigger</code>、存储过程<code>StoredProcedure</code>和函数<code>function）</code>。</li>
</ul>
<table>
<thead>
<tr class="header">
<th>象名称</th>
<th>对应关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>表</td>
<td><code>table</code></td>
<td>表以行和列的形式存在：列就是字段，行就是记录</td>
</tr>
<tr class="even">
<td>数据字典</td>
<td></td>
<td>就是系统表，存放数据库相关信息的表</td>
</tr>
<tr class="odd">
<td>约束</td>
<td><code>constraint</code></td>
<td>执行数据校验的规则，用于保证数据完整性的规则</td>
</tr>
<tr class="even">
<td>视图</td>
<td><code>view</code></td>
<td>一个或者多个数据表数据的逻辑显示。视图并不存储数据</td>
</tr>
<tr class="odd">
<td>索引</td>
<td><code>index</code></td>
<td>用于提高查询性能，相当于书的目录</td>
</tr>
<tr class="even">
<td>函数</td>
<td><code>function</code></td>
<td>用于完成一次特定的计算，具有一个返回值</td>
</tr>
<tr class="odd">
<td>存储过程</td>
<td><code>procedure</code></td>
<td>用于完成一次完整的业务处理，没有返回值，但可以通过传出参数将多个值传给调用环境</td>
</tr>
<tr class="even">
<td>触发器</td>
<td><code>trigger</code></td>
<td>相当于一个事件监听器，当数据库发生特定事件后，触发器触发，完成相应的处理</td>
</tr>
</tbody>
</table>
<p><strong>因此上面的操作数据库的语句就是DDL语句</strong></p>
<blockquote>
<p>因此对于DDL语句来说，主要由数据库管理者使用，而开发人员用的最多的是<strong><code>DML</code>数据库操作语句、<code>DQL</code>数据库查询语句、<code>DCL</code>数据库控制语句</strong></p>
</blockquote>
<h4 id="ddl之操作表">5.1.1 DDL之操作表</h4>
<p>本节主要简单介绍对表的操作关键字和相应的数据库数据类型，让读者对表创建有一个总体的认识。能够简单创建表，提升性能的表创建方法后续才会介绍到。在创建表之前，必须选择对哪一个数据库操作，同时你也必须了解Mysql内的的数据类型 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure></p>
<ul>
<li>** MySQL的数据类型**：数据类型是定义该列可以存储的数据以及该数据实际怎样存储的法则
<ul>
<li><p><strong>串数据类型</strong> <img src="/2022/07/30/MySQL/string.png" width="700"></p></li>
<li><p><strong>数值数据类型</strong> <img src="/2022/07/30/MySQL/digit.png" width="700"></p></li>
<li><p><strong>日期和时间数据类型</strong> <img src="/2022/07/30/MySQL/date.png" width="700"></p></li>
<li><p>二<strong>进制数据类型：可以存储任何数据，如图像、多媒体、字处理文档等</strong> <img src="/2022/07/30/MySQL/binary.png" width="700"></p></li>
</ul></li>
<li><code>bit</code>：1位，可以指定位数，如：<code>bit(3)</code></li>
<li><code>int</code>：2字节可以指定最大位数，如<code>int&lt;4&gt;</code>,最大为4位的整数</li>
<li><code>float</code>：2个字节,可以指定最大的位数和最大的小数位数，如：<code>float&lt;5,2&gt;</code> 最大为一个5位的数，小数位最多2位</li>
<li><code>double</code>：4个字节,可以指定最大的位数和最大的小数位数，如：<code>float&lt;6,4&gt;</code>最大为一个6位的数，小数位最多4位</li>
<li><code>char</code>：必须指定字符数,如<code>char(5)</code>,为不可变字符　即使存储的内容为'ab',也是用5个字符的空间存储这个数据</li>
<li><code>varchar</code>：必须指定字符数,如varchar(5) 为可变字符　如果存储的内容为'ab',占用2个字符的空间；如果为'abc',则占用3个字符的空间</li>
<li><code>text</code>: 大文本(大字符串)</li>
<li><code>blob</code>：二进制大数据,如图片，音频文件，视频文件</li>
<li><code>date</code>: 日期　如：'1921-01-02'</li>
<li><code>datetime</code>: 日期+时间　如：'1921-01-02 12:23:43'</li>
<li><code>timeStamp</code>: 时间戳，自动赋值为当前日期时间</li>
</ul>
<h5 id="创建表">创建表</h5>
<p>创建表使用<code>create table</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建CUSTOMER表，以ID作为主键，同时指示除SALARY外其他都不能为NULL</span><br><span class="line">mysql&gt; CREATE TABLE IF NOT EXISTS CUSTOMER(</span><br><span class="line">    -&gt; NAME VARCHAR(20) NOT NULL, </span><br><span class="line">    -&gt; ID INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; SALARY DOUBLE NULL,</span><br><span class="line">    -&gt; HIREDATE DATE NOT NULL,</span><br><span class="line">    -&gt; PRIMARY KEY (ID)</span><br><span class="line">    -&gt; )ENGINE=InnoDB;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//建立外键</span><br><span class="line">create table epartment(</span><br><span class="line">	ID INT NOT NULL,</span><br><span class="line">	BELONG VARCHAR(20) NOT NULL,</span><br><span class="line">	FOREIGN KEY (ID) REFERENCES CUSTOMER(ID)</span><br><span class="line">)ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">**这里有几个关键字需要介绍**：</span><br><span class="line"></span><br><span class="line">- `NULL`和`NOT NULL`:这两个关键字指示我们在插入记录对于该列来说，如果是`NOT NULL`,则插入记录时该列必须要有数据，否则会报错，而`NULL`修饰的列可以允许插入的记录在该列为空。</span><br><span class="line"></span><br><span class="line">- `AUTO_INCREMENT`:在上述的表中`ID`是标识顾客的唯一编号，它们可以任意但是必须唯一，如果认为指定那么很难维护，`AUTO_INCREMENT`则是告诉MySQL本列每增加一行时自动增量，即每次执行一个`insert`,对该列增量。</span><br><span class="line"></span><br><span class="line">- `PRIMARY KEY()`:指示使用哪一个或哪几个字段作为主键</span><br><span class="line"></span><br><span class="line">- `ENGINE=InnoDB`:指示使用的引擎类型为`InnoDB` ，关于引擎类型后续会讲到</span><br><span class="line"></span><br><span class="line">#####  更新表</span><br><span class="line">有时候我们创建了表，但是对于表的字段列需要添加或者删除操作，这时候就用到了**表更新**这个概念，更新表使用`alter table`</span><br><span class="line"></span><br><span class="line">**添加列定义：如果只新增一列，可以省略圆括号，在add后紧跟一个列定义即可。**</span><br><span class="line">```mysql</span><br><span class="line">alter table 表名</span><br><span class="line">add</span><br><span class="line">(</span><br><span class="line">   #可以有多个列定义</span><br><span class="line">   column_name1 datatype [default expr] [first|after col_name],</span><br><span class="line">   ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p><strong>删除列定义：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alter table 表名</span><br><span class="line">drop colum_name</span><br></pre></td></tr></table></figure></p>
<p><strong>修改列</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名</span><br><span class="line">modify column_name datatype(修改后的类型) [default expr] [first|after col_name](指定需要将目标修改到指定位置）;</span><br></pre></td></tr></table></figure> - 该修改语句每次只能修改一个列定义 - add新增的列名是原表中不存在的，modify修改的是原表中已存在的 - first 表示添加在最开始处，after xxx表示添加在xxx之后</p>
<p><strong>完全改变列定义</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alter table 表名</span><br><span class="line">change old_column new_column type [<span class="keyword">default</span> expr][first|after col_name]</span><br></pre></td></tr></table></figure> 一般只有需要修改列名时才会使用change选项</p>
<p><strong>修改表的字符集:</strong> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表 <span class="type">character</span> <span class="keyword">set</span> [utf8<span class="operator">/</span>gbk];</span><br></pre></td></tr></table></figure></p>
<p><strong>truncate 表：删除表里全部数据和结构，在重新建立一个新表（更彻底，无法找回</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">truncate 表名</span><br></pre></td></tr></table></figure></p>
<h5 id="删除表">删除表</h5>
<p>删除数据库中的表使用<code>drop table</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE CUSTOMER;</span><br></pre></td></tr></table></figure></p>
<h6 id="重命名表">重命名表</h6>
<p>如果相对表的名字重命名则可使用<code>rename</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; rename table CUSTOMER TO customer;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="显示表结构">显示表结构</h5>
<p>如果想对表的结构字段名、类型等了解，可通过<code>describe</code>来显示表结构： - describe(desc简写) 表名：显示出一个表</p>
<ul>
<li>show create table 表名：显示更详细，包括代码 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; describe customer;</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| NAME     | <span class="built_in">varchar</span>(<span class="number">20</span>) | NO   |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">| ID       | <span class="built_in">varchar</span>(<span class="number">30</span>) | NO   | PRI | <span class="literal">NULL</span>    |       |</span><br><span class="line">| SALARY   | <span class="type">double</span>      | YES  |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">| HIREDATE | date        | NO   |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.02</span> sec)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据库约束">5.2 数据库约束</h3>
<p>数据库的约束类型有<code>NOT NULL、UNIQUE、PRIMARY KEY、FOREING KEY、CHECH</code>。</p>
<ul>
<li>约束类型
<ul>
<li><p><code>NOT NULL</code>：非空约束，指定某列不能为空。</p></li>
<li><p><code>UNIQUE</code>：唯一约束，指定某列或者几列组合不能重复。</p></li>
<li><p><code>PRIMARY KEY</code>：主键，指定该列的值可以唯一的标识该条记录，不能为<code>NULL</code>。</p></li>
<li><p><code>POREING KEY</code>：外键，指定该行记录从属于主表中的一条记录，主要用于保证参照完整性。</p></li>
<li><p><code>CHECK</code>：检查，指定一个布尔表达式，用于指定对应列的值必需满足该表达式</p></li>
</ul></li>
</ul>
<blockquote>
<p>MySQL不支持<code>CHECK</code>约束，可使用但没卵用</p>
</blockquote>
<h4 id="not-null约束">5.2.1 NOT NULL约束</h4>
<p>它只能作为列级约束使用，非空约束不能指定名字。null值：所有数据类型的值都可以是null；</p>
<blockquote>
<p>空字符串不等于null，0也不等于null；</p>
</blockquote>
<blockquote>
<p>在数据库中null不等于null；</p>
</blockquote>
<ul>
<li><p>只要在列表定义后添加<code>not null</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table hehe</span><br><span class="line">(</span><br><span class="line">  #建立了非空约束，这意味着hehe_id不可以为null</span><br><span class="line">  hehe_id int not null,</span><br><span class="line">  # MySQL的非空约束不能指定名字</span><br><span class="line">  hehe_name varchar(255) default &#x27;xyz&#x27; not null,</span><br><span class="line">  #下面列可以为空，默认就是可以为空</span><br><span class="line">  hehe_gender varchar(2) null</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p></li>
<li><p>在使用<code>alter table</code> 修改表时增加或者删除非空约束 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#增加非空约束</span><br><span class="line"><span class="function">alter table hehe</span></span><br><span class="line"><span class="function">modify hehe_gender <span class="title">varchar</span><span class="params">(<span class="number">2</span>)</span> <span class="keyword">not</span> null</span></span><br><span class="line"><span class="function">#取消非空约束</span></span><br><span class="line"><span class="function">modify hehe_name <span class="title">varchar</span><span class="params">(<span class="number">2</span>)</span> null</span>;</span><br><span class="line">#取消非空约束，并指定默认值</span><br><span class="line"><span class="function">alter table hehe</span></span><br><span class="line"><span class="function">modify hehe_name <span class="title">varchar</span><span class="params">(<span class="number">255</span>)</span> <span class="keyword">default</span> &#x27;abc&#x27; null</span>;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="unique约束">5.2.2 UNIQUE约束</h4>
<ul>
<li>唯一约束用于保证指定列或指定列组合不允许出现重复值，但可以出现多个null</li>
<li>当某列创建唯一约束时，会为该列相应的创建唯一索引</li>
<li>如果不给唯一约束起名，该唯一约束默认与列名同名</li>
<li>如果需要为多列建组合约束，或者需要为唯一约束指定约束名，`只能用表级约束语法</li>
</ul>
<p><strong>使用</strong>: - 列级约束语法：在定义后增加unique关键字即可 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#建表时创建唯一约束，使用列级约束法建立约束</span><br><span class="line">create table unique_test</span><br><span class="line">(</span><br><span class="line">  #建立了非空约束</span><br><span class="line">  test_id int not null,</span><br><span class="line">  #unique是唯一约束，使用列级约束法建立唯一约束</span><br><span class="line">  test_name varchar(255) unique</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>表级约束语法：<code>[constraint 约束名] 约束定义</code>
<ul>
<li><p>即可放在create table中，也可放在alter table中使用关键字add来添加约束 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">create table <span class="title">unique_test2</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  test_id <span class="type">int</span> <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">  test_name varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  test_pass varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  #使用表级约束法语句建立唯一约束</span></span></span><br><span class="line"><span class="params"><span class="function">  unique (test_name),</span></span></span><br><span class="line"><span class="params"><span class="function">  #使用表级约束法建立唯一约束，并指定约束名</span></span></span><br><span class="line"><span class="params"><span class="function">  constraint test2_uk unique (test_pass)</span></span></span><br><span class="line"><span class="params"><span class="function">  \</span></span></span><br><span class="line"><span class="params"><span class="function">  #使用表级约束法建立唯一约束，指定两列组合不允许重复</span></span></span><br><span class="line"><span class="params"><span class="function">  constraint test3_uk unique(test_name,test_pass)</span></span></span><br><span class="line"><span class="params"><span class="function">  \</span></span></span><br><span class="line"><span class="params"><span class="function">  #使用add关键字添加唯一约束</span></span></span><br><span class="line"><span class="params"><span class="function">  add unique(test_name,test_pass),</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>在修改表结构时使用add关键字添加唯一约束 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">alter table unique_test3</span></span><br><span class="line"><span class="function">add <span class="title">unique</span><span class="params">(test_name,test_pass)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>在修改表时使用modify关键字，为单列采用列级约束语法来增加唯一约束 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">alter table unique_test3</span></span><br><span class="line"><span class="function">modify test_name <span class="title">verchar</span><span class="params">(<span class="number">255</span>)</span> unique</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>删除约束：drop index 约束名 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alter table unique_test3 drop index text3_uk;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h4 id="primary-key约束">5.2.3 PRIMARY KEY约束</h4>
<ul>
<li><strong>主键约束相当于非空约束和唯一约束</strong></li>
<li><strong>主键列的值可用于唯一的标识表中的一条记录</strong></li>
<li><strong>每一个表中最多允许有一个主键，主键是表中能唯一确定一行记录的字段或字段组合</strong></li>
<li><strong>不管用户是否为主键约束指定约束名，MySQL总是将所有的主键约束命名为PRIMARY</strong></li>
<li><strong>MySQL在主键约束所在列或列组合上建立对应的唯一索引</strong></li>
</ul>
<p><strong>使用：primary key</strong></p>
<ul>
<li><p>列级约束法 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">create table <span class="title">primary_test</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  #建立了主键约束</span></span></span><br><span class="line"><span class="params"><span class="function">  test_id <span class="type">int</span> primary key,</span></span></span><br><span class="line"><span class="params"><span class="function">  test_name varchar(<span class="number">255</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>表级约束法:[constraint 约束名] 约束定义 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">create table <span class="title">primary_test2</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  test_id <span class="type">int</span> <span class="keyword">not</span> null,</span></span></span><br><span class="line"><span class="params"><span class="function">  test_name varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  teat_pass varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  #指定约束名对MySQL无效</span></span></span><br><span class="line"><span class="params"><span class="function">  constraint test_pk primary key (test_id)</span></span></span><br><span class="line"><span class="params"><span class="function">  \</span></span></span><br><span class="line"><span class="params"><span class="function">  #建立多列组合的主键约束</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key (test_name,test_pass)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">alter table primary_test3</span></span><br><span class="line"><span class="function">modify test_nama <span class="title">varchar</span><span class="params">(<span class="number">255</span>)</span> primary key</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>删除指定表的主键约束：drop primary key <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alter table primary_test3</span><br><span class="line">drop primary key;</span><br><span class="line">\</span><br><span class="line"><span class="function">drop primary <span class="title">key</span> <span class="params">(test_name,test_pass)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li>自增长特性：<code>auto_increment</code>
<ul>
<li><strong>如果某个数据列的类型是整形，而且该列作为主键列，可指定该列具有自增长功能。</strong></li>
<li><strong>该功能通常用于设置逻辑主键列–该列的值没有任何物理意义，仅仅用于表示每行记录</strong></li>
<li><strong>一旦指定了某列具有自增长特性，则向该表插入记录时可不为该列指定值，由数据库系统自动生成</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">create table <span class="title">primary_test4</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  #建立主键约束，使用自增长</span></span></span><br><span class="line"><span class="params"><span class="function">  test_id <span class="type">int</span> auto_increment primary key,</span></span></span><br><span class="line"><span class="params"><span class="function">  test_name varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  test_pass varchar(<span class="number">255</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="foreign-key约束">5.2.4 FOREIGN KEY约束</h4>
<ul>
<li>外键约束主要用于保证一个或两个数据表之间的参考完整性，外键是构建于一个表的两个字段或者两个表的字段之间的参照关系：<strong>子（从）表外键列的值必须在主表被参照列的值范围之内，或者为空。</strong></li>
<li>当主表的记录被从表记录参照后，必须先把从表里参照记录的所有记录全部删除后，才可以删除主表的该记录或者删除主表记录时级联删除从表所有参照该记录的从表记录</li>
<li><strong>从表外键参照的只能是主表主键列或者唯一键列。同一个表中可以拥有多个外键。</strong></li>
<li>对于一对多的关联关系，通常在多的一端增加外键列</li>
<li>增加外键列的表被称为从表</li>
</ul>
<p><strong>使用：<code>references</code></strong></p>
<ul>
<li><p>列级约束语法(MySQL建立的列级约束语法不会生效) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#为保证从表参照的主表存在，通常应该先建主表</span><br><span class="line"><span class="function">create table <span class="title">teacher_table</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  #auto_increment:代表数据库的自动编码策略，通常用作数据表的逻辑主键</span></span></span><br><span class="line"><span class="params"><span class="function">  teacher_id <span class="type">int</span> auto_increment,</span></span></span><br><span class="line"><span class="params"><span class="function">  teacher_name varchar(<span class="number">255</span>)，</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(teacher_id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span>；</span></span><br><span class="line"><span class="function">create table <span class="title">student_table</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  #为本表建立主键约束</span></span></span><br><span class="line"><span class="params"><span class="function">  student_id <span class="type">int</span> auto_increment primary key,</span></span></span><br><span class="line"><span class="params"><span class="function">  student_name varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  java_teacher <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  #指定java_teacher参照到teacher_table的teacher_id列</span></span></span><br><span class="line"><span class="params"><span class="function">  java_teacher <span class="type">int</span> references teacher_table(teacher_id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>表级约束语法：<code>foreign key</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#为保证从表参照的主表存在，通常应该先建主表</span><br><span class="line"><span class="function">create table <span class="title">teacher_table1</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  #auto_increment:代表数据库的自动编码策略，通常用作数据表的逻辑主键</span></span></span><br><span class="line"><span class="params"><span class="function">  teacher_id <span class="type">int</span> auto_increment,</span></span></span><br><span class="line"><span class="params"><span class="function">  teacher_name varchar(<span class="number">255</span>)，</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(teacher_id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span>；</span></span><br><span class="line"><span class="function">create table <span class="title">student_table</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  #为本表建立主键约束</span></span></span><br><span class="line"><span class="params"><span class="function">  student_id <span class="type">int</span> auto_increment primary key,</span></span></span><br><span class="line"><span class="params"><span class="function">  student_name varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  java_teacher <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  #指定java_teacher参照到teacher_table的teacher_id列</span></span></span><br><span class="line"><span class="params"><span class="function">  foreign key (java_teacher) references teacher_table1(teacher_id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure> &gt;使用表级约束语法可以为外键约束指定约束名，如果没有，MySQL会为该键命名为table_name_ibfk_n //table是从表的表名，而n从1开始的整数</p></li>
<li><p>如果需要建立多列组合的外键约束，必须使用表级约束法 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#为保证从表参照的主表存在，通常应该先建主表</span><br><span class="line"><span class="function">create table <span class="title">teacher_table3</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  #auto_increment:代表数据库的自动编码策略，通常用作数据表的逻辑主键</span></span></span><br><span class="line"><span class="params"><span class="function">  teacher_pass varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  teacher_name varchar(<span class="number">255</span>)，</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(teacher_name,teacher_pass)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span>；</span></span><br><span class="line"><span class="function">create table <span class="title">student_table3</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  #为本表建立主键约束</span></span></span><br><span class="line"><span class="params"><span class="function">  student_id <span class="type">int</span> auto_increment primary key,</span></span></span><br><span class="line"><span class="params"><span class="function">  student_name varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  java_teacher_name varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  java_teacher_pass varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  #指定两列的联合外键</span></span></span><br><span class="line"><span class="params"><span class="function">  foreign key (java_teacher_name,java_teacher_pass) references teacher_table3(teacher_name,teacher_pass)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>显示指定外键约束的名字，可使用<code>constraint</code>来指定名字 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#为保证从表参照的主表存在，通常应该先建主表</span><br><span class="line"><span class="function">create table <span class="title">teacher_table2</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  #auto_increment:代表数据库的自动编码策略，通常用作数据表的逻辑主键</span></span></span><br><span class="line"><span class="params"><span class="function">  teacher_id <span class="type">int</span> auto_increment,</span></span></span><br><span class="line"><span class="params"><span class="function">  teacher_name varchar(<span class="number">255</span>)，</span></span></span><br><span class="line"><span class="params"><span class="function">  primary key(teacher_id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span>；</span></span><br><span class="line"><span class="function">create table <span class="title">student_table2</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  #为本表建立主键约束</span></span></span><br><span class="line"><span class="params"><span class="function">  student_id <span class="type">int</span> auto_increment primary key,</span></span></span><br><span class="line"><span class="params"><span class="function">  student_name varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  java_teacher <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  #指定java_teacher参照到teacher_table的teacher_id列，并指定外键约束名为student_teacher_fk</span></span></span><br><span class="line"><span class="params"><span class="function"> constraint student_teacher_fk foreign key (java_teacher) references teacher_table2(teacher_id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>删除外键约束：<code>alter table后加 drop foreign key 约束名</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#删除student_table3表上名为student_table3_ibfk_1的外键约束</span><br><span class="line">alter table student_table3</span><br><span class="line">drop foreign key student_tables3_ibfk_1;</span><br></pre></td></tr></table></figure></p></li>
<li><p>增加外键约束：<code>add foreign key</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">alter table student_table3</span></span><br><span class="line"><span class="function">add foreign <span class="title">key</span><span class="params">(java_teacher_name,java_teacher_pass)</span> references <span class="title">teacher_table3</span><span class="params">(teacher_name,teacher_pass)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>自关联：参照自身 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">creater table <span class="title">foreign_test</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  foreign_id <span class="type">int</span> auto_increment primary key,</span></span></span><br><span class="line"><span class="params"><span class="function">  foreign_name varchar(<span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">  refer_id <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  foreign key(refer_id) references foreign_test(foreign_id)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure></p></li>
<li>删除主表记录：
<ul>
<li><code>on delete cascade</code>:删除主表记录时，把参照该主表记录的从表记录全部联级删除</li>
<li><code>on delete set null</code>：删除主表记录时，把参照该主表记录的从表记录的外键设为null</li>
<li>在建立外键约束后添加</li>
</ul></li>
</ul>
<h3 id="索引">5.3 索引</h3>
<ul>
<li>索引是一个数据库对象，从属于数据表</li>
<li>作用：加快对表的查询</li>
<li>索引在数据字典中独立存在，但不能独立存在，必须属于某个表</li>
<li>创建索引：
<ul>
<li><p>自动：<strong>当在表上定义主键约束、唯一约束和外键约束时，系统会为该数据自动创建对应的索引</strong></p></li>
<li><p>手动：用户可以通过<code>create index</code>语句来创建索引</p></li>
</ul></li>
<li>删除索引：
<ul>
<li>自动：数据表被删除时，该表上的索引自动被删除</li>
<li>手动：通过drop index语句来删除指定数据表上的指定索引</li>
</ul></li>
<li>一个表中可以有多个索引列，每个索引都可用于加速该列的查询速度</li>
</ul>
<p><strong>创建索引</strong>：</p>
<ul>
<li><p>在创建表时创建索引： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">creat table 表名</span><br><span class="line">(</span><br><span class="line">    字段<span class="number">1</span>，字段<span class="number">2.</span>.. </span><br><span class="line">    [unique]index [索引别名](列名)；<span class="comment">//默认与列名相同</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure> &gt;加unique限定索引的值必须是唯一的</p></li>
<li><p>在已存在的表上创建索引 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create (unique)index index_name</span><br><span class="line">on table_name (column[,column]...);</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#提高employees基于last_name字段的查询速度</span><br><span class="line"><span class="function">create index exm_last_name_idx</span></span><br><span class="line"><span class="function">on <span class="title">emoployees</span> <span class="params">(last_name)</span></span>;```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 对多列建立索引</span><br><span class="line">```cpp</span><br><span class="line">#同时对多列建立索引</span><br><span class="line"><span class="function">create index emp_last_name_idx2</span></span><br><span class="line"><span class="function">on <span class="title">employees</span><span class="params">(first_name , last_name)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用alter table创建索引 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alter table 表名</span><br><span class="line">add [unique] index [索引名] [列名]；</span><br></pre></td></tr></table></figure></p></li>
<li><p>删除索引 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">drop index 索引名 on 表名</span><br><span class="line">#示例</span><br><span class="line">#删除了employees表上的emp_last_name_idx2索引</span><br><span class="line">drop index emp_last_name_idx2</span><br><span class="line">on employees</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="sql常用dql语句">6. SQL常用DQL语句</h2>
<p>对于数据库来说，对数据库的操作离不开最重要的语句，而SQL语句就是对数据库操作的主流语言，可以说数据库和结构化查询语言<code>SQL</code>几乎是同义词，谈到<code>SQL</code>就当相于是在说数据库了。在数据库的操作中最常用的就是<strong>查询<code>select</code>,插入<code>insert into</code>，修改<code>update</code>和删除<code>delete</code>。</strong>也就是增删改差。</p>
<blockquote>
<p>其中<code>select</code>属于<code>DQL</code>数据库查询语句，其他则为<code>SML</code>数据库操作语句，这两种语句可与<code>SCL</code>数据库控制语句结合</p>
</blockquote>
<h3 id="select语句">6.1 select语句</h3>
<p><code>select</code>是数据库中最常用的语句，它能从一个表或多个表中检索数据，使用<code>select</code>至少给出两个信息：一是要检索什么，从什么地方检索：<code>select what from where;</code>。<strong>你可以看作调用<code>select</code>会生成一个临时表作为结果集输出。</strong></p>
<p>如下是最简单的两句查询语句： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//产看该表所有数据</span><br><span class="line">select * from employee;</span><br><span class="line">//查看特定数据</span><br><span class="line">select name 姓名,birthday 出生日期 from employee where sal=15500;</span><br></pre></td></tr></table></figure> 上面的两条语句中：<strong>第一条既没有过滤也没有对查询结果排序</strong>，通常来说都不会使用如下低效的查询语句；<strong>第二句虽然增加了过滤条件<code>sal=15500</code>,也使用文字显示代替<code>name</code>和<code>birthday</code>作为输出界面，但是也没有对结果排序</strong></p>
<h5 id="distinct关键字">6.1.1 distinct关键字</h5>
<p>如果一个表中的一列不是主键有多个相同的值，但是我们又想查询结果只显示不同的值，这个使用就要使用到<code>distinct</code>关键字 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//过滤表中重复数据。</span></span><br><span class="line">select DISTINCT english from student;</span><br><span class="line">select DISTINCT english,name from student;</span><br></pre></td></tr></table></figure></p>
<h5 id="limit关键字">6.1.2 limit关键字</h5>
<p>如果我们对检索的结果不要求其返回太多话，或者是限定其应该返回几行，这个时候就应该使用<code>limit</code>关键字:</p>
<ul>
<li><code>limit</code>后带一个数字的表示最多返回多少行</li>
<li><code>limit</code>后面带两个数字的表示从检索结果的的几行开始和返回的最多行数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from customer limit <span class="number">5</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">mysql&gt; select * from customer limit <span class="number">5</span>,<span class="number">5</span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br></pre></td></tr></table></figure>
<h5 id="order-by关键字">6.1.3 order by关键字</h5>
<p>一般来说，如果<code>select</code>语句没有对数据进行排序，则默认使用的数据在底层表中出现的顺序而显示，它可能是数据最初添加到表的顺序，但是一旦你进行过更新和删除，这个顺序就会受到MySQL重用回收存储空间的影响。因此应该采用关键字<code>order by</code>对检索结构进行排序。</p>
<ul>
<li>当<code>order by</code>后面只有一个字段名是，按该字段排序</li>
<li>当<code>order by</code>后面跟着多个字段名排序，首先是按照第一个字段排序，然后看排序后是否有相同的第一个字段值的记录，如果有，则对有相同第一个字段值的记录进行第二个字段排序。</li>
<li>默认情况下，使用的是升序排序，如果相要使用降序排序，则应该在后面添加<code>desc</code>,如<code>...order by name DESC;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name 姓名 from customer order by name;</span><br><span class="line">+---------+</span><br><span class="line">| 姓名    |</span><br><span class="line">+---------+</span><br><span class="line">| jack    |</span><br><span class="line">| lili    |</span><br><span class="line">| tom     |</span><br><span class="line">| trl     |</span><br><span class="line">| trluper |</span><br><span class="line">| 小明    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<h5 id="where关键字">6.1.4 where关键字</h5>
<p>在上面首次介绍<code>select</code>时，我们已经使用了<code>where</code>关键字，<code>where</code>关键字时对检索记录的一个筛选，只有符合<code>where</code>后面的条件才会输出这些记录 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#普通条件显示，默认是按升序排列，这里使用desc表明采用降序</span><br><span class="line">mysql&gt; select * from customer where salary&gt;=<span class="number">15000</span> order by salary desc;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#非空显示</span></span><br><span class="line"><span class="function">mysql&gt; select * from customer where salary is <span class="keyword">not</span> null</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<p>在这里我们还需要介绍能够与<code>where</code>组合的更高级的过滤语句关键字<code>and、or</code>。上面使用<code>where</code>都是单一条件,如果要求要符合多个条件的使用怎么办？那当然是使用<code>and\or</code>来解决</p>
<ul>
<li><code>and</code>：同c++中的<code>&amp;&amp;</code>起一样的作用，优先级高于<code>or</code></li>
<li><code>or</code>：同c++中的<code>||</code>起一样的作用</li>
</ul>
<h5 id="between-.-and-.">6.1.5 between . and .</h5>
<p>为检查符号某个范围的，可以使用<code>between</code>关键，它的功能于<code>in+[]</code>. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select Math from student where Math between <span class="number">90</span> <span class="keyword">and</span> <span class="number">92</span>;</span><br><span class="line">+------+</span><br><span class="line">| Math |</span><br><span class="line">+------+</span><br><span class="line">|   <span class="number">92</span> |</span><br><span class="line">|   <span class="number">90</span> |</span><br><span class="line">+------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="in关键字">6.1.5 IN关键字</h5>
<p><code>IN</code>操作符用来指定条件的范围，范围中的每个条件都可以进行匹配，它的功能与<code>or</code>很相像，使用<code>IN</code>是因为：</p>
<ul>
<li>在使用长的合法选项清单是，<code>IN</code>操作符更加直观清楚，语句也不如<code>or</code>那样长冗余。</li>
<li>在使用<code>IN</code>时，计算的次序更容易管理</li>
<li><code>IN</code>操作一般比<code>or</code>操作符清单执行的更快</li>
<li><code>IN</code>操作符最多的优点是可以包含其他<code>select</code>语句，更加动态的建立<code>where</code>子句。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="function">select * from customer where salary <span class="title">in</span><span class="params">(<span class="number">12000</span>,<span class="number">15000</span>,<span class="number">25000</span>)</span></span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="not关键字">6.1.6 NOT关键字</h5>
<p><code>NOT</code>关键字有且只有一个功能，那就是否定它之后的紧跟的条件，NOT肯对<code>and、or</code>没什么用，但是对于<code>IN</code>来说却是绝配。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="function">select * from customer where salary <span class="keyword">not</span> <span class="title">in</span><span class="params">(<span class="number">12000</span>,<span class="number">15000</span>,<span class="number">25000</span>)</span></span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| tom  | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="like和通配符">6.1.7 LIKE和通配符</h5>
<p><strong>通配符</strong>指的是用来匹配一部分的特殊字符；<strong>搜索模式</strong>则是指在搜索语句中使用字面值、通配符或两者组合成的搜索条件。<strong>使用通配符是必须在前面使用<code>LIKE</code>关键字，该关键字告诉MySQL后面跟着的搜索模式是使用通配符匹配而不是直接使用字面值匹配</strong></p>
<ul>
<li><code>%</code>通配符：该通配符是最常使用的，它可以表示任意字符出现任意次数，如<code>trl%</code>表示以<code>trl</code>开头的任意名称</li>
<li><code>_</code>通配符：同<code>%</code>是一样的作用，但是只匹配单个任意字符，即只匹配一次。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from customer where name like <span class="string">&#x27;trl%&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p>虽然通配符很有用，但是代价是很大的，它的搜索一般比前面的其他搜索所花时间更多，一般来说使用通配要遵循以下技巧：</p>
<ul>
<li>尽量不使用，如果有其他操作符能够达到相同效果，则应该使用这些操作符</li>
<li>假如一定要使用，则不要把通配符放在搜索模式的开始处，因为这样的搜索极慢</li>
</ul>
<h5 id="select支持算术运算">6.1.8 select支持算术运算</h5>
<p>对于MySQL中的数字类型，运行使用<code>* + - /</code>运算。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select salary,add_salary,salary+add_salary as finalSalary from custommer order by id;</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line">| salary | add_salary | finalSalary |</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line">|  <span class="number">12000</span> |        <span class="number">300</span> |       <span class="number">12300</span> |</span><br><span class="line">|  <span class="number">12500</span> |        <span class="number">300</span> |       <span class="number">12800</span> |</span><br><span class="line">|  <span class="number">15000</span> |        <span class="number">300</span> |       <span class="number">15300</span> |</span><br><span class="line">|  <span class="number">15000</span> |        <span class="number">300</span> |       <span class="number">15300</span> |</span><br><span class="line">|  <span class="number">25000</span> |        <span class="number">300</span> |       <span class="number">25300</span> |</span><br><span class="line">|  <span class="number">16000</span> |        <span class="number">300</span> |       <span class="number">16300</span> |</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="group-by分组查询">6.1.9 group by分组查询</h5>
<ul>
<li>表达式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">group by 属性名 [having表达式] [with rollup]</span><br></pre></td></tr></table></figure></li>
<li>单独使用，只会列出第一个出现的值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 只会筛选出第一个出现GradeName1的student的数据</span><br><span class="line">select * from t_student group by gradeName;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>需要注意，最新的版本的 MySQL 标准<strong>不再允许 <code>SELECT</code>列表，<code>HAVING</code> 条件语句，或 <code>ORDER BY</code> 语句中出现 <code>GROUP BY</code> 中未列表的可聚合列。而 MySQL 中有一个状态 <code>ONLY_FULL_GROUP_BY</code> 来标识是否遵从这一标准，默认为开启状态。</strong></p>
</blockquote>
<p>所以这样的语句是不可以的: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT gender, </span><br><span class="line">       last_name </span><br><span class="line">FROM   employees </span><br><span class="line">GROUP  BY gender </span><br></pre></td></tr></table></figure></p>
<p>将<code>last_name</code> 从 <code>SELECT</code> 中移除或将其添加到 <code>GROUP BY</code> 中都可以修复： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT gender,</span><br><span class="line">FROM   employees </span><br><span class="line">GROUP  BY gender </span><br><span class="line"></span><br><span class="line">SELECT gender,</span><br><span class="line">last_name</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY gender,</span><br><span class="line">last_name</span><br></pre></td></tr></table></figure> 但这样的修改查询出来就可能就不是想要的结果了。针对以上情况，可以有三种方式来解决：</p>
<ul>
<li><strong>关闭 ONLY_FULL_GROUP_BY</strong>：可以选择关掉 MySQL 的 <code>ONLY_FULL_GROUP_BY</code> 模式，有两种方式.
<ul>
<li><strong>通过设置 <code>sql_mode</code> 来关闭。首先查看变更前的 sql_mode：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @@sql_mode;</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| @@sql_mode                                                                                                            |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure> 通过以下脚本关闭 ： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SET SESSION sql_mode=(SELECT <span class="built_in">REPLACE</span>(@@sql_mode,<span class="string">&#x27;ONLY_FULL_GROUP_BY,&#x27;</span>,<span class="string">&#x27;&#x27;));</span></span><br></pre></td></tr></table></figure> 再次查询 @<span class="citation" data-cites="sql_mode">@sql_mode</span> 返回中应该已经没有该模式了。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @@sql_mode;</span><br><span class="line">+----------------------------------------------------------------------------------------------------+</span><br><span class="line">| @@sql_mode                                                                                         |</span><br><span class="line">+----------------------------------------------------------------------------------------------------+</span><br><span class="line">| STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION |</span><br><span class="line">+----------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></li>
<li><strong>第二种是找到 MySQL 配置文件修改并保存。MySQL 的配置文件名为 <code>my.cnf</code></strong>，可通过以下命令查看你位置： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ mysql --help | grep cnf</span><br><span class="line">                      order of preference, my.cnf, $MYSQL_TCP_PORT,</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/etc/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure> 找到后编辑并保存，重启 MySQL 后生效。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">-sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line">+sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure> 如果文件中没有 <code>sql_mode</code> 配置项可手动添加上。</li>
</ul></li>
</ul>
<blockquote>
<p><strong>注：因为 <code>ONLY_FULL_GROUP_BY</code> 更加符合 SQL 标准，所以不建议关掉。使用其他方法代替</strong></p>
</blockquote>
<ul>
<li><p><code>ANY_VALUE()</code>：<strong>还可以通过 <code>ANY_VALUE()</code> 来改造查询语句以避免报错。</strong>使用 ANY_VALUE() 包裹的值不会被检查，跳过该错误。所以这样是可以的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SELECT gender, </span><br><span class="line">       <span class="built_in">ANY_VALUE</span>(last_name) </span><br><span class="line">FROM   employees </span><br><span class="line">GROUP  BY gender </span><br></pre></td></tr></table></figure></p></li>
<li>添加列间的依赖：说到底上面的错误产生是<strong>因为在进行聚合的时候有不能确定的列参与了进来。</strong>假如让 <code>gender</code> 变成不重复的主键，<code>last_name</code> 便与<code>gender</code> 产生了一种关系，即 <code>gender</code> 可唯一确定 <code>last_name</code>。此时便可进行 <code>GROUP BY</code> 了
<ul>
<li><p>与 <code>group concat()</code> 函数一起使用：会把所有值列出来 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-- 会把所有属于gradeName的studentName全部组合在一起列出来</span><br><span class="line">select gradeName,<span class="function">group <span class="title">concat</span><span class="params">(studentName)</span> from t_student  group by gradeName</span>;</span><br></pre></td></tr></table></figure></p></li>
<li>与聚合函数一起使用</li>
<li><p>与 <code>having</code> 一起使用，限制输出结果 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-- 只会输出学生名字多于三个的年级及学生名字</span><br><span class="line">select gradeName,<span class="function">group <span class="title">concat</span><span class="params">(studentName)</span> from t_student  group by gradeName having <span class="title">count</span><span class="params">(studentName)</span> &gt;3</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>与 <code>with rollup</code> 一起使用，在最后一行增加一个叠加总和</p></li>
</ul></li>
</ul>
<h4 id="正则表达式进行搜索">6.2 正则表达式进行搜索</h4>
<p>前面介绍的过滤使用匹配、比较和通配符进行操作寻找符合的数据，对于一些基本情况来说足够了，但是随着过滤条件的增加，<code>where</code>子句本身的复杂性也在增加，这时候就应当使用正则表达式匹配。<strong>使用正则表达式必须在正则表达式（文本）前面使用<code>regexp</code>关键字，同·<code>like</code>一样告诉MySQL后面使用正则表达式进行匹配</strong>。</p>
<p>注意在正则表达式中，对于有特殊意义的符号，如果你不希望他被翻译成则表示里的特殊符号，应该加<code>\\</code>进行转义，如<code>. | []</code>这些通过<code>\\. \\| \\[\\]</code>经过转义后才能被认为是字符串的一部分。</p>
<h5 id="section">6.2.1 |</h5>
<p>在正则表达式中<code>|</code>上面的<code>or</code>是起到一样的作用 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from customer where name regexp <span class="string">&#x27;trl|tom&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<h5 id="section-1">6.2.2 []</h5>
<p><code>[]</code>的作用是匹配方括号内的字符之一，如<code>[123]</code>是指匹配1或2或3，同样为省略书写也可以写出<code>[1-3]</code>是同样的表示。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from customer where name regexp <span class="string">&#x27;[a-z]rl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<h5 id="section-2">6.2.3 .</h5>
<p><code>.</code>也是正则表达式中一个特殊字符，它表示匹配任意一个字符。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;.rl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------|</span><br></pre></td></tr></table></figure></p>
<h5 id="匹配字符类">6.2.4 匹配字符类</h5>
<p>MySQL中存在一些已经定义的字符集，这样就不用你自己手动去阻止这些字符集 <img src="/2022/07/30/MySQL/charSet.png" width="700"></p>
<h5 id="匹配多个字符">6.2.5 匹配多个字符</h5>
<p>至今为止，上面介绍的都是匹配单个字符的情况，是否有匹配多个字符的正则表达式特殊字符呢，当然是有的。 <img src="/2022/07/30/MySQL/muchChar.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;trl*&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意这里的重复元字符是指能够匹配当前元字符的前一个字符的多个重复值，如<code>trl*</code>,匹配<code>trl\trll\trll\trlll...\..</code>等</p>
<h5 id="定位符">6.2.6 定位符</h5>
<p>到目前为止，上面的匹配规则都是匹配一个串中任意一个为止的文本，为了能够指定匹配的为止，给出了定位符： <img src="/2022/07/30/MySQL/locate.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;^trl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select *from customer where name regexp &#x27;^trl$&#x27;</span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure> 一般来说，其他的正则表达式字符都应当与定位符结合使用</p>
<h3 id="dml语句">6.3 DML语句</h3>
<h4 id="insert语句">6.3.1 insert语句</h4>
<p>插入数据使用<code>insert into</code>，如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入完整数据</span></span><br><span class="line"><span class="function">insert into employee <span class="title">values</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="number">15000</span>,<span class="string">&#x27;1998-05-09&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;2021-1-9&#x27;</span>)</span>,<span class="params">(<span class="number">2</span>,<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">15000</span>,<span class="string">&#x27;1998-03-21&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;2021-1-9&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//与select子查询结合使用</span></span><br><span class="line"><span class="function">insert into  <span class="title">employee</span><span class="params">(id,name,salary,birthday,rank,hiredate)</span> select id,name,salary,birthday,rank,hiredate from employee_1 where name</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="update-set语句">6.3.2 update set语句</h4>
<p>修改更新数据使用<code>update</code>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; update customer set salary=salary+<span class="number">500</span>;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: <span class="number">6</span>  Changed: <span class="number">6</span>  Warnings: <span class="number">0</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="delete语句">6.3.3 delete语句</h4>
<p><code>delete</code>用来删除记录 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除所有数据</span></span><br><span class="line"><span class="keyword">delete</span> from employee;</span><br><span class="line"><span class="comment">//删除指定数据</span></span><br><span class="line"><span class="keyword">delete</span> form employee where name=<span class="string">&#x27;jack&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用truncate删除表中记录。无条件 效率高</span></span><br><span class="line">truncate table employee;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数">4. 函数</h3>
<p>有时候，我们对于搜索到的列的一些东西需要得到总和、平均和拼接，总之，我们不希望查找后的结果仍然是以底层表所存储的那样呈现上来,<strong>而是希望在<code>select</code>运行阶段经过处理后得到我们想要的结果，这时候就用到了想要的MySQL函数。</strong>大多数SQL支持以下函数：</p>
<ul>
<li>用于处理文本串的文本函数，如删除或填充、大小写转换等。</li>
<li>用于数值数据进行算术的操作，如绝对值、求和等</li>
<li>用于处理日期和时间值并从时间值提取特定成分</li>
<li>返回DBMS正使用的特殊信息的系统函数，如返回登录信息、检查版本细节等</li>
</ul>
<h4 id="拼接字段">4.1 拼接字段</h4>
<p>假如我们想在<code>select</code>中让输出的结果的一个字段即显示<code>name</code>又显示<code>salary</code>,而不是分开两个字段显示，这样就用到了<code>concat()</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">concat</span><span class="params">(name,<span class="string">&#x27;:&#x27;</span>,salary,<span class="string">&#x27; &#x27;</span>,hiredate)</span> as &#x27;name:salary hiredate<span class="string">&#x27;&#x27; from customer order by id;</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">| name:salary hiredate     |</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">| jack:12000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| tom:12500 2022-08-03     |</span></span></span><br><span class="line"><span class="string"><span class="function">| lili:15000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| 小明:15000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| trluper:25000 2022-08-03 |</span></span></span><br><span class="line"><span class="string"><span class="function">| trl:16000 2022-08-03     |</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">6 rows in set (0.00 sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：</em></strong>在MySQL中拼接两个字段只能使用<code>concat()</code>函数，而在其他的数据库中则运行使用<code>+</code>直接拼接。</p>
<h4 id="文本处理函数">4.2 文本处理函数</h4>
<p><img src="/2022/07/30/MySQL/stringFunc.png" width="700"></p>
<h4 id="日期和时间处理函数">4.3 日期和时间处理函数</h4>
<p><img src="/2022/07/30/MySQL/dateFunc.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">now</span><span class="params">()</span>,<span class="title">year</span><span class="params">(now())</span> as 年,<span class="title">month</span><span class="params">(now() )</span>as 月,<span class="title">date</span><span class="params">(now())</span> as 日</span>; </span><br><span class="line">+---------------------+------+------+------------+</span><br><span class="line">| <span class="built_in">now</span>()               | 年   | 月   | 日         |</span><br><span class="line">+---------------------+------+------+------------+</span><br><span class="line">| <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">25</span> | <span class="number">2022</span> |    <span class="number">8</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------------------+------+------+------------+</span><br></pre></td></tr></table></figure></p>
<h4 id="数值处理函数">4.4 数值处理函数</h4>
<p><img src="/2022/07/30/MySQL/numberFunc.png" width="700"></p>
<h4 id="汇总函数">4.5 汇总函数</h4>
<p>有时候我们需要对表中的数据进行汇总，而不是把它们实际检索出来，这时候就需要这样的函数，因此MySQL专门设立了<strong>汇总函数</strong> <img src="/2022/07/30/MySQL/finalFunc.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#统计一个班级共有多少学生？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student</span>;</span><br><span class="line">#统计数学成绩大于<span class="number">90</span>的学生有多少个？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student where math&gt;90</span>;</span><br><span class="line">#统计总分大于<span class="number">250</span>的人数有多少？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student where math+chinese+english&gt;250</span>;</span><br><span class="line">#统计一个班级数学总成绩？</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span> from student</span>;</span><br><span class="line">#统计一个班级语文、英语、数学各科的总成绩</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span>, <span class="title">sum</span><span class="params">(chinese)</span>, <span class="title">sum</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#统计一个班级语文、英语、数学的成绩总和</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math+chinese+english)</span>from student</span>;</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span>+<span class="title">sum</span><span class="params">(chinese)</span>+<span class="title">sum</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#求一个班级数学平均分？</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math)</span> from student</span>;</span><br><span class="line">#求一个班级总分平均分</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math+chinese+english)</span>from student</span>;</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math)</span>+<span class="title">avg</span><span class="params">(chinese)</span>+<span class="title">avg</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#求班级最高分和最低分</span><br><span class="line"><span class="function">select <span class="title">max</span><span class="params">(math+chinese+english)</span>,<span class="title">min</span><span class="params">(math+chinese+english)</span> from student</span>;</span><br></pre></td></tr></table></figure>
<h3 id="其他查询操作">4. 其他查询操作</h3>
<p>在这里将会介绍分组查询、子查询和组合查询等查询手段，进一步掌握查询检索方法。</p>
<h4 id="分组查询">4.1 分组查询</h4>
<p>分组查询得关键字为<code>group by</code>，使用该关键字能够使得检索后得结果按照你想要得情况进行分组,<strong>下述得<code>group by</code>句子指示是按<code>salary</code>排序并分组</strong>,这样一来我们就不用一一调用<code>select salary count(*) where salary=各个数值;</code>语句，只需要以<code>group by</code>就能执行全部，同时还有附有<code>order by</code>进行排序，如下所示： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#这句sql语句相当于<span class="function">select salary <span class="title">count</span><span class="params">(*)</span> where salary</span>=各个数值 order by salary;</span><br><span class="line">mysql&gt; select salary,<span class="built_in">count</span>(*) from customer group by salary;</span><br><span class="line">+--------+----------+</span><br><span class="line">| salary | <span class="built_in">count</span>(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|  <span class="number">12500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">13000</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">15500</span> |        <span class="number">2</span> |</span><br><span class="line">|  <span class="number">25500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">16500</span> |        <span class="number">1</span> |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="number">5</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>group by</code>分组数据，还允许对分组进行过滤，但在这里使用得不是<code>where</code>，而应该使用<code>having</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select salary,<span class="built_in">count</span>(*) from customer group by salary having salary&gt;=<span class="number">13000</span>;</span><br><span class="line">+--------+----------+</span><br><span class="line">| salary | <span class="built_in">count</span>(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|  <span class="number">13000</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">15500</span> |        <span class="number">2</span> |</span><br><span class="line">|  <span class="number">25500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">16500</span> |        <span class="number">1</span> |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="子查询">4.2 子查询</h4>
<p>迄今为止，我们上面学的得<code>select</code>查询语句都是单语句得简单查询，即都是从单个数据表中检索数据得单条语句。还有一种嵌套在其他查询中查询，内部的查询语句称为<strong>子查询</strong>。有子查询的语句从内向外处理</p>
<p><strong>使用子查询是因为在实际的应用中我们总不可能用一张表来存储全部的数据，而是让每一个表存储特定的内容，这样一来，我们就极有可能会用到一个表中的数据作为另一个表的字段名称或者条件来进行查询</strong>，如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作为条件</span></span><br><span class="line"><span class="function">select cust_id from order_num <span class="title">in</span><span class="params">(select order_num from orderitems where prod_id=<span class="string">&#x27;TNT2&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为计算字段</span></span><br><span class="line">select cust_name,cust_state,</span><br><span class="line">(select <span class="built_in">count</span>(*) from orders where order.cust_id=customer.cust_id) as orders from customer order by cust_name;</span><br></pre></td></tr></table></figure></p>
<h4 id="组合查询">4.3 组合查询</h4>
<p><strong>组合查询是将多个<code>select</code>语句的组合成一个结果集返回，这些组合查询通常称为并<code>union</code>或复合查询</strong>。使用组合查询的情况有以下两点：</p>
<ul>
<li>在多个查询中从不同表返回类似结构的数据要形成一个结果集</li>
<li>对单个表执行多个查询，要按单个查询结果集返回</li>
</ul>
<p>这时就可使用<code>union</code>操作符来组合数条SQL查询语句，<strong>使用时只需要在各条<code>select</code>语句之间加上<code>union</code>关键字即可，返回的结果集中会自动的去重</strong>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name,salary from employee where name=<span class="string">&#x27;trluper&#x27;</span></span><br><span class="line">   -&gt; <span class="keyword">union</span> select name,salary froom employee where name=<span class="string">&#x27;trl&#x27;</span>;</span><br><span class="line">+---------+--------+</span><br><span class="line">| name    | salary |</span><br><span class="line">+---------+--------+</span><br><span class="line">| trluper |  <span class="number">25500</span> |</span><br><span class="line">| trl     |  <span class="number">16500</span> |</span><br><span class="line">+---------+--------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>使用<code>union</code>时的规则:</strong></p>
<ul>
<li><code>union</code>必须由两条或以上的<code>select</code>语句上才能使用</li>
<li><code>union</code>的每个查询必须包含相同的列、表达式或聚集函数（不要求相同次序列出），输出会以第一个<code>select</code>语句的列名称为准</li>
<li>列数据必须兼容：类型不必完全相同，但是DBMS可以隐式转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select salary from employee where name=<span class="string">&#x27;trluper&#x27;</span>  <span class="keyword">union</span> select job_name from employyee_job where id=<span class="number">5</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| salary    |</span><br><span class="line">+-----------+</span><br><span class="line">| <span class="number">25500</span>     |</span><br><span class="line">| c++开发   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select name,salary from employee where name</span>=<span class="string">&#x27;trluper&#x27;</span>  <span class="keyword">union</span> <span class="title class_">select</span> salary,name frmom employee where name=<span class="string">&#x27;trl&#x27;</span>;</span><br><span class="line">+---------+--------+</span><br><span class="line">| name    | salary |</span><br><span class="line">+---------+--------+</span><br><span class="line">| trluper | <span class="number">25500</span>  |</span><br><span class="line">| <span class="number">16500</span>   | trl    |</span><br><span class="line">+---------+--------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="连结表多表查询">5. 连结表（多表查询）</h3>
<p><strong>我们知道将数据分不同种类存储到不同的表能够更有效率，也更方便管理，单是我们不可能在检索的时候对单个表单个表的检索，我们希望能够将不同表但相同对象的数据放置在一起，这和时候就用到了连结表。</strong>SQL最强大的功能就是能在数据检索查询的执行中连结<code>join</code>表，连结表不存在于数据库的存储中，它是在<code>select</code>运行过程依据条件创建而成。一般来说使用连结表最好是定义<strong>主键和外键</strong>，通过主外键将两者两者连结在一起。 <img src="/2022/07/30/MySQL/sql-join.png" width="700"></p>
<p>下面的例子中employee的<code>ID</code>为主键，<code>employee_job</code>的外键为<code>ID</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee,employee_job where employee.id=employee_jjob.id order by salary desc;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面使用<code>where</code>子句来建立连结，但是对于连结表这一知识点来说，最好是使用它的特定规则来实现连结比较好即使用<code>join</code>关键字。如下介绍当中的：笛卡儿积、内连结、外连结。</p>
<h4 id="笛卡儿积交叉连接">5.1 笛卡儿积（交叉连接）</h4>
<p>笛卡尔集是指两个集合<code>A</code>和<code>B</code>的乘积,如下 <figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">例如，有 A 和 B 两个集合，它们的值如下：</span><br><span class="line">A = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">B = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">集合 A×B 和 B×A 的结果集分别表示为：</span><br><span class="line">A×B=&#123;<span class="comment">(1,3)</span>, <span class="comment">(1,4)</span>, <span class="comment">(1,5)</span>, <span class="comment">(2,3)</span>, <span class="comment">(2,4)</span>, <span class="comment">(2,5)</span> &#125;;</span><br><span class="line">B×A=&#123;<span class="comment">(3,1)</span>, <span class="comment">(3,2)</span>, <span class="comment">(4,1)</span>, <span class="comment">(4,2)</span>, <span class="comment">(5,1)</span>, <span class="comment">(5,2)</span> &#125;;</span><br></pre></td></tr></table></figure> 我们发现笛卡儿积不遵从弄个交换律即<code>A*B≠B*A</code>。多表查询遵循的算法就是以上提到的笛卡尔积，表与表之间的连接可以看成是在做乘法运算。<strong>在实际应用中，应避免使用笛卡尔积，因为笛卡尔积中容易存在大量的不合理数据，简单来说就是容易导致查询结果重复、混乱。</strong>笛卡儿积使用<code>cross join</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee cross join employee_job order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 老大         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 开发         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 技术服务     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 产品经理     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | c++开发      |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| lili    |  <span class="number">15500</span> | c++开发      |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 产品经理     |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 老大         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 销售         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | c++开发      |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 销售         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 老大         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 开发         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | c++开发      |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 开发         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 销售         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 技术服务     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 产品经理     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 开发         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 技术服务     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 产品经理     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 销售         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 产品经理     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 老大         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 销售         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">36</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="内连接">5.2 内连接</h4>
<p><strong>基于两个表直接的主键和外键相等的查询称为内部链接</strong>。只返回满足<code>on</code>后连接条件的数据（两边都有的才显示）。（对应oracle等值连接。） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee a inner join employee_job b on a.id=b.id order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br></pre></td></tr></table></figure></p>
<h4 id="外连接">5.3 外连接</h4>
<p>外连结有左外连结和右外连结，外连接与内连接的不同在于外连接对于另一个表会显示全部记录，不管符不符合后边<code>on</code>的条件，另一个表只显示符合条件的数据。</p>
<h5 id="左外连结">5.3.1 左外连结</h5>
<p><code>left join</code>是<code>left outer join</code>的简写，它的全称是左外连接，是外连接中的一种。外连接，左表<code>a</code>的记录将会全部表示出来，而右表<code>b</code>只会显示符合搜索条件的记录。右表记录不足的地方均为<code>NULL</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee a left join employee_job b on a.id=b.idorder by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| Adson   |  <span class="number">19000</span> | <span class="literal">NULL</span>         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">7</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>1、<code>on</code>条件是在生成临时表时使用的条件，它不管<code>on</code>中的条件是否为真，都会返回左边表中的记录。</li>
<li>2、<code>where</code> 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有<code>left join</code>的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li>
</ul>
<h5 id="右外连接">5.3.2 右外连接</h5>
<p>效果同左外是相反的 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ysql&gt; select name,salary,job_name from employee a right join employee_job b on a.id=b.id order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="视图">6. 视图</h3>
<p>视图是虚拟的比表，与包含数据的表不同，视图只包含使用时动态检索数据的查询<strong>。即视图是将一个查询语句包装成一个有名字的虚拟表，我们可以通过该虚拟表来使用这个查询语句</strong>。因此对于视图来说具有以下优点：</p>
<ul>
<li>重用SQL语句</li>
<li>简化了复杂的SQL操作，在编写查询后，我们可以很方便重用它，而不用知道它的细节</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据，可以给用户授予表的特定部分的权限而不是整个表的访问权限</li>
<li>更改数据格式和表示。视图可以返回与底层表不同的数据格式和表示。</li>
<li>节省空间，有了视图，不用在去创建一个同视图一样的表，在有需要的使用视图生成一个临时表即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; create view employee_view as select name,salary,hiredate from employee,employee_job where employee.id=employee_job.id;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; show tables</span>;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| employee       |</span><br><span class="line">| employee_job   |</span><br><span class="line">| employee_view  |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">3</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select * from employee_view</span>;</span><br><span class="line">+---------+--------+------------+</span><br><span class="line">| name    | salary | hiredate   |</span><br><span class="line">+---------+--------+------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     |  <span class="number">13000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    |  <span class="number">15500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper |  <span class="number">25500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     |  <span class="number">16500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+--------+------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p><strong><em>注意</em></strong>：通常来说，视图是支持更新的，即可以对视图使用和表一样的<code>insert\update\delete</code>操作，因为视图只是一个包装<code>select</code>语句的虚拟表，因此更新一个视图会更新其相关的底层表，对视图的更新就是对底层表的更新。<strong>但是并不是所有的视图都支持更新，如果视图不能正确的确定被更新的基数据所在就不能更新。</strong></p>
<h4 id="存储过程">7. 存储过程</h4>
<p>视图能够很好的重复利用SQL语句，但是只能存储<code>select</code>语句，存储过程能够解决这个问题，<strong>存储过程（PROCEDURE）是事先经过编译并存储在数据库中的一段SQL语句的集合。调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是很有好处的。</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li>简化操作，存储过程通过把处理语句封装在容易使用的单元中。</li>
<li>简化对变动的管理，如果有表名、列名的变动时，只需要改动存储过程内的代码即可。</li>
<li>提高性能，使用存储过程比使用单独的SQL语句要快。</li>
<li>安全性大，因此使用的是存储过程内的SQL语句，数据库管理员是可以向访问数据库中存储过程的应用程序授予适当的权限，而不是向基础数据库表提供任何权限。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果使用大量的存储过程，那么使用这些存储过程的每个连接的内存使用量将大大增加</li>
<li>对于复杂的业务逻辑的存储过程的设计较为困难</li>
<li>开发和维护存储过程都不容易。</li>
<li>对数据库依赖程度较高，移值性差。</li>
</ul>
<h4 id="建立和调用存储过程">7.1 建立和调用存储过程</h4>
<p>存储过程就类似于c++中的函数，需要先定义，使用时需要调用。存储过程可以定义参数，参数分为<code>IN、OUT、INOUT</code>类型三种类型。调用存储过程使用<code>call</code></p>
<ul>
<li><code>IN</code>类型的参数表示接受调用者传入的数据；</li>
<li><code>OUT</code>类型的参数表示向调用者返回数据；</li>
<li><code>INOUT</code>类型的参数即可以接受调用者传入的参数，也可以向调用者返回数据。</li>
<li><code>declare</code>指示在存储过程中定义的变量，可使用<code>set</code>设置值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-- 创建存储过程</span><br><span class="line"><span class="function">CREATE PROCEDURE <span class="title">demo2</span><span class="params">(IN s_sex CHAR(<span class="number">1</span>),OUT s_count INT)</span></span></span><br><span class="line"><span class="function">	-- 存储过程体</span></span><br><span class="line"><span class="function">	BEGIN</span></span><br><span class="line"><span class="function">		-- 把SQL中查询的结果通过INTO赋给变量</span></span><br><span class="line"><span class="function">		SELECT <span class="title">COUNT</span><span class="params">(*)</span> INTO s_count FROM student WHERE sex</span>= s_sex;</span><br><span class="line">		declare id <span class="type">int</span>;</span><br><span class="line">		set id=<span class="number">15</span>;</span><br><span class="line">	END;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程</span><br><span class="line"><span class="function">call <span class="title">demo2</span><span class="params">(<span class="string">&#x27;男&#x27;</span>,nums)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的<code>SELECT COUNT(*) INTO s_count FROM student WHERE sex= s_sex;</code>语句将统计到的数目存储到<code>s_count</code>以返回给调用着，因为调用后他这是将结果返回给了<code>s_count</code>并没有输出结果集，可通过<code>select</code>输出 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">select s_count;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除和检查存储过程">7.2 删除和检查存储过程</h4>
<p>可以通过<code>show create procedure</code>查看存储过程的详细信息，通过<code>drop procedure</code>删除存储过程 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">show create procedure demo2;</span><br><span class="line">drop procedure demo2;</span><br></pre></td></tr></table></figure></p>
<h3 id="触发器">8. 触发器</h3>
<p>触发器的作用是让某一条语句在某事件发生时会自动执行。创建触发器时必须给出四条信息：</p>
<ul>
<li>唯一的触发器名称</li>
<li>触发器的关联表</li>
<li>触发器应该响应的活动，如<code>select、insert、update、delete</code>等</li>
<li>触发器何时执行<code>befor\after</code></li>
</ul>
<p>创建触发器使用<code>create trigger</code>,如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">create trigger newproduct after insert on products <span class="keyword">for</span> each row select NEW.product_id;</span><br></pre></td></tr></table></figure> 上面这条触发器名称为<code>newproduct</code>,触发时机为在<code>products</code>表对每个插入行后会执行<code>select NEW.product.id</code>。这里<code>NEW</code>时关键字指定该插入行</p>
<h3 id="事务处理">9. 事务处理</h3>
<p>MySQL支持多种数据库引擎，最常见的是<code>MyISAM</code>和<code>InnoDB</code>。前者不支持事务处理，后者支持。<strong>事务处理可以用来维护数据的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行，事务处理是一种机制，利用事务处理可以保证成批的MySQL操作不会只执行一部分，如果全部执行那没问题，如果在执行过程中发生错误，它就会进行回退以恢复到数据库以前安全版本</strong>。</p>
<p>上面的这种事务处理机制保证了数据的完整性和安全性。事务处理需要知道的几个关键词如下：</p>
<ul>
<li>事务<code>transaction</code>：指一组SQL语句</li>
<li>回退<code>rollback</code>：指撤销指定SQL语句的过程</li>
<li>提交<code>commit</code>：指将未存储的SQL语句写入数据库表</li>
<li>保留的<code>savepoint</code>：指事务处理设置的临时占位符，你可以对它发布回退</li>
</ul>
<h4 id="事务的特性">9.1 事务的特性</h4>
<h5 id="事务的四大特性acid">9.1.1 事务的四大特性acid</h5>
<ul>
<li><strong>原子性</strong>：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的操作要么全部提交成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>：数据库总是从一个一致性状态转移达到另一个一致性状态，一致性状态就是由事务原子性保障，一个事务提交了，那是ok的，一个事务未提交，那也是OK的。</li>
<li><strong>隔离性</strong>：通常来说，一个事务所做的修改在未提交以前，对其他事务是不可见的。事务间是互不干扰的。</li>
<li><strong>持久性</strong>：一旦事务提交了，其所做的修改会永久保存到数据库总中，即使系统崩溃，修改的数据也不会丢失，（持久性不能做到100%保证策略，如果数据库本身就能做到吃性，那么要备份又有什么用呢）</li>
</ul>
<h5 id="事务的隔离级别">9.1.2 事务的隔离级别</h5>
<p><strong>事务的并发问题：</strong></p>
<ul>
<li>脏读 : 能读取到另一个未提交的数据（最可怕）</li>
<li>不可重复读: 对同一记录的两次读取不一致, 因为另一事务对该记录做了修改</li>
<li>幻读(虚读): 对同一记录的两次查询不一致, 因为另一事务插入了一条记录</li>
</ul>
<p><strong>四大隔离级别:</strong></p>
<ul>
<li><p><strong>未提交读(<code>read uncommitted</code>)</strong>：在该隔离级别，事务中的修改，即使没有提交，对其他事务也都是可见的。<strong>事务可以读取未提交的数据，这也被称为脏读</strong>。这个级别会导致喝多问题，从性能上来说，该级别没有比其他级别好很多，一般不推荐使用。</p></li>
<li><strong>提交读(<code>read committed</code>)：在该级别，一个事务开始时只能看见已经提交的事务的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，因此也可称为</strong>不可重复的**。这个隔离级别时大多数数据库默认的隔离级别。</li>
<li><strong>可重复读(<code>repeatable read</code>)</strong>：在该级别，保证了同一个事务多次读取同样的记录的结果是一致的。可重复读是MySQ的默认隔离级别，解决了脏读的问题，但是对于幻读无法解决。<strong>所谓的幻读就是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围插入新的记录，当之前的事务再次读取该范围记录时，产生幻行。</strong>InooDB引擎使用多版本控制MVCC解决幻读问题。</li>
<li><p><strong>可串行化(<code>serializable1</code>)</strong>：该隔离级别时最高的隔离级别，它通过强制事务串行执行，避免了前面说的幻读问题。简单来说，就是在读取每一行数据都加锁，所有会导致大量的超时和锁争问题。</p></li>
</ul>
<h4 id="rollback">9.2 rollback</h4>
<p>MySQL的<code>rollback</code>命令用来指示回退到事务开始之前的版本，如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employee_job;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#开启事务机制</span></span><br><span class="line"><span class="function">mysql&gt; start transaction</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; <span class="keyword">delete</span> from employee_job</span>;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; select * from employee_job</span>;</span><br><span class="line"><span class="function">Empty <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#回退</span></span><br><span class="line"><span class="function">mysql&gt; roolback</span>;</span><br><span class="line">mysql&gt; select * from employee_job;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br></pre></td></tr></table></figure></p>
<h4 id="commit">9.3 commit</h4>
<p>在Mysql中，如果不是在事务处理快，则提交的更改是默认自动立刻写入表中的。但是在事务处理块中，提交不会隐含执行，必须你显示的调用<code>commit</code>它才会提交到表中。但是如果在<code>start transaction</code>~<code>commit</code>当中的SQL语句出现错误时，则全部不会提交，回退事务开始前的版本 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employee_job;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#开始事务</span></span><br><span class="line"><span class="function">mysql&gt; start transaction</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; insert into employee_job <span class="title">values</span><span class="params">(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;老板&#x27;</span>)</span></span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#提交</span></span><br><span class="line"><span class="function">mysql&gt; commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select* from employee_job</span>;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br><span class="line">| <span class="number">2</span>  | 老板         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">7</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用保留点">9.4 使用保留点</h4>
<p>为了避免一次性对事务处理块进行全部的回退或者提交，使用<code>savepoint</code>来设置保留的，已达到能支持部分回退或者提交的功能。如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">...</span><br><span class="line">savepoint point1;</span><br><span class="line">...</span><br><span class="line">savepoint point2;</span><br><span class="line">...</span><br><span class="line">rollback to point1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure> 上面的程序会回退到<code>point1</code>，因此提交的MySQL批次只有<code>point1</code>前的，后面的无法提交。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer</title>
    <url>/2022/10/26/Transformer/</url>
    <content><![CDATA[<h4 id="transformer是什么">1. Transformer是什么</h4>
<p><code>Transformer</code>是一个利用注意力机制来提高模型训练速度的模型。关于注意力机制可以参看<a href="https://zhuanlan.zhihu.com/p/52119092">这篇文章</a>，<strong>trasnformer可以说是完全基于自注意力机制的一个深度学习模型</strong>，因为它适用于并行化计算，和它本身模型的复杂程度导致它在精度和性能上都要高于之前流行的RNN循环神经网络。</p>
<p>对于RNN来说它一般只关注附近的关系关联，而没有从全局寻找关系紧密的相关特征。因此对于一些特定的场景，不能够很好的处理。而Transforme放眼全局,通过计算权重得到相应的向量，得到更为全面的特征</p>
<span id="more"></span>
<h4 id="transformer的构成">2. Transformer的构成</h4>
<p>里面主要有两部分组成：<code>Encoder</code>和<code>Decoder</code> <img src="/2022/10/26/Transformer/Constitue.png" width="500"> 当我输入一个文本<code>机器学习</code>的时候，该文本数据会先经过一个叫Encoders的模块，对该文本进行编码，然后将编码后的数据再传入一个叫Decoders的模块进行解码，解码后就得到了翻译后的文本，对应的我们称Encoders为编码器，Decoders为解码器。</p>
<p>这个编码模块里边，有很多小的编码器，一般情况下，<code>Encoders</code>里边有6个小编码器，同样的，<code>Decoders</code>里边有6个小解码器。 <img src="/2022/10/26/Transformer/encorder.png" width="500"></p>
<p>放大一个encoder，发现里边的结构是一个自注意力机制加上一个前馈神经网络。 <img src="/2022/10/26/Transformer/forward.png" width="500"></p>
<h4 id="encoder">3 Encoder</h4>
<h5 id="self-attention的步骤">3.1 self-attention的步骤</h5>
<p>这里我们以文本词向量为例。总结来说Transformer时将输入的特征信息以向量为一组，计算该向量与别的向量之间的紧密程度，即将Q与K进行点积得到权值值，经过softmax后得到所占的比重值，然后整合各向量的V*权重得到该向量的新的特征向量。</p>
<ul>
<li><p><code>transformer</code>首先将词向量乘上三个矩阵，得到三个新的向量，之所以乘上三个矩阵参数而不是直接用原本的词向量是因为这样增加更多的参数，提高模型效果。对于输入<code>X1</code>(机器)，乘上三个矩阵后分别得到<code>Q1,K1,V1</code>，同样的，对于输入<code>X2</code>(学习)，也乘上三个不同的矩阵得到<code>Q2,K2,V2</code>。Q维要去查询的，K为等着被查的，V为实际的特征信息 <img src="/2022/10/26/Transformer/Three.png" width="500"></p></li>
<li><p>计算注意力得分了，这个得分是通过计算Q与各个单词的K向量的点积得到的。我们以X1为例，分别将Q1和K1、K2进行点积运算，假设分别得到得分112和96. <img src="/2022/10/26/Transformer/qk.png" width="500"></p></li>
<li><p>将得分分别除以一个特定数值8（K向量的维度的平方根，这里以K向量的维度是64为例）这能让梯度更加稳定，则得到结果如下： <img src="/2022/10/26/Transformer/score.png" width="500"></p></li>
<li><p>进行softmax运算得到，softmax主要将分数标准化，使他们都是正数并且加起来等于1 <img src="/2022/10/26/Transformer/softmax.png" width="500"></p></li>
<li><p>V向量乘上softmax的结果，这个思想主要是为了保持我们想要关注的单词的值不变，而掩盖掉那些不相关的单词（例如将他们乘上很小的数字） <img src="/2022/10/26/Transformer/cheng.png" width="500"></p></li>
<li><p>将带权重的各个V向量加起来，至此，产生在这个位置上（第一个单词）的self-attention层的输出，其余位置的self-attention输出也是同样的计算方式 <img src="/2022/10/26/Transformer/out.png" width="500"></p></li>
</ul>
<p>将上述的过程总结为一个公式就可以用下图表示： <img src="/2022/10/26/Transformer/comprehension.png" width="500"></p>
<p>上面所举的例子我们可以发现每一个输入向量只是产生了一组Q、K、V，为了进一步提高自注意力的层的性能，产生了<strong>多头注意力机制，它通过不同的head得到多个特征表达式（理解为多个个互不干扰自的注意力机制运算，每一组的Q/K/V都不相同。然后，得到多个个不同的权重矩阵Z，每个权重矩阵被用来将输入向量投射到不同的表示子空间。），然后将所以特征拼接起来，得到更为丰富的输出，然后经过一层全连接实现降维。</strong></p>
<p>如下我们得到了八个矩阵Z，将他们拼接: <img src="/2022/10/26/Transformer/cat.png" width="500"> 后进行全连接后得到我们作为前馈神经网络的输入： <img src="/2022/10/26/Transformer/fc.png" width="500"></p>
<p><strong><em>注意：为了解决梯度消失的问题，在Encoders和Decoder中都是用了残差神经网络的结构，即每一个前馈神经网络的输入不光包含上述self-attention的输出Z，还包含最原始的输入。</em></strong></p>
<h5 id="前馈神经网络">3.2 前馈神经网络</h5>
<p>前馈神经网络的输入是self-attention的输出，即上图的Z,是一个矩阵，矩阵的维度是（序列长度×D词向量），之后前馈神经网络的输出也是同样的维度</p>
<h4 id="decorder">4. Decorder</h4>
<p>decoder中使用的也是同样的结构。也是首先对输出<code>machine learning</code>计算自注意力得分，不同的地方在于，进行过自注意力机制后，将self-attention的输出再与Decoders模块的输出计算一遍交叉注意力机制得分，之后，再进入前馈神经网络模块</p>
<ul>
<li>交叉注意力：指两个模块的矩阵进行注意力计算</li>
<li>自注意力：指在同一模块内进行注意力计算</li>
</ul>
<h4 id="对位置应用认识">5. 对位置应用认识</h4>
<p>上面所举的例子当中只是单纯的由Q、K、V得到权值计算拼接后的东西。但是思考一下下面两个句子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chen Love wu</span><br><span class="line">wu love chen</span><br></pre></td></tr></table></figure> 这两个句子表达的意思事完全不同的，但是相应词的Q、K、V是一样的，经过计算后得到的特征也是一样。这就是所谓的在self-attention中每个词都会考虑整个序列的加权。所以其出现位置并不会对结果产生影响，相当于放哪都无所谓，但这跟实际就有些不符合了，我们希望模型对位置有额外的认识。</p>
<p>因此我们希望能够对位置进行编码，一般对位置编码不进行更新（大佬作品，水论文可以更）</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>Transformer</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>Zinx</title>
    <url>/2023/03/06/Zinx/</url>
    <content><![CDATA[<h1 id="trluper框架介绍">1 Trluper框架介绍</h1>
<p><code>Trluper</code>框架是一个简单的只有IO功能的框架，用到的技术有<code>epoll</code>、 这个简单框架处理多IO、包括但不限于<code>Socket IO</code>。开发者能够通过重写抽象类方法在IO的各个处理阶段取实现自己的动作。框架也提供了多个具体类来覆盖包装常用的函数，包括<code>TCP SOCKET、STDIN、STDOUT</code>，这样你可以更加方便调用这些函数。</p>
<h1 id="trluper框架结构">2 Trluper框架结构</h1>
<h4 id="快速开始">1.1 快速开始</h4>
<ul>
<li>调用<code>ZinxKernel::ZinxKernelInit()</code>去初始化<strong>IO-调度内核</strong>。</li>
<li>创建一个继承于<code>AZinxHandler</code>的类，并且重写<code>InternelHandle</code>。在这个函数中，你可以添加你自己的代码，它们将被用来处理来自<strong>输入通道处理字节流</strong>。当你重写了这个函数，你会使用一个宏<code>GET_REF2DATA</code>，他会将数据从 <code>IZinxMsg</code>转换为字节流信息<code>BytesMsg</code>。</li>
<li>创建一个或多个继承<code>Ichannel</code>的类，并覆盖定义特定数据通道的操作所需的函数(一般为文件描述)。</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode教程</title>
    <url>/2022/09/07/VScode%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="为什么使用vscode">1. 为什么使用VScode</h3>
<p>VScode是微软推出一个轻量化编辑器，只需要下载相应的编译器和包即可支持C/C++、java、python的编写。相对于VS来说，VScode更加的轻便、体积小，支持许多插件。</p>
<h3 id="vscode的界面使用">2. VScode的界面使用</h3>
<p><img src="/2022/09/07/VScode%E6%95%99%E7%A8%8B/someClick.png" width="600"></p>
<span id="more"></span>
<h4 id="用户设置">2.1 用户设置</h4>
<p><code>文件File--首选项preferences--设置settings</code>，打开用户设置。VScode支持选择配置，也支持编辑<code>setting.json</code>文件修改默认配置 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）editor.fontsize用来设置字体大小，可以设置editor.fontsize : <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）files.autoSave这个属性是表示文件是否进行自动保存，推荐设置为onFocusChange——文件焦点变化时自动保存。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）editor.tabCompletion用来在出现推荐值时，按下Tab键是否自动填入最佳推荐值，推荐设置为on;</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）editor.codeActionsOnSave中的source.organizeImports属性，这个属性能够在保存时，自动调整 <span class="keyword">import</span> 语句相关顺序，能够让你的 <span class="keyword">import</span> 语句按照字母顺序进行排列，推荐设置为<span class="literal">true</span>,即<span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123; <span class="string">&quot;source.organizeImports&quot;</span>: <span class="literal">true</span> &#125;；</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）editor.lineNumbers设置代码行号,即editor.lineNumbers ：<span class="literal">true</span>；</span><br></pre></td></tr></table></figure></p>
<h3 id="常用快捷键">3. 常用快捷键</h3>
<p>高效的使用vscode,记住一些常用的快捷键是必不可少的，这里罗列了一些常用的快捷键。</p>
<h4 id="主命令">3.1 主命令</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+P</code></td>
<td>俗称万能键，可以输入任何命令</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+P</code></td>
<td>根据名称查找文件</td>
</tr>
</tbody>
</table>
<h4 id="编辑器与窗口管理">3.2 编辑器与窗口管理</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+N</code></td>
<td><strong>新建文件</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+N</code></td>
<td><strong>打开一个新的VSCode编辑器</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+O</code></td>
<td><strong>打开文件</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+O</code></td>
<td>打开文件夹</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+W</code></td>
<td>关闭当前文件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+W 或 Alt+F4</code></td>
<td>关闭当前VSCode编辑器</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+\</code></td>
<td>新建窗口显示代码（相当于复制当前代码到一个新的窗口；同一引用，修改一个文件，其他相同文件会一起改变）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Alt+→</code></td>
<td>移动当前文件到右窗口，若没有右窗口，则创建一个新窗口</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Alt+←</code></td>
<td>移动当前文件到左窗口</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Tab</code></td>
<td><strong>切换文件窗口</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+B</code></td>
<td>显示/隐藏侧边栏</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl +/-</code></td>
<td>放大/缩小编辑器窗口</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+E</code></td>
<td>文件资源管理器（Explorer）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+G</code></td>
<td>git管理窗口（Source Control）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+X</code></td>
<td>扩展（插件）管理窗口（Extentions）</td>
</tr>
</tbody>
</table>
<h4 id="代码文本快捷键">3.3 代码文本快捷键</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+F</code></td>
<td><strong>查找</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+H</code></td>
<td><strong>查找替换</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+F</code></td>
<td>全局查找</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+H</code></td>
<td>全局查找替换</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+D</code></td>
<td>选中下一个匹配项</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+L</code></td>
<td>选中所有匹配项（秀儿）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+[</code></td>
<td>向左缩进</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+]</code></td>
<td>向右缩进</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Alt+Up</code></td>
<td><strong>向上移动当前行</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Alt+Down</code></td>
<td>向下移动当前行</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Shift+Alt+Up</code></td>
<td><strong>向上复制当前行</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Shift+Alt+Down</code></td>
<td>向下复制当前行</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Enter</code></td>
<td><strong>在当前行下方插入空行（光标位置可以不在行尾）</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+Enter</code></td>
<td>在当前行上方插入空行（光标位置可以不在行尾）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Alt+Z</code></td>
<td>切换内容是否自动换行（底部显示/隐藏滚动条</td>
</tr>
</tbody>
</table>
<p>如果在编程中忘记了快捷键，也可以使用<code>Ctrl+K/Ctrl+S</code>来查看VSCode中全部快捷键。</p>
<h3 id="插件安装">4. 插件安装</h3>
<p>在输入框中输入想要安装的插件名称，点击安装即可，推荐安装的插件有： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、Bracket Pair Colorizer：给嵌套的各种括号加上不同的颜色。</span><br><span class="line"><span class="number">2</span>、Path Intellisense：智能路径提示，可以在你输入文件路径时智能提示。</span><br><span class="line"><span class="number">3</span>、Markdown Preview：实时预览 markdown。</span><br><span class="line"><span class="number">4</span>、C/C++ <span class="keyword">for</span> Visual Studio Code：</span><br><span class="line"><span class="number">5</span>、C-family Documentation Comments和Better Comments</span><br><span class="line"><span class="number">6</span>、CMake Tools：用于支持CMake进行编译系统的构建</span><br><span class="line"><span class="number">7</span>、CMake:C-family Documentation Comments用于自动生成C、C++语言风格的注释，笔者主要用在头文件的函数生命的时候，对函数接口添加描述。Better Comments则提供注释高亮功能</span><br><span class="line"><span class="number">8</span>、Git Graph:Git Graph主要是用来显示git log，UI比较好看，安装后使用命令Git Graph: <span class="function">View Git <span class="title">Graph</span> <span class="params">(git log)</span>查看，可以设置一个快捷键方便使用。</span></span><br><span class="line"><span class="function">9、Markdown Preview Enhanced：Markdown Preview Enhanced插件的预览功能比较强大，可在预览窗口选择主题，支持[TOC]标题列表，而且导出功能很好用</span></span><br><span class="line"><span class="function">10、Markmap：Markmap是一个基于开源项目markmap开发的vscode插件，画出来的思维导图非常非常的漂亮。使用的时候很简单，只需要简单的Markdown语法；在安装好之后，在.md文档编辑窗口的右上角就会多一个预览的图标Open as markmap，当然也可手动打开命令面板，输入Open as markmap</span></span><br><span class="line"><span class="function">11、Partial Diff：Partial Diff提供部分文本内容的比较，笔者经常用在重构函数的时候，用来比较两个比较类似的函数的实现。使用的时候先复制要比较的内容，然后选中要比较的另外的一部分内容，右键选择Compare Text with Clipboard，就会打开一个比较窗口。</span></span><br><span class="line"><span class="function">12、One Dark Pro：主题</span></span><br><span class="line"><span class="function">13、Material Icon Theme：图标</span></span><br><span class="line"><span class="function">14、C/C++ Project Generator：C/C++的项目生成</span></span><br></pre></td></tr></table></figure></p>
<h3 id="按照remote-ssh">5. 按照remote-ssh</h3>
<p>remote-ssh支持你远程连接Linux、Mac环境，首先：</p>
<ul>
<li>先安装<code>remote-ssh</code>插件，并创建一个<code>txt</code>文件,内容如下，<code>Hostname</code>为你远端ip地址，<code>user</code>为你的用户名 <img src="/2022/09/07/VScode%E6%95%99%E7%A8%8B/ssh_setting.png" width="500"></li>
<li><code>ctrl+shift+p</code>打开万能键，输入<code>remote-ssh:setting</code>，设置你刚刚的<code>txt</code>路径： <img src="/2022/09/07/VScode%E6%95%99%E7%A8%8B/ssh.png" width="500"></li>
<li>使用，在Vscode下方点击绿色<code>&gt;&lt;</code>，选择<code>connect to Host</code>即可，后续会要求验证你远端主机/虚拟机密码</li>
</ul>
<h3 id="tasks.json文件">6. tasks.json文件</h3>
<p><strong><code>tasks.json</code>的作用是编译,</strong>创建一个<code>tasks.json</code>文件告诉VS代码如何构建(编译)程序。</p>
<p><code>tasks.json</code>的主要作用就是执行类似 <code>gcc -g main.c -o main</code>的命令，需要注意的一点是，<code>tasks.json</code>的&quot;<code>label</code>&quot;参数值和<code>launch.json</code>的&quot;preLaunchTask&quot;参数值需要保持一致</p>
<p>当第一次运行程序时且安装了C++ 扩展后，会创建<code>tasks.json</code>，可以在项目<code>.vscode</code>文件夹中找到它。<code>tasks.json</code>存储构建配置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//task.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,	<span class="comment">//任务类型,Vscode将预定义变量转义解析后直接传给command;shell-&gt;先打开shell再输入命令,因此args会经过shell再次解析</span></span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;C/C++: g++ build active file&quot;</span>,	<span class="comment">//任务名称</span></span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;/usr/bin/g++&quot;</span>,	<span class="comment">//编译器路径</span></span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/home/project/testProject/test_vscode/src/leetcode.cpp&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-I&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/home/project/testProject/test_vscode/include&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: &#123;<span class="comment">//包含很多task,归为group</span></span><br><span class="line">                <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,	<span class="comment">//表名该组任务类型是构建</span></span><br><span class="line">                <span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span>	<span class="comment">//表明此任务为此组任务中的默认任务</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;detail&quot;</span>: <span class="string">&quot;Task generated by Debugger.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>command</code>:设置指定要运行的程序,此时是<code>g++</code></li>
<li><code>args</code>：指定将传递给 <code>g++</code> 的命令行参数。这些参数必须按照编译器期望的顺序指定，相当于<code>g++ g main.cpp -o main</code>。你可能注意到了，内部的一些参数类似于正则表达式的形式，以下具体说明：Visual Studio Code 支持<strong>调试和任务配置文件中的变量替换以及一些选择设置</strong>，使用<code>$&#123;variableName&#125;</code>
<ul>
<li>预定义变量如下(假设你打开了文件·<code>/home/your-username/your-project/folder/file.ext</code>；·/home/your-username/your-project·作为根工作区打开的目录。)
<ul>
<li><code>&#123;userHome&#125;</code> - 用户主文件夹的路径<code>/home/your-username</code></li>
<li><strong><code>$&#123;workspaceFolder&#125;</code> - 在 VS Code 中打开的文件夹的路径<code>/home/your-username/your-project</code></strong></li>
<li><strong><code>$&#123;workspaceFolderBasename&#125;</code> - 在 VS Code 中打开的文件夹的名称，没有任何斜杠 (/)<code>your-project</code></strong></li>
<li><code>$&#123;file&#125;</code> - 当前打开的文件<code>/home/your-username/your-project/folder/file.ext</code></li>
<li><strong><code>$&#123;fileWorkspaceFolder&#125;</code> - 当前打开文件的工作区文件夹<code>/home/your-username/your-project</code></strong></li>
<li><code>$&#123;relativeFile&#125;</code> - 当前打开的文件相对于workspaceFolder<code>folder/file.ext</code></li>
<li><code>$&#123;relativeFileDirname&#125;</code> - 当前打开的文件相对于的目录名workspaceFolder——<code>folder</code></li>
<li><strong><code>$&#123;fileBasename&#125;</code> - 当前打开文件的基本名称<code>file.ext</code></strong></li>
<li><strong><code>$&#123;fileBasenameNoExtension&#125;</code> - 当前打开的文件的基本名称，没有文件扩展名<code>file</code></strong></li>
<li><code>$&#123;fileExtname&#125;</code> - 当前打开文件的扩展名<code>.ext</code></li>
<li><strong><code>$&#123;fileDirname&#125;</code> - 当前打开文件的文件夹路径<code>/home/your-username/your-project/folder</code></strong></li>
<li><code>$&#123;fileDirnameBasename&#125;</code> - 当前打开文件的文件夹名称</li>
<li><code>$&#123;cwd&#125;</code> - 启动 VS Code 时任务运行器的当前工作目录</li>
<li><code>$&#123;lineNumber&#125;</code> - 活动文件中当前选定的行号</li>
<li><code>$&#123;selectedText&#125;</code> - 活动文件中的当前选定文本</li>
<li><code>$&#123;execPath&#125;</code> - 正在运行的 VS 代码可执行文件的路径</li>
<li><code>$&#123;defaultBuildTask&#125;</code> - 默认构建任务的名称</li>
<li><code>$&#123;pathSeparator&#125;</code> - 操作系统用来分隔文件路径中的组件的字符</li>
</ul></li>
</ul></li>
<li><code>label</code>:将在任务列表中看到的；你可以随意命名。</li>
<li><code>detail</code>:将在任务列表中作为任务描述的值。强烈建议重命名此值以将其与类似任务区分开来。</li>
<li><code>group</code>:内部含有<code>kind=build</code>，为<code>true</code>时告诉vscode这个是构建文件;同时当<code>isDefault: true</code>时当前<code>tasks.json</code>为默认构建文件</li>
</ul>
<blockquote>
<p>当你按下运行时，VScode将从中读取tasks.json以了解如何构建和运行程序。您可以在 中定义多个构建任务tasks.json，vscode将会使用默认的<code>tasks.json</code>进行构建编译</p>
</blockquote>
<h3 id="launch.json文件">7. launch.json文件</h3>
<p>在c++编写程序中，最常用到的时<strong>调试</strong>这个功能，也就是我们所说的<code>Debug</code>。VScode支持调式，我们只需要按debug图标即可： <img src="/2022/09/07/VScode%E6%95%99%E7%A8%8B/debug-button.png" width="100"></p>
<p>但有时候我们需要自定义的调试，这时候就用到<code>launch.json</code>了。例如指定要在运行时传递给程序的参数。您可以在文件中定义自定义调试配置<code>launch.json</code>。要创建<code>launch.json</code>，请从播放按钮下拉菜单中选择添加调试配置。</p>
<p>然后您会看到各种预定义调试配置的下拉列表。选择<code>C/C++: g++.exe build and debug active file</code>。 <img src="/2022/09/07/VScode%E6%95%99%E7%A8%8B/launch.png" width="600"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//launch.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;C/C++: g++.exe build and debug active file&quot;</span>,	<span class="comment">//launch的名称</span></span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">      <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,	<span class="comment">//调试的可执行文件路径</span></span><br><span class="line">      <span class="string">&quot;args&quot;</span>: [],	<span class="comment">//传递给main函数的参数</span></span><br><span class="line">      <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,	<span class="comment">//是否在开始时就设置端点</span></span><br><span class="line">      <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,	<span class="comment">//调试程序时的工作目录</span></span><br><span class="line">      <span class="string">&quot;environment&quot;</span>: [],		<span class="comment">//环境变量</span></span><br><span class="line">      <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,	<span class="comment">//true:cmd窗口; false:Vscode的内置终端输出</span></span><br><span class="line">      <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,			<span class="comment">//指定连接的调试器,</span></span><br><span class="line">      <span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;C:\\msys64\\mingw64\\bin\\gdb.exe&quot;</span>,	<span class="comment">//gdb所在路径</span></span><br><span class="line">      <span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">          <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C/C++: g++.exe build active file&quot;</span> <span class="comment">//调试开始前执行需要执行的任务,调试前要编译构建 名称要和tasks.json的label保持一致</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong><code>program</code>：指定要调试的可执行程序。即在调试中会使用该可执行文件进行调试debug操作，因此你的目录在调试前必须能够找到该可执行文件</strong></li>
<li><code>args</code>：属性是要在运行时传递给程序的参数数组</li>
<li>默认情况下，C++ 扩展不会向您的源代码添加任何断点，并且该<code>stopAtEntry</code>值设置为<code>false</code>.</li>
<li><strong><code>preLaunchTask</code>：在调试前必须调用的<code>task.json</code>生成调试可执行文件，其后面的值就是<code>task.json</code>中的label，如果你不需要使用task.json来执行g++命令，你可以注释掉<code>&quot;preLaunchTask&quot;:</code>即可</strong></li>
</ul>
<blockquote>
<p>从现在开始，播放按钮和F5将在启动您的程序进行调试时从您的文件中读取launch.json。</p>
</blockquote>
<h3 id="c_cpp_properties.json文件">8 c_cpp_properties.json文件</h3>
<p>如果你想更多地控制<code>C/C++</code>扩展，你可以创建一个<code>c_cpp_properties.json</code>文件，它允许你更改设置，例如编译器的路径、包含路径、C++ 标准（默认为<code>C++17</code>）等等。</p>
<p>您可以通过运行命令<code>C/C++</code> 查看 <code>C/ C++ Edit Configuration UI</code>，创建<code>c_cpp_properties.json</code>，并且查看相关参数说明 <code>( Ctrl+Shift+P )</code></p>
<p><img src="/2022/09/07/VScode%E6%95%99%E7%A8%8B/command.png" width="600"></p>
<p>将打开C/C++ 配置页面。当您在此处进行更改时，VS Code 会自动将它们写入文件夹.vscode中名为<code>c_cpp_properties.json</code>文件。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/home/project/testProject/test_vscode/include/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/g++&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c11&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;gnu++14&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;linux-gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>includePath</code>：如果您的程序包含不在您的工作区或标准库路径中的头文件，您只需要添加到包含路径数组设置。注意这一步仅仅是告诉vscode头文件在哪，方便debug，但是<code>gcc/g++</code>进行编译时并不知道。我们知道如果用<code>g++ main.cpp xxx.cpp -I 库路径 -o main</code>是直接可以编译成功的，那么我们只需要将告诉vscode使用我们自己定义的命令就可以了，那么对于自定义命令仍然是要在<code>task.json</code>中设置</li>
<li><code>compilerPath</code>：这个扩展通过使用<code>campilerPath</code>来推断 C++ 标准库头文件的路径。当扩展知道在哪里可以找到这些文件时，它可以提供智能完成和转到定义导航等功能。其顺序是
<ul>
<li>首先检查 Microsoft Visual C++ 编译器</li>
<li>然后在 Windows Subsystem for Linux (WSL) 上寻找 g++</li>
<li>然后是 Mingw-w64 的 g++。</li>
</ul></li>
</ul>
<h3 id="编译参数">9 编译参数</h3>
<h3 id="vscode中main的参数传递">10 VScode中main的参数传递</h3>
<ul>
<li>VScode中给main函数传递参数是在<code>launch.json</code>中的args中，将要传递的写入数组中即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//launch.josn的args键值对</span></span><br><span class="line"> <span class="string">&quot;args&quot;</span>: [<span class="string">&quot;nihao&quot;</span>,<span class="string">&quot;trluper&quot;</span>],</span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;argc;++i)</span><br><span class="line">        cout&lt;&lt;argv[i]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>输出 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nihao</span><br><span class="line">trluper</span><br></pre></td></tr></table></figure></p>
<ul>
<li>命令行形式的则直接在可执行文件后面接参数,如<code>main nihao trluper</code></li>
</ul>
<blockquote>
<p>对于Visual studio当中main函数的参数传递，在项目名称右击，点击<strong>属性-&gt;配置属性-&gt;调试-&gt;命令参数</strong> <img src="/2022/09/07/VScode%E6%95%99%E7%A8%8B/vstudio.png" width="600"> 然后填入参数，多个参数的话<strong>以空格分开就好</strong></p>
</blockquote>
<h3 id="问题1">11 问题1</h3>
<p>运行C++时出现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ERROR: Unable to start debugging. Unexpected GDB output from command <span class="string">&quot;-exec-run&quot;</span>. During startup program exited with code <span class="number">0xc0000139</span>.</span><br></pre></td></tr></table></figure>
<p>之前配置了VSCode+Anaconda，将<code>conda</code>加入了环境变量，其中有一项是： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">D:\pythonDeve\Anaconda\Library\mingw-w64\bin</span><br></pre></td></tr></table></figure> 其中含有一些c++的动态链接库，与mingw的动态链接库冲突 之前配置的时候，使得PowerShell启动时自动加载Anaconda的配置，并且VSCode自动激活了conda环境，然后就引发冲突了</p>
<p>解决方法：</p>
<ul>
<li>方法一：只需要在 VSCode 的settings.json中加入这一行配置即可： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;python.terminal.activateEnvironment&quot;</span>: <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>方法二：关闭conda环境在终端自动激活 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">conda config --set auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="头文件问题fatal-error-no-such-file-or-directory">12 头文件问题：fatal error: No such file or directory</h3>
<p>虽然在<code>c_cpp_properties.json的&quot;includepath&quot;的&quot;path&quot;</code>设置了头文件路径，但是这一步仅仅是告诉vscode头文件在哪，方便debug，但是<code>gcc</code>进行编译时并不知道。<strong>在命令行中我们知道，用<code>g++ main.cpp xxx.cpp -I 库路径 -o main</code>是可成功运行的，那么我们只需要对<code>VScode</code>运行这样的命令行即可,在<code>tasks.json</code>中设置<code>-I 路径</code> ：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/home/project/testProject/test_vscode/src/leetcode.cpp&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-I&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/home/project/testProject/test_vscode/include&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            ],</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写CMakeList.txt可以解决，这时候不需要改写<code>tasks.json</code>，只需要设置<code>c_cpp_properties.json的&quot;includepath&quot;的&quot;path&quot;</code>即可</p>
</blockquote>
<h3 id="cmake-tools">13 CMake Tools</h3>
<h4 id="为什么用cmake">13.1 为什么用CMake</h4>
<p>利用CMake tools 进行编译系统的构建，省去了编写<code>tasks.json\launch.json</code>或者Makefile的编写，能够处理以上绝大部分问题。大部分的大型项目都是采用<code>CMake</code>实现。</p>
<p>对于一个庞大的CPP工程，我们可以不必写上面的<code>.vscode</code>文件夹，因此也就不必写那3个json文件。原因在于一个庞大的Cpp工程如果配置<code>tasks.json</code>然后用<code>gcc</code>或<code>g++</code>来编译，太过麻烦，他们更适合单一的文件编译，而通常<code>C++</code>工程通常较为庞大，因此更推荐编写<code>CMakeLists.txt</code>。 <img src="/2022/09/07/VScode%E6%95%99%E7%A8%8B/CMake.png" width="600"></p>
<p><code>make</code>工具，它是一个自动化编译工具，用来批处理编译源文件，但是使用<code>make</code>工具进行编译需要编写一个规则文件，<code>make</code>依据它来批处理编译，这个文件就是<code>Makefile</code>，但是对于一个大工程，编写<code>Makefile</code>也是一件很复杂的事情，所以这时人们设计出<code>cmake</code>工具，它能够生成<code>Makefile</code>文件，随之而来的就是<code>CMakeLists.txt</code>文件，它是<code>cmake</code>所依据的规则，相对来说，<code>CMakeLists.txt</code>文件的编写要简单不少。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 最低CMake版本要求</span><br><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.5</span><span class="number">.1</span>)</span><br><span class="line"> </span><br><span class="line"># 项目名称</span><br><span class="line"><span class="built_in">project</span>(leetcode)</span><br><span class="line"> </span><br><span class="line">#添加debug信息，使得生成的可执行文件可以调试</span><br><span class="line"><span class="built_in">set</span>(CMAKE_BUILD_TYPE DEBUG)</span><br><span class="line">#可调试编译选项，这样才能命中断点</span><br><span class="line"><span class="built_in">add_definitions</span>(<span class="string">&quot;-Wall -g&quot;</span>)</span><br><span class="line">#使用通配符添加多个源文件</span><br><span class="line"><span class="built_in">file</span>(GLOB SRC_LIST <span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line"> </span><br><span class="line">#编译选项</span><br><span class="line"><span class="built_in">add_compile_options</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"> </span><br><span class="line"># 头文件路径</span><br><span class="line"><span class="built_in">include_directories</span>(<span class="string">&quot;include&quot;</span>)</span><br><span class="line"> </span><br><span class="line">#链接库</span><br><span class="line"><span class="built_in">link_libraries</span>(event pthread) #相当于-lpthread -event</span><br><span class="line"> </span><br><span class="line"># 生成可执行的文件</span><br><span class="line"><span class="built_in">add_executable</span>(main src/main.cpp src/Convert.cpp)</span><br></pre></td></tr></table></figure>
<p><strong><code>CMakeLists.txt</code>文件具有<code>c_cpp_properties.json、tasks.json</code>两个文件的功能，一般如果C++工程较小，可以编写<code>tasks.json</code>文件，否则更适合编写<code>CMakeLists.txt</code>文件。</strong>不过我还是推荐我们每次编写程序的时候编写一下<code>c_cpp_properties.json</code>，因为该文件中<code>includePath</code>参数可以很好指定头文件目录，这样就算没有<code>CMakeLists.txt</code>文件，我们在vscode编写程序的时候它也自动包含了头文件，这样就可以具有代码提示功能。而<code>CMakeLists.txt</code>中的库文件路径并不是太好指定(主要我目前对CMakeLists.txt还不是太了解)。如果我们需要在VS里调试的话，还是需要编写launch.json文件的。</p>
<ul>
<li><strong>因此在实际的代码开发中最好的搭配组合是<code>CMakeLists.txt</code>和<code>c_cpp_properties.json</code></strong></li>
<li><strong>需要使用Vscode的调试时（不使用GDB命令行），则你要编写<code>launch.json</code>文件</strong></li>
</ul>
<h4 id="cmake流程">13.2 CMake流程</h4>
<ul>
<li>创建<code>CMakeLists.txt</code>文件，编写<code>CMakeLists.txt</code>文件，其编写语句可见<a href>CMake</a></li>
<li><code>ctrl+shift+p</code>搜索<code>CMake:Configue</code>，选择对应的编译器，然后点击，之后在你的工程目录会多出<code>build</code>目录</li>
<li>之后<code>cd</code>进入<code>build</code>目录，执行<code>cmake ..</code>和<code>make</code>后得到编译文件</li>
</ul>
<h4 id="vscode的调试">13.3 VScode的调试</h4>
<p>要使用VSCode的调试，就必须写<code>lanuch.json</code>文件，这样你才可以按<code>F5</code>启动GDB调试，否则你只能以命令行的形式调试。然后选择这个<code>launch.json</code>进行调试，即你会在调试看到<code>leetcode debug</code>，选择它进行调试</p>
<ul>
<li>在这里你只需要保证launch.json`能够找到可执行文件即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//launch.json---</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;leetcode debug&quot;</span>,	<span class="comment">//launch的名称</span></span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">      <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,	<span class="comment">//调试的可执行文件路径</span></span><br><span class="line">      <span class="string">&quot;args&quot;</span>: [],	<span class="comment">//传递给main函数的参数</span></span><br><span class="line">      <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,	<span class="comment">//是否在开始时就设置端点</span></span><br><span class="line">      <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,	<span class="comment">//调试程序时的工作目录</span></span><br><span class="line">      <span class="string">&quot;environment&quot;</span>: [],		<span class="comment">//环境变量</span></span><br><span class="line">      <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,	<span class="comment">//true:cmd窗口; false:Vscode的内置终端输出</span></span><br><span class="line">      <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,			<span class="comment">//指定连接的调试器,</span></span><br><span class="line">      <span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;C:\\msys64\\mingw64\\bin\\gdb.exe&quot;</span>,	<span class="comment">//gdb所在路径</span></span><br><span class="line">      <span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">          <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">          <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">     <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe build active file&quot; //调试开始前执行需要执行的任务,调试前要编译构建 名称要和tasks.json的label保持一致</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题">13.3 问题</h4>
<h5 id="出现vscode-基于-configurationprovider-设置提供的信息检测到-include-错误">13.3.1 出现vscode 基于 configurationProvider 设置提供的信息检测到 #include 错误。</h5>
<p><strong>两个方法解决：</strong></p>
<ul>
<li><strong>方法1</strong>：这是由于CMake工程生成的<code>c_cpp_properties.json</code>当中会出现<code>&quot;configurationProvider&quot;: &quot;ms-vscode.cmake-tools&quot;</code>，将它注释掉即可 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&quot;configurationProvider&quot;: &quot;ms-vscode.cmake-tools&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>方法2</strong>：这种情况需要在工作区settings.json中添加一个配置项，使配置的信息来源于cmake。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">“C_Cpp.<span class="keyword">default</span>.configurationProvider”: “ms-vscode.cmake-tools”</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="完整cmakelists.txt">13.4 完整CMakeLists.txt</h4>
<p>下面是便捷的<code>CMakeLists.txt</code>，只要遵循之前的<strong>目录结构</strong>(include、src、，这个CMakeLists.txt在我们添加源文件的时候也不需要改动任何代码，可以自动生成工程文件名、可执行文件。需要指定的就是需要连接的动态链接库，一般小型程序也不用指定。还有就是这个工程到底是根据多个源文件生成一个可执行文件还是为每一个源文件都生成一个可执行文件。下面的CMakeLists.txt已经默认写好了，每次我们只需要根据自己的实际情况将选择即可。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title>blog域名挂靠</title>
    <url>/2022/12/16/blog/</url>
    <content><![CDATA[<h4 id="github上的博客域名挂靠">1. github上的博客域名挂靠</h4>
<p>由于github是外国网站，存在者有时候节点ip无法访问到github，导致博客也登不上去，为了解决这个方法，可以使用域名进行挂靠。</p>
<h5 id="域名设置">1.1 域名设置</h5>
<p>域名购买可以买腾讯云、阿里喝华为的，这里以腾讯云为例子，点击<a href="https://cloud.tencent.com/act/pro/domain_sales?fromSource=gwzcw.6927043.6927043.6927043&amp;utm_medium=cpc&amp;utm_id=gwzcw.6927043.6927043.6927043&amp;bd_vid=11616374416468829912">域名购买</a>。购买完成后，进入<a href="https://console.cloud.tencent.com/domain">域名控制平台</a>-&gt;我的域名，进行设置： <img src="/2022/12/16/blog/yuming.jpg"></p>
<p>点击<strong>解析</strong>,进入如下页面： <img src="/2022/12/16/blog/jiexi.jpg"> <strong>然后增加<code>CNAME</code>记录类型，其记录值为你的博客地址，如我的为<code>trluper.github.io</code></strong></p>
<span id="more"></span>
<h5 id="github进行settings">1.2 github进行settings</h5>
<p>完成上面步骤后，进入你github的博客仓库，点击<code>settings</code>后选择<code>Pages</code>,设置<code>custom domain</code>的值为你购买的域名，如我的为<code>trluper.cn</code>。 <img src="/2022/12/16/blog/github.jpg"></p>
<p>之后大功告成，可以测试一下是否通过域名能够访问你的博客。</p>
<h5 id="解决每次git-depoly后域名消失">1.3 解决每次git depoly后域名消失</h5>
<p>git deploy之后发现个问题，访问自己的域名返回404，查看github的Custom domain发现已经被还原为空值。解决方案为： - 在你的本地blog文件中<code>source</code>目录下，增加一文件<code>CNAME</code>,文件内只写上你自己的域名url <img src="/2022/12/16/blog/xiaoshi.jpg"></p>
<p>然后进行<code>hexo clean\hexo g\ hexo s</code>即可</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库</title>
    <url>/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="概述一下你认识的redis">0概述一下你认识的Redis？</h2>
<p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载 在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。 因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能 最快的Key-Value DB。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value 的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可 以做高性能的tag系统等等。 另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的 memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据 的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h2 id="redis数据类型">1. Redis数据类型</h2>
<p>Redis提供了<code>String,Hash,List,Set,Zset</code>五种数据类型。</p>
<h3 id="string">1.1 String</h3>
<p><code>String</code>数据结构是最简单的<code>key-value</code>类型，<code>value</code>不仅可以是<code>String</code>,也可以是数字，包括整数，浮点数和二进制数。</p>
<p><code>string</code> 数据结构是简单的 <code>key-value</code> 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串（simple dynamic string，SDS）</strong>。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<p>主要的应用有：缓存，计数（比如用户的访问次数、热点文章的点赞转发数量等等），共享session和限速。</p>
<span id="more"></span>
<p>内部编码主要有：</p>
<ul>
<li><strong><code>int</code></strong>:8个字节的长整型</li>
<li><strong><code>embstr</code></strong>:小于等于39个字节的字符串</li>
<li><strong><code>raw</code></strong>:大于39个字节的字符串</li>
</ul>
<p>各个指令的时间复杂度</p>
<ul>
<li><strong><code>SET</code></strong>：为一个 key 设置 value，可以配合 EX/PX 参数指定 key 的有效期，通过 NX/XX 参数针对 key 是否存在的情况进行区别操作，时间复杂度 O(1)</li>
<li><strong><code>GET</code></strong>：获取某个 key 对应的 value，时间复杂度 O(1)</li>
<li><strong><code>GETSET</code></strong>：为一个 key 设置 value，并返回该 key 的原 value，时间复杂度 O(1)</li>
<li><strong><code>MSET</code></strong>：为多个 key 设置 value，时间复杂度 O(N)</li>
<li><strong><code>MSETNX</code></strong>：同 MSET，如果指定的 key 中有任意一个已存在，则不进行任何操作，时间复杂度 O(N)</li>
<li><strong><code>MGET</code></strong>：获取多个 key 对应的 value，时间复杂度 O(N)</li>
<li><strong><code>INCR</code></strong>：将 key 对应的 value 值自增1，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li>
<li><strong><code>INCRBY</code></strong>：将 key 对应的 value 值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li>
<li><strong><code>DECR/DECRBY</code></strong>：同 INCR/INCRBY，自增改为自减。</li>
</ul>
<h3 id="hash">1.2 Hash</h3>
<p><code>Hash</code>是一个<code>string</code>类型的<code>field</code>和<code>value</code>的映射表，hash特别适合用于存储对象，后续操作的时候，可以直接仅仅修改这个对象某个字段的值。比如可以用hash数据结构来存储用户信息，商品信息等。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">key = JavaUser</span><br><span class="line">value = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="string">&quot;location&quot;</span>: <span class="string">&quot;GuangDong,Jieyang&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要应用有：将关系型数据库每一行数据存储为一个哈希键</p>
<p><strong>内部编码主要：</strong></p>
<ul>
<li><code>ziplist(压缩列表)</code>：当哈希类型元素个数小于<code>hash-max-ziplist-entries</code>配置（默认512个字节），同时所有值小于<code>hash-max-ziplist-value</code>配置（默认64个字节）时，使用<code>ziplist</code>作为内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀</li>
<li><code>hashtable(哈希表)</code>：当哈希类型无法满足ziplist的条件时，使用hashtable作为内部实现，因为此时ziplist读写效率会下降，而hashtable读写时间复杂度为O(1)</li>
</ul>
<h4 id="各个指令的时间复杂度">1.2.1 各个指令的时间复杂度</h4>
<p>与 Hash 相关的常用命令：</p>
<ul>
<li><strong>HSET</strong>：将 key 对应的 Hash 中的 field 设置为 value。如果该 Hash 不存在，会自动创建一个。时间复杂度 O(1)</li>
<li>***：返回指定 Hash 中 field 字段的值，时间复杂度 O(1)</li>
<li>HMSET/HMGET：同 HSET 和 HGET，可以批量操作同一个 key 下的多个 field，时间复杂度：O(N)，N为一次操作的 field 数量</li>
<li>HSETNX：同 HSET，但如 field 已经存在，HSETNX 不会进行任何操作，时间复杂度 O(1)</li>
<li>HEXISTS：判断指定Hash中 field 是否存在，存在返回1，不存在返回0，时间复杂度 O(1)</li>
<li>HDEL：删除指定 Hash 中的 field（1个或多个），时间复杂度：O(N)，N 为操作的 field 数量</li>
<li>HINCRBY：同 INCRBY 命令，对指定 Hash 中的一个 field 进行 INCRBY，时间复杂度 O(1)</li>
</ul>
<p><strong>应谨慎使用的Hash相关命令：</strong></p>
<ul>
<li>HGETALL：返回指定 Hash 中所有的 field-value 对。返回结果为数组，数组中 field 和 value 交替出现。时间复杂度 O(N)</li>
<li>HKEYS/HVALS：返回指定 Hash 中所有的 field/value，时间复杂度 O(N)</li>
<li>上述三个命令都会对 Hash 进行完整遍历，Hash中的 field 数量与命令的耗时线性相关，对于尺寸不可预知的 Hash，应严格避免使用上面三个命令，而改为使用 HSCAN 命令进行游标式的遍历</li>
</ul>
<h3 id="list">1.3 List</h3>
<p><code>list</code>就是链表，Redis中list的应用场景非常多，也是Redis最重要的数据结构之一</p>
<p><strong><code>list</code>的实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</strong></p>
<p>另外可以通过<code>lrange</code>，就是从某个元素开始读取多少个元素，可以基于<code>list</code>实现分页查询，基于 redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
<p>主要的应用有：<strong>栈、队列，消息队列（抢购），文章列表等</strong></p>
<p><strong>内部编码有：</strong></p>
<ul>
<li><strong><code>ziplist(压缩列表)</code>：</strong>当哈希类型元素个数小于<code>list-max-ziplist-entries</code>配置（默认512），同时所有值小于<code>list-max-ziplist-value</code>配置（默认64）时，使用<code>ziplist作</code>为内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀</li>
<li><strong><code>linkedlist</code>(链表)</strong>：当列表类型无法满足<code>ziplist</code>条件时，使用链表作为内部实现</li>
</ul>
<h4 id="各个指令的时间复杂度-1">1.3.1 各个指令的时间复杂度</h4>
<ul>
<li><strong><code>LPUSH</code></strong>：向指定<code>List</code>的左侧（即头部）插入 1 个或多个元素，返回插入后的<code>List</code> 长度。时间复杂度<code>O(N)</code>，<code>N</code>为插入元素的数量</li>
<li><strong><code>RPUSH</code>：</strong>同 <code>LPUSH</code>，向指定<code>List</code>的右侧（即尾部）插入 1 或多个元素</li>
<li><strong><code>LPOP</code>：</strong>从指定<code>List</code>的左侧（即头部）移除一个元素并返回，时间复杂度 O(1)</li>
<li><strong><code>RPOP</code>：</strong>同 <code>LPOP</code>，从指定 <code>List</code> 的右侧（即尾部）移除 1 个元素并返回</li>
<li><strong><code>LPUSHX/RPUSHX</code></strong>：与 <code>LPUSH/RPUSH</code> 类似，区别在于，<code>LPUSHX/RPUSHX</code> 操作的 <code>key</code> 如果不存在，则不会进行任何操作</li>
<li><strong><code>LLEN</code></strong>：返回指定<code>List</code>的长度，时间复杂度 O(1)</li>
<li><strong><code>LRANGE</code></strong>：返回指定 <code>List</code> 中指定范围的元素（双端包含，即 <code>LRANGE key 0 10</code>会返回 <code>11</code> 个元素），时间复杂度 O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的 <code>List</code> 元素会导致延迟，同时对长度不可预知的<code>List</code>，避免使用 <code>LRANGE key 0 -1</code>这样的完整遍历操作。</li>
</ul>
<p>应谨慎使用的List相关命令：</p>
<ul>
<li><strong><code>LINDEX</code></strong>：返回指定<code>List</code>指定 <code>index</code> 上的元素，如果<code>index</code> 越界，返回<code>nil</code>。<code>index</code>数值是回环的，即 <code>-1</code>代表 <code>List</code> 最后一个位置，<code>-2</code>代表<code>List</code>倒数第二个位置。时间复杂度 O(N)</li>
<li><strong><code>LSET</code></strong>：将指定 <code>List</code>指定 <code>index</code> 上的元素设置为 <code>value</code>，如果 <code>index</code> 越界则返回错误，时间复杂度 <code>O(N)</code>，如果操作的是头/尾部的元素，则时间复杂度为<code>O(1)</code></li>
<li><strong><code>LINSERT</code></strong>：向指定 <code>List</code> 中指定元素之前/之后插入一个新元素，并返回操作后的 <code>List</code> 长度。如果指定的元素不存在，返回<code>-1</code>。如果指定<code>key</code> 不存在，不会进行任何操作，时间复杂度 <code>O(N)</code></li>
</ul>
<p><strong>由于<code>Redis</code> 的 List 是链表结构的，上述的三个命令的算法效率较低，需要对 <code>List</code>进行遍历，命令的耗时无法预估，在<code>List</code>长度大的情况下耗时会明显增加，应谨慎使用。</strong></p>
<h3 id="set">1.4 Set</h3>
<p>集合（set）可以保存多个字符串元素，但是不允许有重复元素，并且集合中的元素是无序的，一个集合最多可以存储2^32-1个元素，集合可以进行内部的增删改查和多个集合取交集，并集，差集。</p>
<p>主要的应用有：<strong>标签，生成随机数（抽奖），社交需求（共同好友，粉丝等等）</strong></p>
<p><strong>内部编码主要有：</strong></p>
<ul>
<li>** intset(整数集合)**：当集合中的元素都是整数而且元素个数小于set-max-intset-entries配置（默认512个）时，使用该编码减少内存的使用</li>
<li><strong>hashtable(哈希表)</strong>：其它条件下使用哈希表作为内部实现</li>
</ul>
<h4 id="各个指令的时间复杂度-2">1.4.1 各个指令的时间复杂度</h4>
<ul>
<li><strong>SADD</strong>：向指定 Set 中添加 1 个或多个 member，如果指定 Set 不存在，会自动创建一个。时间复杂度 O(N)，N 为添加的 member 个数</li>
<li><strong>SREM</strong>：从指定 Set 中移除 1 个或多个 member，时间复杂度 O(N)，N 为移除的 member 个数</li>
<li><strong>SRANDMEMBER</strong>：从指定 Set 中随机返回 1 个或多个 member，时间复杂度 O(N)，N 为返回的 member 个数</li>
<li><strong>SPOP：</strong>从指定 Set 中随机移除并返回 count 个 member，时间复杂度 O(N)，N 为移除的 member 个数</li>
<li><strong>SCARD</strong>：返回指定 Set 中的 member 个数，时间复杂度 O(1)</li>
<li><strong>SISMEMBER</strong>：判断指定的 value 是否存在于指定 Set 中，时间复杂度 O(1)</li>
<li><strong>SMOVE</strong>：将指定 member 从一个 Set 移至另一个 Set</li>
</ul>
<p>慎用的Set相关命令：</p>
<ul>
<li><strong>SMEMBERS</strong>：返回指定 Hash 中所有的 member，时间复杂度 O(N)</li>
<li><strong>SUNION/SUNIONSTORE：</strong>计算多个 Set 的并集并返回/存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
<li><strong>SINTER/SINTERSTORE</strong>：计算多个 Set 的交集并返回/存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
<li><strong>SDIFF/SDIFFSTORE：</strong>计算 1 个 Set 与 1 或多个 Set 的差集并返回/存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
</ul>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的 Set 尺寸不可知的情况下，应严格避免使用。可以考虑通过 SSCAN 命令遍历获取相关 Set 的全部 member，如果需要做并集/交集/差集计算，可以在客户端进行，或在不服务实时查询请求的 Slave 上进行</p>
<h3 id="zset">1.5 ZSet</h3>
<p>有序集合（zset）保留集合元素不能重复的特性，但是有序集合中的元素可以排序，它为每一个元素设定一个score作为排序的依据</p>
<p>应用：<strong>排行榜系统，用户点赞。需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</strong></p>
<p><strong>内部编码实现：</strong></p>
<ul>
<li><strong>ziplist(压缩列表)</strong>：当哈希类型元素个数小于zset-max-ziplist-entries配置（默认128个），同时所有值小于zset-max-ziplist-value配置（默认64）时，使用ziplist作为内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀。</li>
<li><strong>skiplist(跳表)：</strong>当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降</li>
</ul>
<h4 id="各个指令的时间复杂度-3">1.5.1 各个指令的时间复杂度</h4>
<ul>
<li><strong>ZADD</strong>：向指定 Sorted Set 中添加 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为添加的 member 数量，N 为 Sorted Set 中的 member 数量</li>
<li><strong>ZREM</strong>：从指定 Sorted Set 中删除 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为删除的 member 数量，N 为 Sorted Set 中的 member 数量</li>
<li><strong>ZCOUNT</strong>：返回指定 Sorted Set 中指定 score 范围内的 member 数量，时间复杂度：O(log(N))</li>
<li><strong>ZCARD</strong>：返回指定 Sorted Set 中的 member 数量，时间复杂度 O(1)</li>
<li><strong>ZSCORE</strong>：返回指定 Sorted Set 中指定 member 的 score，时间复杂度 O(1)</li>
<li><strong>ZRANK/ZREVRANK</strong>：返回指定 member 在 Sorted Set 中的排名，ZRANK 返回按升序排序的排名，ZREVRANK 则返回按降序排序的排名。时间复杂度 O(log(N))</li>
<li><strong>ZINCRBY</strong>：同 INCRBY，对指定 Sorted Set 中的指定 member 的 score 进行自增，时间复杂度 O(log(N))</li>
</ul>
<p><strong>慎用的Sorted Set相关命令：</strong></p>
<ul>
<li><strong>ZRANGE/ZREVRANGE：</strong>返回指定 Sorted Set 中指定排名范围内的所有 member，ZRANGE 为按 score 升序排序，ZREVRANGE 为按 score 降序排序，时间复杂度 O(log(N)+M)，M为本次返回的 member 数</li>
<li><strong>ZRANGEBYSCORE/ZREVRANGEBYSCORE</strong>：返回指定 Sorted Set 中指定 score 范围内的所有 member，返回结果以升序/降序排序，min 和 max 可以指定为 -inf和+ inf，代表返回所有的 member。时间复杂度 O(log(N)+M)</li>
<li><strong>ZREMRANGEBYRANK/ZREMRANGEBYSCORE</strong>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有 member。时间复杂度 O(log(N)+M)</li>
</ul>
<p>上述几个命令，应尽量避免传递<code>[0 -1]</code>或<code>[-inf +inf]</code>这样的参数，来对 Sorted Set 做一次性的完整遍历，特别是在 Sorted Set 的尺寸不可预知的情况下。可以通过 ZSCAN 命令来进行游标式的遍历，或通过 LIMIT 参数来限制返回 member 的数量（适用于 ZRANGEBYSCORE 和 ZREVRANGEBYSCORE 命令），以实现游标式的遍历。</p>
<h2 id="为什么要用redis为什么要用缓存">2. 为什么要用redis/为什么要用缓存</h2>
<p>主要从“高性能”和“高并发”这两个点来看待这个问题</p>
<p><strong>高性能：</strong></p>
<p>Redis中的数据是存储在内存中的，所以读写速度非常快。假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变之后，同步改变缓存中相应的数据即可。</p>
<p><strong>高并发：</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库</p>
<blockquote>
<p><strong>使用Redis的好处有哪些？</strong> 1、访问速度快，因为数据存在内存中，类似于Java中的HashMap或者C++中的哈希表（如unordered_map/unordered_set），这两者的优势就是查找和操作的时间复杂度都是O(1)</p>
</blockquote>
<blockquote>
<p>2、数据类型丰富，支持String，list，set，sorted set，hash这五种数据结构</p>
</blockquote>
<blockquote>
<p>3、支持事务，Redis中的操作都是原子性，换句话说就是对数据的更改要么全部执行，要么全部不执行，这就是原子性的定义</p>
</blockquote>
<blockquote>
<p>4、特性丰富：Redis可用于缓存，消息，按key设置过期时间，过期后将会自动删除。</p>
</blockquote>
<h2 id="redis的数据怎么存储在内存中内存这么有限怎么存储的">3. Redis的数据怎么存储在内存中（内存这么有限，怎么存储的）</h2>
<h2 id="为什么使用redis而不直接在程序中使用map做缓存">4. 为什么使用redis而不直接在程序中使用map做缓存？</h2>
<p>缓存分为本地缓存和分布式缓存，使用语言自带得map实现的是本地缓存，最主要得特点是轻量以及快速，生命周期随着该实例的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。</p>
<h2 id="前的redis的线程模型">5. 4.0前的redis的线程模型</h2>
<blockquote>
<p>总览： - 4.0以前纯单线程 - 4.0以及之后增加了执行的删除指令的多线程 - 6.0后为克服网络IO带来的瓶颈，在IO阶段使用多线程，socket的变化和命令的执行都是主线程复杂的</p>
</blockquote>
<p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型 </strong>。redis内部使用文件事件处理器file event handler,这个文件事件处理器是单线程的，所以redis才叫做单线程的模型。</p>
<p>它采用IO多路复用机制同时监听多个socket，它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。根据socket上的事件来选择对应的事件处理器进行处理。</p>
<p>这样的好处非常明显： I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：</p>
<ul>
<li>文件事件;</li>
<li>时间事件。</li>
</ul>
<p>时间事件不需要多花时间了解，我们接触最多的还是 文件事件（客户端进行读取写入等操作，涉及一系列网络通信）。</p>
<p>《<strong>Redis 设计与实现》有一段话是如是介绍文件事件的：</strong></p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event &gt;handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
</blockquote>
<blockquote>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
</blockquote>
<blockquote>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</strong></p>
</blockquote>
<p>文件事件处理器的结构包含4各部分：</p>
<ul>
<li>多个socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器，命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路服用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis事件处理器.png" width="700"></p>
<p>客户端与redis的一次通信过程如下： <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis一次通行过程.png" width="800"></p>
<p>客户端<code>socket01</code>向<code>redis</code>的<code>server socket</code>请求建立连接，此时<code>server socket</code>会产生一个<code>AE_READBLE</code>事件，IO多路复用程序监听到<code>server socket</code>产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的<code>socket01</code>,并将该<code>socket01</code>的<code>AE_READBLE</code>事件与命令请求处理器相关联。</p>
<p>假设此时客户端发送了一个<code>set key value</code>请求，此时<code>redis</code>的<code>socket01</code>会产生<code>AE_READABLE</code>事件，IO多路复用程序将事件压入队列，此时事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取<code>socket01</code>中的<code>key value</code>并在自己内存中完成<code>key value</code>的设置。操作完成后，它会将<code>socket01</code>的<code>AE_WRITABLE</code>事件与命令回复处理器相关联。</p>
<p>如果此时客户端准备好接收返回结果了，那么redis中的<code>socket01</code>会产生一个<code>AE_WRITABLE</code>事件，同样压入队列中，事件分派器找到相关联的的命令回复处理器，由命令回复处理器对<code>socket01</code>输入本次操作的一个结果，比如ok，之后解除<code>socket01</code>的<code>AE_WRITABLE</code>事件与命令回复处理器的关联。</p>
<p>这就完成了一次通信。</p>
<blockquote>
<p><strong>单线程的Redis为什么这么快？</strong> 主要是有三个原因： 1、Redis的全部操作都是纯内存的操作； 2、Redis采用单线程，有效避免了频繁的上下文切换； 3、采用了非阻塞I/O多路复用机制。</p>
</blockquote>
<h2 id="redis-使用单线程的原因">6. Redis 使用单线程的原因</h2>
<p>Redis 从一开始就选择使用单线程模型处理来自客户端的绝大多数网络请求，这种考虑其实是多方面的，其中最重要的几个原因如下：</p>
<ul>
<li>使用单线程模型能带来更好的可维护性，方便开发和调试；</li>
<li>使用单线程模型也能并发的处理客户端的请求；</li>
<li><strong>Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；</strong></li>
</ul>
<p>上述三个原因中的最后一个是最终使用单线程模型的决定性因素，其他的两个原因都是使用单线程模型额外带来的好处，在这里按顺序介绍上述的几个原因。</p>
<h3 id="可维护性">6.1 可维护性</h3>
<p>可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。</p>
<p>如果计算机中的两个进程（线程同理）同时尝试修改一个共享内存的内容，在没有并发控制的情况下，最终的结果依赖于两个进程的执行顺序和时机，如果发生了并发访问冲突，最后的结果就会是不正确的。</p>
<p>引入了多线程，就必须要同时引入并发控制来保证在多个线程同时访问数据时程序行为的正确性，这就需要工程师额外维护并发控制的相关代码，例如，会需要在可能被并发读写的变量上增加互斥锁。</p>
<p>在访问这些变量或者内存之前也需要先对获取互斥锁，一旦忘记获取锁或者忘记释放锁就可能会导致各种诡异的问题，管理相关的并发控制机制也需要付出额外的研发成本和负担。</p>
<h3 id="并发处理">6.2 并发处理</h3>
<p><strong>使用单线程模型也并不意味着程序不能并发的处理任务，Redis 虽然使用单线程模型处理用户的请求，但是它却使用 I/O 多路复用机制并发处理来自客户端的多个连接，同时等待多个连接发送的请求。</strong></p>
<p>在 I/O 多路复用模型中，最重要的函数调用就是 select 以及类似函数，该方法的能够同时监控多个文件描述符（也就是客户端的连接）的可读可写情况，当其中的某些文件描述符可读或者可写时，select 方法就会返回可读以及可写的文件描述符个数。</p>
<p>使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要额外创建和维护进程和线程来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。</p>
<h3 id="性能瓶颈">6.3 性能瓶颈</h3>
<p>这个就是 Redis 选择单线程模型的决定性原因 —— 多线程技术能够帮助我们充分利用 CPU 的计算资源来并发的执行不同的任务，但是 CPU 资源往往都不是 Redis 服务器的性能瓶颈。哪怕在一个普通的 Linux 服务器上启动 Redis 服务，它也能在 1s 的时间内处理 1,000,000 个用户请求。</p>
<p>如果这种吞吐量不能满足我们的需求，更推荐的做法是使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。</p>
<p>简单总结一下，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的计算机的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；<strong>整个服务的瓶颈在于读写网络数据，也就是网络 I/O，因此对于命令处理只需要主线程参与就可以，真正多线程的是在于网络IO处</strong></p>
<blockquote>
<p>多线程网络IO带来的问题： - 多个线程对同一个客户端请求进行读取，带来数据的不保序问题， - 同时假如一个线程读取发现返回的<code>ret=0</code>，说明客户端关闭了连接，那么服务器也就执行关闭，但此时另一个线程正好对改连续对读取，完了，服务器报错了。（致命）</p>
<ul>
<li><strong>如何解决</strong>： Redis使用了队列+主线程阻塞的措施，在主线程通过epoll对链接的监听，不断向队列添加可读socket，然后当队列到达一定或者一定时间后，主线程自旋阻塞等待，并行I/O线程组将所有可读socket读完放入全局队列，完成后主线程按顺序取出处理</li>
</ul>
</blockquote>
<p>多线程虽然会更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的开销，其中包括：</p>
<ul>
<li>保存线程 1 的执行上下文；</li>
<li>加载线程 2 的执行上下文；</li>
</ul>
<p>频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。</p>
<h2 id="redis-多线程">7 Redis 多线程</h2>
<h3 id="redis-4.0">7.1 Redis 4.0</h3>
<p>虽然说 <code>Redis</code> 是单线程模型，但是， 实际上，<code>Redis</code> 在 4.0 之后的版本中就已经加入了对多线程的支持。</p>
<p>不过，<strong><code>Redis 4.0</code> 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</strong></p>
<p>Redis 在最新的几个版本中加入了一些可以被其他线程异步处理的删除操作，例如 <code>UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC</code>等非阻塞的删除操作。为什么会需要这些删除操作，而它们为什么需要通过多线程的方式异步处理？</p>
<h4 id="删除操作多线程的原因">7.1.1 删除操作多线程的原因</h4>
<p>可以在 Redis 在中使用 <code>DEL</code> 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是同步地删除这些键值对也不会消耗太多的时间。</p>
<p>但<strong>是对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的 PCT99 和可用性。</strong></p>
<p><strong>然而释放内存空间的工作其实可以由后台线程异步进行处理，这也就是 UNLINK 命令的实现原理，它只会将键从元数据中删除，真正的删除操作会在后台异步执行。</strong></p>
<blockquote>
<p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p>
</blockquote>
<h3 id="redis6.0-之后引入了多线程">7.2 Redis6.0 之后引入了多线程</h3>
<p><strong>引入多线程的原因：</strong></p>
<p>Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理80,000到100,000 QPS，这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。</p>
<p>但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的Redis服务器太多，维护代价大；某些适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂等等。</p>
<p>从Redis自身角度来说，因为读写网络的read/write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:</p>
<ul>
<li>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式</li>
<li>使用多线程充分利用多核，典型的实现比如 Memcached。</li>
</ul>
<p><strong>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，redis支持多线程主要就是两个原因：</strong></p>
<ul>
<li><strong>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核</strong></li>
<li><strong>多线程任务可以分摊 Redis 同步 IO 读写负荷</strong></li>
</ul>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</strong> 虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，也不需要担心线程安全问题。</p>
<blockquote>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 redis.conf ： <figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">&gt;io-threads-<span class="keyword">do</span>-reads <span class="literal">yes</span></span><br></pre></td></tr></table></figure> 开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 redis.conf : <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">io-threads 4 <span class="comment">#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span></span><br></pre></td></tr></table></figure> 关于线程数的设置，官方有一个建议：4核的机器建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数。还需要注意的是，线程数并不是越大越好，官方认为超过了8个基本就没什么意义了。</p>
</blockquote>
<h3 id="redis-多线程实现机制">7.3 Redis 多线程实现机制</h3>
<p><img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis多线程实现机制.png" width="700"></p>
<blockquote>
<p><strong>轮询调度算法(Round-Robin Scheduling)</strong>轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N (内部服务器个数)，然后重新开始循环。</p>
</blockquote>
<p><strong>流程简述如下：</strong></p>
<ol type="1">
<li><p>主线程负责接收建立连接请求，并监听可读socket，将可读 socket 放入全局等待读处理队列</p></li>
<li><p>队列慢满或者一定时间后，将这些连接分配给这些 IO 线程组,IO线程组与这些Socket绑定并且并行执行IO</p></li>
<li><p>主线程阻塞等待 IO 线程读取 socket 完毕，IO线程将这些请求读取并解析请求，放入队列</p></li>
<li><p>主线程通过单线程的按序取队列方式执行串行化执行请求命令，然后依次放入全局等待写处理队列。</p></li>
<li><p>主线程阻塞等待 IO 线程将数据回写 socket 完毕</p></li>
<li><p>解除绑定</p></li>
</ol>
<p><img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis多线程实现流程.png" width="700"></p>
<p>该设计有如下特点：</p>
<ul>
<li><p>IO 线程要么同时在读 socket，要么同时在写，不会同时读或写</p></li>
<li><p>IO 线程只负责并行读写 socket和解析命令，不负责命令执行，执行由主线程处理</p></li>
</ul>
<h2 id="memcached与redis的区别都有哪些">8 Memcached与Redis的区别都有哪些？</h2>
<h3 id="共同点">8.1 共同点</h3>
<ul>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ul>
<h3 id="区别">8.2 区别</h3>
<ul>
<li><strong>Redis支持更丰富的数据类型</strong>（支持更复杂的应用场景）：Redis不仅仅支持简单的k/v类型的数据，同时还提供<code>list,hash,set,zset</code>等数据结构的存储。memcached支持简单数据类型String（k/v)。</li>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而Memcached把数据全部存在内存之中</strong></li>
<li><strong>Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。</strong></li>
<li>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</li>
<li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是redis目前是原生支持cluster模式的</li>
<li><strong>Memcached是多线程的，非阻塞IO复用的网络模型；Redis使用单线程的多路复用IO模型（Redis 6.0 引入了多线程 IO ）</strong></li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li><strong>Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>
</ul>
<blockquote>
<p>Redis比Memcached的优势在哪里？ 1、Memcached所有的值均是简单字符串，Redis作为其替代者，支持更为丰富的数据类型</p>
</blockquote>
<blockquote>
<p>2、Redis 的速度比 Memcached 快很多</p>
</blockquote>
<blockquote>
<p>3、Redis可以做到持久化数据</p>
</blockquote>
<h2 id="redis为什么要给缓存数据设置过期时间">9 Redis为什么要给缓存数据设置过期时间</h2>
<p>一般情况下，设置保存的缓存数据的时候都会设置一个过期时间。</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接<code>Out of memory</code>。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exp key  <span class="number">60</span> # 数据在 <span class="number">60</span>s 后过期</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setex key <span class="number">60</span> value # 数据在 <span class="number">60</span>s 后过期 (setex:[set] + [ex]pire)</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl key # 查看数据还有多久过期</span><br><span class="line">(integer) <span class="number">56</span></span><br></pre></td></tr></table></figure> &gt;<strong><em>注意：</em></strong>Redis中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code>外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h2 id="redis-判断数据过期的原理">10 Redis 判断数据过期的原理</h2>
<p>Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis过期时间实现原理.png" width="800"></p>
<p>过期字典是存储在redisDb结构里的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisDb</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></p>
<h2 id="redis过期键处理方式">11 redis过期键处理方式</h2>
<p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如一般项目中的<code>token</code>或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p>
<p>在<code>set key</code>的时候，都可以给一个<code>expire time</code>，就是过期时间，通过过期时间可以指定这个key可以存活的时间。</p>
<p>Redis对过期的键采用的删除方式是：<strong>定期删除+惰性删除</strong></p>
<ul>
<li><strong>定期删除：</strong>redis默认是每隔<code>100ms</code>就随机抽取一些设置了过期时间的key,检查其是否过期，如果过期就删除。注意这里是随机抽取的。采用随机抽取的方式是因为如果Redis存了很多key的话，每隔<code>100ms</code>就遍历所有的设置过期时间的key的话，就会给CPU带来很大的负载。</li>
<li><strong>惰性删除：</strong>定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除。对于过期的key,如果过了时间还没有被定期删除，还停留在内存中，只有在系统中查询一下这个key，redis才会把它给删除掉，这就是所谓的惰性删除。</li>
</ul>
<p>但是仅仅通过设置过期时间还是有问题的。<strong>如果定期删除漏掉了很多过期key，然后也没及时去查，也就没走惰性删除，此时会有大量过期key堆积在内存里，导致redis内存块耗尽了。redis采用内存淘汰机制进行处理。</strong></p>
<h2 id="redis内存淘汰机制mysql中有2000w数据redis中只存了20w数据如何保证redis中的数据都是热点数据">12 redis内存淘汰机制（MySQL中有2000w数据，Redis中只存了20w数据，如何保证Redis中的数据都是热点数据？）</h2>
<p>可以使用Redis的数据淘汰策略，Redis 内存数据集大小上升到一定大小的时候，就会施行这种策略。具体说来，主要有 6种内存淘汰策略:</p>
<ul>
<li><strong><code>olatile-lru</code></strong>：从已设置过期时间的数据集<code>(server.db[i].expires)</code>中挑选最近最少使用的数据淘汰</li>
<li><strong><code>volatile-ttl</code></strong>：从已设置过期时间的数据集<code>(server.db[i].expires)</code>中挑选将要过期的数据淘汰</li>
<li><strong><code>volatile-random</code></strong>：从已设置过期时间的数据集<code>(server.db[i].expires)</code>中任意选择数据淘汰</li>
<li><strong><code>allkeys-lru</code></strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key(这个是最常用的)</li>
<li><strong><code>allkeys-random</code></strong>：从数据集(server.db[i].dict)中任意选择数据淘汰</li>
<li><strong><code>no-eviction</code></strong>:禁止驱逐数据，也就是说当内存不足以容纳新写入的数据时，新写入操作会报错。</li>
</ul>
<blockquote>
<p>另一种问法：定期和惰性一定能保证删除数据吗？如果不能，Redis会有什么应对措施？</p>
</blockquote>
<p>4.0版本以后增加了以下两种：</p>
<ul>
<li><strong><code>volatile-lfu</code></strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong><code>allkeys-lfu</code></strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li>
</ul>
<h2 id="缓存中常说的热点数据和冷数据是什么">13 缓存中常说的热点数据和冷数据是什么？</h2>
<p>其实就是名字上的意思，<strong>热数据就是访问次数较多的数据，冷数据就是访问很少或者从不访问的数据。</strong></p>
<p>需要注意的是<strong>只有热点数据，缓存才有价值 </strong>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。</p>
<p><strong>数据更新前至少读取两次，缓存才有意义</strong>。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<h2 id="redis持久化机制">14 Redis持久化机制</h2>
<p><strong>Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。</strong></p>
<p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机 器、机器故障之后回复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p><strong>实现机理</strong>：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放</p>
<p>Redis支持两种持久化方案，分别是<strong>RDB（快照）和AOF（只追加文件）</strong></p>
<h3 id="快照持久化rdb持久化">14.1 快照持久化（RDB持久化）</h3>
<p><strong>Redis可以通过创建快照RDB来获得存储在某个时间点上数据的副本。RDB就是是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的一个数据快照。同时因为RDB保存在磁盘上，所以即使Redis服务器进程退出，只要RDB存在，就能够还原数据库状态。因此非常适用于备份，全量复制等场景。</strong></p>
<p>Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。<strong>快照持久化是Redis默认采用的持久化方式。</strong></p>
<h4 id="rdb文件结构">14.1.1 RDB文件结构</h4>
<p><img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/RDB.png" width="800"></p>
<ul>
<li><code>redis</code>:5字节，保存&quot;REDIS&quot;五个字符，以便在载入文件时，快速检查载入文件是否为RDB文件，5字节长度。</li>
<li><code>db_version</code>:存储字符串形式整数，指示RDB文件的版本号，4字节长度。</li>
<li><strong><code>databases</code></strong>:包含零个或多个数据库，以及各个数据库中的键值对数据。
<ul>
<li>如果服务器的数据库状态为空，那么这部分为空。</li>
<li>非空，那么这个部分会根据数据库所保存的键值对数量、类型和内容不同来开辟空间。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/RDB03.png" width="800"></li>
</ul></li>
</ul>
<h4 id="rdb文件的创建及自动触发">14.1.2 RDB文件的创建及自动触发</h4>
<p>创建RDB文件的任务由<code>rdb.c/rdbSave</code>函数完成，Redis有两种命令来生成RDB文件，分别是<code>sava</code>和<code>bgsave</code>，这两个命令以不同形式调用<code>rdb.c/rdbSave</code>：</p>
<ul>
<li><strong><code>save</code></strong>:由主线程执行生成RDB操作，因此会阻塞当前Redis，直到RDB过程完成，对于内存比较大的实例会造成阻塞，已经被淘汰</li>
<li><strong><code>bgsave</code></strong>:Redis主线程进行执行fork操作创建子进程，RDB持久化过程由子进程完成，完成后自动结束，阻塞只发生在fork阶段，一般时间很短。</li>
</ul>
<p><strong>自动触发</strong>：</p>
<ul>
<li><p>使用save相关配置，会自动出发bgsave,在<code>redis.conf</code>配置文件中默认有此下配置： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>           #在<span class="number">900</span>秒(<span class="number">15</span>分钟)之后，如果至少有<span class="number">1</span>个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>          #在<span class="number">300</span>秒(<span class="number">5</span>分钟)之后，如果至少有<span class="number">10</span>个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>        #在<span class="number">60</span>秒(<span class="number">1</span>分钟)之后，如果至少有<span class="number">10000</span>个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure></p></li>
<li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li>
<li>执行debug reload命令时重新加载Redis时，也会自动触发save操作</li>
<li><p>默认情况下执行shutdown命令，如果没有开启AOF持久化功能则自动执行bgsave</p></li>
</ul>
<blockquote>
<p>自动触发流程：</p>
<ul>
<li>其设置会保存在<code>redisSever</code>结构的<code>saveparams</code>下 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/saveparams.png" width="800"></li>
<li>处理<code>saveparams</code>，redis服务器还维护一个<code>dirty</code>计数器，以及<code>lastsave</code>属性，<code>dirty</code>计数器记录数据库记录了离上一次<code>save</code>或<code>bgsave</code>执行了多少次修改，<code>lastsave</code>是一个unix时间戳</li>
<li>Redis周期性的执行一个操作函数<code>serverCron</code>,其中一项工作就是检查<code>save</code>或<code>bgsave</code>所设置的条件是否满足。满足则触发生成RDB操作。</li>
</ul>
</blockquote>
<h4 id="save执行时服务器状态">14.1.3 SAVE执行时服务器状态</h4>
<ul>
<li>SAVE命令执行时，Redis服务会阻塞，所以当SAVE命令正在执行时，客户端发生的所有命令请求都会被拒绝。</li>
<li>save完成后,才可以处理客户端的下一条命令</li>
</ul>
<h4 id="bgsave执行是服务器状态">14.1.4 BGSAVE执行是服务器状态</h4>
<ul>
<li>Redis为了避免产生条件禁止，禁止<code>SAVE</code>命令和<code>BGSAVE</code>命令同时调用<code>rdb.c/rdbSave</code>；因此在<code>BGSAVE</code>命令下，<code>SAVE</code>和<code>BGSAVE</code>命令会被拒绝；</li>
<li>在<code>BGSAVE</code>命令下，<code>BGREWRITEAOF</code>命令会被延迟到<code>BGSAVE</code>命令执行完毕后执行。虽然<code>BGREWRITEAOF</code>和<code>BGSAVE</code>不会冲突，但两个子进程同时执行大量的磁盘写入操作，这显然不是一个好主意。（多线程下，数据安全要保证）</li>
</ul>
<p><strong>bgsave执行的流程如下：</strong></p>
<ol type="1">
<li>执行<code>bgsave</code>命令，Redis父进程判断当前是否存在正在执行的子进程，如果<code>RDB/AOF</code>子进程存在则直接返回</li>
<li>父进程执行<code>fork</code>操作创建子进程，<code>fork</code>操作过程父进程会阻塞。（通过<code>info stats</code>查看<code>latest_fork_usec</code>选项，获得最近一个<code>fork</code>操作的耗时，单位为微秒）</li>
<li>父进程<code>fork</code>完成后，<code>bgsave</code>命令返回<code>Background saving started</code>信息并不再阻塞父进程，可以继续响应其他命令</li>
<li>子进程创建<code>RDB</code>文件，根据父进程内存生成的临时快照文件，完成后对原有文件进行原子替换，执行<code>lastsave</code>可以获取最后一次生成<code>RDB</code>的事件，对应info统计的<code>rdb_last_save_time</code></li>
<li>进程发送信号给父进程表示完成，父进程更新统计信息，存放在<code>info</code>的<code>Persistence</code>下。</li>
</ol>
<h4 id="rdb持久化的优缺点">14.1.5 RDB持久化的优缺点</h4>
<h5 id="rdb模式的优点">RDB模式的优点</h5>
<ul>
<li><p>RDB快照保存了某个时间点的数据，可以通过脚本执行redis指令bgsave(非阻塞，后台执行)或者save(会阻塞写操作,不推荐)命令自定义时间点备份，<strong>可以保留多个备份，当出现问题可以恢复到不同时间点的版本,很适合备份</strong>,并且此文件格式也支持有不少第三方工具可以进行后续的数据分析，并且能够把备份的数据导出到指定的文件下，其他redis重启进行加载。<strong>比如: 可以在最近的24小时内，每小时备份一次RDB文件，并且在每个月的每一天，也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</strong></p></li>
<li><p><strong>RDB可以最大化Redis的性能，父进程在保存 RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘工/0操作。</strong></p></li>
<li><p><strong>因为是直接数据恢复，不是操作恢复。因此RDB在大量数据,比如几个G的数据，恢复的速度比AOF的快</strong></p></li>
</ul>
<h5 id="rdb模式的缺点">RDB模式的缺点</h5>
<ul>
<li><strong>不能实时保存数据，可能会丢失自上一次执行RDB备份到这一次还未达到条件备份但已发生部分修改的数据</strong></li>
<li><p>如果你需要尽量避免在服务器故障时丢失数据，那么RDB并不适合。虽然Redis允许设置不同的保存点（save point）来控制保存RDB文件的频率，但是，因为RDB文件需要保存整个数据集的状态，所以它并不是一个轻松快速的操作。因此一般会超过5分钟以上才保存一次RDB文件。在这种情况下，一旦发生故障停机，你就可能会丢失好几分钟的数据。</p></li>
<li><p>当数据量非常大的时候，从父进程<code>fork</code>子进程进行保存至RDB文件时需要一点时间，可能是毫秒或者秒。因此在数据集比较庞大时，<code>fork()</code>可能会非常耗时，造成服务器在一定时间内停止处理客户端﹔如果数据集非常巨大，并且CPU时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒或更久。</p></li>
</ul>
<h3 id="aof持久化">14.2 AOF持久化</h3>
<p>与RDB持久化通过保存数据库中的键值对来记录数据库的状态不同，AOF持久化是通过保存Redis服务器的写命令来记录数据库的状态。</p>
<p>以独立日志的方式记录每次写命令，将写命令添加到<code>AOF</code> 文件（<code>Append Only File</code>）的末尾。重启时再重新执行<code>AOF</code>文件中的命令达到恢复数据的目的。AOF的主要作用是解决数据持久化的实时性，因此已成为主流的持久化方案。</p>
<p>默认情况下Redis没有开启AOF方式的持久化，可以通过以下配置开启： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure> 开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是<code>appendonly.aof</code>。</p>
<h4 id="aof持久化的实现">14.2.1 AOF持久化的实现</h4>
<p>AOF持久化的实现可以分为命令追加、文件写入、文件同步：</p>
<ul>
<li><strong>写入命令(append)</strong>:所有的写入命令都会追加到aof_buf缓冲区</li>
<li><strong>文件写入和同步</strong>：通过<code>flushAppendOnlyFile</code>函数考虑是否将aof_buf缓冲区的命令写入AOF文件,<code>flushAppendOnlyFile</code>的行为由服务器配置的<code>appendfsync</code>选项的值来决定；然后AOF缓冲区根据对应的策略向硬盘做同步操作： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>
<ul>
<li><code>always</code>：写入aof_buf后调用系统fsync操作同步到AOF文件，fsync完成后线程返回；每次写入都要进行文件同步，严重降低Redis速度，一般不建议使用</li>
<li><code>everysec</code>：命令写入aof_buf后调用系统write操作，完成后线程返回。fsync同步文件操作由专门线程每秒调用一次；建议的策略，理论上在系统突然宕机的情况下会丢失1秒数据，fsync完成后会与上次fsync时间做对比，超过两秒后主线程阻塞，直到同步操作完成,因此最多可能丢失2秒数据，不是1秒</li>
<li><code>no</code>:命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒，周期不可控，加大每次同步的数据量，虽然提升了性能，安全性无法保证</li>
</ul></li>
<li><strong>重启加载(load)</strong>:当Redis服务器重启时，可以加载AOF文件进行数据恢复</li>
</ul>
<h4 id="redis-4.0-对于持久化机制的优化">14.2.2 Redis 4.0 对于持久化机制的优化</h4>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h4 id="aof重写机制">14.2.3 AOF重写机制</h4>
<p><strong>随着命令不断写入<code>AOF</code>，文件会越来越大,如果不加以控制的话，使用AOF文化进行数据还原所需的时间会越来越多，因此Redis引入重写机制压缩文件体积</strong>，AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程</p>
<p><strong>AOF重写并不是对现有的AOF文件进行任何读取、分析和写入操作，而是通过读取服务器的当前数据库状态来实现的。其由重写程序<code>aof_rewrite</code>函数实现，因为这个函数会进行大量的写入操作，所以调用这个函数的线程将会长时间阻塞，因此redis将这个AOF重写程序放到子进程执行，即让服务器进程可以举行处理请求，同时避免使用锁的情况下保证数据安全性。</strong></p>
<p><strong>重写后AOF文件变小的原理：</strong></p>
<ul>
<li>进程内已经超时的数据不再写入文件</li>
<li>旧的AOF文件含有无效命令，如<code>del key</code>，<code>hdel key2</code>，<code>srem keys</code>，<code>set a1</code>，<code>set a2</code>等，重写时使用进程内的数据直接生成，这样新的AOF文件只保留最终数据的写入命令</li>
<li>多条写的命令合并为一条，如<code>lpush list a</code>，<code>lpush list b</code>转化为<code>lpush list a b</code>，为了防止过多造成客户端缓冲区溢出，以64个元素为界拆分多条</li>
</ul>
<p><strong>重写的优点：降低文件占用空间，更快的被Redis加载</strong></p>
<h5 id="aof重写缓冲区">AOF重写缓冲区</h5>
<p>虽然AOF使用了子进程来执行重写程序，避免服务器父进程的阻塞，以及能在不使用锁前提下保证数据安全，<strong>但也有一种情况要考虑，在子进程重写AOF期间，服务器进程还需要继续处理客户端请求，新的命令可能会对数据库状态修改，从而使得服务器当前的数据库状态与重写的AOF所保存的数据库状态不一致</strong>。</p>
<p>为解决该问题，提出了AOF重写缓冲区，这个缓冲区在服务器创建AOF子进程后开始使用，当Redis服务器执行完一个写命令后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区，当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容 追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致</p>
<h5 id="重写过程的触发">重写过程的触发：</h5>
<ul>
<li><strong>手动触发</strong>：使用bgrewriteaof命令</li>
<li><strong>自动触发</strong>：配置文件配置<code>auto-aof-rewrite-min-size</code>,<code>auto-aof-rewrite-percentage</code>,前者表示AOF重写时文件最小体积，默认64MB，后者代表AOF文件空间（<code>aof_current_size</code>）和上一次重写后AOF文件空间（<code>aof_base_size</code>）的比值</li>
</ul>
<h5 id="重写流程">重写流程</h5>
<ol type="1">
<li>执行<code>AOF</code>重写请求，如果当前进程正在执行AOF重写，请求不执行；如果当前进程正在执行<code>bgsave</code>操作，重写命令延迟到<code>bgsave</code>完成之后再执行</li>
<li>父进程执行<code>fork</code>创建子进程，开销等同于<code>bgsave</code></li>
<li>(1).主进程<code>fork</code>操作完成后，继续响应其他命令，所有修改命令依然写入<code>AOF</code>缓冲区并根据<code>appendfsync</code>策略同步到硬盘，保证原有<code>AOF</code>机制正确性 (2).由于<code>fork</code>操作运用<strong>写时复制技术</strong>，子进程只能共享<code>fork</code>操作时的内部数据。由于父进程依然响应命令，<strong>Redis使用AOF重写缓冲区保证这部分新数据，防止新的AOF文件生成期间丢失这部分数据</strong></li>
<li>子进程根据内存快照，按照命令合并规则写入到新的AOF文件，每次批量写入硬盘数据量由配置<code>aof-rewrite-incremental-fsync</code>控制，默认<code>32MB</code>，防止单次刷盘数据过多造成硬盘阻塞</li>
<li>(1). 新AOF文件写入完成后，子进程发送信号给父进程，父进程更新统计信息 (2). 父进程把AOF重写缓冲区的数据写入到新的AOF文件 (3). 使用新的AOF文件替换老文件，重写完成</li>
</ol>
<h4 id="aof模式的优缺点">14.2.4 AOF模式的优缺点</h4>
<h5 id="aof模式的优点">AOF模式的优点</h5>
<ul>
<li><p><strong>可以提供实时性保存，数据安全性相对较高</strong>。根据所使用的fsync策略(fsync是同步内存中redis所有已经修改的文件到存储设备)，默认是appendfsync everysec，即每秒执行一次 fsync,在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据( fsync会在后台线程执行，所以主线程可以继续努力地处理命令请求)</p></li>
<li><p><strong>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中不需要seek, 即使出现宕机现象，也不会破坏日志文件中已经存在的内容</strong>。然而如果本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，可以通过 redis-check-aof 工具来解决数据一致性的问题</p></li>
<li><p><strong>Redis可以在 AOF文件体积变得过大时，自动地在后台对AOF进行重写,重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合</strong>。整个重写操作是绝对安全的，因为Redis在创建新 AOF文件的过程中，append模式不断的将修改数据追加到现有的 AOF文件里面，即使重写过程中发生停机，现有的 AOF文件也不会丢失。而一旦新AOF文件创建完毕，Redis就会从旧AOF文件切换到新AOF文件，并开始对新AOF文件进行追加操作。</p></li>
<li><p><strong>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作</strong>。事实上，也可以通过该文件完成数据的重建。AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此 AOF文件的内容非常容易被人读懂，对文件进行分(parse)也很轻松。</p></li>
</ul>
<h5 id="aof模式的缺点">AOF模式的缺点</h5>
<ul>
<li>即使有些操作是重复的也会全部记录，AOF 的文件大小要大于 RDB 格式的文件</li>
<li>AOF 在恢复大数据集时的速度比 RDB 的恢复速度要慢，重复操作过程，不是直接导入数据。</li>
<li>根据fsync策略不同,AOF速度可能会慢于RDB</li>
<li>bug 出现的可能性更多</li>
</ul>
<h3 id="rdb和aof-的选择">14.3 RDB和AOF 的选择</h3>
<ul>
<li><p>如果主要充当缓存功能,或者可以承受数分钟数据的丢失, 通常生产环境一般只需启用RDB即可,此也是默认值</p></li>
<li><p>如果数据需要持久保存,一点不能丢失,可以选择同时开启RDB和AOF</p></li>
<li><p>一般不建议只开启AOF</p></li>
</ul>
<h2 id="缓存雪崩是什么如何解决">15 缓存雪崩是什么，如何解决？</h2>
<p>缓存雪崩指的是缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量的请求而崩掉。可以理解为<strong>由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，此时所有原本应该访问缓存的请求都去查询数据库了，这对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。</strong></p>
<h3 id="解决方法">15.1 解决方法</h3>
<ul>
<li><strong>事前：</strong>尽量保证整个 Redis 集群的高可用性，发现机器宕机尽快补上，选择合适的内存淘汰策略。</li>
<li><strong>事中</strong>：本地<code>ehcache缓存 + hystrix限流&amp;降级</code>，避免MySQL崩掉， 通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li>
<li><strong>事后</strong>：利用 Redis 持久化机制保存的数据尽快恢复缓存 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/缓存雪崩解决方案.png" width="800"></li>
</ul>
<h2 id="缓存穿透是什么如何解决">16 缓存穿透是什么，如何解决？</h2>
<p><strong>缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法查询出结果，因此也不会写入到缓存中，这将会导致每个查询都会去请求数据库，造成缓存穿透。</strong></p>
<p>举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h3 id="解决方法-1">16.1 解决方法</h3>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<h4 id="方法一布隆过滤器">16.1.1 方法一：布隆过滤器</h4>
<p>将所有可能存在的数据哈希到一个足够大的<code>bitmap</code>中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。即对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p>
<p>流程如下： <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/加入布隆过滤器后的缓存处理流程.png" width="800"></p>
<p>这里稍微科普一下布隆过滤器: &gt;布隆过滤器是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率&gt;&gt;下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 &gt; &gt;该算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是布隆过滤器的基本思想，一般用于在大数据量的集合中判定某元素是否存在。</p>
<h4 id="方法二缓存空对象">16.1.2 方法二：缓存空对象</h4>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；如果一个查询返回的数据为空（不管是数据不存 在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<p><strong>但是这种方法会存在两个问题：</strong></p>
<ul>
<li><p>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；（对于黑客攻击来说，内存极有可能分分钟out of memory,因此对于空值键其过期时间应该短一些)</p></li>
<li><p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p></li>
</ul>
<p><strong>我们可以从适用场景和维护成本两方面对这两汇总方法进行一个简单比较：</strong></p>
<ul>
<li><p><strong>适用场景：</strong>缓存空对象适用于数据命中不高但数据频繁变化且实时性较高 ；而布隆过滤器适用数据命中不高但数据相对固定即实时性较低</p></li>
<li><p><strong>维护成本</strong>：缓存空对象的方法代码维护简单但需要较多的缓存空间，而且数据会出现不一致的现象；布隆过滤器的代码维护较复杂但缓存空间要少一些</p></li>
</ul>
<h2 id="缓存预热">17 缓存预热</h2>
<p>热数据就是访问次数较多的数据，冷数据就是访问很少或者从不访问的数据。只有热点数据，缓存才有价值，对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。</p>
<p>对于热点数据，我们希望缓存应该总是命中的，<strong>缓存预热</strong>是指系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户会直接查询事先被预热的缓存数据！</p>
<p>方法：</p>
<ul>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ul>
<h2 id="缓存击穿是什么">18. 缓存击穿是什么</h2>
<p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>比如常见的电商项目中，某些货物成为“爆款”了，可以对一些主打商品的缓存直接设置为永不过期。即便某些商品自己发酵成了爆款，也是直接设为永不过期就好了。</p>
<h2 id="缓存降级是什么">19 缓存降级是什么</h2>
<p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，这时仍然需要保证服务还是可用的，即使是有损服务。此时系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 降级的最终目的是保证核心服务可用，即使是有损的</p>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。<strong>因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</strong></p>
<blockquote>
<p>可以参考日志级别设置预案： （1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； （2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； （3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； （4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>
</blockquote>
<h2 id="如何解决redis的并发竞争key问题">20 如何解决Redis的并发竞争key问题</h2>
<p>所谓Redis的并发竞争Key的问题也就是多个系统同时对一个Key进行操作，但是最后执行的顺序和期望的顺序不同，这样也就导致了结果的不同。</p>
<p>解决方案：可以使用分布式锁（Zookeeper和 redis 都可以实现分布式锁）。（如果不存在Redis的并发竞争Key问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点来释放锁。</p>
<p>在实践中，当然是以可靠性为主,所以首推Zookeeper。</p>
<blockquote>
<p>你要写入缓存的数据，都是从 mysql 里查出来的，都得写入 mysql 中，写入 mysql 中的时候必须保存一个时间戳，从 mysql 查出来的时候，时间戳也查出来。</p>
<p>每次要写之前，先判断一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>
</blockquote>
<h3 id="进一步提问了解redis的cas方案吗">20.1 进一步提问：了解redis的CAS方案吗?</h3>
<p>Redis提供CAS 乐观锁方案能够天然的解决这个问题。</p>
<p>Redis事物 Redis 通过<code>MULTI 、EXEC、WATCH</code>等命令来实现事物功能。事物提供了一种将多个命令请求打包，然后一次性、按顺序的执行多个命令的机制，并且在事物执行期间，服务器不会中断事物而去执行其他客户端的命令请求，它会将事物中所有的命令都执行完毕，然后才去处理其他客户端的请求。</p>
<ul>
<li>事务首先以<code>MULTI</code>命令开始，<code>MULTI</code>后接下来对键的操作命令都会入队列；</li>
<li><code>EXEC</code>相当于提交事务执行</li>
<li><code>WATCH</code>命令是一个乐观锁，它可以在<code>EXCE</code>命令执行之前，监视任意数量的数据库键；并在<code>EXCE</code>执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器拒绝执行事务，并向客户端返回代表事务执行失败的空回复。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/Redis事务执行机制.png" width="700"></li>
</ul>
<h4 id="watch命令的乐观锁机制">WATCH命令的乐观锁机制</h4>
<p>每个redis数据库都保存一个<code>watch_key</code>字典属性，这个字典保存着被<code>watch</code>的键和对于客户端。当某一个客户端执行<code>watch</code>某个键后，该字典就会进行记录，之后所有对数据库修改的命令，比如<code>SET、LPUSH、SADD、ZREM、DEL、</code>等等，都会调用<code>touchWatchKey</code>函数对<code>watch_key</code>字典进行检查，查看是否有客户端正在监视刚刚被修改的键，如果有，对应客户端的<code>REDIS_DIATY_CAS</code>标识被打开，表示这个客户端的事务安全性被破坏，那么服务器会拒绝执行这个客户端的对应事务，以此来保证事务安全性。</p>
<p><img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/watch机制.png" width="700"> 上图表示，该数据库中的<code>name</code>被客户端<code>c1、c2</code>监视着，<code>age</code>被<code>c3</code>监视着，<code>address</code>被<code>c2、c4</code>监视着，在客户端<code>c10086</code>执行下述命令后，<code>name</code>和<code>age</code>也被<code>c100088</code>监视着。之 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端c10086</span></span><br><span class="line">redis&gt;watch <span class="string">&quot;age&quot;</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">redis&gt;MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt;SET <span class="string">&quot;name&quot;</span> <span class="string">&quot;trluper&quot;</span></span><br><span class="line">QUEUE</span><br><span class="line">redis&gt;<span class="built_in">EXCE</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="comment">//nil说明有另一个客户端对name执行修改，服务器对c10086的该事务拒绝执行</span></span><br></pre></td></tr></table></figure></p>
<h2 id="redis事务">21 Redis事务</h2>
<p>Redis提供了简单的事务功能，将一组需要执行的命令放到<code>multi</code>和<code>exec</code>之间，<code>multi</code>代表事务开始，<code>exec</code>代表事务结束，只有执行了<code>exec</code>后中间的命令才会被执行</p>
<p>如果要停止事务的执行，可以使用<code>discard</code>命令代替<code>exec</code></p>
<p>事务中出现错误的情况：</p>
<ul>
<li>命令错误：例如语法错误，会导致整个事务无法执行</li>
<li>运行时错误：例如对于字符串键值,错将<code>SET</code>写成<code>LPUSH</code>，这时候执行<code>exec</code>时正确的命令会被执行，因此Redis不支持<strong>回滚功能</strong></li>
</ul>
<p>在事务之前如果需要确保事务中的<code>key</code>没有被其他客户端修改才能执行，否则不执行（乐观锁），可以通过在<code>multi</code>之前先执行<code>watch</code>命令来实现</p>
<p>Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</p>
<p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。</p>
<ul>
<li><strong>原子性：</strong>Redis的事务中对多个操作当以整体执行，要么都执行，要么都不执行。当redis不支持回滚功能，对于运行时的错误，整个事务会继续执行下去。</li>
<li><strong>一致性</strong>：无论事务是否成功执行，数据库也应该仍然一致的，即数据库的状态符合要求，没有包含非法或者无效数据。
<ul>
<li>入队错误（命令错误）：例如语法错误，会导致整个事务无法执行，一致性能保证。</li>
<li>运行时错误：在执行过程在，出错的的命令会被服务器识别出来，并进行错误处理，所以这些出错命令不会对数据库做出修改。</li>
<li>服务器宕机，若开启了持久化，可将数据库还原到一个一致性状态；未开启，一个空的数据库就是一个一致性状态。</li>
</ul></li>
<li>隔离性：Redis使用单线程来处理命令，而事务是被认为当个命令来执行的，隔离性能够保证。</li>
<li>持久性：Redis事务的持久性由Redis所使用的持久化模式决定。
<ul>
<li>对于RDB，异步执行BGSAVE不能保证事务数据被第一时间保存到硬盘，因此无法保证持久性。</li>
<li><strong>对于AOF，当选择<code>appendfsync</code>选择<code>always</code>时，程序同步保存，这种配置下事务具有持久性。</strong></li>
</ul></li>
</ul>
<h2 id="如何保证缓存与数据库双写时的数据一致性">22 如何保证缓存与数据库双写时的数据一致性？</h2>
<blockquote>
<p>互联网公司非常喜欢问这道面试题因为缓存在互联网公司使用非常频繁 <strong>在高并发的业务场景下，数据库的性能瓶颈往往都是用户并发访问过大。所以，一般都使用Redis做一个缓冲操作，让请求先访问到Redis，而不是直接去访问MySQL等数据库，从而减少网络请求的延迟响应。</strong></p>
</blockquote>
<p>我们使用缓存的目的是为了提升查询的性能。大多数情况下，我们是这样使用缓存的： <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/question.png" width="600"></p>
<p>如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢，这里就涉及到了双写问题。<strong>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题</strong>？要弄明白这个问题，并且能够理解各种情况，需要一步步的说明： <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/Redis与MySQL双写一致性保证.png" width="600"></p>
<h3 id="什么是一致性">22.1 什么是一致性</h3>
<p><strong>一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。</strong></p>
<ul>
<li><strong>强一致性</strong>：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</li>
<li><strong>弱一致性</strong>：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</li>
<li><strong>最终一致性</strong>：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</li>
</ul>
<h3 id="不同的双写策略">22.2 不同的双写策略</h3>
<p>对于缓存和数据库的更新有以下四种：<strong>①先写缓存，再写数据库；②先写数据库，再写缓存；③先删缓存，再写数据库；④先写数据库，再删缓存（<code>Cache Aside Pattern旁路缓存模式</code>）</strong></p>
<ul>
<li><p><strong>先写缓存，再写数据库</strong>：拒绝使用。试想某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了。其结果是缓存更新成了最新数据，但数据库根本没有，这样缓存中的数据变成脏数据了。（就好像你往银行存款1000元，你是存进缓存了，但是没有进数据库，那么当银行因为某些原因缓存更新，发现你这1000块不翼而飞，这个问题极其严重）。</p></li>
<li><strong>先写数据库，再写缓存</strong>：也不推荐使用，在高并发场景下，写数据库与写缓存不在同一事务中，如果写数据库成功，但写缓存失败，这就会导致数据库是新数据，而缓存是旧数据，两边数据不一致的情况。
<ul>
<li>另一个问题就是，多个写并发场景下，由于写缓存的网络卡顿，导致数据不一致 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/先写数据库再写缓存.png" width="600"></li>
</ul></li>
</ul>
<h4 id="cache-aside-pattern旁路缓存模式">22.2.1 Cache Aside Pattern旁路缓存模式</h4>
<p><strong>解决双写数据一致性问题的最经典的模式，就是Cache Aside Pattern旁路缓存模式，它的提出尽可能地解决缓存与数据库的数据不一致问题。</strong></p>
<ul>
<li><strong>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</strong></li>
<li><strong>更新的时候,先更新数据库，再删除缓存</strong></li>
</ul>
<p><img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/cacheAside.png" width="600"></p>
<p>但是旁路缓存模式也不是百分百的保证缓存与数据库一致，</p>
<ul>
<li><p><strong>问题：先更新数据库，再删除缓存，如果删除缓存失败了(删除命令阻塞在网络中），导致数据库中是新数据，缓存中是旧数据，就出现数据不一致的问题。</strong>假设存在下面这种情况<strong>缓存失效，查询先于写</strong>,： <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/special.png" width="600"></p>
<ul>
<li>缓存过期时间到了，自动失效。</li>
<li>请求f查询缓存，发缓存中没有数据，查询数据库的旧值，但由于网络原因卡顿了，没有来得及更新缓存。</li>
<li>请求e先写数据库，接着删除了缓存。</li>
<li>请求f更新旧值到缓存中。</li>
</ul></li>
</ul>
<h4 id="先删缓存再写数据库">22.2.2 先删缓存，再写数据库</h4>
<p>Cache Aside Pattern旁路缓存模式存在问题：先更新数据库，再删除缓存，如果删除缓存失败了，导致数据库中是新数据，缓存中是旧数据，就出现数据不一致的问题。</p>
<p>解决思路：<strong>先删除缓存，再更新数据库。</strong></p>
<ul>
<li><strong>缓存删除失败</strong>：如果缓存删除失败，那么就不会继续执行，数据库信息没有被修改，保持了数据的一致性；</li>
<li><strong>缓存删除成功，数据库更新失败</strong>：此时数据库里的是旧数据，缓存是空的，查询时发现缓存不存在，就查询数据库并更新缓存，数据保持一致。</li>
</ul>
<p>问题：上面的方案也存在不足，如果删除完缓存更新数据库出现网络卡顿时，这时如果一个请求过来查询数据，缓存不存在，就查询数据库的旧数据，更新旧数据到缓存中。随后数据更新完成，修改了数据库的数据，此时缓存和数据库的数据就会出现不一致了。高并发下会出现这种数据库 + 缓存不一致的情况。 <strong>如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</strong></p>
<p><strong>解决方案：</strong>采用<strong>双删除策略</strong>。写请求先删除缓存，再去更新数据库，等待一段时间后再异步删除缓存。这样可以保证在读取错误数据时能及时被修正过来。</p>
<blockquote>
<p>还有一种策略，就是：写请求先修改缓存为指定值，然后再去更新数据库，再更新缓存。读请求过来后，会先读缓存，判断是指定值后就进入循环读取状态，等到写请求更新缓存。如果循环超时就去数据库读取数据，更新缓存。这种方案保证了读写的一致性，但由于读请求等待写请求的完成，会降低系统的吞吐量。</p>
</blockquote>
<h5 id="进一步提问那二次删除也失败怎么办">进一步提问，那二次删除也失败怎么办？</h5>
<ul>
<li><strong>解决方法：引入删除缓存重试机制</strong>。既然删除失败那就多删除几次，保证删除缓存成功。
<ul>
<li>可以把删除失败的key放进消息队列mq，然后消费消息队列的消息，获取要删除的key，重试删除缓存操作。</li>
<li>也可以用定时任务进行重试多次。</li>
</ul></li>
</ul>
<p>上面采用mq的方法做重试机制，对业务都有一定的侵入性。在使用定时任务的方案中，需要在业务代码中增加额外逻辑，如果删除缓存失败，需要将数据写入重试表。而使用mq的方案中，如果删除缓存失败了，需要在业务代码中发送mq消息到mq服务器。</p>
<h5 id="binlog异步淘汰key">binlog异步淘汰key</h5>
<p><strong>上述的步骤，都是在业务线里面执行，可新增一个线下的读取binlog异步淘汰缓存模块，读取binlog总的数据，然后进行异步淘汰。因此另一种更优雅方法就是<code>监听binlog+重试机制</code>：</strong></p>
<ul>
<li>读请求走Redis：热数据基本都在Redis</li>
<li>写请求走MySQL: 增删改都操作MySQL</li>
</ul>
<p><img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/binlog.png" width="600"> 一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新，就无需在从业务线去操作缓存内容。</p>
<ol type="1">
<li>mysql发生变更产生一条binlog</li>
<li>binlog写进消息队列（MQ）</li>
<li>程序监听消息队列，得到binlog消息</li>
<li>解析binlog，得到变更的内容</li>
<li>将变更的内容更新至redis</li>
</ol>
<h3 id="为什么采用删除而不是更新缓存">22.3 为什么采用删除而不是更新缓存？</h3>
<p>很多时候复杂的缓存场景，缓存不是仅仅从数据库中取出来的值。可能是关联多张表的数据并通过计算才是缓存需要的值。并且，更新缓存的代价有时候很高。<strong>缓存存在的意义是优化查询速度，对于需要频繁写操作，而读操作很少的时候，每次进行数据库的修改，缓存也要随之更新，会造成系统吞吐的下降，但此时缓存并不会被频繁访问到，用到的缓存才去算缓存。</strong>删除缓存而不是更新缓存，是一种懒加载的思想，不是每次都重复更新缓存，只有用到的时候才去更新缓存，同时即使有大量的读请求，实际也就更新了一次，后面的请求不会重复读</p>
<h2 id="redlock分布式锁">23 Redlock分布式锁</h2>
<p>RedLock算法是Redis作者提出基于Redis在分布式锁的一种实现。在介绍RedLock之前，先来看看传统的单机锁和分布式锁的比较，还有常见的分布式锁实现方案。 ### 23.1 单机锁 vs 分布式锁 当我们的业务数据流量上来了之后，系统的架构就会从单机集中式系统升级位分布式架构。在单机系统高并发的情况下，我们直接使用内置的锁比如<code>Synchronize</code>或者是<code>ReentrantLock</code>或者<code>mutex</code>就可以实现业务需求。</p>
<p><strong>这类锁属于单机锁，对于单机架构来说是完全够用的。但并不适用于在分布式架构中。用户请求通过负载均衡设备打在每个服务上面的，单机锁只能够限制打入到当前机器的请求，并不能限制整个分布式集群。</strong> <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/单机锁和分布式锁.png" width="700"> 在分布式环境下，如果我们想要并发严格控制资源，那么就需要用到分布式锁。</p>
<h3 id="常见分布式锁实现">23.2 常见分布式锁实现</h3>
<p>常见的分布式锁实现有基于<code>Redis、Mysql、Zookeeper</code>的。归根到底是因为这些中间件可以提供共享资源的一个能力。</p>
<h4 id="redis">23.2.1 Redis</h4>
<p>基于Redis的实现，也是非常常见的一种解决方案。因为一个系统可能没有Zookeeper，可能没有消息中间件，但是Redis缓存肯定会有</p>
<h5 id="key的唯一性">Key的唯一性</h5>
<p>一种实现方案是基于Key的唯一性。也就是<code>setNx</code>，那条指令。 <figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">原理：setNx 就是 <span class="keyword">set</span> if <span class="comment">not Existed</span> （存入<span class="comment">Key</span>如果没有存在的话</span><br></pre></td></tr></table></figure></p>
<p><strong>在单点上获取分布式锁</strong>： 一般我们都会携带超时时间，避免释放锁的时候出现故障导致Key一直存活在Redis里面无法再次进行锁的获取。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX <span class="number">30000</span></span><br></pre></td></tr></table></figure> 该命令仅当key不存在（NX保证）时，set值，并且设置过期时间为3000ms(PX保证)，值my_random_value必须是所有client和所有锁请求发生期间唯一的，释放锁的逻辑是： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.<span class="built_in">call</span>(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.<span class="built_in">call</span>(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure> 上述实现避免了释放另一个client创建的锁。如果只有<code>del</code>命令的话，如果<code>client1</code>拿到<code>lock1</code>之后因为某些操作阻塞了很长时间，此时<code>Redis</code>端<code>lock1</code>已经过期了并且已经被重新分配给了<code>client2</code>,那么<code>client1</code>此时再去释放这把锁就会造成<code>client2</code>原本获取到的锁被<code>client1</code>无故释放了，但现在为每<code>个client</code>分配一个<code>unique</code>的<code>string</code>值可以避免这个问题。至于如何去生成这个<code>unique string</code>，方法很多随意选择一种就行了。</p>
<p>缺点：<strong>Redis基于Key唯一性只能使用于单Redis实例，不支持Redis集群</strong>。 并且如果锁所在的Redis实例挂掉了之后，别的客户端就可以趁机而入进行锁的获取，但是已经拿到锁的客户端无法感知。</p>
<p>那有没有能够支持Redis集群的锁呢？现在Redis基本都是集群架构来抗并发压力了。答案其实是有的RedLock。</p>
<h3 id="redlock">23.3 RedLock</h3>
<h4 id="算法思想">23.3.1 算法思想</h4>
<ol type="1">
<li>获取当前的时间戳</li>
<li>使用同一个<code>Key</code>且带有超时时间，向<code>Redis</code>集群发出锁获取请求，并且给客户端也设置一个超时时间，防止<code>Redis</code>实例挂掉了之后客户端还傻傻等待。（客户端超时时间要比Key的超时时间要短）</li>
<li>超过半数实例获取锁成功并且没有超过客户端超时时间（根据步骤1计算），那么就是视为客户端成功获取锁。</li>
<li>如果获取锁失败，比如没有得到半数客户端加锁成功或者是超时了就视为获取锁失败，客户端需要向全部<code>Redis</code>实例发送解锁请求（del）。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/RedLock.png" width="700"></li>
</ol>
<h4 id="redlock是否真的能彻底解决分布式锁的问题呢">23.3.2 RedLock是否真的能彻底解决分布式锁的问题呢？</h4>
<p>正常情况下，是可以解决分布式问题的。但是面对极端情况下，RedLock可能就不包熟了！</p>
<ul>
<li><strong>加锁的节点宕机情景</strong> <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/加锁节点宕机.png" width="700">
<ul>
<li><strong>解决办法：</strong>
<ul>
<li><strong>持久化数据，</strong>使用AOF方式来存储数据，尽可能地保存全部锁的数据，当节点宕机之后也能保证重启之后锁依然在Redis中。AOF同步策略中，有每秒同步、每次同步。设置位每秒同步，每次进行写操作的时候都会写日志，就是效率优点低。</li>
<li><strong>延迟启动</strong>。光靠持久化数据还不够，必须估计到数据还没有持久化到磁盘后就宕机的情况。此时我们可以采取延迟启动。Redis宕机之后不要立即重启，而是要等分布式锁中最长的Key的TTL（超时时间）过了之后再启动，保证全部Key都被强制解锁了。但这种方案需要用一个东西来存储每个分布式锁的TTL时间。</li>
</ul></li>
</ul></li>
<li><p><strong>极端场景：由于Key在Redis中具有超时自动释放的机制，而客户端无法感知自己的锁失效了。</strong>那么就会出现一种情况，客户端<code>client1</code>获得分布式锁后，恰巧遇到客户端执行垃圾回收时GC中<code>STW(stop the world)</code>停顿机制导致客户端阻塞一段时间，此时<code>client1</code>失效，<code>client2</code>获得锁，而<code>client1</code>不知道自己的锁已经失效了，这时候<code>client1</code>再进行写时就会发生错误. <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/RedLock锁流程.png" width="700"> &gt;除了GC停顿，还有很多原因可能导致进程pause。例如进程可能读取尚未进入内存的数据，所以它得到一个 page fault （错误页面）并且等待 page 被加载进缓存；还有可能你依赖于网络服务；或者其他进程占用 CPU；或者其他意外发生 SIGSTOP 等。</p>
<ul>
<li><strong>解决方法：</strong>
<ul>
<li>使用Fencing（栏栅）使锁变安全：领域大牛Martin提出在每次写操作时加入一个<code>fencing token</code>,这个场景下，<code>fencing token</code>可以是一个递增的数字（lock service可以做到），每次有client申请锁就递增一次： <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/使用Fencing解决锁不安全问题.png" width="700"> <code>client1</code> 申请锁同时拿到<code>token33</code>，然后它进入长时间的停顿锁也过期了。<code>client2</code> 得到锁和<code>token34</code>写入数据，紧接着 <code>client1</code> 活过来之后尝试写入数据，自身<code>token33</code>比<code>34</code>小因此写入操作被拒绝。注意这需要存储层来检查<code>token</code>，但这并不难实现。如果使用<code>Zookeeper</code>作为<code>lock service</code>的话那么可以使用<code>zxid</code>作为递增数字。 但是对于<code>Redlock</code> ，没什么生成<code>fencing token</code>的方式，并且怎么修改<code>Redlock</code> 算法使其能产生<code>fencing toke</code>并不那么显而易见。因为产生<code>token</code>需要在集群中共享单调递增，除非在单节点Redis上完成但是这又没有高可靠性，需要引进一致性协议来让<code>Redlock</code> 产生可靠的<code>fencing token</code>。</li>
</ul></li>
</ul></li>
<li><p><strong>RedLock过于依赖时钟</strong>：在分布式架构中，其中的一个特点就是缺乏全局时钟。而RedLock的上锁机制依赖于分布式的时钟一致性，这存在很大的隐患。</p></li>
</ul>
<p>Martin批评RedLock算法太过于依赖时间，大概意思就是：<strong>强调一个好的算法，不管时间维度上出现问题，还是网络通信上出现了问题，算法可以没有立刻得到正确的答案，但算法会在未来的时间内给出正确的答案而并非是错误的答案。</strong></p>
<p>总结RedLock的两个缺点就是：</p>
<ul>
<li>1、客户端无法感知锁失效。</li>
<li>2、RedLock过于依赖时钟。</li>
</ul>
<blockquote>
<p><code>Redlock</code> 不是一个好的选择，对于需求性能的分布式锁应用它太重了且成本高；对于需求正确性的应用来说它不够安全。因为它对高危的时钟或者说其他上述列举的情况进行了不可靠的假设，如果应用只需要高性能的分布式锁不要求多高的正确性，那么单节点 Redis 够了；如果应用想要保住正确性，那么不建议 <code>Redlock</code>，建议使用一个合适的一致性协调系统，例如<code>Zookeeper</code>，且保证存在<code>fencing token</code>。</p>
</blockquote>
<h2 id="redis高并发和高可用是如何保证的">24 Redis高并发和高可用是如何保证的？</h2>
<blockquote>
<ul>
<li>主从复制集群+redis Sentinel是一种高并发高可用方案</li>
<li>redis Cluster也是一种高高并发高可用方案（redis集合可主从复制和哨兵机制） 后面会讲到</li>
</ul>
</blockquote>
<p>这样的问题主要是在并发读写访问的时候，缓存和数据相互交叉执行</p>
<ul>
<li><strong>高并发</strong>
<ul>
<li><strong>Redis的主从架构模式是实现高并发的主要依赖，一般很多项目只需要一主多从就可以实现其所需要的功能</strong>。通常使用<strong>单主用来写入数据</strong>，单机几万 QPS；<strong>多从一般是查询数据</strong>，同时这样也可以很轻松实现水平扩容，支撑读高并发。</li>
<li>同时一些项目需要在实现高并发的同时，尽可能多的容纳大量的数据，这时需要使用Redis 集群，使用Redis 集群之后，可以提供每秒几十万的读写并发。</li>
</ul></li>
<li><strong>高可用</strong>
<ul>
<li>Redis 高可用，如果是做主从架构部署，那么加上哨兵就可以实现，任何一个实例宕机，可以进行主备切换。</li>
</ul></li>
</ul>
<p><img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/master-slave.png" width="600"></p>
<p><strong>Redis replication(redis主从复制) -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</strong></p>
<blockquote>
<p><strong>redis的文件事件</strong> 虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型应对并发场景，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接。 <strong>Redis6.0的多线程</strong> Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。 虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，也不需要担心线程安全问题。其原因概括来说就两点： - 可以充分利用服务器 CPU 资源，目前主线程只能利用一个核 - 多线程任务可以分摊 Redis 同步 IO 读写负荷</p>
</blockquote>
<h2 id="主从复制">25 主从复制</h2>
<h3 id="redis-replication-的核心机制">25.1 Redis replication 的核心机制</h3>
<ul>
<li>Redis 采用异步方式复制数据到slave从节点，不过 Redis2.8 开始，slave node从节点会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会阻塞 master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会阻塞对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向水平扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须开启 <code>master node</code> 的持久化，同时不建议用 <code>slave node</code> 作为 <code>master node</code> 的数据热备。如果你关掉 <code>master</code> 的持久化，可能在 <code>master</code> 宕机重启的时候数据是空的，然后可能一经过复制， <code>slave node</code> 的数据也丢了。</p>
<p>另外，<code>master</code> 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份<code>rdb</code> 去恢复 <code>master</code>，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，<code>slave node</code> 可以自动接管 <code>master node</code>，但也可能 <code>sentinel</code> 还没检测到<code>master failure</code>，<code>master node</code>就自动重启了，还是可能导致上面所有的 <code>slave node</code> 数据被清空。</p>
<h3 id="redis-主从复制的核心原理流程">25.2 Redis 主从复制的核心原理(流程)</h3>
<ul>
<li><p>当启动一个 <code>slave node</code> 的时候，会在自己本地保存<code>master node</code> 的信息，包括 <code>master node</code> 的 <code>host</code> 和 <code>ip</code> ，但是复制流程没开始。</p></li>
<li><p><code>slave node</code> 内部有个定时任务，每秒检查是否有新的 <code>master node</code> 要连接和复制，如果发现，就跟<code>master node</code>建立<code>socket</code>网络连接。然后 <code>slave node</code> 发送 <code>ping</code>命令给<code>master node</code>。如果 <code>master</code> 设置了 <code>requirepass</code>，那么 <code>slave node</code> 必须发送 <code>masterauth</code> 的口令过去进行认证。</p></li>
<li><p>如果这是 <code>slave node</code> 初次连接到 <code>master node</code>，那么会触发一次 <strong><code>full resynchronization</code> 全量复制</strong>。此时 <code>master</code> 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 <code>client</code> 新收到的所有写命令缓存在内存中。 <code>RDB</code> 文件生成完毕后， <code>master</code> 会将这个<code>RDB</code> 发送给 <code>slave，slave</code>会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 <code>master</code> 会将内存中缓存的写命令发送到 <code>slave，slave</code> 也会同步这些数据。</p></li>
<li><p><code>slave node</code> 如果跟 <code>master node</code> 有网络故障，断开了连接，会自动重连，<strong>连接之后 <code>master node</code> 仅会复制给 <code>slave</code> 部分缺少的数据</strong>，也称为<strong>断点续传</strong>。</p></li>
<li><p>在后续，<code>master node</code> 持续将写命令，异步执行<strong>增量复制</strong>给 slave node</p></li>
</ul>
<p><img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/主从复制核心原理.png" width="700"></p>
<h3 id="主从复制的断点续传">25.3 主从复制的断点续传</h3>
<p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p>
<p><code>master node</code> 会在内存中维护一个 <code>backlog</code>，<code>master</code> 和 <code>slave</code> 都会保存一个 <code>replication offset</code> 还有一个 <code>master run id</code>，<code>offset</code> 就是保存在 <code>backlog</code> 中的。如果 <code>master</code> 和 <code>slave</code> 网络连接断掉了，<code>slave</code> 会让 <code>master</code> 从上次 <code>replica offset</code> 开始继续复制，如果没有找到对应的<code>offset</code>，那么就会执行一次 <code>resynchronization</code>全量复制。</p>
<blockquote>
<p>如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分</p>
</blockquote>
<h3 id="无磁盘化复制">25.4 无磁盘化复制</h3>
<p><code>master</code> 在内存中直接创建 <code>RDB</code> ，然后发送给 <code>slave</code>，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">repl-diskless-sync yes</span><br><span class="line"></span><br><span class="line"># 等待 <span class="number">5</span>s 后再开始复制，因为要等更多 slave 重新连接过来</span><br><span class="line">repl-diskless-sync-delay <span class="number">5</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></p>
<h3 id="从节点过期key处理">25.5 从节点过期key处理</h3>
<p>由于从节点只负责读业务，因此从节点不会自己主动删除过期的key，而是由主节点控制，从节点只会等待<code>master</code> 过期<code>key</code>。如果 <code>master</code> 过期了一个 <code>key</code>，或者通过 <code>LRU</code> 淘汰了一个 <code>key</code>，那么会模拟一条 <code>del</code> 命令发送给 <code>slave</code></p>
<h3 id="全量复制">25.6 全量复制</h3>
<ul>
<li>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</li>
<li>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</li>
<li>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</li>
<li>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit slave <span class="number">256</span>MB <span class="number">64</span>MB <span class="number">60</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li>
<li>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时基于旧的数据版本对外提供服务。</li>
<li>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF</li>
</ul>
<h3 id="增量复制">25.6 增量复制</h3>
<ul>
<li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</li>
<li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。</li>
<li>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的</li>
</ul>
<h2 id="redis-如何才能做到高可用">26 Redis 如何才能做到高可用？</h2>
<p>如果系统在 365 天内，有 99.99% 的时间，都是可以哗哗对外提供服务的，那么就说系统是高可用的。</p>
<p>一个 slave 挂掉了，是不会影响可用性的，还有其它的 slave 在提供相同数据下的相同的对外的查询服务。</p>
<p>但是，如果 master node 死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node 还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了。</p>
<p>Redis 的高可用架构，叫做 failover 故障转移，也可以叫做<strong>主备切换</strong>。</p>
<p><strong>master node 在故障时，自动检测，并且将某个 slave node 自动切换为 master node 的过程，叫做主备切换。这个过程，实现了 Redis 的主从架构下的高可用</strong></p>
<h2 id="redis基于哨兵集群实现高可用">27 Redis基于哨兵集群实现高可用</h2>
<p>Redis 哨兵（<code>Sentinel</code>）是Redis提供的一种高可用实现方案，Redis在主从复制下，一旦主节点出现问题，需要人工干预，手动将一个从节点更新为主节点（<code>slaveof no one</code>），同时还要通知应用方新的主节点，让其他从节点去复制新的从节点。这种方式存在弊端大，<strong><code>Redis Sentinel</code>高可用方案就是为了解决这种问题。</strong></p>
<p><strong><code>Redis Sentinel</code> 是一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点</strong>，每个<code>Sentinel</code>节点会对数据节点和其余<code>Sentinel</code>节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他<code>Sentinel</code>节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个<code>Sentinel</code>节点来完成<strong>自动故障转移</strong>的工作，同时会将这个变化实时通知给Redis应用方。</p>
<p>因此哨兵节点主要负责三件事情：<strong>监控、选主、通知。</strong>所以，我们重点要学习这三件事情： &gt;哨兵节点是如何监控节点的？又是如何判断主节点是否真的故障了？ &gt;根据什么规则选择一个从节点切换为主节点？ &gt;怎么把新主节点的相关信息通知给从节点和客户端呢？</p>
<h3 id="部署方法">27.1 部署方法</h3>
<ul>
<li>首先部署主节点和从节点</li>
<li>部署sentinel节点</li>
<li>在Redis安装目录下有一个 <code>sentinel.conf</code> 的文件，是默认的 <code>sentinel</code> 节点配置文件，对其进行复制和修改</li>
<li>启动Sentinel节点 &gt;Sentinel节点默认的端口是26379</li>
</ul>
<p>启动节点的方式有两种：</p>
<ul>
<li><p>使用redis-sentinel命令 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">redis-sentinel sentinel配置文件.conf</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用<code>redis-server</code>命令加上 <code>--sentinel</code> 参数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">redis-server sentinel配置文件.conf —sentinel</span><br></pre></td></tr></table></figure> &gt;每个sentinel节点会对主节点和所有从节点进行监控，同时Sentinel节点之间也会相互监控</p></li>
</ul>
<h3 id="哨兵节点是如何监控节点的">27.2 哨兵节点是如何监控节点的？</h3>
<p>Redis Sentinel通过三个定时监控任务完成对每个节点发现和监控：</p>
<ol type="1">
<li><p>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构，Sentinel节点可以通过info replication的结果进行解析找到相应的从节点。 &gt;<strong>作用：</strong>通过向主节点执行 info 命令，获取从节点的信息，这也是为什么 Sentinel 节点不需要显式配置监控从节点 &gt;当有新的从节点加入时都可以立刻感知出来。 &gt;<strong>节点不可达或者故障转移后，可以通过 info 命令实时更新节点拓扑信息。</strong></p></li>
<li><p>每隔2秒，每个Sentinel会向Redis数据节点的 <code>__sentinel__:hello</code> 频道发送该 Sentinel 节点的信息，同时每个 Sentinel 节点也会订阅该频道，来了解其他 Sentinel 节点以及他们对主节点的判断 &gt;<strong>作用：</strong>发现新的Sentinel节点：通过订阅主节点的 <strong>sentinel</strong>：hello通道了解其他的Sentinel节点信息，如果是新加入的 Sentinel 节点，将该 Sentinel 节点信息保存起来，并与该 Sentinel 节点创建连接 &gt;<strong>Sentinel 节点之间交换主节点的状态，作为后面客观下线以及领导者选举的依据。</strong></p></li>
<li><p><strong>每隔1秒，每个<code>Sentinel</code>节点会向主节点、从节点、其余<code>Sentinel</code>节点发送一条<code>ping</code>命令做一次心跳检测，来确认这些节点当前是否可达。</strong> &gt;<strong>作用：</strong>通过对上面的定时任务，Sentinel 节点对主节点、从节点，其余 Sentinel 节点都建立起连接，<strong>实现对每个节点的监控，这个定时任务是节点失败判定的重要依据。</strong></p></li>
</ol>
<p><img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/哨兵监控原理.png" width="700"> 如果主节点或者从节点没有在规定的时间内响应哨兵的 <code>PING</code> 命令，哨兵就会将它们标记为「主观下线」。这个「规定的时间」是配置项<code>down-after-milliseconds</code> 参数设定的，单位是毫秒。</p>
<h3 id="如何判断主节点是否真的故障了">27.3 如何判断主节点是否真的故障了？</h3>
<ul>
<li><p><strong>主观下线</strong>：每个 Sentinel 节点每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心脏检测，当这些节点超过 down-after-milliseconds 没有进行有效恢复时，Seintinel 节点会对该节点做失败判定，这个行为称为主观下线。</p></li>
<li><p><strong>客观下线</strong>：当 <code>Sentinel</code> 主观下线的节点是主节点时，该 <code>Sentinel</code> 节点会通过 <code>sentinel</code>的 <code>is-master-down-by-addr</code>命令向其他 <code>Sentinel</code> 节点询问对主节点的判断。当超过 <code>quorum</code> 个数 <code>Sentinel</code> 节点认为主节点确实有问题，这时就会做出客观下线的决定 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/哨兵监控.png" width="700"></p></li>
</ul>
<blockquote>
<p>PS：<code>quorum</code> 的值一般设置为哨兵个数的二分之一加1，例如 3 个哨兵就设置 2。</p>
</blockquote>
<h3 id="哨兵领导者选举方法">27.4 哨兵领导者选举方法</h3>
<p>在进行故障转移之前，<code>Sentinel</code>们需要先选择一个领导者，让它来指定谁应该成为新的主节点。在之前的客观下线，当一个<code>Sentinel is-master-down-by-addr</code>命令向其他 <code>Sentinel</code> 节点询问对主节点的判断，那么该哨兵节点就成为了候选者：</p>
<ul>
<li>每个在线的<code>Sentinel</code>节点都有资格成为领导者，当它确认主节点主观下线时候，会向其他<code>Sentinel</code>节点发送 <code>sentinel is-master-down-by-addr</code> 命令， 要求将自己设置为领导者。</li>
<li>收到命令的<code>Sentinel</code>节点，如果没有同意过其他 <code>Sentinel</code>节点的 <code>sentinel is-master-down-by-addr</code> 命令，将同意该请求，否则拒绝。</li>
<li>如果该 <code>Sentinel</code> 节点发现自己的票数已经大于等于<code>max（quorum， num（sentinels）/2+1）</code>，那么它将成为领导者。</li>
<li>如果此过程没有选举出领导者，将进入下一次选举。 &gt;事实上每个Sectinel只有一票，会最先给发起请求的节点。基本上谁先完成客观下线，就会成为领导者</li>
</ul>
<h3 id="根据什么规则选择一个从节点切换为主节点如何进行主从故障转移">27.5 根据什么规则选择一个从节点切换为主节点(如何进行主从故障转移）？</h3>
<p><strong>为了在从节点中选举出主节点，其选择规则如下：</strong></p>
<ol type="1">
<li>首先进行过滤，滤除那些“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过 <code>down-after-milliseconds*10</code> 秒，接着经过最多三步考察来确定主节点。</li>
<li>选择<code>slave-priority</code>（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续下一步考察。</li>
<li>选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续。</li>
<li>如果优先级和下标都相同，选择<code>run id</code>最小的从节点。</li>
</ol>
<p><strong>选出主节点后，Sentinel领导者会做以下工作：</strong></p>
<ul>
<li>Sentinel领导者节点会对选出来的从节点执行<code>slaveof no one</code>命令让其成为主节点。</li>
<li>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和<code>parallel-syncs</code>参数有关</li>
<li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</li>
</ul>
<blockquote>
<p><strong>更换主节点后，客户端怎么知道主节点是哪个？</strong> 哨兵主节点信息会发布到这个频道中：<code>switch-master</code>，客户端只需要订阅该指定频道，当发生故障转移后，该频道就可以收到新的主节点信息，客户端依据信息更改</p>
</blockquote>
<h3 id="哨兵节点之间如何互相发现哨兵如何发现从节点哨兵集群如何建立的">27.6 哨兵节点之间如何互相发现，哨兵如何发现从节点(哨兵集群如何建立的？)</h3>
<p>在设置哨兵集群时，只需要填下面这几个参数，设置主节点名字、主节点的 IP 地址和端口号以及 quorum 值,不需要填写哨兵间的连续： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sentienl monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure> 这是因为<strong>哨兵节点之间是通过 Redis 的发布者/订阅者机制来相互发现的。在主从集群中，主节点上有一个名为<code>__sentinel__:hello</code>的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</strong></p>
<p>在下图中，哨兵<code>A</code>把自己的** IP 地址和端口的信息<strong>发布到<code>__sentinel__:hello</code>频道上，哨兵<code>B</code> 和<code>C</code>订阅了该频道。那么此时，哨兵<code>B</code>和<code>C</code>就可以从这个频道直接获取哨兵<code>A</code>的</strong> IP 地址和端口号**。然后，哨兵 <code>B、C</code>可以和哨兵<code>A</code>建立网络连接。通过这个方式，哨兵 B 和 C 也可以建立网络连接，这样一来，哨兵集群就形成了。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/Sentinel.png" width="700"></p>
<blockquote>
<p>哨兵集群会对「从节点」的运行状态进行监控，那哨兵集群如何知道「从节点」的信息？</p>
</blockquote>
<p><strong>主节点知道所有「从节点」的信息，所以哨兵会每 10 秒一次的频率向主节点发送 INFO 命令来获取所有「从节点」的信息。</strong></p>
<p>如下图所示，哨兵 B 给主节点发送 INFO 命令，主节点接受到这个命令后，就会把从节点列表返回给哨兵。接着，哨兵就可以根据从节点列表中的连接信息，和每个从节点建立连接，并在这个连接上持续地对从节点进行监控。哨兵 A 和 C 可以通过相同的方法和从节点建立连接。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/哨兵和从节点建立联系.png" width="700"></p>
<p><strong>总结：通过 Redis 的发布者/订阅者机制，哨兵之间可以相互感知，然后组成集群，同时，哨兵又通过 INFO 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。</strong></p>
<h3 id="总结">27.7 总结</h3>
<p>Redis 在 2.8 版本以后提供的<strong>哨兵（Sentinel）机制</strong>，它的<strong>作用是实现主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p>
<p>哨兵一般是以集群的方式部署，至少需要 3 个哨兵节点，哨兵集群主要负责三件事情：<strong>监控、选主、通知</strong></p>
<p>哨兵节点通过 Redis 的<strong>发布者/订阅者机制</strong>，哨兵之间可以相互感知，相互连接，然后组成哨兵集群，同时哨兵又通过 INFO 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。</p>
<h2 id="redis-哨兵主备切换的数据丢失问题">28 Redis 哨兵主备切换的数据丢失问题</h2>
<h3 id="导致数据丢失的两种情况">28.1 导致数据丢失的两种情况</h3>
<p>主备切换的过程，可能会导致数据丢失：</p>
<ul>
<li><strong>异步复制导致的数据丢失：</strong>因为 <code>master-&gt;slave</code> 的复制是异步的，所以可能有部分数据还没复制到 <code>slave</code>，<code>master</code> 就宕机了，此时这部分数据就丢失了。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/异步复制导致的数据丢失.png" width="700"></li>
<li><strong>脑裂导致的数据丢失</strong>：某个 master 所在机器突然脱离了正常的网络，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的脑裂。此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了</li>
</ul>
<h3 id="数据丢失问题的解决方案">28.2 数据丢失问题的解决方案</h3>
<p>上面的出现数据丢失均是master的数据未能及时写进slave，可以进行如下配置,设置最大延迟10s，超过10s不允许写数据： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write <span class="number">1</span></span><br><span class="line">min-slaves-max-lag <span class="number">10</span> Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure> 上面规定要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了,这就保证最多会丢失10s的数据。</p>
<ul>
<li><p>减少异步复制数据的丢失：有了 <code>min-slaves-max-lag</code> 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。</p></li>
<li><p>减少脑裂的数据丢失：如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失<code>10</code>秒的数据</p></li>
</ul>
<h2 id="redis集群介绍一下redis-cluster">29 Redis集群（介绍一下redis cluster)</h2>
<p><strong>redis集群是实现高可用的方式之一，它采用无中心节点方式实现，无需proxy代理，客户端直接与redis集群的每个节点连接，与主从复制集群模式只提供一个master不同，Redis集群会提供多个master节点提供写服务，每个master节点中存储的数据都不一样，这些数据通过数据分片的方式被自动分割到不同的master节点上实现水平扩容。</strong></p>
<p><strong>同时为了保证集群的高可用，每个master节点还会添加slave节点，这样当某个master节点发生故障后，可以从它的slave节点中选举一个作为新的master节点继续提供服务。</strong></p>
<h3 id="集群数据的是怎么分区存储的">29.1 集群数据的是怎么分区存储的？</h3>
<p>因为redis集群使用多个master存储数据，每个master分片存储数据是不一样的。<strong>在<code>redis  Cluste</code>中一共会分为16384（<span class="math inline">\(2^{14}\)</span>）个槽</strong>，假如集群中有三个master，那么<code>master1</code>节点包含<span class="math inline">\(0~5500\)</span>号哈希槽，master2节点包含<span class="math inline">\(5501~11000\)</span>号哈希槽，master3节点包含<span class="math inline">\(11001~16384\)</span>号哈希槽: <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/槽分配.png" width="700"></p>
<p>因为客户端是无中心节点实现，直接与每个节点连接，<code>key</code>是怎么存储的呢，它是对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 <code>key</code> 对应的 <code>hash slot</code>确定其节点。</p>
<p>节点虚拟槽的特点：</p>
<ul>
<li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li>
<li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li>
<li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li>
</ul>
<h3 id="redis集群中节点的通信">29.2 Redis集群中节点的通信</h3>
<p>既然Redis集群中的数据是通过哈希槽的方式分开存储的，<strong>那么集群中每个节点都需要知道其他所有节点的元数据信息（包括当前集群状态、集群中各节点负责的哈希槽、集群中各节点的master-slave状态、集群中各节点的存活状态等）</strong></p>
<p>集群元数据的维护有两种方式：<strong>集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</strong></p>
<h4 id="集中式">29.2.1 集中式</h4>
<p>集中式是将集群元数据（节点信息、故障等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code> 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 <code>zookeeper</code>（分布式协调的中间件）对所有元数据进行存储维护。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/集中式.png" width="700"></p>
<h4 id="gossip">gossip</h4>
<p>Redis 维护集群元数据采用另一个方式， gossip 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p>
<p>Gossip 协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息。</p>
<p><strong>通信原理：</strong></p>
<ul>
<li>集群中的每个节点都会单独开辟一个 TCP 通道，用于节点之间彼此通信，通信端口号在基础端口上加10000。</li>
<li>每个节点在固定周期内通过特定规则选择几个节点发送 ping 消息。</li>
<li>接收到 ping 消息的节点用 pong 消息作为响应。</li>
</ul>
<h3 id="gossip消息">29.3 Gossip消息</h3>
<p>Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。</p>
<p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个<strong>最终一致性协议。</strong></p>
<p>Gossip 协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的 Gossip 消息。常用的 Gossip消息可分为：ping 消息、pong 消息、meet 消息、fail 消息。</p>
<ul>
<li><strong>meet 消息</strong>：用于通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong 消息交换。</li>
<li><strong>ping 消息</strong>：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。ping 消息发送封装了自身节点和部分其他节点的状态数据。</li>
<li><strong>pong 消息</strong>：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新。</li>
<li><strong>fail 消息</strong>：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。</li>
</ul>
<p>所有的消息格式划分为：消息头和消息体。</p>
<h4 id="优势">29.3.1 优势</h4>
<ul>
<li><strong>扩展性：</strong>网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。</li>
<li><strong>容错</strong>：网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。</li>
<li><strong>去中心化</strong>：Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</li>
<li><strong>一致性收敛</strong>：Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。</li>
</ul>
<h4 id="gossip-的缺陷">29.3.2 Gossip 的缺陷</h4>
<p>分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：</p>
<ul>
<li><p><strong>消息的延迟：</strong>由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。</p></li>
<li><p><strong>消息冗余：</strong>Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送而且不反馈，因此，即使节点收到了消息，还是会反复收到重复消息，加重了消息的冗余。</p></li>
</ul>
<h3 id="redis集群是怎么去选择节点来通信">29.4 Redis集群是怎么去选择节点来通信？</h3>
<p>Redis集群内节点通信采用固定频率（定时任务每秒执行10次），并且随机选择选取5个节点找出最久没有通信的节点发送ping消息，用于保证 Gossip 信息交换的随机性。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis集群内节点通信.png" width="700"></p>
<h4 id="选择发送消息的节点数量">29.4.1 选择发送消息的节点数量</h4>
<ul>
<li>集群内每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个节点找出最久没有通信的节点发送ping消息，用于保证 Gossip 信息交换的随机性。</li>
<li>每 100 毫秒都会扫描本地节点列表，如果发现节点最近一次接受 pong 消息的时间大于 cluster_node_timeout/2，则立刻发送 ping 消息，防止该节点信息太长时间未更新。</li>
<li>根据以上规则得出每个节点每秒需要发送 <code>ping 消息的数量 = 1+10*num（node.pong_received&gt;cluster_node_timeout/2)</code>。</li>
</ul>
<h2 id="redis-集群如何进行故障迁移">30 Redis 集群如何进行故障迁移</h2>
<p>当集群内少量节点出现故障时通过自动故障转移保证集群可以正常对外提供服务，<strong>Redis集群的故障迁移与<code>redis Sentinel</code>极为相似。</strong></p>
<h3 id="故障发现">30.1 故障发现</h3>
<p>Redis 集群内节点通过 ping/pong 消息实现节点通信，消息不但可以传播节点槽信息，还可以传播其他状态如：主从状态、节点故障等。因此故障发现也是通过消息传播机制实现的，主要环节包括：主观下线（pfail）和客观下线（fail）</p>
<ul>
<li><strong>主观下线</strong>：指某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</li>
<li><p><strong>客观下线</strong>：指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。</p></li>
<li><p>如果一个节点认为另外一个节点宕机，那么就是 <code>pfail</code> ，主观宕机。如果多个节点都认为另外一个节点宕机了，那么就是<code>fail</code> ，客观宕机，跟哨兵的原理几乎一样。</p></li>
<li><p>在 <code>cluster-node-timeout</code> 内，某个节点一直没有返回 pong ，那么就被认为 <code>pfail</code> 。</p></li>
<li><p>如果一个节点认为某个节点 <code>pfail</code> 了，那么会在 <code>gossip ping</code> 消息中， <code>ping</code> 给其他节点，如果超过半数的节点都认为 <code>pfail</code> 了，那么就会变成 fail 。</p></li>
</ul>
<h3 id="从节点过滤">30.2 从节点过滤</h3>
<p>对宕机的<code>master node</code>，从其所有的 <code>slave node</code> 中，选择一个切换成 <code>master node</code>。</p>
<p>检查每个 <code>slave node</code> 与 <code>master node</code> 断开连接的时间，如果超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code> ，那么就没有资格切换成 <code>master</code> 。</p>
<h3 id="从节点选举">30.3 从节点选举</h3>
<p>每个从节点，都根据自己对<code>master</code>复制数据的<code>offset</code>，来设置一个选举时间，<code>offset</code> 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p>
<p>所有的 <code>master node</code> 开始 <code>slave</code> 选举投票，给要进行选举的<code>slave</code>进行投票，如果大部分 <code>master node （N/2 + 1）</code> 都投票给了某个从节点，那么选举通过，那个从节点可以切换成 <code>master</code>。</p>
<p>从节点执行主备切换，从节点切换为主节点。</p>
<h2 id="redis-sentinel和redis-cluster的区别和联系">31 Redis Sentinel和Redis Cluster的区别和联系</h2>
<p>Redis Sentinel是官方从Redis 2.6版本提供的<strong>高可用方案</strong>，在Redis主从复制集群的基础上，增加Sentinel集群监控整个Redis主从复制集群。当Redis主从集群master节点发生故障时，Sentinel进行故障切换，选举出新的master，<strong>即Sentinel的引入是为了支持高可用集群部署。</strong></p>
<p>Redis Sentinal和Redis Cluster的区别主要在于侧重点不同:</p>
<ul>
<li><strong>Redis Sentinal主要聚焦于高可用，在主从架构基础上引入Sentinel集群，当master宕机时会自动将slave提升为master，继续提供服务。</strong></li>
<li><strong>Redis Cluster也是一种高可用方案</strong>。但相比于Redis Sentinel，Redis Cluster不需要额外部署Sentine集群，而是通过集群内部通信实现集群监控，故障时主从切换，同时，支持内部基于哈希实现数据分片，支持动态水平扩容。</li>
</ul>
<h2 id="redis为什么这么快">32 redis为什么这么快？</h2>
<p><strong>Redis 快的原因主要有：</strong></p>
<ul>
<li><strong>纯内存操作：</strong>是将数据储存在内存里，结构类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)。它的绝大部分请求是纯粹的内存操作，内存响应大约100纳秒，所以他读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</li>
<li><strong>单线程</strong>：采用单线程，保证了每个操作的原子性，也减少了线程的上下文切换和竞争，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作。</li>
<li><strong>使用多路I/O复用模型，非阻塞IO。</strong>（这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求，减少网络 IO 的时间消耗）</li>
<li><strong>高效的数据结构：</strong>5种数据结构都有自己的应用场景</li>
<li><strong>合理的数据编码</strong>：根据具体使用情况使用不一样的编码（字典渐进式Rehash，跳跃表）</li>
<li><strong>其他方面的优化：</strong>定期删除+惰性删除等</li>
</ul>
<h2 id="redis-集群伸缩增加节点删除节点">33 Redis 集群伸缩（增加节点、删除节点）</h2>
<p>集群的伸缩包括新节点的加入和旧节点退出。</p>
<p>新节点时加入时，我们需要把一部分数据迁移到新节点来达到集群的负载均衡，旧节点退出时，我们需要把其上的数据迁移到其他节点上，确保该节点上的数据能够被正常访问。</p>
<p>我们发现集群伸缩的核心其实是数据的迁移，而在 Redis 集群中，数据是以 slot 为单位的，那么也就是说，Redis 集群的伸缩本质上是 slot 在不同机器节点间的迁移。同时，要实现扩缩容，我们不仅需要解决数据迁移，我们还需要解决数据路由问题。比如 A 节点正在向 B 节点迁移 slot1 的数据，<strong>在未完成迁移时，slot1 中的一部分数据存在节点A上，一部分数据存在节点B上。那么以下三种情况下我们该如何路由 slot1 的客户端请求？</strong></p>
<ol type="1">
<li>当除了 A、B 之外的其他节点接收到 <code>slot1</code> 的数据请求时，其他节点该路由给哪个节点？</li>
<li>当节点 A 接收到 slot1 的数据请求时，A 该自己处理还是路由给 B 节点？</li>
<li>当节点 B 接收到 slot1 的数据请求时，B 该自己处理还是路由给A节点？</li>
</ol>
<h3 id="集群扩容">33.1 集群扩容</h3>
<p>Redis集群加入新节点主要分为如下几步：</p>
<ol type="1">
<li>准备新节点</li>
<li>加入集群</li>
<li>迁移slot到新节点。</li>
</ol>
<p>即首先启动一个集群模式下的 Redis 节点，然后通过与任意一个集群中的节点握手使得新的节点加入集群，最后再向新的节点分配它负责的 slot 以及向其迁移 slot 对应的数据。由于 Redis 采用 Gossip 协议，所以可以让新节点与任意一个现有集群节点握手，一段时间后整个集群都会知道新节点的加入。</p>
<p>例如我们向该集群中新加入一个节点 6385。由于我们要追求负载均衡，所以加入后四个节点每个节点负责 4096 个slots，但是集群中原来的每个节点都负责 5462 个slots，所以 6379、6380、6381 节点都需要向新的节点 6385 迁移 1366 个slots。需要说明的是，Redis 集群并没有一个自动实现负载均衡的工具，把多少 slots 从哪个节点迁移到哪个节点完全是由用户自己来指定的。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/Redis集群数据迁移.png" width="700"></p>
<h4 id="设置节点迁入迁出状态解决路由困境">设置节点迁入迁出状态——解决路由困境</h4>
<p><strong>每个 Redis 集群节点的<code>clusterState</code> 都会存储整个集群中 slot 和 Redis 节点的对应关系用于路由</strong>。当 6379 迁移 slot1 时，会首先标级该槽属于正在迁移的状态 IMGRATING，而同样 6385 也需要标记 slot1 属于正在导入的状态 IMPORTING。从实现上看，就是分别设置 migrating_slots_to 和 importing_slots_from 两个数组的对应 index 的值。迁入迁出的状态设置主要是为了方便数据路由的实现。在未完成迁移之前，集群中的所有节点都会将 slot1 的请求重定向到6379节点。</p>
<p>而当 6379 把 slot1 标记为MIGRATING时，该节点会接收所有关于 slot1 的请求，但只有当请求中的 key 存在于 6379 中时该节点才会处理该请求。否则 6379 会把该请求通过 ASK 重定向到 slot1 的迁移目标节点，即 6385 节点。</p>
<p>而当 6385 把 slot1 标记为 IMPORTING 时，该节点也可以接受关于 slot1 的请求，但前提是该请求中必须包含 ASKING 命令。如果关于 slot1 的请求中没有 ASKING 命令，那么 6385 节点会把该请求通过 MOVED 重定向到 6379 节点。</p>
<p>这样我们就解决了上述的三个问题，即：</p>
<ul>
<li>当除了 A、B 之外的其他节点接收到 slot1 的数据请求时，其他节点该路由给 A 节点</li>
<li>当节点A接收到 slot1 的数据请求时，如果请求的key存在，那么就会处理，不存在就会ASK重定向到B</li>
<li>当节点B接收到 slot1 的数据请求时，如果请求中有 ASKING 命令，那么就会自己处理。如果没有，那么重定向到 A。</li>
</ul>
<p>当迁移 slot1 结束后，slot1 就不再由 6379 负责而是交给 6385 节点负责。但是从其他节点的视角看，slot1 仍然由 6379 节点负责，他们接收到关于 slot1 的键的请求还是会路由到 6379 节点。所以迁移结束之后我们要向集群广播 slot1 由 6385 节点负责的消息，这样每个节点都会更新内部的路由数据，之后就可以正确的把 slot1 的键的请求路由到 6385 节点。需要说明的是，我们可以把上述的更新信息只告诉一个节点，那么随着各个节点信息的交换，一段时间后整个集群的所有节点都会更新路由。但是这样显然更新的延迟会很高，那些还没来得及更新的节点仍然会错误的把 slot1 的请求路由给 6379 节点。所以我们需要向每个节点进行广播消息。</p>
<h3 id="集群收缩">33.2 集群收缩</h3>
<p>集群收缩即让其中一些节点安全下线。所谓的安全下线指的是让一个节点下线之前我们需要把其负责的所有 slots 迁移到别的节点，否则该节点下线后其负责的 slots 就没法继续被服务了。节点下线的流程如下图所示： <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/Redis集群节点安全下线.png" width="700"></p>
<p>在上面的扩容完成后，集群中共有四个节点：6379、6380、6381、6385，我们以下线 6381 为例介绍下线的流程。下线 6381 节点首先需要把其上负责 slots 的数据分别迁移到三个节点上，然后通知所有集群中的节点忘记 6381 节点，最后 6381 节点关闭下线。</p>
<p>Redis 的元数据在每个节点中都有一份，即每个 Redis 节点维护者从它的视角看过去集群中所有其他节点的状态。那么当集群中的所有其他节点接收到 CLUSTER FORGET <NODE id> 命令时会删除自己保存的 NODE_ID 对应的节点的状态，同时把 NODE_ID 对应的节点加入到黑名单中 60s。把一个节点放入黑名单意味着其他节点不会再去更新自己维护的该节点的信息，也就意味着当我们向集群中的所有节点发送CLUSTER FORGET 6381 后，6381节点 60s 内不能再次加入集群中。至此就完成了集群的缩容。</NODE></p>
<h2 id="sorted-set即-zset-实现原理">34 Sorted Set（即 ZSet 实现原理）</h2>
<h3 id="zset-内部编码实现">ZSet 内部编码实现：</h3>
<ul>
<li><strong><code>ziplist</code>(压缩列表)</strong>：当哈希类型元素个数小于<code>zset-max-ziplist-entries</code>配置（默认128个），同时所有值小于<code>zset-max-ziplist-value</code>配置（默认64）时，使用<code>ziplist</code>作为内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的<strong>连续存储</strong>，在节省内存方面更加优秀。</li>
<li><strong><code>skiplist</code>(跳表)：</strong>当<code>ziplist</code>条件不满足时，有序集合会使用<code>skiplist</code>作为内部实现，因为此时<code>ziplist</code>的读写效率会下降</li>
</ul>
<h3 id="ziplist">ZipList</h3>
<p><code>ziplist</code> 编码的 <code>Zset</code> 使用紧挨在一起的压缩列表节点来保存，第一个节点保存<code>member</code>，第二个保存 <code>score</code>。<code>ziplist</code> 内的集合元素按<code>score</code> 从小到大排序，其实质是一个双向链表。虽然元素是按 <code>score</code> 有序排序的， 但对 <code>ziplist</code> 的节点指针只能线性地移动，<strong>所以在 <code>REDIS_ENCODING_ZIPLIST</code> 编码的<code>Zset</code> 中， 查找某个给定元素的复杂度为 O(N)。</strong> <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/ziplist结构图.png" width="700"></p>
<h3 id="skiplist">Skiplist</h3>
<p>skiplist 编码的 Zset 底层为一个被称为 zset 的结构体，这个结构体中包含一个字典和一个跳跃表。跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 O(logN)，最坏 O(N) 。字典则保存着从 member 到 score 的映射，这样就可以用 O(1) 的复杂度来查找 member 对应的 score 值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的 member 和 score，因此不会浪费额外的内存。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* zset结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zset</span> &#123;</span><br><span class="line">    <span class="comment">// 字典，维护元素值和分值的映射关系</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// 按分值对元素值排序序，支持O(logN)数量级的查找操作</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p>
<h4 id="跳表数据结构">跳表数据结构</h4>
<p>跳表查找时间复杂度为平均 O(logN)，最差 O(N)，在大部分情况下效率可与平衡树相媲美，但实现比平衡树简单的多，跳表是一种典型的以空间换时间的数据结构。</p>
<p>跳表具有以下几个特点：</p>
<ul>
<li>由许多层结构组成。</li>
<li>每一层都是一个有序的链表。</li>
<li>最底层 (Level 1) 的链表包含所有元素。</li>
<li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</li>
<li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li>
</ul>
<p>跳表的查找会从顶层链表的头部元素开始，然后遍历该链表，直到找到元素大于或等于目标元素的节点，如果当前元素正好等于目标，那么就直接返回它。如果当前元素小于目标元素，那么就垂直下降到下一层继续搜索，如果当前元素大于目标或到达链表尾部，则移动到前一个节点的位置，然后垂直下降到下一层。正因为 Skiplist 的搜索过程会不断地从一层跳跃到下一层的，所以被称为跳跃表。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/跳跃表结构.png" width="700"> 跳表是一个“概率型”的数据结构，指的就是跳表在插入操作时，元素的插入层数完全是随机指定的。实际上该决定插入层数的随机函数对跳表的查找性能有着很大影响，这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p>
<ul>
<li>指定一个节点最大的层数 MaxLevel，指定一个概率 p， 层数 lvl 默认为 1 。</li>
<li>生成一个 0~1 的随机数 r，若 r &lt; p，且 lvl &lt; MaxLevel ，则执行 lvl++。</li>
<li>重复第 2 步，直至生成的 r &gt; p 为止，此时的 lvl 就是要插入的层数。</li>
</ul>
<h4 id="skiplist-与平衡树哈希表的比较">Skiplist 与平衡树、哈希表的比较</h4>
<ul>
<li>Skiplist 和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个 key 的查找，不适宜做范围查找。</li>
<li>在做范围查找的时候，平衡树比 Skiplist 操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在 skiplist 上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而 Skiplist 的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
<li>从内存占用上来说，Skiplist 比平衡树更灵活一些。一般来说，平衡树每个节点包含 2 个指针（分别指向左右子树），而 Skiplist 每个节点包含的指针数目平均为 1/(1−p)，具体取决于参数 p 的大小。如果像 Redis 里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li>查找单个 key，Skiplist 和平衡树的时间复杂度都为 O(logN)；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近 O(1)，性能更高一些。</li>
<li>从算法实现难度上来比较，Skiplist 比平衡树要简单得多。</li>
</ul>
<h2 id="redis应用场景">35 Redis应用场景</h2>
<h3 id="热点数据">热点数据</h3>
<p>存取数据优先从 Redis 操作，如果不存在再从文件（例如 MySQL）中操作，从文件操作完后将数据存储到 Redis 中并返回。同时有个定时任务后台定时扫描 Redis 的 key，根据业务规则进行淘汰，防止某些只访问一两次的数据一直存在 Redis 中。</p>
<p>例如使用 Zset 数据结构，存储 Key 的访问次数/最后访问时间作为 Score，最后做排序，来淘汰那些最少访问的 Key。</p>
<h3 id="会话维持-session">会话维持 Session</h3>
<p>会话维持 Session 场景，即使用 Redis 作为分布式场景下的登录中心存储应用。每次不同的服务在登录的时候，都会去统一的 Redis 去验证 Session 是否正确。但是在微服务场景，一般会考虑 Redis + JWT 做 Oauth2 模块。</p>
<p>其中 Redis 存储 JWT 的相关信息主要是留出口子，方便以后做统一的防刷接口，或者做登录设备限制等。</p>
<h3 id="分布式锁-setnx">分布式锁 SETNX</h3>
<p>命令格式：SETNX key value：当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作。</p>
<p>超时时间设置：获取锁的同时，启动守护线程，使用 expire 进行定时更新超时时间。如果该业务机器宕机，守护线程也挂掉，这样也会自动过期。如果该业务不是宕机，而是真的需要这么久的操作时间，那么增加超时时间在业务上也是可以接受的，但是肯定有个最大的阈值。</p>
<p>但是为了增加高可用，需要使用多台 Redis，就增加了复杂性，就可以参考 Redlock：Redlock分布式锁</p>
<h3 id="表缓存">表缓存</h3>
<p>Redis 缓存表的场景有黑名单、禁言表等。访问频率较高，即读高。根据业务需求，可以使用后台定时任务定时刷新 Redis 的缓存表数据。</p>
<h3 id="消息队列-list">消息队列 list</h3>
<p>主要使用了 List 数据结构。</p>
<p>List 支持在头部和尾部操作，因此可以实现简单的消息队列。</p>
<ul>
<li>发消息：在 List 尾部塞入数据。</li>
<li>消费消息：在 List 头部拿出数据。</li>
</ul>
<p>同时可以使用多个 List，来实现多个队列，根据不同的业务消息，塞入不同的 List，来增加吞吐量。</p>
<h3 id="计数器-string">计数器 string</h3>
<p>主要使用了 INCR、DECR、INCRBY、DECRBY 方法。</p>
<p>INCR key：给 key 的 value 值增加一 DECR key：给 key 的 value 值减去一</p>
<h2 id="redis-压力测试">36 Redis 压力测试</h2>
<p>Redis 自带了一个叫 redis-benchmark 的工具来模拟 N 个客户端同时发出 M 个请求。 （类似于 Apache ab 程序）。你可以使用 redis-benchmark -h 来查看基准参数。</p>
<h2 id="生产环境中的-redis-是怎么部署的">37 生产环境中的 Redis 是怎么部署的？</h2>
<p>看看你了解不了解你们公司的 Redis 生产集群的部署架构，如果你不了解，那么确实你就很失职了，你的 Redis 是主从架构？集群架构？用了哪种集群方案？有没有做高可用保证？有没有开启持久化机制确保可以进行数据恢复？线上 Redis 给几个 G 的内存？设置了哪些参数？压测后你们 Redis 集群承载多少 QPS？</p>
<p>Redis cluster，10 台机器，5 台机器部署了 Redis 主实例，另外 5 台机器部署了 Redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 QPS 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。</p>
<p>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>5 台机器对外提供读写，一共有 50g 内存。</p>
<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p>
<p>其实大型的公司，会有基础架构的 team 负责缓存集群的运维</p>
<h2 id="哪些场景适合用redis">38 哪些场景适合用Redis?</h2>
<ol type="1">
<li>缓存：对热点数据进行缓存，减轻数据库的压力，提高系统性能。</li>
<li>排行榜：利用 Redis 的 SortSet（有序集合）实现排行榜功能；</li>
<li>计数器/限速器：利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等。这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；</li>
<li>好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便解决一些共同好友、共同爱好之类的功能；</li>
<li>消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；</li>
<li>Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。</li>
</ol>
<p>文章参考来源： &gt;<a href="https://blog.csdn.net/2301_76607156/article/details/129749698">分布式锁：RedLock 你这锁也不包熟啊！</a></p>
<blockquote>
<p>《redis设计与实现》</p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_45433817/article/details/130311877">面试官：Redis的数据完全是存在内存中的吗？Redis的虚拟内存机制是什么？</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/mz474920631/article/details/125269560">Redis哨兵</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码剖析</title>
    <url>/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h4 id="stl概述">1.STL概述</h4>
<h5 id="六大组件">1.1 六大组件</h5>
<ul>
<li>容器：各种数据结构,如<code>vector、list、deque、set、map</code>等,用来存放数据</li>
<li>算法：各种常用的算法（冒泡，排序）,如<code>sort、find、copy、for_each、search、erase</code></li>
<li>迭代器：扮演了容器与算法之间的胶合剂，是所谓的泛型指针</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理。注意一般都伴随着重新分配空间，那么原来的迭代器就会失效</li>
</ul>
<p>六大组件的交互关系是<code>Container</code>通过<code>Allocator</code>获得数据存储空间，<code>Alogrithm</code>通过<code>Iterator</code>存取<code>Container</code>的内容，<code>Functor</code>可以协助<code>Algorithm</code>完成不同的策略变化，<code>Adapter</code>可以修饰或套接<code>Functor</code>。本笔记将会以此对这六大组件进行介绍。</p>
<p>++说在前面：STL的实现版本由HP版本、PJ版本、RW版本、STLport版本和SGISTL版本等五个主要版本++</p>
<span id="more"></span>
<h4 id="空间配置器">2. 空间配置器</h4>
<p>在介绍STL的其他组件尤其是<code>container</code>组件之前，空间配置器是必须要先介绍的，因为容器内存空间的开辟需要由<code>allocator</code>去申请。allocator申请的空间是为构造原始的，<code>new</code>申请的空间是已构造的。在<code>gcc</code>中的容器使用了缺省的SGI版本的空间配置器：<code>class Alloc = alloc</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, **<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc**&gt;	<span class="comment">//默认使用了alloc</span></span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="comment">/*...实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="空间配置器的标准接口">2.1 空间配置器的标准接口</h5>
<p>allocator的必要接口（无论是哪个版本的STL）： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员变量</span></span><br><span class="line">allocator::value_type;</span><br><span class="line">allocator::pointer;</span><br><span class="line">allocator::const_pointer;</span><br><span class="line">allocator::reference;</span><br><span class="line">allocator::const_reference;</span><br><span class="line">allocator::size_type;</span><br><span class="line">allocator::difference_type;</span><br><span class="line">allocator::rbind;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>();</span><br><span class="line">allocator::<span class="built_in">allocator</span>(<span class="type">const</span> allocator&amp;);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;allocator：：<span class="built_in">allocator</span>(<span class="type">const</span> allocator&lt;U&gt;&amp;);</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">allocator::~<span class="built_in">allocator</span>();</span><br><span class="line"><span class="comment">//返回某个对象的地址，等同于&amp;X</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::address</span><span class="params">(reference x)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//配置空间，n个足以存储U对象</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n,<span class="type">const</span> <span class="type">void</span>*=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//回收配置的空间,p为allocate返回的指针，n为allocate分配是指定的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::deallocate</span><span class="params">(pointer p,size_type n)</span></span>;</span><br><span class="line"><span class="comment">//对分配空间进行构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::construct</span><span class="params">(pointer,<span class="type">const</span> T&amp;x)</span></span>;</span><br><span class="line"><span class="comment">//对构造空间析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::destroy</span><span class="params">(pointer p)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="设计一个简单的空间配置器">2.1.1设计一个简单的空间配置器</h6>
<p>根据上述的接口，我们可以实现一个自己的、功能简单，接口不齐全的<code>allocator</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstddef&gt;</span>	<span class="comment">//ptrdiff_t,size_t类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myallocator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">inline</span> T* _allocate()（<span class="type">ptrdiff_t</span> size,T*)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//使用全局operator new ,相当于malloc</span></span><br><span class="line">		T* tmp=(T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size*<span class="built_in">sizeof</span>(T))));	<span class="comment">//调用全局重载运算符new</span></span><br><span class="line">		<span class="keyword">if</span>(tmp==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cerr&lt;&lt;<span class="string">&quot;out_of_memory&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _deallocate(T*buffer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//相当于free</span></span><br><span class="line">		::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _construct(T* p,<span class="type">const</span> U&amp; value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span>(p) <span class="built_in">U</span>(value);		<span class="comment">//placement new，相当于realloc，并进行构造</span></span><br><span class="line">	&#125;</span><br><span class="line">	/析构</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _destroy(T* ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">allocator</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> T  value_type;</span><br><span class="line">		<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> T* const_pointer;</span><br><span class="line">		<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">		<span class="comment">//内嵌体</span></span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rebind</span>&#123;</span><br><span class="line">			<span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//函数</span></span><br><span class="line">		<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n,<span class="type">const</span> <span class="type">void</span>* hint=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _allocate((difference_type)n,(pointer)hint);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">deallocte</span><span class="params">(pointer p,size_type n)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_deallocate(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_constrcut(p,value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_destroy(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	<span class="comment">//end of namespace myallocator</span></span><br></pre></td></tr></table></figure></p>
<h5 id="sgi空间配置器">2.2 SGI空间配置器</h5>
<p>SGI版本的空间配置器与众不同，其名称是<code>alloc</code>而不是<code>allocator</code>。<code>alloc</code>不接受任何参数，即如果你的程序要采用SGI版本的配置器，则不能使用标准写法： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::allocator&lt;<span class="type">int</span>&gt;&gt; iv;</span><br></pre></td></tr></table></figure> 而应当使用： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::alloc&gt; iv;</span><br></pre></td></tr></table></figure> 其实这个问题不会给我们带来困扰，在<code>GCC</code>中是使用缺省的空间配置器，我们可以不用显示的去指定，编译器默认采用SGI的这个版本。</p>
<p><strong><em>附</em></strong>：虽然SGI也提供了一个<code>aloocator</code>版本，但是不建议使用，因为效率不佳，因为它只是对<code>::operator new</code>和<code>::operator delete</code>做一个简单包装而已</p>
<h5 id="sgi的alloc">2.3 SGI的alloc</h5>
<p>我们知道<strong><code>new</code>算式包含两个步骤</strong>：一是调用<code>::operator new</code>配置内存；二是调用相应的构造函数构造对象内容。同样<strong><code>delete</code>算式也包含两个步骤</strong>：一是调用对象的析构函数析构；二是调用<code>::operator delete</code>释放内存</p>
<p>为了精密加工和效率的提升，STL的allocator把这两步操作区分开来，<strong>内存配置操作由<code>alloc::allocate()</code>负责，内存释放由<code>alloc::deallocate()</code>负责；而对象的构造和析构分别是由<code>::construct()</code>和<code>::destroy()</code>负责。</strong>STL的标准中规定配置器的定义位于<code>&lt;memory&gt;</code>中，对SGI版本来说<code>&lt;memory&gt;</code>内含有关键的两个文件，这两个文件实行上面的工作划分规则 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_alloc.h&gt;</span>		<span class="comment">//负责内存的配置和释放</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_construct.h&gt;</span>	<span class="comment">//负责构造和析构</span></span></span><br></pre></td></tr></table></figure> 在<code>&lt;stl_alloc.h&gt;</code>中定义了<strong>一、二级配置器</strong>，而在<code>&lt;stl_construct.h&gt;</code>定义了<code>construct()</code>和<code>destroy()</code>函数。</p>
<h5 id="alloc的stl_constuct">2.4 alloc的stl_constuct</h5>
<p>在<code>&lt;stl_construct.h&gt;</code>定义了多个重载的<code>construct()</code>和<code>destroy()</code>函数。这里介绍接受两个迭代器版本的<code>destroy()</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator lasu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_destroy(first,last,<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个函数我们可以知道它会析构掉<code>[first,last)</code>范围内对象，<strong>如果是调用一些无关痛痒得析构函数，又万一这个范围很大的话效率会极低。因此<code>_destroy()</code>利用<code>value_type()</code>获得迭代器对象所指代得类型，在<code>_destroy</code>内部利用<code>_type_traits&lt;T&gt;</code>判断该类型得析构是否对内存空间无关痛痒，若是<code>_true_type</code>，则什么也不做就结束，若是<code>_false_type</code>则只能迭代去析构这个范围得对象。</strong></p>
<h5 id="空间配置stl_alloc">2.5 空间配置stl_alloc</h5>
<p>SGI内部是以<code>malloc()</code>和<code>free()</code>完成内存得配置与释放得。考虑到小型区块可能造成内存碎片得问题，SGI设计了双层配置器，<strong>第一级直接使用<code>molloc()</code>和<code>free()</code>,第二级则看情况采用不同策略分配：</strong></p>
<ul>
<li>当配置区块超过<code>128bytes</code>时，视为足够大，直接调用第一级得配置器</li>
<li>当配置区块小于<code>128bytes</code>时，视为小，便采用复杂的<code>memory pool</code>和自由链表管理配置</li>
</ul>
<p><strong>内存池<code>memory pool</code></strong>：内存池是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样，内存池允许在运行期以常数时间规划内存块，并且尽量避免了内存破碎的情况产生，使得内存分配的效率得到提升。</p>
<p><strong><em>注意：是只开放一级配置器还是同时开放二级，由<code>_USE_MALLOC</code>是否被定义而定，当被定义是，只开放第一级配置器，当未背定义时两级都开放。</em></strong></p>
<h6 id="一级配置器">2.5.1 一级配置器</h6>
<p>一级配置器是类名为<strong><code>template&lt;int inst&gt;class _malloc_alloc_template&#123;...&#125;</code></strong>的一个类，在<code>allocate()</code>内直接使用<code>malloc()</code>,在<code>deallocate()</code>直接使用<code>free()</code>。同时<strong>模拟<code>set_new_handler()</code>来处理内存不足的情况</strong>。奉上源码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_malloc_alloc_template</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//以下函数用来处理内存不足的情况</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span>*,<span class="type">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*_malloc_alloc_oom_handler)</span><span class="params">()</span></span>;	<span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//allocate分配</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">		<span class="type">void</span> *result=<span class="built_in">malloc</span>(n);		<span class="comment">//直接使用malloc分配</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==result)</span><br><span class="line">			result=<span class="built_in">oom_malloc</span>(n);	<span class="comment">//不断尝试</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//模拟set_new_hanlder，返回函数指针</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span><span class="params">(* set_malloc_hanlder(<span class="type">void</span>(*f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">void</span> (*old)=_malloc_alloc_oom_handler;</span><br><span class="line">		<span class="comment">//设置</span></span><br><span class="line">		_malloc_alloc_oom_handler=f;</span><br><span class="line">		<span class="keyword">return</span> (old);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数为纯虚函数，需要自己编写处理函数来不断尝试释放内存、申请内存</span></span><br><span class="line"><span class="built_in">void</span> (* _malloc_alloc_template&lt;inst&gt;::_malloc_alloc_oom_handler)()=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//malloc形式的不断尝试</span></span><br><span class="line"><span class="type">void</span> *_malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n)&#123;</span><br><span class="line">	<span class="built_in">void</span> (*my_malloc_hanlder)();	<span class="comment">//函数指针</span></span><br><span class="line">	<span class="type">void</span> *result;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;<span class="comment">//不断尝试释放，配置</span></span><br><span class="line">		my_malloc_hanlder=_malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==my_malloc_handler)</span><br><span class="line">			_ThROW_BAD_ALLOC;</span><br><span class="line">		(*my_malloc_handler)();<span class="comment">//调用释放</span></span><br><span class="line">		<span class="comment">//进行分配</span></span><br><span class="line">		result=<span class="built_in">malloc</span>(n);</span><br><span class="line">		<span class="comment">//分配成功直接返回</span></span><br><span class="line">		<span class="keyword">if</span>(result)</span><br><span class="line">			<span class="keyword">return</span>(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>查看上述的部分源代码可以知道</strong></p>
<ul>
<li>第一级空间分配器以<code>malloc()、free()、realloc()</code>等C函数执行内存配置，而不是采用<code>C++</code>的<code>::operator new</code>，<strong>因此无法使用C++的<code>new hanlder</code>机制，也就不能使用<code>set_new_hanlder()</code>,必须仿真一个类似该功能的<code>set_malloc_handler()</code></strong></li>
<li><code>allocate()</code>分配不成功后会改调用<code>oom_malloc()</code>不断尝试去释放分配，其中的<code>_malloc_alloc_oom_hanlder()</code>函数是要自己去编写指定的。如果你没有传入该函数，源码也未提供，默认为纯虚函数，则进入到<code>oom_hanlder()</code>判断后直接抛异常。</li>
</ul>
<h6 id="附加知识点new-handler机制">2.5.2 附加知识点：new handler机制</h6>
<p><code>new_handler</code>是一个void*类型的函数指针 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">　<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;	<span class="comment">//函数指针，只是起个名字new_handler=void*</span></span><br><span class="line"> <span class="comment">//new_handler是一个typedef后void*</span></span><br><span class="line">　<span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>new_handler</code>类型内的函数将在默认内存申请函数<code>operator new</code>和<code>operator new[]</code>申请内存失败时被调用;</li>
<li>默认情况下, 当内存不能够分配时, <code>new</code>操作将抛出一个<code>bad_alloc</code>的异常。 你可以改变这个默认操作, 通过<code>set_new_handler()</code>设置<code>new_handler</code>内的函数指针。当然 你可以使用<code>set_new_handler(0)</code>, 获得一个不抛出异常的<code>new</code>.</li>
</ul>
<p><strong>用户定义的my_handler应该可以做以下几件事之一:</strong></p>
<ul>
<li>释放内存, 产生更多可以用的内存</li>
<li>抛出bad_alloc异常(或bad_alloc派生类)</li>
<li>终止程序(比如调用abort或exit)</li>
</ul>
<h6 id="二级配置器">2.5.3 二级配置器</h6>
<p>二级配置器类名为<strong><code>template&lt;bool threads,int ints&gt;class _default_alloc_template&#123;...&#125;</code>：维护16个自由链表，负责16种小型区块内存池的次配置能力，内存池<code>memory pool</code>事先由<code>malloc</code>配置而得</strong>。为了方便管理，SGI的二级配置会主动将小额的内存需求上调至8的倍数，例如我们要求分配30bytes，那么二级配置器就会分配维护多个<code>32bytes</code>的内存块。第二级配置器多了许多机制，以避免太多的小额区块造成内存碎片，从而避免内存浪费和减轻配置负担，第二级配置的做法是：</p>
<ul>
<li>当配置区块超过<code>128bytes</code>时，视为足够大，直接调用第一级得配置器</li>
<li>当配置区块小于<code>128bytes</code>时，视为小，便采用复杂的<code>memory pool</code>管理配置，又称为次层配置。</li>
</ul>
<p><strong><code>memory pool</code>的想法是</strong>：预先配置一大块内存，一般来书为需求的2倍，并维护与之对应的自由链表<code>free list</code>。<strong>下次若有对应大小的内存需求，则直接从该链表拔出给它就行；如果客户端释还从该内存池种拔出的一部分内存，则由配置器回收到该内存池中</strong>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//free list的节点结构如下所示：节点使用union而不是struct，从而达到节省内存开销的目的。</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span>&#123;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;	<span class="comment">//未被使用时，由次指针维护</span></span><br><span class="line">	<span class="type">char</span> client_data[<span class="number">1</span>];	<span class="comment">//当内存被使用时，软件开发者使用这个，执行实际区块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>下面来介绍这种机制：</strong>从内存池中取空间给<code>free list</code>是<code>chunk_alloc()</code>函数得工作。</p>
<ul>
<li>如<code>chunk_alloc(32，20)</code>会根据<code>end_free-start_free</code>来判断内存池得水量是否充足，如果水量充足，则直接调出20个相应大小的内存区块给<code>free_list</code>；如果不充足则调用<code>malloc</code>分配至少40个<code>32bytes</code>的内存块，一个直接给客户端，19个给<code>free_list</code>维护，另外的给内存池</li>
<li>如果不够20个但至少能满足一个32bytes的内存块，也会拨出至少一个；</li>
<li>如果连一个区块都拨不出去，此时便会利用<code>malloc</code>从<code>heap</code>上配置内存，从内存中为内存池注入水源以应付需求，一般来说申请的内存是需求量的2倍。</li>
</ul>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/memorypool.png" width="700"></p>
<p>如上图：</p>
<ul>
<li><strong>假设程序一开始就调用<code>chunk_alloc(32,20)</code>,那么<code>malloc</code>就会配置40个<code>32bytes</code>的区块，其中第一个交出，另外19个交给<code>free_list[3]</code>维护，剩余20个交给内存池。</strong></li>
<li>接下来客户端再调用<code>chunk_alloc(64,20)</code>,此时很明显<code>free_list[7]</code>没有内存，必须向内存池请求支持，但内存池也只够10个64<code>bytes</code>的区块，那么就会交付这10，一个直接给客户端，另外9个由<code>free_list[7]</code>维护。此时内存池已经空了，</li>
<li>如果再调用<code>chunk_alloc(96,20)</code>,不仅<code>free_list[11]</code>没有内存，就连内存池也没有，那么就会调用<code>malloc</code>配置40+n个<code>96bytes</code>区块，其中第一个给客户端，19个给<code>free_list[11]</code>，另外的给内存池。</li>
<li>如果<code>malloc()</code>也无法分配内存，就会使用第一级配置，不断尝试去释放获取。</li>
</ul>
<h4 id="迭代器与traits编程技法">3. 迭代器与traits编程技法</h4>
<p><code>iterator</code>是指提供一种方法，使之能够依序巡防某个容器所含的各个元素，而又无需暴露该容器的内部表达式。STL通过泛型化将数据容器和算法分开，采用<code>iterator</code>将两者粘合起来，以<code>find</code>为例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(first!=last&amp;&amp;*first!=value)</span><br><span class="line">		++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 迭代器是一种行为类似指针的<strong>对象</strong>，而指针最常见的应用就是<strong>内容提取和成员访问</strong>，因此对于迭代器来说最重要的编程工作就是对<code>operator *、operator-&gt;、operator++</code>进行重载</p>
<h5 id="traits编程技法-stl源码的门钥">3.1 traits编程技法-STL源码的门钥</h5>
<h6 id="为什么要使用traits编程技法">3.1.1 为什么要使用traits编程技法</h6>
<p>迭代器一般都为模板，其所指对象的的型别，称为该迭代器的<code>value type</code>。模板函数虽然带有参数类型的推导，但却不是万能的：<strong>万一<code>value type</code>用于函数的反回值，毕竟template的参数推导机制只是适用于参数，无法推导返回值</strong>。<strong>我们可能可以在类内定义内嵌型别来解决，也可以使用<code>C++11</code>的的尾置返回类型</strong><code>remove_reference&lt;decltype(beg*)&gt;::type</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内嵌类型声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myiter</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;		<span class="comment">//内嵌型别声明</span></span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> I&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> I::value_type <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾置返回类型</span></span><br><span class="line"><span class="comment">//此例中我们通知编译器fcn2的返回类型与解引用beg的参数的结果类型相同</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(T beg,T end)</span>-&gt;<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上面这个程序看起来能够解决返回值问题，但是有一个问题就是我们<strong>不能为不是类类型的定义内嵌型别</strong>，比如<strong>指针</strong>就不行，但STL又必须接受原生指针作为一种迭代器。虽然采用模板的特例化可以解决问题，但是每有需要就要特例化一个模板就很麻烦，此时就得采用<code>traits</code>的偏特例化编程。(像<code>int*,double*</code>内置类型或者自动定义的类的指针就是原生指针)</p>
<h6 id="traits和偏特例化">3.1.2 traits和偏特例化</h6>
<p><code>traits</code>单词只是说明这个类能萃取到迭代器的特性，只是一个名字的作用，告诉编程人员注意对于这种类内部会对传入的参数进行取<code>value type</code>操作，说实在就是STL当中的规范协议。如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> itrator_traits&lt;I&gt;::<span class="built_in">value_type</span>(I iter)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果I内定义了自己的<code>value type</code>，那么就会在<code>iterator_traits</code>这种类内部有取<code>value type</code>操作。这里跟我们上面提到的内嵌型别说明是一样的。上面这个类只是起到中间转换的作用，这就<code>traits</code>的特定。</p>
<p>然后我们在去实现iterator_traits的一个特例化版本即传入指针形式的偏特化版本就能取得指针的类型 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的机制是当我们传入T*=int*时，因为int内有定义value_type那么就肯定能获得其类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 为啥还需要const版本，引用我们最终要获取时<code>I</code>的类型，而不是<code>const+类型</code>,试想当没有const版本，调用iterator_traits&lt;const int*&gt;会获取到<code>const int</code>而不是<code>int</code>。<strong>三个版本都是需要的，后面两个版本为解决原生指针无法获取类型而采用（应用偏特例化）</strong></p>
<p>总结：</p>
<ul>
<li>实现原生指针也能推导返回值类型就是要<code>traits</code>编程技法</li>
<li><code>traits</code>不是什么C++内部关键字，它只是对STL源码编写的一个规范</li>
<li><code>traits</code>编程技法主要应用于迭代器实现，迭代器就是行为像指针的类，保证我们在使用迭代器类的<code>operator*</code>后能返回迭代器所指的元素</li>
<li><code>traits</code>编程技法的实现原理就是对类模板的偏特例化（上面的二个篇特例化模板）</li>
</ul>
<h5 id="迭代器相应型别">3.2 迭代器相应型别</h5>
<p>更加迭代器使用<code>operator*</code>时所返回的类别，一般有<code>value type,difference type,pointer,reference,itrator category</code>这五种。因此我们在对<code>traits</code>类进行<code>typedef</code>时都应当指定，以便符号STL规范，即使自己编写的迭代器类也能与STL水乳交融。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::iterator_category	iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type 		    value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::difference_type 	difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer 			pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference 			reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="value_type">3.2.1 value_type</h6>
<p><code>value_type</code>就是迭代器所指对象的型别，任何一个打算与STL算法有完美搭配的class,都应当定义自己的<code>value_type</code>内嵌型别。</p>
<h6 id="difference_type">3.2.2 difference_type</h6>
<p><code>difference_type</code>用来表示两个迭代器的距离，因此也可以用来表示一个容器的最大容量。比如STL的<code>count</code>算法统计指定值出现次数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I*&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">count</span><span class="params">(I fist,I last,<span class="type">const</span> T&amp; value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I*&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;first!=last;++first)</span><br><span class="line">		<span class="keyword">if</span>(*first==value)</span><br><span class="line">			++n;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="reference">3.2.3 reference</h6>
<p><code>reference_type</code>即我们熟知的C++当中的左值引用，这个类型允许我们通过迭代器来对容器内的元素做出改变。</p>
<h6 id="pointer">3.2.4 pointer</h6>
<p><code>pointer</code>是指指针，传回一个指针表示我们也可以通过迭代器对容器内的元素做改变。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="iterator_category">3.2.5 iterator_category</h6>
<p>这个型别是迭代器的类型型名，必须指定迭代器的分类如下： <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/iterator.png" width="300"> 我们在设计算法的时候，必须针对上图的某种迭代器提供一明确定义，比如有一个算法明确使用<code>ForwardIterator</code>，那就应当明确传递这种迭代器，虽然传递<code>RandomAccessIterator</code>和<code>BidirectionalIterator</code>也可以,但效率并不是最佳。</p>
<h5 id="iterator源代码展示">3.3.iterator源代码展示</h5>
<p>下面的源代码选自SGI版本的STL<code>&lt;stl_iterator.h&gt;</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ITERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ITERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//五种迭代器，作为标记型别（tag types）,不需要任何成员</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iteratoe_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为避免写代码时挂一漏万，自行开发的迭代器最好继承自下面这个 std::iterator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Category</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>=<span class="type">ptrdiff_t</span>,</span><br><span class="line">		<span class="keyword">class</span> Pointer=T*,<span class="keyword">class</span> Reference=T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//五种迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> input_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                   value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance            difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                  pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                  reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                     value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance              difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                    pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                    reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;榨汁机&quot;traits</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer            pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference          reference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生指针（naive pointer）而设计的traits偏特性化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对Pointer-to-const而设计的traits偏特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T*                    pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T                     reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某迭代器iterator的类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">category</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器的value_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器的distance_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type*</span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//........................整组advance函数............................................</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数重载，使迭代器能在编译时期就确定调用哪个函数*/</span>  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为input_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_InputIter&amp; __i, _Distance __n, input_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (__n--) ++__i;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为bidirectional_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_BidirectionalIterator&amp; __i, _Distance __n,   </span><br><span class="line">                      bidirectional_iterator_tag) </span><br><span class="line">&#123;  </span><br><span class="line">  __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);  </span><br><span class="line">  <span class="keyword">if</span> (__n &gt;= <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">while</span> (__n--) ++__i;</span><br><span class="line">  <span class="keyword">else</span>  </span><br><span class="line">    <span class="keyword">while</span> (__n++) --__i;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为random_access_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_RandomAccessIterator&amp; __i, _Distance __n,   </span><br><span class="line">                      random_access_iterator_tag) </span><br><span class="line">&#123;  </span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);  </span><br><span class="line">  __i += __n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*决定调用哪个函数，这是一个对外接口*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(_InputIterator&amp; __i, _Distance __n)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_InputIterator, _InputIterator);</span><br><span class="line">  __advance(__i, __n, <span class="built_in">iterator_category</span>(__i));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//............................整组distance函数........................................</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function">	<span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __distance(first, last,</span><br><span class="line">			std::iterator_traits&lt;InputIterator&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">	_distance(InputIterator first,InpuetIterator，input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">    	++first;</span><br><span class="line">		++n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::difference_type </span><br><span class="line">        __distance(InputIterator first, InputIterator last, </span><br><span class="line">		std::random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的<code>advan</code>函数<strong><em>如果</em></strong>不加第三个参数，因为型别都未定，<strong>是实打实的<code>template</code>，不是重载函数，如下：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_II</span><span class="params">(InputIterator&amp; __i, _Distance __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectinalIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_BI</span><span class="params">(BidirectinalIterator&amp; __i, _Distance __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_RI</span><span class="params">(RandomAccessIterator&amp; __i, _Distance __n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们调用的时候，如果选错使用<code>advance_II</code>来进行<code>advance_RI</code>的工作内容，则原本的O(1)时间复杂度就变成了O(n)，<strong>因此在源码中通过增加五个结构体，来给这些函数增加第三个确定的参数形成重载机制，在编译时能够使用重载确定调用哪一个版本，容错率高</strong>。<code>distance</code>函数也是这样的思想。这是一个值得借鉴的模板编写方式！</p>
<h4 id="序列式容器">4. 序列式容器</h4>
<p>序列式容器当中的元素都可序，但未必一定有序，全看编程者的操作。C++语言本身带有<code>array</code>，STL提供<code>vector、list、deque、stack、queue、priority_queue</code>等序列容器。由于<code>stack\queue</code>只是将<code>deque</code>改头换面而成，技术上被归为配接器。</p>
<h5 id="vector">4.1 vector</h5>
<p>在<code>vector</code>中最关键的在于器对大小的控制以及重新配置时数据的移动效率。这些在后面会介绍到，这里我们先对<code>vector</code>的源码进行简单介绍： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T			value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;		<span class="comment">//这个说明了迭代器就是普通指针</span></span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> 		size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> 	difference_type;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//Simple_alloc时SGI STL的空间配置器，</span></span><br><span class="line">	<span class="comment">//虽然vector使用了缺省的配置器,但Simple_alloc更方便以元素大小为配置单元</span></span><br><span class="line">	<span class="keyword">typedef</span> Simple_alloc&lt;value_type,Alloc&gt;data_allocator;</span><br><span class="line">	iterator start;						<span class="comment">//表示目前使用空间的头</span></span><br><span class="line">	iterator finissh;					<span class="comment">//表示目前使用空间的尾</span></span><br><span class="line">	iterator end_of_storage;			<span class="comment">//表示目前可用空间的尾</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_aux</span><span class="params">(iterator position,<span class="type">const</span> T&amp;x)</span></span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...<span class="comment">//一些操作接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 因为<code>vector</code>维护的一个连续空间，所有不论元素型别为哪一种，普通指针都可以作为<code>vector</code>的迭代器而满足所有必要条件，因为像<code>operator*,-&gt;,++,--,+,-,+=,-+</code>这些操作，普通的指针天生就具备。也就是说普通指针就是<code>RandomAccessIterator</code>，支持随机存取。</p>
<h6 id="扩容机制">4.1.1 扩容机制</h6>
<p>在不同的STL版本中，vector的扩容策略不相同，msvc编译器每次是以1.5倍且向下取整的策略进行扩容，gcc编译器则是SGI版本，每次以2.0倍的策略进行扩容。下图时MSVC中的扩容机制 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MSVC</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">34</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(n);</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;size:&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot;  capacity:&quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">size:<span class="number">1</span>  capacity:<span class="number">1</span></span><br><span class="line">size:<span class="number">2</span>  capacity:<span class="number">2</span></span><br><span class="line">size:<span class="number">3</span>  capacity:<span class="number">3</span></span><br><span class="line">size:<span class="number">4</span>  capacity:<span class="number">4</span></span><br><span class="line">size:<span class="number">5</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">6</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">7</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">8</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">9</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">10</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">11</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">12</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">13</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">14</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">15</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">16</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">17</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">18</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">19</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">20</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">21</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">22</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">23</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">24</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">25</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">26</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">27</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">28</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">29</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">30</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">31</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">32</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">33</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">34</span>  capacity:<span class="number">42</span></span><br></pre></td></tr></table></figure></p>
<p>所谓的动态增加，并不是在原空间之后接续新空间，因为无法保证原空间之后尚有可供配置的空间，二是以原来的2倍或1.5倍另外配置一块较大空间，然后将内容拷贝过来，然后才在原内容之后构造新元素，并释放原空间。因此对<code>vector</code>的任何操作若会影响到空间重新配置，指向<code>vector</code>的所有迭代器就都失效了。</p>
<h5 id="list">4.2 list</h5>
<p>相较于<code>vector</code>的连续线性空间，list就比较复杂，它的好处就是每次插入或删除元素，才配置或释放一个元素空间。<strong><code>list</code>是一个双向链表，它不再能够像<code>vector</code>一样以</strong>普通指针<strong>作为迭代器，因为其节点不保证再空间中连续存在，<code>list</code>迭代器必须有能指向<code>list</code>的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。</strong></p>
<h6 id="list的迭代器">4.2.1 list的迭代器</h6>
<p><strong><code>list</code>的迭代器的要求:</strong></p>
<ul>
<li>迭代器必须具备前移、后移的能力，因此对<code>list</code>提供的是<code>BidirectinalIterator</code></li>
<li>与vector不同，不论是何时的插入操作和删除操作、接合操作都不会造成原因的<code>list</code>迭代器失效</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	link_type node; <span class="comment">//迭代器内部需要一个普通指针，指向list的节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//constructor</span></span><br><span class="line">	__list_iterator(link_type x):<span class="built_in">node</span>(x)&#123;&#125;</span><br><span class="line">	__list_iterator()&#123;&#125;</span><br><span class="line">	__list_iterator(<span class="type">const</span> iterator&amp; x):<span class="built_in">node</span>(x.node)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node==x.node;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node!=x.node;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以下对迭代器取值，取的是节点的数据值</span></span><br><span class="line">	reference <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对迭代器累加</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">		node=(link_type)((*node).next);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">		self tmp=*<span class="keyword">this</span>;</span><br><span class="line">		++*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对迭代器减1</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">		node=(link_type)((*node).prev);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">		self tmp=*<span class="keyword">this</span>;</span><br><span class="line">		--*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="list的数据结构">4.2.2 list的数据结构</h6>
<p><code>list</code>是一个<strong>双向环形链表</strong>，所有它只需要一个指针 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> _list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	link_type node;		<span class="comment">//只需一个指针</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="deque">4.3 deque</h5>
<p><strong><code>deque</code>是一种双向开口的连续线性空间，即指能在头尾两端都支持元素的插入和删除</strong> <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/deque.png" width="500"> <code>vector</code>虽然也能支持在头尾两端进行操作，但是效率奇差，无法接受，因为在头部的插入导致后面所有元素都要后移。而<code>deque</code>则不会：</p>
<ul>
<li><code>duque</code>允许时间复杂度<code>O(1)</code>对其头端进行元素的插入和移除，<code>vector</code>为<code>O(n)</code></li>
<li><code>deque</code>没有所谓的容量概念，因为它是动态地以连续空间组合而成，随时可以增加一段新的空间并链接起来，即不会发生如<code>vector</code>那样的空间重新配置机制</li>
<li>虽然<code>deque</code>也提供<code>RandomAccessIterator</code>，但它的迭代器并不是普通指针，其复杂度和<code>vector</code>不可同道里计，因此除非必要我们应该尽量选择<code>vector</code>而不是<code>deque</code>。</li>
<li>在对<code>deque</code>进行排序操作，为了最高效率，可将<code>deque</code>先完整复制到一个<code>vector</code>身上，将<code>vector</code>排序后再复制会<code>deque</code></li>
</ul>
<h6 id="deque的中控器">4.3.1 deque的中控器</h6>
<p><code>deque</code>是逻辑上是连续空间。<code>deque</code>系由一段一段的定量空间组成，一旦必要在<code>deque</code>的前端或尾增加空间，便配置一段定量连续空间，串接在整个<code>deque</code>的头端或尾端。因此对于<code>deque</code>容器来说必须维护其整体连续的假象，并提供随机存取接口，那么必须有中央控制器和复杂的迭代架构去实现。</p>
<p><strong><code>Deque</code>采取一块所谓的<code>map</code>(注意，不是STL的map容器)作为主控，这里所谓的<code>map</code>是一小块连续的内存空间，其中每一个元素(此处成为一个结点<code>node</code>)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是<code>deque</code>的存储空间的主体。</strong><code>SGI STL</code>允许我们指定缓冲区大小，默认使用<code>512bytes</code>(<code>map</code>其实就是二重指针<code>T**</code>) <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dequemap.png" width="500"></p>
<h6 id="deque的迭代器">4.3.2 deque的迭代器</h6>
<p>对于<code>deque</code>，维持其整体连续的假象，落在了迭代器的<code>operator++</code>和<code>operator--</code>两个重载运算符上。</p>
<ul>
<li>该迭代器必须能够指出分段连续空间在哪里</li>
<li>其次他必须能够判断自己是否已经处在其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃到下一个或上一个缓冲区。</li>
</ul>
<p>因此为了能够正确跳跃，<code>deque</code>必须随时掌握管控中心<code>map</code>。如下的实现方式可行: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>,<span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span>&#123; <span class="comment">//为继承 std::iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;,T*,Bufsize&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*,Bufsize&gt; const_iterator;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> __deque_buf_size(Bufsize,<span class="built_in">sizeof</span>(T));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未继承std::iterator,所以必须自行撰写下述五个必要的迭代器相应型别</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref renference; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持与容器的联结</span></span><br><span class="line">    T* cur; <span class="comment">//此迭代器所指之缓冲区中的现行(current)元素</span></span><br><span class="line">    T* first; <span class="comment">//此迭代器所指之缓冲区中的头</span></span><br><span class="line">    T* last; <span class="comment">//此迭代器所指之缓冲区中的尾(含备用空间)</span></span><br><span class="line">    map_pointer node; <span class="comment">//指向管控中心</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n,<span class="type">size_t</span> sz)&#123;</span><br><span class="line">        <span class="keyword">return</span> n!=<span class="number">0</span>? n:(sz&lt;<span class="number">512</span>? <span class="built_in">size_t</span>(<span class="number">512</span>/sz):<span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    n!=0,返回n，表示buffer_size由	用户自定义</span></span><br><span class="line"><span class="comment">    n=0,表示buffer_size使用默认值，那么：</span></span><br><span class="line"><span class="comment">        sz&lt;512,传回512/sz;</span></span><br><span class="line"><span class="comment">        sz&gt;=512,传回1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dequeiterator.png" width="700"> 如上图，假设我们产生一个元素类型未<code>int</code>,缓冲区为8的<code>deque</code>，经过增删操作后拥有20个元素。<strong><code>deque</code>类内的<code>start</code>和<code>finish</code>分别指向<code>deque</code>的第一个缓冲区和最后一个缓冲区，20/8=3，所以map拥有3个节点，且最后一个缓冲区还有插入元素的空间。</strong>三个指针<code>cur、first、last</code>分别如图所示，`cur·指向缓冲区的最后一个元素的下一个位置。</p>
<p>下面是deque几个重要操作： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span></span>&#123;</span><br><span class="line">	node=new_node;</span><br><span class="line">    first=*new_node;</span><br><span class="line">    last=first+<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">renference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> *cur;&#125;</span><br><span class="line"></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())*</span><br><span class="line">		(node-x.node<span class="number">-1</span>)+(cur-first)+(x.last-x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">    ++cur; <span class="comment">//切换下一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(cur==last)&#123; <span class="comment">//如果已达到所在缓冲区的尾端</span></span><br><span class="line">        <span class="built_in">set_node</span>(node+<span class="number">1</span>); <span class="comment">//利用set_node方法切换到下一个缓冲区</span></span><br><span class="line">        cur=first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>; <span class="comment">//调用operator++</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==first)&#123; <span class="comment">//如果达到缓冲区的头部</span></span><br><span class="line">        <span class="built_in">set_node</span>(node<span class="number">-1</span>); <span class="comment">//利用set_node方法切换到上一个缓冲区</span></span><br><span class="line">        cur=first;</span><br><span class="line">    &#125;</span><br><span class="line">    --cur;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>; <span class="comment">//调用operator--</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)&#123; <span class="comment">//实现随机存取、迭代器可以直接跳跃n个距离</span></span><br><span class="line">    difference_type offset=n+(cur-first);</span><br><span class="line">    <span class="keyword">if</span>(offset&gt;=<span class="number">0</span>&amp;&amp;offset&lt;<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) <span class="comment">//目标位置在统一缓冲区</span></span><br><span class="line">        cur+=n;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//目标位置不在统一缓冲区</span></span><br><span class="line">       		difference_type node_offset=offset&gt;<span class="number">0</span>?</span><br><span class="line">			offset/<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">				:-<span class="built_in">difference_type</span>((-offset<span class="number">-1</span>)/<span class="built_in">buffer_size</span>())<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">set_node</span>(node+node_offset); <span class="comment">//切换至正确的节点</span></span><br><span class="line">            cur=first+(offset-node_offset*<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()); <span class="comment">//切换至正确的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp+=n; <span class="comment">//调用operator+=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>+=-n;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp-=n; <span class="comment">//调用operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机存取第n个元素</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n)<span class="type">const</span> &#123;<span class="keyword">return</span> *(*<span class="keyword">this</span>+n);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> cur==x.cur;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> !(*<span class="keyword">this</span>==x);&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="built_in">return</span> (node==x.node)?(cur&lt;x.cur):(node&lt;x.node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="deque的数据结构">4.3.3 deque的数据结构</h6>
<p>deque除了维护<code>map</code>指针外，还必须维护<code>start、finish</code>两个迭代器，分别指向第一个缓冲区的第一个元素和最后一个缓冲区的额最后一个元素。此外，它当然也必须记住目前的map大小，因为一旦<code>map</code>所提供的节点不足，就必须重新配置更大的一块<code>map</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc,<span class="type">size_t</span> BufSiz=<span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;,T*,BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//元素的指针的指针</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start; <span class="comment">//表示第一个节点</span></span><br><span class="line">    iterator finish; <span class="comment">//表示最后一个节点</span></span><br><span class="line">    map_pointer map; <span class="comment">//指向map，map是块连续空间，其每个元素都是指针，指向一个节点</span></span><br><span class="line">    size_type map_size; <span class="comment">//map内有多个指针</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n)&#123;</span><br><span class="line">        <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">//调用operator[]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *start;&#125; <span class="comment">//调用operator*</span></span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        iterator temp=finish;</span><br><span class="line">        --temp; <span class="comment">//调用operator--</span></span><br><span class="line">        <span class="keyword">return</span> *temp; <span class="comment">//调用operator*</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> finish-start;&#125; <span class="comment">//调用operator-</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> finish==start;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="heap">4.5. heap</h5>
<p><code>heap</code>不属于STL的容器组件，但我们有必要认识它的实现思想，它是实现<code>priority queue</code>的助手。<code>priority queue</code>允许用户以任何次序将元素存入容器中，但是取出时一定时从优先权最高的元素开始取。而堆正有这样的特性，适合作为<code>priority queue</code>的底层机制。</p>
<p>对于heap的虽然讲解的时候用的是<strong>完全二叉树</strong>的形式来讲解，但只是为了更直观的表达而已，一般来说实现都是采用数组的形式来实现的，同时为了达到空间可增长，采用<code>vector+heap算法</code>来实现堆。</p>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/heapSort.gif" width="500"></p>
<h6 id="push_heap算法">4.5.1 push_heap算法</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意，此函式被调用时，新元素已置于底部容器的最尾端</span></span><br><span class="line">    __push_heap_aux(first, last, <span class="built_in">distance_type</span>(first),<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap_aux</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last, Distance*, T*)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>),<span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">    <span class="comment">// 以上系根据implicit representation heap的结构特性：新值必置于底部</span></span><br><span class="line">    <span class="comment">// 容器的最尾端，此即第一个洞号：(last-first)–1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 push_back()不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __push_heap(RandomAccessIterator first, Distance holeIndex,Distance topIndex, T value) </span><br><span class="line">&#123;</span><br><span class="line">    Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 找出父节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value) &#123;</span><br><span class="line">        <span class="comment">// 当尚未到达顶端，且父节点小于新值（于是不符合 heap 的次序特性）</span></span><br><span class="line">        <span class="comment">// 由于以㆖使用 operator&lt;，可知 STL heap 是一种 max-heap（大者为父）</span></span><br><span class="line">        *(first + holeIndex) = *(first + parent); <span class="comment">//令洞值为父值</span></span><br><span class="line">        holeIndex = parent; <span class="comment">// percolate up：调整洞号，向上提升至父节点</span></span><br><span class="line">        parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 新洞的父节点</span></span><br><span class="line">    &#125; <span class="comment">// 持续至顶端，或满足heap的次序特性为止</span></span><br><span class="line">    </span><br><span class="line">    *(first + holeIndex) = value; <span class="comment">//令洞值为新值，完成插入动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pop_heap算法">4.5.2 pop_heap算法</h6>
<p><strong><code>pop_heap</code>算法思路如下：</strong></p>
<ul>
<li>1.把根节点元素取出，把最后一个节点的元素取出</li>
<li>2.将原根节点元素放在vector的最后一个节点处</li>
<li>3.将原先的最后一个节点的元素放置到原根节点处作为新根节点</li>
<li>4.将新根节点逐个与子节点比较，直到其值比子节点都大时，结束算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __pop_heap_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap_aux(RandomAccessIterator first,RandomAccessIterator last, T*) </span><br><span class="line">&#123;</span><br><span class="line">    __pop_heap(first, last<span class="number">-1</span>, last<span class="number">-1</span>, <span class="built_in">T</span>(*(last<span class="number">-1</span>)),</span><br><span class="line">    <span class="built_in">distance_type</span>(first));</span><br><span class="line">    <span class="comment">// 以上，根据 implicit representation heap 的次序特性，pop操作的结果</span></span><br><span class="line">    <span class="comment">// 应为底部容器的第一个元素。因此，首先设定欲调整值为尾值，然后将首值调至</span></span><br><span class="line">    <span class="comment">// 尾节点（所以以上将迭代器 result设为 last-1）。然后重整 [first, last-1)，</span></span><br><span class="line">    <span class="comment">// 使之重新成一个合格的 heap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 pop_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap(RandomAccessIterator first,</span><br><span class="line">        RandomAccessIterator last,</span><br><span class="line">        RandomAccessIterator result,</span><br><span class="line">        T value, Distance*) </span><br><span class="line">&#123;</span><br><span class="line">    *result = *first; <span class="comment">// 设定尾值为首值，于是尾值即为欲求结果，</span></span><br><span class="line">                      <span class="comment">// 可由客端稍后再以底层容器之 pop_back() 取出尾值</span></span><br><span class="line"> </span><br><span class="line">    __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">    <span class="comment">// 以上欲重新调整 heap，洞号为 0（亦即树根处），欲调整值为 value（原尾值）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="sort_heap算法">4.5.3 sort_heap算法</h6>
<p>既然每次<code>pop_heap</code>可获得<code>heap</code>之中键值最大的元素，如果持续对整个<code>heap</code>做<code>pop_heap</code>动作，每次将操作范围从后向前缩减一个元素（因为pop_heap会把键值最大的元素放在底部容器的最尾端），当整个程序执行完毕，我们便有了一个递增序列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 [first,last) 排列为一个heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 make_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first,RandomAccessIterator last, T*,Distance*) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//如果长度为0或1，不必重新排列</span></span><br><span class="line"> </span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    <span class="comment">// 找出第一个需要重排的子树头部，以parent标示出。由于任何叶节点都不需执行</span></span><br><span class="line">    <span class="comment">// perlocate down，所以有以下计算。parent命名不佳，名为holeIndex 更好</span></span><br><span class="line">    Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 重排以 parent 为首的子树。len是为了让__adjust_heap() 判断操作范围</span></span><br><span class="line">        __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 走完根节点，就结束。</span></span><br><span class="line">        parent--; <span class="comment">// （即将重排之子树的）头部向前一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="priority_queue">4.6 priority_queue</h5>
<p><code>priority_queue</code>是一个拥有权值观念的<code>queue</code>。其内部的元素不再像<code>queue</code>依照被存入的次序排列，而是按照元素的权值排列，权值最高者，排在最前面。缺省情况下<code>proority_queue</code>利用一个<code>max-heap</code>和<code>vector</code>为底部容器。<code>priority_queue</code>没有迭代器(<code>queue</code>和<code>stack</code>也没有) <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/priorityqueue.png" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;,</span><br><span class="line">    <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line">    Compare comp; <span class="comment">// 元素大小比较标准</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : c(), comp(x) &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以下用到的 make_heap(), push_heap(), pop_heap()都是泛型算法</span></span><br><span class="line">    <span class="comment">// 注意，任一个建构式都立刻于底层容器内产生一个 implicit representation heap</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; x)</span><br><span class="line">        : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(),comp); &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last)</span><br><span class="line">        : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        __STL_TRY &#123;</span><br><span class="line">            <span class="comment">// push_heap是泛型算法，先利用底层容器的 push_back() 将新元素推入末端，再重排heap</span></span><br><span class="line">            c.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); <span class="comment">//push_heap是泛型算法</span></span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        __STL_TRY &#123;</span><br><span class="line">            <span class="comment">//pop_heap 是泛型算法，从 heap 内取出一个元素。它并不是真正将元素</span></span><br><span class="line">            <span class="comment">//弹出，而是重排 heap，然后再以底层容器的 pop_back() 取得被弹出的元素</span></span><br><span class="line">            <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">            c.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="关联式容器">5. 关联式容器</h4>
<p>标准的STL关联式容器分为<code>set</code>集合和<code>map</code>映射表两大类。以及两大衍生体<code>multiset</code>和<code>multimap</code>。这些容器的底层机制均与<code>RB-tree</code>完成。红黑树是一个独立容器，但不对外界使用。同时<code>SGI STL</code>还提供了一个不在标准规则之外的管理容器<code>hash_table</code>，以及以<code>hash_table</code>为底层机制完成的<code>hash_set、hash_map、hash_multiset、hash_multimap</code>。</p>
<p>所谓关联式容器类似于关联式数据库：每笔数据都有一个键值和一个实值，当元素插入到关联式容器时会按照键值大小以某种规则将这个元素放置于合适的位置，因此对于关联式容器没有<code>push_back、push_front、pop_back、pop_front</code>这样的行为。</p>
<h5 id="rb-tree">5.1 RB-tree</h5>
<p>关于红黑树的的定义和一些平衡原理见<a href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构篇</a>，这里列举一些<code>SGI STL</code>的<code>RB-tree</code>源码。</p>
<h6 id="rb-tree结构体">5.1.1 RB-tree结构体</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RB树的节点结构:</span><br><span class="line"><span class="comment">//由于红黑树的各种操作常需要上溯其父级节点，因此特别安排一个parent指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;     <span class="comment">// 红色为0</span></span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">  color_type color;     <span class="comment">// 节点颜色，红色或黑色</span></span><br><span class="line">  base_ptr parent;      <span class="comment">// 该指针指向其父节点</span></span><br><span class="line">  base_ptr left;        <span class="comment">// 指向左节点</span></span><br><span class="line">  base_ptr right;       <span class="comment">// 指向右节点</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	 <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left; <span class="comment">//一直向左走，找到最小值</span></span><br><span class="line">	 <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right; <span class="comment">//一直向右走，找到最大值</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node</span> : <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;   <span class="comment">//节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="rb-tree迭代器">5.1.2 RB-tree迭代器</h6>
<p><code>RB-tree</code>的迭代器属于双向迭代器，但不具备随机定位的能力，与<code>list</code>较为相似，比较特殊的是他具有前进和后退的操作。<code>RB-tree</code>迭代器的<code>operator++</code>是调用了基层迭代器的<code>increment()</code>函数，其<code>operator--</code>调用<code>decrement()</code>函数。 <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/rbtreeiterator.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基层迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_tree_base_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	base_ptr node; <span class="comment">//用来与容器之间产生一个连接的关系</span></span><br><span class="line">	<span class="comment">//实现operator++</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(node-&gt;right != <span class="number">0</span>)&#123;</span><br><span class="line">	        <span class="comment">//状况1：右子结点存在，则当前可以看成是根节点,则找出右子树的最左结点</span></span><br><span class="line">	        node = node-&gt;right;</span><br><span class="line">	        <span class="keyword">while</span>(node-&gt;left != <span class="number">0</span>)</span><br><span class="line">	            node = node-&gt;left;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">	        <span class="comment">//状况2：没有右子节点,找出父节点</span></span><br><span class="line">			<span class="comment">//如果现行节点本身是个右子节点，就一直上溯，直到不为右子节点为止</span></span><br><span class="line">	        base_ptr y = node-&gt;parent;</span><br><span class="line">	        <span class="keyword">while</span>(y-&gt;right == node)&#123;</span><br><span class="line">	            node = y;</span><br><span class="line">	            y = y-&gt;parent;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">if</span>(node-&gt;right != y)</span><br><span class="line">	            <span class="comment">//状况3：如果当前的node不是根节点，则y即为所求</span></span><br><span class="line">	            node = y;</span><br><span class="line">	        <span class="comment">//状况4：如果当前的node是根节点，则node为所求</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//实现--</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(node-&gt;color == rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)</span><br><span class="line">	        <span class="comment">//状况1：如果当前结点是header结点，那么其前驱应该是mostright结点，也就是其右子结点</span></span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//状况2：也就是当前是根节点，那么其前驱应该是左子树中最右结点</span></span><br><span class="line">                base_ptr y = node-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(y-&gt;right != <span class="number">0</span>)</span><br><span class="line">                    y = y-&gt;right;</span><br><span class="line">                node = y;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//状况3：如果当前不是根节点，也没有左子节点，那么当前处于右子树的最左结点，要去找根节点</span></span><br><span class="line">                base_ptr y = node-&gt;parent;</span><br><span class="line">                <span class="keyword">while</span>(y-&gt;left == node)</span><br><span class="line">				&#123;</span><br><span class="line">                    node = y;</span><br><span class="line">                    y = y-&gt;parent;</span><br><span class="line">                &#125;</span><br><span class="line">                node = y;</span><br><span class="line">                <span class="comment">//如果当前处于root结点，y则为header结点，那么当前必定只有root一个结点</span></span><br><span class="line">                <span class="comment">//则可以得到node = header，y = root</span></span><br><span class="line">                <span class="comment">//最终得到node = y，不需要特殊处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正规迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value,<span class="keyword">typename</span> Ref,<span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_tree_iterator</span>:<span class="keyword">public</span> rb_tree_base_iterator&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,Value&amp;,Value*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,<span class="type">const</span> Value&amp;,<span class="type">const</span> Vallue*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,Ref,Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>(link_type x)&#123;node = x&#125;;</span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>(<span class="type">const</span> iterator&amp; it)&#123;node = it.node&#125;;</span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">link_type</span>(node)-&gt;value_field;</span><br><span class="line">	&#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">	    <span class="built_in">increment</span>();</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    <span class="built_in">increment</span>();</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	    <span class="built_in">decrement</span>();</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    <span class="built_in">decrement</span>();</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="rb-tree的数据结构">5.1.3 RB-tree的数据结构</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------------rb_tree类---------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node,Alloc&gt;rb_tree_node_allocator;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//没有迭代器iterator?不！会在后面声明</span></span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">link_type <span class="title">get_node</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">allocate</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span></span>&#123;<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">deallocate</span>(p);&#125;</span><br><span class="line">    <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        link_type tmp = <span class="built_in">get_node</span>(); <span class="comment">//配置空间</span></span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            Chy::allocator&lt;Key&gt;::<span class="built_in">construct</span>(&amp;tmp-&gt;value_field,x);<span class="comment">//构造内容</span></span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(<span class="built_in">put_node</span>(tmp));</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span></span>&#123;<span class="comment">//复制一个节点的颜色和数值</span></span><br><span class="line">        link_type tmp = <span class="built_in">create_node</span>(x-&gt;value_field);</span><br><span class="line">        tmp-&gt;color = x-&gt;color;</span><br><span class="line">        tmp-&gt;left = <span class="number">0</span>;</span><br><span class="line">        tmp-&gt;right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span></span>&#123;</span><br><span class="line">        Chy::allocator&lt;Key&gt;::<span class="built_in">destroy</span>(&amp;p-&gt;value_field); <span class="comment">//析构内容</span></span><br><span class="line">        <span class="built_in">put_node</span>(p); <span class="comment">//释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//RB-tree只使用三笔数据表现</span></span><br><span class="line">    size_type node_count; <span class="comment">//追踪记录树的大小 (节点的数量)</span></span><br><span class="line">    link_type header;     <span class="comment">//实现上的小技巧</span></span><br><span class="line">    Compare key_compare;  <span class="comment">//节点之间的键值大小的比较准则. 应该会是一个function object</span></span><br><span class="line">    <span class="comment">//以下三个函数用于方便获取header的成员</span></span><br><span class="line">    <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;parent;&#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">left_most</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;left;&#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">right_most</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;right;&#125;</span><br><span class="line">    <span class="comment">//以下六个函数用于方便获得节点x的成员</span></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;left;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;right;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;parent;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span> x-&gt;value_field;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x));&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span></span>&#123;<span class="keyword">return</span> (color_type&amp;) (x-&gt;color);&#125;</span><br><span class="line">    <span class="comment">//获取极大值和极小值 node class有实现此功能</span></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type,reference,pointer&gt;iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    iterator __insert(base_ptr x,base_ptr y,<span class="type">const</span> value_type&amp; v);</span><br><span class="line">    link_type __copy(link_type x,link_type p);</span><br><span class="line">    <span class="type">void</span> __erase(link_type x);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">            __erase(<span class="built_in">root</span>());</span><br><span class="line">            <span class="built_in">left_most</span>() = header;</span><br><span class="line">            <span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">right_most</span>() = header;</span><br><span class="line">            node_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        header = <span class="built_in">get_node</span>(); <span class="comment">//产生一个节点空间 令header指向它</span></span><br><span class="line">        <span class="built_in">color</span>(header) = __rb_tree_red;<span class="comment">//令header为红色 用于区分header和root,在iterator的operator++中</span></span><br><span class="line">        <span class="built_in">root</span>() == <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">left_most</span>() = header;   <span class="comment">//令header的左子节点等于自己</span></span><br><span class="line">        <span class="built_in">right_most</span>() = header;  <span class="comment">//令header的右子节点等于自己</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//allocation / deallocation</span></span><br><span class="line">    <span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">            : <span class="built_in">node_count</span>(<span class="number">0</span>),<span class="built_in">key_compare</span>(comp)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">rb_tree</span>()&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">put_node</span>(header);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp;<span class="keyword">operator</span>==(<span class="type">const</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp;x);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> key_compare;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">left_most</span>();&#125; <span class="comment">//RB树的起头为最左(最小)节点处</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> header;&#125; <span class="comment">//RB树的终点为header所指处</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> node_count == <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> node_count;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span> (<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//insert/erase</span></span><br><span class="line">    <span class="comment">//将x插入到RB-Tree中 (保持节点的独一无二)</span></span><br><span class="line">    <span class="function">std::pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//将x插入到RB-Tree中 (允许节点数值重复)</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//寻找键值为k的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> value_type&amp; k)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------rb_tree类主要函数的实现--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新的数值 节点键值允许重复</span></span><br><span class="line"><span class="comment">//注意：返回的是一个RB-Tree的迭代器，指向的是新增的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//根节点开始</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;        <span class="comment">//根节点开始 从上往下寻找适当的插入节点</span></span><br><span class="line">        y = x;</span><br><span class="line">        <span class="comment">//如果当前根节点比 输入的v大，则转向左边，否则转向右边</span></span><br><span class="line">        x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x为新值插入点 y为插入点的父节点 v为新值</span></span><br><span class="line">    <span class="keyword">return</span> __insert(x,y,v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入新的数值 节点键值不允许重复</span></span><br><span class="line"><span class="comment">//注意：返回结果是pair类型，第一个元素是一个RB-Tree的迭代器，指向的是新增的节点；第二个参数表示插入成功与否</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">std::pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator,<span class="type">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//从根节点开始</span></span><br><span class="line">    <span class="type">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123; <span class="comment">//从根节点开始 往下寻找适当的插入点</span></span><br><span class="line">        y = x;</span><br><span class="line">        comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)); <span class="comment">//v键值小于目前节点的键值</span></span><br><span class="line">        x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x); <span class="comment">//遇&quot;大&quot;则向左 遇&quot;小&quot;则向右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离开while循环之后 y所指的即 插入点之父节点（此时它必为叶子结点）</span></span><br><span class="line">    iterator j = <span class="built_in">iterator</span>(y); <span class="comment">//迭代器j指向插入点的父节点y</span></span><br><span class="line">    <span class="keyword">if</span> (comp)&#123;</span><br><span class="line">        <span class="comment">//如果while循环时候，判定comp的数值，如果comp为真(表示遇到大的元素，将插入左侧)</span></span><br><span class="line">        <span class="comment">//如果插入节点的父节点是最左侧的节点</span></span><br><span class="line">        <span class="comment">//x为插入点，y为插入节点的父节点，v表示新值</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">begin</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(__insert(x,y,v), <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//插入节点的父节点不是最左侧的节点</span></span><br><span class="line">            <span class="comment">//调整j 回头准备测试</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node),<span class="built_in">KeyOfValue</span>()(v)))&#123;</span><br><span class="line">            <span class="comment">//小于新值（表示遇到小的数值，将插在右侧）</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(__insert(x,y,v), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此 表示新值一定和树中的键值重复 就不应该插入新的数值</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//真正的插入执行程序 __insert()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::__insert(base_ptr x_, base_ptr y_, <span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    <span class="comment">//参数x_为新的插入点 参数y_为插入点的父节点 参数v为新值</span></span><br><span class="line">    link_type x = (link_type)x_;</span><br><span class="line">    link_type y = (link_type)y_;</span><br><span class="line">    link_type z ;</span><br><span class="line">    <span class="comment">//key_compare 是键值大小的比较准则，应该是一个function object</span></span><br><span class="line">    <span class="keyword">if</span> (y == header||x != <span class="number">0</span>||<span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v),<span class="built_in">key</span>(x)))&#123;</span><br><span class="line">        z = <span class="built_in">create_node</span>(v); <span class="comment">//产生一个新的节点</span></span><br><span class="line">        <span class="comment">//当y即为header的时候，leftmost = z;</span></span><br><span class="line">        <span class="keyword">if</span> (y == header)&#123;</span><br><span class="line">            <span class="built_in">root</span>() = z;</span><br><span class="line">            <span class="built_in">right_most</span>() = z;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">left_most</span>())&#123;</span><br><span class="line">            <span class="comment">//y为最左节点</span></span><br><span class="line">            <span class="comment">//维护leftmost() 使其永远指向最左节点</span></span><br><span class="line">            <span class="built_in">left_most</span>() = z;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            z = <span class="built_in">create_node</span>(v);<span class="comment">//产生一个新的节点</span></span><br><span class="line">            <span class="comment">//让新节成为插入点的父节点y的右子节点</span></span><br><span class="line">            <span class="built_in">right</span>(y) = z;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="built_in">right_most</span>())&#123; <span class="comment">//维护rightmost()让其永远指向最右的节点</span></span><br><span class="line">                <span class="built_in">right_most</span>() = z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">parent</span>(z) = y; <span class="comment">//设定新节点的父节点</span></span><br><span class="line">        <span class="built_in">left</span>(z) = <span class="number">0</span>; <span class="comment">//设定新节点的左子节点</span></span><br><span class="line">        <span class="built_in">right</span>(z) = <span class="number">0</span>; <span class="comment">//设定新节点的右子节点</span></span><br><span class="line">        <span class="comment">//修改颜色</span></span><br><span class="line">        <span class="comment">//参数一为新增节点 ；参数二 为root</span></span><br><span class="line">        __rb_tree_rebalance(z,header-&gt;parent);</span><br><span class="line">        ++node_count;</span><br><span class="line">        <span class="comment">//返回一个迭代器 指向新的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必须为红色，如果插入出父节点同样为红色，就需要进行树形旋转</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_rotate_left(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    <span class="comment">//x为旋转点</span></span><br><span class="line">    __rb_tree_node_base* y = x-&gt;right;<span class="comment">//令y为旋转点的右子节点</span></span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//回马枪设定父亲节点</span></span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="comment">//令y完全替代x的地位 (需要将x对其父节点的关系完全接收回来)</span></span><br><span class="line">    <span class="keyword">if</span> (x == root)&#123;</span><br><span class="line">        root = y; <span class="comment">//x为根节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;  <span class="comment">//x为其父节点的左子节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y; <span class="comment">//x为其父节点的右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必须为红色，如果插入出父节点同样为红色，就需要进行树形旋转</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_rotate_right(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    <span class="comment">//x为旋转点</span></span><br><span class="line">    __rb_tree_node_base* y = x-&gt;left; <span class="comment">//y为旋转点的左子节点</span></span><br><span class="line">    x-&gt;left = y-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;right != <span class="number">0</span>)&#123;</span><br><span class="line">        y-&gt;right-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="comment">//令y完全替代x的地位</span></span><br><span class="line">    <span class="keyword">if</span>(x == root)&#123;</span><br><span class="line">        root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//调整RB_tree 插入节点之后，需要进行调整(颜色/翻转)从而满足要求</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_balance(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    x-&gt;color = __rb_tree_red; <span class="comment">//新节点的颜色必须是红色的</span></span><br><span class="line">    <span class="keyword">while</span>(x!=root &amp;&amp; x-&gt;parent-&gt;color == __rb_tree_red)&#123;</span><br><span class="line">        <span class="comment">//父节点为红色的</span></span><br><span class="line">        <span class="comment">//父节点为祖父节点的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left)&#123;</span><br><span class="line">            <span class="comment">//令y为伯父节点</span></span><br><span class="line">            __rb_tree_node_base* y = x-&gt;parent-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)&#123; <span class="comment">//伯父节点存在 且为红</span></span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//更改父节点的颜色为黑</span></span><br><span class="line">                y-&gt;color = __rb_tree_black;<span class="comment">//更改父节点的颜色为黑</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//更改祖父节点的颜色为红</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无伯父节点 或者伯父节点的颜色为黑</span></span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)&#123;</span><br><span class="line">                    <span class="comment">//新节点为父节点的右子节点</span></span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    <span class="comment">//第一次参数为左旋节点</span></span><br><span class="line">                    __rb_tree_rotate_left(x,root);</span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                <span class="comment">//第一次参数为右旋节点</span></span><br><span class="line">                __rb_tree_rotate_right(x-&gt;parent-&gt;parent,root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//父节点为祖父节点的右子节点</span></span><br><span class="line">            __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left; <span class="comment">//令y为伯父节点</span></span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)&#123; <span class="comment">//存在伯父节点，且为红</span></span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//更改父节点为黑</span></span><br><span class="line">                y-&gt;color = __rb_tree_black;<span class="comment">//更改伯父节点为黑</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; <span class="comment">//更改祖父节点为红</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent; <span class="comment">//准备继续往上层检查</span></span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无伯父节点 或者伯父节点 为黑</span></span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">                    <span class="comment">//新节点 为 父节点的左子节点</span></span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    __rb_tree_rotate_right(x,root); <span class="comment">//第一参数为右旋转点</span></span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                <span class="comment">//第一参数为左旋点</span></span><br><span class="line">                __rb_tree_rotate_left(x-&gt;parent-&gt;parent,root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//while结束</span></span><br><span class="line">    root-&gt;color = __rb_tree_black;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//元素查找程序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">find</span>(<span class="type">const</span> value_type &amp;k) &#123;</span><br><span class="line">    link_type y = header; <span class="comment">//last node which is  not less than k</span></span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//current node</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//key_compare 是节点大小的比较准则 function object</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x),k))&#123;</span><br><span class="line">            <span class="comment">//进行到这里 表示x的数值大于k 。遇到大的数值向左走</span></span><br><span class="line">            y = x,x = <span class="built_in">left</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator j = <span class="built_in">iterator</span> (y);</span><br><span class="line">    <span class="keyword">return</span> (j == <span class="built_in">end</span>() || <span class="built_in">key_compare</span>(k,<span class="built_in">key</span>(j.node))) ? <span class="built_in">end</span>() : j;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/************************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//注意：以下的identify定义于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">identify</span> : <span class="keyword">public</span> std::unary_function&lt;T,T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="set">5.2 set</h5>
<ul>
<li><code>set</code>的特性是 所有的元素会按照键值自动排序</li>
<li><code>set</code>的键值等同于实值</li>
<li><strong><code>set</code>不允许涵盖两个相同的键值</strong></li>
<li><strong>不可以通过迭代器修改<code>set</code>的元素数值，这会破坏元素的排列顺序。因此<code>set&lt;T&gt;::iterator</code>被定义为底层<code>RB-tree</code>的<code>const_iterator</code>,杜绝写入。也就是<code>set</code>的<code>iterators</code>是一种<code>const iterators</code></strong></li>
<li><code>set</code>类似<code>list</code>，当客户端对其进行元素的新增或者删除操作的时候，<strong>操作之前的迭代器不会失效，但是被操作的迭代器会失效</strong></li>
<li>STL提供了一组<code>set/multiset</code>的相关算法，包括交集<code>set_intersection</code><code>set_union</code><code>set_difference</code><code>set_symmetric_difference</code></li>
<li><code>set</code>利用<code>RB-tree</code>的排序机制，因此是基于红黑树进一步的函数封装</li>
</ul>
<h6 id="set源码">5.2.1 set源码</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> set&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">    <span class="comment">//注意key_compare 和 value_compre 使用同一个比较函数</span></span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,identify&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">    rep_type t; <span class="comment">//使用红黑树(RB-Tree)实现set</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">    <span class="comment">//set迭代器无法执行写入操作，因为set的元素有一定的次序安排，不允许用户在任意处进行写入操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_uterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    <span class="comment">//allocation/deallocation</span></span><br><span class="line">    <span class="comment">//set使用RB-Tree的insert_unique() 要求插入的元素都不可以重复</span></span><br><span class="line">    <span class="comment">//multiset 使用 insert_equal() 允许相同键值的存在</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">set</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(InputIterator first,InputIterator last)</span> : t(Compare())&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">set</span>(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x):<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">    set&lt;Key,Compare,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">        t = x.t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//set进行函数的包装</span></span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="comment">//需要注意 set使用的value_comp 事实上为RB-Tree的key_comp()</span></span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(set&lt;Key,Compare,Alloc&gt;&amp; x)</span></span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//insert / erase</span></span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;iterator,<span class="type">bool</span>&gt;pair_iterator_bool;</span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">        std::pair&lt;<span class="keyword">typename</span> rep_type::iterator,<span class="type">bool</span>&gt; p = t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(p.first,p.second);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position,<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>((rep_iterator&amp;)position,x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first,InputIterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        t.<span class="built_in">erase</span>((rep_iterator&amp;)position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        t.<span class="built_in">erase</span>((rep_iterator&amp;)first,(rep_iterator&amp;)last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set operations</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">count</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    std::pair&lt;iterator,iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下的__STL_NULL_TMPL_ARGS 被定义为&lt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;,<span class="type">const</span> set&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;,<span class="type">const</span> set&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="map">5.3 map</h5>
<ul>
<li>所有元素会根据元素的键值自动被排序</li>
<li>元素的类型是<code>pair</code>，同时拥有键值和实值；<code>map</code>不允许两个元素出现相同的键值</li>
<li>不可以修改<code>map</code>的键值 但是可以修改实值</li>
<li><code>map</code>基于红黑树实现对应的函数</li>
<li><code>map</code>和<code>set</code>一样，操作和删除操作时，操作之前的迭代器在操作之后依然有效</li>
</ul>
<h6 id="pair类型的定义">5.3.1 pair类型的定义</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    T1 first;    <span class="comment">//public</span></span><br><span class="line">    T2 second;  <span class="comment">//public</span></span><br><span class="line">    <span class="built_in">pair</span>():<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a,<span class="type">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="map源码">5.3.2 map源码</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> map&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;<span class="comment">//键值型别</span></span><br><span class="line">    <span class="keyword">typedef</span> T data_type;<span class="comment">//数据(实值)型别</span></span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;<span class="type">const</span> Key,T&gt;value_type; <span class="comment">//元素型别(键值/实值)</span></span><br><span class="line">    <span class="comment">//键值比较函数</span></span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="comment">//以下定义一个functor 其作用就是调用&quot;元素比较函数&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">value_compare</span> : <span class="keyword">public</span> std::binary_function&lt;value_type,value_type,<span class="type">bool</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>&lt;Key,T,Compare,Alloc&gt;;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Compare comp;</span><br><span class="line">        <span class="built_in">value_compare</span>(Compare c):<span class="built_in">comp</span>(c)&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> value_type&amp; x,<span class="type">const</span> value_type&amp; y)</span><span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">comp</span>(x.first,y.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//定义表述型别 使用map元素的型别(pair)作为第一性别，作为红黑树节点的键值型别</span></span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,_Select1st&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">    rep_type t; <span class="comment">//使用红黑树(RB-Tree)实现map</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">    <span class="comment">//map迭代器无法执行写入操作，因为map的元素有一定的次序安排，不允许用户在任意处进行写入操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reverse_iterator reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    <span class="comment">//allocation/deallocation</span></span><br><span class="line">    <span class="comment">//map使用RB-Tree的insert_unique() 要求插入的元素都不可以重复</span></span><br><span class="line">    <span class="comment">//multimap 使用 insert_equal() 允许相同键值的存在</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">map</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">map</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">map</span><span class="params">(InputIterator first,InputIterator last)</span> : t(Compare())&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">map</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">map</span>(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x):<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">    map&lt;Key,Compare,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">        t = x.t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//map进行函数的包装</span></span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="comment">//需要注意 map使用的value_comp 事实上为RB-Tree的key_comp()</span></span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">value_compare</span>(t.<span class="built_in">key_comp</span>());&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span>  </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">    <span class="comment">//注意以下 下标操作符号</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k)&#123;</span><br><span class="line">        <span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k,<span class="built_in">T</span>()))).first)).second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(map&lt;Key,Compare,Alloc&gt;&amp; x)</span></span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//insert / erase</span></span><br><span class="line"><span class="comment">//    typedef std::pair&lt;iterator,bool&gt;pair_iterator_bool;</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position,<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(position,x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first,InputIterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map operations</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">count</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    std::pair&lt;iterator,iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;const_iterator,const_iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//以下的__STL_NULL_TMPL_ARGS 被定义为&lt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> map&amp;,<span class="type">const</span> map&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> map&amp;,<span class="type">const</span> map&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="multisetmap">5.3.3 multiset/map</h6>
<p><code>muiltiset\multimap</code>和它们对应的<code>set\map</code>特性完全相同，唯一不同点时<code>multi</code>允许键值重复，因此插入采用的时<code>RB-tree</code>的底层函数的<code>insert_equal()</code>而不是<code>insert_unique()</code>。</p>
<h5 id="hashtable">5.4 hashtable</h5>
<p>上面介绍的是以<code>RB-tree</code>为底层机制的容器，其在有序性和查找的性能(<code>logn</code>)上都不错。但还有一种在查找上的时间复杂度可在常数内完成的结构，那就是哈希表即：</p>
<ul>
<li>二叉搜索树具有对数平均时间的表现，<strong>但是这个需要满足的假设前提是输入的数据需要具备随机性</strong></li>
<li><code>hashtable</code>散列表这种结构在插入、删除、搜寻等操作层面上也具有常数平均时间的表现。<strong>而且不需要依赖元素的随机性，这种表现是以统计为基础的</strong></li>
</ul>
<p><strong>哈希表的特点：</strong></p>
<ul>
<li><code>hashtable</code>可提供对任何有名项的存取和删除操作</li>
<li>因为操作的对象是有名项，因此<code>hashtable</code>可以作为一种字典结构</li>
<li><strong>将一个元素映射成为一个 “大小可以接受的索引”简称为<code>hash function</code>散列函数</strong></li>
<li>考虑到元素的个数大于<code>array</code>的容量，<strong>可能有不同的元素被映射到相同的位置，简称为冲突</strong></li>
<li>解决冲突的方法有很多，线性探测、二次探测、<strong>开链</strong></li>
</ul>
<p>具体的hash思想可见<a href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构篇</a>，在<code>SGI STL</code>版本的<code>hash_table</code>使用的是<strong>开链法</strong>来解决哈希冲突,节点结构体如下： <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/hashtablelist.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_node</span>&#123;</span><br><span class="line">    __hashtable_node* next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="hashtable的迭代器">5.4.1 hashtable的迭代器</h6>
<ul>
<li><code>hashable</code>迭代器维持着与整个<code>buckets vector</code>的关系，并记录目前所指的节点</li>
<li>前进操作是从目前节点出发前进一个位置，由于节点被安置于<code>list</code>内，使用<code>next</code>进行前进操作</li>
<li><strong>如果目前是<code>list</code>的尾端，则跳转至下一个<code>bucket</code>上，正是指向下一个<code>list</code>的头部</strong></li>
<li><strong><code>hashtable</code>的迭代器没有后退操作，<code>hashtable</code>没有定义所谓的逆向迭代器</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">ExtractKey</span>,<span class="keyword">class</span> <span class="title class_">EqualKey</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_iterator</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;hashtable;</span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_iterator&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;iterator;</span><br><span class="line"><span class="comment">//    typedef __hash_const   静态迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt;node;</span><br><span class="line">    <span class="keyword">typedef</span> std::forward_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> Value* pointer;</span><br><span class="line"></span><br><span class="line">    node* cur;<span class="comment">// 迭代器目前所指的节点</span></span><br><span class="line">    hashtable* ht;<span class="comment">//保持对容器的连接关系 (因为可能需要从bucket跳到bucket)</span></span><br><span class="line">    __hashtable_iterator(node*n,hashtable* tab):<span class="built_in">cur</span>(n),<span class="built_in">ht</span>(tab)&#123;&#125;</span><br><span class="line">    __hashtable_iterator()&#123;&#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> cur-&gt;val;&#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line">    iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; it)<span class="type">const</span> &#123;<span class="keyword">return</span> cur == it.cur;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; it)<span class="type">const</span> &#123;<span class="keyword">return</span> cur != it.cur;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">HF</span>,<span class="keyword">class</span> <span class="title class_">ExK</span>,<span class="keyword">class</span> <span class="title class_">EqK</span>,<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;&amp;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="type">const</span> node* old = cur;</span><br><span class="line">    cur = cur-&gt;next; <span class="comment">//如果存在 就是他，否则进入以下的if流程</span></span><br><span class="line">    <span class="keyword">if</span> (!cur)&#123;</span><br><span class="line">        <span class="comment">//根据元素的数值，定位出下一个bucket，其起头处就是我们的目的地</span></span><br><span class="line">        size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cur = ht-&gt;buckets[bucket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">HF</span>,<span class="keyword">class</span> <span class="title class_">ExK</span>,<span class="keyword">class</span> <span class="title class_">EqK</span>,<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++<span class="keyword">this</span>; <span class="comment">//调用operator++</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="hashtable的数据结构">5.4.2 hashtable的数据结构</h6>
<ul>
<li><code>buckets</code>聚合体以<code>vector</code>完成，以利动态扩充</li>
<li><strong><code>&lt;stl_hash_fun.h&gt;</code>定义数个现成的<code>hash functions</code>全都是仿函数，<code>hash function</code>计算单元的位置，也就是元素对应的<code>bucket</code>的位置。具体调用的函数是<code>bkt_num()</code>,它调用<code>hash function</code>取得一个可以执行<code>modulus</code>(取模)运算的数值</strong>，以上的目的是出于 有些元素的型别是无法直接对其进行取模运算的，比如字符串类型 。</li>
<li>按照质数设计<code>vector</code>的大小，事先准备好<code>28</code>个质数，并设计一个函数用于查询最接近某数并大于某数的质数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Key:         节点的实值类型</span></span><br><span class="line"><span class="comment"> * Value:       节点的键值类型</span></span><br><span class="line"><span class="comment"> * HashFun:     hash function的函数型别</span></span><br><span class="line"><span class="comment"> * ExtractKey:  从节点中提取键值的方法 (函数或者仿函数)</span></span><br><span class="line"><span class="comment"> * EqualKey:    判断键值是否相同 (函数或者仿函数)</span></span><br><span class="line"><span class="comment"> * Alloc:       空间配置器 缺省使用 std::alloc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">ExtractKey</span>,<span class="keyword">class</span> <span class="title class_">EqualKey</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> HashFcn hasher;    <span class="comment">//为template型别参数重新定义一个名称</span></span><br><span class="line">    <span class="keyword">typedef</span> EqualKey key_equal;<span class="comment">//为template型别参数重新定义一个名称</span></span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//以下三者都是function objects</span></span><br><span class="line">    <span class="comment">//&lt;stl_hash_fun.h&gt; 定义有数个标准型别(如 int、c-style、string等)的hasher</span></span><br><span class="line">    hasher hash;        <span class="comment">//散列函数</span></span><br><span class="line">    key_equal equals;   <span class="comment">//判断键值是否相等</span></span><br><span class="line">    ExtractKey get_key; <span class="comment">//从节点取出键值</span></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt;node;</span><br><span class="line">    <span class="comment">//专属的节点配置器</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;node,Alloc&gt;node_allocator;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点的配置函数</span></span><br><span class="line">    <span class="function">node* <span class="title">new_node</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        node* n = node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">        n-&gt;next = <span class="number">0</span>;</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            Chy::allocator&lt;Key&gt;::<span class="built_in">construct</span>(&amp;n-&gt;val,obj);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(node_allocator::<span class="built_in">deallocate</span>(n);)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点释放函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delete_node</span><span class="params">(node* n)</span></span>&#123;</span><br><span class="line">        Chy::allocator&lt;Key&gt;::<span class="built_in">destroy</span>(n-&gt;val);</span><br><span class="line">        node_allocator::<span class="built_in">deallocate</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;node*,Alloc&gt;buckets;<span class="comment">//以vector完成桶的集合，其实值是一个node*</span></span><br><span class="line">    size_type num_elements;  <span class="comment">//node的个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bucket个数 即buckets vector的大小</span></span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buckets.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//注意假设 假设long至少有32bit</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">53</span>,         <span class="number">97</span>,         <span class="number">193</span>,       <span class="number">389</span>,       <span class="number">769</span>,</span><br><span class="line">        <span class="number">1543</span>,       <span class="number">3079</span>,       <span class="number">6151</span>,      <span class="number">12289</span>,     <span class="number">24593</span>,</span><br><span class="line">        <span class="number">49157</span>,      <span class="number">98317</span>,      <span class="number">196613</span>,    <span class="number">393241</span>,    <span class="number">786433</span>,</span><br><span class="line">        <span class="number">1572869</span>,    <span class="number">3145739</span>,    <span class="number">6291469</span>,   <span class="number">12582917</span>,  <span class="number">25165843</span>,</span><br><span class="line">        <span class="number">50331653</span>,   <span class="number">100663319</span>,  <span class="number">201326611</span>, <span class="number">402653189</span>, <span class="number">805306457</span>,</span><br><span class="line">        <span class="number">1610612741</span>, <span class="number">3221225473</span>, <span class="number">4294967291</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//找出上述28指数中，最接近并大于n的那个质数</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_next_prime(<span class="type">unsigned</span> <span class="type">long</span> n)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *first = __stl_prime_list;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *pos = std::<span class="built_in">lower_bound</span>(first,last,n);</span><br><span class="line">        <span class="comment">//使用lower_bound() 需要先进行排序</span></span><br><span class="line">        <span class="keyword">return</span> pos == last ? *(last<span class="number">-1</span>) : *pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//总共有多少个buckets。以下是hash_table的一个member function</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">//其数值将为 4294967291</span></span><br><span class="line">        <span class="keyword">return</span> __stl_prime_list[__stl_num_primes - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">hashtable</span>(size_type n,<span class="type">const</span> HashFcn&amp; hf,<span class="type">const</span> EqualKey&amp; eql)</span><br><span class="line">    :<span class="built_in">hash</span>(hf),<span class="built_in">equals</span>(eql),<span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()),<span class="built_in">num_elements</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//例子：传入50 返回53</span></span><br><span class="line">        <span class="comment">//然后保留53个元素的空间 然后将其全部填充为0</span></span><br><span class="line">        <span class="type">const</span> size_type n_buckets = <span class="built_in">next_size</span>(n);</span><br><span class="line">        buckets.<span class="built_in">reserve</span>(n_buckets);</span><br><span class="line">        <span class="comment">//设定所有的buckets的初值为0(node*)</span></span><br><span class="line">        buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">begin</span>(),n_buckets,(node*)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//------------------------------bkt_num函数---------------------------</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//版本1：接受实值（value）和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj), n); <span class="comment">//调用版本4</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本2：只接受实值（value）</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj)); <span class="comment">//调用版本3</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本3，只接受键值</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(key, buckets.<span class="built_in">size</span>()); <span class="comment">//调用版本4</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本4：接受键值和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % n; <span class="comment">//SGI的所有内建的hash()，在后面的hash functions中介绍</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//相关对应的函数</span></span><br><span class="line">    <span class="comment">//next_size()返回最接近n并大于n的质数</span></span><br><span class="line">    <span class="function">size_type <span class="title">next_size</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __stl_next_prime(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;iterator;</span><br><span class="line">    <span class="comment">//插入操作和表格重整</span></span><br><span class="line">    <span class="comment">//插入元素不允许重复</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type&amp; obj)&#123;</span><br><span class="line">        <span class="comment">//判断是否需要重建表格  如果需要就进行扩充</span></span><br><span class="line">        <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//函数判断是否需要重建表格 如果不需要立刻返回，如果需要 就重建表格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type num_elements_hint)</span></span>&#123;</span><br><span class="line">        <span class="comment">//表格重建与否的原则是：元素的个数(新增元素计入之后)和先前分配的bucket vector进行比较</span></span><br><span class="line">        <span class="comment">//如果前者的大于后者 就需要表格的重建</span></span><br><span class="line">        <span class="comment">//因此 bucket(list)的最大容量和buckets vector的大小相同</span></span><br><span class="line">        <span class="type">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (old_n &lt; num_elements_hint)&#123;</span><br><span class="line">            <span class="comment">//需要重新分配内存</span></span><br><span class="line">            <span class="comment">//计算下一个质数</span></span><br><span class="line">            <span class="type">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; old_n)&#123;</span><br><span class="line">                std::vector&lt;node*,Alloc&gt;<span class="built_in">tmp</span>(n,(node*)<span class="number">0</span>);</span><br><span class="line">                __STL_TRY&#123;</span><br><span class="line">                    <span class="comment">//处理每一个旧的bucket</span></span><br><span class="line">                    <span class="keyword">for</span> (size_type bucket=<span class="number">0</span>;bucket&lt;old_n;bucket++) &#123;</span><br><span class="line">                        <span class="comment">//指向节点所对应的的串行的起始节点</span></span><br><span class="line">                        node* first = buckets[bucket];</span><br><span class="line">                        <span class="comment">//处理每一个旧的bucket所含(串行)的每一个节点</span></span><br><span class="line">                        <span class="keyword">while</span>(first)&#123;</span><br><span class="line">                            <span class="comment">//串行节点还未结束</span></span><br><span class="line">                            <span class="comment">//找出节点落在哪一个新的bucket内部</span></span><br><span class="line">                            size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val,n);</span><br><span class="line">                            <span class="comment">//以下四个操作颇为巧妙</span></span><br><span class="line">                            <span class="comment">//(1)令旧bucket指向其所对应的串行的下一个节点(以便迭代处理)</span></span><br><span class="line">                            buckets[bucket] = first-&gt;next;</span><br><span class="line">                            <span class="comment">//(2)(3)将当前节点插入到新的bucket内部，成为其对应串行的第一个节点</span></span><br><span class="line">                            first-&gt;next = tmp[new_bucket];</span><br><span class="line">                            tmp[new_bucket] = first;</span><br><span class="line">                            <span class="comment">//(4)回到旧的bucket所指向的待处理的串行，准备处理下一个节点</span></span><br><span class="line">                            first = buckets[bucket];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//对调新旧两个buckets</span></span><br><span class="line">                    <span class="comment">//离开的时候会释放tmp的内存</span></span><br><span class="line">                    buckets.<span class="built_in">swap</span>(tmp);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要重建表格的情况下插入新的节点 键值不允许重复</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert_unique_noresize</span>(<span class="type">const</span> value_type&amp; obj)&#123;</span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj) ;<span class="comment">//决定obj应该位于 第n n bucket</span></span><br><span class="line">        node* first = buckets[n]; <span class="comment">//令first指向bucket对应的串行头部</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果Buckets[n]已经被占用 此时first不再是0 于是进入以下循环</span></span><br><span class="line">        <span class="comment">//走过bucket所对应的整个链表</span></span><br><span class="line">        <span class="keyword">for</span> (node* cur = first;cur;cur = cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val)),<span class="built_in">get_key</span>(obj))&#123;</span><br><span class="line">                <span class="comment">//如果发现和链表中的某个键值是相同的 就不插入 立刻返回</span></span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//离开上述循环(或者根本没有进入循环的时候)first指向bucket的所指链表的头部节点</span></span><br><span class="line">            node* tmp = <span class="built_in">new_node</span>(obj); <span class="comment">//产生新的节点</span></span><br><span class="line">            tmp-&gt;next = first;</span><br><span class="line">            buckets[n] = tmp; <span class="comment">//令新的节点成为链表的第一个节点</span></span><br><span class="line">            ++num_elements;   <span class="comment">//节点的个数累加</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(tmp,<span class="keyword">this</span>),<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//客户端执行的是另外一种节点的插入行为(不再是insert_unique 而是insert_equal)</span></span><br><span class="line">    <span class="comment">//插入元素 允许重复</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否需要重建表格 如果需要就进行扩充</span></span><br><span class="line">        <span class="built_in">resize</span>(num_elements+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要重建表格的情况下 插入新的节点，键值是允许重复的</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj); <span class="comment">//决定obj应该位于第 n bucket</span></span><br><span class="line">        node* first = buckets[n];<span class="comment">//令first指向的bucket对应的链表的头部</span></span><br><span class="line">        <span class="comment">//如果bucket[n]已经被占用，此时的first不为0，进入循环</span></span><br><span class="line">        <span class="comment">//遍历整个链表</span></span><br><span class="line">        <span class="keyword">for</span>(node* cur = first;cur;cur = cur-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val),<span class="built_in">get_key</span>(obj)))&#123;</span><br><span class="line">                <span class="comment">//如果发现与链表中的某个键值相同，就马上插入，然后返回</span></span><br><span class="line">                node* tmp = <span class="built_in">new_node</span>(obj);  <span class="comment">//产生新的节点</span></span><br><span class="line">                tmp-&gt;next = cur-&gt;next;<span class="comment">//新节点插入目前的位置</span></span><br><span class="line">                cur-&gt;next = tmp;</span><br><span class="line">                ++num_elements;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">iterator</span> (tmp, <span class="keyword">this</span>); <span class="comment">//返回一个迭代器 指向新增的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行到这个时候 表示没有发现重复的数值</span></span><br><span class="line">            node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">            tmp-&gt;next = first;</span><br><span class="line">            buckets[n] = tmp;</span><br><span class="line">            ++num_elements;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//针对每一个bucket</span></span><br><span class="line">        <span class="keyword">for</span>(size_type i = <span class="number">0</span>;i &lt; buckets.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            node * cur = buckets[i];</span><br><span class="line">            <span class="comment">//删除bucket list中的每一个节点</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="number">0</span>)&#123;</span><br><span class="line">                node* next = cur-&gt;next;</span><br><span class="line">                <span class="built_in">delete_node</span>(cur);</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            buckets[i] = <span class="number">0</span>; <span class="comment">//令buckets内容为null</span></span><br><span class="line">        &#125;</span><br><span class="line">        num_elements = <span class="number">0</span>; <span class="comment">//令总的节点的个数为0</span></span><br><span class="line">        <span class="comment">//需要注意 buckets vector并没有释放空间，仍然保存先前的大小</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy_from</span><span class="params">(<span class="type">const</span> hashtable&amp; ht)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先清除己方的buckets vector，此操作是调用vector::clear() 造成所有的元素都为0</span></span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">//为己方的buckets vector保留空间，使与对方相同</span></span><br><span class="line">        <span class="comment">//如果己方的空间大于对方 就不需要改变；如果己方的空间小于对方 就会增大</span></span><br><span class="line">        buckets.<span class="built_in">reserve</span>(ht.buckets.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//从己方的buckets vector尾端开始，插入n个元素，其数值为 null 指针</span></span><br><span class="line">        <span class="comment">//注意此时buckets vector为空，所谓的尾端就是起头处</span></span><br><span class="line">        buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(),ht.buckets.<span class="built_in">size</span>(),(node*)<span class="number">0</span>);</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            <span class="comment">//针对buckets vector</span></span><br><span class="line">            <span class="keyword">for</span> (size_type i = <span class="number">0</span>;i&lt;ht.buckets.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">                <span class="comment">//复制vector的每一个元素(是一个指针，指向hashtable节点)</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="type">const</span> node* cur = ht.buckets[i])&#123;</span><br><span class="line">                    node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">                    buckets[i] = copy;</span><br><span class="line">                    <span class="comment">//针对同一个 buckets list 复制每一个节点</span></span><br><span class="line">                    <span class="keyword">for</span> (node* next = cur-&gt;next;next ; cur = next,next = cur-&gt;next) &#123;</span><br><span class="line">                        copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">                        copy = copy-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新登录的节点的个数(hashtable的大小)</span></span><br><span class="line">            num_elements = ht.num_elements;</span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>STL中哈希表一般不要外部使用，它是实现<code>hash_map</code>和<code>hash_set</code>的底层机制，编程者可以使用它们。</p>
<h5 id="hash_set">5.5 hash_set</h5>
<p>同set一样，单独以键存储。<code>hash_set</code>是以<code>hashtable</code>为底层机制，因此存储数无序的，而<code>set</code>有序。同时其所供应的接口大部分都是转调用<code>hashtable</code>的函数。<code>hash_set</code>的使用方式与<code>set</code>差不多一样.</p>
<h6 id="hash_set源码">5.5.1 hash_set源码</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_INTERNAL_HASH_SET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SGI_STL_INTERNAL_HASH_SET_H</span></span><br><span class="line"></span><br><span class="line">__STL_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> set woff 1174</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Value&gt;,</span><br><span class="line">          <span class="keyword">class</span> EqualKey = equal_to&lt;Value&gt;,</span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> EqualKey, <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> hash_set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;Value, Value, HashFcn, identity&lt;Value&gt;, </span><br><span class="line">                    EqualKey, Alloc&gt; ht;</span><br><span class="line">  ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equal key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hash_set</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hash_set</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equal()) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_set&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_set&amp;,</span><br><span class="line">                                               <span class="type">const</span> hash_set&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique</span>(obj);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span> </span>&#123;</span><br><span class="line">    rep.<span class="built_in">insert_unique</span>(f,l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator f, const_iterator l)</span> </span>&#123;rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="hash_map">5.6 hash_map</h5>
<p>同map一样以键值对形式存储，但其底层机制为<code>hashtable</code>，因此大部分情况支持常数时间复杂度访问，存储是无序的。使用方式与<code>map</code>相差不大</p>
<h6 id="hash_map源码">5.6.1 hash_map源码</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> set woff 1174</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> EqualKey = equal_to&lt;Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> EqualKey, </span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> hash_map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;pair&lt;<span class="type">const</span> Key, T&gt;, Key, HashFcn,</span><br><span class="line">                    select1st&lt;pair&lt;<span class="type">const</span> Key, T&gt; &gt;, EqualKey, Alloc&gt; ht;</span><br><span class="line">  ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">  <span class="keyword">typedef</span> T data_type;</span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equal key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::iterator iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hash_map</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hash_map</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equal()) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_map&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span></span><br><span class="line">  <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_map&amp;, <span class="type">const</span> hash_map&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(obj); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span> </span>&#123;</span><br><span class="line">    rep.<span class="built_in">insert_unique</span>(f,l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator f, const_iterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique_noresize</span>(obj); &#125;    </span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; key) &#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">find_or_insert</span>(<span class="built_in">value_type</span>(key, <span class="built_in">T</span>())).second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line">  <span class="function">pair&lt;const_iterator, const_iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="各个容器的适用场景">6. 各个容器的适用场景</h4>
<ul>
<li>1）<code>vector</code>的使用场景：只查看，而不频繁插入删除的，因为频繁插入删除会造成内存的不断搬家和删除。使用场景比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录。</li>
<li>2）<code>deque</code>的使用场景：比如排队购票系统，对排队者的存储可以采用<code>deque</code>，支持头端的快速移除，尾端的快速添加。如果采用<code>vector</code>，则头端移除时会移动大量的数据，速度慢。<code>vector</code>与<code>deque</code>的比较：
<ul>
<li>一：<code>vector.at()</code>比<code>deque.at()</code>效率高，比如<code>vector.at(0)</code>是固定的，<code>deque</code>的开始位置却是不固定的。</li>
<li>二：如果有大量释放操作的话，<code>vector</code>花的时间更少，这跟二者的内部实现有关。</li>
<li>三：<code>deque</code>支持头部的快速插入与快速移除，这是<code>deque</code>的优点。</li>
</ul></li>
<li><code>list</code>的使用场景：频繁的插入删除的场景，这时也可以使用queue和deque。使用场景比如公交车乘客的存储，随时可能有乘客上下车，支持频繁的不确实位置元素的移除插入删除。</li>
<li><code>set</code>的使用场景：大部分负责查找内容且要求有序的情况下。使用场景比如对游戏中个人得分历史记录的存储，存储要求从高分到低分的顺序排列。</li>
<li><code>map</code>的使用场景：对查找有较高的要求，使用场景比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。红黑树的查找效率，这时就体现出来了。</li>
</ul>
<h4 id="算法">7. 算法</h4>
<h5 id="stl算法分类">7.1 STL算法分类</h5>
<h6 id="质变和非质变">7.1.1 质变和非质变</h6>
<ul>
<li><strong>质变算法：</strong>是指运算过程中会更改区间内的元素的内容</li>
<li><strong>非质变算法：</strong>是指运算过程中不会更改区间内的元素内容</li>
</ul>
<h6 id="stl算法的一般形式">7.1.2 STL算法的一般形式</h6>
<p><strong>大多数算法有下列4中形式：</strong></p>
<ul>
<li><code>alg(first,last,other args);</code></li>
<li><code>alg(first,last,dest,other args);</code></li>
<li><code>alg(first,last,first2,other args);</code></li>
<li><code>alg(first,last,first2,lasst2,other args);</code></li>
</ul>
<p><strong>更一般的说法是：</strong></p>
<ul>
<li><strong>所有泛型算法的前两个参数一定是一对迭代器，通常为<code>first</code>和<code>last</code>,范围为<code>[first,last)</code></strong></li>
<li><strong>许多STL算法不止只支持一个版本，可接受仿函数<code>_if</code>结尾，如<code>find()</code>函数支持传入谓词或仿函数的<code>find_if()</code>版本</strong></li>
<li>质变算法通常会有至少提供两个版本，一个是就地进行改变操作对象的版本，<strong>另一个是<code>_copy</code>版本，拷贝一份副本，在副本上改变，如<code>replace()</code>函数就有<code>replace_copy()</code>版本</strong></li>
<li>所有的数值算法实现都在<code>&lt;stl_numeric.h&gt;，用户使用时可包含</code>#include<numeric>`调用</numeric></li>
<li>其他算法实现于<code>&lt;stl_algo.h&gt;\&lt;stl_algobase.h&gt;</code>，用户使用可通过包含<code>#include&lt;algorithm&gt;</code>调用</li>
</ul>
<h6 id="算法总览">7.1.3 算法总览</h6>
<table>
<thead>
<tr class="header">
<th>算法名称</th>
<th>算法用途</th>
<th style="text-align: center;">质变？</th>
<th>所在文件</th>
<th style="text-align: center;">所属作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>accumulate</code></td>
<td>元素求和</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_numeric.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="even">
<td><code>adjacent_difference</code></td>
<td>相邻元素差额</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_numeric.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td><code>adjacent_find</code></td>
<td>查找相邻重复(或符合条件)的元素</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>binary_search</code></td>
<td>二分查找</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>copy</code></td>
<td>复制</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="even">
<td><code>copy_backward</code></td>
<td>逆向复制</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="odd">
<td><code>copy_n</code></td>
<td>复制n个元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="even">
<td><code>count</code></td>
<td>计数</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>count_if</code></td>
<td>在特定传入的谓词或仿函数条件下计数</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>equal</code></td>
<td>判断两个区间相等与否</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">关系</td>
</tr>
<tr class="odd">
<td><code>equal_range</code></td>
<td>在有序区间寻找某值，返回一个区间</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">关系</td>
</tr>
<tr class="even">
<td><code>fill</code></td>
<td>该填元素值</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>fill_n</code></td>
<td>该填元素值，n次</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>find</code></td>
<td>循序查找</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>find_if</code></td>
<td>查找符合条件的元素</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>find_end</code></td>
<td>查找某个子序列的最后一次出现点</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>find_first_of</code></td>
<td>查找某些元素首次出现点</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>for_each</code></td>
<td>对区间的每一个元素施行某操作</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>generate</code></td>
<td>以特定操作的运算结果填充特定区间内的元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>inner_product</code></td>
<td>内积</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td><code>iter_swap</code></td>
<td>元素互换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td><code>lower_bound</code></td>
<td>返回有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>max</code></td>
<td>最大值</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>max_element</code></td>
<td>最大值所在位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>min</code></td>
<td>最小值</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>min_element</code></td>
<td>最小值所在位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>merge</code></td>
<td>合并两个序列</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>inplace_merge</code></td>
<td>合并且就地替换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>random_shuffle</code></td>
<td>随机重排元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>remove</code></td>
<td>删除某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="odd">
<td><code>remove_copy</code></td>
<td>删除某类元素并将结果存储都另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="even">
<td><code>remove_if</code></td>
<td>有条件的删除某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="odd">
<td><code>remove_copy_if</code></td>
<td>有条件的删除某类元素，并将结果存储到另外一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="even">
<td><code>replace</code></td>
<td>替换某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="odd">
<td><code>replace_copy</code></td>
<td>替换某类元素，并将结果存储到另一个元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="even">
<td><code>replace_if</code></td>
<td>有条件的替换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="odd">
<td><code>replace_copy_if</code></td>
<td>有条件的替换，并将结果存储都另一个容q器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="even">
<td><code>reverse</code></td>
<td>反转</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="odd">
<td><code>reverse_copy</code></td>
<td>反转并把结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="even">
<td><code>rotate</code></td>
<td>旋转</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">旋转</td>
</tr>
<tr class="odd">
<td><code>rotate_copy</code></td>
<td>旋转，并把结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;sta_algo.h&gt;</code></td>
<td style="text-align: center;">旋转</td>
</tr>
<tr class="even">
<td><code>search</code></td>
<td>查找某个子序列</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>search_n</code></td>
<td>查找连续发生n次的某个子序列</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>sort</code></td>
<td>排序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">排序</td>
</tr>
<tr class="odd">
<td><code>stable_sort</code></td>
<td>排序并保持等值元素的相对次序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">排序</td>
</tr>
<tr class="even">
<td><code>stable_partition</code></td>
<td>分割并保存元素的相对次序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">分割</td>
</tr>
<tr class="odd">
<td><code>swap</code></td>
<td>交换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td><code>swap_ranges</code></td>
<td>指定区间的交换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="odd">
<td><code>unique</code></td>
<td>去重</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">去重</td>
</tr>
<tr class="even">
<td><code>unique_copy</code></td>
<td>去重后的结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">去重</td>
</tr>
<tr class="odd">
<td><code>upper_bound</code></td>
<td>返回有序序列范围内的可以插入指定值而不破坏容器顺序的最后位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>make_heap</code></td>
<td>创建一个堆</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="odd">
<td><code>pop_heap</code></td>
<td>从堆取元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="even">
<td><code>push_heap</code></td>
<td>将元素插入堆</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="odd">
<td><code>sort_heap</code></td>
<td>堆heap排序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
</tbody>
</table>
<h5 id="sort">7.2 sort</h5>
<h6 id="适用容器">7.2.1 适用容器</h6>
<p><code>sort()</code>算法是最复杂堆庞大的一个，<strong>这个算法接受两个<code>RandomAccessIterator</code>迭代器，然后将区间内的元素由小到大重新排列</strong>。第二个版本则允许用户传入<strong>谓词或者仿函数</strong>作为排序条件，指定按什么规则排序。适用<code>sort</code>算法的容器有<code>vecror\deque</code>。</p>
<p><strong><em>附</em></strong>：因为关联容器的底层机制，根本不需要<code>sort</code>排序，<code>stack\queue\priority_queue</code>对进出的机制也要求不需排序，而<code>list</code>的迭代器为<code>BidirectinalIterator</code>不适用。</p>
<h6 id="sort实现的原理">7.2.2 sort实现的原理</h6>
<p>早期的STL <code>sort()</code>算法都是采用<strong>快排</strong>来实现，对于快排平均的时间复杂度为<code>O(NlogN)</code>,但是最坏的情况却会达到<code>O(N*N)</code>，<strong>因此现今的<code>STL SGI</code>改用<code>IntroSort</code>即内观排序算法，极其类似于<code>median-three QuickSort</code>三数取中快速排序算法。这种算法即使在最坏的情况下推进到<code>O(NlogN)</code>。</strong>快排的最坏情况的发生与快速排序中基准点的选择是有重大的关系，当出现下面两种情况时性能最差:</p>
<ul>
<li>在分解时每次选取的基准点为最小元素</li>
<li>在分解时每次选取的基准点为最大元素</li>
</ul>
<p><strong>快排的过程：</strong></p>
<ul>
<li>如果序列中的元素个数为0或1，结束</li>
<li>取序列中的任何一个元素，一般会取该段序列的头或者尾元素作为基准点<code>pivot</code></li>
<li>将序列分类<code>L\R</code>两段子序列，使L内的每一个元素都小于或等于基准点，R内的每一个元素都大于等于基准点</li>
<li>对<code>L\R</code>递归执行<code>QuickSort</code>,重复上述操作</li>
</ul>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/quickSort.gif" width="600"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写自己的quickSort,没有优化，遇到最坏情况的时间复杂度会变成O(N*N)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--;</span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="三点取中优化方案">7.2.3 三点取中优化方案</h6>
<p>为了避免快排出现上述所说的最坏情况，选择哪一个元素作为基准点是关键，<strong>在快排过程中采用三点取中间值的优化方案。三数取中<code>median-of-three</code>指的是在挑选基准元素时，不是简单的选择数组中的第一个元素或最后一个，而是选取某三个元素，常选头、尾和中央三个元素，并且适用三个元素之中的中位数作为基准元素进行划分</strong>。这样即使在最坏的情况下将时间复杂度推进到<code>O(NlogN)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化后的快排代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">medianOfThree</span>(a, first, (first + last) / <span class="number">2</span>, last);</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--; </span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cap[first] &lt; cap[mid])</span><br><span class="line">        <span class="keyword">if</span> (cap[first] &gt;= cap[last])	<span class="comment">//last=&lt;first&lt;mid</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&lt;mid&lt;last</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[mid];</span><br><span class="line">            cap[mid] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">// first&lt;last&lt;=mid</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[last];</span><br><span class="line">            cap[last] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[first] &lt; cap[last])	<span class="comment">//last&gt;first&gt;=mid</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&gt;=mid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[last];</span><br><span class="line">        cap[last] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[mid];</span><br><span class="line">        cap[mid] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数值算法">7.3 数值算法</h5>
<p>数值算法都在头文件<code>&lt;numeric&gt;</code>中，实现于<code>&lt;stl_numeric.h&gt;。 ###### 7.3.1 accumulate</code>accumulate`算法用来计算指定区间的和，需要提供额外参数指定累加到哪一个初始值 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init)</span></span>;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T，<span class="keyword">class</span> BinaryOperation &gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init,</span></span></span><br><span class="line"><span class="params"><span class="function">	BinaryOperation binary_op)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="power">7.3.2 power</h6>
<p>计算某数的n次方幂，该算法四<code>SGI</code>版本特有算法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Integer&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">power</span><span class="params">(T x,Integer n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="adjacent_difference">7.3.3 adjacent_difference</h6>
<p>算法<code>adjacent_difference</code>用来计算[first,last)中相邻元素的差额，即它会将<code>*first</code>赋值给<code>*result</code>，并针对[first,last)内的每个迭代器<code>i</code>,进行<code>*i-*(i-1)</code>，然后赋值给<code>*++result</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InpueIterator,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="基本算法">7.4 基本算法</h5>
<p>对于SGI版本,它会把常用的一些算法定义在<code>&lt;stl_algobase.h&gt;</code>,使用时包含<code>&lt;algorithm&gt;</code>即可。</p>
<h5 id="equal">7.4.1 equal</h5>
<p>如果两个序列在<code>[first,lasst)</code>区间内相等，<code>equal</code>会返回<code>true</code>。如果第二序列元素多，则剩余元素不考虑，一般调用前要先保证元素个数一样。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator1,<span class="keyword">class</span> InputIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(InpueIterator1 first1,InpueIterator1 last1,InpueIterator1 first2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="fill">7.4.2 fill</h6>
<p>将<code>[first,last)</code>内的元素该填新值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(ForwardIterator first,ForwardIterator last,<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">###### <span class="number">7.4</span><span class="number">.3</span> fill_n</span><br><span class="line">将`[first,last)`的前n个改填新值，返回的迭代器指向被填入的最后一个元素的下一个位置。</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> OutputIterator,<span class="keyword">class</span> Size,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">fill_n</span><span class="params">(OutputIterator first,Size n,<span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="iter_swap">7.4.4 iter_swap</h6>
<p>该算法将两个<code>ForwardIterator</code>所指对象对调。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1,calss ForwardIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator a,ForwardIterator2 b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="copy">7.4.5 copy</h6>
<ul>
<li><code>copy()</code>算法是最最最常用的一个算法，</li>
<li><code>copy()</code>算法将输入区间的<code>[first,last)</code>的元素复制到目标区间<code>[result,result+(last-first))</code>中，执行完后返回一个迭代器，指向<code>result+(last-first)</code>。</li>
<li><code>copy</code>函数对参数非常宽松，对输入区间只需由<code>InputIterator</code>构成即可，输出区间尾<code>OutputIterator</code>构成即可，即意味着可以将任何容器的任何一段内容复制带任何容器的任何一段上，当然这些容器要由对应的迭代器。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InpueIterator,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span></span><br></pre></td></tr></table></figure>
<h6 id="copy_backward">7.4.6 copy_backward</h6>
<p>与<code>copy</code>非常相似，只不过<code>copy_backward</code>是以逆行方向复制到<code>result</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterator1,<span class="keyword">class</span> BidirectionalIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(BidirectionalIterator1 first,</span></span></span><br><span class="line"><span class="params"><span class="function">	BidirectionalIterator1,BidirectionalIterator2 result)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="其他算法">7.5 其他算法</h5>
<p>定义与<code>&lt;stl_algo.h&gt;</code>内地算法</p>
<h6 id="adjacent_find">7.5.1 adjacent_find</h6>
<p>该算法找出第一组满足条件的相邻元素，这里所谓的条件，在版本一中是指<strong>两元素相等</strong>，在版本二中允许用户指定一个二元为谓词运算，两操作数是相邻第一个元素和第二个元素。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first,ForwardIterator last)</span></span>;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator,<span class="keyword">class</span> BinaryPredicate&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator last,BinaryPredicate binary_pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find">7.5.2 find</h6>
<p>在<code>[first,lasy)</code>找出第一个符合匹配条件的元素，返回该元素所在位置的迭代器，未找到则返回<code>last</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_if">7.5.3 find_if</h6>
<p>传入一原谓词，根据指定的条件<code>pred</code>元素条件查找，返回该元素所在位置的迭代器，未找到则返回<code>last</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> predicate&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,predicate pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_end">7.5.4 find_end</h6>
<p>在序列一的<code>[first1,last1)</code>区间中，查找序列二<code>[first2,last2)</code>最后一次出现点，如果不存在，则返回<code>last1</code>。由两个版本，版本一默认使用<code>==</code>,版本二允许用户传入二元运算谓词。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1,<span class="keyword">class</span> ForwardIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIterator</span><span class="params">(ForwardIterator1 first1,ForwardIterator1 last1</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator2 first2,ForwardIterator2 last2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_first_of">7.5.5 find_first_of</h6>
<p>本算法以<code>[first2,last2)</code>区间内的元素作为查找目标，寻找它们在<code>[first1,last1)</code>第一次出现的位置，<strong>只要<code>[first2,last2)</code>任何一个元素第一次出现在<code>[first1,last1)</code>就返回</strong>。两个版本，一个默认使用<code>==</code>,一个允许用户指定二元谓词传入 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIterator</span><span class="params">(InputIterator first1,InputIterator last1</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator2 first2,ForwardIterator2 last2)</span></span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++的ref作用</title>
    <url>/2023/02/27/c-%E7%9A%84ref%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>C++11 中引入 <code>std::ref</code> 用于取某个变量的引用，这个引入是为了解决一些传参问题。</p>
<p>我们知道 C++ 中本来就有引用的存在，为何 C++11 中还要引入一个 <code>std::ref</code> 了？主要是考虑函数式编程（如 <code>std::bind</code>）在使用时，是对参数直接拷贝，而不是引用。下面通过例子说明</p>
<span id="more"></span>
<p>示例1： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp; n1, <span class="type">int</span>&amp; n2, <span class="type">const</span> <span class="type">int</span>&amp; n3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In function: &quot;</span> &lt;&lt; n1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    ++n1; <span class="comment">// increments the copy of n1 stored in the function object</span></span><br><span class="line">    ++n2; <span class="comment">// increments the main()&#x27;s n2</span></span><br><span class="line">    <span class="comment">// ++n3; // compile error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">1</span>, n2 = <span class="number">2</span>, n3 = <span class="number">3</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; bound_f = std::<span class="built_in">bind</span>(f, n1, std::<span class="built_in">ref</span>(n2), std::<span class="built_in">cref</span>(n3));</span><br><span class="line">    n1 = <span class="number">10</span>;</span><br><span class="line">    n2 = <span class="number">11</span>;</span><br><span class="line">    n3 = <span class="number">12</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before function: &quot;</span> &lt;&lt; n1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">bound_f</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After function: &quot;</span> &lt;&lt; n1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Before</span> function: <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="attribute">In</span> function: <span class="number">1</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="attribute">After</span> function: <span class="number">10</span> <span class="number">12</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>上述代码在执行 <code>std::bind</code> 后，在函数 <code>f()</code> 中<code>n1</code> 的值仍然是 1，<code>n2</code> 和 <code>n3</code> 改成了修改的值，说明 <code>std::bind</code> 使用的是参数的拷贝而不是引用，因此必须显示利用 <code>std::ref</code> 来进行引用绑定。具体为什么 <code>std::bind</code> 不使用引用，可能确实有一些需求，使得 C++11 的设计者认为默认应该采用拷贝，如果使用者有需求，加上 <code>std::ref</code> 即可。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(std::string &amp;str, <span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str = <span class="string">&quot;change by threadFunc&quot;</span>;</span><br><span class="line">    a = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;main&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(threadFunc, std::ref(str), a)</span></span>;</span><br><span class="line"></span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">str = change by threadFunc</span><br><span class="line">a = <span class="number">9</span></span><br></pre></td></tr></table></figure> 可以看到，和 std::bind 类似，多线程的 std::thread 也是必须显式通过 std::ref 来绑定引用进行传参，否则，形参的引用声明是无效的。</p>
<blockquote>
<p>本文作者： murphypei</p>
</blockquote>
<blockquote>
<p>本文来源：<a href="https://murphypei.github.io/blog/2019/04/cpp-std-ref.html" class="uri">https://murphypei.github.io/blog/2019/04/cpp-std-ref.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll</title>
    <url>/2023/09/01/epoll/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>gcc/gdb</title>
    <url>/2023/03/11/gcc-gdb/</url>
    <content><![CDATA[<h4 id="gcc和gcc编译器">7. GCC和gcc++编译器</h4>
<h5 id="gcc和-gcc是两个不同的东西">7.1 gcc和 GCC是两个不同的东西</h5>
<ul>
<li><code>GCC:GNU Compiler Collection</code>(GUN 编译器集合)，它可以编译<code>C、C++、JAV、Fortran、Pascal、Object-C、Ada</code>等语言。</li>
<li>因此<code>gcc</code>是<code>GCC</code>中的<code>GUN C Compiler</code>（C 编译器）；<code>g++</code>是<code>GCC</code>中的<code>GUN C++ Compiler</code>（<code>C++</code>编译器）。二者都可以编译<code>c</code>或<code>cpp</code>文件。只不过用<code>gcc</code>编译<code>c++</code>需要手动添加链接库</li>
<li><strong>在编译阶段，<code>g++</code>会调用<code>gcc</code>，对于<code>c++</code>代码，两者是等价的，但是因为<code>gcc</code>命令不能自动和<code>C++</code>程序使用的库联接，所以通常使用用<code>g++</code>来编译以求自动完成链接。所以对于<code>C</code>语言程序的编译，我们应该使用<code>gcc</code> 指令，而编译<code>C++</code>程序则推荐使用<code>g++</code>指令</strong></li>
</ul>
<span id="more"></span>
<h5 id="gccg的四个步骤">7.2 gcc/g++的四个步骤</h5>
<p><code>gcc、g++</code>编译器从拿到一个c源文件到生成一个可执行程序，中间一共经历了<strong>四个步骤：</strong> <img src="/2023/03/11/gcc-gdb/compile.png"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">第一步: 进行预处理</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -E <span class="number">1</span>hello.c -o <span class="number">1</span>hello.i</span><br><span class="line">第二步: 生成汇编文件</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -S <span class="number">1</span>hello.i -o <span class="number">1</span>hello.s</span><br><span class="line">第三步: 生成目标代码</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -c <span class="number">1</span>hello.s -o <span class="number">1</span>hello.o</span><br><span class="line">第四步: 生成可以执行文件</span><br><span class="line"><span class="comment">//这条指令是完成链接这个过程的，它通过链接器ld将运行程序的目标文件和库文件链接在一起，</span></span><br><span class="line"><span class="comment">//生成最后的可执行文件</span></span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc <span class="number">1</span>hello.o -o <span class="number">1</span>hello</span><br><span class="line">第五步: 执行 </span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc​$ ./<span class="number">1</span>hello</span><br><span class="line">hello itcast</span><br><span class="line"></span><br><span class="line">也可直接将源文件生成一个可以执行文件</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc <span class="number">1</span>hello.c -o <span class="number">1</span>hello</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc​$ ./<span class="number">1</span>hello</span><br><span class="line">hello itcast</span><br></pre></td></tr></table></figure></p>
<p><strong>常用选项</strong> <img src="/2023/03/11/gcc-gdb/gcc.png"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello  -I /home/hello/include -L /home/hello/lib -lworld</span><br><span class="line">上面这句表示在编译hello.c时：</span><br><span class="line"></span><br><span class="line">-I /home/hello/include表示将/home/hello/include目录作为第一个寻找头文件的目录，</span><br><span class="line">寻找的顺序是：/home/hello/include--&gt;/usr/include--&gt;/usr/local/include </span><br><span class="line"></span><br><span class="line">-L /home/hello/lib表示将/home/hello/lib目录作为第一个寻找库文件的目录，</span><br><span class="line">寻找的顺序是：/home/hello/lib--&gt;/lib--&gt;/usr/lib--&gt;/usr/local/lib</span><br><span class="line"></span><br><span class="line">-lworld表示在上面的lib的路径中寻找libworld.so动态库文件或libworld.a静态库文件</span><br></pre></td></tr></table></figure></p>
<p><strong><em>附加</em></strong>：</p>
<ul>
<li><p><code>-I</code>针对头文件，未指明路径时，使用<code>#include&lt;&gt;</code>,<code>gcc/g++</code>默认目录<code>/usr/include</code>，如果使用<code>#include&lt;my.h&gt;</code>则找不到<code>my.h</code>文件，因此要通过<code>-I dir</code>参数来指定包含的头文件<code>my.h</code>的位置： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$gcc hell.c -o hell -I /<span class="built_in">root</span>              (假设文件my.h存放在/root下)</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>-L</code>与<code>-I</code> 功能类似，只不过<code>-L</code>时对库文件使用，能够在指定库文件搜索路径。如果一个程序用到了目录<code>/root/lib</code>下的一个动态库<code>libsunq.so</code>，因为<code>-L dir</code>指定的是路径而没有指定文件，则需要用到 <code>-llibname</code>参数，它可以指定<code>gcc</code>去寻找<code>libsunq.so</code>或者<code>libsunq.a</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$gcc hello.c -o hell -L /root/lib -lsunq</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="静态链接和动态链接">7.3 静态链接和动态链接</h5>
<h6 id="静态链接">7.3.1静态链接</h6>
<p><strong>静态链接是指由链接器在链接时将库的内容直接加入到可执行程序中。</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>对运行环境的依赖性较小，具有较好的兼容性</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间</li>
<li>库函数有了更新，必须重新编译应用程序</li>
</ul></li>
</ul>
<h6 id="动态链接">7.3.2 动态链接</h6>
<p><strong>动态链接是指连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>在需要的时候才会调入对应的资源函数</li>
<li>简化程序的升级；有着较小的程序体积</li>
<li>实现进程之间的资源共享（避免重复拷贝）</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>依赖动态库，不能独立运行</li>
<li>动态库依赖版本问题严重</li>
</ul></li>
</ul>
<p>注：前面我们编写的应用程序大量用到了标准库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入<code>-static</code>参数。</p>
<h6 id="静态库的制作">7.3.3 静态库的制作</h6>
<p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。 按照习惯,一般以<code>.a</code>做为文件后缀名。静态库的命名一般分为三个部分：</p>
<ul>
<li>前缀：<code>lib</code></li>
<li>库名称：自己定义即可</li>
<li>后缀：<code>.a</code></li>
</ul>
<p><strong>所以最终的静态库的名字应该为：<code>libxxx.a</code></strong> <img src="/2023/03/11/gcc-gdb/staticlinked.png" width="600"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">步骤<span class="number">1</span>：将c源文件生成对应的.o文件</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib$ gcc -c add.c -o add.o</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c sub.c -o sub.o </span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c mul.c -o mul.o </span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c div.c -o div.o</span><br><span class="line">步骤<span class="number">2</span>：使用打包工具ar将准备好的.o文件打包为.a文件 libtest.a</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib$ ar -rcs libAlogrithm.a add.o sub.o mul.o div.o</span><br></pre></td></tr></table></figure> <strong>在使用ar工具是时候需要添加参数：<code>-rcs</code></strong></p>
<ul>
<li><code>r</code>更新</li>
<li><code>c</code>创建</li>
<li><code>s</code>建立索引</li>
</ul>
<h6 id="静态库的使用">7.3.4 静态库的使用</h6>
<p>静态库制作完成之后，<strong>需要将<code>.a</code>文件和头文件一起发布给用户</strong>。假设测试文件为<code>main.c</code>，静态库文件为<code>libAlogrithm.a</code>，头文件为<code>Alogrithm.h</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ cat main.cpp </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Alogrithm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>,b=<span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ g++ -<span class="type">static</span> main.cpp -I ../staticLib/ -L ../staticLib/ -lAlogrithm -o test</span><br></pre></td></tr></table></figure></p>
<h6 id="动图库的制作">7.3.5 动图库的制作</h6>
<p>共享库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题和更新问题。 按照习惯,一般以“.so”做为文件后缀名。共享库的命名一般分为三个部分：</p>
<ul>
<li>前缀：<code>lib</code></li>
<li>库名称：自己定义即可</li>
<li>后缀：<code>.so</code></li>
</ul>
<p><strong>所以最终的动态库的名字应该为：<code>libxxx.so</code></strong> <img src="/2023/03/11/gcc-gdb/dynamiclib.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">步骤一：生成目标文件，此时要加编译选项：-fPIC（fpic）</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -fPIC -c add.c</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ gcc -fPIC -c sub.c </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -fPIC -c mul.c </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ gcc -fPIC -c div.c</span><br><span class="line">参数：-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</span><br><span class="line">步骤二：生成共享库，此时要加链接器选项: -shared（指定生成动态链接库）</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -shared add.o sub.o mul.o div.o -o libtest.so</span><br><span class="line"></span><br><span class="line">步骤三: 通过nm命令查看对应的函数</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ nm libtest.so | grep add </span><br><span class="line"><span class="number">00000000000006b</span>0 T add </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ nm libtest.so | grep sub </span><br><span class="line"><span class="number">00000000000006</span>c4 T sub</span><br></pre></td></tr></table></figure>
<h6 id="使用动态库">7.3.6 使用动态库</h6>
<p>静态库制作完后，需要在测试文件所在的目录创建<code>libxxx.so</code>的链接接，否则就会出现下面这个错误： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libtiger.so: cannot open shared object file: No such file <span class="keyword">or</span> direct</span><br></pre></td></tr></table></figure> 可以通过<code>ldd</code>命令查看哪些动态链接库没有找到： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ ldd test1</span><br><span class="line">	linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007ffc0d5fe000</span>)</span><br><span class="line">	libAlogrithm.so =&gt; <span class="keyword">not</span> found</span><br><span class="line">	libstdc++.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span> (<span class="number">0x00007fbd2317f000</span>)</span><br><span class="line">	libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007fbd22f57000</span>)</span><br><span class="line">	libm.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libm.so<span class="number">.6</span> (<span class="number">0x00007fbd22e70000</span>)</span><br><span class="line">	/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fbd233c1000</span>)</span><br><span class="line">	libgcc_s.so<span class="number">.1</span> =&gt; /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007fbd22e50000</span>)</span><br></pre></td></tr></table></figure> <strong>这是因为程序运行时没有找到动态链接库造成的。程序编译时链接动态库和运行时使用动态链接库的概念是不同的，在运行时，程序链接的动态链接库需要在系统目录下才行</strong>。方法：</p>
<ul>
<li><strong>方法一是可在系统目录创建软链接，链接文件。</strong>这是因为用·<code>-L</code>指定动态库文件路径只能保证编译通过，是否能执行还是得看<code>/lib/</code>或<code>/usr/lib</code>下面有没有该库文件（只要没有删除，永久有效）</li>
<li>方法二当然你要可以修改<code>LD_LIBRARY_PATH</code>指定的动态库搜索路径(当前shell有效)</li>
<li>方法三是配置文件<code>/etc/ld.so.conf</code>中指定的动态库搜索路径(永久有效)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deng@itcast:~/test/<span class="number">6</span>share_test$ sudo ln -s /home/trluper/Documents/staticLib/libtest.so /lib/share_test/libtest.so</span><br></pre></td></tr></table></figure>
<p>然后同静态链接一样，引用动态库去编译：（要保证能找到头文件，因此使用<code>-I</code>) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ -<span class="type">static</span> main.cpp -I ../staticLib/ -lAlogrithm -o test</span><br></pre></td></tr></table></figure></p>
<h5 id="gdb调试">7.4 gdb调试</h5>
<p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具。GDB主要帮忙你完成下面四个方面的功能：</p>
<ul>
<li>启动程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>动态的改变你程序的执行环境。</li>
</ul>
<h6 id="gdb的工作步骤">7.4.1 gdb的工作步骤</h6>
<p><strong>1. 准备工作</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用gcc/g++将其编译为可执行文件，同时使用-g表示该程序可调试：</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ g++ -g main.cpp sum.cpp -o main</span><br></pre></td></tr></table></figure>
<p><strong>2. 启动gdb</strong></p>
<p>输入<code>gdb -q + 可执行文件</code>，启动gdb进行调试。<code>-q</code>参数可以屏蔽一些gdb版本等相关信息，使得页面看起来干净些（我用了）。至此gdb启动完毕： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ gdb -q main</span><br><span class="line">Reading symbols from main...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p><strong>3. 查看代码（可选）</strong></p>
<p>输入<code>list（l）</code>即可查看程序源码 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line"><span class="number">1</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Alogrithm.h&quot;</span></span></span><br><span class="line"><span class="number">2</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">3</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="number">4</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">5	</span>&#123;</span><br><span class="line"><span class="number">6</span>		<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="number">7</span>		cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line"><span class="number">8</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span>	&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 设置参数（可选）</strong></p>
<p><code>set args</code>可指定运行时参数（如：<code>set args 10 20 30 40 50</code>）。<code>show args</code>命令可以查看设置好的运行参数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) set args <span class="number">20</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">(gdb) b <span class="number">2</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b5</span>: file main.cpp, line <span class="number">6.</span></span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/trluper/Documents/staticLib/main <span class="number">20</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;20 30 50&quot;</span>.</span><br></pre></td></tr></table></figure></p>
<p><strong>5.设置断点（可选）</strong></p>
<p>输入<code>break（b）+数字</code> 可以对程序进行断点操作（数字就是设置断点的代码行数） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) b <span class="number">2</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b5</span>: file main.cpp, line <span class="number">6.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>6. 启动程序</strong></p>
<p>输入<code>run（r)</code>开始运行程序，直到遇到“断点”或者“结束” <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/trluper/Documents/staticLib/main </span><br><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">6</span></span><br><span class="line"><span class="number">6</span>		<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>7.单步执行程序（可选）</strong></p>
<ul>
<li><code>next</code>单步执行程序，但是遇到函数时会直接跳过函数，不进入函数</li>
<li><code>step</code>单步执行程序，但遇到函数会进入函数</li>
<li><code>continue</code>继续执行程序，直到遇到断点或结束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;20 30 50&quot;</span>.</span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">7</span>		cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">(gdb) <span class="function">s</span></span><br><span class="line"><span class="function"><span class="title">sum</span> <span class="params">(a=<span class="number">10</span>, b=<span class="number">20</span>)</span> at sum.cpp:<span class="number">4</span></span></span><br><span class="line"><span class="function"><span class="number">4</span>		return a+b;</span></span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">5</span>	&#125;</span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="built_in">main</span> () at main.cpp:<span class="number">8</span></span><br><span class="line"><span class="number">8</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>8. 查看变量值（可选）</strong></p>
<p><code>print + 变量</code>查看变量值；<code>whatis + 变量</code>查看变量数据类型。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) print a</span><br><span class="line">$<span class="number">1</span> = <span class="number">10</span></span><br><span class="line">(gdb) whatis a</span><br><span class="line">type = <span class="type">int</span></span><br></pre></td></tr></table></figure></p>
<p><strong>9. 退出</strong></p>
<p>输入<code>q</code>即可退出gdb <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) q</span><br><span class="line">A debugging session is active.</span><br><span class="line">	Inferior <span class="number">1</span> [process <span class="number">3102</span>] will be killed.</span><br><span class="line">Quit anyway? (y <span class="keyword">or</span> n) y</span><br></pre></td></tr></table></figure></p>
<h6 id="其他命令">7.4.2 其他命令</h6>
<p><strong>1. 断点</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>delete + n</code></td>
<td>删除第<code>n</code>个断点</td>
</tr>
<tr class="even">
<td><code>disable + n</code></td>
<td>暂停第<code>n</code>个断点</td>
</tr>
<tr class="odd">
<td><code>enable + n</code></td>
<td>开启第<code>n</code>个断点</td>
</tr>
<tr class="even">
<td><code>clear + n</code></td>
<td>清除第<code>n</code>行的断点</td>
</tr>
<tr class="odd">
<td><code>info b</code></td>
<td>显示当前程序的断点设置情况</td>
</tr>
<tr class="even">
<td><code>delete breakpoints</code></td>
<td>清除所有断点</td>
</tr>
</tbody>
</table>
<p><strong>2. 运行信息</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>where/bt</code></td>
<td>当前运行的堆栈列表</td>
</tr>
<tr class="even">
<td><code>bt backtrace</code></td>
<td>显示当前调用堆栈</td>
</tr>
<tr class="odd">
<td><code>up/down</code></td>
<td>改变堆栈显示的深度</td>
</tr>
<tr class="even">
<td><code>info program</code></td>
<td>查看程序是否在运行，以及进程号被暂停的原因</td>
</tr>
</tbody>
</table>
<p><strong>3. 运行命令</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>until</code></td>
<td>如果你厌倦了在一个循环内单步跟踪，它可以运行程序直到退出循环体</td>
</tr>
<tr class="even">
<td><code>until + 行号</code></td>
<td>运行至某行</td>
</tr>
<tr class="odd">
<td><code>finish</code></td>
<td>运行程序，直到当前函数返回完成，并且打印函数返回时的堆栈地址和返回值及参数值等信息</td>
</tr>
<tr class="even">
<td><code>call + 行数 + （参数）</code></td>
<td>调用程序中可见的函数，并传递参数</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>github访问问题</title>
    <url>/2022/12/16/github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="github无法访问">1. github无法访问</h4>
<p>由于github是外国网站，常常会有些时候无法登进去，这是由于<code>github</code>的IP地址时常会发生改变，我们在浏览器输入 GitHub 的网址时，会向 DNS 服务器发送一个请求，获取到 GitHub 网站所在的服务器 IP 地址，从而进行访问。如果DNS未即使更新地址的话给你一个过期ip，你自然无法访问到。为解决这个问题，可以通过修改host。</p>
<span id="more"></span>
<h5 id="查询可通的ip地址">1.1 查询可通的ip地址</h5>
<p>首先通过<a href="https://tool.chinaz.com/dns/?type=1&amp;host=github.com&amp;ip=">站长</a>,查询<code>github.com</code>可达的ip节点： <img src="/2022/12/16/github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/ip.jpg"></p>
<h5 id="本地修改host">1.2 本地修改host</h5>
<p>先找到域名解析文件 hosts 文件的位置，不同操作系统，hosts 文件的存储位置也不同：</p>
<ul>
<li>Windows 系统：<code>C:\Windows\System32\drivers\etc\hosts</code></li>
<li>Linux 系统：<code>/etc/hosts</code></li>
<li>Mac（苹果电脑）系统：<code>/etc/hosts</code></li>
<li>Android（安卓）系统：<code>/system/etc/hosts</code></li>
<li>iPhone（iOS）系统：<code>/etc/hosts</code></li>
</ul>
<p>进入host文件，在末尾增加该地址<code>20.205.243.166 www.github.com</code> <img src="/2022/12/16/github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/host.jpg"></p>
<p>最后在终端窗口执行：<code>ipconfig/flushdns</code>即可。</p>
<p><strong><em>附：</em></strong>你也可以用<a href="https://github.com/521xueweihan/GitHub520">github520定时更新的host</a></p>
<p>将其复制到host保存,在执行<code>ipconfig/flushdns</code>即可</p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>c++基础</title>
    <url>/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h4 id="类型">1.类型</h4>
<h5 id="基本内置类型">1.1 基本内置类型</h5>
<p>基本内置类型有算术类型和空类型。算术类型分两类为整型和浮点型，下图显示了C++的算数类型: <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/clipboard.png" width="600"></p>
<h5 id="复合类型">1.2 复合类型</h5>
<p>c++有几种复合类型：数组、结构、string、引用和指针。这里讨论引用和指针。</p>
<span id="more"></span>
<h6 id="引用">1.2.1 引用</h6>
<p>引用为对象起了另外一个名字。引用类型必须与其所引用的对象类型一致，通过<code>&amp;d</code>的形式定义引用类型。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> value=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp;d=value;	<span class="comment">//引用必须被初始化</span></span><br><span class="line">d=<span class="number">20</span>;	<span class="comment">//即value=d=20</span></span><br><span class="line"><span class="type">int</span> i=d;	<span class="comment">//即i=value;</span></span><br></pre></td></tr></table></figure> 程序把引用和它的初始值绑定在一起（而不是拷贝）。一但绑定了，无法再重新绑定另外的对象。引用并非是对象，只是已存在对象的别名。</p>
<h6 id="指针">1.2.2 指针</h6>
<p>与引用类似，指针也实现了对其他对象的间接访问。但与引用相比也有不同，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象，指针也无须在定义时赋初值。 指针的值应是下列4种状态之一：</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针</li>
<li>无效指针，即上述情况外的其他值</li>
</ul>
<h4 id="类型转换">2.类型转换</h4>
<p>如果两种类型可以相互转换，那么它们就是关联的。</p>
<h5 id="隐式转换">2.1 隐式转换</h5>
<p><code>如int ival=3.14+3；</code>。编译器会自动转换运算对象的类型的情况：</p>
<ul>
<li>①在大多数表达式中，比int型小的整型值首先提升为较大的整数类型</li>
<li>②条件语句中，非bool类型转化为bool类型</li>
<li>③初始化中，右值转换为左值类型</li>
<li>④算术运算和关系运算的对象要转化为同一种类型：先整型提升、再看是否为带符号运算（有符号&lt;不带符号，应当减少带符号与不带符号的混用）</li>
<li>⑤函数调用也会发生转换</li>
<li>⑥*void类型指针的转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">-11</span>;</span><br><span class="line">	<span class="type">int</span> c=a+b;		<span class="comment">//强制转换为int</span></span><br><span class="line">	<span class="type">unsigned</span> d=a+B;		<span class="comment">//输出了错误结果4294967295,理论计算结果为-1，带符号型的为负值，带符号&lt;不带符号，+-*\这些运算都会隐式转换为不带符号类型，若左值不声明为带符号型出错</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="显示转换">2.2 显示转换</h5>
<p>强制类型转换形式是<code>cast_name&lt;type&gt;(expression)</code>(一般多为右值，但当type为引用类型时，为左值）。</p>
<ul>
<li><code>type</code>是转换的目标类型，</li>
<li><code>expression</code>是要转换的值。</li>
<li><code>cast_name:static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。</code>
<ul>
<li>①<code>static_cast</code>:任何有明确定义的类型转换，只要不包含底层<code>const</code>，均可使用</li>
<li>②<code>const_cast</code>:只能改变运算对象的底层<code>const</code>，即只改变常量属性，不能改变类型</li>
<li>③<code>dynamic_cast</code>:用于将基类的指针或者引用安全地转换成派生类的指针或引用。</li>
<li>④<code>reinterpret_cast</code>:通常为运算对象的位模式提供较低层次上的重新解释。<code>reinterpret_cast</code>可以用来在任意类型间进行转换，转换后其正确性由程序员保证。</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>	*pc;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);	<span class="comment">//合法，但通过p写值是未定义行为</span></span><br><span class="line"><span class="comment">//上面我们称为去const性质（常量对象转化为非常量对象，这种情况编译器此时就不允许我们进行写操作了）</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cp=&amp;c;</span><br><span class="line"><span class="type">char</span>* q=<span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(cp);		<span class="comment">//不合法，想改变底层const</span></span><br><span class="line">string a = <span class="built_in">static_cast</span>&lt;string&gt;(cp);	<span class="comment">//合法，字符串转换为string类型</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;string&gt;(cp)				<span class="comment">//不合法</span></span><br></pre></td></tr></table></figure>
<h4 id="const关键字">3. const关键字</h4>
<p>使用关键字<code>const</code>对变量类型加以限定，它的值不能被改变。注意在默认情况下，<code>const</code>对象仅在文件内有效。如果像让const对象能在文件间共享，加<code>extern</code>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> buffer=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> buffer=<span class="number">25</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="const引用">3.1 const引用</h5>
<p>把引用绑定在<code>const</code>对象上，称为对常量的引用。与普通引用所不同的是，对常量的引用不能被用作修改它所绑定的对象：(非常量引用不能绑定常量对象，但允许常量引用绑定非常量对象）: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">onst <span class="type">int</span> ci=<span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri=ci;</span><br><span class="line"><span class="type">int</span> &amp;a=ci;		<span class="comment">//错误，不能用非常量引用绑定常量对象</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">40</span>;</span><br><span class="line">r1=<span class="number">42</span>;		<span class="comment">//错误，r1是对常量的引用，不能被修改所绑定的对象ci</span></span><br><span class="line"><span class="type">int</span> &amp;r=ci;	<span class="comment">//错误，不能非常量引用绑定常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;d=i;		<span class="comment">//允许const int&amp; 绑定在一个int对象上</span></span><br></pre></td></tr></table></figure> 还有以下也不允许：<strong>一个常量引用绑定另外一种类型。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> i=<span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p=i;</span><br><span class="line"><span class="comment">/*实际的底层：</span></span><br><span class="line"><span class="comment">double i=3;</span></span><br><span class="line"><span class="comment">int temp=i;</span></span><br><span class="line"><span class="comment">const int &amp;p=temp;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure> 原因是为了确保<code>p</code>绑定的是整型，编译器会把上述的代码中的i由双精度浮点数生产一个临时整型（常）量，此时p就绑定了一个临时量对象<code>temp</code>。如果<code>p</code>不是常量，此时不能对<code>p</code>赋值来改变i的值（因为实际改变的是零时<code>temp</code>的值），在c++看来这是非法的。</p>
<h5 id="指针和const">3.2指针和const</h5>
<p>与引用一样，也可以让指针指向常量或非常量。指向常量的指针不能改变其所指向对象的值。且常量指针必须初始化。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *p 	<span class="comment">//表示 指向的内容不能改变。</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> p	<span class="comment">//就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。</span></span><br></pre></td></tr></table></figure></p>
<h5 id="顶层const和底层const">3.3顶层const和底层const</h5>
<p>一般来说对于指针而言才有底层和顶层这个区分。顶层const表示指针本身是一个常量，底层const表示指针所指向的对象是一个常量。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci=<span class="number">42</span>;	<span class="comment">//顶层const,不能修改ci的值</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> cr=<span class="number">40</span>;	<span class="comment">//顶层const</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p=&amp;i;	<span class="comment">//顶层const,不允许修改p的值</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p1=&amp;i;	<span class="comment">//底层const，允许修改p1的值，但不能修改ci的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2=&amp;ci;	<span class="comment">//底层const，允许修改p2的值，但不能修改ci的值</span></span><br></pre></td></tr></table></figure> <strong><em>注意：执行对象拷贝时，必须至少具有相同底层const资格，或非常量可转化为常量，但反过来不行。如下的两句</em></strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> *p=&amp;i;	<span class="comment">//底层const</span></span><br><span class="line"><span class="type">int</span>* f = p;		<span class="comment">//不允许</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* g = i;	<span class="comment">//合法</span></span><br></pre></td></tr></table></figure></p>
<h4 id="标准库string">4.标准库string</h4>
<p>C++大大增强了对字符串的支持，除了可以使用C风格的字符串，还可以使用内置的 string 类。string 类处理起字符串来会方便很多，完全可以代替C语言中的字符数组或字符串指针。string类重载许多运算符，如<code>&lt;,&gt;,&lt;=,&gt;=,==,!=,[],+</code>,以及输出流<code>&lt;&lt;</code>和<code>&gt;&gt;</code></p>
<h5 id="string的构造">4.1 string的构造</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> naemspace std;</span><br><span class="line">string s1;		<span class="comment">//未定义具体值，则调用string类的未传参构造函数，s1=&quot;&quot;</span></span><br><span class="line">string s2=s1;	<span class="comment">//赋值拷贝</span></span><br><span class="line">string s3=<span class="string">&quot;value&quot;</span>;	<span class="comment">//赋值拷贝</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;		<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>;	<span class="comment">//s4的内容为ccccccccccc，直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(s3,<span class="number">2</span>)</span></span>;	<span class="comment">//结果为lue</span></span><br></pre></td></tr></table></figure>
<h5 id="string关于长度的函数">4.2 string关于长度的函数</h5>
<p>string支持较多的关于长度的函数，这里通过表格形式列举：</p>
<table>
<thead>
<tr class="header">
<th>函数名</th>
<th>功能</th>
<th>调用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>size()</code></td>
<td>返回字符数量</td>
<td><code>s.size()</code></td>
</tr>
<tr class="even">
<td><code>length()</code></td>
<td>返回字符数量</td>
<td><code>s.length()</code></td>
</tr>
<tr class="odd">
<td><code>empty()</code></td>
<td>判空操作</td>
<td><code>s.empty()</code></td>
</tr>
<tr class="even">
<td><code>capacity</code></td>
<td>返回字符容量</td>
<td><code>s.capacity()</code></td>
</tr>
<tr class="odd">
<td><code>reserve(size_t)</code></td>
<td>保留内存以存储一定数量的字符</td>
<td><code>s.reserve(20)</code></td>
</tr>
<tr class="even">
<td><code>resize(size_t)</code></td>
<td>改变字符数量</td>
<td><code>s.reszie(20)</code></td>
</tr>
</tbody>
</table>
<h5 id="string的增删">4.3 string的增删</h5>
<p>一般来说相同名称的接口有很多个重载，因此列举的只是一部分，读者可以在实际开发中依据编辑器给的提示选择： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s2=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">s1=s1+<span class="string">&quot; &quot;</span>+s2;	<span class="comment">//重载+运算符</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>,<span class="string">&quot;ins&quot;</span>); <span class="comment">//从s1的1位置开始，插入&quot;ins&quot;字符串，即s1=&quot;hinsello&quot;;</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;ins&quot;</span>, <span class="number">2</span>);<span class="comment">//从s1的1位置开始，插入&quot;ins&quot;字符串的前2个字符，即s1=&quot;hinello&quot;;</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;ins&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//从s1的1位置开始，插入&quot;ins&quot;字符串的从1位置开始的2个字符，即s1=&quot;hnsello&quot;;</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="type">char</span> c)</span></span>;<span class="comment">//在it处插入字符c，返回插入后迭代器的位置，该insert不是string的insert，而是算法层的函数</span></span><br><span class="line">s1.<span class="built_in">append</span>(str);</span><br><span class="line">s1.<span class="built_in">push_back</span>(<span class="type">char</span> c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊</span></span><br><span class="line">s1.<span class="built_in">assign</span>(str);		<span class="comment">//赋新值，旧值全部删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">iterator s1.<span class="built_in">erase</span>(iterator first, iterator last);<span class="comment">//删除[first，last）之间的所有字符，返回删除后迭代器的位置</span></span><br><span class="line">iterator s1.<span class="built_in">erase</span>(iterator it);<span class="comment">//删除it指向的字符，返回删除后迭代器的位置</span></span><br><span class="line">string&amp;  s1.<span class="built_in">erase</span>(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> n = npos);<span class="comment">//删除pos开始的n个字符，返回修改后的字符串</span></span><br></pre></td></tr></table></figure></p>
<h5 id="string的查找">4.4 string的查找</h5>
<p>string类的查找函数提供了比较多的接口，以下是列举的一些常用<code>find</code>函数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，-1表示查找不到子串</span></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">(charc, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="type">size_t</span> <span class="title">rfind</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</span></span><br><span class="line"><span class="number">4.</span> <span class="function"><span class="type">size_t</span> <span class="title">rfind</span> <span class="params">(charc, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">5.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">6.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">7.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">8.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</span></span><br></pre></td></tr></table></figure></p>
<h5 id="string的遍历和排序">4.5 string的遍历和排序</h5>
<p>string支持下标<code>[]</code>随机访问，也支持迭代器遍历，因此对于遍历string可通过这些功能来遍历。排序我们使用<code>algorithm</code>头文件内的<code>sort</code>，<code>sort</code>内部的实现机制是快排，并且通过修改避免快排中复杂都最高的情况 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="comment">//foreach循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">	<span class="built_in">printf</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">	cout&lt;&lt;c&lt;&lt;ends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string::iterator it=s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it&lt;s.<span class="built_in">end</span>())&#123;</span><br><span class="line">	cout&lt;&lt;*it&lt;&lt;ends;</span><br><span class="line">	it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="其他操作">4.6 其他操作</h5>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/cctype.png" width="600"></p>
<p><strong><em>注意</em></strong>：<strong>在c++中存在一个从<code>const char*</code>到<code>string</code>的隐式类型转换，却不存在从一个<code>string</code>对象到<code>C_string</code>的自动类型转换</strong>。对于<code>string</code>类型的字符串，可以通过<code>c_str()</code>函数返回<code>string</code>对象对应的<code>C_string</code>. 通常，程序员在整个程序中应坚持使用<code>string</code>类对象，直到必须将内容转化为<code>char*</code>时才将其转换为<code>C_string</code>.(即string类型有向const char*的转换，没有string向非const char的转换)</p>
<h4 id="初见迭代器">5. 初见迭代器</h4>
<p>这里尽对迭代器做一个简单的介绍，更加具体的见<strong>STL源码剖析</strong>。我们可通过下标运算符来访问string和vector对象的元素。还有一种是通过迭代器（iterator)进行访问，在c++中我们强烈推荐使用迭代器而不是下标，因为标准库几乎为每一种容器都提供了迭代器，而迭代器提供了对对象的间接访问。</p>
<ul>
<li><p><strong>使用迭代器</strong>：有迭代器的类型同时拥有返回迭代器成员的函数，如<code>begin</code>和<code>end</code>,其中<code>begin</code>成员负责返回指向第一个元素；<code>end</code>成员负责返回尾元素的下一个位置。和指针类似，也能通过解引用迭代器来获取它所指示的元素。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">begin</span>()!=s.<span class="built_in">end</span>())&#123;	<span class="comment">//确保s非空</span></span><br><span class="line"><span class="keyword">auto</span> it=s.<span class="built_in">begin</span>();	<span class="comment">//it表示s的第一个字符地址</span></span><br><span class="line">*it=<span class="built_in">toupper</span>(*it);	<span class="comment">//将第一个改为大写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>将迭代器从一个元素移动到另外一个元素：使用递增++运算符达到这个目的，如下 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>()&amp;&amp;!<span class="built_in">isspace</span>(*it);it++)to</span><br><span class="line">*it=<span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="迭代器类型">5.1迭代器类型</h5>
<p>拥有迭代器的标准库类类型使用iterator和const_iterator来表示迭代器类型.所以如果对象是一个常量，只能用const_iterator。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;	<span class="comment">//it能读写vector&lt;int&gt;的有元素</span></span><br><span class="line">string::iterator it2;		<span class="comment">//it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;		<span class="comment">//it3只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4;			<span class="comment">//只能读，无法写</span></span><br></pre></td></tr></table></figure></p>
<h5 id="迭代器运算">5.2 迭代器运算</h5>
<p>迭代器的递增运算令迭代器每次移动一个元素，所有标准库都支持递增运算，也能用==和!=对两个有效迭代器进行比较。以下是vector和string提供的个更多的关系运算: <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/iterator.png" width="600" align="middle"></p>
<h4 id="异常处理">6.异常处理</h4>
<p>异常处理包括：</p>
<ul>
<li><code>throw</code>表达式：异常检测部分使用<code>throw</code>表达式来表示它遇到了无法处理的问题。</li>
<li><code>try</code>语句块：异常处理部分使用<code>try</code>语句块处理异常，<code>try</code>语句块代码中抛出的异常会被某个<code>catch</code>子句处理。（<code>catch</code>为异常处理代码）</li>
<li>一套异常类：用于<code>throw</code>语句和相关<code>catch</code>子句之间传递异常的具体信息</li>
</ul>
<p><strong>1）throw表达式</strong> throw表达式引发一个异常。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(item1.<span class="built_in">isbn</span>()!=item2.<span class="built_in">isbn</span>())</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to	same ISBN&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;item1+item2&lt;&lt;endl;</span><br></pre></td></tr></table></figure> c++标准异常类,它们分别位于4个头文件中：</p>
<ul>
<li>①<code>exception</code></li>
<li>②<code>stdexcept</code></li>
<li>③<code>new</code>头文件定义的<code>bad_alloc</code></li>
<li>④<code>type_inof</code>头文件定义的<code>bad_cast</code></li>
</ul>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/exception.png" width="600"></p>
<h4 id="函数">7.函数</h4>
<h5 id="局部对象">7.1 局部对象</h5>
<p>在c++中，名字有作用域，对象有<strong>生命周期。</strong></p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见</li>
<li>对象的生命周期是程序执行过程中该对象存在时间</li>
</ul>
<p>形参和函数体内部定义的变量统称为<strong>局部变量</strong>。所有在函数体之外定义的对象存在于程序的整个执行过程。</p>
<ul>
<li><strong>自动对象</strong>：只存在于块执行期间的对象为自动对象。<strong>即对于局部变量，当函数的执行路径经过变量定义语句时创建该对象，到达块末尾时销毁它</strong>。</li>
<li><strong>局部静态对象</strong>：将局部变量定义成static类型从而可获得。在定义中初始化时生产该对象，直到程序终止才被销毁（即static修饰得变量只会被初始化一次）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">size_t</span> ctr=<span class="number">0</span>;	<span class="comment">//只被初始化一次</span></span><br><span class="line">	<span class="keyword">return</span>	++ctr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>:i++)</span><br><span class="line">	cout&lt;&lt;<span class="built_in">count</span>()&lt;&lt;endl;	<span class="comment">//输出得一次为1、2、3.....10</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="参数传递">7.2 参数传递</h5>
<p>形参的类型决定了形参与实参得交互方式。若形参为引用类型，则对应得实参被引用传递，引用形参是它对应实参得别名。当实参的值被拷贝给形参时，形参和实参是两个独立的对象，此时实参被值传递。</p>
<ul>
<li><strong>①指针形参</strong>：和其他非引用形参一样，形参的指针执行拷贝时，拷贝的是实参指针，两个指针是不同的指针，但他们都指向同一对象，因此可修改指向对象的值。</li>
<li><strong>②引用行参</strong>：引用参数绑定初始化它的对象，改变形参也就改变了所引对象的值。使用引用能避免拷贝。</li>
</ul>
<h6 id="指针形参与const">7.2.1 指针形参与const</h6>
<p>达到不改变实参和形参所指对象的值，而且调用时，若改变了值，编译器报错。但需注意(于底层const)允许非常量初始化常量对象（形参），但不允许常量(实参）初始化一个非常量对象（形参）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> a)</span></span>;	<span class="comment">//顶层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* a)</span></span>;	<span class="comment">//底层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>* a)</span></span>;		<span class="comment">//正常指针参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span>* y = &amp;x;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* a = &amp;x;</span><br><span class="line">	<span class="type">int</span>* <span class="type">const</span> b = &amp;x;</span><br><span class="line">	<span class="built_in">func1</span>(b);</span><br><span class="line">	<span class="comment">//func1(a); 不允许，实参为底层，形参为顶层，想用底层初始化顶层是不被允许的</span></span><br><span class="line">	<span class="built_in">func2</span>(a);</span><br><span class="line">	<span class="built_in">func2</span>(b);</span><br><span class="line">	<span class="built_in">func3</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;顶层const可以用非常亮初始化一个常量对象（形参），反之不行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	*a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;底层const可以用非常亮初始化一个常量对象（形参），反之不行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//*a=20;		//错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>* a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;不允许常量初始化一个非常量对象（形参）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	*a = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="引用形参与const">7.2.2 引用形参与const</h6>
<p>常量引用时候我们经常要用到的东西。同<code>const</code>指针形参一样，同样不能修改值。普通引用（即没有<code>const</code>)的限制:</p>
<ul>
<li>不允许实参为const对象（即非常量不能初始化常量对象）</li>
<li>不允许实参为字面值</li>
<li>不能提供类型转换</li>
</ul>
<p>const引用形参却能克服这些限制。但就是不能改变绑定的值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="type">const</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">	<span class="comment">//func1(a) 不允许，普通引用不允许实参为const</span></span><br><span class="line">	<span class="comment">//func1(10) 不允许，普通引用形参不允许实参为字面值</span></span><br><span class="line">	<span class="built_in">func1</span>(b);</span><br><span class="line">	<span class="built_in">func2</span>(a);</span><br><span class="line">	<span class="built_in">func2</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;这里是func1&quot;</span>&lt;&lt;endl;</span><br><span class="line">	a=<span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;这里是function2&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//a=40;		不允许对const引用的修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="数组形参">7.2.3 数组形参</h6>
<p>因为数组不能被拷贝，所以无法以值传递的方式使用数组参数。但数组会被转换为指针，所以当我们传递一个数组时，实际上传递的指向数组首元素的指针。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这三个函数声明均为const int*类型。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="comment">//还有数组引用形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> (&amp;arry)[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="可变形参函数">7.2.4 可变形参函数</h6>
<p>有时我们无法预知应该向函数传递几个参数，所以可使用可变形参函数.c++11新标准提供了以下主要方法：</p>
<ul>
<li>若所以实参类型相同，可传递一个名为initializer_list的标准库类型</li>
<li>若实参类型不同，编写一个可变参数模板</li>
<li><strong>c++还有一种形参类型（省略符），用它来传递可变数量的实参。</strong></li>
</ul>
<p><strong>1.initializer_list形参</strong></p>
<p>它是一种标准库类型，定义在同名（initializer_list)头文件中。它提供的操作有：</p>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/initializer.png" width="600"> 和vector不同的是，initializer_list对象中的元素是常量值，我们无法修改它们的值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">msg</span><span class="params">(initializer_list&lt;string&gt; li)</span>	<span class="comment">//均为string类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	functionbody;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.省略符形参</strong></p>
<p>省略符形参应该仅仅用于c和c++的通用的类型（因为省略符的实际就是为了c++能够访问特殊c代码所设计的，这些代码使用了varargs的c标准库功能）。使用参数是用位置数字代号作为形参变量 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略符形参只有两种形式：</span></span><br><span class="line"><span class="built_in">foo</span>(parm_list,...);	<span class="comment">//指定部分形参类型</span></span><br><span class="line"><span class="built_in">foo</span>(...);			<span class="comment">//均无指定</span></span><br><span class="line"><span class="comment">//用数字作为代号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="返回值">7.3返回值</h5>
<ul>
<li>①c++11新标准规定，函数可以返回花括号包围的列表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">	....<span class="comment">//expect\actual为string对象</span></span><br><span class="line">	<span class="keyword">if</span>(expected.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(expected==actual)</span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="string">&quot;funtionX&quot;</span>,<span class="string">&quot;OK&quot;</span>&#125;;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>c++11新标准规定，main函数的类型如果不为void,也可没有return语句（编译器会自己添加return 0;)</li>
</ul>
<h5 id="函数重载">7.4函数重载</h5>
<p>如果同一作用域内的几个<strong>函数名字相同但形参列表不同，称为重载函数</strong>（函数的重载应该使用于那些操作非常类似的函数）,返回值也可不同（但不是必须）。如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* beg,<span class="type">const</span> <span class="type">int</span> *end)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> aa[],<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure> 这些重载函数形参类型不同，当调用这些函数时，编译器会根据传递的实参类型推断调用的是哪个函数。</p>
<h6 id="重载和const形参">7.4.1 重载和const形参</h6>
<ul>
<li>拥有顶层const和没有顶层const的形参无法区分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>	<span class="title">lookup</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>	<span class="title">lookup</span><span class="params">(<span class="type">const</span> <span class="type">int</span>)</span></span>;	<span class="comment">//不能识别，不要这样用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>	<span class="title">lookup</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>底层const可区分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;	<span class="comment">//重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span> *）；</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> lookup(<span class="type">const</span> <span class="type">int</span>*);	<span class="comment">//重载</span></span></span></span><br></pre></td></tr></table></figure>
<h6 id="const_cast和重载">7.4.2 const_cast和重载</h6>
<p>const_cast在重载函数的情景中最有用。例子如下 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">shorterString</span><span class="params">(<span class="type">const</span> string&amp; s1,<span class="type">const</span> string&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size&lt;=s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上面这个参数和返回类型都是<code>const string</code>的引用。当我们传入的参数时非常量的时候，我们当然希望返回的是<code>string</code>的引用，而不是<code>const string</code>的引用，这时候就用到显示类型转换<code>const_cast</code>.改进如下：重载另一<code>shorterString</code>函数: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">shorterString</span><span class="params">(string&amp; s1,string&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; r=<span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其参数和返回值均为<code>string&amp;</code>。在该函数内部调用<code>const</code>的版本，参数强制转换为<code>const string&amp;</code>型 执行后返回后<code>auto&amp; r</code>。无<code>const</code>版本再强制转为<code>string&amp;</code>。 你觉得很不应该，直接在无<code>const</code>函数实现不就行了吗，其实不是的，这样写是为了方便代码的维护,要修改的时候我们只有修改<code>const</code>版本</p>
<h5 id="特殊用途语言特性">7.5特殊用途语言特性</h5>
<p>这里介绍<strong>默认实参、内联函数和constexpr函数</strong>。</p>
<h6 id="默认实参">7.5.1 默认实参</h6>
<p>某些函数再多次调用时都被赋予一个相同值，这个反复出现的值就为默认实参。其声明定义如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> ht=<span class="number">24</span>,<span class="type">int</span> wid=<span class="number">10</span>,<span class="type">char</span>  backgrd=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">typedef</span> string::szie_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht=<span class="number">24</span>,sz wid=<span class="number">10</span>,<span class="type">char</span>  backgrd=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数时：</span></span><br><span class="line">string window;</span><br><span class="line">window=<span class="built_in">screen</span>();		<span class="comment">//默认实参</span></span><br><span class="line">window=<span class="built_in">screen</span>(<span class="number">60</span>);	<span class="comment">//等价于screen(60,10,&#x27; &#x27;);</span></span><br><span class="line">window=<span class="built_in">screen</span>(<span class="number">60</span>,<span class="number">10</span>,<span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h6 id="内联函数和constexptr函数">7.5.2 内联函数和constexptr函数</h6>
<p>因为调用函数要先保存寄存器，并在返回时恢复。有一定的时间开销。而内联函数可避免调用函数的开销。关键字是<code>inline</code>. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string&amp; <span class="title">shorterString</span><span class="params">(<span class="type">const</span> string&amp; s1,<span class="type">const</span> string&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size&lt;=s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>constexptr函数</code>:指能用于常量表达式的函数。函数的返回类型及所有形参的的类型都是字面值，函数体中有且仅有一条return语句。</p>
<h5 id="lambda表达式">7.6 lambda表达式</h5>
<p>我们可以向一个算法传递任何类别可调用对象，如果可以对其使用调用运算符()，则称它为可调用的。c++中可调用对象有函数、函数指针、重载函数调用运算符类、<code>lambda</code>表达式。</p>
<p><strong>一个<code>lambda</code>表达式表示一个可调用的代码单元，可将其理解为一个未命名的内联函数。一个<code>lambda</code>具有一个返回类型、一个参数列表和一个函数体(同函数一样）。与函数不同的是，<code>lambda</code>可定义在函数内部，有捕获列表：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (parameter list)-&gt;<span class="keyword">return</span> type&#123;	function body 	&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>captue list</code>（捕获列表）是一个lambda所在函数中定义的局部变量列表（通常为空）</li>
<li><code>return type</code>为返回类型，</li>
<li><code>parameter list</code>为参数列表、</li>
<li><code>function body</code>为函数体</li>
</ul>
<p>可以忽略参数列表（等价于指定一个空参数列表）和返回类型（此时根据代码推断，有return返回相应类型，没有为void)，<strong>但必须包含捕获列表和函数体：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=[] &#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;endl;	<span class="comment">//调用时也有调用运算符()</span></span><br><span class="line"><span class="comment">//lambda不能设默认参数，因此一个lambda调用时实参数目必须与形参一一对应。</span></span><br><span class="line">[](<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="捕获规则">7.6.1 捕获规则</h6>
<p>lambda表达式的捕获列表有值捕获和引用捕获 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/lambda.png" width="700"> <strong>我们可以在捕获列表中写一个<code>&amp;</code>或者<code>=</code>，指示编译器推断捕获列表。<code>&amp;</code>告诉编译器采用捕获引用方式，<code>=</code>则表示采用值捕获方式</strong>。我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：</p>
<ul>
<li>当混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个<code>&amp;</code>或<code>=</code>（必须隐式）</li>
<li>当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">biggies</span><span class="params">(vector&lt;string&gt; &amp;words,vector&lt;string&gt;::size_type sz,ostream &amp;os,string c=<span class="string">&quot; &quot;</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//words,sz c采用值捕获，os为引用捕获</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[=,&amp;os](<span class="type">const</span> string &amp;s)&#123;os&lt;&lt;s&lt;&lt;c&lt;&lt;ends;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。<strong>如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字<code>mutable</code></strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b, <span class="type">int</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c = <span class="number">10</span>;</span><br><span class="line">    a = <span class="number">11</span>;</span><br><span class="line">    b = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; b&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambdaTest</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;,c]()<span class="keyword">mutable</span> &#123;<span class="keyword">return</span> <span class="built_in">sum</span>(a, b, c); &#125;;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">f</span>();</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">11</span> <span class="number">12</span> <span class="number">10</span></span><br><span class="line"><span class="number">33</span> <span class="number">11</span> <span class="number">12</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<h4 id="类">8.类</h4>
<p>c++语言中，使用类定义自己的数据类型，是我们更容易编写、调试和修改程序。类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>。 <strong>数据抽象是一种依赖接口和实现的分离编程技术</strong>。类的接口包括用户所能执行的操作，类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。要实现数据抽象，首先要定义抽象数据类型。</p>
<h5 id="定义抽象数据类型">8.1 定义抽象数据类型</h5>
<p><strong>成员函数的声明必须在类的内部</strong>，它的定义既可以在类的内部也可以在类的外部。而作为接口组成部分的非成员函数，他们的定义和声明都在类的外部。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;		<span class="comment">//Sales_data类</span></span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> 	BookNo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	std::string 	BookNo;</span><br><span class="line">	<span class="type">unsigned</span>  units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure> 上面这个类成员函数有<code>isbn、combine、avg_prince</code>。其中<code>isbn</code>在类的内部定义，<code>combine</code>和<code>avg_price</code>定义在类外部（声明于类内部）。</p>
<h5 id="成员函数">8.2 成员函数</h5>
<h6 id="const修饰函数---常量成员函数">8.2.1 const修饰函数---常量成员函数</h6>
<ul>
<li>在类中将成员函数修饰为<code>const</code>表明在该函数体内，<strong><em>不能修改对象的数据成员而且它不能调用非const函数</em></strong>。</li>
<li><p><strong>为什么不能调用非<code>const</code>函数</strong>:因为非<code>const</code>函数可能修改数据成员，<code>const</code>成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数。</p></li>
<li><p>同时这里的<code>const</code>也有修改隐式<code>this</code>指针的作用，使<code>T*const register this</code>为<code>const T*const register this</code>，这样<code>this</code>指针就能绑定到一个常量（<code>const</code>）对象上。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;	<span class="comment">//set函数设置值，不能声明为const函数</span></span><br><span class="line">			i=n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span><span class="type">const</span></span>&#123;		<span class="comment">//get函数只取值，声明为const符合规范设计</span></span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="this指针">8.2.2 this指针</h6>
<p>上面提到了<code>this</code>指针，它指的是对于类的内部成员函数，其参数列表的第一若不显式写出总是隐藏有一个<code>this</code>指针:</p>
<ul>
<li><strong><em>成员函数this指针：成员函数通过一个名为this的隐式参数来访问调用它的那个对象</em></strong>。<code>this</code>指针是一个指向当前对象的指针，或者说当前对象的地址。</li>
<li><strong>this指针只能在一个类的非静态成员函数中使用（全局函数、静态函数不能使用）</strong>。</li>
<li>C++的非静态成员函数的第一个默认并且被隐藏的参数是<code>T *const register this</code>。比如我们在<code>Student</code>这个类里声明这样一个函数：<code>int SetName(const char *name)</code>;其实编译器处理的时候会变为 <code>int SetName(Student *const register this, const char *name)</code>;</li>
</ul>
<h6 id="类的静态函数没有this指针">8.2.3 类的静态函数没有this指针</h6>
<p><strong>静态函数如同静态变量一样，他不属于具体的哪一个对象而是属于类</strong>，静态函数表示了整个类范围意义上的信息。<strong>而this指针却实实在在的对应一个对象，所以this指针不能被静态函数使用了</strong>，同理，全局函数也一样。</p>
<p><strong><em>注意：</em></strong>在静态成员函数的实现中不能直接引用类中说明的非静态成员，但可以引用类中说明的静态成员。非静态成员函数即可以引用类中静态成员和非静态成员（这点非常重要）</p>
<h6 id="this指针什么时候创建的">8.2.4 this指针什么时候创建的</h6>
<p><strong><code>this</code>在成员函数的开始执行前构造的，在成员的执行结束后清除</strong>。<code>this</code>指针只有在成员函数中才有定义。因此你获得一个对象后，不能通过对象使用<code>this</code>指针。所以，我们也无法知道一个对象的this指针的位置（只有在成员函数里才有<code>this</code>指针的位置，<code>this</code>指针存于寄存器中）。</p>
<p>当然，在成员函数里，是可以知道<code>this</code>指针的位置的（可以<code>&amp;this</code>获得)，也可以直接使用的: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个返回this对象的函数：</span></span><br><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">	units_sold+=rhs.units_sold;		<span class="comment">//把rhs的成员加到this对象的成员上</span></span><br><span class="line">	revenue+=rhs.revenue;			<span class="comment">//同理</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;					<span class="comment">//返回调用该函数的对象（引用）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="类相关的非成员函数">8.3类相关的非成员函数</h5>
<p>类的定义常常需要辅助函数（非成员函数），它们的声明要与类声明在同一头文件中。最常用的就是输入输出的非成员函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream &amp;is,Sales_data&amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> price=<span class="number">0</span>;</span><br><span class="line">	is&gt;&gt;item.BookNO&gt;&gt;item.units_sold&gt;&gt;price;</span><br><span class="line">	item.revenue=price*item.units_sold</span><br><span class="line">	<span class="keyword">return</span> is</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="built_in">print</span>(ostream &amp;os,Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	os&lt;&lt;item.<span class="built_in">isbn</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.units_sold&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">	&lt;&lt;item.revenue&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.<span class="built_in">avg_price</span>();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Sales_data sum=lhs;		<span class="comment">//lhs拷贝给sum</span></span><br><span class="line">	sum.<span class="built_in">combine</span>(rhs);		<span class="comment">//将rhs的数据加到sum中，sum存放lhs和rhs和</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="类的静态成员">8.4类的静态成员</h5>
<h6 id="什么是静态成员声明">8.4.1 什么是静态成员（声明）</h6>
<p><strong>有时候我们需要一些成员与类本身直接相关</strong>，而不是与类的各个对象保持关联。在该成员变动时，希望每个对象都能使用新值，就如银行利率。这个时候就引入了类的静态成员 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			amount+=amoubt*interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">static</span>	<span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string owner;</span><br><span class="line">		<span class="type">double</span> amount;</span><br><span class="line">		<span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="title">doubleinitRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 类的静态成员存在于任何对象之外，对象中不包含任何与静态成员有关的数据（），<strong>因此<code>Account</code>的对象只包含了两个数据成员<code>owner和amount</code>。<code>interestRate</code>被所有对象共享。</strong> 静态成员函数也不与对象绑定，它们不包含<code>this</code>指针，所以静态成员函数不能被声明为<code>const</code>。</p>
<h6 id="定义静态成员及类外初始化静态成员变量和静态成员函数">8.4.2 定义静态成员及类外初始化（静态成员变量和静态成员函数）</h6>
<p>和其他成员函数一样，可在内部定义也可在外部定义（在外部时，不可重复使用static关键字，static只出现在内部声明语句） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Account::rate</span><span class="params">(<span class="type">double</span> newRate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	interestRate=newRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 静态成员不属于类的对象，因此它们并不是在创建对象时被定义的，<strong>即它们不是由类的构造函数初始化的</strong>。<strong>类似于全局变量，静态数据成员定义在任何函数之外，它一旦被定义，就一直存在于程序整个生命周期，它只能被定义一次</strong>。（一般在类外初始化） 如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> Account::interestRate=<span class="built_in">initRate</span>();		<span class="comment">//定义并初始化一个静态成员</span></span><br></pre></td></tr></table></figure></p>
<h6 id="使用静态成员">8.4.3 使用静态成员</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用域运算符直接访问静态成员</span></span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    r=Account::<span class="built_in">rate</span>();</span><br><span class="line"><span class="comment">//使用类的对象、引用或者指针访问</span></span><br><span class="line">	Account ac1;</span><br><span class="line">	Account *ac2=&amp;ac1;</span><br><span class="line">	r=ac1.<span class="built_in">rate</span>();</span><br><span class="line">	r=ac2-&gt;<span class="built_in">rata</span>();</span><br><span class="line">成员函数不需要使用域运算符，可直接使用静态成员</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			amount+=amoubt*interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> interestRate;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构造函数">8.5 构造函数</h5>
<p>每个类都定义了它的对象被初始化的方式，类是通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数就是<strong>构造函数</strong>。<strong>构造函数的任务就是初始化对象的数据成员，只要类的对象被创建，就会执行构造函数----&gt;拷贝。</strong></p>
<ul>
<li><strong>构造函数</strong>：构造函数的名字与类名相同，没有返回(值）类型，不能被声明为<code>const</code>（const对象执行构造函数时，执行完毕才成为const对象）。</li>
<li><strong>拷贝和赋值：</strong>拷贝是构造行为，状态取决于用于构造的对象；赋值是对已构造对象进行状态更新。赋值侧重于更新，构造侧重于构造。</li>
</ul>
<h6 id="默认构造函数--也可写成默认实参的构造函数还是默认构造函数">8.5.1 默认构造函数--&gt;也可写成默认实参的构造函数（还是默认构造函数）</h6>
<p>在没有为对象提供初始值，类没有显示地定义任何构造函数，编译器会为我们隐式的定义一个构造函数，称为合成的默认构造函数。其初始化规则：</p>
<ul>
<li>类内如果存在初始值，用它来初始化成员</li>
<li>没有，默认初始化（为0）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;		<span class="comment">//Sales_data类</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Sales_data</span>()=<span class="keyword">default</span>;	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> std::stsring&amp; s,<span class="type">unsigned</span> n,<span class="type">double</span> p):</span><br><span class="line">		<span class="built_in">BookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n) &#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> BookNo;&#125;</span><br><span class="line">	<span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	std::string BookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>c++11新标准，可以通过=default来要求编译器生成合成的默认构造函数（default在类内部声明为内联的，在外部就不是）。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;</span><br></pre></td></tr></table></figure> 同时上面这条语句中，在<strong>初始化列表</strong>中有数据成员<code>units_sold,revenue</code>被忽略，那么他等价于<code>Salse_data(const std::string&amp; s):BookNo(s)，units_sold(0),revenue(0) &#123;&#125;;</code></p>
<h6 id="构造函数初始值列表">8.5.2 构造函数初始值列表</h6>
<ul>
<li>冒号和花括号之间的部分。其负责为新创建的对象的一个或几个数据成员赋值。列表是是类内置成员的名字，其()括号内就为初始值（注意不是赋值而是初始化）。</li>
<li><strong><em>注意：列表对成员变量的初始化是按其类内声明顺序初始化，而不是列表顺序。</em></strong></li>
<li>使用初始化列表是直接初始化,因此具有更高的效率，而在函数体内是先初始化再赋值。存在效率的差异，如果是类对象，那么效率更低</li>
<li>构造函数的初始值列表解决了初始值必不可少的三种情况：</li>
</ul>
<ol type="1">
<li><strong>一是const或者引用成员，他们必须被初始化，因为在函数体内是赋值而不是初始化</strong>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况1</span></span><br><span class="line">Class  Test&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Test</span>(<span class="type">int</span> ii);	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> ci;		<span class="comment">//未被初始化</span></span><br><span class="line">		<span class="type">int</span> &amp;ri;			<span class="comment">//未被初始化</span></span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> cr=<span class="number">10</span>;	<span class="comment">//已类内初始化</span></span><br><span class="line">&#125;;</span><br><span class="line">Test:<span class="built_in">Test</span>(<span class="type">int</span> ii)&#123;</span><br><span class="line">	i=ii;</span><br><span class="line">	ci=ii;		<span class="comment">//错误，不能给const赋值</span></span><br><span class="line">	ri=i;			<span class="comment">//错误，引用必须创建时被初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.<strong>二是当成员属于某种类类型且该类型没有默认构造函数，也必须将这个成员初始化。</strong>尝试在内部通过赋值的方式初始化，但没有默认的构造函数，即参数列表为空，那么test就会首先被默认初始化，但是Test类没有默认的构造函数从而出现错误，所以初始化只能放在列表中。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;	<span class="comment">//无默认构造函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Test&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mytest</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mytest</span>():<span class="built_in">test</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#123;       <span class="comment">//初始化ok</span></span><br><span class="line">        <span class="comment">//test(Test(1,2,3));//error: no match for call to &#x27;(Test) (Test)&#x27;</span></span><br><span class="line">        <span class="comment">//test=Test(12,3,4);//error: no matching function for call to &#x27;Test::Test()&#x27;</span></span><br><span class="line">        <span class="comment">//test(1,2,3);//error: no match for call to &#x27;(Test) (int, int, int)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Test test; <span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 3.<strong>三是需要初始化的数据成员是对象(存在继承关系，继承时调用基类构造函数)原因同样是创建对象时，要初始类成员的每一个成员</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Test</span> (<span class="type">int</span> x)&#123; int_x = x;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt; int_x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> int_x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mytest</span>:<span class="keyword">public</span> Test&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mytest</span>():<span class="built_in">Test</span>(<span class="number">110</span>)&#123;<span class="comment">//打印出110</span></span><br><span class="line">      <span class="comment">//Test(110);  //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用 。不报错但打印随机数：14887136</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：从无到有叫初始化，初始化（调用拷贝构造函数）创建了新对象；赋值（调用赋值操作符）没有创建新对象，而是对已有的对象赋值。</em></strong></p>
<h6 id="类外构造函数的定义">8.5.3 类外构造函数的定义</h6>
<p>以istream为参数的的构造函数因为要执行一些实际操作。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非成员函数</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">((istream &amp;is,Sales_data&amp; item)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">double</span> price=<span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	is&gt;&gt;item.BookNO&gt;&gt;item.units_sold&gt;&gt;price;</span></span></span><br><span class="line"><span class="params"><span class="function">	item.revenue=price*item.units_sold</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">return</span> is</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//构造函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">Sales_data::Sales_data(std::istream &amp;is)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	read(is,*<span class="keyword">this</span>);	<span class="comment">//read函数的作用是从is中读取一条交易信息后存入this</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure> 该构造函数的初始值列表是为空的，但对象的成员仍能够初始化。第二个参数的<code>this</code>是一个<code>Sale_data</code>对象的引用。 其他的诸如<strong>拷贝构造、赋值构造、析构和移动构造</strong>放在后面的<strong>拷贝控制</strong>详细讲述。</p>
<h6 id="委托构造函数">8.5.4 委托构造函数</h6>
<p>c++11新标准扩展了构造函数初始值的功能，使得我们可以定义委托构造函数。所谓的委托构造函数其实就是一个构造函数的任务交给零一构造函数去完成， <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">		<span class="built_in">Sales_data</span>(sting s,<span class="type">unsigned</span> cnt,<span class="type">double</span> price):</span><br><span class="line">			<span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(cnt),<span class="built_in">revenue</span>(cny*price)&#123;&#125;</span><br><span class="line">		<span class="comment">//委托构造函数</span></span><br><span class="line">		<span class="built_in">Sales_data</span>():<span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">		<span class="built_in">Sales_data</span>(string s):<span class="built_in">Sales_data</span>(s,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="转换构造函数">8.5.5转换构造函数</h6>
<p>如果构造函数只接受一个实参，<strong>那么实际上定义了转换为此类类型的隐式转换机制</strong>。这种构造函数称为<strong>转换构造函数</strong>，但只允许一步类类型转换。如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;<span class="comment">//这个构造函数。支持了转换构造,参数为const</span></span><br></pre></td></tr></table></figure> 在类中我们定义了一个<code>Sales_data &amp;combine(const Sales_data&amp;);</code>函数,参数为<code>const</code>，如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_data item;	<span class="comment">//执行了默认构造函数</span></span><br><span class="line">string null_book=<span class="string">&quot;9-999-999&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(null_book);<span class="comment">//在这里combine函数的参数时Sales_data类型，因此这里用单参转换构造函数构造了一零时Sales_data对象，即null_book隐式转换为Sales_data类型</span></span><br></pre></td></tr></table></figure> 在这里<code>combine</code>函数的参数实际是<code>Sales_data</code>类型，因此这里调用单参转换构造函数<code>Salse_data(const std::string&amp; s):BookNo(s)&#123;&#125;;</code>构造了一零时<code>Sales_data</code>对象，即null_book隐式转换为Sales_data类型,然后在执行该语句。 <strong><em>注意：形参必须声明为<code>const</code></em></strong></p>
<h6 id="深浅拷贝区别">8.5.6 深浅拷贝区别</h6>
<p><strong>背景：</strong></p>
<ol type="1">
<li><strong>默认的拷贝构造函数进行了简单的赋值操作（浅拷贝）</strong></li>
<li><strong>浅拷贝的问题：当多个对象执行默认拷贝构造函数时会多次释放同一个分配的内存空间</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> age)&#123;</span><br><span class="line">		pName=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName,name);</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Student</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(pName);</span><br><span class="line">			pName=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;小明&quot;</span>，<span class="number">22</span>)</span>；</span></span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;		<span class="comment">//执行默认拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p>如下图，两个对象的<code>name</code>指针指向同一块内存。在释放时，这会导致同一块内存会被释放两次，这是不允许的。 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/copy.png" width="600" align="middle"> <strong>深拷贝解决浅拷贝问题：自己写拷贝构造函数</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> Student &amp;stu)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//1.申请空间</span></span><br><span class="line">	pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(stu.pName) + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//2.拷贝数据</span></span><br><span class="line">	<span class="built_in">strcpy</span>(pName, stu.pName);</span><br><span class="line">	age = stu.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="访问控制和封装">8.6 访问控制和封装</h5>
<h6 id="封装">8.6.1 封装</h6>
<p>我们为类定义了接口，但并没有机制制约用户使用这些接口。使用访问说明符加强类的封装性：</p>
<ul>
<li><code>public</code>:<code>public</code>说明符之后的成员在整个程序可被访问</li>
<li><code>private</code>:可以被类的成员函数访问，但不能被使用该类的代码访问。</li>
<li><code>protected</code>:被该关键词修饰的成员不能被外部访问，但是能够给成员函数和继承的类访问</li>
<li><code>class</code>:<code>class</code>和<code>struct</code>一样的作用,声明一个类，唯一不同是定义在第一个访问说明符之前的成员的访问权限不同<code>struct</code>是<code>public</code>,<code>class</code>是<code>private</code></li>
</ul>
<h6 id="友元">8.6.2 友元</h6>
<p>在真正的项目中，有一些一起声明在头文件的类的非成员函数，它们作为类的接口的一部分，想要访问该类的私有成员，但不是类的的成员，因此无法做到，而友元可以很好的解决这类问题：</p>
<p><strong>类可以允许其他类或者函数访问它的非公有成员，只要让这些类或函数成为该类的友员(friend)即可。友元函数必须被声明过。</strong>友元分为<strong>非成员函数友元、类友元和成员函数友元</strong>。</p>
<ul>
<li><p>非成员函数友元：即非成员函数在类内部声明<code>friends</code>。增加一条friend关键字开头的函数声明即可。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;		<span class="comment">//Sales_data类</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//三个非成员函数声明友元</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="built_in">Sales_data</span>()=<span class="keyword">default</span>;	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> std::stsring&amp; s,<span class="type">unsigned</span> n,<span class="type">double</span> p):</span><br><span class="line">	<span class="built_in">BookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n) &#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> BookNo;&#125;</span><br><span class="line">	<span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span>  <span class="type">const</span></span>;</span><br><span class="line">	std::string BookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li>类友元：即在类A中声明另一个类B为它的友元，那么类B可以访问类A的私有成员，但是A不能访问B的私有成员，如果要访问，那么应该也罢A声明为B的友元，即友元使单向的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	friends <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearA</span><span class="params">()</span></span>;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>成员函数友元:即将类A中声明一个类B的函数为友元，该函数能够访问A的私有成员 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">B::clearB</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong><em>注意:要使某个类成员函数为另一类的友元，则必须组织程序的结构使声明和定义符合</em></strong></p>
<ol type="1">
<li>首先要定义B类，其中声明<code>clearB</code>函数但不定义。（在<code>clearB</code>使用<code>A</code>的成员之前必须先声明<code>A</code>）</li>
<li>定义<code>A</code>类，包括对<code>clearB</code>的友元声明</li>
<li>最后定义<code>clearB</code></li>
</ol>
<h5 id="类的其他特性">8.7 类的其他特性</h5>
<h6 id="成员函数的重载">8.7.1 成员函数的重载</h6>
<p>成员函数可支持重载，参数不同即可以。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Screen</span>()=defalut;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">(<span class="type">char</span> s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(<span class="type">char</span> s,<span class="type">size_t</span> i)</span></span>;	<span class="comment">//成员函数重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="内联函数">8.7.2 内联函数</h6>
<p>在类中成为内联函数有两种：</p>
<ul>
<li>在类内定义的（隐式内联）</li>
<li>有inline关键字(显示内联）</li>
</ul>
<h6 id="可变数据成员">8.7.3 可变数据成员</h6>
<p>在类中，存在<code>const</code>函数防止类内成员在此函数的修改，但有时候对于有些成员我们希望在任何函数都能够得到可变的保证，即使是在<code>const</code>函数总，因此出现了<code>mutable</code>关键字。只有被该关键字修饰的成员变量无论在类的哪个成员函数内都能得到可修改的保证： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">get</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">		acces_time++;</span><br><span class="line">		<span class="keyword">return</span> acces_time;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">size_t</span> acces_time=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="聚合类">8.8 聚合类</h5>
<p>当一个类满足下述条件使，是聚合类（使用户可以直接访问其成员）：</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，也没有virtual函数。</li>
</ul>
<h4 id="io库">9.IO库</h4>
<h5 id="io类">9.1 IO类</h5>
<p>IO库设施和主要的类包括：</p>
<ul>
<li><code>ostream</code>类型，提供输出操作;<code>istream</code>类型，提供输入操作</li>
<li><code>cin</code>,一个<code>istream</code>对象，从标准输入读取数据;<code>cout</code>,一个<code>ostream</code>对象，向标准输出写入数;<code>cerr</code>，一个<code>ostream对</code>象，用于输出程序错误信息，写入到标准错误</li>
<li><code>&gt;&gt;</code>运算符，用于一个<code>istream</code>对象读取输入数据;<code>&lt;&lt;</code>运算符，用于一个<code>ostream</code>对象写入输出数据</li>
<li><code>getline()</code>,从一个给的的<code>istream</code>读取一行数据，存入一个给定的<code>string</code>对象。<code>getline(cin,s1)</code>; 读取内容，直到遇到换行符（换行符也被读取,但<code>s1</code>不存取换行符）。</li>
</ul>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/IO.png" width="600"></p>
<ul>
<li><code>iostream</code>定义了读写了基本类型</li>
<li><code>fstream</code>定义了读写命名文件的类型</li>
<li><code>sstream</code>定义了读写内存<code>string</code>对象的类型</li>
</ul>
<h5 id="条件状态">9.2 条件状态</h5>
<p>以前用条件判断语句<code>while(cin&gt;&gt;i);        //EOF时结束，即达到了文件结束跳出循环（ctrl+z)</code>。来判断流是否有效，但我们无法知道流的具体状态。所以有如下IO库条件状态。 IO库定义了一个与机器无关的<code>iostate</code>类型。它提供了表达流状态的完整功能<code>（badbit、failbit、eofbit、goodbit</code>:</p>
<ul>
<li><code>badbit</code>表示发生系统级的错误，如不可恢复的读写错误。通常情况下一旦<code>badbit</code>被置位，流就无法再使用了--4（代表数字）。</li>
<li><code>failbit</code> 表示发生可恢复的错误，如期望读取一个数值，却读出一个字符等错误。这种问题通常是可以修改的，流还可以继续使用---2。</li>
<li>当到达文件的结束位置时，<code>eofbit</code> 和 <code>failbit</code> 都会被置位---1。</li>
<li><code>goodbit</code> 被置位表示流未发生错误。如果<code>badbit failbit 和eofbit</code> 任何一个被置位，则检查流状态的条件会失败---0。</li>
</ul>
<p>对应的<code>bad(), fail(), eof(), good()</code>能检查对应位是否被置位，返回1表示被置位。<strong>但是，<code>badbit</code>被置位时，<code>fail()</code>也会返回1。所以使用<code>good()</code>和<code>fail()</code>是确定流能否使用的正确方法</strong>。实际上，流当做条件使用的代码就等价于<code>!fail()</code>。而且<code>eof()</code> 和<code>bad()</code> 操作只能表示特定的错误.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> std::ios;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> m=ios::badbit;			<span class="comment">//4</span></span><br><span class="line">	ios::iostate n=ios::failbit;	<span class="comment">//2</span></span><br><span class="line">	ios::iostate m=ios::eofbit;		<span class="comment">//1</span></span><br><span class="line">	ios_base::iostate p=ios::goodbit;	<span class="comment">//0</span></span><br><span class="line">	<span class="type">int</span> number</span><br><span class="line">	cin&gt;&gt;number;			<span class="comment">//输入字符串 ada</span></span><br><span class="line">	<span class="keyword">auto</span> s=cin.<span class="built_in">rdstate</span>();	<span class="comment">//被置2</span></span><br><span class="line">	cin.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">auto</span> x=cin.<span class="built_in">rdstate</span>();	<span class="comment">//0</span></span><br><span class="line">	cin.<span class="built_in">setstate</span>(s);		<span class="comment">//置2</span></span><br><span class="line">	<span class="keyword">auto</span> y=cin.<span class="built_in">rdstate</span>();	<span class="comment">//为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="管理输出缓冲">9.3 管理输出缓冲</h5>
<p>输出缓存刷新是指数据数据真正写到输出设备和文件，在C++中导致输出缓存刷新的的原因有：</p>
<ul>
<li>程序正常结束，作为<code>main</code>函数的<code>retrun</code>操作的一部分，缓存刷新执行</li>
<li>缓冲区满使，需要刷新，而后新的数据才能继续写入缓冲区</li>
<li>显式调用<code>endl</code>刷新缓冲区</li>
<li>每个输出操作之后，可使用操纵符<code>unitbuf</code>设置流的内部状态，来清空缓冲区。默认下，对<code>cerr</code>是设置<code>unitbuf</code>的，因此对于<code>cerr</code>来说写入到<code>cerr</code>的内容都是立即刷新的</li>
<li>一个输出流可能关联到另一个流。当读写被关联流时，关联到的流的缓冲区会被刷新。比如默认情况下，<code>cin</code>和<code>cerr</code>都被关联到<code>cout</code>,因此读<code>cin</code>或<code>cerr</code>都会导致<code>cout</code>的缓冲区被刷新</li>
</ul>
<p>每个输出流都管理一个缓冲区，最重要得是刷新缓冲区：</p>
<ul>
<li><code>endl</code>:输出操作后刷新缓冲区（会额外输出换行符）</li>
<li><code>flush</code>:输出操作后刷新缓冲区（没有额外字符）</li>
<li><code>ends</code>:输出操作后刷新缓冲区(额外输出空格符）</li>
</ul>
<h6 id="nitbuf操作符每次输出都会flush">9.3.1 nitbuf操作符：每次输出都会flush</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;unitbuf;	<span class="comment">//所有输出操作后会立即刷新缓冲区</span></span><br><span class="line">cout&lt;&lt;nounitflush;	<span class="comment">//回到正常模式</span></span><br></pre></td></tr></table></figure>
<h6 id="关联输入输出流">9.3.2 关联输入输出流</h6>
<p>标准库默认将cout于cin关联在一起。手动关联操作<code>tie</code>，有带参和不带参两个版本 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不带参：返回指向输出流得指针</span></span><br><span class="line"><span class="comment">//带参：接受一个ostream得指针参数，将对象关联到该输出流</span></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);</span><br></pre></td></tr></table></figure></p>
<h5 id="文件输入输出">9.4 文件输入输出</h5>
<ul>
<li>ifstream从一个给定文件读取数据</li>
<li>ofstream向一个给定文件写入数据</li>
<li>fstream向给定文件读写</li>
</ul>
<p>除了继承了iostream类型的行为之外，fstream中定义的类型还增加了新的成员来管理与流关联的文件。如下： <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/fstream.png" width="600"></p>
<h6 id="继承关系">9.4.1 继承关系</h6>
<p>因为<code>fstream</code>继承自<code>iostream</code>，<code>ifstream</code>继承自<code>istream</code>，<code>ofstream</code>继承自<code>ostream</code>。所以由继承机制的：<strong>派生类（继承类）的对象可以当作其基类（被继承类）的对象来使用</strong>。所以在参数为<code>ostream&amp;</code>的函数中允许我们传入一个<code>ofstream</code>型参数，同理其他两个也是一样 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s=<span class="string">&quot;xxx/xxxx/xxx.txt&quot;</span>;</span><br><span class="line">	<span class="function">fstream <span class="title">f</span><span class="params">(s)</span></span>;</span><br><span class="line">	<span class="built_in">func</span>(f);	<span class="comment">//允许传入一个fstream参数，派生类像基类转换</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(iostream&amp; io)</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="open和close">9.4.2 open和close</h6>
<p>若我们定义了一个空文件流对象: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fstream file;</span><br></pre></td></tr></table></figure> 我们可以使用<code>open</code>来将<code>file</code>与相应的文件关联起来 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file.<span class="built_in">open</span>(filename);	<span class="comment">//若调用open失败，则failbit会被置位</span></span><br></pre></td></tr></table></figure> 所以我们在执行open后，判断流的状态是一个好习惯，流的状态有效，才能对流执行操作。操作完后手动关闭。当流对象离开作用域域是，流对象会被销毁，结果是会自动调用<code>close</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(file)&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">if</span>(!file.failbit)&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure> <strong><em>注意：<code>ofstream</code>是对写文件，从程序写出到文件，<code>ifstream</code>是从文件读入到程序中。这点不要搞混</em></strong></p>
<h6 id="文件模式">9.4.3 文件模式</h6>
<p>每个流都有关联的文件模式，用来指出如何使用文件。<code>ofstream</code>关联<code>out</code>、<code>ifstream</code>关联<code>in</code>、<code>fstream</code>关联<code>in</code>和<code>out</code>。 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/filemode.png" width="600"></p>
<ul>
<li>只可以对<code>ofstream</code>或<code>fstream</code>对象设定<code>out</code>模式;只可以对<code>ifstream</code>或<code>fstream</code>对象设定<code>in</code>模式</li>
<li>只有当<code>out</code>被设定时才可设定<code>trunc</code>模式</li>
<li><code>trunc</code>没被设定，<code>app</code>就可设定。且在<code>app</code>模式下，文件也是<code>out</code>模式下打开(open)</li>
<li>即使没有设定<code>trunc</code>模式，<code>out</code>模式打开（open)的文件也会被截断。所以为保留out模式打开的文件，需要指定<code>app</code>模式（或同时指定in模式）</li>
<li><code>ate</code>和<code>binary</code>模式可用于任何文件流，与任何模式组合。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IOFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fstream isfile;</span><br><span class="line">	ofstream out;</span><br><span class="line">	ifstream in;</span><br><span class="line">	out.<span class="built_in">open</span>(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (out) &#123;	<span class="comment">//判断是否打开成功</span></span><br><span class="line">		out &lt;&lt; <span class="string">&quot;out成功了&quot;</span> &lt;&lt; endl;</span><br><span class="line">		out.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	isfile.<span class="built_in">open</span>(<span class="string">&quot;D:\\test.txt&quot;</span>, std::fstream::app);</span><br><span class="line">	<span class="keyword">if</span> (isfile) &#123;</span><br><span class="line">		isfile &lt;&lt; <span class="string">&quot;isfile也成功了&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string s;</span><br><span class="line">		isfile &gt;&gt; s;</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;	<span class="comment">//打印换行，因为写入时已经指定app在末尾</span></span><br><span class="line">		isfile.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	in.<span class="built_in">open</span>(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (in) &#123;</span><br><span class="line">		string s;</span><br><span class="line">		in &gt;&gt; s;</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">		in.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>out会发生截断是因为每次写操作没有定位到文件末尾，所以防止截断是设定app模式</p>
<h5 id="string流">9.5 string流</h5>
<p><strong>与<code>fstream</code>类似，<code>string</code>也分别继承于<code>iostream</code>。</strong><code>istringstream</code>从<code>string</code>读取数据，<code>ostringstream</code>向<code>string</code>写入，<code>stringstream</code>即可写入也可读取。 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/stringstream.png" width="600"></p>
<h5 id="常用成员函数">9.6 常用成员函数</h5>
<h6 id="istream的成员函数">9.6.1 <code>istream</code>的成员函数:</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>() <span class="comment">//一次只能读取一个字符</span></span><br><span class="line">cin.<span class="built_in">get</span>(一个参数) <span class="comment">//读一个字符</span></span><br><span class="line">cin.<span class="built_in">get</span>(两个参数) <span class="comment">//可以读字符串</span></span><br><span class="line">cin.<span class="built_in">getline</span>()<span class="comment">//取一行，换行符丢弃</span></span><br><span class="line">cin.<span class="built_in">ignore</span>()<span class="comment">//忽略</span></span><br><span class="line">cin.<span class="built_in">peek</span>()<span class="comment">//偷窥，只看不从缓冲区拿走</span></span><br><span class="line">cin.<span class="built_in">putback</span>()<span class="comment">//放回缓冲区</span></span><br></pre></td></tr></table></figure>
<h6 id="ostream可用">9.6.2 <code>ostream</code>可用</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过流成员函数实现格式化的输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">99</span>;</span><br><span class="line">	cout.<span class="built_in">width</span>(<span class="number">20</span>);<span class="comment">//设置宽度</span></span><br><span class="line">	cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);<span class="comment">//填充</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::left);<span class="comment">//让数据在左边</span></span><br><span class="line">	cout.<span class="built_in">unsetf</span>(ios::dec);<span class="comment">//卸载十进制</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::hex);<span class="comment">//安装十六进制</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::showbase);<span class="comment">//显示基数</span></span><br><span class="line">	cout.<span class="built_in">unsetf</span>(ios::hex);<span class="comment">//卸载十六进制</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::oct);<span class="comment">//安装八进制</span></span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过控制符来格式化输出，引入头文件iomanip</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//重载了&lt;&lt;运算符</span></span><br><span class="line">	<span class="type">int</span> num = <span class="number">99</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">20</span>);<span class="comment">//设置宽度</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;~&#x27;</span>);<span class="comment">//填充</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::showbase);<span class="comment">//显示基数</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::left);<span class="comment">//让数据在左边</span></span><br><span class="line">	cout &lt;&lt; hex;<span class="comment">//六十进制</span></span><br><span class="line">	cout &lt;&lt; oct;<span class="comment">//八进制</span></span><br><span class="line">	cout &lt;&lt; dec;<span class="comment">//十进制</span></span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="fstrem常用">9.6.3 <code>fstrem</code>常用</h6>
<p>主要读写：其有write()/read()成员函，重载&lt;&gt;运算符 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名:悟空&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Maker <span class="title">m1</span><span class="params">(<span class="string">&quot;悟空&quot;</span>,<span class="number">18</span>)</span>；</span></span><br><span class="line"><span class="function">ofstream ofs</span>;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc | ios::binary);</span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;m1, <span class="built_in">sizeof</span>(Maker));</span><br></pre></td></tr></table></figure> <strong><em>注：当文件读写时，类中的成员变量不要有string类型，因为：</em></strong></p>
<ul>
<li>①string类中有一个成员指针char*,该指针指向存储字符串的空间</li>
<li>②当我们把string类的数据存储到文件中，再读出来时，不能保证指针有效</li>
</ul>
<h4 id="动态内存">10.动态内存</h4>
<h5 id="生命周期">10.1 生命周期</h5>
<p><strong>目前的我们接触到的对象或者静态static都有着严格的生命周期：</strong></p>
<ul>
<li><strong>全局：</strong>程序启动时自动分配，程序结束时销毁</li>
<li><strong>局部对象：</strong>进入其所定义的程序时被创建，离开块时销毁</li>
<li><strong>静态：</strong>第一次使用前分配，程序结束时销毁</li>
</ul>
<p>上述中的变量只使用了静态内存和栈内存。它们会自动创建和销毁。静态内存保存局部static、类static成员以及定义在任何函数之外的变量。栈内存保存定义在函数内的非static对象</p>
<p>除了上述的自动分配外，<strong>c++还支持动态分配对象</strong>。（其生命周期与它们在哪创建无关，只有显式的被释放时，这些对象才会被销毁）。<strong>它们被分配在内存池，称作自由空间或堆。程序用堆来存储动态分配</strong>。</p>
<h5 id="new动态内存">10.2 new动态内存</h5>
<h6 id="直接动态内存管理">10.2.1 直接动态内存管理</h6>
<p>c++的动态内存管理是通过一对运算符来完成：</p>
<ul>
<li><code>new</code>,在动态内存中为对象分配空间并返回一个指向该对象的指针</li>
<li><code>delete</code>,接受一个动态对象的指针，销毁该对象，并释放关联的内存。</li>
</ul>
<p>不再使用的动态内存应及时释放，否则会造成内存泄漏。释放<code>delete</code>的时机要适宜，否则在还有指针引用内存的时候释放，会导致引用非法内存的指针错误.<strong>内存泄漏：分配内存使用完毕后不释放将引起内存泄漏，会榨干内存。 相对于智能指针，直接管理内存的类与使用智能指针的类不同，他们不能依赖类拷贝、赋值和销毁操作的任何默认定义。</strong>虽然如此，但有时候我们不得不用的<code>new与delete</code>。在后面我们还会介绍跟高级的内存分配工具<code>allocator类</code></p>
<h6 id="使用new动态分配和初始化对象">10.2.2 使用new动态分配和初始化对象</h6>
<p>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是<strong>返回一个指向该对象的指针</strong>。默认情况下，动态分配的对象是默认初始化的，这意味着<strong>内置类型或组合类型的对象的值是未定义的，而类类型对象将默认构造函数进行初始化</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string *ps=<span class="keyword">new</span> string;	<span class="comment">//初始化为空的string。类类型--&gt;默认构造,等价于与值初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>;	<span class="comment">//p指向一个动态分配、未初始化的无名对象。内置类型--&gt;值初始化</span></span><br></pre></td></tr></table></figure> 也可以直接初始化一个动态分配的对象： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line">string *ps=<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;trluper&quot;</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;* pv=<span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure> <strong><em>注意：对于内置类型，注意值初始化和默认初始化的区别：</em></strong></p>
<ul>
<li>对于定义了自己的构造函数的类类型（如string），要求值初始化是没有意义的，因为不管采用什么形式，对象都会通过默认构造函数来初始化；</li>
<li>对于内置类型，值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。</li>
<li>对于类中那些依赖于编译器合成的默认构造函数的内置类型对象，如果它们未在类内初始化，它们的值也是未定义的</li>
</ul>
<p>如果我们提供了一个括号包围的初始化器，就可以使用auto，此时初始化器可以推断我们想要分配的对象的类型，<strong>只有当括号中仅有单一初始化器才能使用auto</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1=<span class="keyword">new</span> <span class="built_in">auto</span>(obj);</span><br><span class="line"><span class="keyword">auto</span> p2=<span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125;;	<span class="comment">//错误，括号中只能有单一初始化器</span></span><br></pre></td></tr></table></figure></p>
<h6 id="动态分片的const对象">10.2.3 动态分片的const对象</h6>
<p><strong>动态分配的const对象必须进行初始化</strong>。对于定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* pci=<span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);		<span class="comment">//显示初始化</span></span><br><span class="line"><span class="type">const</span> string *pcs=<span class="keyword">new</span> <span class="type">const</span> string;		<span class="comment">//隐式</span></span><br></pre></td></tr></table></figure></p>
<h6 id="内存耗尽">10.2.4 内存耗尽</h6>
<p>默认情况下，<strong>如果<code>new</code>不能分配所要求的内存空间，会抛出一个类型为<code>bad_alloc</code>的异常</strong>。我们也可以改变使用<code>new</code>的方式来阻止它抛出异常（称为定位new)。<code>bad_alloc</code>和<code>nothrow</code>都定义在头文件<code>new</code>中： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> *p1=<span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//如果分配失败，会抛出一个类型为`bad_alloc`的异常</span></span><br><span class="line"><span class="type">int</span> *p2=<span class="built_in">new</span>(nothrow) <span class="type">int</span>;<span class="comment">//如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure></p>
<h6 id="释放内存">10.2.5 释放内存</h6>
<p><code>delete</code>表达式接受一个指针，指向我们想要释放的对象:<code>delete p</code>。 <strong>指针值和<code>delete</code>：</strong>传递给<code>delete</code>的指针必须指向动态分配的内存，或者是一个空指针。释放一块并<code>非new</code>分配的内存，或者将相同的指针值释放多次，其行为是未定义的。虽然一个<code>const对象</code>的值不能被改变，但它本身是可以被销毁的.<code>delete</code>条件有：</p>
<ul>
<li>应与<code>new</code>配对使用，既只能释放<code>new</code>分配得内存</li>
<li>不要再次释放已经释放得内存</li>
<li>如果使用<code>new[]</code>分配动态数组，应用<code>delete[]</code>释放</li>
<li>对空指针使用<code>delete</code>是安全的</li>
</ul>
<p>不需要再使用该动态分配的内存时，必须释放，否则容易内存泄漏！！以下是两个版本的use_factory函数。（p是已经new分配好的返回指针） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_factory</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//函数结束，不再需要，则释放</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">use_factory</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//函数结束，仍然需要，则返回后由调用这释放</span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="动态数组">10.2.6 动态数组</h6>
<p>某些应用需要一次性为很对对象分配内存（如vector)。为了支持这种需求，c++语言和标准库提供两者方法：</p>
<ul>
<li>分配和初始化一个对象数组</li>
<li>应用allocator类</li>
</ul>
<p>通常第二种法方会提供更好的性能和更灵活的管理内存能力，我们将在后面介绍，同时<strong>“STL源码剖析”</strong>会更详细。这类我们说说<code>new[]</code></p>
<p><strong>new和数组</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[size];		<span class="comment">//返回的指向第一个元素对象指针</span></span><br><span class="line"><span class="comment">//初始化动态分配对象的数组</span></span><br><span class="line"><span class="comment">//不加括号——默认初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];		<span class="comment">//默认初始化</span></span><br><span class="line"><span class="comment">//大小之后加一对空括号——值初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]();		<span class="comment">//10个值初始化为0</span></span><br><span class="line"><span class="comment">//大小之后跟一个花括号列表——初始化器初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放，使用特殊的delete来释放动态数组，在delete前加上一个空方括号对(方括号必须加上)</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure> 当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。但此指针不能解引用——毕竟它不指向任何元素。</p>
<p><strong><em>注意：</em></strong>我们得到的时数组元素的指针，而不是数组的对象，所以我们不能调用标准库函数中的<code>begin()和end()</code>，也不能使用<code>范围for循环</code>。</p>
<h6 id="placement-new">10.2.7 placement new</h6>
<p><code>placement new</code>相当于C语言中的<code>realloc</code>，在已有空间的基础上，重新分配一个空间，可以不破坏原来数据，也可以把数据全部用新值覆盖。这个操作就是把已有的空间当成一个缓冲区来使用，这样子就减少了分配空间所耗费的时间，因为直接用new操作符分配内存的话，在堆中查找足够大的剩余空间速度是比较慢的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//就是在指针p所指向的内存空间创建一个T1类型的对象，但是对象的内容是从T2类型的对象转换过来的,</span></span><br><span class="line"><span class="comment">//就是在已有空间的基础上重新调整分配的空间，类似于realloc函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _construct(T1 * p, <span class="type">const</span> T2&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">new</span>(p) <span class="built_in">T1</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="三种new重要">10.2.8 三种new(重要)</h6>
<p><code>new</code>存在三种操作符，其含义和应用的场景都不同。在这里我们必须再次提到<code>new operator</code>、<code>operator new</code>和<code>placement new</code>三种<code>new</code>。在前面我们介绍的都是具有构造效果的<code>new operator</code></p>
<ul>
<li><p><code>new operator</code>指的就是new操作，使用它会经过两个步骤：一是调用<code>::operator new</code>操作符申请内存；二是使用类型的构造函数对内存地址进行构造。‘new operator`操作符不能被重载 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">classA* p=<span class="keyword">new</span> <span class="built_in">classA</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>operator new</code>操作符是单纯的申请内存，相当于C当中的<code>malloc函数</code>，<code>operator new</code>可以重载。<code>::operator new</code>和<code>::operator delete</code>前面加上<code>::</code>表示全局，使用时就像<code>malloc</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *tmp=(<span class="type">int</span>*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size*<span class="built_in">siezeof</span>(<span class="type">int</span>))));</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>placement new</code>仅仅返回已经申请好内存的指针，它通常应用在对效率要求高的场景下，提前申请好内存，能够节省申请内存过程中耗费的时间</p></li>
</ul>
<h5 id="new-operator与c的malloc的比较">10.3 new operator与C的malloc的比较</h5>
<p>首先我们来看<code>operator new</code>生成的源码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GLIBCXX_WEAK_DEFINITION <span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> sz)</span> _<span class="title">GLIBCXX_THROW</span> <span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">void</span> *p;</span><br><span class="line">  <span class="comment">/* malloc (0) is unpredictable; avoid it.  */</span></span><br><span class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>)</span><br><span class="line">    sz = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (__builtin_expect ((p = <span class="built_in">malloc</span> (sz)) == <span class="number">0</span>, <span class="literal">false</span>))<span class="comment">//底层仍然使用malloc</span></span><br><span class="line">    &#123;</span><br><span class="line">      new_handler handler = std::<span class="built_in">get_new_handler</span> ();</span><br><span class="line">      <span class="keyword">if</span> (! handler)</span><br><span class="line">	_GLIBCXX_THROW_OR_ABORT(<span class="built_in">bad_alloc</span>());</span><br><span class="line">      <span class="built_in">handler</span> ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从上面可以看到operator new的内部实现仍然使用<code>malloc</code>，也就不奇怪new的行为像<code>malloc</code>。</p>
<p>这里主要介绍<code>new operator</code>与malloc主要区别如下：</p>
<ul>
<li><code>new operator</code>分配内存按照数据类型进行分配，<code>malloc</code>分配内存按照指定的大小分配；</li>
<li><code>new</code>返回的是指定对象的指针，而<code>malloc</code>返回的是void*，因此malloc的返回值一般都需要进行类型转化。</li>
<li><code>new</code>不仅分配一段内存，而且会调用构造函数，<code>malloc</code>不会。</li>
<li><code>new</code>分配的内存要用<code>delete</code>销毁，<code>malloc</code>要用<code>free</code>来销毁；<code>delete</code>销毁的时候会调用对象的析构函数，而<code>free</code>则不会。</li>
<li><code>new</code>是一个操作符可以重载，内部实现仍然使用<code>malloc</code>这个库函数。</li>
<li><code>malloc</code>分配的内存不够的时候，可以用<code>realloc</code>扩容。new则能使用<code>replacement new</code>方式来到底<code>realloc</code>功能</li>
<li><code>new</code>如果分配失败了会抛出<code>bad_malloc</code>的异常，而<code>malloc</code>失败了会返回<code>NULL</code>。</li>
<li>8、申请数组时： <code>new[]</code>一次分配所有内存，多次调用构造函数，搭配使用<code>delete[]</code>，<code>delete[]</code>多次调用析构函数，销毁数组中的每个对象。而<code>malloc</code>是通过<code>free(p)</code>来释放。</li>
</ul>
<h5 id="shared_ptr智能指针">10.4 shared_ptr智能指针</h5>
<p>为了更安全地使用动态内存，新标准库提供了两种智能指针。智能指针类似于常规指针，<strong>但区别是它负责自动释放所指向的对象：</strong></p>
<ul>
<li><code>shared_ptr</code>,它允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code>，独占一个对象（一个指针指向一个对象）</li>
<li><code>weak_ptr</code>,弱引用，指向<code>shared_ptr</code>所过来的对象</li>
</ul>
<p>上述的三种类型都定义在<code>memory</code>头文件中</p>
<h6 id="shared_ptr类">10.4.1 shared_ptr类</h6>
<p>类似于vector,智能指针也是模板。使用该类的理由有以下几点：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; p1;		<span class="comment">//p1指向string</span></span><br><span class="line">shared_ptr&lt;list&lt;T&gt;&gt; p2;		<span class="comment">//指向int的list</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/shared_ptr.png" width="700"></p>
<h6 id="make_shared函数">10.4.2 make_shared函数</h6>
<p>最安全的分配和使用动态内存的方法是调用该函数。<code>make_shared&lt;T&gt;(args)</code>函数在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hared_ptr&lt;<span class="type">int</span>&gt; p3=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//指向一个值为42的int的shared_ptr</span></span><br><span class="line">shared_ptr&lt;string&gt; p4=<span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">//指向一个值为9999999999的string</span></span><br><span class="line">share_ptr&lt;<span class="type">int</span>&gt; p5=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//指向值初始化为0的int</span></span><br><span class="line"><span class="keyword">auto</span> p5=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//指向值初始化为0的int</span></span><br></pre></td></tr></table></figure></p>
<h6 id="shared_ptr的拷贝和赋值和释放">10.4.3 shared_ptr的拷贝和赋值和释放</h6>
<ul>
<li><p>当进行拷贝和赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他<code>shared_ptr</code>指向相同的对象。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;		<span class="comment">//q是p的拷贝，递增了的计数器。对象此时有俩引用者</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>当给相应的<code>shared_ptr</code>赋予一个新值，计数器递减，当为0时，自动释放自己所管理的对象。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);		<span class="comment">//创建shared_ptr,为值43动态分配内存，拷贝</span></span><br><span class="line">p=r;		<span class="comment">//给p新赋值r,令他指向了另一个地址，此时</span></span><br><span class="line">			<span class="comment">//递增r所指向的引用计数</span></span><br><span class="line">			<span class="comment">//递减p原来的指向的对象的引用计数</span></span><br><span class="line">			<span class="comment">//若递减后为0，已没有引用者，自动释放</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong><code>销毁\释放原理</code></strong>：通过一个特殊的成员函数————析构函数完成销毁工作（每个类都有一个析构函数）。<strong>析构函数一般用来来释放对象所分配的的资源</strong>。<code>shared_ptr</code>的析构函数会递减它所指向对象的引用计数，当为0时，就会销毁对象，释放内存。</p>
<ul>
<li>当对象被销毁时，将递减其引用引用计数并检查它是否为0，如下这个例子： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;foo&gt; <span class="title">factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line"><span class="comment">//该函数返回shared_ptr</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_shared</span>&lt;foo&gt;(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">use_factory</span>(T arg)</span><br><span class="line">&#123;	</span><br><span class="line">shared_ptr&lt;Foo&gt; p=<span class="built_in">factory</span>(arg);</span><br><span class="line"><span class="comment">//为arg用智能指针动态分配内存，达到能够自动释放的目的</span></span><br><span class="line">&#125;<span class="comment">//对象p离开了此作用域被销毁，此时计数减一（此例为0--&gt;释放内存）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">shared_ptr&lt;Foo&gt; p=<span class="built_in">factory</span>(arg)	</span><br><span class="line"><span class="comment">//为arg用智能指针动态分配内存，达到能够自动释放的目的</span></span><br><span class="line"><span class="keyword">return</span> p;	<span class="comment">//引用加1，为2</span></span><br><span class="line">&#125;	<span class="comment">//此时p减一，但不为0，不释放</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="shared_ptr的共享数据">10.4.4 shared_ptr的共享数据</h6>
<p>到目前为止，我们使用的类中，分配的资源都与对应对象生存期一致。当我们拷贝一个<code>vector</code>时，<code>原vector</code>和<code>副本vector</code>中的元素是相互分离的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v1;</span><br><span class="line">&#123;<span class="comment">//新作用域</span></span><br><span class="line">    vector&lt;string&gt; v2=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line">    v1=v2; <span class="comment">//从v2拷贝元素到v1</span></span><br><span class="line">&#125; <span class="comment">//v2被销毁，其中的元素也被销毁</span></span><br><span class="line"><span class="comment">//v1依然有三个元素</span></span><br></pre></td></tr></table></figure> 所以此时的<code>V2只是V1</code>的一份赋值过来的值。指向的不是共同地址的数据。(这里的共同是指内存地址是同一个）。为了达到这个目的，<code>shared_ptr</code>就排上了用场--&gt;多个对象共享数据。</p>
<h6 id="定义strblob类">10.4.5 定义StrBlob类</h6>
<p>下面的是创建一个类模板（实现多个对象共享数据），每个<code>strBlob</code>对象设置一个<code>shared_ptr</code>来管理动态分配的vector。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlob</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::vector&lt;std::string&gt;::size_type size_type;</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">StrBlob</span>();</span><br><span class="line">	<span class="comment">//可变形参构造函数，内元素均为字面值且为strig</span></span><br><span class="line">	<span class="built_in">StrBlob</span>(std::initializer_list&lt;std::string&gt; il);</span><br><span class="line">	<span class="comment">//容器大小和判空</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span>  <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> std::string &amp;t)</span> </span>&#123; data-&gt;push_back; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//外部获得类的data</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;* <span class="built_in">get</span>()&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置data</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(shared_ptr&lt;std::vector&lt;std::string&gt;&gt;* p)</span></span>&#123;</span><br><span class="line">		data=p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">std::string &amp;<span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string &amp;<span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//声明智能指针data</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;</span><br><span class="line">	<span class="comment">//如果data[i]不合法，抛出一个异常</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span>()：<span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;()) &#123;&#125;</span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span>(initializer_list&lt;string&gt; il):</span><br><span class="line">       <span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125;</span><br><span class="line"><span class="comment">//检查函数，i&gt;size，抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrBlob::check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取头元素</span></span><br><span class="line"><span class="function">string &amp;<span class="title">StrBlob::front</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;front on empty StrBlob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取尾元素</span></span><br><span class="line"><span class="function">string&amp; <span class="title">StrBlob::back</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;back on empty StrBlob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弹出尾部元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrBlob::pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了该类后，我们创建类的对象，可以通过<code>get</code>函数获得智能指针，通过<code>set</code>赋给类的新对象即可.这样实现了类多个对象的数据共享。这要看很像类的静态成员，但它比静态成员有一个好处就是，当没有对象引用时，会释放，而不像静态成员持续到程序结束时才释放</p>
<h6 id="shared_ptr和new结合使用">10.4.6 shared_ptr和new结合使用</h6>
<p>我们可以用<code>new</code>返回的指针来初始化智能指针。因为接受指针参数的智能指针构造函数是<code>explicit</code>的，<strong>因此我们不能将一个内置指针隐式转换成一个智能指针</strong>，必须使用直接初始化形式而且使用字面值： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);    <span class="comment">//错误：必须使用直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;   <span class="comment">//正确：使用了直接初始化形式</span></span><br></pre></td></tr></table></figure> 同理，一个返回<code>shared_ptr</code>的函数不能在其返回语句中隐式转换成一个普通指针： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(p);  <span class="comment">//错误：隐式转换为shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));  <span class="comment">//正确：显式地用int*创建shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所关联的对象。 <strong><em>注意：</em></strong>内置指针是指内置类型<code>（如int、char)</code>的指针，一般没有默认构造函数。普通指针是普通类型的指针），一般有默认构造函数</p>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/shared.png" width="700"></p>
<h6 id="莫交错使用new和shared_ptr">10.4.7 莫交错使用new和shared_ptr</h6>
<p>当将一个<code>shared_ptr</code>绑定到一个普通指针时，我们就将内存的管理责任交给了这个<code>shared_ptr</code>。一旦这么做了，我们就不应该再使用内置指针来访问<code>shared_ptr</code>所指向的内存了。如下列子: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; p)</span></span>&#123;</span><br><span class="line"><span class="comment">//空函数，离开时p对象被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;  <span class="comment">//危险：x是一个普通指针，而不是一个智能指针</span></span><br><span class="line"><span class="comment">//process(x);           //错误：不能将int*转换成一个shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));   <span class="comment">//临时shared_ptr，合法的，但内存会被释放，引用计数变为0</span></span><br><span class="line"><span class="type">int</span> j=*x;   <span class="comment">//未定义的：x是一个空悬指针</span></span><br></pre></td></tr></table></figure></p>
<p><strong>上述代码中<code>x</code>是一个普通指针，当把<code>x</code>传给<code>process</code>时，报错，因为普通指针不能隐式的转换为智能指针。传入的实参显示转换为智能指针，此时<code>x</code>就将内存交给了<code>shared_ptr</code>管理</strong>，当该函数执行完毕时，该指针指针<code>shared_ptr</code>被销毁（x所指向的内存没了），<code>x</code>也就成了空悬指针。</p>
<p>使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。而且内置指针很可能成为空悬指针</p>
<h6 id="智能指针和异常">10.4.8 智能指针和异常</h6>
<p>使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//如果在这里抛出了异常,其内存也会释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面这种清空就不会释放：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//如果在这里抛出了异常</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;<span class="comment">//因为抛出了异常，无法执行delete p语句</span></span><br></pre></td></tr></table></figure></p>
<h6 id="删除器">10.4.9 删除器</h6>
<p>某些类没有定义析构函数，此时我们可以使用<code>shared_ptr</code>来保证该类生成的对象的内存被正确释放，首先定义一个函数（删除器）来代替得<code>delete</code>。下面以连接为例子，<code>destination</code>类是连接信息类 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一些类和接口</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;		<span class="comment">//该类标识我们连接的信息，如端口，地址</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connnection</span>;		<span class="comment">//连接类，已连接信息记录</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destionatin *p)</span></span>;	<span class="comment">//请求连接,返回一个连接类记录信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnection</span><span class="params">(connection)</span></span>;		<span class="comment">//关闭连接,内含delete操作</span></span><br><span class="line"><span class="comment">//对声明的类和接口定义</span></span><br><span class="line">....</span><br><span class="line"><span class="comment">//定义删除器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connecttion</span><span class="params">(connection *p)</span></span>&#123;</span><br><span class="line">	<span class="built_in">disconnection</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shared_ptr使用删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">	connection c=<span class="built_in">connect</span>(&amp;d)；	<span class="comment">//返回一个连接类信息</span></span><br><span class="line">	shared_ptr&lt;connection&gt; <span class="built_in">p</span>(&amp;c,end_connnection);	<span class="comment">//shared_ptr的用法，自定义删除器</span></span><br><span class="line">	<span class="comment">//这样。当f函数退出时，即使是由异常引起的，Connection也会被释放关掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当对象智能指针对象p离开函数f的作用域时，自动调用end_connection函数，end_connection函数又调用disconnection函数执行delete操作，注意形参时指针类型</p>
<h6 id="shared_ptr与数组">10.4.10 shared_ptr与数组</h6>
<p>与<code>unique_ptr</code>不同，<code>shared_ptr</code>不直接支持管理动态数组。如果我们希望使用<code>shared_ptr</code>管理一个动态数组，<strong>必须提供自己定义的删除器(因为删除是我们默认的是<code>delete</code>而不是<code>delete[]</code>)：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了使用shared_ptr,必须提供一个删除器</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>],[](<span class="type">int</span> *p)&#123;<span class="keyword">delete</span> [] p;&#125;)</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>();   <span class="comment">//使用我们提供的lambda释放数组，它使用delete[]</span></span><br></pre></td></tr></table></figure> <code>shared_ptr</code>未定义下标运算符，<strong>而且智能指针类型不支持指针算数运算</strong>。因此，为了访问数组中的元素，必须用<code>get</code>获取一个内置指针，然后用它来访问数组元素： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</span><br><span class="line">    *(sp.<span class="built_in">get</span>()+i)=i;  <span class="comment">//使用get获取一个内置指针</span></span><br></pre></td></tr></table></figure></p>
<h5 id="unique_ptr">10.5 unique_ptr</h5>
<p><code>unique_ptr</code>是C++的另一个智能指针，与<code>shared_ptr</code>不同的是，任何时刻，都至多只能有一<code>unique_ptr</code>智能指针指向一个对象，当<code>unique_ptr</code>指针被销毁时，其对象也被销毁。</p>
<h6 id="unique_ptr的初始化">10.5.1 unique_ptr的初始化</h6>
<p>与<code>shared_ptr</code>不同，没有类似<code>make_shared</code>的标准函数返回一个<code>unique_ptr</code>。因此，当我们定义一个<code>unique_ptr</code>时，需要将其绑定到一个<code>new</code>返回的指针上。类似于<code>shared_ptr</code>（接受参数的构造函数有<code>explicit修饰</code>），所以初始化<code>unique_ptr</code><strong>必须采用直接初始化方式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p;		<span class="comment">//定义</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;		<span class="comment">//定义并初始化，指向一个值为24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr不支持普通的拷贝和赋值：</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p2</span>(p1);		<span class="comment">//错误，不支持拷贝</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;p3;</span><br><span class="line">p3=p1;						<span class="comment">//或p3(p2)错误，不允许赋值</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/unique_ptr.png" width="700"></p>
<p>虽然我们无法拷贝或者赋值，但我们可以通过调用<code>release或reset</code>将指针所有权从一个<code>（const)unique_ptr</code>转移给另一个<code>unique_ptr</code>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;	<span class="comment">//p1转移给p2，p1置空</span></span><br><span class="line">unique_ptr&lt;string&gt;<span class="built_in">p3</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line"><span class="comment">//p3转移给p2ertyui</span></span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">//p2释放原来的，p3被置空，p2指向的p3的</span></span><br></pre></td></tr></table></figure> <strong><code>release</code>函数会切断智能指针和它原来管理的对象的联系</strong>，它返回的指针通常用来初始化另一个智能指针或给另一个智能指针赋值。 如果我们不用另一个智能指针来保存<code>release</code>返回的指针，我们的程序就要负责资源的释放： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=p2.<span class="built_in">release</span>();		<span class="comment">//后面程序应该有delete(p);操作</span></span><br></pre></td></tr></table></figure></p>
<h6 id="向unique_ptr传递删除器">10.5.2 向unique_ptr传递删除器</h6>
<p>和<code>shared_ptr</code>一样，<code>unique_ptr</code>默认情况（源代码）使用<code>delete</code>释放它指向的对象。我们可和<code>shared_ptr</code>一样重载一个<code>unique_ptr</code>中的删除器。</p>
<p>重载一个<code>unique_ptr</code>中的删除器会影响到<code>unique_ptr类型</code>以及如何构造（或<code>reset</code>）该类型的对象：<strong>我们必须在尖括号中<code>unique_ptr</code>指向类型之后提供删除器类型</strong>，即在创建或<code>reset</code>一个这种<code>unique_pt</code>r类型的对象时，必须提供一个指定类型的可调用对象（删除器） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span></span><br><span class="line"><span class="comment">//它会调用一个名为fcn的delT类型对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT,delT&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> objT,fcn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(desitination &amp;d)</span></span>&#123;</span><br><span class="line">	connection c=<span class="built_in">connect</span>(&amp;d)；	<span class="comment">//返回一个连接类信息</span></span><br><span class="line">	<span class="comment">//当p被销毁时，连接会关闭</span></span><br><span class="line">	unique_ptr&lt;connection,<span class="keyword">decltype</span>(end_connection)*&gt; <span class="built_in">p</span>(&amp;c,end_connnection);</span><br><span class="line">	<span class="comment">//这样。当f函数退出时，即使是由异常引起的，Connection也会被释放关掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong><em>注：</em></strong><code>decltype</code>是C++11新增的一个关键字，和<code>auto</code>的功能一样，用来在编译时期进行自动类型推导。引入<code>decltype</code>是因为<code>auto</code>并不适用于所有的自动类型推导场景，在某些特殊情况下auto用起来很不方便，甚至压根无法使用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> varName=value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varName=value;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li><code>auto</code>根据<code>=</code>右边的初始值推导出变量的类型，<code>decltype</code>根据<code>exp</code>表达式推导出变量的类型，跟``=右边的value没有关系</li>
<li><code>auto</code>要求变量必须初始化，这是因为<code>auto</code>根据变量的初始值来推导变量类型的，如果不初始化，变量的类型也就无法推导</li>
<li>而<code>decltype</code>不要求，因此可以写成如下形式 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varName;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h6 id="指向数组的unique_ptr">10.5.3 指向数组的unique_ptr</h6>
<p>标准库提供了一个可以管理<code>new</code>分配的数组的<code>unique_ptr</code>版本。使用<code>unique_ptr</code>管理动态数组时，我们必须在对象类型后面跟一对方括号,下面是用法介绍： <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/uniquearry.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">up.<span class="built_in">release</span>();   <span class="comment">//自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>
<p>另外一方面，当一个unique_tr指向一个数组时，我们可以使用下标运算符来访问数组中的元素： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</span><br><span class="line">    up[i]=i;  <span class="comment">//为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure></p>
<h5 id="weak_ptr">10.6 weak_ptr</h5>
<p><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针,是弱用智能指针，<strong>它指向一个有<code>shared_ptr</code>管理的对象。将一个<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变<code>share_ptr</code>的引用计数。</strong> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/weak_ptr.png" width="700"> 当我们创建一个<code>weak_ptr</code>时，我们要用以<code>shared_ptr</code>初始化它： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">43</span>);</span><br><span class="line"><span class="function">weak_ptr <span class="title">wp</span><span class="params">(p)</span></span>;		<span class="comment">//wp若共享p,p的引用计数不变</span></span><br></pre></td></tr></table></figure> 由于对象可能不存在，不能直接使用<code>weak_ptr</code>直接访问对象，必须调用<code>lock(</code>)函数！该函数会检查<code>weak_ptr</code>指向的对象是否存在，若存在，则返回一个指向共享对象的<code>shared_ptr</code>。如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; q=wp.<span class="built_in">lock</span>())	</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使用q访问对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="allocator类">10.7 allocator类</h5>
<p>在前面我们主要介绍了<code>new,delete和智能指针</code>。但他们分配的内存不是原始的，它们在分配的时候要对内存进行构造。<strong>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</strong> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/allocator.png" width="700"></p>
<h6 id="allocate分配未构造内存">10.7.1 allocate：分配未构造内存</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">allocator&lt;string&gt; allco;	<span class="comment">//定义可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p=alloc.<span class="built_in">allocate</span>(n);	<span class="comment">//分配n个为初始化的string</span></span><br></pre></td></tr></table></figure>
<p><code>alloc</code>完成了分配n个<code>string</code>的连续内存的工作，并且返回一个指向这一块内存的首地址给指针<code>p</code>。我希望p记住这个首地址在哪免得我后边找不到了，所以把它设为<code>const</code>的。</p>
<h6 id="construct创建对象">10.7.2 construct：创建对象</h6>
<p>下面我让<code>alloc</code>为我在这些内存上构造对象：<code>alloc.construct(内存地址，参数......)</code>，括号里的“参数”是给我这块内存的对象类型的构造函数的参数，比如这里对于<code>string</code>，可以这样: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string *S=p;	<span class="comment">//将首地址给S</span></span><br><span class="line">alloc.<span class="built_in">constrcut</span>(S,<span class="number">10</span>,<span class="string">&#x27;A&#x27;</span>);		<span class="comment">//该内存构造string &quot;AAAAAAAAAA&quot;</span></span><br><span class="line">S++;			<span class="comment">//把内存地址往后挪，以便后续的构造</span></span><br></pre></td></tr></table></figure> <strong><em>注意：使用未构造的对象的内存空间是错误</em></strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;*p&lt;&lt;endl;		<span class="comment">//正确，p是指向首地址</span></span><br><span class="line">cout&lt;&lt;*S&lt;&lt;endl;		<span class="comment">//错误，还没构造</span></span><br></pre></td></tr></table></figure></p>
<h6 id="destroy摧毁对象">10.7.3 destroy：摧毁对象</h6>
<p>当我们用完对象后，必须对每个构造的元素调用<code>destory</code>来摧毁它们。我们只能对真正构造了的元素进行<code>destory</code>操作,而且只有摧毁的内存或未构造的内存才能被<code>deallocate</code>回收。<code>destroy</code>参数接受一指针，对指向的对象执行析构函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(q!=p)</span><br><span class="line">alloc.<span class="built_in">destroy</span>(--q);</span><br></pre></td></tr></table></figure> 一旦元素被销毁，我们就可以重新使用这部分内存来保存其他string,也可以将其归还给系统。释放内存通过调用dealloccate来完成： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alloc.<span class="built_in">dealloccate</span>(p,n);	<span class="comment">//p必须是allocate返回的指针，n必须是分配时指定的n</span></span><br></pre></td></tr></table></figure></p>
<h6 id="拷贝和填充未初始化的内存算法">10.7.4 拷贝和填充未初始化的内存算法</h6>
<p>allocator还有两个伴随算法，可以在未初始化内存中创建对象。它们都定义在头文件<code>memory</code>中。 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/allocator_algorithm.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配动态内存</span></span><br><span class="line"><span class="keyword">auto</span> p=alloc.<span class="built_in">allocate</span>(v.<span class="built_in">size</span>()*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//拷贝vi的元素到未构造内存,返回下一个未构造地址</span></span><br><span class="line"><span class="keyword">auto</span> q=<span class="built_in">uninitialized_copy</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),p);</span><br><span class="line"><span class="comment">//将剩余空间构造为42</span></span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(q,vi.<span class="built_in">size</span>(),<span class="number">42</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="拷贝控制">11.拷贝控制</h4>
<p>如何控制类型对象拷贝、赋值、移动和销毁，<strong>有对应的五种特殊成员函数来控制这些操作：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数</strong></p>
<h5 id="拷贝构造函数">11.1 拷贝构造函数</h5>
<h6 id="拷贝构造函数-1">11.1.1 拷贝构造函数</h6>
<p>个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>&#123;</span><br><span class="line"><span class="built_in">foo</span>();			<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="type">const</span> foo&amp;);	<span class="comment">//拷贝构造函数</span></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>第一个参数几乎总是<code>const</code>的（虽然可以不为<code>const</code>)，拷贝构造函数在几种情况下都会被隐式的调用，因此拷贝构造函数通常不应该是<code>explicit</code>(<code>explicit</code>修饰的不能拷贝初始化，只能直接初始化，不能隐式转换类类型）。</strong></p>
<h6 id="合成拷贝构造函">11.1.2 合成拷贝构造函</h6>
<p>如果我们没有为一个类定义拷贝构造函数，<strong>编译器会为我们定义默认的拷贝构造函数（即使有其他的构造函数）</strong>。但有些类，合成的拷贝构造函数用来阻止我们拷贝该类类型的对象。<strong>但一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中（从给定对象依次将每个非static成员拷贝到正在创建的对象中）。</strong> <strong>如何拷贝：</strong></p>
<ul>
<li>对类类型（需要include&lt;&gt;的就为类类型)的成员，会使用其拷贝构造函数来拷贝</li>
<li>内置类型的成员则直接拷贝</li>
<li>对数组，合成拷贝构造函数会逐元素拷贝数组类型成员</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...		<span class="comment">//其他构造函数</span></span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;);	<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string Book_NO;</span><br><span class="line">	<span class="type">int</span> units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data &amp;data):<span class="built_in">Book_NO</span>(data.Book_NO),<span class="built_in">units_sold</span>(data.units_sold)</span><br><span class="line">	<span class="built_in">revenue</span>(data.revenue)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="拷贝初始化">11.1.3 拷贝初始化</h6>
<ul>
<li><strong>使用<code>=</code>进行的初始化是拷贝形式的初始化，编译器将等号右边的初始值拷贝到新创建的对象上去</strong>。这时将调用对象定义的<strong>拷贝构造函数</strong>进行操作，只要这些构造函数满足这样的调用就会被隐式的调用。但是被explicit修饰的拷贝构造函数将会禁止该构造函数进行这样隐式的调用（因为可能由隐式类型转换）。</li>
<li>不使用<code>=</code>进行初始化的操作就是直接初始化,采用<code>()</code>直接进行初始化。这里调用的构造函数就是直接使用对应的<strong>构造函数</strong>进行初始化。explicit修饰的构造函数能用于直接初始化。这种形式没有什么限制。</li>
</ul>
<p><strong><em>总结：</em></strong> <strong>直接初始化：</strong>根据提供的参数选择最匹配的构造函数 <strong>拷贝初始化：</strong>右侧运算对象拷贝到正在创建的对象中，通常由拷贝构造函数完成。</p>
<h6 id="拷贝构造函数的参数必须是引用">11.1.4 拷贝构造函数的参数必须是引用</h6>
<p><strong>因为在函数调用中，非引用类型的的参数要进行拷贝初始化；函数返回一个非引用类型，调用方的返回结果也是一个拷贝，所以拷贝函数此时被用来初始化非引用类型的数据。如果拷贝构造函数的参数不是引用类型都是类型形参，为获得它的实参，那么它自身就会无限的调用自身的死循环。P（442）</strong></p>
<h6 id="构造函数不能为虚函数">11.1.5 构造函数不能为虚函数</h6>
<p>我们知道，<strong>每个有虚函数的类都有属于自己的虚函数表<code>vtbl</code>，虚函数表在编译器构建好。当我们的派生类重写了虚函数，那么在虚表中就会替换掉父类的虚函数指针为子类的虚函数指针。当我们创建一个对象时，会在对象的内存模型中有自己的指向虚表的指针<code>vtpr</code>，对象通过虚表才知道调用的是哪一版本的虚函数</strong> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/vtpr.png" width="500"> 如果构造函数是虚函数,那么也会如上面的机制一样在虚表有一个指向自己构造函数版本的虚函数指针。现在有两个类<code>A</code>和<code>B</code>,<code>B</code>是<code>A</code>的派生类，在构造<code>B</code>的对象的时候发现继承于<code>A</code>的部分要先构造，它就要求调用<code>A</code>的构造函数，但是这些构造函数已经是虚函数了，而虚表指针必须是在构造一个对象的时候分配了内存才能得到，而你有调用不到构造函数，<strong>这就陷入了一个矛盾的处境：你要用虚表指针<code>vtpr</code>去调用构造函数，而虚表指针<code>vtpr</code>只有当年调用构造申请了内存后才能得到，这形成了一个死结。</strong></p>
<p><strong><em>附加</em></strong>：vptr的初始化工作早于构造函数中的初始化列表</p>
<h5 id="拷贝赋值运算符">11.2 拷贝赋值运算符</h5>
<p>与类控制对象如何初始化一样，类也可以控制对象如何赋值： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_data trans,accum;</span><br><span class="line">trans=accum;		<span class="comment">//使用Sales_data的拷贝运算符</span></span><br></pre></td></tr></table></figure> <strong><em>注意区分：拷贝构造函数是在对象创建时拷贝，而赋值拷贝时在对象已经创建后进行赋值，这就是两者的区别</em></strong></p>
<h6 id="重载赋值运算符">11.2.1 重载赋值运算符</h6>
<p>重载运算符的本质是函数。其名由<code>operator</code>关键字接要定义的运算符组成。赋值运算符<code>operator=</code>的函数，其也有返回类型和参数（参数表示要运算的对象），运算符如果是成员函数，则运算对象就绑定在隐式的this指针上。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> foo&amp;);	<span class="comment">//赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="合成拷贝赋值运算符">11.2.2 合成拷贝赋值运算符</h6>
<p>与拷贝构造函数一样，在没有定义自己的拷贝运算符时，<strong>编译器会生成一个合成拷贝赋值运算符</strong>。同样，对于某些类，合成拷贝赋值运算符会禁止该类型对象的赋值，如果不是此目的，它会赋值（非static)。</p>
<h5 id="析构函数">11.3 析构函数</h5>
<p>析构函数释放对象使用的资源，并销毁对象的非<code>static</code>数据成员。析构函数时类的成员函数，名字由波浪号<code>~</code>接类名构成，没有返回值，也不接受参数，既不能重载但一般定义未虚函数重写，类只有一个析构函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">foo</span>();	<span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="定义析构函数">11.3.1 定义析构函数</h6>
<p>析构函数同构造函数一样，也由一函数体和一个析构部分。在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。<strong>析构部分是隐式的，销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销魂内置类型成员什么也不需要做（隐式的）。</strong></p>
<ul>
<li>隐式销毁一个内置指针类型的成员不会delete它所指向的对象</li>
<li>智能指针式类类型的，所以具有析构函数，所以智能指针在析构阶段被自动销毁</li>
</ul>
<p><strong>什么时候调用析构函数：无论何时一个对象被销毁，就会自动调用其析构函数</strong>:</p>
<ul>
<li>变量离开作用域时被销毁</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器被销毁时，其元素被销毁</li>
<li>对于动态分配对象，当指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<p>由于析构函数的自动允许，我们程序可以按需要分配资源，无需担心何时释放这些资源。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">//语句块作用域</span></span><br><span class="line">	Sales_data* p=<span class="keyword">new</span> Sales_data;	<span class="comment">//p是一个普通指针</span></span><br><span class="line">	<span class="keyword">auto</span> p2=<span class="built_in">make_shared</span>&lt;Sales_data&gt;();	<span class="comment">//p2是一个智能指针</span></span><br><span class="line">	<span class="function">Sales_data <span class="title">item</span><span class="params">(*p)</span></span>;			<span class="comment">//使用拷贝构造</span></span><br><span class="line">	vector&lt;Sales_data&gt;vec;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(*p2);</span><br><span class="line">	<span class="keyword">delete</span> p;						<span class="comment">//释放p</span></span><br><span class="line">	<span class="comment">//离开作用域后，p2的计数归0，自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="合成析构函数">11.3.2 合成析构函数</h6>
<p><strong>当一个类未定义析构函数时，编译器会为它定义一个合成析构函数。同时同拷贝构造函数、拷贝赋值运算符一样，对于某些类，合成析构函数被用来阻止该类型的对象被销毁</strong>。如果不是这种情况，合成析构函数的函数体就为空。<strong>析构函数体自身不直接销毁成员，而是在析构函数体之后隐含的析构阶段中被销毁</strong></p>
<h5 id="c对这些构造函数的法则">11.4 C++对这些构造函数的法则</h5>
<p>目前为止介绍了三个拷贝控制操作：拷贝构造函数、拷贝赋值运算符、析构函数，知道我们若是不显示定义，编译器会自动合成默认的拷贝构造和赋值构造函数以及析构函数。c++新标准还引入了：一个类还可以定义一个移动构造函数、一个移动赋值运算符。对于它们，编译器有自己的一套法则</p>
<h6 id="三五法则">11.4.1 三/五法则</h6>
<p>对于这些构造函数，我们有时候不必全部定义，有如下的法则：</p>
<ul>
<li>（1）需要析构函数的了也需要拷贝和赋值操作</li>
<li>（2）如果类需要一个析构函数，那么几乎可以肯定它也需要拷贝构造函数和拷贝赋值运算符</li>
<li>（3）需要拷贝操作的类也需要赋值操作，反之亦然</li>
</ul>
<p>总结：即一般来说类中一般以三</p>
<h6 id="default默认合成">11.4.2 =default：默认合成</h6>
<p>同默认合成构造函数一样，可以用<code>=default</code>来显示要求合成拷贝构造函数，默认为内联的。<strong>若不要内联，则在类的外部定义为<code>=default</code></strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;)=<span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="delete阻止拷贝">11.4.3 =delete：阻止拷贝</h6>
<p>上面我们总是讲到有些拷贝构造、赋值构造和析构会阻止它们的应用功能，这就是用<code>=delete</code>定义的函数。虽然大多数类定义了拷贝构造函数和拷贝赋值运算符，但对于某些类，这些操作没有实际意义，如<code>iostream</code>类阻止了拷贝以避免多个对象写入或读取相同的<code>IO</code>缓冲。所以这种情况就要阻止拷贝的发生。<strong><em>在新标准之前（<code>=delet</code>e前)，类是通过将其拷贝构造函数和拷贝赋值运输符声明为private来阻止拷贝：</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp;);		<span class="comment">//阻止拷贝构造</span></span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;);		<span class="comment">//阻止赋值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新标准下，我们可以将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。 <strong>删除的函数</strong>：我们声明了它，但不能以任何方式使用它，我们在相应的拷贝构造和拷贝运算符后加<code>=delete</code>即可 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mm</span>&#123;</span><br><span class="line">	<span class="built_in">mm</span>()=<span class="keyword">default</span>;		<span class="comment">//合成构造函数</span></span><br><span class="line">	<span class="built_in">mm</span>(<span class="type">const</span> mm&amp;)=<span class="keyword">delete</span>;		<span class="comment">//阻止拷贝</span></span><br><span class="line">	mm &amp;<span class="keyword">operator</span>=(<span class="type">const</span> mm &amp;)=<span class="keyword">delete</span>;		<span class="comment">//阻止赋值</span></span><br><span class="line">	~<span class="built_in">mm</span>();				<span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 与<code>default</code>不同:</p>
<ul>
<li><code>delete</code>必须出现在函数第一声明的时候；</li>
<li>还有一点不同的是我们可以对任何函数<code>=delete</code>，而<code>default</code>只能是默认合成构造函数和拷贝控制成员，但一般而言，对于析构函数我们不应该使用<code>=delete</code>(因为这样我们就无法销毁类型对象了）</li>
</ul>
<h6 id="合成的拷贝控制成员可能是删除的">11.4.4 合成的拷贝控制成员可能是删除的</h6>
<p><strong>正如前面所将的，合成的拷贝控制操作可能是阻止类型的：</strong></p>
<ul>
<li>如果类的某个成员的析构函数是删除或不可访问的（如<code>private</code>),则类的合成析构函数被定义为删除的</li>
<li>如果类的某个成员的拷贝构造函数是删除或不可访问的，则类的合成拷贝构造函数被定义为删除。同样，析构函数是删除或不可访问，合成拷贝构造函数被定义为删除</li>
<li><strong>如果类的某个成员的拷贝赋值运算符是删除或不可访问的，或者类有一个<code>const</code>的或者引用的成员，则类的合成拷贝赋值运算符被定义为删除</strong></li>
<li><strong>如果类的某个成员的析构函数是删除或不可访问的、或者类有一个引用成员，它没有类内初始器、或是类内有一个<code>const</code>成员，他没有类内初始器且其类型为显示定义默认构造函数，则该类的默认构造函数被定义为删除的</strong></li>
</ul>
<p><strong><em>即：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数被定义为删除</em></strong></p>
<h5 id="对象移动">11.5 对象移动</h5>
<p>新标准一个最主要的特征是可以移动而非拷贝对象的能力。使用移动而不是拷贝：</p>
<ul>
<li>①在对象较大时，进行拷贝代价很高。</li>
<li>②对于像IO类和unique_ptr这些类，这些类都包含了不能被共享的资源，因此不能拷贝但可以移动。</li>
</ul>
<p>该特性主要针对这样一种场景：<strong>一个对象在被拷贝之后就不在使用了或者马上就会被析构掉，这种情况下，使用移动操作而非拷贝操作将会大幅度提升性能。移动操作的思想是接管源对象的内容。</strong></p>
<h6 id="右值与左值">11.5.1 右值与左值</h6>
<ul>
<li><strong>左值</strong>：返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式。</li>
<li><strong>右值</strong>：右值要么是字面常量，要么是在常量表达式求职过程中创建的临时对象。</li>
</ul>
<p>左值持久；右值短暂。</p>
<h6 id="右值引用和左值引用">11.5.2 右值引用和左值引用</h6>
<p>为了支持移动，新标准引入了新类型的引用——<strong>右值引用</strong>。<strong>通过&amp;&amp;获得右值引用。右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。因此我们可以将一个右值引用资源“移动”到另一个对象去。</strong>不难知道，不管是左值引用还是右值引用都是变量的一个别名：</p>
<ul>
<li><strong>左值引用</strong>：不能将其绑定到要求转换的公式、字面常量或者是返会右值的表达式，即左值引用是绑定对象（左值）的。</li>
<li><strong>右值引用</strong>：与左值引用恰恰相反，可绑定右值，但不能绑定左值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r=i;		<span class="comment">//正确，左值引用绑定对象（左值）</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr=i;	<span class="comment">//错误，右值引用不能绑定左值</span></span><br><span class="line"><span class="type">int</span> &amp;r2=i*<span class="number">42</span>;	<span class="comment">//错误，左值引用不能绑定右值</span></span><br><span class="line"><span class="comment">//可以将一个const的左值引用或者一个右值引用绑定到这类表达式上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3=i*<span class="number">42</span>;	<span class="comment">//正确，可以将const的引用绑定到右值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;r3=i*<span class="number">42</span>;	<span class="comment">//正确</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于右值引用只能绑定到临时对象，我们可以知道：<strong>①所引用的对象将要被销毁，②该对象没有其他用户。这两个特性意味着使用右值引用的代码可以自由地接管所引用的对象的资源。</strong></p>
<p><strong>记住变量是左值，我们不能将右值引用绑定到变量上，即使这个变量本身是右值引用也不行！</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  &amp;&amp;r1=<span class="number">42</span>;		<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;r2=r1;		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p>
<h6 id="move函数">11.5.3 move函数</h6>
<p>新标准提供了一个函数解决右值引用无法绑定左值的函数，通过调用新标准库函数move来获得绑定到左值的右值引用。该函数定义在头文件<code>utility</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;r2=std::<span class="built_in">move</span>(r1);		<span class="comment">//可行</span></span><br></pre></td></tr></table></figure> 调用<code>move</code>之后，我们可以销毁一个移后员对象，也可以赋予它新值，但不能使用一个移后源对象的值。 有了这些知识我们就能看接下来的<strong>移动拷贝构造函数和移动赋值运算符</strong>。类似string类，自定义的类支持移动和拷贝，会十分方便。它们从指定对象“窃取”资源，而不是拷贝资源。</p>
<h6 id="移动拷贝构造函数">11.5.4 移动拷贝构造函数</h6>
<p>类似于拷贝构造函数，<strong>第一个参数是该类类型的右值引用</strong>，其他额外参数必须有默认值。<strong>移动构造函数需要确保移后源对象处于这样一个状态：销毁它是无害的。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> <span class="comment">//移动操作不应抛出任何异常</span></span><br><span class="line">    <span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">    :<span class="built_in">elements</span>(s.elements), <span class="built_in">first_free</span>(s.first_free), <span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//另s进入这样一个状态——对其运行析构函数是安全的</span></span><br><span class="line">    s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>上面这个程序不分配任何内存，只是接管了s的内存，接管之后，将给定对象的指针都设为<code>nullptr</code>,这样就完成了移动操作</strong>。此源对象继续存在（但已经没有管理任何内存），当允许其析构函数时，源对象被销毁。<strong>注意：不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</strong></p>
<blockquote>
<p><strong>为什么要声明<code>noexcept</code></strong> 虽然移动操作通常不会异常抛出，但抛出异常时允许的。而且标准库容器能对异常发生时其自身的行为提供保障。&gt;<code>noexcept</code>它告诉编译器该函数不会抛出异常，否则编译器会认为移动操作可能会发生异常，并且为了处理这种可&gt;能性做一些额外的工作。</p>
</blockquote>
<h6 id="移动赋值运算符">11.5.5 移动赋值运算符</h6>
<p>移动赋值运算符指向析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为<code>noexcept</code>。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(); <span class="comment">//释放已有元素</span></span><br><span class="line">        elements = rhs.elements;</span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="移动操作的要求">11.5.6 移动操作的要求</h6>
<ul>
<li><strong>移动源对象必须可析构</strong>：当我们编写一个移动操作，必须保证移动源进入一个可析构状态，如上面的例子中，我们将移动源数据置为<code>nullptr</code>。其次，还应保证，对象移动后还是有效的，既可以重新赋值。</li>
<li><strong>合成的移动操作</strong>：<strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时（指针型），编译器才会为它合成移动构造函数或移动赋值运算符。</strong></li>
<li><strong>移动右值，拷贝左值</strong>：在一个类中，既定义了移动又定义了拷贝，编译器使用匹配规则进行匹配。在定义了拷贝但没有定义移动，右值也使用拷贝构造函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译器会为X和hasX合成移动操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">//内置类型可以移动</span></span><br><span class="line">    std::string s; <span class="comment">//string 定义了自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasX</span>&#123;</span><br><span class="line">    X mem;  <span class="comment">//X有合成的移动操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X x, x2 = std::<span class="built_in">move</span>(x);        <span class="comment">//使用合成的移动构造函数</span></span><br><span class="line">hasX hx, hx2 = std::<span class="built_in">move</span>(hx);  <span class="comment">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>
<p>移动操作永远不会隐式定义为删除的函数。如果我们显示地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。移动构造函数被定义为删除的函数的条件是：</p>
<ul>
<li>有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者有类成员未定义自己的拷贝构造函数且编译器不能为其合成构造函数。移动赋值运算符的情况类似。</li>
<li>如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。</li>
<li>如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。</li>
<li>如果有类成员是<code>const</code>或是引用，则类的移动赋值运算符被定义为删除的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假定Y是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasY</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">hasY</span>() = defualt;</span><br><span class="line">    <span class="built_in">hasY</span>(hasY&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Y mem;  <span class="comment">//hasY将有一个删除的移动构造函数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hasY hy, hy2 = std::move(hy); //错误，移动构造函数是删除的</span></span><br></pre></td></tr></table></figure>
<p><strong>如果类定义了一个移动构造拷贝和/或一个移动赋值运算符，该类的合成拷贝构造函数和拷贝赋值运算符将会被定义为删除的</strong>。因此定义了一个移动构造函数或者移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员都被默认为删除的。（三/五法则）</p>
<h6 id="移动迭代器">11.5.7 移动迭代器</h6>
<p>新标准库定义了一种<strong>移动迭代器适配器</strong>。<strong>移动迭代器的解引用生成一个右值引用</strong>（其他的迭代器一般时指向元素的左值）。 通过调用标准库函数的<code>make_move_iterator</code>函数将以普通迭代器转换为移动迭代器。移动迭代器支持正常迭代器的工作。<strong>但值得注意的是只有在确定算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，能可以使用移动迭代器。否则使用移动迭代器销毁了原来数据，还想使用是错误的行为。</strong></p>
<h5 id="实际运用">11.6 实际运用</h5>
<p>在我们已经运用的类中，如<strong><code>string</code>、标准库容器它们的对象行为像一个值，即我们拷贝这些类的对象是，副本和原对象是独立的，互不影响</strong>。 但像<code>shared_ptr</code>类，<strong>这些智能指针的对象的行为像一个指针，副本和原对象使用相同的底层数据，即数据共享，它们之间会互相影响。</strong></p>
<h6 id="行为像值的类">11.6.1 行为像值的类</h6>
<p>这种行为的类，它们得对象都有着自己的一份数据： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span>  string&amp; s=<span class="built_in">string</span>())</span><br><span class="line">		:<span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)),<span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;		<span class="comment">//ps指向自己分配的空间,构造函数</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">		:<span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p.ps)),<span class="built_in">i</span>(p.i)&#123;&#125;		<span class="comment">//拷贝构造函数</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;);		<span class="comment">//赋值运算符</span></span><br><span class="line">	~<span class="built_in">HasPtr</span>()&#123;<span class="keyword">delete</span> ps;&#125;					<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string *ps;</span><br><span class="line">	<span class="type">int</span> i；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 上面这个类除了拷贝赋值运算符外，其他的成员函数都定义了。<strong>构造函数和拷贝构造函数都动态分配它们自己的<code>string</code>,以及分配自己栈内存给整型<code>i</code></strong>；赋值运算符通常组合了析构函数和构造函数的操作，我们编写的赋值运算符还应该是异常安全的--当异常发生时，仍能将左侧运算对象置于一个有意义的状态。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p)&#123;</span><br><span class="line">	<span class="keyword">auto</span> newp=<span class="keyword">new</span> <span class="built_in">string</span>(*p.ps);</span><br><span class="line">	<span class="keyword">delete</span> ps;</span><br><span class="line">	ps=newp;</span><br><span class="line">	i=p.i;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> delete这个对象原来的指向的<code>string</code>，再将<code>newp</code>的管理权给它。在编写赋值运算符时，需要注意：</p>
<ul>
<li>如果将一个对象赋予它自身，赋值运算符必须能正确工作</li>
<li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作</li>
</ul>
<p>一个好的赋值运算符，往往会借助一个局部零时对象拷贝，如上的<code>newp</code>。（就如在上面的程序中，如果p和this是同一个对象，如果不借助中间<code>newp</code>而直接<code>delete ps</code>将会发生错误）。你也可以增加判断语句<code>if(this!=p)</code>避免增加一个零时量</p>
<h6 id="行为像指针的类">11.6.2 行为像指针的类</h6>
<p>令一个类展现类似指针行为的最好方法是<code>shared_ptr</code>来管理类中的资源，拷贝一个<code>shared_ptr</code>会拷贝（赋值）所指向的指针，共享数据，只要当s<code>hare_ptr</code>引用计数为0时才会释放资源。 <strong>另一个方法是不用<code>shared_ptr</code>，而是设计自己的引用计数，这种情况下，我们可以自己直接管理资源</strong> <strong>引用计数：</strong></p>
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还有创建一个引用计数，用来记录多少对象与正在创建的对象共享数据状态。</li>
<li>拷贝构造函数不分配计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户共享</li>
<li>析构函数递减计数器，指出gong共享状态的用户少了一个。若为0，则释放</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧。若左侧为0，则销毁释放。</li>
</ul>
<p>怎么存放计数器：将计数器保存在动态内存中，当创建一个对象时，我们分配一个计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;, HasPtr&amp;)</span></span>;	<span class="comment">//交换操作</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span>  string&amp; s=<span class="built_in">string</span>())</span><br><span class="line">		:<span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)),<span class="built_in">i</span>(<span class="number">0</span>),<span class="built_in">use</span>(<span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>))&#123;&#125;		<span class="comment">//构造函数,计数器为1</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">		:<span class="built_in">ps</span>(p.ps),<span class="built_in">i</span>(p.i),<span class="built_in">use</span>(p.use)&#123;*use++&#125;		<span class="comment">//拷贝构造函数,共享ps,use</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;);			<span class="comment">//赋值运算符</span></span><br><span class="line">	~<span class="built_in">HasPtr</span>()；					<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string *ps;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> *use;							<span class="comment">//引用计数器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数定义：</span></span><br><span class="line">HasPtr::~<span class="built_in">HasPtr</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span>(--*use==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">delete</span> ps;			<span class="comment">//计数为0时，释放</span></span><br><span class="line">		<span class="keyword">delete</span> use;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符定义：</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;p)&#123;</span><br><span class="line">	++*p.use;		<span class="comment">//递增右侧计数器</span></span><br><span class="line">	<span class="keyword">if</span>(--*use==<span class="number">0</span>)&#123;		<span class="comment">//递减左侧计数器，并判断</span></span><br><span class="line">		delele ps;</span><br><span class="line">		<span class="keyword">delete</span> use;</span><br><span class="line">	&#125;</span><br><span class="line">	ps=p.ps;			<span class="comment">//共享该堆内数据</span></span><br><span class="line">	i=p.i;</span><br><span class="line">	use=p.use;		<span class="comment">//共享计数器</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;		<span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换操作</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp; p1,HasPtr &amp;p2)</span></span>&#123;		<span class="comment">//定义该类自己的swap</span></span><br><span class="line">	<span class="keyword">using</span> std::swap;</span><br><span class="line">	<span class="built_in">swap</span>(p1.ps,p2,ps);		<span class="comment">//交换指针</span></span><br><span class="line">	<span class="built_in">swap</span>(p1.i,p2.i);			<span class="comment">//交换int成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="重载运算与类型转换">12.重载运算与类型转换</h4>
<p>当运算符被用于类类型对象时，c++语言允许我们为其指定新的含义，同时我们也能自定义类类型转换规则。<strong>重载运算符：</strong> <strong>它的名字由<code>operator</code>和其后要定义的运算符共同组成，它们的参数数量应该与运算符作用的运算对象数量一样多</strong>。 <strong>调用时左侧元素对象传递给第一个参数（若为成员函数则传给隐式this指针），右侧运算对象传递给之后的参数。重载不改变运算符原有的优先级</strong> 不能重载运算对象全为内置类型的运算符，既一定要包含至少一个类类型参数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span>,<span class="type">int</span>);		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/operator.png" width="700"></p>
<h5 id="输入和输出运算符">12.1 输入和输出运算符</h5>
<p>类需要定义适合其对象的新版本以支持IO操作，方便！</p>
<h6 id="重载输出运算符">12.1.1 重载输出运算符&lt;&lt;</h6>
<p>通常情况下第一个形参是<strong>非常量对象<code>ostream</code>的引用</strong>，之所以是<strong>非常量</strong>是因为向流写入对象会改变其状态，第二个参数(要IO操作的)是常量的引用.返回ostream对象。</p>
<ol type="1">
<li>输出运算不要考虑格式化操作，尤其不会打印换行符，应当主要负责打印对象的内容。</li>
<li>与<code>iostream</code>兼容的<strong>输入输出运算符必须是普通的非成员函数</strong>，而不能是类的成员函数，否则左侧的运算对象是我们类的一个对象。因此如果想为自定义类重载IO运算符就要定义成非成员函数，但是为了读取私有数据成员，常声明为友元</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> Sales_data &amp;item)&#123;		<span class="comment">//非成员函数</span></span><br><span class="line">	os&lt;&lt;item.<span class="built_in">isbn</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.units_sold&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">	&lt;&lt;item.revenue&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line">Sales_data data;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(cout,data);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">cout&lt;&lt;data;</span><br></pre></td></tr></table></figure>
<h6 id="重载输入运算符">12.1.2 重载输入运算符&gt;&gt;</h6>
<p>输入运算符的第一个形参是将要读取的流的引用，第二个形参是将要读取到的对象的引用，返回流的引用.输入运算符负担从流中读取数据到对象的工作，需要注意的是，应当处理输入可能失败的状态: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(ostream&amp; is, Sales_data &amp;item)&#123;		<span class="comment">//非成员函数</span></span><br><span class="line">	<span class="type">double</span> price;			<span class="comment">//临时变量</span></span><br><span class="line">	is&gt;&gt;item.units_sold&gt;&gt;item.bookNo&gt;&gt;price;	<span class="comment">//读取</span></span><br><span class="line">	<span class="keyword">if</span>(is)		<span class="comment">//检查输入是否成功</span></span><br><span class="line">		item.revenue=item.unit_sold*price;</span><br><span class="line">	<span class="keyword">else</span>			<span class="comment">//失败，则置为默认状态</span></span><br><span class="line">		item=<span class="built_in">Sales_data</span>();</span><br><span class="line">	retuen is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="算术和关系运算符">12.2 算术和关系运算符</h5>
<p>我<strong>们把算术和关系运算符定义为非成员函数来允许对左侧或右侧的运算对象进行转换，因为不需要改变运算对象的状态，形参都是常量的引用。</strong> 算术运算符计算它的两个对象并得到一个新值，有区别于任意一个运算对象，位于一个局部变量内，操作完成后返回该局部变量的副本 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data&amp;,rhs)&#123;</span><br><span class="line">	Sales_data sum=lhs;</span><br><span class="line">	sum+=rhs;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="相等运算符">12.2.1 相等运算符</h6>
<p>C++中的相等运算符应当比较每一个数据成员，当对应的成员都相等时才认为两个对象相等，所以我们的相等运算符不但应当比较<code>bookNo</code>，还应当比较具体的销售数据。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data&amp; rhs)&#123;</span><br><span class="line">	<span class="keyword">return</span>	lhs.<span class="built_in">isbn</span>()==rhs.<span class="built_in">isbn</span>()&amp;&amp;lhs.<span class="built_in">units_sold</span>()==rhs.<span class="built_in">units_sold</span>()</span><br><span class="line">	&amp;&amp;lhs.<span class="built_in">revenue</span>()==rhs.<span class="built_in">revenue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data&amp; rhs)&#123;</span><br><span class="line">	<span class="keyword">return</span> !lhs==rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>显然如果一个类有判断两个对象是否相等的操作，我们应当重载运算符而不是新增函数，更容易使用</li>
<li>定义了<code>operator==</code>应当能判断一组给定的对象中是否有重复数据</li>
<li>相等运算符应当具有传递性，既<code>a==b、b==c</code>为真,那么<code>a==c</code>也该为真</li>
<li>定义了<code>operator==</code>则应该定义<code>operator!=</code>并且可以利用已经重载的运算符来实现另一个运算符（如上例）</li>
</ul>
<h6 id="关系运算符">12.2.2 关系运算符</h6>
<ul>
<li><p>关系运算符应当定义顺序关系，令其与关联容器中对关键字的要求一致 , 如果类同时含有==运算符的话，应当定义关系与其保持一致，如果两个对象是<code>!=</code>的，那么一个对象应当<code>&lt;</code>另外一个</p></li>
<li><p>需要指出的是，<code>Sales_data</code>是不存在逻辑可靠的<code>&lt;</code>定义的，首先，我们不能只比较<code>ISBN</code>，如果<code>ISBN</code>相同但<code>revenue</code>和<code>units_sold</code>是不相等的，但一个对象<code>units_sold</code>大，一个<code>revenue</code>大，所以一个对象并不比另一个小（任意对象不比另一个小，按道理讲这两个对象是相等的），但对象其实又不是相等的，所以逻辑会出现问题。所以像这种类不定义<code>&lt;</code>比较好</p></li>
</ul>
<h5 id="赋值运算符">12.3 赋值运算符</h5>
<p>将类的一个对象赋值给另一个对象，类也可以定义其他赋值运算符来使用a值运算符：它可以使用别的类型作为右值： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrVec&amp; <span class="keyword">operator</span>=(Strvec&amp; li)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;li)&#123;</span><br><span class="line">			<span class="keyword">this</span>.elements=li.elements;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	StrVec&amp; <span class="keyword">operator</span>+=(Strvec&amp; li)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;li)&#123;</span><br><span class="line">			<span class="keyword">this</span>.elements+=li.elements;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="下标运算符">12.4 下标运算符</h5>
<p>下标运算符必须是<strong>成员函数，通常以所访问的元素的引用作为返回值</strong>，进一步，最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，返回常量引用来确保不会对返回的对象赋值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index)&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.<span class="built_in">size</span>()&lt;index<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;index is out of range&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> elements[index];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.<span class="built_in">size</span>()&lt;index<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;index is out of range&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> elements[index];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="递增和递减运算符">12.5 递增和递减运算符</h5>
<p>在迭代器类中通常会实现递增运算符<code>++</code>和递减运算符<code>--</code>，着两种运算符使得类可以在元素序列中前后移动，建议将其设为成员函数。其有前置和后置版本: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	A&amp; <span class="keyword">operator</span>++();</span><br><span class="line">	A&amp; <span class="keyword">operator</span>--();</span><br><span class="line">	A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>);		<span class="comment">//后置版本</span></span><br><span class="line">	A&amp; <span class="keyword">operator</span>--(<span class="type">int</span>);		<span class="comment">//后置版本</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">	++num;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	--num;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 前置后置运算符使用同一个符号，意味着其重载版本所用的名字是相同的，并且运算对象的数量和类型也相同，为了解决这个问题，后置版本接受一个额外的int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是参加运算。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	A* ret=<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> *ret;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	A* ret=<span class="keyword">this</span>;</span><br><span class="line">	--*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> *ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="成员访问运算符">12.6 成员访问运算符</h5>
<p>在迭代器类和智能指针类中，常常会用到解引用运算符<code>*</code>和箭头运算符。类成员访问运算符<code>*</code>和<code>-&gt;</code>可以被重载，但它较为麻烦。<strong>它被定义用于为一个类赋予&quot;指针&quot;行为。运算符<code>-&gt;</code> 必须是一个成员函数。如果使用了<code>-&gt;</code> 运算符，返回类型必须是指针或者是类的对象。</strong></p>
<p>运算符 <code>-&gt;</code> 通常与指针引用运算符 <code>*</code> 结合使用，用于实现&quot;智能指针&quot;的功能。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁时，或者当指针指向另一个对象时，会自动删除对象。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(vector&lt;<span class="type">int</span>&gt; vec) :<span class="built_in">vec</span>(vec) &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span>*() &#123;	<span class="comment">//返回类型</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;vec[current++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> current=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;* ve = &amp;vec;</span><br><span class="line">	<span class="function">B <span class="title">m</span><span class="params">(vec)</span></span>;</span><br><span class="line">	*m;</span><br><span class="line">	B* x = &amp;m;</span><br><span class="line">	x-&gt;<span class="keyword">operator</span>-&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt;运算符<code>-&gt;</code>的重载比较特别，它只能是非静态的成员函数形式，而且没有参数。如果返回值是一个原始指针，那么就将运算符的右操作数当作这个原始指针所指向类型的成员进返回；如果返回值是另一个类型的实例，那么就继续调用这个返回类型的 <code>operator-&gt;()</code> ，直到有一个调用返回一个原始指针为止，然后按第一种情况处理。</p>
<p>既然<code>-&gt;</code> 的重载可以返回一个类型的实例而非指针，那如果返回本身的类型呢，它会继续调用自己的<code>operator-&gt;()</code>，永无止尽 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Joke</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Joke&amp; <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Joke j;</span><br><span class="line">    std::cout &lt;&lt; j-&gt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其中 <code>j-&gt;i</code> 会导致自身的 operator-&gt;() 被无限调用。但编译器不是傻子，在使用GCC 4.8.2编译的时候，直接报错： <figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>circular pointer delegation detected</span><br></pre></td></tr></table></figure></p>
<h5 id="函数调用运算符">12.7 函数调用运算符</h5>
<p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类得对象成员函数: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">absInt</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value&lt;<span class="number">0</span>?-value:value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line">absInt  abs;</span><br><span class="line"><span class="type">int</span> ui=<span class="built_in">abs</span>(<span class="number">-40</span>);		<span class="comment">//对类对象像调用函数一样调用</span></span><br></pre></td></tr></table></figure></p>
<h5 id="类型转换运算符">12.8 类型转换运算符</h5>
<p>在讲类的时候，<strong>提到单个参数的构造函数定义了一种隐式类型转换</strong>。这里，我们通过类型转换运算符和转换构造函数共同定义类类型转换，也被称为用户定义的类型转换</p>
<h6 id="类型转换运算符-1">12.8.1 类型转换运算符</h6>
<p><strong>是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型</strong>。<code>operator type()const</code>该运算符没有显式的返回类型，形参，必须定义成类的成员函数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SmallInt</span>(<span class="type">const</span> <span class="type">int</span>&amp; i = <span class="number">0</span>) :<span class="built_in">val</span>(i) &#123;	<span class="comment">//转换构造函数</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i&gt;<span class="number">255</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Bad_int_value&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">aadd</span><span class="params">(<span class="type">const</span> SmallInt&amp; s)</span> </span>&#123; <span class="keyword">return</span> val + s.<span class="built_in">get</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;		<span class="comment">//类型转换运算符</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure> 定义了内置类型向类型的转换(转换构造函数），也定义了类类型向内置类型的转换(类型转换运算符） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SmallInt si;		<span class="comment">//构造函数 si=0,si为Smallint对象</span></span><br><span class="line">	si = <span class="number">4</span>;				<span class="comment">//合成默认赋值运算符 si=4，si为Smallint对象</span></span><br><span class="line">	<span class="type">int</span> i=si+<span class="number">3</span>;			<span class="comment">//调用类型转换运算符，si转换为int</span></span><br><span class="line">	si.<span class="built_in">aadd</span>(i);			<span class="comment">//会调用单参const构造函数构造零时对象，后在调用aadd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型转换运算符可能有意外结果，因为如果类型转换自动发生，用户可能感觉意外。我们经常会定义向bool的转换，但是类类型的对象转换为bool后就能被用在任何需要算术类型的地方<code>int i=42; cin&lt;&lt;i;</code>会造成cin转换为bool类型，然后左移位i个位置。为防止这样的情况发生，C++11=-引入了显式类型转换运算符: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;		<span class="comment">//类型转换运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示调用</span></span><br><span class="line"><span class="type">int</span> i=si.<span class="keyword">operator</span> <span class="built_in">int</span>() + <span class="number">3</span>;			<span class="comment">//si转换为int</span></span><br></pre></td></tr></table></figure> 这种情况下当显式地请求转换，才会执行类类型到内置类型的转换。但是如果表达式被用作条件，编译器将会执行显式的类型转换。<strong>即如果表达式出现在：<code>if while do的条件部分，for语句头的条件表达式，逻辑与或非</code>，显式类型转换将会被隐式执行</strong>。</p>
<h6 id="避免二义性的类型转换">12.8.2 避免二义性的类型转换</h6>
<p>需要确保在类类型和目标类型之间只存在唯一一种转换方式，否则代码会有二义性。</p>
<ul>
<li>比如两个类提供了相同的类型转换方式，或者一个类定义了多个转换运算符。存在二义性，就必须显式地调用类型转换运算符或者转换构造函数。</li>
<li>如果定义了多个参数都为算术类型的构造函数和对应类型转换运算符，有可能会产生二义性，原因是在隐式类型转换时，标准类型转换级别一致，这决定了编译器选择最佳匹配的过程。如果转换级别有一个更高，则不会出现二义性错误</li>
</ul>
<h4 id="函数对象">13. 函数对象</h4>
<h5 id="lambda是函数对象">13.1 lambda是函数对象</h5>
<p>我们编写一个<code>lambda</code>后，编译器将表达式翻译成一个未命名类的未命名对象，这个类中有一个重载的函数调用运算符。如下面这个<code>lambda</code>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">const</span> string&amp;a,<span class="type">const</span> string&amp;b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();&#125;);</span><br></pre></td></tr></table></figure> 相似于下面类对象：由于默认情况下<code>lambda</code>不能改变它捕获的变量，因此在默认情况下<code>lambda</code>生成的类当中的函数调用运算符是<code>const</code>成员函数: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shorter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp;a,<span class="type">const</span> string&amp;b)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="生成类对于lambda的值捕获与引用捕获的不同">13.2 生成类对于lambda的值捕获与引用捕获的不同</h5>
<p><strong>当<code>lambda</code>表达式通过</strong>引用捕获变量时<strong>，程序确保<code>lambda</code>执行引用时所引用的对象确实存在，编译器可以直接使用该引用而无需再<code>lambda</code>产生的类中将其存储。但是通过值捕获时，在<code>lambda</code>生成的类中需要为值捕获的变量生成数据成员，创建构造函数：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> w=<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[sz](<span class="type">const</span> string&amp;a,)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;&#125;);</span><br></pre></td></tr></table></figure> 该<code>lambda</code>值捕获<code>sz</code>，则其产生的类将形如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sizecmp</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Sziecamp</span>(<span class="type">size_t</span> n):<span class="built_in">sz</span>(n)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp;a)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">size_t</span> sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 标准库定义了一组表示算术、关系、逻辑运算符的类，都被定义成模板的形式，可以为其指定具体的应用类型即调用运算符的形参类型。</p>
<h5 id="标准库定义的函数对象">13.3 标准库定义的函数对象</h5>
<p>标准库定义了一组表示算术、关系、逻辑运算符的类，都被定义成模板的形式，可以为其指定具体的应用类型即调用运算符的形参类型。 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/func.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">plus&lt;<span class="type">int</span>&gt; intadd;</span><br><span class="line"><span class="type">int</span> sum=<span class="built_in">intadd</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure> 表示运算符的函数对象类常用来替换算法中的默认运算符，如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用greater代替默认的，此时执行降序排序</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),greater&lt;string&gt;);</span><br></pre></td></tr></table></figure> 第三个实参是<code>greater&lt;string&gt;</code>类型的一个未命名的对象，需要注意的是，标准库定义的函数对象也适用于指针，但不能用大于小于号而是用<code>less</code>函数对象</p>
<h5 id="可调用对象与function">13.4 可调用对象与function</h5>
<p><strong><code>function</code>函数是一直通用、多态的函数封装，它的实例可以对任何可以调用的目标进行存储、赋值和调用操作。是C++现有的对可以调用实体的一种安全的包裹，简而言之，<code>function</code>就是可调用对象的容器。</strong> 进一步讲，<code>function</code>模板类就是为了解决<code>lambda</code>表达式的存入问题，因为每个<code>lambda</code>有它自己的类型，该类型会与<code>map</code>中的定好的值的类型不匹配，步骤：</p>
<ul>
<li><strong>C++的可调用对象有：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类</strong>，其实可调用对象也有类型，每个<code>lambda</code>有它自己唯一的类类型，函数及函数指针的类型由其返回值和实参类型决定</li>
<li><strong>不同类型的可调用对象可能共享同一种调用形式</strong>，指明了返回类型和传递给调用的实参类型。例如普通函数加、<code>lambda</code>表达式减和函数对象类除法的调用方法都为:<code>mod(a,b)</code>为了利用这些可调用对象，可以定义一个函数表来存储指向这些可调用对象的指针。</li>
<li>用运算符符号的<code>string</code>对象作为关键字，<strong>用实现运算符的函数作为值构建运算符到函数指针的映射</strong><code>map&lt;string, function&lt;int(*)(int,int)&gt;&gt; binops;</code></li>
<li>再利用<code>function&lt;T&gt; f</code>来创建可放入容器中的类型，无论函数指针，<code>lambda</code>表达式，函数对象、类的对象都可保存，<strong>但也不能把重载函数的名字直接存入<code>map</code>中，而是要利用函数指针或者<code>lambda</code>表达式</strong>；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line">map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; bin;</span><br><span class="line"><span class="built_in">int</span> (*fp)(<span class="type">int</span>,<span class="type">int</span>)=add;</span><br><span class="line">bin.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,fp&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/funcoperate.png" width="700"></p>
<h4 id="容器概述">14.容器概述</h4>
<h5 id="stl提供了六大组件">14.1 STL提供了六大组件</h5>
<ul>
<li>容器：各种数据结构,如<code>vector、list、deque、set、map</code>等,用来存放数据</li>
<li>算法：各种常用的算法（冒泡，排序）,如<code>sort、find、copy、for_each</code></li>
<li>迭代器：扮演了容器与算法之间的胶合剂（类似于指针等）</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理。注意一般都伴随着重新分配空间，那么原来的迭代器就会失效</li>
</ul>
<p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p>
<h5 id="三大重点组件">14.2 三大重点组件</h5>
<p>容器有<strong>序列式容器</strong>和<strong>关联式容器</strong>：</p>
<ul>
<li>序列式容器：序列式容器就是容器元素在容器中的位置是由元素进入容器的时间和地点来决定</li>
<li>关联式容器：关联式容器是指容器已经有了一定的规则，容器元素在容器中的位置由容器的规则来决定</li>
</ul>
<p>算法分为<strong>质变算法</strong>和<strong>非质变算法</strong>：</p>
<ul>
<li>质变算法：：是指运算过程中会更改区间内的元素的内容</li>
<li>非质变算法：是指运算过程中不会更改区间内的元素内容</li>
</ul>
<p><strong>迭代器</strong></p>
<ul>
<li><strong>输入迭代器</strong>：提供对数据的只读访问 只读，支持<code>++、==、！=</code></li>
<li><strong>输出迭代器</strong>：提供对数据的只写访问 只写，支持<code>++</code></li>
<li><strong>前向迭代器</strong>：提供读写操作，并能向前推进迭代器 读写，支持<code>++、==、！=</code></li>
<li><strong>双向迭代器</strong>：提供读写操作，并能向前和向后操作 读写，支持<code>++、--，</code></li>
<li><strong>随机访问迭代器</strong>：提供读写操作，并能在数据中随机移动 读写，支持<code>++、--、[n]、+n、-n、&lt;、&lt;=、&gt;、&gt;=</code></li>
</ul>
<p><strong>重点学习双向迭代器和随机访问迭代器</strong></p>
<ul>
<li>双向迭代器：++,--可以访问下一个元素和上一个元素(list、forward_list、关联容器set/map）</li>
<li>随机访问迭代器：+2，可以跳2个元素访问元素、下标访问（vector、deque、string、array)</li>
</ul>
<p>三大组件的关系：容器存储数据，并且提供迭代器，算法使用迭代器来操作容器中的元素</p>
<h5 id="stl优点">14.3 STL优点</h5>
<ul>
<li>STL是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li>
<li><strong>STL的一个重要特点是数据结构和算法的分离</strong>。尽管这是个简单的概念，但是这种分离使得 STL 变得非常通用。例如:在 STL 的<code>vector</code>容器中，可以放入元素、基础数据类型变量、元素的地址；STL 的<code>sort()</code>排序函数可以用来操作 <code>ector,list</code>等容器。</li>
<li>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就行了。这样他们就可以把精力放在程序开发的别的方面。</li>
<li>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</li>
</ul>
<p><strong>高可重用性</strong>：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知 识，已经给大家介绍了。</p>
<p><strong>高性能</strong>：如<code>map</code>可以高效地从十万条记录里面查找出指定的记录，因为<code>map</code>是采用红黑树的变体实现的。(红黑树是平横二叉树的一种) 高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</p>
<h4 id="序列式式容器">15. 序列式式容器</h4>
<p>所有容器类都有共享公共接口，不同容器按不同方式对其进行扩展</p>
<h5 id="顺序容器种类">15.1 顺序容器种类</h5>
<p>所有顺序容器都提供了快速顺序访问元素的能力。下表中的string我们已经在前面介绍，这里不重复做介绍： <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/rongqi.png" width="700"></p>
<ul>
<li><strong><code>string和vector</code>将元素保存在连续的内存空间内，因此由元素的下标来计算其地址是非常快速的</strong>。但是，在这两种容器的中间位置添加或删除元素就会非常耗时。即随机访问迭代器</li>
<li><strong><code>list</code>和<code>forward_list</code>在任何位置添加/删除元素都非常快速</strong>。作为代价，这两个容器不支持元素的随机访问。而且，与<code>vector、array、deque</code>相比，这两个容器的额外内存开销(指针开销)也很大。另外<code>forward_list</code>没有<code>size</code>操作。</li>
</ul>
<p><strong>确定使用哪种顺序容器:</strong></p>
<ul>
<li>通常使用vector是最好的选择，除非你有更好的理由选择其他容器</li>
<li>注重空间开销的，不要使用list或forward_list</li>
<li>只在头尾，不在中间插入/删除元素的，使用deque</li>
<li>在中间插入/删除元素的，使用list或forward_list</li>
</ul>
<p>总之选择哪一种容器需要依据需求而决定</p>
<h5 id="序列容器支持的操作概览">15.2 序列容器支持的操作概览</h5>
<h6 id="容器操作">15.2.1 容器操作</h6>
<p>对与序列式容器，它们有一些公共接口，支持相同的操作方式(除特别标注)： <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/rongqioperate.png" width="600"></p>
<h6 id="顺序容器操作迭代器">15.2.2 顺序容器操作：迭代器</h6>
<p>标准容器类型上所有迭代器都允许我们访问容器中的元素（通过解引用运算符来实现），所有迭代器都定义了递增运算符。 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/iteratoroperate.png" width="700"> 个迭代器的范围由一对迭代器表示，两个迭代器分别指向同一容器中的首元素<code>begin</code>和尾元素之后<code>end</code>的位置,其标准的数学表达为<code>[begin,end)</code>。 <strong>对一个非常量对象调用<code>begin、end、rbegin、rend</code>（反向跌代），得到的是返回<code>iterator</code>的版本；对一个<code>const</code>对象调用这些函数时，才会得到一个const版本</strong>。但以c开头的版本还是可以获得<code>const_iterator</code>的，而不管容器的类型是什么,<strong>因此当不需要写访问时，应使用<code>cbegin</code>和<code>cend</code>.</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;string&gt; a=&#123;<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;making&quot;</span>,<span class="string">&quot;track&quot;</span>,<span class="string">&quot;2025&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">begin</span>();		<span class="comment">//list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">rbegin</span>();	<span class="comment">//list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">cbegin</span>();	<span class="comment">//list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">crbegin</span>();	<span class="comment">//list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure></p>
<h6 id="顺序容器操作定义和初始化">15.2.3 顺序容器操作：定义和初始化</h6>
<p>每个容器都定义了一个默认构造函数（除array,它按默认方式初始化）: <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/rongqichushihua.png" width="700"></p>
<p><strong>1. 当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了，元素类型也可以不同，只要能将元素类型转换即可</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;string&gt; ls=&#123;<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;making&quot;</span>,<span class="string">&quot;track&quot;</span>,<span class="string">&quot;2025&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt;vec=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">ls_1</span><span class="params">(ls)</span></span>;		<span class="comment">//正确，类型匹配</span></span><br><span class="line"><span class="comment">//deque&lt;string&gt; dq(ls);		//错误，容器类型不匹配</span></span><br><span class="line"><span class="comment">//vector&lt;string&gt; ves(vec);	//错误，元素类型不匹配</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">ves</span><span class="params">(vec.begin(),vec.end())</span></span>;	<span class="comment">//正确，元素类型const char*可向string转换</span></span><br></pre></td></tr></table></figure> <strong>2. 与顺序容器大小相关的构造函数:除了有与关联容器相同的构造函数外，顺序容器（除array)还提供了另一个构造函数：它接受一个容器大小和一个（可选的）元素初始值。如果不提供元素初始值，则标准库会创建一个值初始化器</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">veci</span><span class="params">(<span class="number">10</span>,<span class="number">-1</span>)</span></span>;	<span class="comment">//10个int元素，初始值为-1</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">ls</span><span class="params">(<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>)</span></span>;	<span class="comment">//10个string元素，初始值为hi</span></span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">fls</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//10个int元素，初始值为0，注意区分()和&#123;&#125;</span></span><br></pre></td></tr></table></figure> <strong>3. 标准库array具有固定大小：大小也是array类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,10&gt; ia1;		<span class="comment">//默认初始化10个int</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; ia2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;	<span class="comment">//列表初始化</span></span><br><span class="line">array&lt;<span class="type">int</span> 10&gt;ia3=&#123;<span class="number">10</span>&#125;;					<span class="comment">//第一个元素围为10，其余为0</span></span><br><span class="line"><span class="comment">//但ia3定义后在这样赋值不允许：(因为array不允许插入和删除）</span></span><br><span class="line">ia3=&#123;<span class="number">10</span>&#125;;	<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//数组类型无法拷贝和赋值，但array可以</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; ia4=ia2;		<span class="comment">//只有数组类型匹配array&lt;int,10&gt;即合法</span></span><br></pre></td></tr></table></figure></p>
<h6 id="顺序容器操作添加元素">15.2.4 顺序容器操作：添加元素</h6>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/pushback.png" width="700"> <strong>1. 除<code>array</code>和<code>forward_list</code>之外，每个顺序容器（包括<code>string</code>类型)都支持<code>push_back</code>,它将一个元素加到容器尾部:</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span>(<span class="type">size_t</span> cnt, string &amp;word)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt&gt;<span class="number">1</span>)</span><br><span class="line">word.<span class="built_in">push_back</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 除<code>string</code>和<code>vector</code>不支持<code>push_front</code>外，<code>list、forward_list、deque</code>容器都支持push_front,即将元素插入到容器头部</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> ix=<span class="number">0</span>;ix!=<span class="number">4</span>;++ix)</span><br><span class="line">p.<span class="built_in">push_front</span>(ix);</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 特定位置插入元素<code>insert</code>。forward_list有自己版本的<code>insert</code></strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; sece;</span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">begin</span>(),<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//插入范围元素</span></span><br><span class="line">ist&lt;string&gt; p=&#123;<span class="string">&quot;wwj&quot;</span>,<span class="string">&quot;love&quot;</span>&#125;;</span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">begin</span>(),<span class="number">10</span>,<span class="string">&quot;CRF&quot;</span>);		<span class="comment">//10个“CRF&quot;插入到容器头部</span></span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">begin</span>()+<span class="number">3</span>,p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//p容器的内容拷贝插入到了sece第四个元素前</span></span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">end</span>(),&#123;<span class="string">&quot;these&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="string">&quot;are&quot;</span>,<span class="string">&quot;finished&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//将元素值列表插入到尾部</span></span><br></pre></td></tr></table></figure> 以上的insert调用后，会返回新添加的第一个元素的迭代器，若没有插入元素则返回原迭代器</p>
<p><strong>4.c++新标准引入三个新成员：<code>emplace_front</code>对应<code>push_front</code>、<code>emplace_back</code>对应<code>push_back</code>、<code>emplace</code>对应<code>insert</code>。主要区别是这些操作是构造不是拷贝元素。也就说明传入给<code>emplace</code>的参数必须与元素类型的构造函数相匹配(即个数、类型一样），先假设有定义的<code>Sales_data</code>类型有一个三参构造函数：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;Sales_data&gt; c;</span><br><span class="line">c.<span class="built_in">emplace_back</span>(<span class="string">&quot;p78&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"><span class="comment">//该式子等价于c.push_back(Sales_data(&quot;p78&quot;,20,30));</span></span><br></pre></td></tr></table></figure></p>
<h6 id="顺序容器操作访问元素">15.2.5 顺序容器操作：访问元素</h6>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/fangwen.png" width="700"> 这些访问操作（<code>back、front</code>、下标、<code>at</code>)返回的都是引用，如果容器是一个<code>const</code>对象，则返回的是<code>const</code>的引用，不是则返回普通的引用（可以改变元素值）。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!c.<span class="built_in">empty</span>())&#123;</span><br><span class="line">	c.<span class="built_in">front</span>()=<span class="number">42</span>;	<span class="comment">//将42赋予c的第一个元素</span></span><br><span class="line">	<span class="keyword">auto</span> &amp;v1=c.<span class="built_in">back</span>();</span><br><span class="line">	v1=<span class="number">1024</span>;		<span class="comment">//改变最后一个元素的值</span></span><br><span class="line">	<span class="keyword">auto</span> v2=c.<span class="built_in">back</span>();</span><br><span class="line">	v2=<span class="number">0</span>;		<span class="comment">//无法改变值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="顺序容器操作删除元素">15.2.6 顺序容器操作：删除元素</h6>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/delete.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除list中的所有奇数：</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it=lst.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it!=lst.<span class="built_in">end</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span>(*it%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">		it=lst.<span class="built_in">erase</span>(it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="顺序容器操作赋值和swap">15.2.7 顺序容器操作：赋值和swap</h6>
<p>该表中的赋值运算符可用于所有容器: <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/fuzhi.png" width="700"></p>
<p><strong>1. 赋值运算符<code>=</code>要求左边和右边的运算对象具有相同的类型。<code>assign</code>允许我们从一个相容 的类型赋值，或者从容器一个子序列赋值</strong>(由于左右两边的运算容器大小可能不同，所有<code>array</code>无法使用<code>assign</code>)。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本一：</span></span><br><span class="line">list&lt;string&gt;names;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt;oldstyle&#123;<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>,<span class="string">&quot;man&quot;</span>&#125;;</span><br><span class="line">names.<span class="built_in">assign</span>(oldstyle.<span class="built_in">cbegin</span>(),oldstyle.<span class="built_in">cend</span>());	<span class="comment">//names的元素替换为oldstyle中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">slist</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">//1个元素且为空字符串</span></span><br><span class="line">slist.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="string">&quot;Hello&quot;</span>）；	<span class="comment">//10个元素且都为Hello</span></span><br></pre></td></tr></table></figure></p>
<p><strong><code>swap</code>操作交换两个相同类型容器的内容。除<code>array</code>外，交换两个容器内容的操作保证会很快——元素本身未交换，swap只是交换了两个容器的内部数据结构（即只是交换了第一次指向的指针)。即也代表着指向容器的迭代器、引用和指针在<code>swap</code>前后都不会改变（除<code>string</code>、<code>array</code>容器）</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">s1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">vector&lt;string&gt;<span class="built_in">s2</span>(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">swap</span>(s1,s2);		<span class="comment">//执行完后s1指向的是30个元素，s2是（42）</span></span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong>对于<code>array</code>，<code>swap</code>会真正交换它们的元素。</p>
<h6 id="顺序容器操作改变容器大小">15.2.8 顺序容器操作：改变容器大小</h6>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/resize.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst</span><span class="params">(<span class="number">10</span>,<span class="number">42</span>)</span></span>;</span><br><span class="line">lst.<span class="built_in">resize</span>(<span class="number">20</span>);		<span class="comment">//将后10个值赋值为0</span></span><br><span class="line">lst.<span class="built_in">resize</span>(<span class="number">30</span>,<span class="number">-1</span>);	<span class="comment">//将10个值为-1的添加到尾部</span></span><br><span class="line">lst.<span class="built_in">resize</span>(<span class="number">10</span>);		<span class="comment">//删除后20个元素</span></span><br></pre></td></tr></table></figure></p>
<h6 id="容器操作可能使迭代器失效">15.2.9 容器操作可能使迭代器失效</h6>
<p>在对容器进行添加删除可能会使迭代器失效。一个失效的指针、引用和迭代器只是不再表示任何元素。此题的<code>vector</code>的<code>end</code>作为条件，要时时刻刻在插入或删除后更新。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>，<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter=vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(iter!=vi.<span class="built_in">end</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span>(*iter%<span class="number">2</span>)&#123;</span><br><span class="line">		iter=vi.<span class="built_in">insert</span>(iter,*iter);	<span class="comment">//返回插入后的的迭代器</span></span><br><span class="line">		iter+=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		iter=vi.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="关系运算符-1">15.2.10 关系运算符</h6>
<ul>
<li>关系运算符两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素</li>
<li>比较两个容器实际上是进行元素的逐对比较，比较方式与string比较类似。</li>
<li>容器的关系运算符使用元素的关系运算符完成比较</li>
<li>只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</li>
</ul>
<h5 id="vector容器">15.3vector容器</h5>
<p><code>vector</code>是STL常用的容器之一，它和数组一样拥有连续的内存空间，但却比数组更好用。<strong><code>String</code>和<code>vector</code>均使用随机访问迭代器。<code>vector</code>在空间配置器下重新分配空间，那么原来的迭代器就会失效.</strong> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/vector.png" width="500"></p>
<h6 id="vector的扩容机制">15.3.1 vector的扩容机制</h6>
<p><strong>对于能够快速随机访问的(下标访问），其内存是连续的，当我们的内存不够时，容器必须分配新的内存空间来保存已有的和新的元素(即将旧内存的元素拷贝到新内存，添加新元素，释放旧内存），所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为O(n)。</strong>。</p>
<p>当不得不获取新的内存空间时，<code>vector</code>和<code>string</code>的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可以来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。<strong>在不同的编译器中，vector的扩容策略不相同，msvc编译器每次是以1.5倍且向下取整的策略进行扩容，gcc编译器则是每次以2.0倍的策略进行扩容。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MSVC</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">34</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(n);</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;size:&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot;  capacity:&quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">size:<span class="number">1</span>  capacity:<span class="number">1</span></span><br><span class="line">size:<span class="number">2</span>  capacity:<span class="number">2</span></span><br><span class="line">size:<span class="number">3</span>  capacity:<span class="number">3</span></span><br><span class="line">size:<span class="number">4</span>  capacity:<span class="number">4</span></span><br><span class="line">size:<span class="number">5</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">6</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">7</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">8</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">9</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">10</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">11</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">12</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">13</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">14</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">15</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">16</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">17</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">18</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">19</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">20</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">21</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">22</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">23</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">24</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">25</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">26</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">27</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">28</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">29</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">30</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">31</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">32</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">33</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">34</span>  capacity:<span class="number">42</span></span><br></pre></td></tr></table></figure></p>
<h6 id="管理容量的成员函数">15.3.2 管理容量的成员函数</h6>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/managercapacity.png" width="700"></p>
<ul>
<li><code>reverse</code>并不改变容器中元素的数量，它仅影响<code>vector</code>预先分配多大的内存空间。</li>
<li>如果需求大小小于或等于当前容量，<code>reverse</code>什么也不做。且需求大小小于当前容量，容器不会退回内存空间。</li>
</ul>
<p><strong>源码：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type __new_size)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (__new_size &gt; <span class="built_in">size</span>()) </span><br><span class="line">		  _M_default_append(__new_size - <span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">		  _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start + __new_size);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//reserve</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (__n &gt; <span class="built_in">max_size</span>())</span><br><span class="line">	__throw_length_error(__N(<span class="string">&quot;vector::reserve&quot;</span>));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">capacity</span>() &lt; __n)</span><br><span class="line">	_M_reallocate(__n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="vector构造函数">15.3.3 vector构造函数</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; v; <span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br><span class="line"><span class="comment">//例子 使用第二个构造函数 我们可以...</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>; </span><br></pre></td></tr></table></figure>
<h6 id="vector数据存取操作">15.3.4 vector数据存取操作</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> idx); <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>
<h6 id="vector插入和删除操作">15.3.5 vector插入和删除操作</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele);<span class="comment">//迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line"><span class="built_in">push_back</span>(ele); <span class="comment">//尾部插入元素ele</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);<span class="comment">//删除迭代器指向的元素</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure>
<h5 id="deque容器">15.4 deque容器</h5>
<p><strong><code>Vector</code>容器是单向开口的连续内存空间，<code>deque</code>则是一种双向开口的连续线性空间</strong>。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/deque.png" width="500"></p>
<p>虽然<code>deque</code>容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和<code>vector</code>不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用<code>vector</code>，而不是<code>deque</code>。对<code>deque</code>进行的排序操作，为了最高效率，可将<code>deque</code>先完整的复制到一个<code>vector</code>中，对<code>vector</code>容器进行排序，再复制回<code>deque</code>.</p>
<h6 id="deque容器实现原理">15.4.1 deque容器实现原理</h6>
<p><strong><code>deque</code>是由一段一段的定量的连续空间构成。一旦有必要在<code>deque</code>前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在<code>deque</code>的头端或者尾端。<code>deque</code>最大的工作就是维护这些分段连续的内存空间的整体性的假象</strong>，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p>
<p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。 <strong><code>Deque</code>采取一块所谓的<code>map</code>(注意，不是STL的map容器)作为主控，这里所谓的<code>map</code>是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是<code>deque</code>的存储空间的主体。</strong> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/dequemap.png" width="500"></p>
<h6 id="deque常用api">15.4.2 deque常用API</h6>
<p><strong>1. deque构造函数</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;deq);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.deque赋值操作</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">deque&amp;<span class="keyword">operator</span>=(<span class="type">const</span> deque &amp;deq); <span class="comment">//重载等号操作符 </span></span><br><span class="line"><span class="built_in">swap</span>(deq);<span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3. deque双端插入和删除操作</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//删除容器第一个数据</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4. deque访问操作</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">at</span>(idx);<span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个数据。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure></p>
<p><strong>5. deque插入操作</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure></p>
<h5 id="list容器">15.5 list容器</h5>
<p><strong>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</strong> 相较于<code>vector</code>的连续线性空间，<code>list</code>就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，<code>list</code>对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，<code>list</code>永远是常数时间。</p>
<p><strong><code>list</code>和<code>vector</code>是两个最常被使用的容器。<code>list</code>容器是一个双向链表:</strong></p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
<li>链表灵活，但是空间和时间额外耗费较大 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/list.png" width="500"></li>
</ul>
<h6 id="list容器的迭代器">15.5.1 list容器的迭代器</h6>
<p><code>list</code>容器不能像<code>vector</code>一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。<code>list</code>迭代器必须有能力指向<code>list</code>的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”<code>list</code>正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员</p>
<p><strong>由于<code>list</code>是一个双向链表，迭代器必须能够具备前移、后移的能力，所以<code>list</code>容器提供的是Bidirectional Iterators.<code>list</code>有一个重要的性质，插入操作和删除操作都不会造成原有<code>list</code>迭代器的失效</strong>。这与<code>vector</code>是不同的，<code>vector</code>插入操作可能造内存重新配置导致原有的迭代器全部失效。</p>
<h6 id="list常用api">15.5.2 list常用API</h6>
<p><strong>1. list构造函数</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;T&gt; lstT;<span class="comment">//list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list &amp;lst);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. list数据元素插入和删除操作</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器中最后一个元素</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器开头插入一个元素</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">remove</span>(elem);<span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3. list赋值操作</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">list&amp;<span class="keyword">operator</span>=(<span class="type">const</span> list &amp;lst);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(lst);<span class="comment">//将lst与本身的元素互换。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4. list数据的存取、反转和排序</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素。</span></span><br><span class="line"><span class="built_in">reverse</span>();<span class="comment">//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span></span><br><span class="line"><span class="built_in">sort</span>(); <span class="comment">//list排序</span></span><br></pre></td></tr></table></figure></p>
<p><strong>5. list和forward_list独有的函数</strong> 与其他容器不同，链表类型的<code>list</code>和<code>forward_list</code>定义了几个成员函数形式的算法。<strong>特别的是，它们定义可独有的<code>sort、merge、remove、reverse、unique</code>。</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数名</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>lst.merge(lst2)</code></td>
<td style="text-align: center;">将<code>lst2</code>合并到<code>lst</code>,<code>lst</code>和<code>lst2</code>必须都是有序的，合并后<code>lst2</code>为空，默认为<code>&lt;</code>即升序合并</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>lst.merge(lst2,cmp)</code></td>
<td style="text-align: center;">使用给定的<code>cmp</code>合并</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>lst.remove(val)</code></td>
<td style="text-align: center;">内部调用<code>erase</code>删除给的值</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>lst.remove_if(pred)</code></td>
<td style="text-align: center;">使用一元谓词为真时删除</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>lst.reverse()</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>lst.sort()</code></td>
<td style="text-align: center;">升序排序</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>lst.sort(cmp)</code></td>
<td style="text-align: center;">使用谓词为真时排序</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>lst.unique()</code></td>
<td style="text-align: center;">去重，调用前必须有序</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>lst.unique(pred)</code></td>
<td style="text-align: center;">使用一元谓词为真时去重</td>
</tr>
</tbody>
</table>
<h4 id="适配器">16. 适配器</h4>
<p>除了顺序容器，还定义了三个顺序容器适配器：<code>stack（栈）、queue（队列）和priority_queue</code>。本质上，<strong>适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。</strong> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/shipeiqi.png" width="700"></p>
<h5 id="适配器使用概览">16.1 适配器使用概览</h5>
<h6 id="定义适配器">16.1.1 定义适配器</h6>
<p>每个适配器都定义了<strong>两个构造函数：默认构造函数创建一个空对象;接受一个容器的构造函数拷贝该容器来初始化适配器。（下面的API介绍）</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span>；	<span class="comment">//接受一个容器对象初始化适配器，deq是一个deque&lt;int&gt;</span></span></span><br></pre></td></tr></table></figure> <strong>默认情况下，<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是在<code>vector</code>之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;string,vector&lt;string&gt;&gt; str_stk;	<span class="comment">//在vector上实现空栈</span></span><br><span class="line">stack&lt;string,vector&lt;string&gt;&gt; <span class="built_in">str_stk</span>(sevc);	<span class="comment">//构造在vector上实现，并初始化</span></span><br></pre></td></tr></table></figure></p>
<h6 id="适配器限制">16.1.2 适配器限制</h6>
<p>所有的适配器都要求能够删除和添加元素的能力，因此适配器不能构造在array上实现：</p>
<ul>
<li><strong><code>stack</code>——要求有<code>pop、push</code>和<code>top</code>能力，所以可用（除<code>array、forward_list</code>）的容器构造</strong></li>
<li><strong><code>queue</code>——要求有<code>back、push、front、pop</code>能力，所以可构造在<code>list、deque</code>，不能<code>vector</code></strong></li>
<li><strong><code>priority_queue</code>——要求有<code>front、push、pop和top</code>，所以可用<code>vector、deque</code>，但不能<code>list</code></strong></li>
</ul>
<h5 id="stacks适配器">16.2 stacks适配器</h5>
<p><code>stack</code>是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。<code>stack</code>容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取<code>stack</code>的其他元素。换言之，<code>stack</code>不允许有遍历行为。有元素推入栈的操作称为:<code>push</code>,将元素推出的操作称为<code>pop</code>. <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/stack.png" width="500"> <strong>栈适配器默认基于<code>deque</code>实现，也可以在<code>list</code>和<code>vector之</code>上实现</strong>。虽然<code>stack</code>是基于<code>deque</code>实现的，但我们不能调用<code>push_back</code>等等这些操作，我们必须调用它自己的操作。</p>
<h6 id="stack常用api">16.2.1 stack常用API</h6>
<p>Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，<strong>也不提供迭代器。</strong></p>
<p><strong>1. stack构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;<span class="comment">//stack采用模板类实现， stack对象的默认构造形式： </span></span><br><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack &amp;stk);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p><strong>2. stack数据存取操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>
<p><strong>3. stack赋值操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&amp;<span class="keyword">operator</span>=(<span class="type">const</span> stack &amp;stk);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>
<h5 id="queue适配器">16.3 queue适配器</h5>
<p><code>queue</code>是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，<code>queue</code>容器允许从一端新增元素，从另一端移除元素。<code>queue</code>默认基于<code>deque</code>实现，<code>priority_queue</code>默认基于<code>vector</code>实现</p>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/queue.png" width="500"></p>
<h6 id="queue常用api">16.3.1 queue常用API</h6>
<p><code>queue</code>所有元素的进出都必须符合”先进先出”的条件，只有<code>queue</code>的顶端元素，才有机会被外界取用。<code>queue</code><strong>不提供遍历功能，也不提供迭代器</strong>。</p>
<p><strong>1. queue构造函数</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：</span><br><span class="line">queue(const queue &amp;que);//拷贝构造函数</span><br></pre></td></tr></table></figure></p>
<p><strong>2. queue赋值操作</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&amp;<span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3.queue存取、插入和删除操作</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure></p>
<h4 id="关联式容器">17. 关联式容器</h4>
<h5 id="关联容器概述">17.1 关联容器概述</h5>
<p>与顺序容器不同，<strong>关联容器中的元素是按着元素的关键字来保存和访问的</strong>。顺序容器中的元素是按着它们在容器中的位置来顺序保存和访问。c++两个主要的关联容器是<code>map</code>和<code>set</code>。 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/guanlian.png" width="700"></p>
<ul>
<li><code>map</code>中的元素是关键字-值<code>key-value</code>对。关键字起到索引的作用，值则是与索引相关联的数据。</li>
<li><code>set</code>中只包含一个关键字，<code>set</code>支持高效的关键字查询操作——检查一给定关键字是否在<code>set</code>中</li>
<li>标准库提供8个关联容器，它们的不同体现在三个维度上：<strong>①每个容器或者是个set或者是个map;②或者要求不重复的关键字，或者允许重复关键字；③按顺序保存元素，或者无序保存元素</strong></li>
<li>允许重复关键字关键字的容器名字中都包含<code>multi</code>;不保持关键字按顺序存储的容器的名字都以单词<code>unordered</code>开头。<strong>无序容器使用哈希函数来组织元素</strong>。</li>
<li>类型<code>map</code>和<code>multimap</code>定义在头文件<code>map</code>中，<code>set</code>和<code>multiset</code>定义在头文件<code>set</code>中。无序容器则定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中</li>
<li><strong><code>map、multimap、set、multiset</code>都是以红黑树为底层实现机制。<code>unordered_map</code>、<code>unordered_set</code>底层哈希表的实现机理</strong></li>
</ul>
<h5 id="关键字类型要求">17.2 关键字类型要求</h5>
<p>对于有序容器<code>map、multimap、set、multiset</code>，<strong>关键字类型必须定义元素比较的方式</strong>。默认情况下，标准库使用关键字类型的<code>&lt;</code>运算来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。</p>
<p>传递给排序算法的可调用对象必须满足与关联容器中关键字一样的类型要求。<strong>我们可以自定义操作来代替关键字上的<code>&lt;</code>操作，但所提供的操作必须在关键字类型上定义一个严格弱序——可以看做“小于等于”</strong>。在实际编程中，重要的是，如果一个类型定义了“行为正常”的&lt;运算符，则它可以用作关键字类型。</p>
<p><strong>当关键字类型使用自己定义的操作时，必须在定义关联容器类型时提供此操作的类型。即用尖括号指出要定义哪种类型的容器，自定义的操作必须在尖括号中紧跟着元素类型给出。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data&amp; a,<span class="type">const</span> Sales_data&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a,<span class="built_in">isbn</span>()&lt;b.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">multiset&lt;Sales_data,<span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt;	<span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="pair类型">17.3 pair类型</h5>
<p>对组<code>pair</code>将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用<code>pair</code>的两个公有属性<code>first</code>和<code>second</code>访问。<code>pair</code>与<code>map、multimap</code>和<code>unorderedmap</code>等联合使用. <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/pair.png" width="700"></p>
<h5 id="都支持的操作">17.4 都支持的操作</h5>
<p><strong>1. 关联容器（有序和无序）都支持表9.2的容器操作。但不支持顺序容器的位置相关操作。如<code>push</code>和<code>pop</code>,因为关联容器是根据关键字存储的。关联容器也不支持构造函数或者插入操作这些接受一个元素值和一个数量值得操作。关联容器的迭代器都是双向的。</strong> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/guanlianoperate.png" width="600"></p>
<p><strong>2. 除了上面表9.2操作，还有如下操作：</strong> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/leixingbieming.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;		<span class="comment">//v1时一个string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;		<span class="comment">//v2是一个string</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;::value_type v3;	<span class="comment">//v3是一个pair&lt;const string,int&gt;</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;::mapped_type v4;	<span class="comment">//v4是一个int</span></span><br></pre></td></tr></table></figure></p>
<h5 id="map和multimap">17.5 map和multimap</h5>
<p><strong><code>map</code>类型通常被称为关联数组，其与普通数组类似，不同之处在于其下标不必是整数，我们通过一个关键字而不是位置来查找值</strong>。如查找电话号码：我们可以把联系人名字作为关键字，电话号码作为值。<strong><code>map</code>与<code>multimap</code>的不同就是<code>map</code>不允许关键字重复，而<code>multimap</code>则相反。它们存储的元素是<code>pair</code>.</strong></p>
<p>我们不可以通过的迭代器改变它们的的键值，<strong>因为<code>map</code>和<code>multimap</code>的键值关系到元素的排列规则，任意改变键值将会严重破坏组织。如果想要修改元素的实值，那么是可以的。</strong></p>
<h6 id="map定义">17.5.1 map定义</h6>
<p>支持空容器、拷贝初始化、范围初始化、值初始化，赋值初始化 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_count_1;		<span class="comment">//空map</span></span><br><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_count_2&#123;&#123;<span class="string">&quot;trluper&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;github&quot;</span>,<span class="number">2</span>&#125;&#125;;	<span class="comment">//初始化列表</span></span><br><span class="line"><span class="function">map&lt;string,<span class="type">size_t</span>&gt; <span class="title">word_count_3</span><span class="params">(word_count_2)</span>		<span class="comment">//拷贝初始化</span></span></span><br><span class="line"><span class="function">map&lt;string,<span class="type">size_t</span>&gt; <span class="title">word_count_4</span><span class="params">(word_count.begin(),word_count.end())</span></span>;	<span class="comment">//迭代器初始化</span></span><br></pre></td></tr></table></figure></p>
<h6 id="map和multimap迭代器">17.5.2 map和multimap迭代器</h6>
<p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的<code>value_type</code>的值的引用。必须记住，一个<code>map</code>的<code>value_type</code>是一个<code>pair</code>，我们可以改变<code>pair</code>的值，<strong>但是不能改变关键字成员的值</strong>,因为它是个<code>const</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得map迭代器</span></span><br><span class="line"><span class="keyword">auto</span> map_it=mymap.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//map_it是指向一个pair&lt;const string,size_t&gt;对象的迭代器</span></span><br><span class="line">cout&lt;&lt;map_it-&gt;fist&lt;&lt;<span class="string">&quot;---&quot;</span>&lt;&lt;map_it-&gt;second;</span><br><span class="line">++map_it-&gt;second;</span><br></pre></td></tr></table></figure></p>
<h6 id="添加元素">17.5.3 添加元素</h6>
<p>对map执行insert，必须记住元素类型是pair，且返回的是<code>pair&lt;iterator,boo&gt;</code>,第一个插入后返回的迭代器，指向指定关键字的迭代器，第二个是插入是否成功。有以下4中添加方法 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">insert</span>(...); <span class="comment">//往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStu;</span><br><span class="line"><span class="comment">// 第一种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;小张&quot;</span>));</span><br><span class="line"><span class="comment">// 第二种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">inset</span>(<span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="string">&quot;校长&quot;</span>));</span><br><span class="line"><span class="comment">// 第三种 通过value_type的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>, <span class="string">&quot;小李&quot;</span>));</span><br><span class="line"><span class="comment">// 第四种 通过数组的方式插入值</span></span><br><span class="line">mapStu[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>;</span><br><span class="line">mapStu[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>insert(v)（和emplace(args))</code>返回的是<code>pair</code>类型,如果关键字已在容器中，则<code>insert</code>什么事情也不用做，且返回值中的<code>bool</code>部分为<code>false</code>；如果关键字不存在，则元素被插入容器中，且<code>bool</code>值为<code>true</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_count;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)&#123;</span><br><span class="line">	<span class="comment">//插入一个元素，关键字为word,初始值为1</span></span><br><span class="line">	<span class="keyword">auto</span> ret=word_count.<span class="built_in">insert</span>(&#123;word,<span class="number">1</span>&#125;);</span><br><span class="line">	<span class="comment">//如果键值对早已存在，则对相应的键值对的值++</span></span><br><span class="line">	<span class="keyword">if</span>(!ret.second)</span><br><span class="line">		++ret.first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ret——是一个pair类型，&lt;map&lt;string,size_t&gt;::iterator,bool&gt;</span></span><br><span class="line"><span class="comment">ret.first——是一个map迭代器，指向具有指定关键字的元素</span></span><br><span class="line"><span class="comment">ret.first-&gt;——是个pair，&lt;string,size_t&gt; </span></span><br><span class="line"><span class="comment">ret.first-&gt;second——map中元素的值部分</span></span><br><span class="line"><span class="comment">++ret.first-&gt;second——递增此值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h6 id="删除元素">17.5.4 删除元素</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除所有元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(keyElem);<span class="comment">//删除容器中key为keyElem的对组。</span></span><br></pre></td></tr></table></figure>
<h6 id="查找操作">17.5.5 查找操作</h6>
<p>由于下标运算符可能插入一个新元素，我们只可以对非<code>const</code>的<code>map</code>使用下标操作: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下标操作</span></span><br><span class="line">c[k];	<span class="comment">//返回关键字为k的值，若k不存在则添加键为k的元素，对其值进行初始化</span></span><br><span class="line">c.<span class="built_in">at</span>(k);<span class="comment">//访问关键字元素为k的元素，若不在，抛出out_of_range异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lower_bound和upper_bound不适用于无序容器</span></span><br><span class="line">c.<span class="built_in">find</span>(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回map.end();</span></span><br><span class="line">c.<span class="built_in">count</span>(keyElem);<span class="comment">//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span></span><br><span class="line">c.<span class="built_in">lower_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">c.<span class="built_in">upper_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line">c.<span class="built_in">equal_range</span>(keyElem);<span class="comment">//返回pair,pair中的元素为容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：下标操作只有非常量<code>map</code>和<code>unordered_map</code>能用。<code>set</code>类型不支持下标，因为<code>set</code>中没有与关键字相关联的“值”。<code>multimap</code>和<code>undered_multimap</code>不支持下标操作，因为这些容器中可能有多个值与一个关键字相关联</em></strong></p>
<h5 id="set和multiset">17.6 set和multiset</h5>
<p><code>set</code>就是关键字的简单集合，当只想知道一个值是否存在时，<code>set</code>是最为恰当的。<code>set</code>是不可重复，而<code>multiset</code>可重复。<code>set</code>的许多操作同<code>map</code>一样</p>
<h6 id="set定义">17.6.1 set定义</h6>
<p>同map一样支持支持空容器、拷贝初始化、范围初始化、值初始化，赋值初始化。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;string&gt; set1&#123;<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;github&quot;</span>&#125;;</span><br><span class="line"><span class="function">set&lt;string&gt; <span class="title">set2</span><span class="params">(set1)</span></span>;</span><br><span class="line"><span class="function">set&lt;string&gt; <span class="title">set3</span><span class="params">(set1.begin(),set1.end())</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h6 id="迭代器">17.6.2 迭代器</h6>
<p><code>set</code>的迭代器是<code>const</code>的，同<code>ma</code>p一样<code>set</code>中的关键字也是<code>const</code>的，可以用一个<code>set</code>迭代器来读取元素的值，但不能修改。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; iset=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator set_it=iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span>(set_it!=iset.<span class="built_in">end</span>())&#123;</span><br><span class="line">	<span class="comment">//*set_it=42;		//非法,set的关键字是const，不能修改</span></span><br><span class="line">	cout&lt;&lt;*set_it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>省下操作略写，map的操作就是set操作，除了下标操作</strong></p>
<h5 id="关联无序容器">17.7 关联无序容器</h5>
<p>新标准定义了4个无序<code>unordered</code>容器，这些容器不是使用比较运算符来组织元素的，而是使用一个哈希函数<code>hash function</code>和关键字类型的<code>==</code>运算符。除了哈希管理外，无序容器还提供了与有序容器相同的操作<code>find,insert</code>等。</p>
<h6 id="管理桶">17.7.1 管理桶</h6>
<p><strong>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器采用哈希算法（函数）将元素映射到桶</strong>。为了访问一个元素，容器首先要计算元素的哈希值，它指出了应该搜索哪个桶。该无序容器会将一个特定哈希值的所有元素都保存在相同的桶中。（如果容器允许重复关键字，自然而然相同关键字的元素也都会在同一个桶中）。所有，无序容器的性能依赖哈希函数和桶的数量及大小。</p>
<p>对于相同的参数，哈希函数必然产生相同的结果。<strong>计算一个元素的哈希值和在桶中的搜索是很快的，但如果一个桶存放太多的元素，则查找一个特定的元素会进行大量比较操作</strong>。 无序容器提供了一组管理桶函数，这些成员函数允许我们查询容器状态以及在必要时强制容器重组。 <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/bucket.png" width="700"></p>
<h4 id="泛型算法">18. 泛型算法</h4>
<p>标准库容器定义的操作集合惊人的小。标准库并未给每个容器添加大量功能，而是提供了一组算法，这些算法中的大多数都独立于任何特定的容器。这些算法是通用的（generic，或称泛型的）：它们可以用于不同类型的容器和不同类型的元素</p>
<p>大多数算法都定义在头文件<code>algorithm</code>中。标准库还在头文件中定义了一组数值泛型算法。<strong>一般情况下，这些算法并不直接操作容器，而是遍历两个迭代器指定的一个元素范围来操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。</strong> 迭代器令算法不依赖于容器，但算法依赖于元素类型的操作算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素，也可能在容器中移动元素，但永远不会直接添加或删除元素。</p>
<h5 id="初始泛型算法">18.1 初始泛型算法</h5>
<h6 id="只读算法">18.1.1 只读算法</h6>
<p><code>find、count、accumulate，accumulate</code>定义在头文件<code>numeric</code>中,<strong>其只读取输入范围内的元素，而不改变元素.</strong></p>
<p><strong>1. accumulate函数接收3个参数，前两个指出了是需要求和的元素范围，第三个参数是求和的初值</strong>。第三个参数的类型决定了函数中使用哪个加法运算符和返回值类型，这个特性蕴含着：将元素类型加到和的类型上的操作使可行的，如下面<code>string</code>允许+，但<code>const char*</code>不允许，没有定义+ <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="built_in">accumulate</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">string sum=<span class="built_in">accumulate</span>(vs.<span class="built_in">begin</span>(),vs.<span class="built_in">end</span>(),<span class="built_in">string</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">//const char* 没有+运算符，不能使用</span></span><br><span class="line"><span class="comment">//string sum=accumulate(vc.begin(),v.end().&quot;&quot;);</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. 只读算法<code>equal</code>，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素比较。如果所有对应元素相等，则返回<code>true</code>，否则，返回<code>false</code></strong>。要求内部元素支持<code>==</code>运算符 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">equal</span>(v1.<span class="built_in">cbegin</span>(),v1.<span class="built_in">cend</span>(),v2.<span class="built_in">cbegin</span>());</span><br></pre></td></tr></table></figure></p>
<h6 id="写容器元素算法">18.1.2 写容器元素算法</h6>
<p>一些算法将新值赋予序列中的元素。<strong>必须注意保存序列原大小至少不小于我们要求算法写入的元素数目。算法不会执行容器操作，所以它们自身无法改变容器大小。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>);		<span class="comment">//每个元素重置为0</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">begin</span>()+vec.<span class="built_in">size</span>()/<span class="number">2</span>,<span class="number">10</span>);		<span class="comment">//将一半元素置为10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一些算法接受一个迭代器来指出一个单独的目的位置，新值从目的迭代器的位置开始插入。</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec;		<span class="comment">//空vector</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">size</span>(),<span class="number">0</span>); <span class="comment">//所有元素置为0，vec.size()=0,所以对于空容器没有发生错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素：（举个反例）</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec;	<span class="comment">//空vector</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(),<span class="number">10</span>,<span class="number">0</span>);		<span class="comment">//不允许，至少容器容量为10</span></span><br></pre></td></tr></table></figure></p>
<h6 id="back_inserter">18.1.3 back_inserter</h6>
<p>一种保证算法有足够的元素空间来容纳输出数据的方法是<strong>使用插入迭代器</strong>。<strong>插入迭代器是一种向容器添加元素的迭代器。</strong> <code>back_inserter</code>定义在<code>iterator</code>头文件中。<strong><code>back_inserter</code>接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中,并会返回下一个插入迭代器：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it=<span class="built_in">back_inserter</span>(vec);;</span><br><span class="line">*it=<span class="number">42</span>;		<span class="comment">//42</span></span><br><span class="line">*it=<span class="number">50</span>;		<span class="comment">//42 50</span></span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_insertor</span>(vec),<span class="number">10</span>,<span class="number">0</span>);		<span class="comment">//添加10个元素到vec:42 50 0 0 0 0 0 0 0 0 0 0</span></span><br></pre></td></tr></table></figure></p>
<h6 id="拷贝算法">18.1.4 拷贝算法</h6>
<p><strong>1. 拷贝算法<code>copy</code>接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置,返回拷贝后的下一个元素的迭代器。此算法使将输入范围的元素拷贝到目的序列中。所以目的序列的元素（内存空间）至少要和输入范围元素数量一样。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec_c</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//ret为vec_c拷贝元素的下一个元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> ret=<span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),vec_c.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure></p>
<p><strong>2. <code>replace</code>算法读入一个序列，并将其所有等于给定值得元素都改为另一个值，接受4个参数：前两个为迭代器，表示输入序列，后两个是要搜索得值、替换得值,位于<code>algorithm</code>头文件</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="built_in">replace</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>3.<code>replace_copy</code>,与<code>replace</code>不同，该算法保持原序列不变，而是生成了新序列将搜索值变为替换值。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; Mlist;</span><br><span class="line"><span class="built_in">replace_copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="built_in">back_inserter</span>(Mlist),<span class="number">0</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure> 此调用后，<code>vec</code>并未改变，<code>Mlist</code>包含<code>vec</code>的一份拷贝，不过原来在<code>vec</code>中值为0的元素在<code>Mlist</code>中都变为10.</p>
<h6 id="重排容器元素的算法">18.1.5 重排容器元素的算法</h6>
<ul>
<li>(1)某些算法会重排容器中元素的顺序，代表函数是<code>sort</code>。调用<code>sort</code>会重排输入序列中的元素，使之有序</li>
<li>(2)<code>unique</code>算法重拍序列，其把相邻重复项“消除”，并返回一个指向不重复值范围末尾的迭代器（但此words的大小没有改变）此位置之后的元素仍然存在，但是我们并不知道它们的值是什么。(去重)</li>
</ul>
<p><img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/unique.png" width="700"></p>
<p>这是需要用到容器操作erase删除该元素。代码如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">elimDups</span><span class="params">(vector&lt;sting&gt;&amp; words)</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">auto</span> it=<span class="built_in">unique</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">	words.<span class="built_in">erase</span>(it,words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="定制操作">18.2 定制操作</h5>
<p>很多算法都会比较输入序列的元素，这类算法使用元素类型的<code>&lt;</code>或<code>==</code>运算符完成比较。<strong>标准库还未这些算法定义了额外的版本，允许我们定义的操作来代替默认运算符。</strong></p>
<h6 id="用函数做谓词">18.2.1 用函数做谓词</h6>
<p><strong>向算法传递函数:</strong> 我们可以按照长度重排<code>vector</code>，所以要重载<code>sort</code>。<strong>此时，<code>sort</code>接受第三个参数，最后一个参数称为谓词。谓词是一个可调用的表达式，其返回结果是一个能用作条件的值</strong>。根据它们接受的参数数量，谓词可分为一元谓词和二元谓词。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。</p>
<p><strong>谓词：指普通函数或者重载了<code>operator()</code>且返回值是<code>bool</code>类型的的函数对象。函数对象和普通函数的区别：</strong></p>
<ul>
<li>1.函数对象可以有自己的状态</li>
<li>2.普通函数没有类型，函数对象有类型</li>
<li>3.函数对象比普通函数执行效率有可能更高（成员函数自动申请为内联函数）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br></pre></td></tr></table></figure>
<p>我们将<code>words</code>按大小重排的同时，还希望将具有相同长度的元素按字典排序。我们可以使用<code>stable_sort</code>算法。这种稳定的排序算法维持了相等元素的原有顺序。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br></pre></td></tr></table></figure> <strong><em>附：函数对象是指类中重载了()，而这个类实例化的对象就叫函数对像。又称仿函数</em></strong></p>
<h6 id="使用lambda">18.2.2 使用lambda</h6>
<p><strong><code>lambda</code>的主要时解决传递谓词时参数的限制，其可通过捕获列表来传递多个想要传给函数体的参数</strong>。就如<code>find_if</code>，<code>find_if</code>只接受一元谓词，因此传递给<code>find_if</code>的可调用对象必须接受单一参数。此时可调用对象（一元谓词）无法传递别的参数。用lambda表达式便能解决: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findLength</span><span class="params">(vector&lt;string&gt;&amp; words,vector&lt;string&gt;::size_type sz)</span></span>&#123;</span><br><span class="line">	<span class="built_in">elimDups</span>(words);</span><br><span class="line">	<span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br><span class="line">	<span class="keyword">auto</span> s=<span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">		[sz](<span class="type">const</span> string s1)&#123;<span class="keyword">return</span> s1.<span class="built_in">size</span>()&gt;sz;&#125;);		<span class="comment">//使用lambda捕获sz,符合要求便返回迭代器</span></span><br><span class="line">	for_each(s,words.<span class="built_in">end</span>(),</span><br><span class="line">		[](<span class="type">const</span> string&amp; a)&#123;cout&lt;&lt;s&lt;&lt;endl;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="bind使函数更加灵活的函数适配器">18.3 bind：使函数更加灵活的函数适配器</h5>
<p>对于<code>lambda</code>,如果捕获列表是空的，推荐不使用它而是使用函数。如果不为空，而那些定制的函数只要求传入一元或二元谓词的时候，使用<code>lambda</code>尤为重要。<strong>但是我们可能要在很多地方使用相同的操作，编写相同的<code>lambda</code>表达式会过于麻烦，此时应该定义一个函数。为解决上面的要求，我们引入了标准库<code>bind</code>函数</strong></p>
<p><strong><code>bind()</code>函数作为函数的适配器，它可以扩大函数是使用场合，使得函数更加灵活的被使用。</strong><code>bind</code>定义在头文件<code>functional</code>中。它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表（即适用上述只能传入一元和二元谓词的要求）</p>
<h6 id="bind的一般形式">18.3.1 bind的一般形式</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable=<span class="built_in">bind</span> (callable, arg_list);</span><br></pre></td></tr></table></figure>
<p><code>newcallable</code>是一个可调用对象，当<code>newcallable</code>被调用时，<code>newcallable</code>就调用<code>callable</code>，并将参数列表<code>arg_list</code>中的参数依次序给<code>callable</code>（<strong>其中可能会包含占位符<code>_n</code>表示<code>newcallable</code>的第<code>n</code>个参数</strong>）。占位符定义在<code>placeholders</code>的命名空间中,因此使用时要声明命名空间<code>using namespace std::placeholders;</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">islength</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">size_t</span> sz)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>()&gt;sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f=<span class="built_in">bind</span>(islength,_1,<span class="number">6</span>);		<span class="comment">//s1=_1,sz=6</span></span><br><span class="line"><span class="keyword">auto</span> s=<span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),<span class="built_in">f</span>(string &amp;s));	<span class="comment">//克服了find_if只能接受元谓词的缺点_1=s;</span></span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：占位符_n不仅仅使得参数使得调用时参数减少，也能对参数的顺序进行重排 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="keyword">auto</span> fn1 = <span class="built_in">bind</span>(func, _1, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> fn2 = <span class="built_in">bind</span>(func, <span class="number">2</span>, _1, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">fn1</span>(<span class="number">10</span>);	<span class="comment">//调用func(10,2,3)</span></span><br><span class="line"><span class="built_in">fn2</span>(<span class="number">10</span>);	<span class="comment">//调用func(2,10,3);</span></span><br></pre></td></tr></table></figure></p>
<h6 id="绑定引用参数">18.3.2 绑定引用参数</h6>
<p>默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。因为bind拷贝其参数，而我们不能拷贝一个<code>ostream</code>。如果我们希望传递给<code>bind</code>一个对象而又不拷贝它，就必须使用标准库<code>ref</code>函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os,string&amp; s,<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">	 os&lt;&lt;s&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">	 <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f=<span class="built_in">bin</span>(print,<span class="built_in">ref</span>(os),_1,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="string">&quot;trluper&quot;</span>);	<span class="comment">//print(os,&quot;trluper&quot;,&#x27; &#x27;);</span></span><br></pre></td></tr></table></figure></p>
<h5 id="泛型算法的结构">18.4 泛型算法的结构</h5>
<h6 id="算法支持的迭代器">18.4.1 算法支持的迭代器</h6>
<p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别:</p>
<ul>
<li><strong>输入迭代器</strong>：提供对数据的只读访问 只读，支持<code>++、==、！=</code></li>
<li><strong>输出迭代器</strong>：提供对数据的只写访问 只写，支持<code>++</code></li>
<li><strong>前向迭代器</strong>：提供读写操作，并能向前推进迭代器 读写，支持<code>++、==、！=</code></li>
<li><strong>双向迭代器</strong>：提供读写操作，并能向前和向后操作 读写，支持<code>++、--，</code></li>
<li><strong>随机访问迭代器</strong>：提供读写操作，并能在数据中随机移动 读写，支持<code>++、--、[n]、+n、-n、&lt;、&lt;=、&gt;、&gt;=</code></li>
</ul>
<p><strong>算法还共享一组参数传递规范和一组命名规范。</strong></p>
<h6 id="形参规范">18.4.2 形参规范</h6>
<p>大多数算法有下列4中形式</p>
<ul>
<li><code>alg(beg,end,other args);</code></li>
<li><code>alg(beg,end,dest,other args);</code></li>
<li><code>alg(beg,end,beg2,other args);</code></li>
<li><code>alg(beg,end,beg2,end2,other args);</code></li>
</ul>
<p><code>alg</code>为算法名称，<code>beg</code>和<code>end</code>表示算法所操作的输入范围（几乎所有算法均支持接受一个输入范围）。同时这里还列出了<code>dest</code>（目标迭代器）、<code>beg2、end2、</code>它们都是迭代器参数，如果用到了这些参数，它们分别承担了指定目的位置和第二个范围的角色。 <strong><em>注意：</em></strong> <strong>接受单个目标迭代器的算法：向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据 接受第二个输入序列的算法：接受单独beg2的算法假定从beg2开始的序列与beg与end所表示的范围至少一样大</strong></p>
<h6 id="命名规范">18.4.3 命名规范</h6>
<p>除了上述的参数规范，算法还遵循一套命名和重载规范。这些规范处理：<strong>提供一个操作去代替默认的<code>&lt;</code>或者<code>==</code>运算符，以及算法是将输出数据写入输入序列还是一个分离目的位置</strong></p>
<p><strong>1. 重载形式</strong></p>
<p>接受谓词参数来代替算法默认的&lt;或者其他运算符，以及那些不接受额外参数的算法，通常都是重载的函数。函数一个版本用来元素类型运算符来比较元素，<strong>另一个版本接受一个额外的谓词来代替默认的<code>&lt;</code>或者<code>==</code>。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique</span>(beg,end,val);	<span class="comment">//使用默认==比较元素</span></span><br><span class="line"><span class="built_in">unique</span>(beg,end,compare);	<span class="comment">//使用传入的谓词compare比较</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. <code>_if</code>版本的算法</strong></p>
<p>接受一个元素值的算法通常会有另一个不同名（不是重载版本）版本，该版本接受一个谓词代替元素值，接受谓词参数的算法都有附加_if后缀： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg,end,val);		<span class="comment">//查找范围内val第一次出现的位置</span></span><br><span class="line"><span class="built_in">find_if</span>(beg,end,pred);	<span class="comment">//查找第一个另pred谓词为真的元素</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3. 区分拷贝元素的版本和不拷贝的版本</strong></p>
<p>默认情况下，那些能重排元素的算法（sort,stable_sort等)将重排后的元素写回给定的输入序列。这些算法还提供另一版本：将元素写道一个指定的输出目的位置，写到额外目的空间的算法都在名字后面附加一个<code>_copy</code>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg,end);		<span class="comment">//反转</span></span><br><span class="line"><span class="built_in">reverse_copy</span>(beg,end,dest);	<span class="comment">//反转拷贝到dest</span></span><br></pre></td></tr></table></figure></p>
<p>一些算法同时有_if和_copy:它们接受一个目的迭代器和一个谓词： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">remove_coy_if</span>(beg,end,dest,pred);</span><br></pre></td></tr></table></figure></p>
<h4 id="再探迭代器">19 再探迭代器</h4>
<p><strong>除了为每个容器定义的迭代器外，标准库在iterator头文件还定义了额外几种迭代器。</strong></p>
<ul>
<li>插入迭代器：绑定在容器上时，可用来向容器插入元素</li>
<li>流迭代器：绑定在容器上时，可用来遍历元素</li>
<li>反向迭代器（forward_list除外）：这些迭代器是向后而不是向前移动</li>
<li>移动迭代器：不是拷贝元素，而是移动它们</li>
</ul>
<h5 id="插入迭代器">19.1 插入迭代器</h5>
<p><strong>插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素</strong>。如<code>back_inserter</code>接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用<code>push_back</code>将一个具有给定值的元素添加到容器中。插入迭代器有三种类型：</p>
<ul>
<li><code>back_inserter</code>：创建一个使用<code>push_back</code>的迭代器</li>
<li><code>front_inserter</code>：创建一个使用<code>push_front</code>的迭代器</li>
<li><code>inserter</code>：创建一个使用<code>insert</code>的迭代器。接受第二个参数，元素将被插入到给定迭代器表示的元素之前</li>
</ul>
<p>只有在容器支持<code>push_front</code>的情况下，我们才可以使用<code>front_inserter</code>。类似的，只有在容器支持<code>push_back</code>的情况下，我们才能使用<code>back_inserter</code>。<strong>当调用<code>insert(c,iter)</code>时，我们得到一个迭代器，使用它时，会将元素插入到<code>iter</code>原来指向的元素之前的位置（iter一直指向固定的一个元素）</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;lst2,lst3;</span><br><span class="line"><span class="comment">//拷贝完成后，lst2为4，3，2，1</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">begin</span>(),lst.<span class="built_in">end</span>(),<span class="built_in">front_inserter</span>(lst2));</span><br><span class="line"><span class="comment">//拷贝完成后，lst3为1,2,3,4</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">begin</span>(),lst.<span class="built_in">end</span>(),<span class="built_in">inserter</span>(lst3,lst.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure></p>
<h5 id="反向迭代器">19.2 反向迭代器</h5>
<p><strong>除了<code>forward_list</code>之外，其他容器都支持反向迭代器。<code>rbegin、crbegin</code>返回指向容器尾元素的迭代器<code>rend</code>、<code>crend</code>返回指向首元素之前一个位置的迭代器。</strong> 反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。<strong>对于反向迭代器，递增<code>++</code>和递减<code>--</code>的含义是反过来的。即递增++iter是移动到前一个元素，递减<code>--iter</code>是移到下一个元素。</strong> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/rbegin.png" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());		<span class="comment">//正常升序排序</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(),vec.<span class="built_in">rend</span>());		<span class="comment">//反过来了，降序排序</span></span><br></pre></td></tr></table></figure></p>
<h6 id="反向迭代器和其他迭代器之间的关系">19.2.1 反向迭代器和其他迭代器之间的关系</h6>
<p>我们想在存放了<code>words,lanuage,last</code>的<code>string</code>类型的<code>line</code>中输出打印最后一个单词<code>last</code>,使用find函数查找最后一个“，” <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> rcomm=<span class="built_in">find</span>(line.<span class="built_in">crbegin</span>(),line.<span class="built_in">crend</span>(),<span class="string">&#x27;,&#x27;</span>);		<span class="comment">//此时rcomm指向的是最后“,”的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们这样调用印，会打印出tsal逆序单词：</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(line.<span class="built_in">crbegin</span>(),rcomm)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//我们可以通过调用reverse_iterator的base成员函数可以将其转换成普通迭代器，从而正确打印：</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(rcomm.<span class="built_in">base</span>(),line.<span class="built_in">cend</span>())&lt;&lt;endl;</span><br></pre></td></tr></table></figure> <img src="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/guanxi.png" width="500"></p>
<p><strong><em>注意：</em></strong>关键点在于<code>[line.crbegin(),rcomma)</code>和<code>[rcomma.base(),line.cend())</code>指向line中相同的元素范围。为了实现这一点，<code>rcomma</code>和<code>rcomma.base()</code>必须生成相邻位置而不是相同位置<code>rcomma.base()</code>在<code>rcomma</code>的下一个位置），<code>crbegin()</code>和<code>cend()</code>也是如此。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="git是什么">1. Git是什么</h3>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git原来是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<span id="more"></span>
<h4 id="git-与-svn-区别">1.1 Git 与 SVN 区别</h4>
<p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。</p>
<p><code>Git</code>与<code>SVN</code>区别点：</p>
<ul>
<li><p>1、<code>Git</code>是分布式的，<code>SVN</code>不是：这是<code>Git</code>和其它非分布式的版本控制系统，</p></li>
<li><p>2、<code>Git</code>把内容按元数据方式存储，而<code>SVN</code>是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 <code>.svn、.cvs</code>等的文件夹里。</p></li>
<li><p>3、<code>Git</code>分支和<code>SVN</code>的分支不同：分支在 <code>SVN</code>中一点都不特别，其实它就是版本库中的另外一个目录。</p></li>
<li><p>4、<code>Git</code>没有一个全局的版本号，而<code>SVN</code>有：目前为止这是跟<code>SVN</code>相比<code>Git</code>缺少的最大的一个特征。</p></li>
<li><p>5、<code>Git</code>的内容完整性要优于<code>SVN</code>：<code>Git</code>的内容存储使用的是<code>SHA-1</code>哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Git.png" width="500"></p></li>
</ul>
<h3 id="git安装">2. Git安装</h3>
<h4 id="linux下的git">2.1 Linux下的Git</h4>
<p>Git 的工作需要调用<code>curl，zlib，openssl，expat，libiconv</code>等库的代码，所以需要先安装这些依赖工具。 在有<code>yum</code>的系统上centOS或者有<code>apt-get</code>的系统上（比如 Debian 体系），可以用下面的命令安装：</p>
<h5 id="ubuntu安装">2.1.1 ubuntu安装</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \</span><br><span class="line">  libz-dev libssl-dev</span><br><span class="line"></span><br><span class="line">$ apt-get install git</span><br><span class="line"></span><br><span class="line">$ git --version</span><br><span class="line">git version <span class="number">1.8</span><span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
<h5 id="centos安装">2.1.2 centOS安装</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel \</span><br><span class="line">  openssl-devel zlib-devel</span><br><span class="line"></span><br><span class="line">$ yum -y install git-core</span><br><span class="line"></span><br><span class="line">$ git --version</span><br><span class="line">git version <span class="number">1.7</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<h4 id="windows下的git">2.2 windows下的Git</h4>
<p>在 Windows平台上安装 Git同样轻松,找到<a href="https://gitforwindows.org/">官网下载链接</a>，点击下一步直接安装即可。</p>
<h4 id="git配置">2.3 Git配置</h4>
<p>Git 提供了一个叫做<code>git config</code>的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ul>
<li><code>/etc/gitconfig</code>文件：系统中对所有用户都普遍适用的配置。若使用<code>git config</code>时用 <code>--system</code>选项，读写的就是这个文件。</li>
<li><code>~/.gitconfig</code>文件：用户目录下的配置文件只适用于该用户。若使用<code>git config</code>时用 <code>--global</code>选项，读写的就是这个文件。</li>
<li>当前项目的<code>Git</code>目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code>里的配置会覆盖 <code>/etc/gitconfig</code>中的同名变量。</li>
</ul>
<p>在 Windows 系统上，Git 会找寻用户主目录下的 <code>.git/config</code>文件。主目录即 $HOME 变量指定的目录，一般都是 <code>C:\Documents and Settings\$USER。</code></p>
<p>此外，Git 还会尝试找寻 <code>/etc/gitconfig</code>文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<h5 id="用户信息">2.3.1 用户信息</h5>
<p>为了方便后续Git能跟踪到谁做了修改，我们需要设置对应的用户名与邮箱地址。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;wuwenjie&quot;</span></span><br><span class="line">$ git config --global user.email <span class="number">1229413537</span>@qq.com</span><br><span class="line"></span><br><span class="line">$ git config --list</span><br><span class="line">diff.astextplain.textconv=astextplain</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=<span class="literal">true</span></span><br><span class="line">http.sslbackend=openssl</span><br><span class="line">http.sslcainfo=D:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt</span><br><span class="line">core.autocrlf=<span class="literal">true</span></span><br><span class="line">core.fscache=<span class="literal">true</span></span><br><span class="line">core.symlinks=<span class="literal">false</span></span><br><span class="line">pull.rebase=<span class="literal">false</span></span><br><span class="line">credential.helper=manager-core</span><br><span class="line">credential.https:<span class="comment">//dev.azure.com.usehttppath=true</span></span><br><span class="line">init.defaultbranch=master</span><br><span class="line">user.email=<span class="number">1229413537</span>@qq.com</span><br><span class="line">user.name=wuwenjie</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>git config</code> 命令的 <code>--global</code> 参数，表示使用的这台机器上所有的 Git 仓库都会使用这个配置</p>
</blockquote>
<h5 id="git配置ssh">2.3.2 git配置ssh</h5>
<p>git是现在代码管理的一个常用工具，采用两种传输方式 <code>http</code>和 <code>ssh</code>。<code>SSH</code> 比较安全可靠，也不需要每次都输入账号密码，所以我们在使用git时一般采用ssh。</p>
<p><strong>windows版本：</strong></p>
<ul>
<li>windows打开Gitbash（linux打开终端）输入 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure> 如果你看到一下输出，那么说明你已经有ssh秘钥 （以.pub结尾的文件） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">total <span class="number">24</span></span><br><span class="line">drwxr-xr-x <span class="number">1</span> Administrator <span class="number">197121</span>    <span class="number">0</span> Sep <span class="number">23</span> <span class="number">15</span>:<span class="number">25</span> .</span><br><span class="line">drwxr-xr-x <span class="number">1</span> Administrator <span class="number">197121</span>    <span class="number">0</span> Sep <span class="number">23</span> <span class="number">15</span>:<span class="number">07</span> ..</span><br><span class="line">-rw-r--r-- <span class="number">1</span> Administrator <span class="number">197121</span> <span class="number">3389</span> Sep <span class="number">23</span> <span class="number">15</span>:<span class="number">07</span> id_rsa</span><br><span class="line">-rw-r--r-- <span class="number">1</span> Administrator <span class="number">197121</span>  <span class="number">750</span> Sep <span class="number">23</span> <span class="number">15</span>:<span class="number">07</span> id_rsa.pub</span><br><span class="line">-rw-r--r-- <span class="number">1</span> Administrator <span class="number">197121</span> <span class="number">1458</span> Sep <span class="number">23</span> <span class="number">15</span>:<span class="number">25</span> ssh.ppk</span><br></pre></td></tr></table></figure></li>
<li><p>如果你不想用原来的秘钥或者没有秘钥的话，直接进行下一步生成ssh公钥秘钥 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 邮箱</span><br><span class="line"><span class="comment">//如下:</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ ssh-keygen -t rsa -C <span class="string">&quot;1229413537@qq.com&quot;</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa key pair.</span><br><span class="line"><span class="function">Enter file in which to save the <span class="title">key</span> <span class="params">(/home/trluper/.ssh/id_rsa)</span>: </span></span><br><span class="line"><span class="function">Created directory <span class="string">&#x27;/home/trluper/.ssh&#x27;</span>.</span></span><br><span class="line"><span class="function">Enter passphrase (empty for no passphrase): </span></span><br><span class="line"><span class="function">Enter same passphrase again: </span></span><br><span class="line"><span class="function">Your identification has been saved in /home/trluper/.ssh/id_rsa</span></span><br><span class="line"><span class="function">Your public key has been saved in /home/trluper/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="function">The key fingerprint is:</span></span><br><span class="line"><span class="function">SHA256:<span class="number">1</span>Cj60kKeZzc8eMn1G09kN65qxVQ4FhyiKwumBElPf6I <span class="number">1229413537</span>@qq.com</span></span><br><span class="line"><span class="function">The key<span class="string">&#x27;s randomart image is:</span></span></span><br><span class="line"><span class="string"><span class="function">+---[RSA 3072]----+</span></span></span><br><span class="line"><span class="string"><span class="function">| . .       ..o+  |</span></span></span><br><span class="line"><span class="string"><span class="function">|. + .    o. .= . |</span></span></span><br><span class="line"><span class="string"><span class="function">| o . o..o.. . o  |</span></span></span><br><span class="line"><span class="string"><span class="function">|  . ..oo  .  .   |</span></span></span><br><span class="line"><span class="string"><span class="function">|   Eoo .S.. o o..|</span></span></span><br><span class="line"><span class="string"><span class="function">|  .oo+.+oo . =...|</span></span></span><br><span class="line"><span class="string"><span class="function">|   .= *.O   + .. |</span></span></span><br><span class="line"><span class="string"><span class="function">|     = o o . =.  |</span></span></span><br><span class="line"><span class="string"><span class="function">|          ..o..  |</span></span></span><br><span class="line"><span class="string"><span class="function">+----[SHA256]-----+</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>将公钥复制到github上，使用<code>ssh -T git@github.com</code>验证是否成功，成功会出现以下语句 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ ssh -T git@github.com</span><br><span class="line">Hi trluper! Yo<span class="string">u&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<blockquote>
<p>附加：如果上面的<code>ssh -T git@github.com</code>验证成功，但是git clone时出现错误： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:/home/CPP_project$ git clone git@github.com:qinguoyi/TinyWebServer.git</span><br><span class="line">git@github.com: <span class="function">Permission <span class="title">denied</span> <span class="params">(publickey)</span>.</span></span><br><span class="line"><span class="function">fatal: Could not read from remote repository.</span></span><br></pre></td></tr></table></figure> 则说明本节git仓库没有没有和这个ssh key关联，则依次执行： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看密钥运行</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/home/trluper/.ssh<span class="meta"># eval</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/home/trluper/.ssh<span class="meta"># ssh-agent -s</span></span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SSH_AUTH_SOCK=/tmp/ssh-XXXXXX8U3b13/agent<span class="number">.259910</span>; <span class="keyword">export</span> SSH_AUTH_SOCK;</span><br><span class="line">SSH_AGENT_PID=<span class="number">259911</span>; <span class="keyword">export</span> SSH_AGENT_PID;</span><br><span class="line">echo Agent pid <span class="number">259911</span>;</span><br></pre></td></tr></table></figure> //把ssh添加到你的账号 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/home/trluper/.ssh<span class="meta"># ssh-agent bash</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/home/trluper/.ssh<span class="meta"># ssh-add /home/trluper/.ssh/id_rsa</span></span><br></pre></td></tr></table></figure> 输出下述语句则说明添加成功 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Identity added: /home/trluper/.ssh/<span class="built_in">id_rsa</span> (<span class="number">1229413537</span>@qq.com)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="git工作流程">3. git工作流程</h3>
<p>git一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/git-process.png" width="500"></li>
</ul>
<h3 id="git三个区和三个状态">4. git三个区和三个状态</h3>
<p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p>
<ul>
<li><strong>工作区</strong>：就是你在电脑里能看到的目录。</li>
<li><strong>暂存区</strong>：英文叫<code>stage</code>或<code>index</code>。一般存放在<code>.git</code>目录下的<code>index</code>文件（<code>.git/index</code>）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><p><strong>版本库</strong>：工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 <code>Git</code> 的版本库。存储着所有提交的版本快照，并由当前分支引用的指针HEAD指向该分支最新一条提交 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Three.png" width="500"></p></li>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为 <code>index</code>的区域是暂存区<code>stage/index</code>，标记为 <code>master</code>的是<code>master</code>分支所代表的目录树。</li>
<li>图中我们可以看出此时<code>HEAD</code>实际是指向<code>master</code>分支的一个<code>游标</code>。所以图示的命令中出现<code>HEAD</code>的地方可以用<code>master</code>来替换。</li>
<li>图中的<code>objects</code>标识的区域为<code>Git</code>的对象库，实际位于<code>.git/objects</code>目录下，里面包含了创建的各种对象及内容。</li>
<li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li>
<li>当执行提交操作<code>git commit</code>时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 <code>master</code>指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，被 <code>master</code>分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 <code>git rm --cached &lt;file&gt;</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行 <code>git checkout</code> . 或者 <code>git checkout -- &lt;file&gt;</code>命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li>
<li><p>当执行 <code>git checkout HEAD</code> . 或者 <code>git checkout HEAD &lt;file&gt;</code>命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li>
</ul>
<h3 id="git创建仓库">5. Git创建仓库</h3>
<p>可以使用一个已经存在的目录作为<code>Git</code>仓库。<code>Git</code>使用<code>git init</code>命令来初始化一个<code>Git</code>仓库，<code>Git</code>的很多命令都需要在<code>Git</code>的仓库中运行，所以<code>git init</code>是使用<code>Git</code>的第一个命令。</p>
<p>在执行完成<code>git init</code>命令后，<code>Git</code> 仓库会生成一个<code>.git</code>目录，该目录包含了资源的所有元数据，其他的项目目录保持不变</p>
<ul>
<li><p><strong>当前目录即为仓库</strong>：使用当前目录作为 Git 仓库，我们只需使它初始化。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/gitTest</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in C:/Users/Trluper/Desktop/gitTest/.git/</span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ ls -al</span><br><span class="line">total <span class="number">8</span></span><br><span class="line">drwxr-xr-x <span class="number">1</span> Trluper <span class="number">197121</span> <span class="number">0</span> Mar <span class="number">13</span> <span class="number">12</span>:<span class="number">43</span> ./</span><br><span class="line">drwxr-xr-x <span class="number">1</span> Trluper <span class="number">197121</span> <span class="number">0</span> Mar <span class="number">13</span> <span class="number">12</span>:<span class="number">42</span> ../</span><br><span class="line">drwxr-xr-x <span class="number">1</span> Trluper <span class="number">197121</span> <span class="number">0</span> Mar <span class="number">13</span> <span class="number">12</span>:<span class="number">43</span> .git/</span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ cd .git/</span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/gitTest/.<span class="built_in">git</span> (GIT_DIR!)</span><br><span class="line">$ ls</span><br><span class="line">HEAD  config  description  hooks/  info/  objects/  refs/</span><br></pre></td></tr></table></figure> 该命令执行完后会在当前目录生成一个 .git 目录，内部含有的内容如上所示，没有<code>index</code>是因为我们还没用到暂存区，如果<code>git add filename</code>则就会创建一个<code>index</code>目录。</p></li>
<li><p><strong>使用我们指定目录作为Git仓库。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure> 初始化后，会在<code>newrepo</code>目录下会出现一个名为 <code>.git</code>的目录，所有<code>Git</code>需要的数据和资源都存放在这个目录中。</p></li>
</ul>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用<code>git add</code>命令告诉<code>Git</code>开始对这些文件进行跟踪，然后提交： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下命令将目录下以 .c 结尾及 README 文件提交到仓库中。</span></span><br><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">&#x27;初始化项目版本&#x27;</span></span><br></pre></td></tr></table></figure> &gt; 注： 在 Linux 系统中，commit 信息使用单引号 <code>'</code>，Windows 系统，commit 信息使用双引号<code>&quot;</code>。 &gt;所以在 git bash 中<code>git commit -m '提交说明'</code>这样是可以的，在 Windows 命令行中就要使用双引号 &gt;<code>git commit -m &quot;提交说明&quot;</code>。</p>
<h3 id="git的基本操作">6. Git的基本操作</h3>
<p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。Git 常用的是以下 6 个命令：<code>git clone、git push、git add 、git commit、git checkout、git pull</code>，后面我们会详细介绍。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/git-command.png" width="500"></p>
<ul>
<li><code>workspace</code>：工作区</li>
<li><code>staging area</code>：暂存区/缓存区</li>
<li><code>local repository</code>：版本库或本地仓库</li>
<li><code>remote repository</code>：远程仓库</li>
</ul>
<h4 id="git-clone">6.1 git clone</h4>
<p>我们使用<code>git clone</code>从现有<code>Git</code>仓库中拷贝项目（类似<code>svn checkout</code>）.克隆仓库的命令格式为：<code>git clone &lt;repo&gt;</code>。</p>
<p>要克隆<code>Ruby</code>语言的<code>Git</code>代码仓库<code>Grit</code>，可以用下面的命令： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ git clone git:<span class="comment">//github.com/schacon/grit.git</span></span><br></pre></td></tr></table></figure></p>
<h4 id="本地仓库操作">6.2 本地仓库操作</h4>
<p>下表列出了有关创建与提交你的项目的快照的命令：</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>git add</code></td>
<td>添加文件到暂存区</td>
</tr>
<tr class="even">
<td><code>git status</code></td>
<td>查看仓库当前的状态，显示有变更的文件。</td>
</tr>
<tr class="odd">
<td><code>git diff</code></td>
<td>比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr class="even">
<td><code>git commit</code></td>
<td>提交暂存区到本地仓库。</td>
</tr>
<tr class="odd">
<td><code>git reset</code></td>
<td>回退版本。</td>
</tr>
<tr class="even">
<td><code>git rm</code></td>
<td>将文件从暂存区和工作区中删除。</td>
</tr>
<tr class="odd">
<td><code>git mv</code></td>
<td>移动或重命名工作区文件。</td>
</tr>
</tbody>
</table>
<h5 id="git-add命令">6.2.1 git add命令</h5>
<p><code>git add</code>命令可将该文件添加到暂存区,其形式可为： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加一个或多个文件到暂存区：</span></span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加指定目录到暂存区，包括子目录：</span></span><br><span class="line">git add [dir]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加当前目录下的所有文件到暂存区：</span></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure> 示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git add test1</span><br></pre></td></tr></table></figure></p>
<h5 id="git-status命令">6.2.2 git status命令</h5>
<p><code>git status</code> 命令用于查看在你上次提交之后是否有对文件进行再次修改。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        <span class="keyword">new</span> file:   test1/test1.txt</span><br></pre></td></tr></table></figure> 通常我们使用 <code>-s</code> 参数来获得简短的输出结果： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ echo <span class="string">&quot;trluper&quot;</span> &gt; test1/test1.txt</span><br><span class="line"></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git status -s</span><br><span class="line">AM test1/test1.txt</span><br><span class="line">?? test1.txt</span><br></pre></td></tr></table></figure> - <code>M</code>:表示这个文件在我们将它添加到缓存之后又有改动。 - <code>??</code>：表示改文件未添加到缓存区</p>
<h5 id="git-diff命令">6.2.3 git diff命令</h5>
<p><code>git diff</code> 命令显示已写入暂存区和已经被修改但尚未写入暂存区文件的区别。git diff 有两个主要的应用场景:</p>
<ul>
<li>尚未缓存的改动：<code>git diff</code></li>
<li>查看已缓存的改动： <code>git diff --cached</code></li>
<li>查看已缓存的与未缓存的所有改动：<code>git diff HEAD</code></li>
<li>显示摘要而非整个 <code>diff：git diff --stat</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git diff</span><br><span class="line">warning: LF will be replaced by CRLF in test1/test1.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">diff --git a/test1/test1.txt b/test1/test1.txt</span><br><span class="line">index e69de29.<span class="number">.6</span>b69dda <span class="number">100644</span></span><br><span class="line">--- a/test1/test1.txt</span><br><span class="line">+++ b/test1/test1.txt</span><br><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span><br><span class="line">+trluper</span><br></pre></td></tr></table></figure>
<h5 id="git-commit命令">6.2.4 git commit命令</h5>
<p><code>git commit</code> 命令将暂存区内容添加到本地仓库中。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git commit -m <span class="string">&quot;commit test 2&quot;</span></span><br><span class="line">[<span class="built_in">master</span> (root-commit) b795d59] commit test <span class="number">2</span></span><br><span class="line"> <span class="number">2</span> files changed, <span class="number">2</span> <span class="built_in">insertions</span>(+)</span><br><span class="line"> create mode <span class="number">100644</span> test1.txt</span><br><span class="line"> create mode <span class="number">100644</span> test1/test1.txt</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>-m</code>：<code>m</code>为<code>message</code>的缩写，表示为后面要接的提交描述，如果没有加<code>-m</code>描述，则git会打开一个Vim编辑器让你填写提交信息</li>
<li><code>-a</code>：如果你觉的不要填写提交信息，那么<code>-a</code>选项跳过这一步</li>
</ul>
<h5 id="git-reset命令">6.2.5 git reset命令</h5>
<p><code>git reset</code> 命令用于回退版本，可以指定退回某一次提交的版本。语法格式如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git reset [--soft | --mixed | --hard] [HEAD/commit_id]</span><br><span class="line"><span class="comment">//回退指定版本号</span></span><br><span class="line">git reset -<span class="built_in">hard</span> (版本号) <span class="comment">//版本号没必要写全，前几位就可以了，Git会自动去找，版本号通过git log --pretty=oneline获取</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>--hard</code>：工作区、暂存区、本地仓库都会回滚到对应commit-id上 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/hard.png" width="400"></p></li>
<li><p><code>–-mixed</code>为默认的，可以不用带该参数。使用该参数工作区代码不会受到影响，但是暂存区、本地仓库区的代码已经回滚到了YY对应的commit-id上。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/mixed.png" width="400"></p></li>
<li><p><code>--soft</code>:工作区和暂存区的代码不会受到影响，但是本地仓库的代码会回滚到YY对应的commit-id上 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/soft.png" width="400"></p></li>
</ul>
<p>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git log  --pretty=oneline</span><br><span class="line"><span class="number">450f</span>4d7914f2db54bdab2eea422119e1fea7fafa (HEAD -&gt; master) 第二次commit</span><br><span class="line">b795d59de32dd11f307ecefa32b51c7dd8b901af commit test <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at b795d59 commit test <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：谨慎使用 <code>–-hard</code> 参数，它会删除回退点之前的所有日志提交记录。</em></strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> ((<span class="number">8692</span>a93...))</span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line"><span class="number">8692</span>a9397fb6fd23a262eb8f38997b549064a017 (HEAD) fix conflict</span><br><span class="line"><span class="number">0b</span>d22ddc1e7387bd4e97effa0a463056ce7be0dd master修改</span><br><span class="line"></span><br><span class="line"><span class="comment">//--hard回退到master修改</span></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> ((<span class="number">8692</span>a93...))</span><br><span class="line">$ git reset --hard <span class="number">0b</span>d22ddc1e7387bd4e97effa0a463056ce7be0dd</span><br><span class="line">HEAD is now at <span class="number">0b</span>d22dd master修改</span><br><span class="line"></span><br><span class="line"><span class="comment">//再次查看日志：fix conflict记录已经没有了</span></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> ((<span class="number">0b</span>d22dd...))</span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line"><span class="number">0b</span>d22ddc1e7387bd4e97effa0a463056ce7be0dd (HEAD) master修改</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>HEAD说明 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HEAD 表示当前版本</span><br><span class="line">HEAD^ 上一个版本</span><br><span class="line">HEAD^^ 上上一个版本</span><br><span class="line">HEAD^^^ 上上上一个版本</span><br><span class="line">以此类推...</span><br></pre></td></tr></table></figure> 也可以<code>~数字</code>表示 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HEAD~<span class="number">0</span> 表示当前版本</span><br><span class="line">HEAD~<span class="number">1</span> 上一个版本</span><br><span class="line">HEAD~<span class="number">2</span> 上上一个版本</span><br><span class="line">HEAD~<span class="number">3</span> 上上上一个版本</span><br><span class="line">以此类推...</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="git-revert命令">6.2.6 git revert命令</h5>
<p>上面的<code>git reset [commit_id]</code>的<code>--hard</code>参数太极端直接清除了<code>[commit_id]</code>之前的提交记录，而对应参数<code>--mixed --soft</code>虽然不会清除记录，但没有更改版本库的内容，即你还得修改后手动<code>commit</code>一次。</p>
<p><code>revert</code>命令不这样做，他不会清除之前的提交日志记录，而是自动的<code>commit</code>一次最新的提交</p>
<h5 id="git-rm命令">6.2.7 git rm命令</h5>
<p><code>git rm</code> 命令用于删除文件。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。</p>
<p><code>git rm</code> 删除文件有以下几种形式：</p>
<ul>
<li><strong>将文件从暂存区和工作区中删除：</strong>
<ul>
<li>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git rm -f &lt;file&gt;</span><br></pre></td></tr></table></figure></li>
<li>如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <code>--cached</code> 选项即可： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h5 id="git-mv命令">6.2.8 git mv命令</h5>
<p><code>git mv</code>命令用于移动或重命名一个文件、目录或软连接。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git mv [file] [newfile]</span><br></pre></td></tr></table></figure> 示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git mv -f  README.txt README.md</span><br><span class="line"></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        renamed:    README.txt -&gt; README.md</span><br></pre></td></tr></table></figure> - <code>-f</code>:若新文件名已经存在，但还是要重命名它，可以使用 <code>-f</code> 参数</p>
<h4 id="提交日志">6.3 提交日志</h4>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>git log</code></td>
<td>查看历史提交记录</td>
</tr>
<tr class="even">
<td><code>git blame &lt;file&gt;</code></td>
<td>以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody>
</table>
<h5 id="git-log命令">6.3.1 git log命令</h5>
<p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git log --oneline</span><br><span class="line"><span class="number">21</span>ab31a (HEAD -&gt; master) 第三次提交</span><br><span class="line">b795d59 commit test <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git log --pretty=online</span><br><span class="line">fatal: invalid --pretty format: online</span><br><span class="line"></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line"><span class="number">21</span>ab31a605efea7f4b3f8ebb47aecee82311a534 (HEAD -&gt; master) 第三次提交</span><br><span class="line">b795d59de32dd11f307ecefa32b51c7dd8b901af commit test <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用<code>--pretty=oneline</code>或者<code>--oneline</code>来查看历史记录的简洁的版本,含有<code>commit</code>提交id,哈希生成</li>
<li>用 <code>--graph</code> 选项，查看历史中什么时候出现了分支、合并</li>
<li>可以用<code>--reverse</code> 参数来逆向显示所有日志</li>
</ul>
<h5 id="git-blame命令">6.3.2 git blame命令</h5>
<p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git blame &lt;file&gt;</span><br></pre></td></tr></table></figure> 示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git blame README.md</span><br><span class="line"><span class="number">88</span>c273c5 README.<span class="built_in">md</span>  (wuwenjie <span class="number">2023</span><span class="number">-03</span><span class="number">-13</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">00</span> +<span class="number">0800</span> <span class="number">1</span>) 后缀名改了，为.md</span><br><span class="line"><span class="number">21</span>ab31a6 README.<span class="built_in">txt</span> (wuwenjie <span class="number">2023</span><span class="number">-03</span><span class="number">-13</span> <span class="number">18</span>:<span class="number">42</span>:<span class="number">25</span> +<span class="number">0800</span> <span class="number">2</span>) 这是README文件，后缀还没改，为.txt</span><br></pre></td></tr></table></figure></p>
<h4 id="远程操作">6.4 远程操作</h4>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>git remote</code></td>
<td>远程仓库操作</td>
</tr>
<tr class="even">
<td><code>git fetch</code></td>
<td>从远程获取代码库</td>
</tr>
<tr class="odd">
<td><code>git pull</code></td>
<td>下载远程代码并合并</td>
</tr>
<tr class="even">
<td><code>git push</code></td>
<td>上传远程代码并合并</td>
</tr>
</tbody>
</table>
<h5 id="git-remote命令">6.4.1 <code>git remote</code>命令</h5>
<p><code>git remote</code> 命令用于在远程仓库的操作，其有如下操作：</p>
<ul>
<li><p><code>git remote add [shortname] [url]</code>：添加远程版本库，其中[shortname]为别名，后续对改远程仓库的操作可以通过别名来使用 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git remote add trluperLearnGit https:<span class="comment">//github.com/trluper/Trluper_LearnGit.git</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>-v</code>：显示当前所有的远程仓库<code>git remote -v</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git remote -v</span><br><span class="line">trluperLearnGit https:<span class="comment">//github.com/trluper/Trluper_LearnGit.git (fetch)</span></span><br><span class="line">trluperLearnGit https:<span class="comment">//github.com/trluper/Trluper_LearnGit.git (push)</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>git remote show</code>:显示某个远程仓库的信息： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git remote show</span><br><span class="line">trluperLearnGit</span><br><span class="line"></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git remote show trluperLearnGit</span><br><span class="line">* remote trluperLearnGit</span><br><span class="line">  Fetch URL: https:<span class="comment">//github.com/trluper/Trluper_LearnGit.git</span></span><br><span class="line">  Push  URL: https:<span class="comment">//github.com/trluper/Trluper_LearnGit.git</span></span><br><span class="line">  HEAD branch: (unknown)</span><br></pre></td></tr></table></figure></p></li>
<li><code>git remote rm name</code> ：删除远程仓库</li>
<li><p><code>git remote rename old_name new_name</code> ： 修改远程仓库名</p></li>
</ul>
<h5 id="git-push-命令">6.4.3 git push 命令</h5>
<p><code>git push</code> 命令用于从将本地的分支版本上传到远程并合并。命令格式如下 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"><span class="comment">//如果本地分支名与远程分支名相同，则可以省略冒号：</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure></p>
<p>示例： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git push trluperLearnGit master:master</span><br><span class="line">Enumerating objects: <span class="number">10</span>, done.</span><br><span class="line">Counting objects: <span class="number">100</span>% (<span class="number">10</span>/<span class="number">10</span>), done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up to <span class="number">8</span> threads</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">10</span>/<span class="number">10</span>), <span class="number">920</span> bytes | <span class="number">460.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">10</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span><br><span class="line">To https:<span class="comment">//github.com/trluper/Trluper_LearnGit.git</span></span><br><span class="line"> * [<span class="keyword">new</span> branch]      master -&gt; master</span><br></pre></td></tr></table></figure> - <code>--force</code>:本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git push --force trluperLearnGit master:trluper</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>--delete</code>:删除主机的分支可以使用 --delete 参数(一般不使用)</li>
</ul>
<blockquote>
<p><strong><em>注意</em></strong>：一般来说在实际开发中，我们总会在远程仓库建立自己的分支，而不是直接<code>push</code>到master分支，这样<code>push</code>到自己分支，管理者看完修改对比并同意后才合并到<code>master</code>分支，这才是正确的做法 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/push.png" width="600"></p>
</blockquote>
<h5 id="git-fetch-命令">6.4.2 <code>git fetch</code> 命令</h5>
<p><code>git fetch</code> 命令用于从远程获取代码库。因为<code>git fetch</code>不会改变本地仓库的状态，该命令执行完后需要执行 <code>git merge</code> 远程分支到你本地仓库所在的分支。命令格式</p>
<blockquote>
<p>git fetch 实际所做的工作是将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git fetch shortname</span><br><span class="line">git merge shortname/branch</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>git fetch</code>:改命令告诉 Git 去远程仓库获取它有你没有的数据。，下面的<code>88c273c..54788d2  master     -&gt; trluperLearnGit/master</code>表示确实有新数据可获取 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git fetch trluperLearnGit</span><br><span class="line">remote: Enumerating objects: <span class="number">5</span>, done.</span><br><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">766</span> bytes | <span class="number">40.00</span> KiB/s, done.</span><br><span class="line">From https:<span class="comment">//github.com/trluper/Trluper_LearnGit</span></span><br><span class="line">   <span class="number">88</span>c273c.<span class="number">.54788</span>d2  master     -&gt; trluperLearnGit/master</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>git merge trluperLearnGit/master</code>然后执行与本地指定分支合并 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git merge trluperLearnGit/master</span><br><span class="line">Updating <span class="number">88</span>c273c.<span class="number">.54788</span>d2</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | <span class="number">2</span> ++</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">2</span> <span class="built_in">insertions</span>(+)</span><br></pre></td></tr></table></figure> 查看一下是否更改了工作区的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ cat README.md</span><br><span class="line">后缀名改了，为.md</span><br><span class="line">这是README文件，后缀还没改，为.txt</span><br><span class="line">我在github上修改，测试git fetch</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="git-pull命令">6.4.3 git pull命令</h5>
<p><code>git pull</code> 命令用于从远程获取代码并合并本地的版本。就是将上面的<code>git fetch</code>和<code>git merge</code>合并·到了一起。一般来说使用<code>pull</code>较多</p>
<ul>
<li><code>git pull [shortname] [远程仓库分支]:[本地仓库分支]</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git pull trluperLearnGit trluper:master</span><br><span class="line">remote: Enumerating objects: <span class="number">5</span>, done.</span><br><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">0</span></span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">687</span> bytes | <span class="number">42.00</span> KiB/s, done.</span><br><span class="line">From https:<span class="comment">//github.com/trluper/Trluper_LearnGit</span></span><br><span class="line">   <span class="number">54788</span>d2.<span class="number">.20</span>be99d  trluper    -&gt; master</span><br><span class="line"> * [<span class="keyword">new</span> branch]      trluper    -&gt; trluperLearnGit/trluper</span><br><span class="line">warning: fetch updated the current branch head.</span><br><span class="line">fast-forwarding your working tree from</span><br><span class="line">commit <span class="number">54788</span>d2727502d34e5e214c2ce08853ac628a6f5.</span><br><span class="line">Already up to date.</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="git的分支管理">7. Git的分支管理</h3>
<p>几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。<code>Git</code>分支实际上是指向更改快照的指针。有人把<code>Git</code>的分支模型称为必杀技特性，而正是因为它，将<code>Git</code>从版本控制系统家族里区分出来。</p>
<p>在 Git 里，<code>master</code> 分支叫主分支。<code>HEAD</code>严格来说不是指向提交，而是指向 <code>master</code>，<code>master</code> 才是指向提交的，所以，<code>HEAD</code> 指向的就是当前分支。</p>
<h4 id="git-branch创建分支">7.1 git branch创建分支</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">git <span class="title">branch</span> <span class="params">(branchname)</span></span></span><br></pre></td></tr></table></figure>
<p>没有参数时，<code>git branch</code>会列出你在本地的分支。当你执行<code>git init</code>的时候，默认情况下<code>Git</code>就会为你创建<code>master</code>主分支。如果我们要手动创建一个分支。执行<code>git branch (branchname)</code>即可。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ git branch testing</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure></p>
<h4 id="git-checkout切换分支">7.2 git checkout切换分支</h4>
<p>格式： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git checkout [commit_id/分支名称]</span><br></pre></td></tr></table></figure> 在git中，每个<code>commit</code>提交都会生成哈希索引，默认HEAD指向最新的提交记录，<code>checkout</code>其实就是改变<code>HEAD</code>的指向，从而达到改变切换分支的目的。但他不仅仅只有改变分支的作用，只要你想切换到任一提交记录都可以: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line"><span class="number">65</span>eb23309a8650f462f61f14ec661219072f2a8f (HEAD -&gt; master) checkout</span><br><span class="line"><span class="number">8692</span>a9397fb6fd23a262eb8f38997b549064a017 fix conflict</span><br><span class="line"><span class="number">0b</span>d22ddc1e7387bd4e97effa0a463056ce7be0dd master修改</span><br><span class="line"></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git checkout <span class="number">8692</span>a9397fb6fd23a262eb8f38997b549064a017</span><br><span class="line">Note: switching to <span class="string">&#x27;8692a9397fb6fd23a262eb8f38997b549064a017&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> ((<span class="number">8692</span>a93...))</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>用<code>git checkout (branch)</code>切换到我们要修改的分支，<code>checkout</code>的工作原理就只是修改<code>HEAD</code>指针的指向。</p></li>
<li><p>每个提交记录是独立的，其工作区间、暂存区和版本库的内容不与其他记录共享，即当切换到一个提交记录时，就会显示改记录的内容。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ echo <span class="string">&#x27;runoob.com&#x27;</span> &gt; test.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&#x27;add test.txt&#x27;</span></span><br><span class="line">[master <span class="number">3e92</span>c19] add test.txt</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> <span class="built_in">insertion</span>(+)</span><br><span class="line"> create mode <span class="number">100644</span> test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git checkout testing</span><br><span class="line">Switched to branch <span class="string">&#x27;testing&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure>
<p>当我们切换到<code>testing</code>分支的时候，我们添加的新文件 <code>test.txt</code>被移除了。切换回<code>master</code>分支的时候，它们又重新出现了。</p>
<h4 id="合并分支">7.4 合并分支</h4>
<p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：<code>git merge</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  newtest</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git merge newtest</span><br><span class="line">Updating <span class="number">3e92</span>c19..c1501a2</span><br><span class="line">Fast-forward</span><br><span class="line"> runoob.php | <span class="number">0</span></span><br><span class="line"> test.txt   | <span class="number">1</span> -</span><br><span class="line"> <span class="number">2</span> files changed, <span class="number">1</span> <span class="built_in">deletion</span>(-)</span><br><span class="line"> create mode <span class="number">100644</span> runoob.php</span><br><span class="line"> <span class="keyword">delete</span> mode <span class="number">100644</span> test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        runoob.php</span><br></pre></td></tr></table></figure> 以上实例中我们将<code>newtest</code>分支合并到主分支去，那么<code>test.txt</code>文件被删除,<code>runoob.php</code>被添加到主分支</p>
<h4 id="删除分支">7.5 删除分支</h4>
<p>删除分支只需加个<code>-d</code>即可：<code>git branch -d (branchname)</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br><span class="line">$ git branch -<span class="function">d testing</span></span><br><span class="line"><span class="function">Deleted branch <span class="title">testing</span> <span class="params">(was <span class="number">85f</span>c7e7)</span>.</span></span><br><span class="line"><span class="function">$ git branch</span></span><br><span class="line"><span class="function">* master</span></span><br></pre></td></tr></table></figure></p>
<h4 id="详解分支管理">7.6 详解分支管理</h4>
<p>假如你有两个分支<code>master</code>和<code>dev</code>:</p>
<ul>
<li><p>1、当你只是<code>checkout</code>切换一个分支，而对两个分支都没修改(在切换分支时一旦在工作区修改git会要求你在切换前<code>commit</code>)，那么各分支状态如下： <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/dev.png" width="400"></p></li>
<li><p>2、现在你切换到了dev，并修改了三次，<code>commit</code>了三次，那么在本地仓库（版本库）会生成三次的哈希索引，且其分支记录指针图示如下： <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/dev_change.png" width="400"></p></li>
<li>3、现在有另一种情况，你在<code>dev</code>修改，另一位同事对<code>master</code>分支做出修改，这时候就可能出现潜在问题，出现合并冲突： <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/master.png" width="400">
<ul>
<li><strong>如果你们的修改没有出现合并冲突，那么很好，你们可以愉快的执行<code>git merge dev</code>操作</strong></li>
<li><strong>但如果你能出现冲突了(比如说修改了同一份文件、master创建一份新的代码文价)，你必须手动解决冲突，再去合并，非常好的一点是，git会提示冲突出现的位置</strong>。</li>
</ul></li>
<li><p>举例有一个<code>test.txt</code>文件，在<code>mater</code>添加了<code>master：修改</code>，在<code>test</code>分支添加<code>test：修改</code>,都各自commit，在执行合并操作时出现合并冲突： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trluper@DESKTOP<span class="number">-67</span>ADUGH MINGW64 ~/Desktop/<span class="built_in">gitTest</span> (master)</span><br><span class="line">$ git merge test</span><br><span class="line">Auto-merging test.<span class="function">txt</span></span><br><span class="line"><span class="function"><span class="title">CONFLICT</span> <span class="params">(content)</span>: Merge conflict in test.txt</span></span><br><span class="line"><span class="function">Automatic merge failed;</span> fix conflicts <span class="keyword">and</span> then commit the result.</span><br></pre></td></tr></table></figure> <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/notice.png" width="600"></p></li>
</ul>
<blockquote>
<p><strong>合并冲突：</strong>冲突的产生是因为在合并的时候，不同分支修改了相同的位置。所以在合并的时候git不知道哪个到底是你想保留的，所以就提出疑问（冲突提醒）让你自己手动选择想要保留的内容，从而解决冲突。 <strong>解决冲突：</strong></p>
<ul>
<li>（一股脑）使用merge命令合并分支，解决完冲突，执行git add .和git commit -m'fix conflict'。这个时候会产生一个commit。</li>
<li>（交互式）使用rebase命令合并分支，解决完冲突，执行git add .和git rebase --continue，不会产生额外的commit。这样的好处是，‘干净’，分支上不会有无意义的解决分支的commit；坏处，如果合并的分支中存在多个commit，需要重复处理多次冲突。</li>
</ul>
</blockquote>
<h3 id="git回滚一次错误合并">8 git回滚一次错误合并</h3>
<p>在git种支持回滚的操作主要有三个<code>checkout、reset、revert</code></p>
<ul>
<li>三个回滚操作在我们错误提交还未<code>push</code>时具有重要作用，支持我们回滚版本、版本管理强。</li>
<li>三个操作的具体见上面章节。</li>
</ul>
<h3 id="git的merge和rebase区别">9 git的merge和rebase区别</h3>
<p><code>merge</code>和<code>rebase</code>都是用来合并分支的。</p>
<ul>
<li><p>1.采用<code>merge</code>和<code>rebase</code>后，git log的区别：<code>merge</code>命令不会保留<code>merge</code>的分支的<code>commit</code>记录，<code>rebase</code>会保留所有的<code>commit</code>：（即<code>rebase: 合体</code> <code>merge: 脚手相连，肚皮是独立的</code>） <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/rebase.png" width="600"></p></li>
<li><code>merge</code>和<code>rebase</code>应用场景：
<ul>
<li><strong><code>merge</code>一般用在<code>master</code>这种公共分支上</strong>。在多人开发同一个项目时，如果多人的开发分支有一定的命名规范，比如需求的版本号，那么在排查问题或者追溯需求时，会很方便；保存的日志记录轨迹清晰，回滚方便</li>
<li><strong>一般<code>rebase</code>基本法则是只对自己的的分支做</strong>，在自己的分支上若有多次提交，可以合并为一次提交，并强推上去，这样的话将自己的分支合入公共分支master的时候，分支树也很简明</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在master分支执行下面语句的意思：</span><br><span class="line">git merge dev：将dev代码合并至master</span><br><span class="line">git rebase dev：将master代码合并至dev</span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩展：当你本地仓库落后于远程仓库进行<code>commit</code> ,然后<code>pull</code>, 那会多生成一条<code>merge</code>记录, 这是非常错误的:</p>
</blockquote>
<blockquote>
<ul>
<li>情况1：如果 <code>remote</code> 分支超前于本地分支，并且本地分支没有任何 <code>commit</code> 的，直接从 <code>remote</code> 进行 <code>pull</code> 操作，默认会采用 <code>fast-forward</code> 模式，这种模式下，并不会产生合并节点，也就是说不会产生多余的记录</li>
<li>情况2：如果，本地先 <code>commit</code> 后再去 <code>pull</code>，那么此时，<code>remote</code> 分支和本地会分支会出现分叉，这个时候使用 <code>pull</code> 操作拉取更新时，就会进行分支合并，产生合并节点和 <code>log</code> 记录</li>
</ul>
</blockquote>
<p>关键是看自己本地有没有<code>commit</code>，因为<code>commit</code>已经进入了本地仓库了，是会被检测到，并记录的</p>
<p><strong>应该要解决第二种情况：</strong>使用<code>git pull --rebase</code> ,使用<code>rebase</code>合并，避免产生记录</p>
<p>文章来源：<a href="https://www.runoob.com/git/git-workflow.html">菜鸟教程</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式</title>
    <url>/2023/03/07/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="lambda表达式">7 lambda表达式</h3>
<p>我们可以向一个算法传递任何类别可调用对象，如果可以对其使用调用运算符()，则称它为可调用的。c++中可调用对象有函数、函数指针、重载函数调用运算符类、<code>lambda</code>表达式。</p>
<p><strong>一个<code>lambda</code>表达式表示一个可调用的代码单元，可将其理解为一个未命名的内联函数。一个<code>lambda</code>具有一个返回类型、一个参数列表和一个函数体(同函数一样）。与函数不同的是，<code>lambda</code>可定义在函数内部，有捕获列表：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (parameter list)-&gt;<span class="keyword">return</span> type&#123;	function body 	&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>captue list</code>（捕获列表）是一个lambda所在函数中定义的局部变量列表（通常为空）</li>
<li><code>return type</code>为返回类型，</li>
<li><code>parameter list</code>为参数列表、</li>
<li><code>function body</code>为函数体</li>
</ul>
<span id="more"></span>
<p>可以忽略参数列表（等价于指定一个空参数列表）和返回类型（此时根据代码推断，有return返回相应类型，没有为void)，<strong>但必须包含捕获列表和函数体：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=[] &#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;endl;	<span class="comment">//调用时也有调用运算符()</span></span><br><span class="line"><span class="comment">//lambda不能设默认参数，因此一个lambda调用时实参数目必须与形参一一对应。</span></span><br><span class="line">[](<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="捕获规则">7.1捕获规则</h4>
<p>lambda表达式的捕获列表有值捕获和引用捕获 <img src="/2023/03/07/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/lambda.png" width="700"> <strong>我们可以在捕获列表中写一个<code>&amp;</code>或者<code>=</code>，指示编译器推断捕获列表。<code>&amp;</code>告诉编译器采用捕获引用方式，<code>=</code>则表示采用值捕获方式</strong>。我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：</p>
<ul>
<li>当混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个<code>&amp;</code>或<code>=</code>（必须隐式）</li>
<li>当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">biggies</span><span class="params">(vector&lt;string&gt; &amp;words,vector&lt;string&gt;::size_type sz,ostream &amp;os,string c=<span class="string">&quot; &quot;</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//words,sz c采用值捕获，os为引用捕获</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[=,&amp;os](<span class="type">const</span> string &amp;s)&#123;os&lt;&lt;s&lt;&lt;c&lt;&lt;ends;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。<strong>如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字<code>mutable</code></strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b, <span class="type">int</span>&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c = <span class="number">10</span>;</span><br><span class="line">    a = <span class="number">11</span>;</span><br><span class="line">    b = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt; a&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; b&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambdaTest</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;,c]()<span class="keyword">mutable</span> &#123;<span class="keyword">return</span> <span class="built_in">sum</span>(a, b, c); &#125;;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">f</span>();</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">11</span> <span class="number">12</span> <span class="number">10</span></span><br><span class="line"><span class="number">33</span> <span class="number">11</span> <span class="number">12</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<h4 id="lambda是函数对象">7.2 lambda是函数对象</h4>
<p>我们编写一个<code>lambda</code>后，编译器将表达式翻译成一个未命名类的未命名对象，这个类中有一个重载的函数调用运算符。如下面这个<code>lambda</code>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">const</span> string&amp;a,<span class="type">const</span> string&amp;b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();&#125;);</span><br></pre></td></tr></table></figure> 相似于下面类对象：由于默认情况下<code>lambda</code>不能改变它捕获的变量，因此在默认情况下<code>lambda</code>生成的类当中的函数调用运算符是<code>const</code>成员函数: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shorter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp;a,<span class="type">const</span> string&amp;b)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="生成类对于lambda的值捕获与引用捕获的不同">7.3 生成类对于lambda的值捕获与引用捕获的不同</h4>
<p><strong>当<code>lambda</code>表达式通过</strong>引用捕获变量时<strong>，程序确保<code>lambda</code>执行引用时所引用的对象确实存在，编译器可以直接使用该引用而无需再<code>lambda</code>产生的类中将其存储。但是通过值捕获时，在<code>lambda</code>生成的类中需要为值捕获的变量生成数据成员，创建构造函数：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> w=<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[sz](<span class="type">const</span> string&amp;a,)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;&#125;);</span><br></pre></td></tr></table></figure> 该<code>lambda</code>值捕获<code>sz</code>，则其产生的类将形如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sizecmp</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Sziecamp</span>(<span class="type">size_t</span> n):<span class="built_in">sz</span>(n)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp;a)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">size_t</span> sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 标准库定义了一组表示算术、关系、逻辑运算符的类，都被定义成模板的形式，可以为其指定具体的应用类型即调用运算符的形参类型。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf</title>
    <url>/2023/03/10/protobuf/</url>
    <content><![CDATA[<h2 id="protobuf-概述">1 Protobuf 概述</h2>
<p>Protocol Buffer (简称Protobuf) 是Google出品的性能优异、跨语言、跨平台的序列化库。在网络通信和通用数据交换等应用场景中经常使用的技术是 <code>JSON</code>或 <code>XML</code>，在微服务架构中通常使用另外一个数据交换的协议的工具<strong>ProtoBuf</strong>。</p>
<p>ProtoBuf也是我们做微服务开发，进行Go进阶实战中，必知必会的知道点。</p>
<p><strong>ProtoBuf全称：</strong>protocol buffers，直译过来是：“协议缓冲区”，是一种与语言无关、与平台无关的可扩展机制，用于序列化结构化数据。</p>
<ul>
<li><strong>和<code>json\xml</code>最大的区别是：json，ProtoBuf是二进制格式。</strong></li>
<li><strong><code>ProtoBuf</code>相比于<code>json\XML</code>，更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。</strong></li>
<li><strong>我们只需要定义一次数据结构，就可以使用ProtoBuf生成源代码，轻松搞定在各种数据流和各种语言中写入、读取结构化数据。</strong></li>
</ul>
<span id="more"></span>
<p><strong>官方的发布日志中列举了 proto3 的改变：</strong></p>
<ul>
<li>移除了原始值字段的出现逻辑。</li>
<li>移除了required字段</li>
<li>移除了缺省值</li>
<li>移除了unknown字段 （3.5中又加上了）</li>
<li>移除了扩展，使用Any代替</li>
<li>修复了未知的枚举值的语义</li>
<li>添加了map类型</li>
<li>添加了一些标准类似，比如time、动态数据的呈现</li>
<li>可以使用 JSON 编码代替二进制 proto 编码</li>
</ul>
<blockquote>
<p>2001年初，Protobuf 首先在 Google 内部创建， 我们把它称之为 proto1，一直以来在 Google 的内部使用，其中也不断的演化，根据使用者的需求也添加很多新的功能，一些内部库依赖它。几乎每个 Google 的开发者都会使用到它。</p>
<p>Google 开始开源它的内部项目时，因为依赖的关系，所以他们决定首先把 Protobuf 开源出去。 proto1 在演化的过程中有些混乱，所以Protobuf 的开发者重写了 Protobuf 的实现，保留了 proto1 的大部分设计，以及 proto1 的很多的想法。但是开源的 proto2 不依赖任何的 Google 的库，代码也相当的清晰。2008年7月7日，Protobuf 开始公布出来。</p>
<p>Protobuf 公布出来也得到了大家的广泛的关注， 逐步地也得到了大家的认可，很多项目也采用 Protobuf 进行消息的通讯，还有基于 Protobuf 的微服务框架 GRPC。在使用的过程中，大家也提出了很多的意见和建议，Protobuf 也在演化，于 2016 年推出了 Proto3。 Proto3 简化了 proto2 的开发，提高了开发的效能，但是也带来了版本不兼容的问题。</p>
</blockquote>
<h2 id="protobuf环境配置">2 protobuf环境配置</h2>
<p>我们以ubuntu为例进行protobuf的环境安装。值得一提的是，目前机构培训和学习一般使用较旧的版本如<code>v2.5.0</code>版本。目前最新版本用<code>CMake</code>安装</p>
<h3 id="最新版本">最新版本</h3>
<p>下载地址：<a href="https://github.com/protocolbuffers/protobuf" class="uri">https://github.com/protocolbuffers/protobuf</a></p>
<p>利用CMake安装：执行下面命令： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:protocolbuffers/protobuf.git</span><br><span class="line">#下载完成后，执行下述命令</span><br><span class="line">cmake . -Dprotobuf_BUILD_TESTS=OFF</span><br><span class="line">cmake --build . --parallel <span class="number">10</span></span><br><span class="line">#测试</span><br><span class="line">ctest --verbose</span><br><span class="line">#安装至user目录下</span><br><span class="line">sudo cmake --install .</span><br><span class="line"></span><br><span class="line">#用makefile测试安装也可</span><br><span class="line">make VERBOSE=<span class="number">1</span> test</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<p>出现错误1： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CMake Error at cmake/gtest.cmake:<span class="number">7</span> (message):</span><br><span class="line">  Cannot find third_party/googletest directory that<span class="number">&#x27;</span>s needed to build tests.</span><br><span class="line">  If you use git, make sure you have cloned submodules:</span><br><span class="line"></span><br><span class="line">    git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line">  If instead you want to skip tests, run cmake with:</span><br><span class="line"></span><br><span class="line">    cmake -Dprotobuf_BUILD_TESTS=OFF</span><br><span class="line"></span><br><span class="line">Call <span class="built_in">Stack</span> (most recent call first):</span><br><span class="line">  CMakeLists.txt:<span class="number">291</span> (include)</span><br></pre></td></tr></table></figure> 解决方法，将<code>cmake .</code>更改为<code>cmake .  -Dprotobuf_BUILD_TESTS=OFF</code></p>
<p>出现错误2： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CMake Error at third_party/utf8_range/CMakeLists.txt:<span class="number">31</span> (add_subdirectory):</span><br><span class="line">  The source directory</span><br><span class="line"></span><br><span class="line">    /home/project/protobuf/sourcecode/protobuf/third_party/abseil-cpp</span><br><span class="line"></span><br><span class="line">  does <span class="keyword">not</span> contain a CMakeLists.txt file.</span><br></pre></td></tr></table></figure> 解决方法：在third_party进行<code>git clone https://github.com/abseil/abseil-cpp</code></p>
<h3 id="版本安装">2.5.0版本安装</h3>
<p>下载v2.5.0版本的protobuf后，执行下述命令 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#安装必要的库</span><br><span class="line">apt-get install autoconf automake libtool curl make g++ unzip </span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<h2 id="安装go">3 安装go</h2>
<ul>
<li><strong>步骤1：先安装golang</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt-get install golang-go</span><br></pre></td></tr></table></figure></li>
<li><p><strong>步骤2：</strong>将go的path添加进<code>~/.bashrc</code>，并进行<code>source ~/.bashrc</code>。可用<code>go env</code>查看go的路径 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> GOROOT=/opt/go</span><br><span class="line"><span class="keyword">export</span> GOPATH=~/GOPATH</span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$GOROOT/bin:$GOPATH</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>步骤3</strong>：安装<code>protoc-gen-go</code>:Protobuf 核心的工具集是 C++ 语言开发的，官方的 protoc 编译器中并不支持 Go 语言，需要安装一个插件才能生成 Go 代码。用如下命令安装： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure> 此命令会将 <code>protoc-gen-go</code> 可执行文件安装在<code>$GOROOT/bin</code>目录下,因此需要将其添加进PATH（步骤2）。当编译器调用时传递了--go_out 命令行标志时 <code>protoc</code> 就会使用该插件。<code>--go_out</code> 告诉编译器把 Go 源代码写到哪里。编译器会为每个 <code>.proto</code>文件生成一个单独的源代码文件。</p></li>
</ul>
<blockquote>
<p>如果出现<code>go: google.golang.org/protobuf/cmd/protoc-gen-go@latest: module google.golang.org/protobuf/cmd/protoc-gen-go: Get &quot;https://proxy.golang.org/google.golang.org/protobuf/cmd/protoc-gen-go/@v/list&quot;: dial tcp 172.217.160.81:443: i/o timeout</code>错误 可尝试设置Go代理重新安装 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https:<span class="comment">//goproxy.io,direct</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="protobuf是什么作用">4 protobuf是什么？作用？</h2>
<p><strong>Protocol Buffers（简称 Protobuf）是一种轻便高效的能够序列化结构数据的协议工具</strong>，可以用于结构化数据串的序列化。适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p>
<p>和<code>json\xml</code>最大的区别是json，ProtoBuf是经过编码压缩的二进制格式。 因此<code>ProtoBuf</code>相比于<code>json\XML</code>，其体积更小（3 ~ 10倍）、速度更快（20 ~ 100倍）、也更为简单。** <img src="/2023/03/10/protobuf/protobuf的特点.png" width="700"></p>
<h3 id="protocol-buffer-的序列化-和反序列化简单速度快的原因">Protocol Buffer 的序列化 和反序列化简单、速度快的原因</h3>
<ul>
<li>使用二进制的形式，比json用文本形式更接近计算机处理语言</li>
<li>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）。</li>
<li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成。</li>
</ul>
<h3 id="protocol-buffer-的数据压缩效果好即序列化后的数据量体积小的原因是">Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是</h3>
<ul>
<li><ol type="a">
<li>采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li>
</ol></li>
<li><ol start="2" type="a">
<li>采用 <code>T - L - V</code>的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li>
</ol></li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/633656133">如果面试提到Protobuf，面试官问其原理怎么办？</a></p>
<h3 id="protobuf-2和3的区别">Protobuf 2和3的区别</h3>
<ol type="1">
<li>protoful文件的第一行需要指定您正在使用proto3语法：如果不这样做，protocol buffer编译器将假定使用的是proto2。这必须是文件的第一个非空、非注释行。</li>
<li>proto3取消了proto2的required，而proto3的singular就是proto2的optional。</li>
<li>proto3 repeated标量数值类型默认packed，而proto2默认不开启。</li>
<li>proto3增加了Kotlin，Ruby，Objective-C，C#，Dart的支持。</li>
<li>proto2可以选填default，而proto3只能使用系统默认的。（序列化后如果是默认值是不会占用空间的，对于proto2来说处理就很麻烦了）</li>
<li>proto3必须有一个零值，以便我们可以使用 0 作为数字默认值。零值需要是第一个元素，以便与proto2语义兼容，其中第一个枚举值始终是默认值。proto2则没有这项要求。</li>
<li>proto3在3.5版本之前会丢弃未知字段。但在 3.5 版本中，重新引入了未知字段的保留以匹配 proto2 行为。在 3.5 及更高版本中，未知字段在解析过程中保留并包含在序列化输出中。</li>
<li>proto3移除了proto2的扩展，新增了Any（仍在开发中）和JSON映射。</li>
</ol>
<h3 id="protobuf中每个字段后的序号作用">Protobuf中每个字段后的序号作用？</h3>
<p><strong>每个字段有唯一编号，在二进制流中标识该字段，可以看后面protobuf 编解码原理去了解字段的作用。</strong></p>
<blockquote>
<ul>
<li>消息被使用了，字段就不能改了，改了会造成数据错乱（常见坑)，服务器和客户端很多bug，是proto buffer 文件更改，未使用更改后的协议导致。</li>
<li>1 到 15 范围内的字段编号需要一个字节进行编码，编码结果将同时包含编号和类型</li>
<li>16 到 2047 范围内的字段编号占用两个字节。因此，非常频繁出现的 message 元素保留字段编号 1 到 15。</li>
<li>字段最小数字为1，最大字段数为2^29 - 1。（原因在编码原理那章讲解过，字段数字会作为key，key最后三位是类型）</li>
<li>19000 through 19999 (FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber这些数字不能用，这些是保留字段，如果使用会编译器会报错</li>
</ul>
</blockquote>
<h3 id="protobuf和json对比">protobuf和json对比</h3>
<p>可以从优缺点来对比protobuf和json，相较于json，protobuf具有优点：</p>
<ul>
<li>在性能上，其使用编码进行二进制数据流形式传输，压缩性好，能够一定程度上减小流量，从而节省网络带宽和省电。其序列化和烦序列化的速度要比json快2-100倍，传输的速度也更加快。</li>
<li>在便捷性上，使用较为简单，能够依靠protoc自动生成序列化和反序列化的目标代码；</li>
<li>维护成本低，只需要维护指定的<code>.protoc</code>文件即可，加密性较好，只有通过<code>proto</code>文件才能了解数据结构</li>
<li>兼容性较好，跨平台，能够支持各种主流语言。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>自解释性差：只有通过<code>proto</code>文件才能了解数据结构，这一点源于它的加密性好，才导致自解释性差。</li>
</ul>
<blockquote>
<p>一般来说，客户端与服务器用的是json，而服务器与服务器之间用protobuf，该策略的原因上面对比已经分析出来了：后端服务之间的RPC调用可能会传输大量数据，如果全部用纯文本的形式来表示数据那么不管是网络带宽还是性能可能都会差强人意，protobuf更适合。而客户端更多与人相关，使用对人较友好的json语句更为稳妥。</p>
</blockquote>
<h2 id="protobuf的序列化和反序列化原理">5 protobuf的序列化和反序列化原理</h2>
<p>protobuf之所以序列化和反序列化快，体积小，在于其采用了独特的编码，采用<code>T - L - V</code>的数据存储方式，减少了分隔符的使用，使得数据存储得紧凑。</p>
<p>在protobuf，其使用<strong>标识 - 长度 - 字段值</strong> 表示每个字段，所有字段拼接成一个 字节流，从而 实现 编码存储 的功能 <img src="/2023/03/10/protobuf/protobuf的存储方式.png" width="700"></p>
<ul>
<li>Tag: field_number &lt;&lt; 3 | wire type <img src="/2023/03/10/protobuf/wireType.png" width="700"></li>
<li>length:可选字段,目前只有类型2需要，例如字符串，length会存储字符串长度。</li>
<li>value：不同类型的value值会有不同的编码方式。下面对每种类型进行逐一讲解。</li>
</ul>
<h3 id="wiretype0时的编码方式">5.1 wireType=0时的编码方式</h3>
<p>采用了两种编码方式：<strong><code>Varint &amp; Zigzag</code></strong></p>
<h4 id="varint">varint</h4>
<ul>
<li><strong>Varint编码方式</strong>:一种变长的编码方式。将数据按7个bit为一组进行分组， 每分组前加1bit标示是否有下一组数据。依靠这种编码技术能够省去不必要的存储空间。 <img src="/2023/03/10/protobuf/varint.png" width="700"></li>
</ul>
<blockquote>
<p>这样就可以用更少的字节表示数字，达到压缩的目的。</p>
</blockquote>
<blockquote>
<ul>
<li>采用 Varint编码，对于很小的 int32 类型 数字，则可以用 1个字节来表示</li>
<li>虽然大的数字会需要 5 个 字节 来表示，但大多数情况下，消息都不会有很大的数字，所以采用 Varint方法总是可以用更少的字节数来表示数字</li>
</ul>
</blockquote>
<ul>
<li><strong>Varint解码方式</strong> <img src="/2023/03/10/protobuf/varint解码方式.png" width="700"></li>
</ul>
<h4 id="zigzag">Zigzag</h4>
<p>Varint 编码方式的不足是如果采用 Varint编码方式 表示一个<strong>负数</strong>，那么一定需要 5 个 byte。<strong>因为最高位bit是1</strong>。例如int32类型 -1: <code>100000000    00000000   00000000 00000001</code>，使用varint编码<code>ceil(4*8/7) =  5</code></p>
<p><strong>protobuf会先采用 Zigzag 编码，再采用 Varint编码</strong>，Zigzag的原理是<strong>使用 无符号数 来表示 有符号数字；</strong></p>
<ul>
<li>Zigzag 编码 是补充 Varint编码在 表示负数 的不足，从而更好的帮助 Protocol Buffer进行数据的压缩</li>
<li>所以，<strong>如果提前预知字段值是可能取负数的时候，记得采用sint32 / sint64 数据类型</strong></li>
</ul>
<h3 id="wiretype2时的编码方式">5.2 wireType=2时的编码方式</h3>
<p>wireType=2时的编码方式，采用<code>T-L-V</code>的格式存储。这里，我们主要讲解常用的讲解三种数据类型的Value：</p>
<ul>
<li>String类型</li>
<li>嵌套消息类型（Message）</li>
<li>通过packed修饰的 repeat 字段（即packed repeated fields）</li>
</ul>
<h4 id="string类型">String类型</h4>
<p>字段值（即V） 采用UTF-8编码 <img src="/2023/03/10/protobuf/string类型的value.png" width="700"> <img src="/2023/03/10/protobuf/string类型的value存储方式.png" width="700"></p>
<h4 id="嵌套消息类型message">嵌套消息类型（Message）</h4>
<p>即字面意思<strong>内部消息编码的T - L -V组成外部消息的v</strong> <img src="/2023/03/10/protobuf/嵌套message.png" width="700"></p>
<h4 id="通过packed修饰的-repeat-字段">通过packed修饰的 repeat 字段</h4>
<p>repeated 修饰的字段有两种表达方式： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message Test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 表达方式1：不带packed=true</span></span><br><span class="line">    repeated int32 Car = <span class="number">4</span> ;</span><br><span class="line">    <span class="comment">// 表达方式2：带packed=true,proto 2.1 开始可使用</span></span><br><span class="line">    repeated int32 Car = <span class="number">4</span> [packed=<span class="literal">true</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在代码中给`repeated int32 Car`附上3个字段值：3、270、86942</span></span><br><span class="line">Test.setCar（<span class="number">3</span>）；</span><br><span class="line">Test.setCar（<span class="number">270</span>）；</span><br><span class="line">Test.setCar（<span class="number">86942</span>）；</span><br></pre></td></tr></table></figure> <img src="/2023/03/10/protobuf/不带packed的repeated存储方式.png" width="700"></p>
<ul>
<li><p><strong>问题：</strong>对于同一个 repeated字段、多个字段值来说，他们的Tag都是相同的，会导致Tag的冗余，即相同的Tag存储多次；</p></li>
<li><p>解决方案：采用带packed=true 的 repeated 字段存储方式，即将相同的 Tag 只存储一次、记一个长度Length字段 ：Tag - Length - Value -Value -Value。 <img src="/2023/03/10/protobuf/带packed的repeated存储方式.png" width="700"></p></li>
</ul>
<p>通过采用带<code>packed=true</code> 的 <code>repeated</code> 字段存储方式，从而更好地压缩序列化后的数据长度。</p>
<blockquote>
<p><strong>特别注意</strong> packed修饰只用于基本类型的repeated字段 用在其他字段，编译 .proto 文件时会报错</p>
</blockquote>
<h3 id="总结">总结</h3>
<ul>
<li>protobuf编码/解码 方式简单，只需要简单的数学运算、位移等，序列化 &amp; 反序列化速度很快</li>
<li>protobuf采用了独特的编码方式，如Varint、Zigzag编码方式等等，采用T - L - V 的数据存储方式，数据存储得紧凑，数据压缩效果好</li>
</ul>
<p><strong>使用建议</strong> 根据上面的序列化原理分析，有以下使用建议：</p>
<ul>
<li><p>建议1：字段标识号（Field_Number）尽量只使用 1-15，且不要跳动使用 因为Tag里的Field_Number是需要占字节空间的。如果Field_Number&gt;16时，Field_Number的编码就会占用2个字节，那么Tag在编码时也就会占用更多的字节；如果将字段标识号定义为连续递增的数值，将获得更好的编码和解码性能</p></li>
<li><p>建议2：若需要使用的字段值出现负数，请使用 sint32 / sint64，不要使用int32 / int64 因为采用sint32 / sint64数据类型表示负数时，会先采用Zigzag编码再采用Varint编码，从而更加有效压缩数据</p></li>
<li><p>建议3：对于repeated字段，尽量增加packed=true修饰 因为加了packed=true修饰repeated字段采用连续数据存储方式，即T - L - V - V -V方式</p></li>
</ul>
<h2 id="protobuf语法">6 protobuf语法</h2>
<h3 id="定义一个消息类型">定义一个消息类型</h3>
<p>假设现在要定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的 .proto 文件了： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">package Request;</span><br><span class="line">option go_package=<span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query = <span class="number">1</span>;</span><br><span class="line">    int32 page_number = <span class="number">2</span>;</span><br><span class="line">    int32 result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - syntax：是必须写的，而且要定义在第一行；目前proto3是主流，不写默认使用proto2 - package：定义我们proto文件的包名 - option go_package：定义生成的pb.go的包名，我们通常在proto文件中定义。如果不在proto文件中定义，也可以在使用protoc生成代码时指定pb.go文件的包名 - message：非常重要，用于定义消息结构体，不用着急，下文会重点讲解</p>
<h3 id="分配标识号">分配标识号</h3>
<p>可以看到消息定义的每个字段都有一个唯一的数字标识符。<strong>这个标识符用于在消息的二进制格式中标识字段, 一旦消息类型被使用后不可以再修改。</strong></p>
<p>注意标识符的值在 <strong>1 和 15 之间时，编码只需一个字节</strong>。标识符 在16 到 2047 之间将占用两个字节<strong>。因此应该将从 1 到 15 的标识符分派给最频繁出现的消息元素</strong>。记得保留一些空间给未来可能添加的频繁出现的元素。</p>
<p>最小的标识号可以从 1 开始，最大到 <span class="math inline">\(2^{29} - 1\)</span>（536,870,911）,另外<code>19000 到 19999(FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber)</code>不能使用，Protobuf协议实现中对这些进行了预留。</p>
<h3 id="指定字段规则">指定字段规则</h3>
<p>消息字段有以下两种属性：</p>
<ul>
<li><strong><code>singular</code></strong>：一个格式良好的消息应该有 0 个或者 1 个这种字段（但是不能超过 1 个）。（没有使用 repeated 默认属于这种属性）</li>
<li><strong><code>repeated</code>(数组形式）</strong>：在一个格式良好的消息中，这种字段可以重复任意多次（包括 0 次）。重复的值的顺序会被保留。（<strong>在 go 里面会被转化为数组</strong>）</li>
</ul>
<p>在 proto3 中，<code>repeated</code> 的标量域默认情况下会使用<code>packed</code> 编码(见上编码原理)</p>
<h3 id="定义多个消息类型">定义多个消息类型</h3>
<p>在一个 .proto 文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与 SearchResponse消息类型对应的回复消息格式的话，可以将它添加到相同的 .proto 文件中，如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  string query = <span class="number">1</span>;</span><br><span class="line">  int32 page_number = <span class="number">2</span>;</span><br><span class="line">  int32 result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchResponse &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="添加注释">添加注释</h3>
<p>向 .proto 文件添加注释，可以使用 C/C++/Java 风格的双斜杠（//） 语法格式，如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  string query = <span class="number">1</span>;</span><br><span class="line">  int32 page_number = <span class="number">2</span>;  <span class="comment">// Which page number do we want?</span></span><br><span class="line">  int32 result_per_page = <span class="number">3</span>;  <span class="comment">// Number of results to return per page.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="保留标识符reserved">保留标识符（Reserved）</h3>
<p>当更新消息类型，需要彻底删除或者注释掉一个字段时，以后的用户在更新这个类型的时候可以重用这些标识号。如果他们后来使用同一个文件的旧版本加载，会导致严重的问题，包括数据损坏、隐私错误等等。现在有一种确保不会发生这种情况的方法就是为字段 tag（reserved name 可能会 JSON 序列化的问题）指定 reserved 标识符，protocol buffer 的编译器会警告未来尝试使用这些域标识符的用户。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>;</span><br><span class="line">  reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong><em>注：不要在同一行 reserved 声明中同时声明名字和标签数字。</em></strong></p>
<h3 id="从-.proto-生成的文件">从 .proto 生成的文件</h3>
<p>当用 protocol buffer 编译器来运行 .proto 文件时,即<code>protoc **.proto --*_out=&quot;.&quot;</code>，编译器将选择的编程语言，生成相应的代码，这些代码可以操作在 .proto 文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>
<ul>
<li>对 C++ 来说，编译器会为每个 .proto 文件生成一个 .h 文件和一个 .cc 文件，.proto 文件中的每一个消息有一个对应的类。</li>
<li>对 Java 来说，编译器为每一个消息类型生成了一个 .java 文件，以及一个特殊的 Builder 类（该类是用来创建消息类接口的）。</li>
<li>对 Python 来说，有点不太一样——Python 编译器为 .proto 文件中的每个消息类型生成一个含有静态描述符的模块，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的 Python 数据访问类。</li>
<li>对 Go 来说，编译器会位每个消息类型生成了一个 .pd.go 文件。</li>
<li>对于 Ruby 来说，编译器会为每个消息类型生成了一个 .rb 文件。</li>
<li>对 javaNano 来说，编译器输出类似于 java 但是没有 Builder 类</li>
<li>对于 Objective-C 来说，编译器会为每个消息类型生成了一个 pbobjc.h 文件和 pbobjcm 文件，.proto 文件中的每一个消息有一个对应的类。</li>
<li>对于 C# 来说，编译器会为每个消息类型生成了一个 .cs 文件，.proto 文件中的每一个消息有一个对应的类。</li>
</ul>
<h2 id="protobuf的字段类型与编程语言的对应">7 protobuf的字段类型与编程语言的对应</h2>
<p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>
<table style="width:83%;">
<colgroup>
<col style="width: 5%">
<col style="width: 33%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 9%">
<col style="width: 5%">
<col style="width: 6%">
</colgroup>
<thead>
<tr class="header">
<th>.proto</th>
<th>使用技巧</th>
<th>C++</th>
<th>Java</th>
<th>Python</th>
<th>Go</th>
<th>Ruby</th>
<th>C#</th>
<th>PHP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>float64</td>
<td>Float</td>
<td>double</td>
<td>float</td>
</tr>
<tr class="even">
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>Float</td>
<td>float</td>
<td>float</td>
</tr>
<tr class="odd">
<td>int32</td>
<td>使用变长编码，对于负值的效率很低，如果值有可能有负值，使用sint32替代</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr class="even">
<td>int64</td>
<td>使用变长编码，对于负值的效率很低，如果值有可能有负值，使用sint64替代</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string</td>
</tr>
<tr class="odd">
<td>uint32</td>
<td>使用变长编码</td>
<td>uint32</td>
<td>int</td>
<td>int/long</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>uint</td>
<td>integer</td>
</tr>
<tr class="even">
<td>uint64</td>
<td>使用变长编码</td>
<td>uint64</td>
<td>long</td>
<td>int/long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer/string</td>
</tr>
<tr class="odd">
<td>sint32</td>
<td>使用变长编码，这些编码在负值时比int32高效的多</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr class="even">
<td>sint64</td>
<td>使用变长编码，有符号的整型值。编码时比通常的int64高效。</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string</td>
</tr>
<tr class="odd">
<td>fixed32</td>
<td>总是4个字节，如果数值总是比228大的话，这个类型会比uint32高效。</td>
<td>uint32</td>
<td>int</td>
<td>int</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>uint</td>
<td>integer</td>
</tr>
<tr class="even">
<td>fixed64</td>
<td>总是8个字节，如果数值总是比256大的话，这个类型会比uint64高效。</td>
<td>uint64</td>
<td>long</td>
<td>int/long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer/string</td>
</tr>
<tr class="odd">
<td>sfixed32</td>
<td>总是4个字节</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr class="even">
<td>sfixed64</td>
<td>总是8个字节</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string</td>
</tr>
<tr class="odd">
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>bool</td>
<td>TrueClass/FalseClass</td>
<td>bool</td>
<td>boolean</td>
</tr>
<tr class="even">
<td>string</td>
<td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td>
<td>string</td>
<td>String</td>
<td></td>
<td>str/unicode</td>
<td>string</td>
<td>String (UTF-8)</td>
<td>string</td>
</tr>
<tr class="odd">
<td>bytes</td>
<td>可能包含任意顺序的字节数据。</td>
<td>string</td>
<td>ByteString</td>
<td>str</td>
<td>[]byte</td>
<td>String (ASCII-8BIT)</td>
<td>ByteString</td>
<td>string</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>在 java 中，无符号 32 位和 64 位整型被表示成他们的整型对应形式，最高位被储存在标志位中。</li>
<li>对于所有的情况，设定值会执行类型检查以确保此值是有效。</li>
<li>64 位或者无符号 32 位整型在解码时被表示成为 long，但是在设置时可以使用int型值设定，在所有的情况下，值必须符合其设置其类型的要求。</li>
<li>python中 string 被表示成在解码时表示成 unicode。但是一个 ASCII string 可以被表示成 str 类型。</li>
<li>Integer 在 64 位的机器上使用，string 在 32 位机器上使用</li>
</ol>
<h2 id="默认值">8 默认值</h2>
<p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的简单元素，被解析的对象所对应的字段被设置为默认值，对于不同类型指定如下：</p>
<ul>
<li>对于string，默认是一个空 string</li>
<li>对于bytes，默认是一个空的 bytes</li>
<li>对于 bool，默认是 false</li>
<li>对于数值类型，默认是 0</li>
<li>对于枚举，默认是第一个定义的枚举值，必须为 0;</li>
<li>对于消息类型（message），如果没有被设置，确切的消息是根据语言确定的。</li>
</ul>
<p>对于可重复的字段，默认值是空（通常情况下是对应语言中空数组）。</p>
<blockquote>
<p>对于简单字段，一旦消息被解析，就无法判断这个字段时有设置值但是恰巧是默认值，还是根本没有被设置（例如 boolean 值是否被设置为 false）。另外，如果一个简单消息字段被设置为默认值，这个值不会被序列化传输。</p>
</blockquote>
<h2 id="更新一个消息类型">9 更新一个消息类型</h2>
<p>如果一个已有的消息格式已无法满足新的需求。<strong>例如，要在消息中添加一个额外的字段，但是同时旧版本写的代码仍然可用。不用担心，更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可：</strong></p>
<ul>
<li><p><strong>不要更改任何已有的字段的数值标识。</strong></p></li>
<li><p>如果增加新的字段，使用旧格式的字段仍然可以被新产生的代码所解析。应该记住这些元素的默认值，这样新代码就可以以适当的方式和旧代码生成的数据交互。<strong>相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉</strong>。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和 proto2 中的行为是不同的，在 proto2 中未定义的域依然会随着消息被序列化）</p></li>
<li><p><strong>非 required 的字段可以移除，只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的 .proto 文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</strong></p></li>
<li><p>int32, uint32, int64, uint64, 和 bool 是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在 C++ 中对它进行了强制类型转换一样（例如，如果把一个 64 位数字当作 int32 来读取，那么它就会被截断为 32 位的数字）。</p></li>
<li><p>sint32 和 sint64 是互相兼容的，但是它们与其他整数类型不兼容。</p></li>
<li><p>string 和 bytes 是兼容的（只要 bytes 是有效的 UTF-8 编码）。</p></li>
<li><p>嵌套消息与 bytes 是兼容的（只要 bytes 包含该消息的一个编码过的版本）。</p></li>
<li><p>fixed32 与 sfixed32 是兼容的，fixed64 与 sfixed64 是兼容的。</p></li>
<li><p>枚举类型与 int32，uint32，int64 和 uint64 相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的 proto3 枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int 类型的字段总会被保留。</p></li>
</ul>
<h2 id="字段类型">10 字段类型</h2>
<p>处理上面提到的一些基础类型以外，protobuf还支持一些其他结构类型。</p>
<h3 id="枚举">枚举</h3>
<p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个 SearchRequest 消息添加一个 corpus 字段，而 corpus 的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS 或 VIDEO 中的一个。 这时通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。</p>
<p>在下面的例子中，在消息格式中添加了一个叫做SexType 的枚举类型——它含有所有可能的值 ——以及一个类型为 SexType 的字段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;<span class="comment">//指定版本信息，非注释的第一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SexType</span> <span class="comment">//枚举消息类型，使用enum关键词定义,一个性别类型的枚举类型</span></span><br><span class="line">&#123;</span><br><span class="line">    UNKONW = <span class="number">0</span>; <span class="comment">//proto3版本中，首成员必须为0，成员不应有相同的值</span></span><br><span class="line">    MALE = <span class="number">1</span>;  <span class="comment">//1男</span></span><br><span class="line">    FEMALE = <span class="number">2</span>; <span class="comment">//2女  0未知</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个用户消息</span></span><br><span class="line">message UserInfo</span><br><span class="line">&#123;</span><br><span class="line">    string name = <span class="number">1</span>; <span class="comment">// 姓名字段</span></span><br><span class="line">    SexType sex = <span class="number">2</span>; <span class="comment">// 性别字段，使用SexType枚举类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SexType 枚举的第一个常量映射为 0：每个枚举类型必须将其第一个类型映射为0，这是因为：</p>
<ul>
<li>必须有一个 0 值，可以用这个 0 值作为默认值。</li>
<li>这个零值必须为第一个元素，为了兼容 proto2 语义，枚举类的第一个值总是默认值。</li>
</ul>
<p><strong>可以通过将相同值赋值给不同的枚举常量来定义别名. 为此需要设置<code>allow_alias</code>选项为true</strong>, 否则当发现别名时protocol编译器会生成错误消息。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumAllowingAlias</span> &#123;</span><br><span class="line">  option allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 此时 RUNNING 是 STATRTED 的别名</span></span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumNotAllowingAlias</span> &#123;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 枚举常量必须在 32 位整型值的范围内。因为 enum 值是使用可变编码方式的，对负数不够高效，因此不推荐在 enum 中使用负数。</p>
<p>如上例所示，可以外部声明枚举类型，然后message内定义一个枚举类型；当然，<strong>也可以在message中声明枚举类型然后定义。</strong></p>
<p>当对一个使用了枚举的 .proto 文件运行 protocol buffer 编译器的时候，生成的代码中将有一个对应的 enum（对Java或C++来说）</p>
<blockquote>
<p>Go不直接支持枚举的，并没有<code>enum</code>关键字</p>
</blockquote>
<h3 id="自定义类型">自定义类型</h3>
<p>可以将其他消息类型用作自定义的字段类型。例如，假设在每一个 <code>SearchResponse</code> 消息中包含 <code>Result</code> 消息，此时可以在相同的 <code>.proto</code>文件中定义一个<code>Result</code> 消息类型，然后在<code>SearchResponse</code> 消息中指定一个 <code>Result</code>类型的字段，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">essage SearchResponse &#123;</span><br><span class="line">  repeated Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Result &#123;</span><br><span class="line">  string url = <span class="number">1</span>;</span><br><span class="line">  string title = <span class="number">2</span>;</span><br><span class="line">  repeated string snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="导入其他文件中的类型">导入其他文件中的类型</h4>
<p>如果是希望导入其他 .proto 文件中的类型定义，可以在文件中添加一个导入声明： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在this.proto导入other_protos.proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;myproject/other_protos.proto&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>这种导入方式存在一个问题：</strong><code>this.proto</code>只能通过<strong><code>包名.消息或类型名称</code></strong>访问<code>other_protos.proto</code>中定义的消息或类型。无法访问在<code>other_protos.proto</code>内<code>import</code>的其他<code>proto</code>文件里定义的消息或类型，即：只能访问直接import的proto文件里的类型或消息；</p></li>
<li><p><strong>解决方法</strong>：通过<code>import public</code>可解决。即如果在<code>other_protos.proto</code>内使用<code>import public</code>关键字导入其他<code>proto</code>文件，那么在导入<code>other_protos.proto</code>的<code>proto</code>文件中可以访问其他<code>proto</code>文件。这种方式就想是将<code>proto</code>文件移到<code>other_protos.proto</code>一样</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new.proto文件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old.proto文件</span></span><br><span class="line"><span class="comment">// 通过import public导入new.proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">public</span> <span class="string">&quot;new.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;other.proto&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端 proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;old.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 现在你可以使用new.protoc和old.protoc两种包的proto定义了。</span></span><br></pre></td></tr></table></figure>
<p>通过在编译器命令行参数中使用 -I/--proto_pathprotocal 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常只要指定 proto_path 标志为工程根目录，并且指定好导入的正确名称就好。</p>
<h4 id="使用-proto2-的消息类型">使用 proto2 的消息类型</h4>
<p>导入 proto2 的消息类型并在 proto3 消息中使用是可以的，反之也如此。但是，proto2 的枚举不能在 proto3 语法中使用</p>
<h3 id="any">Any</h3>
<p>Protobuf中的Any类型可以理解为泛型类型，它可以存储任何消息类型的字段（int, char等类型必须先封装成消息类型）。Any类型字段也可以用<code>Repeated</code> 修饰。为了使用Any类型，你需要导入import google/protobuf/any.proto。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">  string message = <span class="number">1</span>;</span><br><span class="line">  repeated google.protobuf.Any details = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于给定的消息类型的默认类型 URL 是 type.googleapis.com/packagename.messagename。</p>
<p>不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装 Any 值。例如在 java 中，Any类型会有特殊的 pack() 和 unpack() 访问器，在C++中会有 <code>PackFrom()</code> 和 <code>UnpackTo()</code> 方法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Storing an arbitrary message type in Any.</span></span><br><span class="line">NetworkErrorDetails details = ...;</span><br><span class="line">ErrorStatus status;</span><br><span class="line">status.<span class="built_in">add_details</span>()-&gt;<span class="built_in">PackFrom</span>(details);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reading an arbitrary message from Any.</span></span><br><span class="line">ErrorStatus status = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> Any&amp; detail : status.<span class="built_in">details</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (detail.<span class="built_in">Is</span>&lt;NetworkErrorDetails&gt;()) &#123;</span><br><span class="line">    NetworkErrorDetails network_error;</span><br><span class="line">    detail.<span class="built_in">UnpackTo</span>(&amp;network_error);</span><br><span class="line">    ... processing network_error ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 目前，用于Any类型的动态库仍在开发之中</p>
<h3 id="oneof">Oneof</h3>
<p><strong>如果消息中有很多可选字段，并且同时至多一个字段会被设置， 可以通过使用 Oneof 特性来强化这个行为并节省内存。</strong></p>
<p>Oneof 字段就像可选字段， 除了它们会共享内存，并且同一时间最多一个字段会被设置。 设置其中一个字段会清除其它字段。 可以使用 <code>case()</code> 或者 <code>WhichOneof()</code> 方法检查哪个 <code>oneof</code> 字段被设置，这取决于使用什么编程语言。</p>
<p>因为 <code>proto3</code>没有办法区分正常的值是否是设置了还是取得缺省值(比如 int64 类型字段，如果它的值是 0，无法判断数据是否包含这个字段，因为 0 既可能是数据中设置的值，也可能是这个字段的零值)，所以可以通过 <code>Oneof</code> 取得这个功能，因为 <code>Oneof</code> 有判断字段是否设置的功能。</p>
<h4 id="使用-oneof">使用 Oneof</h4>
<p>为了在 . proto 定义 Oneof 字段， 需要在名字前面加上 <code>oneof</code> 关键字, 比如下面例子的 <code>test_oneof:</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message SampleMessage &#123;</span><br><span class="line">  oneof test_oneof &#123;</span><br><span class="line">    string name = <span class="number">4</span>;</span><br><span class="line">    SubMessage sub_message = <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后再将<code>oneof</code> 字段定义到<code>test_oneof</code> 中。<strong>可以增加任意类型的字段，但是不能使用<code>repeated</code>关键字。 </strong> 在产生的代码中, oneof 字段拥有同样的 <code>getters</code>和<code>setters</code>， 就像正常的可选字段一样，也有一个特殊的方法来检查到底哪个字段被设置。</p>
<h4 id="oneof-特性">Oneof 特性</h4>
<ul>
<li>设置 oneof 会自动清除其它 oneof 字段的值。所以设置多次后，只有最后一次设置的字段有值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">CHECK</span>(message.<span class="built_in">has_name</span>());</span><br><span class="line">message.<span class="built_in">mutable_sub_message</span>();   <span class="comment">// Will clear name field.</span></span><br><span class="line"><span class="built_in">CHECK</span>(!message.<span class="built_in">has_name</span>());</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">- 如果解析器遇到同一个 oneof 中有多个成员，只有看到的最后一个成员会被解析成消息。</span><br><span class="line">- oneof 不支持 repeated.</span><br><span class="line">- 反射 API 对 oneof 字段有效.</span><br><span class="line">- 如果使用 C++，需确保代码不会导致内存泄漏。下面的代码会崩溃， 因为 sub_message 已经通过 <span class="built_in">set_name</span>() 删除了</span><br><span class="line">```cpp</span><br><span class="line">SampleMessage message;</span><br><span class="line">SubMessage* sub_message = message.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);      <span class="comment">// Will delete sub_message</span></span><br><span class="line">sub_message-&gt;set_...            <span class="comment">// Crashes here</span></span><br></pre></td></tr></table></figure></li>
<li>在 C++ 中，如果使用 Swap() 来交换两个带有 oneof 的消息，每个消息将会有另一个消息的 oneof，例如在下面的例子中，msg1 会拥有sub_message 并且 msg2 会有 name。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SampleMessage msg1;</span><br><span class="line">msg1.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">SampleMessage msg2;</span><br><span class="line">msg2.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">msg1.<span class="built_in">swap</span>(&amp;msg2);</span><br><span class="line"><span class="built_in">CHECK</span>(msg1.<span class="built_in">has_sub_message</span>());</span><br><span class="line"><span class="built_in">CHECK</span>(msg2.<span class="built_in">has_name</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="向后兼容性问题">向后兼容性问题</h4>
<p>当增加或者删除 oneof 字段时一定要小心。如果检查 oneof 的值返回 None/NOT_SET，它意味着 oneof 字段没有被赋值或者在一个不同的版本中赋值了。 没有办法知道是哪种情况，因为没有办法判断一个未知字段是否是 oneof 的成员。</p>
<h4 id="tag-重用问题">Tag 重用问题</h4>
<p>将字段移入或移除oneof：在消息被序列号或者解析后，可能会失去一些信息（有些字段也许会被清除） 删除一个字段或者加入一个字段：在消息被序列号或者解析后，这也许会清除现在设置的 oneof 字段 分离或者融合oneof：和移动普通字段一样有类似问题。</p>
<h3 id="map">Map</h3>
<p>如果希望创建一个关联映射，protocol buffer 提供了一种快捷的语法： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure> - 其中 key_type 可以是任意 Integer 或者 string 类型（所以，除了 floating 和 bytes 的任意简单类型都是可以的）。</p>
<ul>
<li>value_type 可以是任意类型。</li>
</ul>
<p>例如，如果希望创建一个 project 的映射，每个 Projecct 使用一个 string 作为 key，可以像下面这样定义： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string, Project&gt; projects = <span class="number">3</span>;</span><br></pre></td></tr></table></figure> - Map 的字段不可以是 repeated。 - 序列化后的顺序和 map 迭代器的顺序是不确定的，所以不要期望以固定顺序处理 Map。 - 当为 .proto 文件产生生成文本格式的时候，map 会按照 key 的顺序排序，数值化的 key 会按照数值排序。 - 从序列化中解析或者融合时，如果有重复的 key 则后一个 key 不会被使用，当从文本格式中解析 map 时，如果存在重复的 key，则可能会导致解析失败。 - 如果为映射字段提供键但没有值，则序列化字段时的行为取决于语言。在 C ++，Java 和 Python 中，该类型的默认值已序列化，而在其他语言中，则没有序列化。</p>
<h4 id="向后兼容性问题-1">向后兼容性问题</h4>
<p>map语法序列化后等同于如下内容，因此即使是不支持 map 语法的protocol buffer 实现也是可以处理数据的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">message MapFieldEntry &#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeated MapFieldEntry map_field = N  </span><br></pre></td></tr></table></figure></p>
<h3 id="定义服务service">定义服务(Service)</h3>
<p>如果想要将消息类型用在 RPC (远程方法调用)系统中，可以在 .proto 文件中定义一个 RPC 服务接口，protocol buffer 编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个 RPC 服务并具有一个方法，该方法能够接收 SearchRequest 并返回一个 SearchResponse，此时可以在 .proto 文件中进行如下定义： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">service SearchService &#123;</span><br><span class="line">  <span class="function">rpc <span class="title">Search</span> <span class="params">(SearchRequest)</span> <span class="title">returns</span> <span class="params">(SearchResponse)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 最直观的使用 protocol buffer 的 RPC 系统是 Go 的 RPC 框架 gRPC，一个由谷歌开发的语言和平台中的开源的 PRC 系统，gRPC 在使用 protocl buffer 时非常有效，如果使用特殊的 protocol buffer 插件可以直接从 .proto 文件中产生相关的RPC代码。</p>
<p>如果不想使用 gRPC，也可以使用 protocol buffer 用于自己的 RPC 实现。</p>
<h2 id="实例">11 实例</h2>
<p>文章参考来源：</p>
<blockquote>
<p><a href="https://blog.csdn.net/wangdanyangtc/article/details/126480389">protobuf序列化和反序列化原理</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/633656133">如果面试提到Protobuf，面试官问其原理怎么办？</a></p>
<p><a href="https://juejin.cn/post/7164261080678531108">IM通讯协议专题学习(一)：Protobuf从入门到精通，一篇就够！</a></p>
<p><a href="https://juejin.cn/post/7144948875613339685">【Go微服务】一文带你玩转ProtoBuf</a></p>
<p><a href="https://xiaoming.net.cn/2020/11/27/Protobuf%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/#%E5%9C%A8-Go-%E4%B8%AD%E4%BD%BF%E7%94%A8-protobuf">Protobuf</a></p>
</blockquote>
]]></content>
      <categories>
        <category>protobuf</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础知识</title>
    <url>/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="python的运行过程">1. python的运行过程</h4>
<p><img src="https://img-blog.csdnimg.cn/9f0f1b3db22d4c1e8a5bdd455e7702a7.jpeg#pic_center"></p>
<h5 id="字节码编译">1.1 字节码编译</h5>
<p>当程序运行时,Python内部会将源代码(.py文件中的程序)编译成所谓的字节码的形式,就是将每一行源代码语句从上到下翻译过来,翻译成一组字节码的指令.这些字节码可以提高执行速度;比起源代码语句,字节码要执行快的多。 <span id="more"></span></p>
<p>它会将字节码保存为一个以pyc为扩展名的文件，Python这样保存字节码是一种作为启动速度的优化.下一次运行程序时,如果你还停留在上一次修改记录的话,就会直接跳过编译直接加载.pyc文件.</p>
<h5 id="pvm虚拟机">1.2 PVM虚拟机</h5>
<p>py程序编译成字节码后，字节码文件会发送给PVM，也就是python虚拟机进行出来。PVM是python运行的引擎，从根本上讲，它才算是python解释器。python虚拟机就是去模拟可执行程序在x86机器上的运行</p>
<h4 id="python的内置对象">2. python的内置对象</h4>
<p>python中没有类型声明，运行的表达式的语法决定了创建和使用对象的类型，正如以下表达式就是这些类型起源的地方。Python有五个标准的数据类型：</p>
<ul>
<li><code>Numbers</code>（数字）</li>
<li><code>String</code>（字符串）</li>
<li><code>List</code>（列表）</li>
<li><code>Tuple</code>（元组）</li>
<li><code>Dictionary</code>（字典）</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">column</th>
<th style="text-align: center;">column</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数字</td>
<td style="text-align: center;"><code>1234，3.14159，3+4j</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">字符串</td>
<td style="text-align: center;"><code>'spaw',&quot;guidos&quot;,&quot;python&quot;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">列表</td>
<td style="text-align: center;"><code>[1,[2,'there'],4]</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">字典</td>
<td style="text-align: center;"><code>&#123;'food':'spam','taste':'yum'&#125;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">元组</td>
<td style="text-align: center;"><code>(1,'spam',4,'u')</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">文件</td>
<td style="text-align: center;"><code>my=open('eggs','r')</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">集合</td>
<td style="text-align: center;"><code>set('abs'),&#123;'a','b','s'&#125;</code></td>
</tr>
</tbody>
</table>
<p>可迭代对象：字符串、列表、字典、元组、集合、文件对象 一些操作： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//数字整型</span><br><span class="line">s=<span class="number">546</span>;</span><br><span class="line">s=s*<span class="number">4</span>;</span><br><span class="line">//字符串</span><br><span class="line">s=<span class="string">&#x27;spam&#x27;</span>;</span><br><span class="line">k=<span class="built_in">len</span>(s); 	<span class="comment">#k=4</span></span><br><span class="line">s=s+<span class="string">&#x27;xyz&#x27;</span>;  <span class="comment">#s=&#x27;spamxyz&#x27;</span></span><br><span class="line">//序列操作</span><br><span class="line">s=<span class="string">&#x27;spam&#x27;</span>;</span><br><span class="line">q=s[<span class="number">0</span>];</span><br><span class="line">m=s[-<span class="number">1</span>];	<span class="comment">#字符串长度-1，即s[4-1]</span></span><br><span class="line">t=s[<span class="number">0</span>:<span class="number">3</span>]	<span class="comment">#从下标0开始，输出三个字符，即t=&#x27;spa&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>重要性质：</strong></p>
<p><strong>python的对象内存不可变性：</strong>在上面所写的例子中没有通过任何操作对原始字符串即spam变动，字符串在python中具有不可变性，在创建后就不可改变，但比总可以通过建立一个新的字符串并以同一个名字对其进行赋值（如<code>s=s+'xyz'</code>)，因为python在运行过程中会清理旧对象（动态类型）。<strong>一旦改变便意味是产生了新的对象</strong></p>
<h4 id="数字类型">3. 数字类型</h4>
<h5 id="一些内置的数学函数">3.1 一些内置的数学函数</h5>
<table>
<thead>
<tr class="header">
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>abs()</code></td>
<td>取绝对值</td>
</tr>
<tr class="even">
<td><code>pow()</code></td>
<td>计算任意N次方值</td>
</tr>
<tr class="odd">
<td><code>min()\max()</code></td>
<td>取最小值</td>
</tr>
<tr class="even">
<td><code>divmod()</code></td>
<td>同时取商和余数</td>
</tr>
<tr class="odd">
<td><code>sum()</code></td>
<td>求和</td>
</tr>
<tr class="even">
<td><code>round()</code></td>
<td>四舍五入</td>
</tr>
<tr class="odd">
<td><code>hex()</code></td>
<td>十进制转为十六进制</td>
</tr>
</tbody>
</table>
<h5 id="表达式操作符">3.2 表达式操作符</h5>
<p>与C/C++有些不同： <img src="https://img-blog.csdnimg.cn/57b3415f38e34a2a96c5b56f1dd1bffa.jpeg#pic_center"></p>
<h4 id="字符串">4. 字符串</h4>
<h5 id="raw字符串抑制转义">4.1 raw字符串抑制转义</h5>
<p>转义序列用来处理嵌入在自符串中的特殊字节编码很合适，但有些场合我们希望不要发生转义，如文件路径中<code>myfile=open('C:\new\test.txt','w')。</code>本意想打开这个文件，但是因为转义字符<code>\n</code>的存在。如果字母<code>r</code>出现在字符串第一个引号钱，意味着关闭转义：<code>myfile=open(R'C:\new\test.txt','w')'</code></p>
<h5 id="常见操作">4.2 常见操作</h5>
<p>对于python的字符串，无论是<code>&quot;&quot;</code>还是<code>''</code>都一样,支持串与串的相加，支持串与数的相乘，但不允许串与数的相加。同时支持负偏移和分片操作： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;trluper&quot;</span>;	<span class="comment">#合法</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;	<span class="comment">#合法</span></span><br><span class="line">c=<span class="built_in">str</span>[-<span class="number">1</span>];		<span class="comment">#str[len(str)-1]=str[6]</span></span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>+<span class="string">&#x27;github&#x27;</span>;</span><br><span class="line"><span class="built_in">str</span>*=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">str</span>+=<span class="number">4</span>;			<span class="comment">#error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r</span><br><span class="line">trlupergithub</span><br><span class="line">trlupergithubtrlupergithubtrlupergithubtrlupergithub</span><br></pre></td></tr></table></figure></p>
<p><strong>分片：</strong><code>Str[i:j]</code>i表示从下标为i的开始，小标j结束（不包括j）(i未输入时默认为0，j未说明默认为到最后一个元素)。即<code>str[1:-1]</code>,表示从r开始到e结束（<code>len(str)-1=6</code>），<strong>分片会产生新对象。</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br><span class="line">s=<span class="built_in">str</span>[<span class="number">1</span>:-<span class="number">1</span>];</span><br><span class="line"><span class="built_in">print</span>(s);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rlupe</span><br></pre></td></tr></table></figure></p>
<p><strong>扩展分片：</strong>分片表达式有可选的第三个索引，用作步进<code>str[i:j:k]</code>，未声明时k默认为1，表示隔几个元素取 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br><span class="line">s=<span class="built_in">str</span>[<span class="number">1</span>:-<span class="number">1</span>:<span class="number">2</span>];</span><br><span class="line"><span class="built_in">print</span>(s);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rue</span><br></pre></td></tr></table></figure></p>
<h5 id="数据类型转换">4.3 数据类型转换</h5>
<p>上面讲到字符串和数字之间无法相加，会发生错误，为解决这方面问题，python提供了字符串和数字间的转换函数：</p>
<table>
<thead>
<tr class="header">
<th>函数名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>int(string s)</code></td>
<td>将字符串转换为数字</td>
</tr>
<tr class="even">
<td><code>str(int i)</code></td>
<td>将数字转换为字符串</td>
</tr>
<tr class="odd">
<td><code>float(string s</code>)</td>
<td>将字符串转换为浮点数</td>
</tr>
<tr class="even">
<td><code>repr(object)</code></td>
<td>将对象转换为字符串并返回一个字符串对象</td>
</tr>
<tr class="odd">
<td><code>ord(char c)</code></td>
<td>将单个字符转为ascii码</td>
</tr>
<tr class="even">
<td><code>chr(int i)</code></td>
<td>将数字转换为对于的ascii码</td>
</tr>
<tr class="odd">
<td><code>tuple(s)</code></td>
<td>将序列 s 转换为一个元组</td>
</tr>
<tr class="even">
<td><code>list(s)</code></td>
<td>将序列 s 转换为一个列表</td>
</tr>
<tr class="odd">
<td><code>set(s)</code></td>
<td>转换为可变集合</td>
</tr>
<tr class="even">
<td><code>dict(d)</code></td>
<td>创建一个字典。d 必须是一个序列 (key,value)元组。</td>
</tr>
</tbody>
</table>
<h5 id="修改查询字符串">4.4 修改/查询字符串</h5>
<p>对于不可变性质，如果我们要改变原有字符串的一些值，则需要利用合并、分片这样的工具来重新建立并赋值一个新字符串或者<code>replace</code>，若有必要（程序的方便和易读），需要将结果重新赋值给原变量名。查找可以使用<code>find()</code>函数或者判断<code>“Trl&quot; in str</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;Trluper!&#x27;</span>;</span><br><span class="line"><span class="built_in">str</span>[<span class="number">0</span>]=<span class="string">&#x27;t&#x27;</span>;	<span class="comment">#error</span></span><br><span class="line">//分片合并</span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>[:<span class="number">3</span>]+<span class="string">&quot;user&quot;</span>+<span class="built_in">str</span>[-<span class="number">1</span>];</span><br><span class="line">//replace</span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>.replace(<span class="string">&quot;uper&quot;</span>,<span class="string">&quot;user&quot;</span>);</span><br><span class="line">//查找</span><br><span class="line"><span class="built_in">str</span>.find(<span class="string">&quot;trl&quot;</span>);	<span class="comment">#找到返回第一个下标，未找到则返回-1</span></span><br><span class="line">“trl” <span class="keyword">in</span> <span class="built_in">str</span>;		<span class="comment">#return True or false</span></span><br></pre></td></tr></table></figure></p>
<h5 id="字符串格式化">4.5 字符串格式化</h5>
<p>字符串格式化提供了一种组合字符串处理任务的处理思想。在python中有两种形式的<strong>字符串格式化表达式</strong>：</p>
<ol type="1">
<li>基于C的<code>printf模型</code>:在%左侧放置字符串，字符串中带有一个或多个嵌入目标(即<code>%d、%s、%c</code>这些)，<code>%</code>右侧放置一个元组或字典 。</li>
<li>python的字符串的<code>format函数</code>：通过花括号的位置或者关键字指出替换目标</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基于元组的字符串格式化：</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;my name is %s,and I am %d years old&quot;</span> %(<span class="string">&quot;trluper&quot;</span>,<span class="number">24</span>);</span><br><span class="line"><span class="comment">#基于字典</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;my name is %(name)s,and I am %(age)d years old&quot;</span> % &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>&#125;;</span><br><span class="line"><span class="comment">#format函数</span></span><br><span class="line">template=<span class="string">&quot;my name is &#123;0&#125;,and i am &#123;age&#125; years old&quot;</span> ;</span><br><span class="line"><span class="built_in">str</span>=template.<span class="built_in">format</span>(<span class="string">&quot;trluper&quot;</span>,age=<span class="number">24</span>);</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> I am <span class="number">24</span> years old</span><br><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> I am <span class="number">24</span> years old</span><br><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> i am <span class="number">24</span> years old</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串的函数接口">5. 字符串的函数接口</h4>
<h5 id="字符串查询">5.1 字符串查询</h5>
<p>建议使用<code>find</code>，因为如果没有找到匹配的字符串，<code>index</code>方法会报异常。</p>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>find(str, beg=0, end=len(string))</code></td>
<td>查找子串<code>str</code>第一次出现的位置，如果找到则返回相应的索引，否则返回-1</td>
</tr>
<tr class="even">
<td><code>rfind(str, beg=0,end=len(string))</code></td>
<td>类似于<code>find()</code>函数，不过是从右边开始查找</td>
</tr>
<tr class="odd">
<td><code>index(str, beg=0, end=len(string))</code></td>
<td>类似于<code>find</code>，只不过如果没找到会报异常。</td>
</tr>
<tr class="even">
<td><code>rindex(str, beg=0 end=len(string))</code></td>
<td>类似于<code>rfind</code>，如果没有匹配的字符串会报异常</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;my name is qlee，what your name?&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2))<span class="comment">#全部查找</span></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2,<span class="number">5</span>))<span class="comment">#从第5个元素开始查找</span></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2,<span class="number">35</span>))<span class="comment"># 从第35个元素开始查找，超过元素索引或者没找到，不会报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="字符串大小写转换操作upperlowerswapcasecapitalize和title">5.2 字符串大小写转换操作（upper、lower、swapcase、capitalize和title）</h5>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>upper</code></td>
<td>将字符串中所有元素都转为大写</td>
</tr>
<tr class="even">
<td><code>lower</code></td>
<td>将字符串中所有元素都转为小写</td>
</tr>
<tr class="odd">
<td><code>swapcase</code></td>
<td>交换大小写。大写转为小写，小写转为大写</td>
</tr>
<tr class="even">
<td><code>capitalize</code></td>
<td>第一个大写，其余小写</td>
</tr>
<tr class="odd">
<td><code>title</code></td>
<td>每个单词的第一次字符大写，其余均为小写</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">txt = <span class="string">&quot;my name is Qlee&quot;</span></span><br><span class="line"><span class="built_in">print</span>(txt.upper())</span><br><span class="line"><span class="built_in">print</span>(txt.lower())</span><br><span class="line"><span class="built_in">print</span>(txt.swapcase())</span><br><span class="line"><span class="built_in">print</span>(txt.capitalize())</span><br><span class="line"><span class="built_in">print</span>(txt.title())</span><br></pre></td></tr></table></figure>
<h5 id="字符串对齐centerjust和zfill">5.3 字符串对齐（center，just和zfill）</h5>
<p><img src="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png" width="700"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.center(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.ljust(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.rjust(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.zfill(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*********hello world!*********</span><br><span class="line">hello world!******************</span><br><span class="line">******************hello world!</span><br><span class="line">000000000000000000hello world!</span><br></pre></td></tr></table></figure>
<h5 id="分割字符串splitsplitlines和partition">5.4 分割字符串(split、splitlines和partition)</h5>
<p><img src="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png" width="700"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;my name is qlee, what is your name&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split())       <span class="comment"># 以空格为分隔符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split(<span class="string">&#x27;i&#x27;</span>,<span class="number">1</span>))   <span class="comment"># 以 i 为分隔符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split(<span class="string">&#x27;b&#x27;</span>))     <span class="comment"># 以b为分隔符,没找到不会报错</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.partition(<span class="string">&quot;name&quot;</span>))<span class="comment">#找到第一个name，分割为三部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.rpartition(<span class="string">&quot;name&quot;</span>))<span class="comment">#反向找到第一个name，分割为三部分</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;&quot;&quot;my name is qlee</span></span><br><span class="line"><span class="string">      what is your name&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.splitlines())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;qlee,&#x27;</span>, <span class="string">&#x27;what&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;your&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;my name &#x27;</span>, <span class="string">&#x27;s qlee, what is your name&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;my name is qlee, what is your name&#x27;</span>]</span><br><span class="line">(<span class="string">&#x27;my &#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27; is qlee, what is your name&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;my name is qlee, what is your &#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;my name is qlee&#x27;</span>, <span class="string">&#x27;      what is your name&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="合并与替换joinreplace">5.5 合并与替换(join，replace)</h5>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>join(seq)</code></td>
<td>以指定字符串作为分隔符，将 <code>seq</code> 中所有的元素(的字符串表示)合并为一个新的字符串</td>
</tr>
<tr class="even">
<td><code>replace(old,new [,max])</code></td>
<td>把 将字符串中的 <code>old</code> 替换成 <code>new</code>,如果 <code>max</code>指定，则替换不超过<code>max</code>次</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------join-----------&quot;</span>)</span><br><span class="line">seq1 = (<span class="string">&quot;h&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>) <span class="comment">#元组</span></span><br><span class="line">seq2 = [<span class="string">&quot;h&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>] <span class="comment">#列表</span></span><br><span class="line">seq3 = <span class="string">&quot;hello&quot;</span> <span class="comment">#字符串</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;&quot;</span>.join(seq1)) <span class="comment">#无分隔符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot; &quot;</span>.join(seq1))<span class="comment">#空格</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;,&quot;</span>.join(seq1))<span class="comment">#&quot;,&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------replace-----------&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;my name is qlee&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.replace(<span class="string">&quot;qlee&quot;</span>, <span class="string">&quot;lq&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">----------join-----------</span><br><span class="line">hello</span><br><span class="line">h e l l o</span><br><span class="line">h,e,l,l,o</span><br><span class="line">----------replace-----------</span><br><span class="line">my name <span class="keyword">is</span> lq</span><br></pre></td></tr></table></figure></p>
<h5 id="字符串的比较maxmin等">5.6 字符串的比较(&lt;,&gt;,max,min等)</h5>
<p>字符串的比较操作：</p>
<ul>
<li>运算符：<code>&gt; , &gt;=, &lt;, &lt;=, ==, !=</code></li>
<li>比较规则：从第一个以此往下比较。</li>
<li>比较原理：比较的是<code>oridinal value</code>(原始值，即ascii码值)</li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>max(str)</code></td>
<td>返回字符串<code>str</code>中最大的字母</td>
</tr>
<tr class="even">
<td><code>min(str)</code></td>
<td>返回字符串<code>str</code>中最小的字母</td>
</tr>
<tr class="odd">
<td><code>ord</code></td>
<td>将指定字符转换为原始值</td>
</tr>
<tr class="even">
<td><code>chr</code></td>
<td>将原始值转换为对应的字符</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;mynameisqlee&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;max(str): &quot;</span>, <span class="built_in">max</span>(<span class="built_in">str</span>),<span class="string">&quot;min(str): &quot;</span>, <span class="built_in">min</span>(<span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> &lt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;c&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">98</span>))</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="built_in">str</span>):  y <span class="built_in">min</span>(<span class="built_in">str</span>):  a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure></p>
<h5 id="判断字符串isidentifierisspaceisalphaisdecimalisnumeric和isalnum等">5.7 判断字符串(isidentifier、isspace、isalpha、isdecimal、isnumeric和isalnum等)</h5>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>isidentifier</code></td>
<td>判断字符串是不是合法标识符(字符、数字、下划线)</td>
</tr>
<tr class="even">
<td><code>isspace</code></td>
<td>判断字符是否只有空白字符(回车、换行和水平制表符)</td>
</tr>
<tr class="odd">
<td><code>isalpha</code></td>
<td>判断字符串是否全部由字母组成</td>
</tr>
<tr class="even">
<td><code>isdecimal</code></td>
<td>判断字符是否全部由十进制的数字组成，不包括中文、罗马字符</td>
</tr>
<tr class="odd">
<td><code>isdigit</code></td>
<td>判断字符串只包含数字，不包括中文数字</td>
</tr>
<tr class="even">
<td><code>isnumeric</code></td>
<td>判断字符串是否全部由数字组成，中文数字也算</td>
</tr>
<tr class="odd">
<td><code>isalnum</code></td>
<td>判断字符串是否由字母和数字组成</td>
</tr>
<tr class="even">
<td><code>islower</code></td>
<td>判断字符串中的字符是否全部为小写，字符串至少有一个字符</td>
</tr>
<tr class="odd">
<td><code>isupper</code></td>
<td>判断字符串中的字符是否全部为大写，字符串至少有一个字符</td>
</tr>
<tr class="even">
<td><code>istitle</code></td>
<td>判断字符串是否标题话，见<code>titile</code></td>
</tr>
<tr class="odd">
<td><code>isascii</code></td>
<td>如果字符串为空或字符串中的所有字符都是 ASCII，则返回 <code>True</code>，否则返回<code>False</code>。</td>
</tr>
<tr class="even">
<td><code>isprintable</code></td>
<td>如果所有字符都是可打印的，则<code>isprintable()</code>方法返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&amp;&quot;</span>.isidentifier())<span class="comment">#False,&amp;为非法标识符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   t&quot;</span>.isspace())<span class="comment">#False,&quot;t&quot;为非空</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aldflafd你好&quot;</span>.isalpha())<span class="comment">#ture,中文也可以</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isdecimal())<span class="comment">#False,中文不属于十进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isnumeric())<span class="comment">#True,中文、罗马字符的数字也算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123abc&quot;</span>.isalnum())<span class="comment">#True,只能字母和数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isdigit())<span class="comment">#False，不能包括中文</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.islower())<span class="comment"># False,不能为空字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;TLUHBH&quot;</span>.isupper())<span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My Name Is Qlee&quot;</span>.istitle())<span class="comment">#True,只有第一个字符为大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是中国人&quot;</span>.isascii())<span class="comment">#False，中文不属于ascii</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello!\nAre you ?&quot;</span>.isprintable()) <span class="comment">#False,\n不可打印</span></span><br></pre></td></tr></table></figure>
<h4 id="模式匹配">6. 模式匹配</h4>
<p>字符串对象的方法能够支持基于模式的文本出处理，文本的模式匹配是一个高级工具，需要导入一个re模块，这个模块包含了搜索、分割和替换等调用。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re;</span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;Hello  se es ra df world&quot;</span>;</span><br><span class="line">match=re.match(<span class="string">&#x27;Hello[\t]*(.*)world&#x27;</span>,<span class="built_in">str</span>);</span><br><span class="line">gr=match.group(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(gr);</span><br></pre></td></tr></table></figure> 上面这个例子是在以Hello未开始，后面接这几个或零个制表符或空格的，接着将任意字符保存至组中，后以world结尾的str， 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">se es ra df</span><br></pre></td></tr></table></figure></p>
<h4 id="列表list">7. 列表(list)</h4>
<p>python的列表对象是一个任意类型对象的位置相关的有序集合，没有固定大小，不像C++数组那样，它没有固定类型的约束，同时python的核心数据类型一个优秀特性就是能支持任意类型的嵌套。<strong>同字符串不同，列表是可变对象，支持在原处修改</strong>，总结性质如下：</p>
<ul>
<li>列表是保持从左到右的序列，列表内存储的元素没有类型限制，也支持任意嵌套</li>
<li>列表可以像字符串一样索引、分片和合并</li>
<li>与字符串不同的是，列表是可变的，支持在原处修改。同时列表的长度可以改变</li>
<li>在python解释器内部，列表就是C数组，而不是链结构</li>
<li>存储的是对象引用，而不是拷贝，因此从这来看很像C/C++的指针数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#包含了整型、字符串、浮点数</span></span><br><span class="line">L=[<span class="number">123</span>,<span class="string">&quot;spam&quot;</span>,<span class="number">1.23</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">#一些接口</span></span><br><span class="line">append(<span class="built_in">object</span>, /)	<span class="comment">#将任意object在列表尾部插入</span></span><br><span class="line">pop();				<span class="comment">#移除给定偏移项</span></span><br><span class="line">insert();			<span class="comment">#插入元素</span></span><br><span class="line">remove（）;			<span class="comment">#按照值移除</span></span><br><span class="line">sort();				<span class="comment">#安照默认的升序排序</span></span><br><span class="line">reverse();			<span class="comment">#翻转</span></span><br><span class="line"><span class="keyword">del</span> L[i]			<span class="comment">#删除指定位置元素</span></span><br></pre></td></tr></table></figure>
<h4 id="列表解析">8. 列表解析</h4>
<p>处理序列和列表的方法中，python还包括了一个更高级的的操作，称为列表解析表达式.<strong>列表解析最常应用迭代协议的环境之一</strong>，列表解析把任意一个表达式应用于一个迭代对象中的元素。它可提供一种处理矩阵这样的数据结构。假如现在要从矩阵中提取第二列，使用列表解析可以很简单提取出来：<code>row[1]for row in AOI_world</code>,这种表达式有许多玩法，如<code>row[1]for row in AOI_world if row[1]%2==0</code></p>
<ul>
<li>列表解析编写代码比for循环更精简</li>
<li>执行速度更快</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AOI_world=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]];</span><br><span class="line">col2=[row[<span class="number">1</span>]<span class="keyword">for</span> row <span class="keyword">in</span> AOI_world];</span><br><span class="line"><span class="built_in">print</span>(col2);</span><br><span class="line"></span><br><span class="line"><span class="comment">#更爽的用法,rstrip函数去除右边的空白，使用if滤除开头不为p的字符串</span></span><br><span class="line">lines=[line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">if</span> line[<span class="number">0</span>]==<span class="string">&#x27;p&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure> 当然其他相关函数内容如<code>map</code>，<code>filter</code>还未介绍，但列表解析这里可以涉及一些。列表解析说白了，就是把任意一个表达式应用于一个可迭代对象中的元素，并将结束收集到一个新列表中。列表解析能够成为比<code>filter,map</code>更有用的函数工具： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用map</span></span><br><span class="line">res=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>,<span class="string">&#x27;trluper&#x27;</span>));</span><br><span class="line"><span class="comment">#用列表解析</span></span><br><span class="line">res=[<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;trluper&#x27;</span>];</span><br><span class="line"><span class="comment">#使用if的列表解析能有与filter一样的过滤功能</span></span><br><span class="line">res=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"><span class="comment">#嵌套for循环</span></span><br><span class="line">res=[x+y <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]];</span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：列表解析会产生一个新列表对象。</p>
<h4 id="字典dictionary">9. 字典(Dictionary)</h4>
<p>字典是一种映射，是一个键值对集合，通过键值获取相应的值，字典具有可变性，可以随需求增大或减小，像列表那样。字典页可以嵌套，性质总结：</p>
<ul>
<li>字典其实就是散列表也叫哈希表，通过键对生成哈希码而找到值，通过键值对映射类型</li>
<li>与列表不同，字典是无序，保存在字典中的项没有特定的顺序，因此不支持序列操作，如下标访问，是通过键值访问，键值是不可重复的</li>
<li>与列表一样，可变长，存储的元素可为任意类型，支持任意嵌套，可以在原处修改；存储的是对象引用，而不是拷贝 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keyValue_test=&#123;<span class="string">&#x27;food&#x27;</span>:<span class="string">&#x27;fish&#x27;</span>,<span class="string">&#x27;quantity&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;price&#x27;</span>:<span class="number">50</span>&#125;;</span><br><span class="line">fod_name=keyValue_test[<span class="string">&#x27;food&#x27;</span>];</span><br></pre></td></tr></table></figure> <strong>字典常用函数：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;fish&quot;</span> <span class="keyword">in</span> keyValue;		<span class="comment">#键存在判断</span></span><br><span class="line">D.keys();				<span class="comment">#返回所有键,可迭代对象</span></span><br><span class="line">D.values();				<span class="comment">#返回所有值,可迭代对象</span></span><br><span class="line">D.items();				<span class="comment">#键+值,可迭代对象</span></span><br><span class="line">D.copy();				<span class="comment">#拷贝</span></span><br><span class="line">D.get(key,\);			<span class="comment">#返回key对应的值，相当于D[key]</span></span><br><span class="line">D.update(D1);			<span class="comment">#合并字典</span></span><br><span class="line">D.pop(key);				<span class="comment">#删除键值对</span></span><br><span class="line"><span class="built_in">len</span>(D);					<span class="comment">#长度</span></span><br><span class="line"><span class="keyword">del</span> D[key];</span><br><span class="line"><span class="built_in">list</span>(D.keys())			<span class="comment">#生成键序列</span></span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>clear()</code></td>
<td>删除字典内所有元素</td>
</tr>
<tr class="even">
<td><code>copy()</code></td>
<td>返回一个字典的浅复制</td>
</tr>
<tr class="odd">
<td><code>fromkeys(seq[, val])</code></td>
<td>创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td>
</tr>
<tr class="even">
<td><code>get(key, default=None)</code></td>
<td>返回指定键的值，如果值不在字典中返回default值</td>
</tr>
<tr class="odd">
<td><code>has_key(key)</code></td>
<td>如果键在字典dict里返回true，否则返回false</td>
</tr>
<tr class="even">
<td><code>items()</code></td>
<td>以列表返回可遍历的(键, 值) 元组数组</td>
</tr>
<tr class="odd">
<td><code>keys()</code></td>
<td>以列表返回一个字典所有的键</td>
</tr>
<tr class="even">
<td><code>setdefault(key, default=None)</code></td>
<td>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr class="odd">
<td><code>update(dict2)</code></td>
<td>把字典dict2的键/值对更新到dict里</td>
</tr>
<tr class="even">
<td><code>values()</code></td>
<td>以列表返回字典中的所有值</td>
</tr>
<tr class="odd">
<td><code>pop(key[,default])</code></td>
<td>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td>
</tr>
<tr class="even">
<td><code>popitem()</code></td>
<td>返回并删除字典中的最后一对键和值。</td>
</tr>
</tbody>
</table>
<h5 id="键的排序">9.1 键的排序</h5>
<ul>
<li><p>因为字典不是序列，不包含任何可靠的从左到右的顺序排序方法，当我们需要强调某种顺序时，一个常用方法就是通过字典的keys方法收集一个键的列表，使用列表的<code>sort</code>方法进行排序： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key_list=<span class="built_in">list</span>(d.keys());</span><br><span class="line"><span class="built_in">print</span>(key_list);</span><br><span class="line">key_list.sort();</span><br><span class="line"><span class="built_in">print</span>(key_list);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;quantity&#x27;</span>, <span class="string">&#x27;buyer&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;buyer&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;quantity&#x27;</span>]</span><br></pre></td></tr></table></figure></p></li>
<li><p>第二种方法是通过使用最新的<code>sorted</code>内置函数可以一步完成，<code>sorted</code>调用后会返回排序后的新列表对象 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="built_in">sorted</span>(d);</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(key,<span class="string">&quot;==&gt;&quot;</span>,d[key]);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buyer ==&gt; TOM</span><br><span class="line">food ==&gt; fish</span><br><span class="line">price ==&gt; <span class="number">50</span></span><br><span class="line">quantity ==&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="set集合">10. set集合</h4>
<p>set集合是无序的，它既不是映射也不是序列，可以说它是存储无值的键，而且键值唯一不可变</p>
<p>创建集合对象： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#python2.6版</span></span><br><span class="line">x=<span class="built_in">set</span>(<span class="string">&#x27;abcde&#x27;</span>);</span><br><span class="line">y=<span class="built_in">set</span>(<span class="string">&#x27;bdxyz&#x27;</span>);</span><br><span class="line"></span><br><span class="line">z=x&amp;y</span><br><span class="line"><span class="built_in">print</span>(z);</span><br><span class="line"></span><br><span class="line">i=x.intersection(y);</span><br><span class="line"><span class="built_in">print</span>(i);</span><br><span class="line">x.add(<span class="string">&#x27;trluper&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line">x.update(<span class="built_in">set</span>([<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;y&#x27;</span>]));</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line">x.remove(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.0</span></span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="元组tuple">11. 元组(tuple)</h4>
<p>元组对象是一个不可改变的列表，他有列表的有序性，但没有列表的可变性，和字符串类似。它们编写在圆括号<code>()</code>而不是<code>[]</code>和<code>&#123;&#125;</code>内,<strong><code>()</code></strong>时可选的，不是必须，。它们支持任意类型和任意嵌套。元组提供了不可变这一项约束是使用它的原因，否则使用列表。性质总结：</p>
<ul>
<li>元组是位置有序的对象集合，因此支持下标访问，支持分片。</li>
<li>与字符串一样，元组是不可比变的，不能在原处进行修改。因此元组也就是长度不可变的，在不生产一个新对象下不能增长或缩短</li>
<li>元组内的元素可为任意类型且为引用，而不是拷贝，支持任意嵌套</li>
<li>元组不支持任何方法调用，但是支持字符串和列表的一般序列操作：合并、倍乘、分块</li>
</ul>
<p>一般操作： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T=(elements);   <span class="comment">#创建元组</span></span><br><span class="line">T=i,j,k,l		<span class="comment">#省略()创建元组</span></span><br><span class="line">T[j];			<span class="comment">#访问</span></span><br><span class="line">T[i:j];			<span class="comment">#分块</span></span><br><span class="line"><span class="built_in">len</span>(T);			<span class="comment">#长度</span></span><br><span class="line">T1+T2;			<span class="comment">#合并</span></span><br><span class="line">T*<span class="number">3</span>;			<span class="comment">#内容倍乘</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> T:		<span class="comment">#迭代</span></span><br><span class="line">“trlupe<span class="string">r&quot; in T;	#元组内是否有该元素</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></p>
<p>在python3.0以上，有元组的专有调用方法 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index(element);		<span class="comment">#查询元素下标</span></span><br><span class="line">count(element);		<span class="comment">#统计元素出现过几次</span></span><br></pre></td></tr></table></figure></p>
<h4 id="文件">12. 文件</h4>
<p>文件对象提供了python编程对外部文件操作的接口，要创建一个文件对象，就必须调用内置的<code>open</code>函数打开问文件： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file_object=<span class="built_in">open</span>(<span class="string">&quot;*.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure> 除了<code>open</code>这个函数，python还有额外的类文件工具：管道、FIFO、套接字、通过键访问文件、对象吃久、基于描述符的文件、关系数据库等.</p>
<p><strong>文件常用函数接口：</strong></p>
<p><img src="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/file.jpg" width="600"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file_name=<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">lines=file_name.readlines();	<span class="comment">#读取整个文件到列表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><em>注意：</em></strong>在写入时，我们必须将对象转换成字符串，同样在读出时，我们也必须用转换工具将文本文件中的字符串转换乘python对象</p>
<h4 id="python的动态类型">13. python的动态类型</h4>
<h5 id="动态类型是什么">13.1 动态类型是什么</h5>
<p>python的动态类型是为什么在python不必声明变量的存在和类型的缘由。<strong>python使用动态类型和他提供的多态性来提供python语言的简洁灵活的基础。在python中我们是不会声明所使用对象的确切类型的。所谓的python动态类型，就是在程序运行的过程中自动决定对象的类型。</strong></p>
<ul>
<li>与C/C++明显不同的是，在python中，变量只是一个名字，它永远不会有任何类型约束，变量是通用的，在python中类型的概念只存在于对象中。</li>
<li>变量在赋值的时候才创建，即没有声明，当变量出现在表达式中，它会被当前引用的对象所替代，无论该对象是什么类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">就如a=<span class="number">3</span>这个简单的赋值语句，python分步：</span><br><span class="line">	<span class="number">1.</span>创建一个对象代表<span class="number">3</span>，</span><br><span class="line">　　<span class="number">2.</span>如果程序中没有变量a，则创建他。</span><br><span class="line">　　<span class="number">3.</span>将变量与对象<span class="number">3</span>连接起来。</span><br></pre></td></tr></table></figure>
<ul>
<li>变量和对象保存在内存中的不同部分，变量只是对对象的引用，这样来说变量更像是C/C++中的<code>void*</code>指针
<ul>
<li><ol type="1">
<li>变量是系统表的元素，他指向对象存放的地址空间</li>
</ol></li>
<li><ol start="2" type="1">
<li>对象是分配的一块内存，地址可被连接，有足够大空间代表对象的值，每个对象都有两个标准头部信息:一是类型标识符（标识对象类型），二是引用计数器（垃圾回收）。</li>
</ol>
<ul>
<li>2.1 <strong>类型标识符</strong>：对象知道自己的类型，一旦与变量连接，程序执行中也就知道变量是引用了哪种类型的对象。</li>
<li>2.2 <strong>引用计数</strong>：每当对象被引用到一个变量是，其引用计数会+1，反之则-1，当引用计数为0是，该对象的内存空间被自动回收，这种性质很想C++的智能指针<code>shared_ptr</code>，意味着我们在使用过程中不需要考虑对象内存释放的问题.</li>
<li>2.3 引用的过程自动完成变量指向对象地址的过程，即从变量到对象的指针</li>
</ul></li>
</ul></li>
</ul>
<h5 id="共享引用">13.2. 共享引用</h5>
<ul>
<li><p>之前我们就提到过，在python中对象是不可变性的，一旦发生改变便意味这新对象的产生。共享引用也是如此： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">3</span>; <span class="comment">#a指向对象，对象值为3，对象引用为1</span></span><br><span class="line">b=a; <span class="comment">#b也指向该对象，对象引用为2</span></span><br><span class="line">b=b+<span class="number">2</span>; <span class="comment">#产生新对象5，引用计数为1，a所引用的对象仍为3，引用计数为1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>但有一些对象和操作也确实会在原处修改对象，如列表、字典以及一些通过<code>class</code>语句定义的对象，对列表的一个位置进行赋值会改变这个列表对象，而不是生成一个新列表（想想也是，如果每次都有生成一个新列表，那么对于数量极大的列表来说，其消耗的时间是极大的）,如果不想这样，使用<code>copy</code>函数进行拷贝成一个新对象，指向内容相同但内存不同 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#同上面一样创建了新对象42，没有影响原对象</span></span><br><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">L1=L2;</span><br><span class="line">L2=<span class="number">42</span>;</span><br><span class="line"><span class="comment">#原处修改,L1和L2均变为[42,2,3]</span></span><br><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">L1=L2;</span><br><span class="line">L1[<span class="number">0</span>]=<span class="number">42</span>;</span><br><span class="line"><span class="comment">#copy函数防止原处修改，</span></span><br><span class="line"><span class="keyword">import</span> copy;</span><br><span class="line">L2=copy.copy(L1);</span><br></pre></td></tr></table></figure></p></li>
<li><p>共享引用和相等：<code>==操作符</code>，测试两个引用对象值是否相同；<code>is操作符</code>,检查对象的同一性，是否内存地址一样</p></li>
</ul>
<h5 id="引用和拷贝">13.3.引用和拷贝</h5>
<p>到这里，应该知道了引用和拷贝的区别：</p>
<ul>
<li>引用是指变量名指向对象，多个引用都是指向同意内存地址</li>
<li>而拷贝是对原对象的一份拷贝，会在PVM中开辟一份自己的内存地址存储</li>
</ul>
<p>在python中赋值操作总是存储对象的引用，而不是拷贝。如果有些时候我们不希望因多个对象的引用中的改变而造成影响（如上面所举列表例子），那么就应该用拷贝：</p>
<ul>
<li>没有限制条件的分片语句会产生一份拷贝</li>
<li><code>copy</code>方法产生一份拷贝</li>
<li>一些内置函数，如<code>list(L)</code>产生一份拷贝</li>
</ul>
<h4 id="python语句">14. python语句</h4>
<h5 id="与cc完全不同点">14.1 与C/C++完全不同点</h5>
<ul>
<li>python中所有的嵌套语句的首行以<code>:</code>结尾</li>
<li>python中不像C/C++,可省略嵌套语句的<code>()</code>，如<code>if x&gt;y:</code>,如果单条if，则必须加<code>()</code></li>
<li>每个语句最后的<code>;</code>不是必须的，可省略，但是当一行有多条语句用<code>;</code></li>
<li>缩进的结束就是代码块的结束，python没有用<code>&#123;&#125;</code>来标识代码块，而是看缩进</li>
</ul>
<h5 id="赋值和打印">14.2 赋值和打印</h5>
<h6 id="赋值">14.2.1 赋值</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;trluper&quot;</span></span><br><span class="line"><span class="built_in">str</span>,s=<span class="string">&quot;trl&quot;</span>,<span class="string">&quot;uper&quot;</span></span><br><span class="line">a,b,c,d=<span class="string">&#x27;trlu&quot;	#a=&#x27;</span>t<span class="string">&#x27;,b=&#x27;</span><span class="string">r&#x27;,c=&#x27;</span>l<span class="string">&#x27;,d=&#x27;</span><span class="string">u&#x27;</span></span><br><span class="line"><span class="string">a,*b=&quot;trluper&quot; #a=&#x27;</span>t<span class="string">&#x27; b=[&#x27;</span><span class="string">r&#x27;,&#x27;</span>l<span class="string">&#x27;,&#x27;</span><span class="string">u&#x27;,&#x27;</span>p<span class="string">&#x27;,&#x27;</span>e<span class="string">&#x27;,&#x27;</span><span class="string">r&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>在上面的表达式可以看到，<code>*b</code>并不是C/C++中的指针，而是告诉赋值表达式变量<code>b</code>匹配剩下的内容成列表</p>
<h6 id="打印">14.2.2 打印</h6>
<p>python中<code>print</code>的语法:<code>print([object,...][,sep=' '][,end='\n'][,file=sys.stdout]);</code>在表示中，方括号的的项是可选的，且这些参数跟在要打印的对象后面，以<code>name=value</code>形式出现。</p>
<ul>
<li><code>object</code>指要打印的对象</li>
<li><code>sep</code>表示没打印一个对象，都有输出一个空格。(没有显式传递，则默认` `)</li>
<li><code>end</code>表示在打印末尾输出换行符（没有传递就默认<code>\n</code>）</li>
<li><code>file</code>表示要将这些对象输出给文件、标准流还是其他文件对象。(没有显示说明，则默认<code>sys.stdout</code>)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">log=<span class="built_in">open</span>(<span class="string">r&#x27;D:\Python_WorkSpace\test.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;唱&quot;</span>,<span class="string">&quot;跳&quot;</span>,<span class="string">&quot;rap&quot;</span>,<span class="string">&quot;篮球&quot;</span>,sep=<span class="string">&#x27;*&#x27;</span>,end=<span class="string">&#x27;\n&#x27;</span>,file=log);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="python的布尔值">14.3 python的布尔值</h5>
<p>对于python的<code>bool</code>类型来说，其<code>true</code>和<code>false</code>的判断：</p>
<table>
<thead>
<tr class="header">
<th>情况</th>
<th>True/False</th>
<th>情况</th>
<th>True/False</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>none</code></td>
<td><code>F</code></td>
<td>空<code>map&#123;&#125;</code></td>
<td><code>F</code></td>
</tr>
<tr class="even">
<td>数值<code>0</code></td>
<td><code>F</code></td>
<td><code>False</code></td>
<td><code>F</code></td>
</tr>
<tr class="odd">
<td>空序列</td>
<td><code>F</code></td>
<td>对象为空</td>
<td><code>F</code></td>
</tr>
</tbody>
</table>
<h5 id="判断循环语句">14.4 判断循环语句</h5>
<h6 id="ifelifelse">14.4.1 if/elif/else</h6>
<p>python中没有C/C++中的<code>switch case</code>语句块，要做判断选择只有用<code>if</code>语句,在python中没有<code>&#123;&#125;</code>作为语句块边界标识，只能靠左侧的缩进来判断语句属于哪一部分:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a==b <span class="keyword">and</span> c==d <span class="keyword">and</span> d==e):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;相等&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> c==d <span class="keyword">and</span> d==e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;cde相等&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;不相等“)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#三目运算</span></span><br><span class="line"><span class="string">A=Y if X else Z;	#X为真时A=Y,false时为A=Z</span></span><br></pre></td></tr></table></figure>
<h6 id="while语句">14.4.2 while语句</h6>
<p><code>while</code>语句书写格式时：首行以及测试表达式，内部有一行或多行缩进语句主题执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">0</span>;b=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> a&lt;b:</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">    a+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;a不小于b&quot;</span>)</span><br></pre></td></tr></table></figure>
<h6 id="for语句">14.4.3 for语句</h6>
<p><code>for</code>循环不同与c/c++，在python中，它通常是用作序列迭代器，可以遍历任何有序的序列对象内的元素，可用于字符串、列表、元组、其他内置可迭代对象； <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;target&gt; <span class="keyword">in</span> &lt;<span class="built_in">object</span>&gt;:</span><br><span class="line">	&lt;Options&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	&lt;Options&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 当运行<code>for</code>循环时,PVM会将序列对象中的元素赋值給<code>target</code>,然后在循环主题中对其进行操作。<code>for</code>循环的循环变量<code>target</code>可以是任何赋值目标(反正执行完一次后就会重新赋值，引用)。因此<code>for</code>对序列的任意嵌套都能解包。</p>
<h5 id="其他循环">14.5 其他循环</h5>
<h6 id="range函数跳遍历">14.5.1 range函数跳遍历</h6>
<p><code>range函数</code>常用在<code>for循环</code>中用来产生索引，但也可以用在任何需要整数列表的地方。<code>range</code>是一个跌代器，会根据需要产生元素： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">5</span>);	<span class="comment">#生成0，1，2，3，4</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>,<span class="number">5</span>);	<span class="comment">#生成2，3，4</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>); <span class="comment">#生成0，2，4，6，8</span></span><br><span class="line"><span class="comment">#应用,遍历X跳一个输出,其实就是相当与while循环，条件+2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(X),<span class="number">2</span>):</span><br><span class="line">	<span class="built_in">print</span>(X[i],end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure> 根据上面的解释可知：</p>
<ul>
<li>传一个参数时，会产生从0算起的整数，不包括参数值</li>
<li>传两个参数时，第一个为起始值，第二个为最大不包括值</li>
<li>传三个参数时，第三个为步进值</li>
</ul>
<h6 id="并行遍历zip和map">14.5.2 并行遍历zip和map</h6>
<p><strong><code>zip</code>函数</strong>：传而对于<code>zip()</code>，原型是<code>zip(*list)</code>，<code>list</code>是一个列表，<code>zip(*list)</code>返回的是一个元组串，如果要转为元组列表，必须使用<code>list()</code>函数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">L2=[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">L3=<span class="built_in">zip</span>(L1,L2);	<span class="comment">#L3=(1,5),(2,6),(3,7),(4,8)</span></span><br><span class="line">L4=<span class="built_in">list</span>(<span class="built_in">zip</span>(L1,L2)) <span class="comment">#L4=[(1,5),(2,6),(3,7),(4,8)]</span></span><br><span class="line"><span class="comment">#并行遍历</span></span><br><span class="line"><span class="keyword">for</span> (x,y) <span class="keyword">in</span> L3:</span><br><span class="line">	<span class="built_in">print</span>(x,y,<span class="string">&quot;x+y=&quot;</span>,x+y);</span><br><span class="line">a2,b2=<span class="built_in">zip</span>(*<span class="built_in">zip</span>(L1,L2))  <span class="comment">#a2=(1,2,3,4) b2=(5,6,7,8)</span></span><br></pre></td></tr></table></figure> 事实上，<code>zip()</code>可以接受任何类型的序列（就是任何可迭代对象）。</p>
<p><strong><code>map函数</code>:</strong> 对于map()它的原型是<code>map(function,sequence)</code>，就是对序列sequence中每个元素都执行函数function操作.比如之前的<code>a,b,c = map(int,raw_input().split())</code>，意思就是说把输入的<code>a，b，c</code>转化为整数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="built_in">ord</span>,<span class="string">&#x27;spam&#x27;</span>);	<span class="comment">#ord为ascii转换为数字，结果为115，112，97，109</span></span><br></pre></td></tr></table></figure></p>
<h6 id="filter和reduce">14.5.3 filter和reduce</h6>
<p><code>filter</code>和<code>reduce</code>都会返回可迭代对象。在python3.0,需要用<code>list</code>调用来显示其所有结果。<code>filter</code>的作用是基于某一函数的过滤器。<code>reduce</code>是没对元素都应用函数得到最后结果 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>((<span class="keyword">lambda</span> x:x&gt;<span class="number">0</span>),<span class="built_in">range</span>(-<span class="number">5</span>,<span class="number">5</span>)));	<span class="comment">#[1,2,3,4]</span></span><br><span class="line">reduce((<span class="keyword">lambda</span> x,y:x+y),[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);			<span class="comment">#10</span></span><br></pre></td></tr></table></figure></p>
<h4 id="迭代器和解析">15. 迭代器和解析</h4>
<p>在上面提到的for循环和while循环能够处理重复性任务，但是序列迭代在程序中非常常见，因此python提供了额外工具来使得这项工作变得简单高效。</p>
<h5 id="文件迭代器">15.1. 文件迭代器</h5>
<h6 id="next__">15.1.1 <code>__next()__</code></h6>
<p>在文件类中，有一个方法<code>__next__()</code>,该方法每次调用时，就会返回文件的下一行，到达文件末尾时，会抛出StopIteration异常，而不是空字符串。像这样的接口就是python中所说的<strong><em>迭代协议</em></strong>.事实上，任何这类对象都认为时可迭代的，因为它们也能以<code>for循环</code>或其他迭代工具遍历，<strong><em>因为所有迭代工具内部工作原理都是调用<code>__next__()</code>，并且捕捉StopIteration异常来确定何时离开</em></strong></p>
<p><strong><em>迭代协议：Python 迭代协议由<code>__iter__</code>方法与<code>__next__</code>方法构成，若对象具有<code>__iter__</code>方法，称该对象为“可迭代对象（iterable object）”。若对象具有<code>__next__</code>方法，称该对象为“迭代器（iterator）”。<code>__iter__</code>方法必须返回一个迭代器对象，<code>__next__</code>方法不断的返回下一元素，或者抛出StopIteration。<code>__next__</code>方法是 Python 迭代协议的核心.<code>__iter__</code>方法是迭代协议的辅助——将可迭代对象转换成迭代器</em></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		s=file.__next__();</span><br><span class="line">	<span class="keyword">except</span> StopIteration:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="built_in">print</span>(s,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="用for循环推荐">15.1.2 用for循环(推荐)</h6>
<p>读取文本文件的最佳方式就是根本不要去读，其代替的方法就是让for循环每轮自动调用<code>__next__()</code>从而前进到下一行： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>):</span><br><span class="line">	<span class="built_in">print</span>(line,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure> 不建议使用<code>readlines</code>函数，因为<code>readlines</code>时一次性把文件加载到内存，且运行速度不如<code>for循环</code>.</p>
<h6 id="手动迭代">15.1.3 手动迭代</h6>
<p>为了支持手动迭代，python提供了一内置函数<code>next()</code>，他会自动调用一个对象的<code>__next__()</code>函数。即调用<code>next(X)</code>等价于<code>X.__next__()</code>。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s=<span class="built_in">next</span>(file);</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(s,end=<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure> 另一方面，再深一点看，当for循环开始时，通过iter内置函数获得一个迭代器，返回的迭代器对象含有需要的next或<code>__next__()</code>方法 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">it=<span class="built_in">iter</span>(file);	//获取迭代器</span><br><span class="line"><span class="built_in">print</span>(file <span class="keyword">is</span> it);</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s= it.__next__();</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(s,end=<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="字典迭代">15.2. 字典迭代</h5>
<h6 id="获取键值列表再由遍历列表遍历字典">15.2.1 获取键值列表，再由遍历列表遍历字典</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D.keys():</span><br><span class="line">	<span class="built_in">print</span>(key,D[key]);</span><br></pre></td></tr></table></figure>
<h6 id="有字典的迭代器遍历">15.2.2 有字典的迭代器遍历</h6>
<p>字典有一个迭代器，在<strong><em>迭代的环境下（即for循环/while循环）</em></strong>会自动一次返回一个键，这样我们就不必生成键值序列来遍历： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">it=<span class="built_in">iter</span>(D);	<span class="comment">#获得字典的迭代器</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">		<span class="comment">#s=it.__next__();</span></span><br><span class="line">        l=<span class="built_in">next</span>(it);</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(l,D[l]);</span><br><span class="line"></span><br></pre></td></tr></table></figure> 因此可简写for循环：（推荐） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D:</span><br><span class="line">    <span class="built_in">print</span>(key,D[key]);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="其他迭代环境">15.3 其他迭代环境</h5>
<p>上面介绍的迭代环境是在<strong>for循环</strong>看的以及之前讲到过的<strong>列表解析</strong>也有迭代协议。其实，<strong><code>in成员测试</code>、<code>map</code>内置函数以及像<code>sorted</code>（调用后会返回排序后的列表对象）和<code>zip</code>调用这样的内置函数也使用了迭代协议</strong>。<strong><em>当应用于文件时，文件对象的迭代器都自动扫描：</em></strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>.upper,<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>))); <span class="comment">#[&quot;ADC&quot;,&quot;DADA&quot;,&quot;SSDA&quot;]</span></span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>));				<span class="comment">#[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<h4 id="函数">16. 函数</h4>
<p>作为一位C/C++、java程序员，需要了解python函数体系下的函数相关语句和表达式,因为它们有很大的不同点:</p>
<ul>
<li><code>def</code>是可执行代码，python的函数由<code>def</code>语句编写，<strong>函数只有当<code>def</code>运行后才存在，这就意味着不能在函数未运行时就去调用</strong>。</li>
<li><code>def</code>创建了一个对象并将其赋值给某一个变量，即函数名只是函数对象的引用。</li>
<li><code>lambda</code>创建一个对象但将其作为结果返回。使用<code>lambada</code>表达式创建函数，运行将函数定义内联到语法上一条<code>def</code>语句不能工作的地方。</li>
<li><code>yield</code>向调用者发回结果对象，<strong>但会记住它离开的地方</strong></li>
<li><code>global</code>声明了一个模块的变量并被赋值。默认情况下所有在一个函数总被赋值的对象，仅在函数作用域中有效。如要使得它在整个模块中都可使用，函数需要<code>global</code>语句声明</li>
<li><code>nonlocal</code>声明了将要赋值的一个封闭函数变量</li>
</ul>
<h5 id="def">16.1 def</h5>
<p><code>def</code>语句将创建一个函数对象并将其赋值给一个变量名，格式如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(arg1,arg2,arg3,...):</span><br><span class="line">	functions-body;</span><br><span class="line"></span><br></pre></td></tr></table></figure> python中所有语句都是实时运行的，没有像独立编译时间这样的流程。<strong><em>python函数在程序运行之前并不需要全部定义，因为<code>def</code>在运行时评估，而<code>def</code>里面的函数体调用时才评估（与C/C++不同) </em></strong>。一个<code>def</code>语句可以出现在任何地方，比如<code>if</code>,<code>while</code>甚至是<code>def</code>嵌套也是合法的： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> test:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_func</span>():</span><br><span class="line">		....</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_func1</span>():</span><br><span class="line">		....</span><br><span class="line"></span><br><span class="line"><span class="comment">#嵌套</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">	x=<span class="number">99</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">		<span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">			<span class="built_in">print</span>(x);</span><br><span class="line">		f3();	<span class="comment">#调用</span></span><br><span class="line">	f2();		<span class="comment">#调用</span></span><br><span class="line"></span><br><span class="line">f1();</span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：当我<code>def</code>嵌套时，必须在上一层函数调用嵌套函数</p>
<h5 id="python中的多态">16.2 python中的多态</h5>
<p>对于python中函数的作用，会根据传入参数的不同而有些许不同： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">times</span>(<span class="params">x,y</span>):</span><br><span class="line">	<span class="keyword">return</span> x*y;</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">times(<span class="number">2</span>,<span class="number">4</span>);	<span class="comment">#return 8</span></span><br><span class="line">times(<span class="string">&quot;tr&quot;</span>,<span class="number">4</span>);	<span class="comment">#return trtrtrtr</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 可以看到<code>times</code>实现的功能的意义完全依赖于参数<code>x</code>和<code>y</code>的类型，<strong><em>这种依赖类型的行为称为多态</em></strong>。可以说python的动态类型是实现python多态的前提条件。在python这种多头机制下，<strong>编写函数接口更多是为对象编写，而不是特定为一个类型</strong>，这样可以达到函数的复用，提升代码简易和高效性。</p>
<h5 id="作用域">16.3 作用域</h5>
<p>在代码编写过程中，变量可以在三个不同地方辅助，其对应的作用域：</p>
<ul>
<li>变量在一个<code>def</code>赋值，其作用域只在该函数有效</li>
<li>变量在<code>def</code>之外赋值，从赋值地方开始到文件结尾都有效</li>
<li>变量在嵌套<code>def</code>内，只在内层<code>def</code>内有效</li>
</ul>
<h6 id="作用域法则">16.3.1 作用域法则</h6>
<ol type="1">
<li>全局作用域的作用范围仅限单个文件。要是有其他模块的变量名，必须导入模块</li>
<li>导入模块的作用域是全局的</li>
<li>每次函数调用都创建一个新的本地作用域</li>
<li>在函数赋值的变量名除非声明为<code>global</code>或者<code>nonlocal</code>变量，否则默认为本地变量。<code>global</code>将位于函数内的变量变为全局（位于模块文件内部的顶部），<code>nonlocal</code>将嵌套函数内的变量声明为非本地</li>
<li>python执行过程变量搜索路径：<code>本地作用域--&gt;上一层结构def或lambda的本地作用域--&gt;全局作用域--&gt;内置作用域</code></li>
</ol>
<h6 id="global">16.3.2 global</h6>
<p><code>global</code>不是一个类型或者大小的声明，而是<strong><em>命名空间的声明</em></strong>，它告诉编译器python函数打算生成一个或多个全局变量名 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用法1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_func</span>(<span class="params">x,y</span>):</span><br><span class="line">	<span class="keyword">global</span> z;</span><br><span class="line">	z=x+y;</span><br><span class="line">func(<span class="number">2</span>,<span class="number">4</span>)；</span><br><span class="line"><span class="built_in">print</span>(z);	<span class="comment">#输出6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用法2，告诉函数x不是本地的，而是全局的（主要用法：将在函数内修改的全局变量保存）</span></span><br><span class="line">x=<span class="number">22</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">   <span class="keyword">global</span> x;</span><br><span class="line">   x=<span class="number">99</span></span><br><span class="line">f1();</span><br><span class="line"><span class="built_in">print</span>(x);	<span class="comment">#输出99</span></span><br></pre></td></tr></table></figure></p>
<h6 id="nonlocal">16.3.3 nonlocal</h6>
<p>与<code>global</code>一样，<code>nonlocal</code>也是将变量在嵌套作用中的修改保存下来。与<code>global</code>不同之处在于：<code>global</code>是对<code>def</code>之外的全局变量作用，而<code>nonlocal</code>更严格，是对嵌套的的变量，这样达到能够使内层嵌套对变量的修改能够保存。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_func1</span>(<span class="params">a,<span class="built_in">str</span></span>):</span><br><span class="line">	x=a;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">		<span class="keyword">nonlocal</span> x</span><br><span class="line">		x+=<span class="number">20</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">str</span>,x);	<span class="comment">#这是一个nonlocal测试 21</span></span><br><span class="line">	_f(<span class="built_in">str</span>);</span><br><span class="line">	<span class="built_in">print</span>(x);			<span class="comment">#21</span></span><br><span class="line"></span><br><span class="line">_func1(<span class="number">1</span>,<span class="string">&quot;这是一个nonlocal测试&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="参数">17. 参数</h4>
<h5 id="引用传递">17.1 引用传递</h5>
<p>要努力区别python的传参机制和C++引用参数，对于python来说：</p>
<ul>
<li><strong>不可变参数通过“值”传递，虽然像整数、字符串这些是通过对象的引用进行传递的，但是它们的不可变性导致我们不可能在原处改变，一旦执行给变量赋新值，意味这新对象产生，变量只是新对象的一份引用。</strong>（这样来看它的效果其实就是C++中的按值传递，即发生了一份拷贝）</li>
<li><strong>可变对象时通过“指针”进行传递的。虽然列表、字典这样的对象实际上也是通过引用来传递，但效果却和不可变参数完全不同，因为它们支持原处修改，因此函数内发生的改变能够保存。</strong>（这就像C++中传递数组很像）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">2</span>;</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x</span>):</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">isinstance</span>(x,<span class="built_in">list</span>):</span><br><span class="line">		x[<span class="number">0</span>]=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">	<span class="keyword">elif</span> <span class="built_in">isinstance</span>(x,numbers.Number):</span><br><span class="line">		x=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">test(a);</span><br><span class="line"><span class="built_in">print</span>(a);	<span class="comment">#2</span></span><br><span class="line">test(b);</span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#[20,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>python通过引用来传参，意味着我们不需要进行多余的拷贝操作，能够节约内存和运行时间，同时也就支持可传递很大对象。如果我们要抑制因传入可变参数而带来的修改，可以在传入时拷贝一份作为参数<code>test(copy(b));</code></p>
<h5 id="返回值">17.2 返回值</h5>
<p><code>return</code>语句能够返回任意种类对象，所有也能够返回多个值（指的是封装进元组或列表这样的集合里）： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">	x=<span class="number">2</span>;</span><br><span class="line">	y=[<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">return</span> x,y;</span><br><span class="line"></span><br><span class="line">l=func();	<span class="comment">#(2,[3,4])</span></span><br></pre></td></tr></table></figure> 上面的函数返回了元组(2,[3,4])。（因为元组的<code>()</code>不是必须的）</p>
<h5 id="参数匹配模型">17.3 参数匹配模型</h5>
<p>这些匹配模型的底层传参机制仍有是引用赋值：</p>
<ul>
<li>位置参数：默认模式，通过从左到右参数匹配(位置：调用者)</li>
<li>关键字参数；设置传参默认值，<code>name=value</code>形式，意思是当我们执行从左到右匹配，发现某参数没有传入，则调用时使用默认值(位置：被调函数)</li>
<li>关键字参数：<code>name=value</code>还可以指定我们调用时参数传递给哪一个参数变量，破环了默认模式，即不必遵循从左到右匹配，而是按名字匹配,如<code>print(&quot;trluper&quot;,sep=' ',end=' ',file=sys,stdout);</code>（位置：调用者）</li>
<li>可变参数列表，在函数的参数中有<code>*</code>号，意味着该函数支持可变参数列表，即支持传递任意个参数。单个<code>*</code>指对元组，<code>**</code>是对字典,<strong>即指在调用的时候我们传递给函数的参数会被打包参数位置信息的元组序列或者字典对象</strong>，对函数来说它会解包</li>
</ul>
<p>示例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#位置参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,c</span>):</span><br><span class="line">	<span class="built_in">print</span>(a,b,c);</span><br><span class="line"><span class="comment">#关键字参数name=value形式调用</span></span><br><span class="line">f(a=<span class="number">2</span>,c=<span class="number">3</span>,b=<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#关键字参数,设置默认值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name=<span class="string">&#x27;Bob&#x27;</span>,age=<span class="string">&#x27;&#x27;</span>,jov=<span class="string">&#x27;engineer&#x27;</span></span>):</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line"><span class="comment">#*</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">*args</span>):</span><br><span class="line">	<span class="built_in">print</span>(args);</span><br><span class="line"><span class="comment">#调用时打包成元组</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)		<span class="comment">#(1,2,3,4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#**只对关键字参数有效，将关键字参数打包成字典</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">**args</span>):</span><br><span class="line">	<span class="built_in">print</span>(args);</span><br><span class="line">f(a=<span class="number">1</span>,b=<span class="number">2</span>);		<span class="comment">#&#123;&#x27;a&#x27;=1,&#x27;b&#x27;=2&#125;</span></span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：如要函数要混用这些模式，则顺序必须是<code>位置参数-&gt;关键字参数-&gt;*-&gt;**</code></p>
<h4 id="函数的高级话题">18. 函数的高级话题</h4>
<p>学习了函数，我们就必须要了解如何使函数聚合性更强，解耦合性能更好，设计函数的功能性。</p>
<h5 id="递归函数">18.1 递归函数</h5>
<p>较循环结构而言，对任意深度的嵌套，循环较难处理，而递归能够容易处理该类嵌套： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#能够处理任意嵌套</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L:<span class="string">&quot;可以是列表也可是元组&quot;</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">		<span class="keyword">if</span>  <span class="built_in">isinstance</span>(x,<span class="built_in">list</span>):</span><br><span class="line">			tot+=sumtree(x);</span><br><span class="line">		<span class="keyword">elif</span>  <span class="built_in">isinstance</span>(x,<span class="type">Tuple</span>):</span><br><span class="line">			tot+=sumtree(x);</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			tot+=x;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sumtree([<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],(<span class="number">3</span>,<span class="number">4</span>),<span class="number">5</span>,[<span class="number">7</span>,<span class="number">8</span>,[<span class="number">2</span>,<span class="number">3</span>]]])); <span class="comment">#38</span></span><br></pre></td></tr></table></figure></p>
<h5 id="属性存储和注解">18.2 属性存储和注解</h5>
<p>由于python函数是对象，函数对象可以赋值给其他的变量名、传递给其他函数、嵌入到数据结构、从一个函数返回给另一个函数等等。</p>
<h6 id="属性">18.2.1 属性</h6>
<p>函数除了调用以外，我们还可以检查它的<strong>属性</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(sumtree.__name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(sumtree));</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sumtree</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__call__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__closure__&#x27;</span>, <span class="string">&#x27;__code__&#x27;</span>, <span class="string">&#x27;__defaults__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__get__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__globals__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__kwdefaults__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<h6 id="注解">18.2.2 注解</h6>
<p>python3.0以后，可以给函数对象附加注解信息---就是与函数的参数和结果相关的任意用户定义的数据。注解有它专有的语法，但它自身不做任何事情，注解是可选的，并且出现的时候只是直接附加在函数对象的<code>__annotations__</code>属性以供其他用户使用。语法：</p>
<ul>
<li>函数注解编写在def行</li>
<li>对于参数，它们出现在紧随参数名冒号的后面</li>
<li>对于返回值，它们编写于参数列表之后的<code>-&gt;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L:<span class="string">&quot;可以是列表也可是元组&quot;</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sumtree.__annotations__);	<span class="comment">#&#123;&#x27;L&#x27;: &#x27;可以是列表也可是元组&#x27;, &#x27;return&#x27;: &lt;class &#x27;int&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="lambda表达式">18.3. lambda表达式</h5>
<p>除了<code>def</code>之外，python提供了另一种函数对象的表达式，叫<code>lambada</code>也称匿名函数。这个表达式创建了一个之后能够调用的函数，但是它返回一个函数而不是将这个函数赋值给一个变量名，这也是为啥lambda叫匿名函数。</p>
<h6 id="lambda表达式格式">18.3.1 lambda表达式格式</h6>
<p>关键字lambda后面接参数列表，<code>:</code>后面为函数体 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arg1,rag2,...:</span><br><span class="line">	function_body;</span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong></p>
<ul>
<li>lambda是一个表达式，而不是语句。因为是一个表达式，所有它能出现在<code>def</code>不能出现的地方，如列表中、或者函数参数中等。同时它会返回一个新函数对象，我们可以选择性的将对象赋值给一个变量，方便操作。</li>
<li>lambda的主体是一个单个的表达式，而不是一个代码块。因为lambda是为编写简单函数而设计的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_test</span>(<span class="params">L,cmp=<span class="keyword">lambda</span> x,y:x&gt;y</span>):</span><br><span class="line">	a=L[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> e <span class="keyword">in</span> L[<span class="number">1</span>:]:</span><br><span class="line">		<span class="keyword">if</span> cmp(a,e):</span><br><span class="line">			a=e;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">min_test([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>])		<span class="comment">#0</span></span><br></pre></td></tr></table></figure>
<h4 id="深入理解迭代和解析">19深入理解迭代和解析</h4>
<h5 id="重访迭代器生成器">19.1 重访迭代器：生成器</h5>
<p>python对延迟提供了更多的支持，有两种方法尽可能延迟结果创建：</p>
<ul>
<li><strong>生成器函数</strong>：编写为常规的<code>def</code>，但是使用<code>yield</code>一次返回一个结果，在每个结果之间挂起和继续它们的状态</li>
<li><strong>生成器表达式</strong>：类似于列表解析，但是它们的返回是按需产生结果对象，而不是像列表解析一样构建一新列表</li>
</ul>
<p>由于二者都不会创建列表，因此节省了内存空间，并且允许计算时间分散到各个结果请求。</p>
<h6 id="生成器函数">19.1.1 生成器函数</h6>
<p><strong>一个送回一个值并随后从退出的地方继续的函数就叫生成器函数</strong>。<strong><em>生成器函数</em></strong>与常规函数的不同点主要在于：</p>
<ul>
<li>生成器函数自动在生成值的时刻挂起，在挂起时要保存函数的状态。</li>
<li>生成器函数代码不同是生成器<code>yield</code>一个值，而不是<code>return</code>，从该角度来看，允许生成器函数随时间产生一系列值</li>
</ul>
<p><strong>1 迭代协议</strong></p>
<p>要理解生成器，必须了解<strong>迭代协议</strong>。可迭代的对象定义了一个<code>__next__</code>方法，要么返回迭代中的下一项，要么抛出<code>StopIteration</code>异常终止迭代。一个对象的迭代器用<code>iter</code>内置函数接受。如果支持该协议，则<code>for</code>循环和其他迭代语句，使用这种迭代协议来遍历一个序列或者生成器；若不支持，迭代返回去重复序列。</p>
<p><strong>2 生成器：</strong></p>
<p>生成器函数要支持该协议，就必须得包含一条<code>yiled</code>语句，该语句被编译为生成器，一旦调用这条语句就会返回一个迭代对象，该对象支持用一个<code>__next__()</code>函数来继续执行该生成器函数接口。要终止生成器函数，可以在生成器函数末尾有一条<code>return</code>语句，终止生成，也可以引发一个<code>StopIteration</code>异常终止。<strong><em>简而言之，编写了包含<code>yiled</code>的函数称为生成器函数，<code>yield</code>语句为生成器，自动的支持迭代协议</em></strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">L</span>):</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">		<span class="keyword">yield</span> i**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]));		<span class="comment">#&lt;generator object func at 0x000001FB7F4AB450&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]):	<span class="comment">#1，4，9，16</span></span><br><span class="line">	<span class="built_in">print</span>(i);</span><br></pre></td></tr></table></figure> 从上面程序可以看到，调用一个生成器函数会返回一个生成器对象，它支持迭代协议，即生成器对象有一个<code>__next__()</code>方法，它可以开始这个函数，或者从它上一次<code>yield</code>值后的地方恢复，并且得到一系列的值，到最后一个时，产生<code>StopIteration</code>异常。</p>
<p><strong>3 扩展生成器函数协议send和next</strong></p>
<p>生成器函数协议增加了一个<code>send()</code>函数，<code>send()</code>函数生成一系列结果的下一个元素，这一点像<code>__next__()</code>,但是它提供了一种调用者与生成器之间的通信。当使用这一额外协议时，值可以通过调用<code>G.send(value)</code>发生给一个生成器 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g=func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="literal">None</span>));</span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<h6 id="生成器表达式">19.1.2 生成器表达式</h6>
<p>生成器表达式其实跟列表解析相似，区别就是列表解析是在<code>[]</code>内，而生成器表达式是在<code>()</code>内： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列表解析</span></span><br><span class="line">[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]; <span class="comment">#[0,1,4,9]</span></span><br><span class="line"><span class="comment">#生成器表达式</span></span><br><span class="line">G=(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))	<span class="comment">#generator</span></span><br><span class="line">G.__next__();</span><br><span class="line"><span class="comment">#for循环自动迭代</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span>(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)):</span><br><span class="line">	<span class="built_in">print</span>(num);</span><br></pre></td></tr></table></figure> 从上面可知道，生成器表达式很不同，不是在内存种构建结果，而是返回一个生成器对象，这个对象将会支持迭代协议并在任意迭代语境的操作。</p>
<p><strong>1 生成器是单迭代对象</strong></p>
<p>无论是生成器函数还是生成器表达式，都只支持一次活跃迭代，即不能在不同位置的有自己的迭代器： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G=(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">iter_1=<span class="built_in">iter</span>(G);</span><br><span class="line">iter_1.__next__();		<span class="comment">#0</span></span><br><span class="line">iter_2=<span class="built_in">iter</span>(G);</span><br><span class="line">iter_2.__next_();		<span class="comment">#1</span></span><br></pre></td></tr></table></figure> 如上，两个迭代器总是在同一位置，即只能有一个活跃的迭代器</p>
<p><strong>2. 编写自己的map和zip</strong></p>
<p><strong>mymap</strong>: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mymap</span>(<span class="params">func,*seqs</span>):</span><br><span class="line">	<span class="keyword">return</span> [func(*args) <span class="keyword">for</span> args <span class="keyword">in</span> <span class="built_in">zip</span>(*seqs)]</span><br><span class="line"><span class="built_in">print</span>(mymap(<span class="built_in">pow</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)));</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">16</span>, <span class="number">243</span>, <span class="number">4096</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>myzip</strong>: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myzip</span>(<span class="params">func,*seqs</span>):</span><br><span class="line">	seqs=[<span class="built_in">list</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> seqs];</span><br><span class="line">	res=[];</span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">all</span>(seqs):</span><br><span class="line">		res.append(<span class="built_in">tuple</span>(s.pop(<span class="number">0</span>)<span class="keyword">for</span> s <span class="keyword">in</span> seqs));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="解析语法概况">19.2. 解析语法概况</h5>
<p>除了列表解析以外，python3.0还增加了集合解析和字典解析： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列表解析</span></span><br><span class="line">[f(x) <span class="keyword">for</span> x <span class="keyword">in</span> S]</span><br><span class="line"><span class="comment">#集合解析</span></span><br><span class="line">&#123;f(x) <span class="keyword">for</span> x <span class="keyword">in</span> S&#125;</span><br><span class="line"><span class="comment">#字典解析</span></span><br><span class="line">&#123;key:val <span class="keyword">for</span> (key,val) <span class="keyword">in</span> <span class="built_in">zip</span>(keys,vals)&#125;</span><br><span class="line"><span class="comment">#生成器表达式</span></span><br><span class="line">(x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br></pre></td></tr></table></figure></p>
<h4 id="模块">20. 模块</h4>
<p>模块是将程序代码和数据封装起来以方便重用，其实模块就相当于是一个命名空间。模块由两个语句和一个终于的内置函数进行处理：</p>
<ul>
<li><code>import</code>:让用户导入一个模块</li>
<li><code>from</code>:允许用户从以模块文件获取特定变量名</li>
<li><code>imp.reload</code>:在不终止python程序下，提供重新载入模块文件代码的方法.</li>
</ul>
<h5 id="import工作机制">20.1 import工作机制</h5>
<p>乍一看，我们都会认为python的<code>import</code>很像C/C++的<code>#include&lt;&gt;</code>，但是并不是完全一样，首先一点就是在导入时模块就已经运行了，即一旦<code>import a</code>模块，<code>a</code>模块里面的代码就会执行，如果<code>a</code>模块内有<code>print</code>语句的话就会输出。而<code>C</code>会在预处理阶段将头文件展开，同内部代码一样，执行<code>预处理编译--&gt;汇编--&gt;链接</code>过程</p>
<p><strong>import的三个过程：</strong></p>
<p><strong>1. 找到模块文件</strong></p>
<p>在执行钱必须找到模块文件所在的位置，导入是简单的<code>import a</code>，没有路径，也没有加后缀<code>.py</code>,因为python使用<strong>==标准模块搜索路径==</strong></p>
<p><strong>2. 编译成字节码（如果需要）</strong></p>
<p>python会检查模块文件的时间戳，当发现字节码即后缀为<code>.pyc</code>的文件比源代码<code>.py</code>旧，就会重新编译成<code>.pyc</code>文件，覆盖原字节码文件，反之，则不。若在搜索时只有<code>.pyc</code>文件，没有<code>.py</code>文件，直接加载<code>.pyc</code>文件。通过这些算法方式来提高程序启动速度。（<strong><em>注意</em></strong>：只有被导入的文件才会有<code>.pyc</code>文件） <strong><em>注意</em></strong>：因此多次在一个顶层模块导入模块，导入操作只会执行一次，因为已经生成了最新的<code>.pyc</code>文件</p>
<p><strong>3. 执行模块代码来创建其所定义的对象</strong></p>
<p>最后一步执行，不多说</p>
<h5 id="标准模块搜索路径">20.2.标准模块搜索路径</h5>
<p>大多数情况下，可以说依赖导入模块的搜索路径的自动特性，完全不要要配置路径。要配置你自己的路径，必须了解模块搜索路径的四个组件：</p>
<ul>
<li>程序主目录</li>
<li>pythonPATH(如果已经设置)</li>
<li>标准链接库目录</li>
<li>任何.pth文件内容</li>
</ul>
<p>这四个组件组合起来就变成了<code>sys.path</code>。第一个和第三个是自动定义，以及固定了，第二和第四个就可以用来扩展路径，从而包含你自己的外部源代码。</p>
<h5 id="import和from">20.3 import和from</h5>
<p>格式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line"><span class="keyword">from</span> simple <span class="keyword">import</span> x,y</span><br><span class="line">x=<span class="number">42</span>;</span><br></pre></td></tr></table></figure> 在交互的模式下对<code>x</code>赋值运输,只会修改作用域内的变量x，而不是这个文件内的x，以from复制而来的变量名和其来源的文件之间没有联系，如果要修改，应该用<code>import</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line">simple.x=<span class="number">42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="命名空间">20.4 命名空间</h5>
<p>在模块的文件顶层（也就是不在函数或类的主体内）每一个赋值的变量名都会变成该模块的属性。我么们可以在模块外以<code>simple.x</code>对其属性进行引用。</p>
<h6 id="模块加载和作用域">20.4.1 模块加载和作用域</h6>
<ul>
<li><strong>模块语句会在首次导入时执行</strong>：模块第一次导入无论在什么地方，<strong>都会建立空的模块对象，并逐一执行模块文件内的语句</strong></li>
<li>顶层的赋值语句创建模块属性（如def,=)</li>
<li>模块的命名空间能够通过属性<code>__dict__</code>或<code>dir(simple)</code>获得</li>
<li>模块是一个独立的作用域（本地变量就是全局变量）：模板自己成立一个作用域，但是它的变量可看作全局变量，文件内都可使用</li>
</ul>
<h6 id="进行导入操作的文件的与被导入的文件的关系">20.4.2 进行导入操作的文件的与被导入的文件的关系</h6>
<p>导入操作不会赋予被导入文件种的代码对上层代码的可见度：即被导入文件无法看见进行导入操作的文件内的变量名 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#modeA.py</span></span><br><span class="line">x=<span class="number">88</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">	gloabal x;</span><br><span class="line">	x=<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#modeB.py</span></span><br><span class="line"><span class="keyword">import</span> modeA</span><br><span class="line">x=<span class="number">11</span>;</span><br><span class="line">modeA.f()</span><br><span class="line"><span class="built_in">print</span>(x,modeA.x);	<span class="comment">#11 99</span></span><br></pre></td></tr></table></figure> 总结来说：</p>
<ul>
<li>函数绝对无法看见其他函数内的变量名，除非它们是嵌套的</li>
<li>模块程序代码绝对无法看见其他模块的变量名，除非明确进行了变量导入</li>
</ul>
<h6 id="模块重载">20.4.3 模块重载</h6>
<p>我们之前提到，模块导入只会执行一次，要强制模块代码重新载入并执行，得要调用<code>reload</code>内置函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line">reload(simple);		<span class="comment">#重载模块</span></span><br></pre></td></tr></table></figure> 重载模块有几个<strong><em>注意点：</em></strong></p>
<ul>
<li><code>reload</code>会在模块当前命名空间内执行模块文件的新代码</li>
<li>重载会影响所有使用import读取的模块属性</li>
<li>重载只会以后对以后使用from的造成影响</li>
</ul>
<h4 id="内置函数">21 内置函数</h4>
<p>python内部内置了丰富的函数供开发者调用，下面进行简单的介绍。</p>
<h5 id="数学函数">21.1 数学函数</h5>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>abs(x)</code></td>
<td>返回数字的绝对值，如<code>abs(-10)</code>返回 10</td>
</tr>
<tr class="even">
<td><code>ceil(x)</code></td>
<td>返回数字的上入整数，如<code>math.ceil(4.1)</code> 返回 5</td>
</tr>
<tr class="odd">
<td><code>cmp(x, y)</code></td>
<td>如果 <code>x &lt; y</code> 返回 -1, 如果 <code>x == y</code> 返回 0, 如果 <code>x &gt; y</code> 返回 1</td>
</tr>
<tr class="even">
<td><code>exp(x)</code></td>
<td>返回e的x次幂(ex),如<code>math.exp(1)</code> 返回2.718281828459045</td>
</tr>
<tr class="odd">
<td><code>fabs(x)</code></td>
<td>返回数字的绝对值，如<code>math.fabs(-10)</code> 返回10.0</td>
</tr>
<tr class="even">
<td><code>floor(x)</code></td>
<td>返回数字的下舍整数，如<code>math.floor(4.9)</code>返回 4</td>
</tr>
<tr class="odd">
<td><code>log(x)</code></td>
<td>如<code>math.log(math.e)</code>返回1.0,<code>math.log(100,10)</code>返回2.0</td>
</tr>
<tr class="even">
<td><code>log10(x)</code></td>
<td>返回以10为基数的x的对数，如<code>math.log10(100)</code>返回 2.0</td>
</tr>
<tr class="odd">
<td><code>max(x1, x2,...)</code></td>
<td>返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr class="even">
<td><code>min(x1, x2,...)</code></td>
<td>返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr class="odd">
<td><code>modf(x)</code></td>
<td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr class="even">
<td><code>pow(x, y)</code></td>
<td>x**y 运算后的值。</td>
</tr>
<tr class="odd">
<td><code>round(x [,n])</code></td>
<td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td>
</tr>
<tr class="even">
<td><code>sqrt(x)</code></td>
<td>返回数字x的平方根</td>
</tr>
</tbody>
</table>
<h5 id="内置函数-1">21.2 内置函数</h5>
<p>这里列举一些简单内置函数列表，不做例子解释：</p>
<table>
<colgroup>
<col style="width: 5%">
<col style="width: 94%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>abs()</code></td>
<td><code>abs()</code>函数返回数字的绝对值</td>
</tr>
<tr class="even">
<td><code>all()</code></td>
<td><code>all()</code>函数用于判断给定的可迭代参数<code>iterable</code>中的所有元素是否都为<code>TRUE</code>，如果是返回 <code>True</code>，否则返回<code>False</code>.元素除了<code>0、空、None、False</code>外都算 True</td>
</tr>
<tr class="odd">
<td><code>any()</code></td>
<td><code>any()</code>函数用于判断给定的可迭代参数<code>iterable</code>是否全部为<code>False</code>，则返回<code>False</code>，如果有一个为<code>True</code>，则返回<code>True</code>。元素除了是<code>0、空、FALSE 外都算 TRUE</code>。</td>
</tr>
<tr class="even">
<td><code>bin()</code></td>
<td><code>bin()</code>返回一个整数 <code>int</code> 或者长整数 <code>long int</code> 的二进制表示</td>
</tr>
<tr class="odd">
<td><code>bool()</code></td>
<td><code>bool()</code> 函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。</td>
</tr>
<tr class="even">
<td><code>bytearray()</code></td>
<td><code>bytearray()</code>方法返回一个新字节数组。这个数组里的元素是可变的，并且每个元素的值范围</td>
</tr>
<tr class="odd">
<td><code>callable()</code></td>
<td>函数用于检查一个对象是否是可调用的。如果返回<code>True</code>，<code>object</code>仍然可能调用失败；但如果返回<code>False</code>，调用对象<code>object</code>绝对不会成功。</td>
</tr>
<tr class="even">
<td><code>chr()</code></td>
<td><code>chr()</code>用一个范围在 <code>range（256）</code>内的（就是0～255）整数作参数，返回一个对应的字符</td>
</tr>
<tr class="odd">
<td><code>classmethod修饰符</code></td>
<td><code>classmethod</code> 修饰符对应的函数不需要实例化，不需要 <code>self</code> 参数，但第一个参数需要是表示自身类的 <code>cls</code> 参数，可以来调用类的属性，类的方法，实例化对象等。</td>
</tr>
<tr class="even">
<td><code>cmp()</code></td>
<td>cmp(x,y) 函数用于比较2个对象，如果 <code>x &lt; y</code> 返回 -1, 如果<code>x == y</code>返回 0, 如果 <code>x &gt; y</code>返回 1</td>
</tr>
<tr class="odd">
<td><code>delattr()</code></td>
<td>删除属性,<code>delattr(x, 'foobar')</code> 相等于 <code>del x.foobar</code></td>
</tr>
<tr class="even">
<td><code>dir()</code></td>
<td><code>dir()</code>函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表</td>
</tr>
<tr class="odd">
<td><code>divmod()</code></td>
<td>把除数和余数运算结果结合起来，返回一个包含商和余数的元组<code>(a / b, a % b)</code></td>
</tr>
<tr class="even">
<td><code>execfile()</code></td>
<td>函数可以用来执行一个文件</td>
</tr>
<tr class="odd">
<td><code>file()</code></td>
<td><code>file()</code>函数用于创建一个 file 对象，它有一个别名叫<code>open()</code>，更形象一些，它们是内置函数。参数是以字符串的形式传递的</td>
</tr>
<tr class="even">
<td><code>float()</code></td>
<td><code>float()</code>函数用于将整数和字符串转换成浮点数。</td>
</tr>
<tr class="odd">
<td><code>frozenset()</code></td>
<td>返回一个冻结的集合，冻结后集合不能再添加或删除任何元素，即不可变</td>
</tr>
<tr class="even">
<td><code>getattr()</code></td>
<td>返回一个对象的属性值</td>
</tr>
<tr class="odd">
<td><code>globals()</code></td>
<td><code>globals()</code>函数会以字典类型返回当前位置的全部全局变量</td>
</tr>
<tr class="even">
<td><code>hasattr()</code></td>
<td><code>hasattr()</code>函数用于判断对象是否包含对应的属性</td>
</tr>
<tr class="odd">
<td><code>hash()</code></td>
<td><code>hash()</code>用于获取取一个对象（字符串或者数值等）的哈希值</td>
</tr>
<tr class="even">
<td><code>help()</code></td>
<td><code>help()</code> 函数用于查看函数或模块用途的详细说明</td>
</tr>
<tr class="odd">
<td><code>hex()</code></td>
<td><code>hex()</code> 函数用于将10进制整数转换成16进制，以字符串形式表示</td>
</tr>
<tr class="even">
<td><code>id()</code></td>
<td><code>id()</code>函数返回对象的唯一标识符，标识符是一个整数</td>
</tr>
<tr class="odd">
<td><code>input()</code></td>
<td>标准输入流，接受一个标准输入数据，返回为 string 类型</td>
</tr>
<tr class="even">
<td><code>int()</code></td>
<td>将一个字符串或数字转换为整型</td>
</tr>
<tr class="odd">
<td><code>iter()</code></td>
<td><code>iter()</code>函数用来生成迭代器</td>
</tr>
<tr class="even">
<td><code>len</code></td>
<td><code>len()</code>方法返回对象（字符、列表、元组等）长度或项目个数</td>
</tr>
<tr class="odd">
<td><code>locals()</code></td>
<td><code>locals()</code>函数会以字典类型返回当前位置的全部局部变量</td>
</tr>
<tr class="even">
<td><code>next()</code></td>
<td><code>next()</code>返回迭代器的下一个项目,该函数于<code>iter()</code>配套使用</td>
</tr>
<tr class="odd">
<td><code>open()</code></td>
<td><code>open()</code>函数用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 <code>OSError</code></td>
</tr>
<tr class="even">
<td><code>ord()</code></td>
<td>该函数是<code>chr()</code>函数（对于 8 位的 ASCII 字符串）的配对函数，它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。</td>
</tr>
<tr class="odd">
<td><code>pow(x,y)</code></td>
<td>指数计算，返回<span class="math display">\[$x^y\]</span>$</td>
</tr>
<tr class="even">
<td><code>round()</code></td>
<td>返回浮点数 x 的四舍五入值，准确的说保留值将保留到离上一位更近的一端（四舍六入）</td>
</tr>
<tr class="odd">
<td><code>sorted()</code></td>
<td>对所有可迭代的对象进行排序操作</td>
</tr>
<tr class="even">
<td><code>str()</code></td>
<td>返回一个对象的<code>string</code>格式,将对象转化为适于人阅读的形式</td>
</tr>
</tbody>
</table>
<h6 id="compile函数">21.2.1 compile()函数</h6>
<p>compile() 函数将一个字符串编译为字节代码，格式如下: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">compile</span>(source, filename, mode[, flags[, dont_inherit]])</span><br></pre></td></tr></table></figure> - <code>source</code>：字符串或者AST（Abstract Syntax Trees）对象。。 - <code>filename</code>：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。 - <code>mode</code> ：指定编译代码的种类。可以指定为 exec, eval, single。 - <code>flags</code> ：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。。 - <code>flags和dont_inherit</code>是用来控制编译源码时的标志</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">str</span> = <span class="string">&quot;for i in range(0,10): print(i)&quot;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">compile</span>(<span class="built_in">str</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;exec&#x27;</span>)   <span class="comment"># 编译为字节代码对象 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;code <span class="built_in">object</span> &lt;module&gt; at <span class="number">0x10141e0b0</span>, file <span class="string">&quot;&quot;</span>, line <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">exec</span>(c)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h6 id="complex函数">21.2.2 complex()函数</h6>
<p><code>complex()</code>函数用于创建一个值为<code>real + imag * j</code>的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span>(<span class="number">1</span>)    <span class="comment"># 数字，结果为(1 + 0j)</span></span><br><span class="line"><span class="built_in">complex</span>(<span class="string">&quot;1&quot;</span>)  <span class="comment"># 当做字符串处理，结果为(1 + 0j)</span></span><br></pre></td></tr></table></figure></p>
<h6 id="dict函数">21.2.3 dict()函数</h6>
<p>dict() 函数用于创建一个字典。有四种接口来创建字典 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>()                        # 创建空字典</span><br><span class="line"><span class="built_in">dict</span>(a=<span class="string">&#x27;a&#x27;</span>, b=<span class="string">&#x27;b&#x27;</span>, t=<span class="string">&#x27;t&#x27;</span>)     # 传入关键字</span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))   # 映射函数方式来构造字典</span><br><span class="line"><span class="built_in">dict</span>([(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])    # 可迭代对象方式来构造字典</span><br></pre></td></tr></table></figure></p>
<h6 id="enumerate函数">21.2.4 enumerate()函数</h6>
<p><code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#形式</span></span><br><span class="line"><span class="built_in">enumerate</span>(sequence, [start=<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line">seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons))   <span class="comment">#[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>))       <span class="comment"># 小标从 1 开始[(1, &#x27;Spring&#x27;), (2, &#x27;Summer&#x27;), (3, &#x27;Fall&#x27;), (4, &#x27;Winter&#x27;)]</span></span><br></pre></td></tr></table></figure></p>
<h6 id="eval函数">21.2.5 eval()函数</h6>
<p><code>eval()</code>函数用来执行一个字符串表达式，并返回表达式的值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line"><span class="built_in">eval</span>( <span class="string">&#x27;3 * x&#x27;</span> )		#<span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<h6 id="filter函数">21.2.6 filter()函数</h6>
<p><code>filter()</code>函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。<strong>接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 <code>True</code> 或 <code>False</code>，最后将返回 <code>True</code> 的元素放到新列表中。</strong></p>
<blockquote>
<p>注意: Python2.7 返回列表，Python3.x 返回迭代器对象，具体内容可以查看：Python3 filter() 函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">    return n % <span class="number">2</span> =</span>= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">newlist = <span class="built_in">filter</span>(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(newlist) #[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h6 id="format-格式化函数">21.2.7 format 格式化函数</h6>
<p>Python2.6 开始，新增了一种格式化字符串的函数<code>str.format()</code>，它增强了字符串格式化的功能。基本语法是通过<code>&#123;&#125;</code>和<code>:</code>来代替以前的 <code>%</code>。<code>format</code> 函数可以接受不限个参数，位置可以不按顺序 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.format(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    # 不设置指定位置，按默认顺序</span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.format(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  # 设置指定位置</span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.format(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  # 设置指定位置</span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h6 id="isinstance函数">21.2.8 isinstance()函数</h6>
<p><code>isinstance()</code>判断一个对象是否是一个已知的类型，类似<code>type()</code>。<code>isinstance()</code> 与 <code>type()</code> 区别：</p>
<ul>
<li><code>type()</code>不会认为子类是一种父类类型，不考虑继承关系。</li>
<li><code>isinstance()</code>会认为子类是一种父类类型，考虑继承关系。</li>
<li>因此如果要判断两个类型是否相同推荐使用 <code>isinstance()</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line"><span class="built_in">isinstance</span>(object, classinfo)</span><br><span class="line">#举例</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">isinstance</span> (a,<span class="type">int</span>)			#True</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="issubclass函数">21.2.9 issubclass()函数</h6>
<p>方法用于判断参数 <code>class</code> 是否是类型参数 <code>classinfo</code> 的子类: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">issubclass</span>(<span class="keyword">class</span>, classinfo)</span><br></pre></td></tr></table></figure></p>
<h6 id="list函数">21.2.10 list()函数</h6>
<p><code>list()</code>方法用于将元组或字符串转换为列表。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aTuple = (<span class="number">123</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>)</span><br><span class="line">list1 = <span class="built_in">list</span>(aTuple)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line">list2=<span class="built_in">list</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure> <em>注：元组与列表是非常类似的，区别在于元组的元素值不能修改，元组是放在括号中，列表是放于方括号中。</em></p>
<h6 id="range函数">21.2.11 range()函数</h6>
<p>Python3 <code>range()</code>函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。 Python3 <code>list()</code>函数是对象迭代器，可以把<code>range()</code>返回的可迭代对象转为一个列表，返回的变量类型为列表。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#格式</span></span><br><span class="line"><span class="built_in">range</span>(stop)</span><br><span class="line"><span class="built_in">range</span>(start, stop[, step])</span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">	<span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<h6 id="reversed函数">21.2.12 reversed()函数</h6>
<p>reversed 函数返回一个反转的迭代器。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 字符串</span><br><span class="line">seqString = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqString)))</span><br><span class="line"> </span><br><span class="line"># 元组</span><br><span class="line">seqTuple = (<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqTuple)))</span><br><span class="line"> </span><br><span class="line"><span class="meta"># range</span></span><br><span class="line">seqRange = <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqRange)))</span><br><span class="line"> </span><br><span class="line"># 列表</span><br><span class="line">seqList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqList)))</span><br></pre></td></tr></table></figure> 结果： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;R&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;R&#x27;</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h6 id="set函数">21.2.13 set()函数</h6>
<p><code>set()</code>函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">set</span>(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">y = <span class="built_in">set</span>(<span class="string">&#x27;google&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="built_in">set</span>([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]), <span class="built_in">set</span>([<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;l&#x27;</span>]))   <span class="comment"># 重复的被删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x &amp; y         <span class="comment"># 交集</span></span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;o&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x | y         <span class="comment"># 并集</span></span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x - y         <span class="comment"># 差集</span></span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="sorted函数">21.2.14 sorted()函数</h6>
<p><code>sorted()</code>函数对所有可迭代的对象进行排序操作 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#格式</span></span><br><span class="line"><span class="built_in">sorted</span>(iterable, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">example_list = [<span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">sorted</span>(example_list, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>sort 与 sorted 区别：</strong></p>
<ul>
<li><code>sort</code>是应用在 <code>list</code> 上的方法，<code>sorted</code> 可以对所有可迭代的对象进行排序操作。</li>
<li><code>list</code> 的 <code>sort</code> 方法返回的是对已经存在的列表进行操作，而内建函数<code>sorted</code>方法返回的是一个新的 <code>list</code>，而不是在原来的基础上进行的操作。</li>
</ul>
<h6 id="hash函数">21.2.15 hash()函数</h6>
<p>hash() 用于获取取一个对象（字符串或者数值等）的哈希值。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hash</span>(<span class="string">&#x27;test&#x27;</span>)            <span class="comment"># 字符串</span></span><br><span class="line"><span class="comment">#哈希值</span></span><br><span class="line"><span class="number">2314058222102390712</span></span><br></pre></td></tr></table></figure></p>
<h6 id="vars函数">21.2.16 vars()函数</h6>
<p><code>vars()</code>函数返回对象<code>object</code>的属性和属性值的字典对象。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#格式</span><br><span class="line"><span class="built_in">vars</span>([object])</span><br><span class="line">#举例</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runoob</span>:</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>(Runoob))</span><br><span class="line">#输出：</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>: None&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="命令行参数add_argument用法解析">22. 命令行参数add_argument()用法解析</h4>
<h5 id="argparse介绍">22.1 argparse介绍</h5>
<p><code>argparse</code>模块是 Python 内置的一个用于命令项选项与参数解析的模块，argparse 模块可以让人轻松编写用户友好的命令行接口。通过在程序中定义好我们需要的参数，然后 argparse 将会从 sys.argv 解析出这些参数。argparse 模块还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。</p>
<p>三个步骤：</p>
<ul>
<li>1、创建一个解析器——创建 ArgumentParser() 对象</li>
<li>2、添加参数——调用 add_argument() 方法添加参数</li>
<li>3、解析参数——使用 parse_args() 解析添加的参数</li>
</ul>
<h5 id="创建一个解析器创建-argumentparser-对象">22.2 创建一个解析器——创建 ArgumentParser() 对象</h5>
<p>使用 argparse 的第一步是创建一个 ArgumentParser 对象： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure> ArgumentParser 对象包含将命令行解析成 Python 数据类型所需的全部信息。</p>
<ul>
<li><code>description</code>:大多数对 ArgumentParser 构造方法的调用都会使用 description= 关键字参数。这个参数简要描述这个程度做什么以及怎么做。在帮助消息中，这个描述会显示在命令行用法字符串和各种参数的帮助消息之间。</li>
</ul>
<h5 id="添加参数调用-add_argument-方法添加参数">22.3 添加参数——调用 add_argument() 方法添加参数</h5>
<p>给一个 ArgumentParser 添加程序参数信息是通过调用 add_argument() 方法完成的。通常，这些调用指定 ArgumentParser 如何获取命令行字符串并将其转换为对象。这些信息在 parse_args() 调用时被存储和使用。例如 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--sparse&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;GAT with sparse version or not.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">72</span>, <span class="built_in">help</span>=<span class="string">&#x27;Random seed.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10000</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of epochs to train.&#x27;</span>)</span><br></pre></td></tr></table></figure> add_argument() 方法定义如何解析命令行参数: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ArgumentParser.add_argument(name <span class="keyword">or</span> flags...[, action][, nargs][, const][, default][, <span class="built_in">type</span>][, choices][, required][, <span class="built_in">help</span>][, metavar][, dest])</span><br></pre></td></tr></table></figure></p>
<p>每个参数解释如下:</p>
<ul>
<li><code>name or flags</code>: 选项字符串的名字或者列表，例如 foo 或者 -f, --foo。</li>
<li><code>action</code> : 命令行遇到参数时的动作，默认值是 store。</li>
<li><code>store_const</code>:表示赋值为const；</li>
<li><code>append</code>:将遇到的值存储成列表，也就是如果参数重复则会保存多个值;</li>
<li><code>append_const</code>:将参数规范中定义的一个值保存到一个列表；</li>
<li><code>count</code>：存储遇到的次数；此外，也可以继承 argparse.Action 自定义参数解析；</li>
<li><code>nargs</code>: 应该读取的命令行参数个数，可以是具体的数字，或者是?号，当不指定值时对于 Positional argument 使用 default，对于 Optional argument 使用 const；或者是 * 号，表示 0 或多个参数；或者是 + 号表示 1 或多个参数。</li>
<li><code>const</code>: action 和 nargs 所需要的常量值。</li>
<li><code>default</code> : 不指定参数时的默认值。</li>
<li><code>type</code>: 命令行参数应该被转换成的类型。</li>
<li><code>choices</code> : 参数可允许的值的一个容器。</li>
<li><code>required</code>: 可选参数是否可以省略 (仅针对可选参数)。</li>
<li><code>help</code> : 参数的帮助信息，当指定为 argparse.SUPPRESS 时表示不显示该参数的帮助信息.</li>
<li><code>metavar</code>:在 usage 说明中的参数名称，对于必选参数默认就是参数名称，对于可选参数默认是全大写的参数名称.</li>
<li><code>dest</code>: 解析后的参数名称，默认情况下，对于可选参数选取最长的名称，中划线转换为下划线.</li>
</ul>
<h5 id="解析参数使用-parse_args-解析添加的参数">22.4 解析参数——使用 parse_args() 解析添加的参数</h5>
<p>rgumentParser 通过 parse_args() 方法解析参数。它将检查命令行，把每个参数转换为适当的类型然后调用相应的操作。在大多数情况下，这意味着一个简单的 Namespace 对象将从命令行解析出的属性构建： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = parser.parse_args()</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 22.5 实例</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"> </span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">parser.add_argument(<span class="string">&#x27;--sparse&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;GAT with sparse version or not.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">72</span>, <span class="built_in">help</span>=<span class="string">&#x27;Random seed.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10000</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of epochs to train.&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">args = parser.parse_args()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(args.sparse)</span><br><span class="line"><span class="built_in">print</span>(args.seed)</span><br><span class="line"><span class="built_in">print</span>(args.epochs)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python环境配置</title>
    <url>/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="使用anaconda">1. 使用Anaconda</h4>
<p>Anaconda，中文大蟒蛇，是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖.可通过<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Anaconda下载</a>。选择合适版本。</p>
<p><strong><em>注意</em></strong>：一个python环境应当只安装一个版本的tensorflow，如果还需要安装其他版本的tensorflow，应该再创建一个python环境</p>
<span id="more"></span>
<h5 id="anaconda创建指定python环境">1.1 anaconda创建指定python环境</h5>
<p>主要命令为配置自己环境<code>conda create -n 环境的名字 python=版本号</code></p>
<ul>
<li>步骤一：打开Anaconda powershell prompt。</li>
<li>步骤二：输入命令<code>conda create -n py36 anaconda=2020.02 python=3.6</code>，版本<code>python=3.x</code>自己指定。</li>
<li>步骤三：应用该环境<code>conda activate py36</code></li>
<li>下载的环境会在<code>D:\pythonDeve\Anaconda\envs\py36</code>处</li>
</ul>
<blockquote>
<p>退出该环境使用<code>conda deactivate py36</code> 显示当前所有已发现的环境：<code>conda info --envs</code></p>
</blockquote>
<h5 id="pycharm中导入该python版本编译环境">1.2pycharm中导入该python版本编译环境：</h5>
<ul>
<li>步骤一：打开pycharm，点击<code>File\settings\project:项目名</code> <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/one.png" width="500"></li>
<li>步骤二：选择上面提到的路径导入 <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/two.png" width="500"></li>
</ul>
<h5 id="配置python环境变量">1.3 配置python环境变量</h5>
<p>配置python环境变量是为了能在命令行窗口中能够找到该命令。一般建议配置，因为后续的许多安装都要用到<code>pip</code>和<code>conda</code>。 <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/three.png" width="500"></p>
<h5 id="安装指定版本tensorflow">1.4 安装指定版本tensorflow</h5>
<ul>
<li>查看当前可使用的tensorflow版本<code>conda search  --full tensorflow</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(py36) PS C:\Users\Trluper&gt; conda search  --full tensorflow</span><br><span class="line">&gt;&gt;</span><br><span class="line">Loading channels: done</span><br><span class="line"># Name                       Version           Build  Channel</span><br><span class="line">tensorflow                     <span class="number">1.7</span><span class="number">.0</span>               <span class="number">0</span>  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.7</span><span class="number">.1</span>               <span class="number">0</span>  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.8</span><span class="number">.0</span>               <span class="number">0</span>  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.8</span><span class="number">.0</span>      haa95532_0  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.9</span><span class="number">.0</span> eigen_py35hb0e21f4_1  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.9</span><span class="number">.0</span> eigen_py36h0b764b7_1  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.9</span><span class="number">.0</span> gpu_py35h0075c17_1  pkgs/main</span><br><span class="line">tensorflow                     <span class="number">1.9</span><span class="number">.0</span> gpu_py36hfdee9c2_1  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> eigen_py35h38c8211_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> eigen_py36h849fbd8_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> gpu_py35ha5d5ef7_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> gpu_py36h3514669_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> mkl_py35h4a0f5c2_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.10</span><span class="number">.0</span> mkl_py36hb361250_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.11</span><span class="number">.0</span> eigen_py36h346fd36_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.11</span><span class="number">.0</span> gpu_py36h5dc63e2_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.11</span><span class="number">.0</span> mkl_py36h41bbc20_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.12</span><span class="number">.0</span> eigen_py36h67ac661_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.12</span><span class="number">.0</span> gpu_py36ha5f9131_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.12</span><span class="number">.0</span> mkl_py36h4f00353_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> eigen_py36hf0a88a9_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> eigen_py37h2a8d240_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> gpu_py36h1635174_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> gpu_py36h9006a92_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> gpu_py37h83e5d6a_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> gpu_py37hbc1a9d5_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> mkl_py36hd212fbe_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.13</span><span class="number">.1</span> mkl_py37h9463c59_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.14</span><span class="number">.0</span> eigen_py36hf4fd08c_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.14</span><span class="number">.0</span> eigen_py37hcf3f253_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.14</span><span class="number">.0</span> gpu_py36h305fd99_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.14</span><span class="number">.0</span> gpu_py36heb2afb7_0  pkgs/main</span><br><span class="line">tensorflow                    <span class="number">1.14</span><span class="number">.0</span> gpu_py37h2fabf85_0  pkgs/main</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<ul>
<li>查看tensorflow包信息及依赖关系<code>conda  info  tensorflow</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(py36) PS C:\Users\Trluper&gt; conda  info  tensorflow</span><br><span class="line">tensorflow <span class="number">1.15</span><span class="number">.0</span> mkl_py36h997801b_0</span><br><span class="line">------------------------------------</span><br><span class="line">file name   : tensorflow<span class="number">-1.15</span><span class="number">.0</span>-mkl_py36h997801b_0.conda</span><br><span class="line">name        : tensorflow</span><br><span class="line">version     : <span class="number">1.15</span><span class="number">.0</span></span><br><span class="line">build string: mkl_py36h997801b_0</span><br><span class="line">build number: <span class="number">0</span></span><br><span class="line">channel     : https:<span class="comment">//repo.anaconda.com/pkgs/main/win-64</span></span><br><span class="line">size        : <span class="number">4</span> KB</span><br><span class="line">arch        : None</span><br><span class="line">constrains  : ()</span><br><span class="line">legacy_bz2_md5: ad6e18c8cdd17fe2bd396177ba904065</span><br><span class="line">legacy_bz2_size: <span class="number">3829</span></span><br><span class="line">license     : Apache <span class="number">2.0</span></span><br><span class="line">license_family: Apache</span><br><span class="line">md5         : aa94e7a35e3cf46219e5750ea5674fa0</span><br><span class="line">platform    : None</span><br><span class="line">sha256      : <span class="number">04b</span>f8a4c378f150163cbdfe1cf5d996c1251b9231acf2d723336668259a4e0e4</span><br><span class="line">subdir      : win<span class="number">-64</span></span><br><span class="line">timestamp   : <span class="number">1573235601611</span></span><br><span class="line">url         : https:<span class="comment">//repo.anaconda.com/pkgs/main/win-64/tensorflow-1.15.0-mkl_py36h997801b_0.conda</span></span><br><span class="line">dependencies:</span><br><span class="line">    _tflow_select <span class="number">2.3</span><span class="number">.0</span> mkl</span><br><span class="line">    python <span class="number">3.6</span>.*</span><br><span class="line">    tensorboard &gt;=<span class="number">1.15</span><span class="number">.0</span></span><br><span class="line">    tensorflow-base <span class="number">1.15</span><span class="number">.0</span> mkl_py36h190a33d_0</span><br><span class="line">    tensorflow-estimator &gt;=<span class="number">1.15</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>主要看<code>dependencies</code>，可以看到tensorflow对应的python版本</p>
<ul>
<li>安装指定版本tensorflow：<code>conda  install tensorflow-cpu=1.13</code>，其中<code>-cpu</code>指cpu版本，还有<code>-gpu</code>版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定清华源，但有一些会没有</span></span><br><span class="line">pip install -i  https:<span class="comment">//pypi.mirrors.ustc.edu.cn/simple  tensorflow-cpu==2.1.0</span></span><br><span class="line"><span class="comment">//国外源</span></span><br><span class="line">pip install tensorflow-cpu==<span class="number">2.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>激活tensorflow<code>conda activate tensorflow</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">conda activate tensorflow</span><br></pre></td></tr></table></figure>
<ul>
<li>查看该环境下安装的tensorflow：<code>conda list tensorflow</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(py36) PS C:\Users\Trluper&gt; conda list tensorflow</span><br><span class="line"><span class="meta"># packages in environment at D:\pythonDeve\Anaconda\envs\py36:</span></span><br><span class="line">#</span><br><span class="line"># Name                    Version                   Build  Channel</span><br><span class="line">tensorflow-cpu            <span class="number">2.1</span><span class="number">.0</span>                    pypi_0    pypi</span><br><span class="line">tensorflow-estimator      <span class="number">2.1</span><span class="number">.0</span>                    pypi_0    pypi</span><br></pre></td></tr></table></figure>
<h5 id="安装指定版本keras">1.5 安装指定版本keras</h5>
<ul>
<li>查询所有版本的keras</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(py36) PS C:\Users\Trluper&gt; conda info keras</span><br><span class="line">keras <span class="number">2.6</span><span class="number">.0</span> pyhd3eb1b0_0</span><br><span class="line">------------------------</span><br><span class="line">file name   : keras<span class="number">-2.6</span><span class="number">.0</span>-pyhd3eb1b0_0.conda</span><br><span class="line">name        : keras</span><br><span class="line">version     : <span class="number">2.6</span><span class="number">.0</span></span><br><span class="line">build string: pyhd3eb1b0_0</span><br><span class="line">build number: <span class="number">0</span></span><br><span class="line">channel     : https:<span class="comment">//repo.anaconda.com/pkgs/main/noarch</span></span><br><span class="line">size        : <span class="number">721</span> KB</span><br><span class="line">arch        : None</span><br><span class="line">constrains  : (<span class="string">&#x27;tensorflow 2.6.0&#x27;</span>,)</span><br><span class="line">legacy_bz2_md5: <span class="number">9</span>c47afd01ba08eeb2130cf9811c59918</span><br><span class="line">legacy_bz2_size: <span class="number">848011</span></span><br><span class="line">license     : MIT</span><br><span class="line">license_family: MIT</span><br><span class="line">md5         : <span class="number">4</span>aeef3bf046f7e1ed44efe59fb7d3e23</span><br><span class="line">noarch      : python</span><br><span class="line">package_type: noarch_python</span><br><span class="line">platform    : None</span><br><span class="line">sha256      : c0156c162ce479d5eafd468acb956b977b7b9ae9236494b698d5b4dab02cdd7d</span><br><span class="line">subdir      : noarch</span><br><span class="line">timestamp   : <span class="number">1643826831715</span></span><br><span class="line">url         : https:<span class="comment">//repo.anaconda.com/pkgs/main/noarch/keras-2.6.0-pyhd3eb1b0_0.conda</span></span><br><span class="line">dependencies:</span><br><span class="line">    python &gt;=<span class="number">3.6</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<ul>
<li>安装指定版本keras</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(py36) PS C:\Users\Trluper&gt; pip install keras==<span class="number">2.6</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<h5 id="annconda中使用jupyter">1.6 Annconda中使用Jupyter</h5>
<p>在Annconda prompt中切换自己想要的python环境，然后直接输入<code>jupyter notebook</code>即可 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Users\Trluper&gt; <span class="function">conda activate <span class="title">py36</span></span></span><br><span class="line"><span class="function"><span class="params">(py36)</span> PS C:\Users\Trluper&gt; jupyter notebook</span></span><br></pre></td></tr></table></figure></p>
<h5 id="jupyter导入文件夹">1.7 jupyter导入文件夹</h5>
<p>导入压缩包后，创建一个python文件输入下述代码并运行，可能会出现乱码 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">files = zipfile.<span class="built_in">ZipFile</span>(<span class="string">&#x27;文件夹名称.zip&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">files.<span class="built_in">extractall</span>(os.<span class="built_in">getcwd</span>())</span><br></pre></td></tr></table></figure> 当然你要可以在本地jupyter的工作路径上直接解压该文件更快，也更推荐这种方法： <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/jupyter.png" width="500"></p>
<h5 id="更改jupyter的工作路径">1.8 更改jupyter的工作路径</h5>
<p>默认情况下jupytr的工作路径wei<code>C:\Users\用户名</code>，我们不希望放在C盘，可以通过以下方法更改。</p>
<ul>
<li>首先找到对于的python环境的Annconda prompt进入,输入命令<code>jupyter notebook --generate-config</code>得到路径 <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Annconda.png" width="500"></li>
<li>根据上面运行处的路径打开<code>C:\Users\Trluper\.jupyter\jupyter_notebook_config.py</code>文件</li>
<li>在文件中找到<code>c.NotebookApp.notebook_dir = ''</code>，删除注释符<code>#</code>，并在单引号内写上自己的工作路径 <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/config.png" width="500"></li>
<li>之后找到<code>jupyter Notebook</code>,点击属性，删除后面的<code>&quot;%USERPROFILE%/”</code> <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/delete.png" width="500"></li>
</ul>
<h5 id="安装pytorch">1.9 安装pytorch</h5>
<p>pytorch的安装可以直接在<a href="https://pytorch.org/get-started/previous-versions/">官网</a>复制相应版本的pytorch进行安装，注意区分GPU版本和CPU版本。复制后在Annconda prompt下进行执行，在执行前自己先切换到要安装pytorch的python虚拟环境，下面是pytorch 1.8.1版本的安装语句，上面的cuda是其对应cuda版本。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CUDA 11.1</span></span><br><span class="line">pip install torch==<span class="number">1.8</span><span class="number">.1</span>+cu111 torchvision==<span class="number">0.9</span><span class="number">.1</span>+cu111 torchaudio==<span class="number">0.8</span><span class="number">.1</span> -f https://download.pytorch.org/whl/torch_stable.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># CUDA 10.2</span></span><br><span class="line">pip install torch==<span class="number">1.8</span><span class="number">.1</span>+cu102 torchvision==<span class="number">0.9</span><span class="number">.1</span>+cu102 torchaudio==<span class="number">0.8</span><span class="number">.1</span> -f https://download.pytorch.org/whl/torch_stable.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># CUDA 10.1</span></span><br><span class="line">pip install torch==<span class="number">1.8</span><span class="number">.1</span>+cu101 torchvision==<span class="number">0.9</span><span class="number">.1</span>+cu101 torchaudio==<span class="number">0.8</span><span class="number">.1</span> -f https://download.pytorch.org/whl/torch_stable.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU only</span></span><br><span class="line">pip install torch==<span class="number">1.8</span><span class="number">.1</span>+cpu torchvision==<span class="number">0.9</span><span class="number">.1</span>+cpu torchaudio==<span class="number">0.8</span><span class="number">.1</span> -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></table></figure> <strong><em>注：一般来说cuda高版本可兼容低版本pytorch，但高pytorch不能兼容低版本的cuda</em></strong></p>
<p><img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/cuda.png" width="500"> python和pytorch的对应版本一般只要求python在3.6和3.9之间</p>
<h5 id="安装mmlab的mmcv">1.10 安装mmlab的mmcv</h5>
<p><strong>MMCV 有两个版本：</strong></p>
<ul>
<li>mmcv-full: 完整版，包含所有的特性以及丰富的开箱即用的 CUDA 算子。注意完整版本可能需要更长时间来编译。</li>
<li>mmcv: 精简版，不包含 CUDA 算子但包含其余所有特性和功能，类似 MMCV 1.0 之前的版本。如果你不需要使用 CUDA 算子的话，精简版可以作为一个考虑选项。</li>
</ul>
<p><strong>安装CUDA版mmcv</strong>:</p>
<ul>
<li>从网址中选择自己对应的cuda版本、pytorch版本，如下<code>https://download.openmmlab.com/mmcv/dist/cu101/torch1.8.0/index.html</code>，其中cu后面的三个数字对应你的cuda版本号，torch后面的数字对应逆的pytorch版本号。 <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/mmcv.png" width="500"></li>
<li>将选择的<code>whl</code>包下载后，到指定的python虚拟环境进行安装，这里我将包下载到了<code>D:\Applycation_SapceOfSourse</code>,进入该路径后，执行<code>pip install  mmcv_full-1.5.3-cp37-cp37m-win_amd64.whl</code> <img src="/2022/09/17/python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/install.png" width="500"></li>
<li>安装完成后运行<code>check_installation.py</code>脚本看是否安装成功</li>
</ul>
<p><strong>精简版</strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install mmcv</span><br></pre></td></tr></table></figure></p>
<p>详情看<a href="https://github.com/open-mmlab/mmcv/blob/master/README_zh-CN.md">mmlab的官方github</a></p>
<h5 id="安装mmlab的mmdetection3d">1.11 安装mmlab的mmdetection3D</h5>
<p>待更新</p>
<p>详情看<a href="https://github.com/open-mmlab/mmdetection3d/blob/master/docs/zh_cn/getting_started.md">mmlab的mmdetection3D</a></p>
<h4 id="错误总览">2. 错误总览</h4>
<h5 id="cannot-import-name-get_config">2.1 cannot import name 'get_config'</h5>
<ul>
<li><p>问题：导入语句<code>from keras.datasets import mnist</code>出现<code>ImportError: cannot import name ‘get_config’</code></p></li>
<li><p><code>解决方法</code>： <code>ImportError: cannot import name ‘get_config’</code> 这个类型报错的问题我遇到的都可以通过导入包时使用tensorflow.keras解决,如下：成功解决 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">from tensorflow.keras.datasets <span class="keyword">import</span> mnist</span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python数学库</title>
    <url>/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/</url>
    <content><![CDATA[<h4 id="numpy概述">1. Numpy概述</h4>
<h5 id="概念">1.1 概念</h5>
<p>Python本身含有列表和数组，但对于大数据来说，这些结构是有很多不足的。由于列表的元素可以是任何对象，因此列表中所保存的是对象的指针。对于数值运算来说这种 结构比较浪费内存和CPU资源。至于数组对象，它可以直接保存 数值，和C语言的一维数组比较类似。但是由于它不支持多维，在上面的函数也不多，因此也不适合做数值运算。Numpy提供了两种基本的对象：<code>ndarray(N-dimensional Array Object)</code>和 <code>ufunc(Universal Function Object)</code>。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。</p>
<span id="more"></span>
<h5 id="功能">1.2 功能</h5>
<ul>
<li>创建n维数组(矩阵)</li>
<li>对数组进行函数运算，使用函数计算十分快速，节省了大量的时间，且不需要编写循环，十分方便</li>
<li>数值积分、线性代数运算、傅里叶变换</li>
<li>ndarray快速节省空间的多维数组，提供数组化的算术运算和高级的 广播功能</li>
</ul>
<h5 id="对象">1.3 对象</h5>
<ul>
<li>NumPy中的核心对象是<code>ndarray</code></li>
<li><code>ndarray</code>可以看成数组，存放 同类元素</li>
<li>NumPy里面所有的函数都是围绕ndarray展开的</li>
</ul>
<p><strong><code>ndarray</code> 内部由以下内容组成：</strong></p>
<ul>
<li>一个指向数据(内存或内存映射文件中的一块数据)的指针。</li>
<li>数据类型或 dtype，描述在数组中的固定大小值的格子。</li>
<li>一个表示数组形状(shape)的元组，表示各维度大小的元组。形状为(row×col)</li>
</ul>
<h5 id="数据类型">1.4 数据类型</h5>
<p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和C语言的数据类型对应上。主要包括<code>int8、int16、int32、int64、uint8、uint16、uint32、uint64、float16、float32、float64</code></p>
<h5 id="数组属性">1.5 数组属性</h5>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ndarray.ndim</code></td>
<td>秩，即轴的数量或维度的数量</td>
</tr>
<tr class="even">
<td><code>ndarray.shape</code></td>
<td>数组的维度(n×m)，对于矩阵，n 行 m 列</td>
</tr>
<tr class="odd">
<td><code>ndarray.size</code></td>
<td>数组元素的总个数，相当于 .shape 中 n*m 的值</td>
</tr>
<tr class="even">
<td><code>ndarray.dtype</code></td>
<td>ndarray 对象的元素类型</td>
</tr>
<tr class="odd">
<td><code>ndarray.itemsize</code></td>
<td>ndarray 对象中每个元素的大小，以字节为单位</td>
</tr>
<tr class="even">
<td><code>ndarray.flags</code></td>
<td>ndarray对象的内存信息</td>
</tr>
<tr class="odd">
<td><code>ndarray.real</code></td>
<td>ndarray元素的实部</td>
</tr>
<tr class="even">
<td><code>ndarray.imag</code></td>
<td>ndarray元素的虚部</td>
</tr>
<tr class="odd">
<td><code>ndarray.data</code></td>
<td>包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td>
</tr>
</tbody>
</table>
<h4 id="具体操作">2. 具体操作</h4>
<h5 id="numpy的创建">2.1 Numpy的创建</h5>
<h6 id="利用列表生成数组">2.1.1 利用列表生成数组</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">lst=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">np1=np.array(lst)</span><br><span class="line"><span class="built_in">print</span>(np1,<span class="built_in">type</span>(np1))</span><br></pre></td></tr></table></figure>
<h6 id="利用random模块生成数组">2.1.2 利用random模块生成数组</h6>
<p><img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/numpyRandom.png" width="600"> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#0到1标准正态分布</span></span><br><span class="line">arr1 = np.random.randn(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#0到1均匀分布</span></span><br><span class="line">arr2 = np.random.rand(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#均匀分布的随机数（浮点数），前两个参数表示随机数的范围，第三个表示生成随机数的个数</span></span><br><span class="line">arr3 = np.random.uniform(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">#均匀分布的随机数（整数），前两个参数表示随机数的范围，第三个表示生成随机数的个数</span></span><br><span class="line">arr4 = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;arr1 : <span class="subst">&#123;arr1&#125;</span>\narr2 : <span class="subst">&#123;arr2&#125;</span>\narr3 : <span class="subst">&#123;arr3&#125;</span>\narr4 : <span class="subst">&#123;arr4&#125;</span>&#x27;</span>)</span><br><span class="line">out : </span><br><span class="line"><span class="comment"># arr1 : [[-0.31637952 -0.08258995  1.43866984]</span></span><br><span class="line"><span class="comment">#  [-0.11216775  0.43881134  0.11745847]</span></span><br><span class="line"><span class="comment">#  [-1.1770306  -0.97657465  2.2368878 ]]</span></span><br><span class="line"><span class="comment"># arr2 : [[0.16350611 0.4467384  0.9465067 ]</span></span><br><span class="line"><span class="comment">#  [0.1882318  0.40261184 0.93577701]</span></span><br><span class="line"><span class="comment">#  [0.56243911 0.69179631 0.83407725]]</span></span><br><span class="line"><span class="comment"># arr3 : [4.41402883 6.03259052]</span></span><br><span class="line"><span class="comment"># arr4 : [9 7 7]</span></span><br></pre></td></tr></table></figure></p>
<h6 id="创建特定形状数组">2.1.3 创建特定形状数组</h6>
<p><img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/spacial.png" width="600"> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mport numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#未初始化的数组</span></span><br><span class="line">arr1 = np.empty((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">#数组元素以 0 来填充</span></span><br><span class="line">arr2 = np.zeros((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">#数组元素以 1 来填充</span></span><br><span class="line">arr3 = np.ones((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">#数组以指定的数来进行填充，这里举例3</span></span><br><span class="line">arr4 = np.full((<span class="number">2</span>, <span class="number">3</span>), <span class="number">3</span>)</span><br><span class="line"><span class="comment">#生成单位，对角线上元素为 1，其他为0</span></span><br><span class="line">arr5 = np.eye(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#二维矩阵输出矩阵对角线的元素，一维矩阵形成一个以一维数组为对角线元素的矩阵</span></span><br><span class="line">arr6 = np.diag(np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]))</span><br></pre></td></tr></table></figure></p>
<h6 id="linspace">2.1.4 linspace</h6>
<p>此函数类似于arange()函数。在此函数中，指定了范围之间的均匀间隔数量，而不是步长。用法如下 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.linspace(start, stop, num, endpoint, retstep, dtype)</span><br></pre></td></tr></table></figure> - <code>start</code> 序列的起始值 - <code>stop</code> 序列的终止值，如果endpoint为true，该值包含于序列中 - <code>num</code> 要生成的等间隔样例数量，默认为50 - <code>endpoint</code> 序列中是否包含stop值，默认为ture - <code>retstep</code> 如果为true，返回样例，以及连续数字之间的步长 - <code>dtype</code> 输出ndarray的数据类型</p>
<h5 id="查找和搜索">2.2 查找和搜索</h5>
<p>Numpy可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样，设置start, stop 及 step 参数</p>
<h6 id="切片操作">2.2.1 切片操作</h6>
<p><img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/index.png" width="600"></p>
<h6 id="元素查找定位">2.2.2 元素查找定位</h6>
<p>Numpy库中提供了<code>where</code>函数来查找满足条件元素的索引，表示如下：</p>
<ul>
<li><code>np.where(condition, x, y)</code>: 满足条件(condition)，输出x，不满足输出y</li>
<li><code>np.where(condition)</code>: 输出满足条件 (即非0) 元素的坐标</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=np.array([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>]).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x=np.where(a&gt;<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a[x])</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span>]</span><br></pre></td></tr></table></figure></p>
<h6 id="高级索引">2.2.3 高级索引</h6>
<p>如果一个<code>ndarray</code>是非元组序列，数据类型为整数或布尔值的ndarray，或者至少一个元素为序列对象的元组，我们就能够用它来索引ndarray。高级索引始终返回数据的副本。使用方法 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([[<span class="number">1</span>,  <span class="number">2</span>],  [<span class="number">3</span>,  <span class="number">4</span>],  [<span class="number">5</span>,  <span class="number">6</span>]]) </span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]  </span><br><span class="line"><span class="built_in">print</span> y</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure> 解析:上面的x下标索引的两个列表进行两两配对<code>(0,0),(1,1),(2,0)</code>位置，得到`x[0,0],x[1,1],x[2,0]等就是输出结果</p>
<h5 id="删除">2.3 删除</h5>
<p><code>np.delete(arr, index, axis=None)</code></p>
<ul>
<li>第一个参数：要处理的矩阵，</li>
<li>第二个参数，处理的位置，下标</li>
<li>第三个参数，0表示按照行删除，1表示按照列删除，默认为0</li>
<li>返回值为删除后的剩余元素构成的矩阵</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m=np.delete(a,[<span class="number">0</span>],<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure>
<h5 id="numpy的拼接和分割">2.4 numpy的拼接和分割</h5>
<h6 id="拼接">2.4.1 拼接</h6>
<p>下面的图列举了常见的用于数组或向量 合并的方法。 <img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/append.png" width="600"></p>
<ul>
<li><code>append、concatenate</code>以及<code>stack</code>都有一个<code>axis</code>参数，用于控制数组的合 并方式是按行还是按列。</li>
<li>对于<code>append</code>和<code>concatenate</code>，待合并的数组必须有相同的行数或列数</li>
<li><code>stack、hstack、dstack</code>，要求待合并的数组必须具有相同的形状</li>
</ul>
<h6 id="分割">2.4.2 分割</h6>
<ul>
<li>水平分割：<code>np.split(arr,n,axis=1) 或 np.hsplit(arr,n)</code>：按列分成<code>n</code>份。返回一个<code>list</code></li>
<li>垂直分割：<code>np.split(arr,n,axis=0)</code> 或 <code>np.vsplit(arr,n)</code>：按行分成n份，返回一个<code>list</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">splitTes=np.split(a,<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">splitTes2=np.split(a,<span class="number">3</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="维度变换">2.5 维度变换</h5>
<p>在机器学习以及深度学习的任务中，通常需要将处理好的数据以模型能 接收的格式输入给模型，然后由模型通过一系列的运算，最终返回一个处理 结果。然而，由于不同模型所接收的输入格式不一样，往往需要先对其进行 一系列的变形和运算，从而将数据处理成符合模型要求的格式。在矩阵或者 数组的运算中，经常会遇到需要把多个向量或矩阵按某轴方向合并，或展平 (如在卷积或循环神经网络中，在全连接层之前，需要把矩阵展平)的情 况。下面介绍几种常用的数据变形方法。 <img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/switch.png" width="600"></p>
<h6 id="reshape">2.5.1 reshape</h6>
<p>不会改变数组内额元素，返回一个指定的shap维度的数组，按原顺序放置元素 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#三行四列，如果单指定行数或列数，另一个参数可设置为-1</span></span><br><span class="line">x=np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<h6 id="resize">2.5.2 resize</h6>
<p>改变向量的维度，同<code>reshape</code>作用 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二行五列</span></span><br><span class="line">arr=np.arange(<span class="number">10</span>)</span><br><span class="line">arr.resize(<span class="number">2</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<h6 id="转置">2.5.3 转置</h6>
<p>将矩阵转置 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr=np.nrange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.T)</span><br></pre></td></tr></table></figure></p>
<h6 id="向量展平">2.5.4 向量展平</h6>
<p>将多维数组转为一维数组，不会产生数组的副本 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr=arr.ravel()</span><br></pre></td></tr></table></figure></p>
<h6 id="向量展平之flatten">2.5.5 向量展平之flatten</h6>
<p>把矩阵转换为向量，这种需求经常出现在卷积网络与全连接层之间 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">arr.flatten() <span class="comment"># out : array([0, 1, 2, 3, 4, 5, 6, 7])</span></span><br></pre></td></tr></table></figure></p>
<h6 id="squeeze">2.5.6 squeeze</h6>
<p>这是一个降维的函数，把矩阵中为1维的维度去掉 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">arr.shape <span class="comment"># out : (2, 4, 1)</span></span><br><span class="line">arr.squeeze().shape <span class="comment"># out : (2, 4)</span></span><br></pre></td></tr></table></figure></p>
<h6 id="transpose">2.5.7 transpose</h6>
<p>对高维矩阵进行轴对换，这个在深度学习中经常使用，比如把图片中表 示颜色顺序的RGB改为GBR。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).reshape(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>)</span><br><span class="line">arr.shape <span class="comment"># out : (2, 6, 1)</span></span><br><span class="line">arr.transpose(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).shape <span class="comment"># out : (6, 1, 2)</span></span><br></pre></td></tr></table></figure></p>
<h5 id="矩阵运算">2.6 矩阵运算</h5>
<h6 id="对于元素相乘">2.6.1 对于元素相乘</h6>
<p>对应元素相乘（Element-Wise Product）是两个矩阵中对应元素乘积。 np.multiply函数用于数组或矩阵对应元素相乘，输出与相乘数组或矩阵的大 小一致。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.array([[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line">np.multiply(a, b) <span class="comment"># 等效于a * b，out : array([[4, 0], [0, 2]])</span></span><br></pre></td></tr></table></figure></p>
<h6 id="点积">2.6.2 点积</h6>
<p>点积运算(Dot Product)又称为内积，在Numpy用np.dot或者np.matmul表示 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.array([[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line">np.dot(a, b) <span class="comment"># 等效于np.matmul(a, b) out : array([[4, 1], [2, 2]])</span></span><br></pre></td></tr></table></figure></p>
<h6 id="行列式">2.6.3 行列式</h6>
<p>计算行列式的值 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">np.linalg.det(arr) <span class="comment"># out : -2.0000000000000004</span></span><br></pre></td></tr></table></figure></p>
<h6 id="求逆">2.6.4 求逆</h6>
<p>求逆 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">np.linalg.inv(arr) <span class="comment"># out : array([[-2. ,  1. ], [ 1.5, -0.5]])</span></span><br></pre></td></tr></table></figure></p>
<h6 id="特征值和特征向量">2.6.5 特征值和特征向量</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A = np.random.<span class="built_in">randint</span>(<span class="number">-10</span>,<span class="number">10</span>,(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">C = np.<span class="built_in">dot</span>(A.T, A)</span><br><span class="line">vals, vecs = np.linalg.<span class="built_in">eig</span>(C) </span><br><span class="line"><span class="built_in">print</span>(f<span class="number">&#x27;</span>特征值 : &#123;vals&#125;, 特征向量 : &#123;vecs&#125;<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">#out : </span></span><br><span class="line"><span class="string">特征值 : [395.26566729 358.52489695  44.41465068  52.79478508]</span></span><br><span class="line"><span class="string">特征向量 : [[ 0.30221599  0.64309202 -0.64757004 -0.27522935]</span></span><br><span class="line"><span class="string">             [ 0.87819925 -0.03518532  0.18871425  0.43808105]</span></span><br><span class="line"><span class="string">             [-0.35779498  0.26192443 -0.27010759  0.85464626]</span></span><br><span class="line"><span class="string">             [ 0.09702746 -0.71874212 -0.68708214  0.04374437]]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h5 id="numpy--matplotlib">2.7 numpy- Matplotlib</h5>
<p>Matplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure> 这里<code>pyplot()</code>是 <code>matplotlib</code>库中最重要的函数，用于绘制 2D 数据。 以下脚本绘制方程<code>y = 2x + 5：</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt </span><br><span class="line"> </span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">11</span>) <span class="comment">#x=np.linspace(1,11,2000)</span></span><br><span class="line">y =  <span class="number">2</span>  * x +  <span class="number">5</span> </span><br><span class="line">plt.title(<span class="string">&quot;Matplotlib demo&quot;</span>) </span><br><span class="line">plt.xlabel(<span class="string">&quot;x axis caption&quot;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&quot;y axis caption&quot;</span>) </span><br><span class="line">plt.plot(x,y) plt.show()</span><br></pre></td></tr></table></figure>
<p><a href="https://quantfabric.blog.csdn.net/article/details/123096127?spm=1001.2014.3001.5502">Numpy详细教程</a></p>
<h4 id="pandas概述">3.pandas概述</h4>
<p>Pandas是Python的一个大数据处理模块。Pandas使用一个二维的数据结构DataFrame来表示表格式的数据，相比较于Numpy，Pandas可以存储混合的数据结构，同时使用NaN来表示缺失的数据，而不用像Numpy一样要手工处理缺失的数据，并且Pandas使用轴标签来表示行和列。它具有：</p>
<ul>
<li>便捷的数据处理能力</li>
<li>独特的数据结构</li>
<li>读取文件方便</li>
<li>封装了<code>matplotlib</code>的画图和<code>numpy</code>的计算</li>
</ul>
<h5 id="pandas的数据结构">3.1 pandas的数据结构</h5>
<p>Pandas有三种主要数据结构<code>Series、DataFrame、Panel</code>。</p>
<ul>
<li><p><code>Series</code>是带有标签的一维数组，可以保存任何数据类型（整数，字符串，浮点数，Python对象等），轴标签统称为索引（index）。</p></li>
<li><p><code>DataFrame</code>是带有标签的二维数据结构，具有<code>index</code>（行标签）和<code>columns</code>（列标签）。如果传递<code>index</code>或<code>columns</code>，则会用于生成的D<code>ataFrame</code>的<code>index</code>或<code>columns</code>。</p></li>
<li><p><code>Panel</code>是一个三维数据结构，由<code>items、major_axis、minor_axis</code>定义。<code>items</code>（条目），即轴0，每个条目对应一个<code>DataFrame</code>；<code>major_axis（主轴）</code>，即轴1，是每个<code>DataFrame</code>的index（行）；<code>minor_axis</code>（副轴），即轴2，是每个<code>DataFrame</code>的columns（列）。</p></li>
</ul>
<h5 id="series">3.2 Series</h5>
<p>Series是能够保存任何类型数据(整数，字符串，浮点数，Python对象等)的一维标记数组，轴标签统称为index（索引）。series是一种一维数据结构，每一个元素都带有一个索引，其中索引可以为数字或字符串。Series结构名称： <img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/Series.png" width="400"></p>
<h6 id="构造对象">3.2.1 构造对象</h6>
<p>Series的构造函数如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Series( data, index, dtype, copy)</span><br></pre></td></tr></table></figure> - <code>data</code>：构建Series的数据，可以是ndarray，list，dict，constants。 - <code>index</code>：索引值必须是唯一的和散列的，与数据的长度相同。 如果没有索引被传递，默认为np.arange(n)。 - <code>dtype</code>：数据类型，如果没有，将推断数据类型。 - <code>copy</code>：是否复制数据，默认为false。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = np.array([<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">    s = pd.Series(data,index=[<span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 101      a</span></span><br><span class="line"><span class="comment"># 102      1</span></span><br><span class="line"><span class="comment"># 103      2</span></span><br><span class="line"><span class="comment"># hello    4</span></span><br><span class="line"><span class="comment"># world    6</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br></pre></td></tr></table></figure>
<p>使用<code>ndarray</code>作为数据时，传递的索引必须与<code>ndarray</code>具有相同的长度。 如果没有传递索引值，那么默认的索引是<code>range(n)</code>，其中n是数组长度，即<code>[0,1,2,3…. range(len(array))-1] - 1]</code>。</p>
<h6 id="series数据的访问">3.2.2 Series数据的访问</h6>
<p>Series中的数据可以使用有序序列的方式进行访问。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(s[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(s[-<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(s[-<span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># c    3</span></span><br><span class="line"><span class="comment"># d    4</span></span><br><span class="line"><span class="comment"># e    5</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br></pre></td></tr></table></figure></p>
<h6 id="series属性">3.2.3 Series属性</h6>
<ul>
<li><code>Series.axes</code>：返回行轴标签列表</li>
<li><code>Series.dtype</code>：返回对象的数据类型</li>
<li><code>Series.empty</code>：如果对象为空，返回True</li>
<li><code>Series.ndim</code>：返回底层数据的维数，默认为1</li>
<li><code>Series.size</code>：返回基础数据中的元素数</li>
<li><code>Series.values</code>：将对象作为ndarray返回</li>
<li><code>Series.head()</code>：返回前n行</li>
<li><code>Series.tail()</code>：返回后n行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = pd.Series([<span class="string">&quot;Bauer&quot;</span>, <span class="number">30</span>, <span class="number">90</span>], index=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Score&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Series=================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;axes===================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.axes)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dtype==================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.dtype)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;empty==================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.empty)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ndim===================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.ndim)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;size===================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.size)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;values=================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.values)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;head()=================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.head(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tail()=================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.tail(<span class="number">2</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Series=================</span></span><br><span class="line"><span class="comment"># Name     Bauer</span></span><br><span class="line"><span class="comment"># Age         30</span></span><br><span class="line"><span class="comment"># Score       90</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br><span class="line"><span class="comment"># axes===================</span></span><br><span class="line"><span class="comment"># [Index([&#x27;Name&#x27;, &#x27;Age&#x27;, &#x27;Score&#x27;], dtype=&#x27;object&#x27;)]</span></span><br><span class="line"><span class="comment"># dtype==================</span></span><br><span class="line"><span class="comment"># object</span></span><br><span class="line"><span class="comment"># empty==================</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># ndim===================</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># size===================</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># values=================</span></span><br><span class="line"><span class="comment"># [&#x27;Bauer&#x27; 30 90]</span></span><br><span class="line"><span class="comment"># head()=================</span></span><br><span class="line"><span class="comment"># Name    Bauer</span></span><br><span class="line"><span class="comment"># Age        30</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br><span class="line"><span class="comment"># tail()=================</span></span><br><span class="line"><span class="comment"># Age      30</span></span><br><span class="line"><span class="comment"># Score    90</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br></pre></td></tr></table></figure>
<h5 id="dataframe">3.3 DataFrame</h5>
<p>数据帧(DataFrame)是二维的表格型数据结构，即数据以行和列的表格方式排列，DataFrame是Series的容器。 <img src="/2022/09/18/python%E6%95%B0%E5%AD%A6%E5%BA%93/DataFrame.png" width="400"> <strong>特点：</strong></p>
<ul>
<li>底层数据列是不同的类型</li>
<li>大小可变</li>
<li>标记轴(行和列)</li>
<li>可以对行和列执行算术运算</li>
</ul>
<h6 id="dataframe对象构造">3.3.1 DataFrame对象构造</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame( data, index, columns, dtype, copy)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code>：构建DataFrame的数据，可以是ndarray，series，map，lists，dict，constant和其它DataFrame。</li>
<li><code>index</code>：行索引标签，如果没有传递索引值，索引默认为np.arrange(n)。</li>
<li><code>columns</code>：列索引标签，如果没有传递索列引值，默认列索引是np.arange(n)。</li>
<li><code>dtype</code>：每列的数据类型。</li>
<li><code>copy</code>：如果默认值为False，则此命令(或任何它)用于复制数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = &#123;<span class="string">&#x27;one&#x27;</span>: pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;two&#x27;</span>: pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;three&#x27;</span>: pd.Series([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])&#125;</span><br><span class="line">    df = pd.DataFrame(data, columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(df)</span><br><span class="line">    <span class="keyword">del</span>(df[<span class="string">&#x27;two&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#  one  two  three</span></span><br><span class="line"><span class="comment"># a  1.0    1   10.0</span></span><br><span class="line"><span class="comment"># b  2.0    2   20.0</span></span><br><span class="line"><span class="comment"># c  3.0    3   30.0</span></span><br><span class="line"><span class="comment"># d  NaN    4    NaN</span></span><br><span class="line"><span class="comment">#    one  three</span></span><br><span class="line"><span class="comment"># a  1.0   10.0</span></span><br><span class="line"><span class="comment"># b  2.0   20.0</span></span><br><span class="line"><span class="comment"># c  3.0   30.0</span></span><br><span class="line"><span class="comment"># d  NaN    NaN</span></span><br></pre></td></tr></table></figure>
<h6 id="dataframe属性">3.3.2 DataFrame属性</h6>
<ul>
<li><code>DataFrame.T</code>：转置行和列</li>
<li><code>DataFrame.axes</code>：返回一个列，行轴标签和列轴标签作为唯一的成员。</li>
<li><code>DataFrame.dtypes</code>：返回对象的数据类型</li>
<li><code>DataFrame.empty</code>：如果NDFrame完全为空，返回True</li>
<li><code>DataFrame.ndim</code>：返回轴/数组维度的大小</li>
<li><code>DataFrame.shape</code>：返回表示DataFrame维度的元组</li>
<li><code>DataFrame.size</code>：返回DataFrame的元素数</li>
<li><code>DataFrame.values</code>：将对象作为ndarray返回</li>
<li><code>DataFrame.head()</code>：返回前n行</li>
<li><code>DataFrame.tail()</code>：返回后n行</li>
</ul>
<h6 id="示例">3.3.3 示例</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个符合正态分布的10个股票5天的涨跌幅数据,0表示正态分布的中心点，1表示标准宽度，越大曲线越矮越胖，[10,5]数据shape</span></span><br><span class="line">stocks = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">10</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 使用pandas中的数据结构 DataFrame() 处理数据</span></span><br><span class="line">stocks_rise = pd.DataFrame(stocks)</span><br><span class="line"><span class="comment"># 设置行索引,获取行数 stocks_rise.shape[0] 进行遍历 列表生成式</span></span><br><span class="line">index_row = [<span class="string">&#x27;股票&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(stocks_rise.shape[<span class="number">0</span>])]</span><br><span class="line"><span class="comment"># 设置列索引，日期是一个时间序列，为了简便，使用pd.date_range()生成一组连续的时间序列</span></span><br><span class="line"><span class="comment"># pd.date_range(start,end,periods,freq) start:开始时间, end:结束时间</span></span><br><span class="line"><span class="comment"># periods:时间天数, freq:递进单位，默认1天，&#x27;B&#x27;默认略过周末</span></span><br><span class="line">index_col = pd.date_range(start=<span class="string">&#x27;20220201&#x27;</span>,periods=stocks_rise.shape[<span class="number">1</span>],freq=<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加索引，注意数据是ndarray数据 index表示行索引，columns表示列索引</span></span><br><span class="line">data = pd.DataFrame(stocks, index=index_row, columns=index_col)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">      <span class="number">2022</span>-02-01  <span class="number">2022</span>-02-02  <span class="number">2022</span>-02-03  <span class="number">2022</span>-02-04  <span class="number">2022</span>-02-07</span><br><span class="line">股票<span class="number">1</span>    -<span class="number">2.054041</span>   -<span class="number">1.170757</span>    <span class="number">0.162393</span>    <span class="number">0.253333</span>   -<span class="number">1.638837</span></span><br><span class="line">股票<span class="number">2</span>    -<span class="number">1.463734</span>    <span class="number">0.408459</span>    <span class="number">0.530070</span>   -<span class="number">0.925281</span>    <span class="number">1.454630</span></span><br><span class="line">股票<span class="number">3</span>    -<span class="number">0.511517</span>   -<span class="number">0.827591</span>   -<span class="number">2.076265</span>    <span class="number">0.139486</span>    <span class="number">0.658707</span></span><br><span class="line">股票<span class="number">4</span>    -<span class="number">1.698789</span>    <span class="number">0.250902</span>   -<span class="number">0.624713</span>    <span class="number">1.378845</span>   -<span class="number">1.672292</span></span><br><span class="line">股票<span class="number">5</span>     <span class="number">0.683233</span>   -<span class="number">1.083694</span>    <span class="number">0.810567</span>    <span class="number">0.421215</span>    <span class="number">1.375385</span></span><br><span class="line">股票<span class="number">6</span>    -<span class="number">0.296111</span>   -<span class="number">0.946959</span>    <span class="number">0.836536</span>   -<span class="number">1.179879</span>   -<span class="number">0.397406</span></span><br><span class="line">股票<span class="number">7</span>     <span class="number">0.017772</span>    <span class="number">0.180210</span>    <span class="number">2.022776</span>    <span class="number">0.436337</span>   -<span class="number">1.555866</span></span><br><span class="line">股票<span class="number">8</span>     <span class="number">0.638262</span>   -<span class="number">0.790932</span>    <span class="number">1.077822</span>   -<span class="number">1.746631</span>   -<span class="number">0.591360</span></span><br><span class="line">股票<span class="number">9</span>    -<span class="number">0.681391</span>   -<span class="number">0.613255</span>   -<span class="number">1.849094</span>    <span class="number">0.438304</span>   -<span class="number">0.503742</span></span><br><span class="line">股票<span class="number">10</span>   -<span class="number">0.243500</span>   -<span class="number">1.733623</span>   -<span class="number">1.137840</span>    <span class="number">0.124976</span>   -<span class="number">0.415727</span></span><br></pre></td></tr></table></figure>
<h5 id="panel">3.4 panel</h5>
<p>panel 是三维的数据结构，是DataFrame的容器，Panel的3个轴如下：</p>
<ul>
<li><code>items</code>：axis 0，每个项目对应于内部包含的数据帧(DataFrame)。</li>
<li><code>major_axis</code> ：axis 1，是每个数据帧(DataFrame)的索引(行)。</li>
<li><code>minor_axis</code>：axis 2，是每个数据帧(DataFrame)的列。</li>
</ul>
<h6 id="panel对象构造">3.4.1 Panel对象构造</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Panel(data, items, major_axis, minor_axis, dtype, copy)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code>：构建Panel的数据，采取各种形式，如<code>ndarray，series，map，lists，dict，constant</code>和另一个数据帧<code>DataFrame</code>。</li>
<li><code>items</code>：axis=0</li>
<li><code>major_axis</code>：axis=1</li>
<li><code>minor_axis</code>：axis=2</li>
<li><code>dtype</code>：每列的数据类型</li>
<li><code>copy</code>：复制数据，默认 - false</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = np.random.rand(<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    p = pd.Panel(data, items=[<span class="string">&quot;item1&quot;</span>, <span class="string">&quot;item2&quot;</span>], major_axis=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], minor_axis=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(p)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;item1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(p[<span class="string">&quot;item1&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(p.major_xs(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(p.minor_xs(<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;pandas.core.panel.Panel&#x27;&gt;</span></span><br><span class="line"><span class="comment"># Dimensions: 2 (items) x 4 (major_axis) x 5 (minor_axis)</span></span><br><span class="line"><span class="comment"># Items axis: item1 to item2</span></span><br><span class="line"><span class="comment"># Major_axis axis: 1 to 4</span></span><br><span class="line"><span class="comment"># Minor_axis axis: a to e</span></span><br><span class="line"><span class="comment"># item1</span></span><br><span class="line"><span class="comment">#           a         b         c         d         e</span></span><br><span class="line"><span class="comment"># 1  0.185626  0.976123  0.566263  0.273208  0.675442</span></span><br><span class="line"><span class="comment"># 2  0.209664  0.205190  0.217200  0.158447  0.400683</span></span><br><span class="line"><span class="comment"># 3  0.499591  0.963321  0.759330  0.089930  0.362824</span></span><br><span class="line"><span class="comment"># 4  0.723158  0.585642  0.629246  0.886086  0.493039</span></span><br><span class="line"><span class="comment">#       item1     item2</span></span><br><span class="line"><span class="comment"># a  0.209664  0.592154</span></span><br><span class="line"><span class="comment"># b  0.205190  0.661562</span></span><br><span class="line"><span class="comment"># c  0.217200  0.743716</span></span><br><span class="line"><span class="comment"># d  0.158447  0.055882</span></span><br><span class="line"><span class="comment"># e  0.400683  0.245760</span></span><br><span class="line"><span class="comment">#       item1     item2</span></span><br><span class="line"><span class="comment"># 1  0.976123  0.630320</span></span><br><span class="line"><span class="comment"># 2  0.205190  0.661562</span></span><br><span class="line"><span class="comment"># 3  0.963321  0.741791</span></span><br><span class="line"><span class="comment"># 4  0.585642  0.729366</span></span><br></pre></td></tr></table></figure>
<h6 id="panel数据索引">3.4.2 Panel数据索引</h6>
<p>Panel右三个数据索引，因此可使用它们获取相应的结果，这里使用<code>Items</code>访问<code>Panel</code>可以获取相应的<code>DataFrame</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = &#123;<span class="string">&#x27;Table1&#x27;</span>: pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line">                                   index=[<span class="string">&#x27;rank1&#x27;</span>, <span class="string">&#x27;rank2&#x27;</span>, <span class="string">&#x27;rank3&#x27;</span>, <span class="string">&#x27;rank4&#x27;</span>],</span><br><span class="line">                                   columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Score&#x27;</span>]),</span><br><span class="line">            <span class="string">&#x27;Table2&#x27;</span>: pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line">                                   index=[<span class="string">&#x27;rank1&#x27;</span>, <span class="string">&#x27;rank2&#x27;</span>, <span class="string">&#x27;rank3&#x27;</span>, <span class="string">&#x27;rank4&#x27;</span>],</span><br><span class="line">                                   columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Score&#x27;</span>]</span><br><span class="line">                                   )</span><br><span class="line">            &#125;</span><br><span class="line">    p = pd.Panel(data)</span><br><span class="line">    <span class="built_in">print</span>(p[<span class="string">&#x27;Table1&#x27;</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#            Name       Age     Score</span></span><br><span class="line"><span class="comment"># rank1 -1.240644 -0.820041  1.656150</span></span><br><span class="line"><span class="comment"># rank2  1.830655 -0.258068 -0.728560</span></span><br><span class="line"><span class="comment"># rank3  1.268695  1.259693 -1.005151</span></span><br><span class="line"><span class="comment"># rank4 -0.139876  0.611589  2.343394</span></span><br></pre></td></tr></table></figure></p>
<h6 id="panel属性">3.4.3 Panel属性</h6>
<ul>
<li><code>Panel.T</code>：转置行和列</li>
<li><code>Panel.axes</code>：返回一个列，行轴标签和列轴标签作为唯一的成员。</li>
<li><code>Panel.dtypes</code>：返回对象的数据类型</li>
<li><code>Panel.empty</code>：如果NDFrame完全为空，返回True</li>
<li><code>Panel.ndim</code>：返回轴/数组维度的大小</li>
<li><code>Panel.shape</code>：返回表示DataFrame维度的元组</li>
<li><code>Panel.size</code>：返回DataFrame的元素数</li>
<li><code>Panel.values</code>：将对象作为ndarray返回</li>
</ul>
<p><a href="https://blog.csdn.net/weixin_45698637/article/details/122766366">Pandas教程</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python面向对象</title>
    <url>/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h4 id="面向对象">1. 面向对象</h4>
<h5 id="类对象提供的默认行为">1.1 类对象提供的默认行为</h5>
<p>在python的面向对象模型种，要分清<strong>类对象</strong>和<strong>实例对象</strong>。类对象就是<code>class</code>定义了一个类只会，该类提供些行为就是类对象.而实例对象就是该类的实例。每次调用类，就会生成一个实例。 类对象提供的默认行为：</p>
<ul>
<li><code>class</code>语句创建类对象并将其赋值给变量名。就像<code>def</code>一样，class语句也是可执行语句，执行时会产生类对象，并赋值变量名</li>
<li>class语句的赋值语句会创建类属性，像模块文件一样，class语句内的顶层的赋值语句（不在<code>def</code>内）会成为类对象的属性。</li>
<li>类属性提供对象的状态（变量）和行为（函数）</li>
<li>类仍然时模块内的属性。当<code>class</code>执行时，只是赋值语句而已，赋值了一个类对象</li>
</ul>
<span id="more"></span>
<h5 id="实例对象是具体对象">1.2 实例对象是具体对象</h5>
<p>每当调用类对象时，就会生成示例对象：</p>
<ul>
<li>调用类对象会创建新的实例对象</li>
<li>每个示例对象有类的属性并且有自己的命名空间</li>
<li><strong><em>在方法内对self属性做赋值会产生每个实例自己的属性</em></strong>：在类函数内，第一个参数总是接受方法调用的隐形主体，通常用<code>self</code>会引用正处理的实例对象（相当于C/C++的<code>this指针</code>)。对<code>self</code>的属性做赋值运算，会创建或修改实例内的数据，而不是类的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">firstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.data=value;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data);</span><br><span class="line">    data=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">s=firstClass();</span><br><span class="line">s.printdata();	<span class="comment">#0</span></span><br><span class="line">s.setdata(<span class="number">10</span>);</span><br><span class="line">s.printdata();	<span class="comment">#10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>self</code>会自动引用正在处理的示例对象，所以赋值语句会把值村储到实例的命名空间。因为<strong>类对象</strong>会产生多个实例，函数必须经过<code>self</code>参数才能识别获取正在处理的实例（就看出时c/c++中隐藏的<code>this指针</code>就行了)</p>
<h5 id="继承">1.3 继承</h5>
<p>面向对象的一大特性就是继承，以下时python中继承的核心观点：</p>
<ul>
<li>父类列在类开头的括号处</li>
<li>子类从父类中继承了函数和属性</li>
<li>实例会继承所有可读取类的属性：每个实例会从创建它的类中获取变量名，此外还有该类的父类</li>
<li>每个<code>object.attribute</code>都会开启新的独立搜索：python会对每个属性取出表达式进行对类树的独立搜索，包括self</li>
<li>一般来说逻辑的修改都是通过继承的子类修改，而不是直接修改父类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">secondClass</span>(<span class="title class_ inherited__">firstClass</span>):</span><br><span class="line">	data=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这是第二个类&quot;</span>，sefl.data);</span><br><span class="line"></span><br><span class="line">a=secondClass();</span><br><span class="line">a.setdata(<span class="number">20</span>)</span><br><span class="line">a.printdata();		<span class="comment">#这是第二个类 20</span></span><br></pre></td></tr></table></figure>
<p>子类对属性的搜索会从下往上，即从子类到父类，直到所找属性名首次出现为止。上面的<code>printdata</code>函数覆盖了父类的<code>printdata</code>函数，这中覆盖叫做<code>重载</code>。</p>
<h5 id="类的运算符重载初识">1.4 类的运算符重载初识</h5>
<p><strong>运算符重载</strong>就是让类写成的对象可以截获并响应内置类型上的运算，如加法、切片和打印等等，在这里我们只是片面性的列举了一些重载以做了解，更加具体的将在后面介绍。运算符重载的主要注意点：</p>
<ul>
<li>运算符重载的命名方式为<code>__x__</code></li>
<li>当实例出现内置运算时，这类方法会自动调用。比如实例有<code>__add__</code>方法，当对象出现<code>+</code>表达式时，该方法就会调用</li>
<li>类可覆盖多数内置类型运算</li>
<li>运算符重载让类变得更趋像python的对象模型</li>
</ul>
<p><strong><em>注意</em></strong>：我们必须关心一个方法，那就是<code>__init__</code>方法，也称为<strong>构造函数</strong>,它用于初始化对象的状态的，<strong><em><code>__init__</code>和<code>self</code>是我们理解python面向对象特性的关键</em></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdClass</span>(<span class="title class_ inherited__">secondClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.data=value;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> ThirdClass(self.data+other);</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[ThirdClass:%s]&#x27;</span>% self.data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是ThirdClass&quot;</span>,self.data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=ThirdClass(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">a.printdata();</span><br><span class="line">a=a+<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">a.printdata();</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">这是ThirdClass abc</span><br><span class="line">这是ThirdClass abc123</span><br><span class="line">[ThirdClass:abc123]</span><br></pre></td></tr></table></figure> 从上面可以知道几点：</p>
<ol type="1">
<li><code>ThirdClass</code>调用传入一个参数，这是传给<code>__init__</code>构造函数的参数，即在在构建实例时自动调用<code>__init__</code>构造函数来初始化属性</li>
<li>有<code>__add__</code>函数后，即<code>+</code>运算符重载，<code>ThirdClass</code>的实例对象就可出现在<code>+</code>处，对与<code>+</code>，它把左侧的对象传给<code>self</code>，右侧的给<code>other</code>。执行完后，<strong>对于<code>__add__</code>来说要返回一个新的对象实例</strong></li>
<li>重载了<code>__str__</code>方法后，可以直接调用<code>print</code>打印对象</li>
</ol>
<h5 id="以实例介绍类的细节">1.5 以实例介绍类的细节</h5>
<h6 id="person和manager">1.5.1 person和manager</h6>
<p>在本节，将会两个类<code>person</code>和<code>manager</code>来介绍类实现的一些细节。顺带一提oython的%字符串格式为<code>&quot;%s,%d&quot; %(&quot;2222&quot;,10)</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,job=<span class="literal">None</span>,pay=<span class="number">0</span></span>):</span><br><span class="line">		self.name=name;</span><br><span class="line">		self.job=jon;</span><br><span class="line">		self.pay=pay;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span>  self.name.split()[-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self,percent</span>):</span><br><span class="line">		self.pay=<span class="built_in">int</span>(self.pay*(<span class="number">1</span>+percent))</span><br><span class="line">	<span class="comment">#print重载</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;[Person:%s,%s]&#x27;</span> % (self.name,self.pay)</span><br><span class="line"><span class="comment">#manager类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">	<span class="comment">#定制自己的构造函数，使用父类（超类）的构造函数构造</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,pay</span>):</span><br><span class="line">		self.person=Person.__init__(self,name,<span class="string">&#x27;mgr&#x27;</span>,pay);</span><br><span class="line">	<span class="comment">#重载函数，内部仍然使用超类的函数</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self,percent,bonus=<span class="number">1.0</span></span>):</span><br><span class="line">		person.giveRaise(self,percent+bonus);</span><br><span class="line">	<span class="comment">#改进点：</span></span><br><span class="line">	<span class="comment">#1. 使用内置的`Instance.__class__.__name__`,避免重复修改前部分的名称</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span><span class="string">&#x27;[%s:%s,%s]&#x27;</span> % (self.__class__.__name__,self.name,self.pay)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="对象持久化">1.5.2 对象持久化</h6>
<p>在上面我们创建的不是真正的数据库记录，如果关闭python，实例也将消失，因为它们是内存中的临时对象，这时可以使用python中<code>对象持久化</code>的功能，让对象在退出程序时依然存在。<strong>对象持久化</strong>通过3个标准库模块实现：</p>
<ul>
<li><code>pickle</code>:任意python对象和字节串之间的转化</li>
<li><code>dbm</code>：实现一个可通过键访问的文件系统，以存储字符串</li>
<li><code>shelve</code>:使用上面两个模块按照键把python对象存储到一个文件</li>
</ul>
<p>即<code>shelve</code>通过使用<code>pickle</code>将对象转为字符串，然后存储到一个<code>dbm</code>文件中键值对下，<code>shelve</code>通过键获取<code>pinkle</code>化的字符串，并用<code>pickle</code>在内存中重新创建最初对象。<code>shelve</code>就像字典一样，但是<code>shelve</code>一开始必须打开，并且在修改后关闭它 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">a=Person(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">b=Manager(<span class="string">&quot;小路&quot;</span>，<span class="number">1000</span>)</span><br><span class="line">db=shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">object</span> <span class="keyword">in</span>(a,b)</span><br><span class="line">	db[objecct.name]=<span class="built_in">object</span></span><br><span class="line">db.close();</span><br></pre></td></tr></table></figure> 此时，当前目录下会生成一个或多个名为<code>persondb</code>的文件</p>
<h5 id="抽象类">1.6 抽象类</h5>
<p>抽象类只是实现给继承者的一些接口，继承者类将接口实现什么功能完全由继承类决定，因此抽象接口类不能产生实例,只要类中有一个抽象方法，我们就不能创建该类的实例对象。在python3中，在<code>class</code>的头部使用一个关键字参数，以及特殊的<strong><span class="citation" data-cites="装饰器">@装饰器</span></strong>语法 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCmeta,abstractmethod</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>(metaclass=ABCmeta):</span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">method_1</span>(<span class="params">self,*args</span>):</span><br><span class="line">		<span class="keyword">pass</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="命名空间">1.7 命名空间</h5>
<p>我们知道点号和无点号的变量名，会用不同方式进行访问，还有一些作用域是用于对对象命名空间做初始而设定的（如模块和类），总结如下：</p>
<ul>
<li>无点号运算的变量民与作用域相对应（如普通的全局和局部赋值）</li>
<li>点号的属性名<code>object.x</code>使用的是对象的命名空间</li>
<li>有些作用域会对对象的命名空间初始化（模块和类）</li>
</ul>
<h5 id="运算符重载详解">1.8 运算符重载详解</h5>
<p>运算符重载是意味着给自定义类增加操作，在类方法中拦截内置操作，当类的实例出现内置操作时，python自动调用你的方法。以下时常见的运算符重载方法：</p>
<table>
<thead>
<tr class="header">
<th>运算符重载函数名</th>
<th>重载功能</th>
<th>调用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__init__</code></td>
<td>构造函数</td>
<td>实例创建时自动调用</td>
</tr>
<tr class="even">
<td><code>__del__</code></td>
<td>析构函数</td>
<td>实例对象回收时自动调用</td>
</tr>
<tr class="odd">
<td><code>__add__</code></td>
<td>运算符<code>+</code></td>
<td>如果没有<code>__iadd__</code>，<code>X+Y,X+=Y</code>时会调用</td>
</tr>
<tr class="even">
<td><code>__sub__</code></td>
<td>运算符<code>-</code></td>
<td><code>X-Y,X-=Y</code>调用</td>
</tr>
<tr class="odd">
<td><code>__repr__,__str__</code></td>
<td>打印，转换</td>
<td><code>print(x),repr(x),str(x)</code></td>
</tr>
<tr class="even">
<td><code>__call__</code></td>
<td>函数调用</td>
<td><code>X(*args,**dargs)</code></td>
</tr>
<tr class="odd">
<td><code>__getattr__</code></td>
<td>点号运算</td>
<td><code>X.undefined</code></td>
</tr>
<tr class="even">
<td><code>__setattr__</code></td>
<td>属性赋值语句</td>
<td><code>X.attribute=value</code></td>
</tr>
<tr class="odd">
<td><code>__delattr__</code></td>
<td>属性删除</td>
<td><code>del X.attribute</code></td>
</tr>
<tr class="even">
<td><code>__getattribute__</code></td>
<td>属性获取</td>
<td><code>X.attribute</code></td>
</tr>
<tr class="odd">
<td><code>__getitem__</code></td>
<td>索引运算</td>
<td><code>x[key],x[i:j]</code></td>
</tr>
<tr class="even">
<td><code>__setitem__</code></td>
<td>索引赋值语句</td>
<td><code>x[key]=value,x[i:j]=sequance</code></td>
</tr>
<tr class="odd">
<td><code>__delitem__</code></td>
<td>索引和分片删除</td>
<td><code>del x[key],del x[i:j]</code></td>
</tr>
<tr class="even">
<td><code>__iter__</code>,<code>__next___</code></td>
<td>迭代环境</td>
<td><code>i=iter(x),next(i)</code></td>
</tr>
<tr class="odd">
<td><code>__len__</code></td>
<td>长度</td>
<td>如果没有<code>__bool__</code>，直接<code>len(x)</code></td>
</tr>
<tr class="even">
<td><code>__bool__</code></td>
<td>布尔测试</td>
<td><code>bool(x)</code></td>
</tr>
<tr class="odd">
<td><code>__lt__</code>,<code>__gt__</code></td>
<td>比较</td>
<td>从左到右以此为<code>&lt;,&gt;</code></td>
</tr>
<tr class="even">
<td><code>__le__</code>,<code>__ge__</code></td>
<td>比较</td>
<td><code>&lt;=,&gt;=</code></td>
</tr>
<tr class="odd">
<td><code>__eq__</code>,<code>__ne__</code></td>
<td>比较</td>
<td><code>==,!=</code></td>
</tr>
<tr class="even">
<td><code>__contains__</code></td>
<td>成员关系测试</td>
<td><code>item in X</code></td>
</tr>
</tbody>
</table>
<p>由上面可知，运算符的重载前后都有两个下划线标识，以区分其他变量名函数。</p>
<h6 id="索引和分片__getitem__">1.8.1 索引和分片<code>__getitem__</code></h6>
<p>如果类中定义或者继承了该运算符，则对于实例的索引运算，会自动调用<code>__getitem__</code>,会把实例传递给第一个参数，方括号内的值则传递给后面的一个参数，<code>__setitem__</code>则加了一个值value参数。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">operatorOverload</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		self.L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,index</span>):</span><br><span class="line">		<span class="keyword">return</span> self.L[index];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,index,value</span>):</span><br><span class="line">		self.L[index]=value;</span><br><span class="line">x=operatorOverload();</span><br><span class="line"><span class="comment">#索引操作</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">2</span>]);	<span class="comment">#9</span></span><br><span class="line"><span class="built_in">print</span>(x.L);		<span class="comment">#[1,2,3,4]</span></span><br><span class="line"><span class="comment">#分片操作</span></span><br><span class="line"><span class="built_in">print</span>(x[::<span class="number">2</span>])	<span class="comment">#[1,3]</span></span><br><span class="line"><span class="comment">#赋值</span></span><br><span class="line">x[::<span class="number">2</span>]=[<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="built_in">print</span>(x[:])</span><br></pre></td></tr></table></figure></p>
<h6 id="索引迭代__iter__">1.8.2 索引迭代<code>__iter__</code></h6>
<p><code>__getitem__</code>有一个买一送一的情况，该重载不仅仅支持上面所讲的<strong>索引和分片功能</strong>,同时支持了<code>for</code>循环的迭代，<strong>当类中未定义<code>__iter__</code>时，即<code>for</code>循环每次循环时都会调用类的<code>__getitem__</code></strong>。其实不仅仅指<code>for</code>循环会调用，其他的迭代环境，如<code>in成员测试，列表解析,内置函数map，列表和元组赋值运算以及类型构造方法</code>也会自动调用该方法，只有类中没有<code>__iter__</code>. <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> x:	<span class="comment">#调用了__getitem__</span></span><br><span class="line">	<span class="built_in">print</span>(item,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h6 id="迭代器对象">1.8.3 迭代器对象</h6>
<p>尽管上面说的<code>__getitem__</code>支持迭代，但是它只是一直附加方法，真正的迭代还是要习惯用<code>__iter__</code>来获取迭代器，调用<code>__next__</code>访问，直到碰见异常<code>StopIteration</code>。python环境中所有迭代环境都是先尝试<code>__iter__</code>方法，然后再试<code>__getitem__</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IterTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> self.start==self.end:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration;</span><br><span class="line">		self.start+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> self.start**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">m=IterTest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">q=<span class="built_in">iter</span>(m);</span><br><span class="line"><span class="built_in">print</span>(q);		<span class="comment">#&lt;__main__.IterTest object at 0x00000168A41CDFF0&gt;</span></span><br><span class="line"><span class="comment">#print(next(q))	#1</span></span><br><span class="line">L=<span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">	L.append(x);</span><br><span class="line"><span class="built_in">print</span>(L);		<span class="comment">#[1, 4, 9, 16, 25]，当print(next(q))未注释，输出为[4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<p>上面可以看到，迭代器对象就是实例<code>self</code>，这是因为<code>__next__</code>使类方法。且上面定义的迭代器使像<strong>生成器函数和表达式、<code>map</code>和<code>zip</code>内置函数</strong>一样的单迭代对象，要达到多个迭代器的效果，<code>__iter__</code>只需替迭代器定义新的状态对象，而不是返回<code>self</code>，带来的消耗是要创建多个迭代对象: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NextTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> self.start==self.end:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration;</span><br><span class="line">		self.start+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> self.start**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IterTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> NextTest(self.start,self.end);</span><br><span class="line"></span><br><span class="line">m=IterTest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">q=<span class="built_in">iter</span>(m);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(q));		<span class="comment">#1</span></span><br><span class="line">L=<span class="built_in">list</span>();</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">	L.append(x);</span><br><span class="line"><span class="built_in">print</span>(L);			<span class="comment">#[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure></p>
<h6 id="成员关系">1.8.4 成员关系</h6>
<p>再迭代领域，类通常把<code>in</code>成员关系运算符实现为一个迭代，使用<code>__iter__</code>或着<code>__getitem__</code>。要支持更加特定的成员关系，类可能要编写一个<code>__contains__</code>方法，出现是，方法优先级是<code>contains&gt;iter&gt;getitem</code>。<code>__contains__</code>方法应该把成员关系定义为对一个<strong>映射</strong>应用键，用于序列的搜索 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContainsTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.data=value;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self,x</span>):</span><br><span class="line">		<span class="keyword">return</span> x <span class="keyword">in</span> self.data;</span><br><span class="line"></span><br><span class="line">m=ContainsTest([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Contains:&quot;</span>,<span class="number">3</span> <span class="keyword">in</span> m,end=<span class="string">&#x27; &#x27;</span>);		<span class="comment">#Contains: True</span></span><br></pre></td></tr></table></figure></p>
<h6 id="属性引用">1.8.5 属性引用</h6>
<p><code>__getattr__</code>方法是拦截属性点号运算，当通过对未定义（不存在）属性名称和实例进行点号运算时，就会用属性名称作为字符串调用这个方法，如果可以通过继承找到属性就不会调用这个方法。因此，<code>__getattr__</code>可以作为钩子通过这种方式响应属性请求： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">empty</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">___getattr__</span>(<span class="params">self,attrname</span>):</span><br><span class="line">		<span class="keyword">if</span> attrname=<span class="string">&quot;age&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> AttributeError,attrname</span><br><span class="line"></span><br><span class="line">x=empty();</span><br><span class="line">x.age		<span class="comment">#40</span></span><br><span class="line">x.name		<span class="comment">#AttributeError:name</span></span><br></pre></td></tr></table></figure> <code>__setattr__</code>会拦截所有属性的赋值语句,因此如果定义了这个方法要小心。除此之外，因为它对任何赋值语句都会拦截，即使是在<code>__setattr__</code>内也不例外，为防止无限递归，要使用该方法，必须通过<strong>属性字典</strong>做索引来赋值任何实例属性<code>self.__dict__[attr]=value;</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self,attrname,value</span>):</span><br><span class="line">		<span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">			self.__dict__[attr]=value;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">raise</span> AttriubteError, attrname+<span class="string">&#x27;nor allowed&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="call表达式">1.8.6 call表达式</h6>
<p>当调用实例时，使用<code>__call__</code>。如果定义该方法，python1就会为实例应用函数调用表达式运行<code>__call__</code>。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,*args,**agrv</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;called:&#x27;</span>,args,argv);</span><br><span class="line">c=Test();</span><br><span class="line">c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,x=<span class="number">4</span>,y=<span class="number">5</span>);	<span class="comment">#called:(1,2,3)&#123;&#x27;x&#x27;=4,&#x27;y&#x27;=5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="布尔测试">1.8.7 布尔测试</h6>
<p>python首先尝试<code>__bool__</code>来直接获取一个<code>bool</code>值，如果没有该方法，就尝试<code>__len__</code>，根据对象的长度确定一个真值。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.data=value;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span>(self.data!=<span class="literal">None</span>):</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span>;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(self.data);</span><br><span class="line">x=Truth(<span class="string">&quot;12314&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;bool yes!&#x27;</span>);	<span class="comment">#bool yes!</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(x):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;len yes!&#x27;</span>);	<span class="comment">#len yes!</span></span><br></pre></td></tr></table></figure></p>
<h6 id="迭代环境__next__和__iter__">1.8.8 迭代环境<code>__next__</code>和<code>__iter__</code></h6>
<p>python对于创建得类允许自定义迭代环境，如果用户需要定义迭代环境，必须 - 实现<code>__iter__</code>和<code>__next__</code>函数， - 同时在<code>__next__</code>函数中指定迭代退出环境,一般为产生一个异常<code>raise</code> - 在迭代中<code>__next__</code>中实现迭代对象，返回该对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def __iter__(self):</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">def __next__(self):</span><br><span class="line">    <span class="keyword">if</span> self.Next is None:</span><br><span class="line">        raise StopIteration</span><br><span class="line">    self.currentNode=self.Next</span><br><span class="line">    self.Next=self.Next.next</span><br><span class="line">    <span class="keyword">return</span> self.currentNode</span><br></pre></td></tr></table></figure>
<h6 id="section">1.8.9</h6>
<h5 id="类的设计">1.9 类的设计</h5>
<p>无论是哪门语言，对于OOP，其重要的三个面向对象特性：继承、多态、封装。在python，这三个特性作用也是一样：</p>
<ul>
<li>继承：提高代码的复用性</li>
<li>多态：提高程序的可扩展性和可维护性</li>
<li>封装：方法和运算符实现行为，数据隐藏是一种惯例，以此提高程序安全性</li>
</ul>
<h6 id="封装">1.9.1 封装</h6>
<p>封装提高程序的安全性。将数据（属性）和行为（方法）包装到类对象中，在方法内部对属性进行操作，在类对象的外部调用方法，这样无需关心方法内部的具体实现细节，从而隔离了复杂度；在python中没有专门的修饰符用于属性的私有，如果该属性不希望在类对象外部被访问，前边使用两个<code>_</code>修饰 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.__age=age  <span class="comment">#年龄不希望在类的外部被使用，所以加了两个__</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.__age)</span><br><span class="line">stu1=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">stu1.show()</span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br><span class="line"><span class="comment">#print(stu1.__age)   #这句话会报错，因为__age不希望在类外面使用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;如果想在类之外使用，可以用_类名__实例属性来用&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(stu1._Student__age)</span><br></pre></td></tr></table></figure></p>
<h6 id="继承-1">1.9.2 继承</h6>
<p>在python中，如果一个类没有继承任何类，则默认继承object。python支持多继承，<strong>定义子类时，必须在其构造函数中调用父类的构造函数</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,stu_num</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.stu_num=stu_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,teachofyear</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.teachofyear=teachofyear</span><br><span class="line"></span><br><span class="line">stu=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>,<span class="number">1001</span>)</span><br><span class="line">teach=Teacher(<span class="string">&#x27;李四&#x27;</span>,<span class="number">40</span>,<span class="number">20</span>)</span><br><span class="line">stu.info()</span><br><span class="line">teach.info()</span><br></pre></td></tr></table></figure> 如上，如果子类对继承父类中的某个属性或方法不满意，可以在子类中对其（方法体）进行重新编写.<strong>子类重写后的方法中可以通过<code>super().xxx()</code>调用父类中被重写的方法</strong>。</p>
<p>另外一点，在python中object类是所有类的父类，因此所有类都有object类的属性和方法。有内置函数dir()可以查看指定对象所有属性。object还有有一个<code>__str__()</code>方法，用于返回一个对于“对象的描述”，对应于内置函数<code>str()</code>经常用于<code>print()</code>方法，帮我们查看对象的信息，所以我们经常会对<code>__str__()</code>进行重写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我的名字是&#123;0&#125;,今年&#123;1&#125;岁&#x27;</span>.<span class="built_in">format</span>(self.name,self.age)</span><br><span class="line">stu=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(stu))</span><br><span class="line"><span class="built_in">print</span>(stu)  <span class="comment">#默认会调用__str__()这样的方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(stu))</span><br></pre></td></tr></table></figure>
<h6 id="多态">1.9.3 多态</h6>
<p>多态就是“具有多种形态”,它指的是：即便不知道一个变量所引用的对象到底是 什么类型，仍然可以通过这个变量调用方法，在运行过程中根据变量所引用对象的类型， 动态决定调用哪个对象中的方法。实现多态必须有的三个条件：</p>
<ul>
<li>继承</li>
<li>方法重写</li>
<li>父类引用指向子类对象 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动物会吃&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;狗吃骨头&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猫吃鱼&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;人吃五谷杂粮&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.eat()</span><br><span class="line">fun(Cat())</span><br><span class="line">fun(Dog())</span><br><span class="line">fun(Animal())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;——————————&#x27;</span>)</span><br><span class="line">fun(Person())</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="类的浅拷贝和深拷贝">1.9.4 类的浅拷贝和深拷贝</h6>
<ul>
<li><strong>变量的赋值操作</strong>：只是形成两个变量，实际上还是指向同一个对象</li>
<li><strong>浅拷贝</strong>：python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，源对象与拷贝对象会引用同一个子对象</li>
<li><strong>深拷贝</strong>：使用copy模块的<code>deepcopy</code>函数，递归拷贝对象中包含的子对象，源对象和拷贝 对象所有的子对象也不相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Disk</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,cpu,disk</span>):</span><br><span class="line">        self.cpu=cpu</span><br><span class="line">        self.disk=disk</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.变量的赋值</span></span><br><span class="line">cpu1=CPU()</span><br><span class="line">cpu2=cpu1</span><br><span class="line"><span class="built_in">print</span>(cpu1)</span><br><span class="line"><span class="built_in">print</span>(cpu2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.类的浅深拷贝</span></span><br><span class="line">disk=Disk() <span class="comment">#创建一个硬盘类的对象</span></span><br><span class="line"><span class="built_in">print</span>(disk)</span><br><span class="line">computer=Computer(cpu1,disk)    <span class="comment">#创建一个计算机类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#浅拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">computer2=copy.copy(computer)</span><br><span class="line"><span class="built_in">print</span>(computer,computer.cpu,computer.disk)</span><br><span class="line"><span class="built_in">print</span>(computer2,computer2.cpu,computer2.disk)</span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝</span></span><br><span class="line">computer3=copy.deepcopy(computer)</span><br><span class="line"><span class="built_in">print</span>(computer,computer.cpu,computer.disk)</span><br><span class="line"><span class="built_in">print</span>(computer3,computer3.cpu,computer3.disk)</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//赋值就是简单的变量引用同一个对象</span><br><span class="line">&lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt;</span><br><span class="line">&lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#浅拷贝，对象包含的的子对象内容不拷贝，都引用同一个内容</span></span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615ED70</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615F820</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝，子对象也拷贝了</span></span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615ED70</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615DD50</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615D450</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615D3F0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="设计模式之委托模式">1.9.5 设计模式之委托模式</h6>
<p>所谓的<strong>委托</strong>，<strong>通常就是指控制对象内嵌其他对象，而把运算请求传给这些内嵌对象处理，控制器对象只负责管理工作</strong>。在python中，委托通常用<code>__getattr__</code>钩子方法实现，因为这个方法会拦截对不存在属性的读取，因此代理类可以使用<code>__getattr__</code>把任意读取操作转给被包装对象。 简而言之：通过一个类来调用另一个类里的方法来处理请求，即这两个类对象参与处理同一个请求对象，只不过一个是<strong>委托者</strong>，一个是<strong>处理者</strong>。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,<span class="built_in">object</span></span>):</span><br><span class="line">		self.wrapped=<span class="built_in">object</span>;	<span class="comment">#内嵌对象</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self,attrname</span>):</span><br><span class="line">		<span class="keyword">if</span> attrname==<span class="string">&#x27;append&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped,attrname);</span><br><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">x=wrapper(L);</span><br><span class="line">x.append(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">print</span>(L)			<span class="comment">#[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure> 上述代码中，因为<code>x.append(4)</code>未在<code>wrapper</code>内定义，触发<code>__getattr__</code>函数,<code>getattr(x,y)</code>函数的作用就是点操作，即<code>x.y</code>。</p>
<h6 id="绑定和无绑定方法">1.9.6 绑定和无绑定方法</h6>
<ul>
<li>实例的绑定方法：即有<code>self</code>，且在类中没有被任何装饰器修饰的方法就是绑定到对象的方法，这类方法专门为对象定制。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    country = <span class="string">&quot;China&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">str</span>(self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;Kitty&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p.__dict__)</span><br><span class="line">p.speak()   <span class="comment">#通过对象调用 Kitty, 18</span></span><br><span class="line">Person.speak(p)   <span class="comment">#通过类调用Kitty, 18</span></span><br></pre></td></tr></table></figure>
<p>通过对象调用绑定到对象的方法，会有一个自动传值的过程，即自动将当前对象传递给方法的第一个参数（<code>self</code>，一般都叫<code>self</code>，也可以写成别的名称）；若是使用类调用，则第一个参数需要手动传值。</p>
<ul>
<li>类的绑定方法:类中使用<code>@classmethod</code>修饰的方法就是绑定到类的方法。这类方法专门为类定制。通过类名调用绑定到类的方法时，会将类本身当做参数传给类方法的第一个参数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operate_database</span>():</span><br><span class="line">    host = <span class="string">&#x27;192.168.0.5&#x27;</span></span><br><span class="line">    port = <span class="string">&#x27;3306&#x27;</span></span><br><span class="line">    user = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">cls</span>):  <span class="comment"># 约定俗成第一个参数名为cls，也可以定义为其他参数名</span></span><br><span class="line">        <span class="built_in">print</span>(cls)</span><br><span class="line">        <span class="built_in">print</span>(cls.host + <span class="string">&#x27;:&#x27;</span> + cls.port + <span class="string">&#x27; &#x27;</span> + cls.user + <span class="string">&#x27;/&#x27;</span> + cls.password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Operate_database.connect();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Operate_database&#x27;</span>&gt;</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span>:<span class="number">3306</span> abc/<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>非绑定方法:在类内部使用 <span class="citation" data-cites="staticmethod">@staticmethod</span> 修饰的方法即为非绑定方法，这类方法和普通定义的函数没有区别，不与类或对象绑定，谁都可以调用(实例和类都可以)，且没有自动传值的效果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operate_database</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port, user, password</span>):</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_passwrod</span>(<span class="params">salt, password</span>):</span><br><span class="line">        m = hashlib.md5(salt.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 加盐处理</span></span><br><span class="line">        m.update(password.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">hash_password = Operate_database.get_passwrod(<span class="string">&#x27;lala&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)  <span class="comment"># 通过类来调用</span></span><br><span class="line"><span class="built_in">print</span>(hash_password)</span><br><span class="line"></span><br><span class="line">p = Operate_database(<span class="string">&#x27;192.168.0.5&#x27;</span>, <span class="string">&#x27;3306&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line">hash_password = p.get_passwrod(p.user, p.password)  <span class="comment"># 也可以通过对象调用</span></span><br><span class="line"><span class="built_in">print</span>(hash_password)</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f7a1cc409ed6f51058c2b4a94a7e1956</span><br><span class="line">0659c7992e268962384eb17fafe88364</span><br></pre></td></tr></table></figure></p>
<h5 id="棱形继承">1.10 棱形继承</h5>
<p>在多层继承和多继承同时使用的情况下，就会出现复杂的继承关系，即重重复继乘，常说的<strong>菱形继承</strong> <img src="/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/lengxing.png" width="300"> 在这种结构中，在调用顺序上就出现了疑惑，调用顺序究竟是以下哪一种顺序呢,如果是深度，那么A会重复调用，造成不必要的消耗</p>
<ul>
<li><code>D-&gt;B-&gt;A-&gt;C-&gt;A（深度优先）</code></li>
<li><code>D-&gt;B-&gt;C-&gt;A（广度优先）</code></li>
</ul>
<p>上面问题的根源都跟MRO有关,MRO(Method Resolution Order)也叫方法解析顺序，主要用于在多重继承时判断调的属性来自于哪个类，其使用了一种叫做C3的算法，其基本思想时在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则去寻找需要的属性和方法。 <strong>要避免顶层父类某个方法被多次调用，此时就需要super()来发挥作用了,super本质上是一个类，内部记录着MRO信息，由于C3算法确保同一个类只会被搜寻一次，这样就避免了顶层父类中的方法被多次执行了</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意，这段代码是个特例，在D的注释处明显调用了B/C的构造函数，所有会执行两次A的构造函数，要使其不执行两次，则需要使用super().xxx()。这种方法很常用，应该熟记</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init A...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end A...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init B...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(B, self).__init__()</span><br><span class="line">		<span class="comment"># A.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end B...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init C...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(C, self).__init__()</span><br><span class="line">		<span class="comment"># A.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end C...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init D...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(D, self).__init__()</span><br><span class="line">		<span class="comment">#B.__init__(self)</span></span><br><span class="line">        <span class="comment">#C.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end D...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    D()</span><br></pre></td></tr></table></figure> 输出：采用广度优先搜索 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init D...</span><br><span class="line">init B...</span><br><span class="line">init C...</span><br><span class="line">init A...</span><br><span class="line">end A...</span><br><span class="line">end C...</span><br><span class="line">end B...</span><br><span class="line">end D...</span><br><span class="line"></span><br></pre></td></tr></table></figure> 值得一提的是Python类分为两种，一种叫经典类，一种叫新式类。都支持多继承，但继承方式不同：</p>
<ul>
<li><strong>新式类</strong>：从object继承来的类。（如:class A(object)），采用广度优先搜索的方式继承（即先水平搜索，再向上搜索）。</li>
<li><strong>经典类</strong>：不从object继承来的类。（如：class A()），采用深度优先搜索的方式继承（即先深入继承树的左侧，再返回，再找右侧）。</li>
</ul>
<p><strong><em>注意：Python2.x中类的是有经典类和新式类两种。Python3.x中都是新式类（类都默认继承object）。因此对于多重继承，顺序很重要，他会根据继承类在首行位置，从左到右搜索</em></strong> 实例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    attr=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    attr=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B,C):</span><br><span class="line">    <span class="keyword">pass</span>;</span><br><span class="line"></span><br><span class="line">M=D();</span><br><span class="line"><span class="built_in">print</span>(M.attr)		<span class="comment">#2</span></span><br></pre></td></tr></table></figure> 上面的代码输出为2，先解释一下：因为B、C都继承自A，D继承自B，那么在python3.x版本以上，采用了广度优先，顺序是<code>D-&gt;B-&gt;C-&gt;A</code>,在C时遇到了属性<code>attr=2</code>，停止搜索返回，输出为2</p>
<h6 id="super详解">1.10.1 super详解</h6>
<p>上面已经提到了，在python3.x版本上，都使用新式类，python避免重复调用是采用<strong>MRO(Method Resolution Order)机制也叫方法解析顺序，主要用于在多重继承时判断调的属性来自于哪个类，其使用了一种叫做C3的算法，其基本思想时在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则去寻找需要的属性和方法。</strong></p>
<p><code>super</code>本质上是一个类，但super() 和父类没有实质性的关联：</p>
<ul>
<li><code>super()</code>函数需要两个参数，第一个是类名，第二个是一般都为<code>self</code>但也会有<code>cls</code>情况，但在python3.x中使用<code>super().xxxx()</code>等同于<code>super(classname,self).xxxx()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;B&quot;</span>)</span></span><br><span class="line"><span class="function">        super().__init__()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class C(A):</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;C&quot;</span>)</span></span><br><span class="line"><span class="function">        super(C, self).__init__()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class D(B,C):</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;D&quot;</span>,D.__mro__)</span></span><br><span class="line"><span class="function">        super(D, self).__init__()</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">#输出</span></span><br><span class="line"><span class="function">D (&lt;class <span class="string">&#x27;ListNode.D&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.B&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.C&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.A&#x27;</span>&gt;, &lt;class <span class="string">&#x27;object&#x27;</span>&gt;)</span></span><br><span class="line"><span class="function">B</span></span><br><span class="line"><span class="function">C</span></span><br><span class="line"><span class="function">A</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p><code>super</code>工作原理：如果在类D中调用<code>super()</code>会传入D类，那就会在它<code>__mro__</code>上一级开始查找，它的上一级是B，就会调用B的函数，依次类推下去。如下更改D类的<code>super()</code>输出改变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;D&quot;</span>,D.__mro__)</span></span><br><span class="line"><span class="function">        super(C, self).__init__()</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">#输出：</span></span><br><span class="line"><span class="function">D (&lt;class <span class="string">&#x27;ListNode.D&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.B&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.C&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.A&#x27;</span>&gt;, &lt;class <span class="string">&#x27;object&#x27;</span>&gt;)</span></span><br><span class="line"><span class="function">A</span></span><br></pre></td></tr></table></figure>
<p>因为上一级是<code>__mro__</code>中C的上一级是A，就好执行A的<code>__init__()</code>函数</p>
<h5 id="slots可选">1.11 slots（可选）</h5>
<p>python类有一个双刃剑就是：即使我们没有在类内部创建属性，也可以在实例对象中通过<code>.</code>给实例对象创建一个属于实例的属性，这样听起来非常bug，不像java和c++这样有很好的封装性: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a=A();</span><br><span class="line">a.p=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">print</span>(a.p) <span class="comment">#20</span></span><br></pre></td></tr></table></figure> 之前提到过<code>__getattr__</code>能够对未在类内创建的属性提供操作。这里介绍python提供的<code>slots</code>来支持这一功能。 这个特殊属性一般是在类的顶层内将变量名称（字符串形式）按顺序赋值给变量<code>__slots__</code>，<strong>该属性规定：只有<code>__slots__</code>列表内的这些变量名可赋值为实例属性</strong>。它也要遵循python的规则，实例属性名必须在引用前赋值 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>:</span><br><span class="line">	__slots__=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=limiter();</span><br><span class="line"><span class="comment">#print(x.age)		#AttributeError,未赋值就引用</span></span><br><span class="line">x.age=<span class="number">40</span></span><br><span class="line"><span class="built_in">print</span>(x.age)		<span class="comment">#40</span></span><br><span class="line">x.jk=<span class="number">2</span>;				<span class="comment">#不允许，变量名不在__slots__</span></span><br></pre></td></tr></table></figure> 但是注意，类中有<code>__slots__</code>会没有<code>__dict__</code>属性，事实上，<code>__slots__</code>就是以<code>__dict__</code>的代价来起到这样一个功能的： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>:</span><br><span class="line">	__slots__=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>,<span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=limiter();</span><br><span class="line">x.jk=<span class="number">2</span>;				<span class="comment">#运行成功</span></span><br></pre></td></tr></table></figure> 没有<code>__dict__</code>，我们就不能在类的函数内随便起变量名，因此对于<code>__slots__</code>看情况使用</p>
<h5 id="装饰器">1.12. 装饰器</h5>
<p>装饰器一般有函数装饰器和类装饰器。装饰器即指通过对函数的包装来修改其他函数的功能的函数。我们知道在python中可以嵌套定义函数，<strong>但是我们外部无法直接访问嵌套内部函数，好在可以将一个函数名赋值给一个变量，其实函数名就是一个变量，只不过指向函数对象，也可通过返回函数变量名</strong>，然后通过变量名去调用<code>变量名()</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">hi</span><span class="params">(name=<span class="string">&quot;yasoob&quot;</span>)</span>:</span></span><br><span class="line"><span class="function">    def greet():</span></span><br><span class="line"><span class="function">        return <span class="string">&quot;now you are in the greet() function&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    def welcome():</span></span><br><span class="line"><span class="function">        return <span class="string">&quot;now you are in the welcome() function&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    if name =</span>= <span class="string">&quot;yasoob&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> greet</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"> </span><br><span class="line">a = <span class="built_in">hi</span>()		#返回great</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">a</span>())				#调用<span class="built_in">a</span>()==<span class="built_in">great</span>()</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">&lt;function greet at <span class="number">0x7f2143c01500</span>&gt;</span><br><span class="line">now you are in the <span class="built_in">greet</span>() function</span><br></pre></td></tr></table></figure></p>
<p>既然我们能够将函数作为变量，那么变量当然可以作为参数，当我们将函数变量作为参数传递给另外一个函数时，就会产生装饰器的知识，实际上装饰器就是做这种事： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    def wrapTheFunction():</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">        a_func()</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    return wrapTheFunction</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">def a_function_requiring_decoration():</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration()</span></span><br><span class="line"><span class="function">#outputs: <span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration =</span> <span class="built_in">a_new_decorator</span>(a_function_requiring_decoration)</span><br><span class="line"><span class="meta">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">a_function_requiring_decoration</span>()</span><br><span class="line"><span class="meta">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line">#        I am the function which needs some decoration to remove my foul smell</span><br><span class="line">#        <span class="function">I am doing some boring work after executing <span class="title">a_func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="函数装饰器">1.12.1 函数装饰器</h6>
<p>上面讲解了函数装饰器的原理，提供了一种方式声明函数的特定运算模式，其原理是将函数包裹到另一个函数，在另一个函数的逻辑内实现。<strong>现在为简化其实现，使用<code>@</code>代替这些代码，所以函数装饰器在def语句前一行，由<code>@符号、后面跟着所谓的元函数</code></strong>组成。元函数就是管理另一函数（或其他可调用对象）的函数,如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@<span class="function">a_new_decorator</span></span><br><span class="line"><span class="function">def <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span></span><br><span class="line"><span class="function">          <span class="string">&quot;remove my foul smell&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration()</span></span><br><span class="line"><span class="function">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="function">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="function">#         I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure> 上面的<code>@a_new_decorator</code>等价于<code>a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration</code></p>
<p><strong>python内置的装饰器：</strong></p>
<ul>
<li><code>@classmethod</code>：修饰类内的方法是绑定到类的方法，该方法专门为类提供，会将类本身当作参数传给类方法的第一个参数，不需要使用对象调用当然你可以使用对象调用。</li>
<li><code>@staticmethod</code>：在类内部使用该装饰器修饰方法，这类方法不与类或对象绑定，属于静态方法，谁都可以调用，且没有自动传值功能。</li>
<li><code>@wraps(函数变量名)</code>；在上面举例的函数装饰器<code>@a_new_decorator</code>中会改变函数的<code>__name__</code>为<code>wrapTheFunction</code>，正常应该为<code>a_function_requiring_decoration</code>。这时候就需要使用<code>@wraps()</code>装饰器 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: wrapTheFunction</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="comment">#使用@wraps()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_new_decorator</span>(<span class="params">a_func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">a_func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapTheFunction</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requiring_decoration</span>():</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"><span class="comment">#输出正常</span></span><br><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: a_function_requiring_decoration</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="类装饰器">1.12.2 类装饰器</h6>
<p>类装饰器类似于函数装饰器（后续补充）</p>
<h4 id="链表实现">2. 链表实现</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value,<span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.value=value</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;节点已删除&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,Size=<span class="number">0</span>,pHead=<span class="literal">None</span></span>):</span><br><span class="line">        self.pHead=pHead</span><br><span class="line">        self.Next=pHead</span><br><span class="line">        self.Size=Size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已注销&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.Next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.currentNode=self.Next</span><br><span class="line">        self.Next=self.Next.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> self.currentNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Crease</span>(<span class="params">self</span>):</span><br><span class="line">        self.Size+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DeCrease</span>(<span class="params">self</span>):</span><br><span class="line">        self.Size-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node=ListNode(value)</span><br><span class="line">        <span class="comment">#判断是否为空链表</span></span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.pHead=node</span><br><span class="line">            <span class="keyword">return</span> self.pHead;</span><br><span class="line">        <span class="comment">#找到最后一个节点</span></span><br><span class="line">        current_Node=self.pHead;</span><br><span class="line">        preNode=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current_Node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode=current_Node</span><br><span class="line">            current_Node=current_Node.<span class="built_in">next</span></span><br><span class="line">        preNode.<span class="built_in">next</span>=node</span><br><span class="line">        self.Crease()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">erase</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            preNode=<span class="literal">None</span></span><br><span class="line">            current_node=self.pHead;</span><br><span class="line">            <span class="keyword">while</span> current_node!=<span class="literal">None</span> <span class="keyword">and</span> current_node.value != value:</span><br><span class="line">                preNode=current_node</span><br><span class="line">                current_node=current_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> preNode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">             self.pHead=self.pHead.<span class="built_in">next</span></span><br><span class="line">             self.DeCrease()</span><br><span class="line">             <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">elif</span> current_node.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode.<span class="built_in">next</span>=current_node.<span class="built_in">next</span></span><br><span class="line">            self.DeCrease()</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">return</span> self.pHead</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,value</span>):</span><br><span class="line">        Next=self.pHead</span><br><span class="line">        <span class="keyword">while</span> Next.value <span class="keyword">is</span> <span class="keyword">not</span> value:</span><br><span class="line">            Next=Next.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> Next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        current_node=self.pHead</span><br><span class="line">        preNode=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current_node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode=current_node</span><br><span class="line">            current_node=current_node.<span class="built_in">next</span></span><br><span class="line">        preNode.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        self.DeCrease()</span><br><span class="line">        <span class="keyword">return</span> current_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        retNode=self.pHead</span><br><span class="line">        self.pHead=self.pHead.<span class="built_in">next</span></span><br><span class="line">        self.DeCrease()</span><br><span class="line">        <span class="keyword">return</span> retNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_front</span>(<span class="params">self,value</span>):</span><br><span class="line">        node = ListNode(value)</span><br><span class="line">        self.Next=self.pHead</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.pHead=node</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        node.<span class="built_in">next</span>=self.pHead</span><br><span class="line">        self.pHead=node</span><br><span class="line">        self.Crease()</span><br><span class="line">        self.Next=self.pHead</span><br><span class="line">        <span class="keyword">return</span> self.pHead</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch基础</title>
    <url>/2022/10/06/pytorch%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="pytorch简介">1、pytorch简介</h4>
<p>pytorch是一个基于Python的科学计算包，PyTorch 的设计遵循tensor→variable(autograd)→nn.Module 三个由低到高的抽象层次，分别代表高维数组（张量）、自动求导（变量）和神经网络（层/模块），而且这三个抽象之间联系紧密，可以同时进行修改和操作。它主要有两个用途：</p>
<ul>
<li>类似于Numpy但是能利用GPU加速</li>
<li>一个非常灵活和快速用于深度学习的研究平台</li>
</ul>
<span id="more"></span>
<h4 id="基本数据结构tensor">2、基本数据结构：Tensor</h4>
<p>Tensor在pttorch中负责存储基本数据，ptyTorch针对Tensor也提供了丰富的函数和方法，所以pyTorch中的Tensor与Numpy的数组具有极高的相似性。Tensor是一种高级的API。</p>
<p><strong>Tensor即张量，张量是Pytorch的核心概念，pytorch的计算都是基于张量的计算，是PyTorch中的基本操作对象，可以看做是包含单一数据类型元素的多维矩阵</strong>。从使用角度来看，Tensor与NumPy的ndarrays非常类似，相互之间也可以自由转换，只不过Tensor还支持GPU的加速</p>
<table>
<thead>
<tr class="header">
<th>数据类型</th>
<th>CPU Tensor</th>
<th>GPU Tensor</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>32位浮点</td>
<td><code>torch.FloatTensor</code></td>
<td><code>torch.cuda.FloatTensor</code></td>
</tr>
<tr class="even">
<td>64位浮点</td>
<td><code>torch.DoubleTensor</code></td>
<td><code>torch.cuda.DoubleTensor</code></td>
</tr>
<tr class="odd">
<td>16位半精度浮点</td>
<td><code>N/A</code></td>
<td><code>torch.cuda.HalfTensor</code></td>
</tr>
<tr class="even">
<td>8位无符号整型</td>
<td><code>torch.ByteTensor</code></td>
<td><code>torch.cuda.ByteTensor</code></td>
</tr>
<tr class="odd">
<td>8位有符号整型</td>
<td><code>torch.charTensor</code></td>
<td><code>torch.cuda.charTensor</code></td>
</tr>
<tr class="even">
<td>16位有符号整型</td>
<td><code>torch.ShortTensor</code></td>
<td><code>torch.cuda.ShortTensor</code></td>
</tr>
<tr class="odd">
<td>32位有符号整型</td>
<td><code>torch.IntTensor</code></td>
<td><code>torch.cuda.IntTensor</code></td>
</tr>
<tr class="even">
<td>64位有符号整型</td>
<td><code>torch.LongTensor</code></td>
<td><code>torch.cuda.LongTensor</code></td>
</tr>
</tbody>
</table>
<p>pytorch不支持str类型</p>
<h5 id="tensor的创建">2.1 Tensor的创建</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.tensor(data, </span><br><span class="line">             dtype=<span class="literal">None</span>, </span><br><span class="line">             device=<span class="literal">None</span>, </span><br><span class="line">             requires_grad=<span class="literal">False</span>, </span><br><span class="line">             pin_memory=<span class="literal">False</span>) -&gt; Tensor</span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code>：数据，可以是list，也可以是numpy</li>
<li><code>dtype</code>：数据类型，默认和data一致</li>
<li><code>device</code>：tensor所在的设备</li>
<li><code>requires_grad</code>：是否需要梯度，默认False，在搭建神经网络时需要将求导的参数设为True</li>
<li><code>pin_memory</code>：是否存于锁页内存，默认False</li>
</ul>
<p>还有其他的按数值创建的方法，这里只列举一个： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.zeros(*size, </span><br><span class="line">            out=<span class="literal">None</span>, </span><br><span class="line">            dtype=<span class="literal">None</span>, </span><br><span class="line">            layout=torch.strided, </span><br><span class="line">            device=<span class="literal">None</span>, </span><br><span class="line">            requires_grad=<span class="literal">False</span>) -&gt; Tensor</span><br></pre></td></tr></table></figure> - <code>size</code>：张量的形状，如（3，3） - <code>layout</code> ：这个是内存中的布局形式,有strided和sparse_coo等 - <code>out</code>：表示输出张量，就是再把这个张量赋值给别的一个张量，但是这两个张量时一样的，指的同一个内存地址 - <code>device</code>：所在的设备，gpu/cpu - <code>requires_grad</code>：是否需要梯度</p>
<p><img src="/2022/10/06/pytorch%E5%9F%BA%E7%A1%80/build.png" width="500"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用特定类型构造函数创建</span></span><br><span class="line">i=torch.FloatTensor(<span class="number">2</span>,<span class="number">3</span>)						<span class="comment">#构造了一个2*3的32位浮点矩阵，初始值为0</span></span><br><span class="line">b=torch.FloatTensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])			<span class="comment">#使用列表构造一个2*3的2维张量</span></span><br><span class="line"><span class="comment">#使用tensor函数</span></span><br><span class="line">a=torch.tensor([[<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>]],dtype=<span class="built_in">float</span>)	<span class="comment">#dtype指定类型，如果省略则自动推断</span></span><br><span class="line"><span class="comment">#使用其他函数</span></span><br><span class="line">t=torch.randn(<span class="number">2</span>,<span class="number">2</span>)								<span class="comment">#生一个2*2随机2维张量</span></span><br><span class="line"><span class="comment">#如果张量中只有一个元素, 可以用.item()将值取出, 作为一个python number</span></span><br><span class="line">x = torch.randn(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(x.item())</span><br></pre></td></tr></table></figure>
<h5 id="张量的尺寸">2.2 张量的尺寸</h5>
<p><strong>可以使用<code>shape</code>属性或者<code>size()</code>方法查看张量在每一维的长度.</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=torch.randn(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(t.shape,t.size())</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.Size([<span class="number">2</span>, <span class="number">2</span>]) torch.Size([<span class="number">2</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure></p>
<p>也能使用可以使用<code>view()</code>方法改变张量的尺寸。如果<code>view()</code>方法改变尺寸失败，可以使用<code>reshape()</code>方法 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=torch.FloatTensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">m=b.view(<span class="number">3</span>,<span class="number">2</span>)									<span class="comment">#将2*3转为3*2</span></span><br></pre></td></tr></table></figure> 有些时候有些操作会让张量存储结构扭曲，比如转置，直接使用view会失败，可以用reshape方法 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m=b.reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="tensor和numpy数组">2.3 Tensor和numpy数组</h5>
<p>可以用numpy方法从Tensor得到numpy数组，也可以用torch.from_numpy从numpy数组得到Tensor。<strong>这两种方法关联的Tensor和numpy数组是共享数据内存的，即改变其中一个，另一个也会发生改变</strong>。因此如果不需要共享，可以用张量的<code>clone()</code>方法拷贝张量，中断这种关联 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment">#torch.from_numpy函数从numpy数组转为Tensor</span></span><br><span class="line">arr = np.zeros(<span class="number">3</span>)</span><br><span class="line">tensor = torch.from_numpy(arr)</span><br><span class="line">np.add(arr,<span class="number">1</span>, out = arr) 		<span class="comment">#给arr增加1，tensor也随之改变</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用clone</span></span><br><span class="line"><span class="comment"># 可以用clone() 方法拷贝张量，中断这种关联</span></span><br><span class="line">tensor = torch.zeros(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#使用clone方法拷贝张量, 拷贝后的张量和原始张量内存独立</span></span><br><span class="line">arr = tensor.clone().numpy() <span class="comment"># 也可以使用tensor.data.numpy()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将Torch Tensor转换为Numpy array</span></span><br><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">b = a.numpy()</span><br></pre></td></tr></table></figure> 输出 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], dtype=torch.float64)</span><br></pre></td></tr></table></figure></p>
<h5 id="tensor操作">2.4 Tensor操作</h5>
<p>Tensor同样跟python一样支持切片、合并分割操作和相应的数学运算 ###### 2.4.1 索引切片 切片时支持缺省参数和省略号。可以通过索引和切片对部分元素进行修改。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=torch.randn(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">m=t[<span class="number">0</span>:-<span class="number">1</span>:<span class="number">2</span>,<span class="number">1</span>:-<span class="number">1</span>:<span class="number">3</span>]		<span class="comment">#表示从第一行到最后一行每隔一行取一行，从第二列到最后一列每隔两列取一列</span></span><br></pre></td></tr></table></figure></p>
<h6 id="合并分割">2.4.2 合并分割</h6>
<ul>
<li>可以用<code>torch.cat()</code>方法和<code>torch.stack()</code>方法将多个张量合并，</li>
<li>可以用<code>torch.split()</code>方法把一个张量分割成多个张量。</li>
<li><code>torch.cat()</code>和<code>torch.stack()</code>有略微的区别，<code>torch.cat()</code>是连接，不会增加维度，而<code>torch.stack()</code>是堆叠， 会增加维度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=torch.tensor([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b=torch.tensor([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line">c=torch.tensor([[<span class="number">9</span>,<span class="number">10</span>],[<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">d=torch.cat([a,b,c])</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">e=torch.stack([a,b,c])</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line">f,g,h=torch.split(d,split_size_or_sections=<span class="number">2</span>,dim=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(f,g,h)</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor([[ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">tensor([[[ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">         [ <span class="number">3</span>,  <span class="number">4</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">         [ <span class="number">7</span>,  <span class="number">8</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">         [<span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>]]) tensor([[<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">7</span>, <span class="number">8</span>]]) tensor([[ <span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="tensor的运算操作">2.5 Tensor的运算操作</h5>
<p>张量数学运算主要有：标量运算，向量运算，矩阵运算。</p>
<h6 id="标量运算">2.5.1 标量运算</h6>
<p>加减乘除乘方，以及三角函数，指数，对数等常见函数，逻辑比较运算符等都是标量运算符。标量运算符的特点是对张量实施逐元素运算。有些标量运算符对常用的数学运算符进行了重载，并且支持类似numpy的广播特性 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例1-3-1 张量的数学运算-标量运算</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = torch.tensor([[<span class="number">1.0</span>,<span class="number">2</span>],[-<span class="number">3</span>,<span class="number">4.0</span>]])</span><br><span class="line">b = torch.tensor([[<span class="number">5.0</span>,<span class="number">6</span>],[<span class="number">7.0</span>,<span class="number">8.0</span>]])</span><br><span class="line">a+b <span class="comment">#运算符重载</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[ <span class="number">6.</span>,  <span class="number">8.</span>],</span><br><span class="line">        [ <span class="number">4.</span>, <span class="number">12.</span>]])</span><br><span class="line"> </span><br><span class="line">a-b</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[ -<span class="number">4.</span>,  -<span class="number">4.</span>],</span><br><span class="line">        [-<span class="number">10.</span>,  -<span class="number">4.</span>]])</span><br><span class="line"> </span><br><span class="line">a*b</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[  <span class="number">5.</span>,  <span class="number">12.</span>],</span><br><span class="line">        [-<span class="number">21.</span>,  <span class="number">32.</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">a/b</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[ <span class="number">0.2000</span>,  <span class="number">0.3333</span>],</span><br><span class="line">        [-<span class="number">0.4286</span>,  <span class="number">0.5000</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">a**<span class="number">2</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[ <span class="number">1.</span>,  <span class="number">4.</span>],</span><br><span class="line">        [ <span class="number">9.</span>, <span class="number">16.</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">a**(<span class="number">0.5</span>)</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="number">1.0000</span>, <span class="number">1.4142</span>],</span><br><span class="line">        [   nan, <span class="number">2.0000</span>]])</span><br><span class="line"> </span><br><span class="line">a%<span class="number">3</span> <span class="comment">#求模</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">2.</span>],</span><br><span class="line">        [-<span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">a//<span class="number">3</span> <span class="comment">#地板除法</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [-<span class="number">1.</span>,  <span class="number">1.</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">a&gt;=<span class="number">2</span> <span class="comment"># torch.ge(a,2) #ge: greater_equal缩写</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">False</span>,  <span class="literal">True</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">(a&gt;=<span class="number">2</span>)&amp;(a&lt;=<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">(a&gt;=<span class="number">2</span>)|(a&lt;=<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="literal">True</span>, <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">True</span>, <span class="literal">True</span>]])</span><br><span class="line"> </span><br><span class="line">a==<span class="number">5</span> <span class="comment">#torch.eq(a,5)</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line"></span><br><span class="line">torch.sqrt(a)</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="number">1.0000</span>, <span class="number">1.4142</span>],</span><br><span class="line">        [   nan, <span class="number">2.0000</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">a = torch.tensor([<span class="number">1.0</span>,<span class="number">8.0</span>])</span><br><span class="line">b = torch.tensor([<span class="number">5.0</span>,<span class="number">6.0</span>])</span><br><span class="line">c = torch.tensor([<span class="number">6.0</span>,<span class="number">7.0</span>])</span><br><span class="line">d = a+b+c</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([<span class="number">12.</span>, <span class="number">21.</span>])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">max</span>(a,b))</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([<span class="number">5.</span>, <span class="number">8.</span>])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">min</span>(a,b))</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">6.</span>])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">x = torch.tensor([<span class="number">2.6</span>,-<span class="number">2.7</span>])</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">round</span>(x)) <span class="comment">#保留整数部分，四舍五入</span></span><br><span class="line"><span class="built_in">print</span>(torch.floor(x)) <span class="comment">#保留整数部分，向下归整</span></span><br><span class="line"><span class="built_in">print</span>(torch.ceil(x)) <span class="comment">#保留整数部分，向上归整</span></span><br><span class="line"><span class="built_in">print</span>(torch.trunc(x)) <span class="comment">#保留整数部分，向0归整</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([ <span class="number">3.</span>, -<span class="number">3.</span>])</span><br><span class="line">tensor([ <span class="number">2.</span>, -<span class="number">3.</span>])</span><br><span class="line">tensor([ <span class="number">3.</span>, -<span class="number">2.</span>])</span><br><span class="line">tensor([ <span class="number">2.</span>, -<span class="number">2.</span>])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">x = torch.tensor([<span class="number">2.6</span>,-<span class="number">2.7</span>])</span><br><span class="line"><span class="built_in">print</span>(torch.fmod(x,<span class="number">2</span>)) <span class="comment">#作除法取余数</span></span><br><span class="line"><span class="built_in">print</span>(torch.remainder(x,<span class="number">2</span>)) <span class="comment">#作除法取剩余的部分，结果恒正</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([ <span class="number">0.6000</span>, -<span class="number">0.7000</span>])</span><br><span class="line">tensor([<span class="number">0.6000</span>, <span class="number">1.3000</span>])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 幅值裁剪</span></span><br><span class="line">x = torch.tensor([<span class="number">0.9</span>,-<span class="number">0.8</span>,<span class="number">100.0</span>,-<span class="number">20.0</span>,<span class="number">0.7</span>])</span><br><span class="line">y = torch.clamp(x,<span class="built_in">min</span>=-<span class="number">1</span>,<span class="built_in">max</span> = <span class="number">1</span>)</span><br><span class="line">z = torch.clamp(x,<span class="built_in">max</span> = <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([ <span class="number">0.9000</span>, -<span class="number">0.8000</span>,  <span class="number">1.0000</span>, -<span class="number">1.0000</span>,  <span class="number">0.7000</span>])</span><br><span class="line">tensor([  <span class="number">0.9000</span>,  -<span class="number">0.8000</span>,   <span class="number">1.0000</span>, -<span class="number">20.0000</span>,   <span class="number">0.7000</span>])</span><br></pre></td></tr></table></figure></p>
<h6 id="向量运算">2.5.2 向量运算</h6>
<p>向量运算符只在一个特定轴上运算，将一个向量映射到一个标量或者另外一个向量。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例1-3-2  张量的数学运算-向量运算</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment">#统计值</span></span><br><span class="line">a = torch.arange(<span class="number">1</span>,<span class="number">10</span>).<span class="built_in">float</span>()</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">sum</span>(a))</span><br><span class="line"><span class="built_in">print</span>(torch.mean(a))</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">max</span>(a))</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">min</span>(a))</span><br><span class="line"><span class="built_in">print</span>(torch.prod(a)) <span class="comment">#累乘</span></span><br><span class="line"><span class="built_in">print</span>(torch.std(a)) <span class="comment">#标准差</span></span><br><span class="line"><span class="built_in">print</span>(torch.var(a)) <span class="comment">#方差</span></span><br><span class="line"><span class="built_in">print</span>(torch.median(a)) <span class="comment">#中位数</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor(<span class="number">45.</span>)</span><br><span class="line">tensor(<span class="number">5.</span>)</span><br><span class="line">tensor(<span class="number">9.</span>)</span><br><span class="line">tensor(<span class="number">1.</span>)</span><br><span class="line">tensor(<span class="number">362880.</span>)</span><br><span class="line">tensor(<span class="number">2.7386</span>)</span><br><span class="line">tensor(<span class="number">7.5000</span>)</span><br><span class="line">tensor(<span class="number">5.</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#指定维度计算统计值</span></span><br><span class="line">b = a.view(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">max</span>(b,dim = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">max</span>(b,dim = <span class="number">1</span>))</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>],</span><br><span class="line">        [<span class="number">7.</span>, <span class="number">8.</span>, <span class="number">9.</span>]])</span><br><span class="line">torch.return_types.<span class="built_in">max</span>(</span><br><span class="line">values=tensor([<span class="number">7.</span>, <span class="number">8.</span>, <span class="number">9.</span>]),</span><br><span class="line">indices=tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]))</span><br><span class="line">torch.return_types.<span class="built_in">max</span>(</span><br><span class="line">values=tensor([<span class="number">3.</span>, <span class="number">6.</span>, <span class="number">9.</span>]),</span><br><span class="line">indices=tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#cum扫描</span></span><br><span class="line">a = torch.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.cumsum(a,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(torch.cumprod(a,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(torch.cummax(a,<span class="number">0</span>).values)</span><br><span class="line"><span class="built_in">print</span>(torch.cummax(a,<span class="number">0</span>).indices)</span><br><span class="line"><span class="built_in">print</span>(torch.cummin(a,<span class="number">0</span>))</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([ <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>])</span><br><span class="line">tensor([     <span class="number">1</span>,      <span class="number">2</span>,      <span class="number">6</span>,     <span class="number">24</span>,    <span class="number">120</span>,    <span class="number">720</span>,   <span class="number">5040</span>,  <span class="number">40320</span>, <span class="number">362880</span>])</span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">tensor([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">torch.return_types.cummin(</span><br><span class="line">values=tensor([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]),</span><br><span class="line">indices=tensor([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#torch.sort和torch.topk可以对张量排序</span></span><br><span class="line">a = torch.tensor([[<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]]).<span class="built_in">float</span>()</span><br><span class="line"><span class="built_in">print</span>(torch.topk(a,<span class="number">2</span>,dim = <span class="number">0</span>),<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.topk(a,<span class="number">2</span>,dim = <span class="number">1</span>),<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.sort(a,dim = <span class="number">1</span>),<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">torch.return_types.topk(</span><br><span class="line">values=tensor([[<span class="number">9.</span>, <span class="number">7.</span>, <span class="number">8.</span>],</span><br><span class="line">        [<span class="number">5.</span>, <span class="number">6.</span>, <span class="number">4.</span>]]),</span><br><span class="line">indices=tensor([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]])) </span><br><span class="line"> </span><br><span class="line">torch.return_types.topk(</span><br><span class="line">values=tensor([[<span class="number">9.</span>, <span class="number">8.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">2.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">5.</span>]]),</span><br><span class="line">indices=tensor([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>]])) </span><br><span class="line"> </span><br><span class="line">torch.return_types.sort(</span><br><span class="line">values=tensor([[<span class="number">7.</span>, <span class="number">8.</span>, <span class="number">9.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]]),</span><br><span class="line">indices=tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]]))</span><br></pre></td></tr></table></figure></p>
<h6 id="矩阵运算">2.5.3 矩阵运算</h6>
<p>矩阵必须是二维的，类似<code>torch.tensor([1,2,3])</code>这样的不是矩阵。矩阵运算包括：<strong>矩阵乘法，矩阵转置，矩阵逆，矩阵求迹，矩阵范数，矩阵行列式，矩阵求特征 值，矩阵分解等运算</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例1-3-3 张量的数学运算-矩阵运算</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment">#矩阵乘法</span></span><br><span class="line">a = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = torch.tensor([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br></pre></td></tr></table></figure> <strong>1. 矩阵乘法</strong>：矩阵乘法可以使用<code>a@b</code>，也可以函数<code>torch.matmul(a,b)</code>或者`torch.mm(a,b)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a@b</span><br><span class="line">torch.matmul(a,b)</span><br><span class="line">torch.mm(a,b)</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor([[<span class="number">19</span>, <span class="number">22</span>],</span><br><span class="line">        [<span class="number">43</span>, <span class="number">50</span>]])</span><br><span class="line">tensor([[<span class="number">19</span>, <span class="number">22</span>],</span><br><span class="line">        [<span class="number">43</span>, <span class="number">50</span>]])</span><br><span class="line">tensor([[<span class="number">19</span>, <span class="number">22</span>],</span><br><span class="line">        [<span class="number">43</span>, <span class="number">50</span>]])</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 矩阵转置</strong>：转置直接使用其成员函数<code>t()</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.t()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">2.</span>, <span class="number">4.</span>]])</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 逆矩阵</strong>：求逆使用Tensorde1<code>inverse()</code>函数。矩阵逆，必须为浮点类型 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.inverse(a)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor([[-<span class="number">2.0000</span>,  <span class="number">1.0000</span>],</span><br><span class="line">        [ <span class="number">1.5000</span>, -<span class="number">0.5000</span>]], dtype=torch.float64)</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 矩阵求Tr</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([[<span class="number">1.0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(torch.trace(a))</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor(<span class="number">5.</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>5. 矩阵求范数</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.norm(a)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor(<span class="number">5.4772</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>6. 矩阵行列式</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.det(a)</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">tensor(-<span class="number">2.0000</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>7. 矩阵特征值和特征向量</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k=torch.tensor([[<span class="number">1</span>,<span class="number">2</span>],[-<span class="number">5</span>,<span class="number">4</span>]],dtype=<span class="built_in">float</span>)</span><br><span class="line">L_complex,V_complex=torch.linalg.eig(k)</span><br><span class="line"><span class="built_in">print</span>(L_complex,V_complex)</span><br></pre></td></tr></table></figure></p>
<p><strong>8. 矩阵QR分解</strong>：将一个方阵分解为一个正交矩阵q和上三角矩阵r。QR分解实际上是对矩阵a实施Schmidt正交化得到q</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=torch.tensor([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype=<span class="built_in">float</span>)</span><br><span class="line">q,r=torch.linalg.qr(a)</span><br><span class="line"><span class="built_in">print</span>(q,r)</span><br></pre></td></tr></table></figure>
<p><strong>9. 矩阵svd分解：</strong>svd分解可以将任意一个矩阵分解为一个正交矩阵u,一个对角阵s和一个正交矩阵v.t()的乘积，svd常用于矩阵压缩和降维 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u,s,v=torch.linalg.svd(a)</span><br><span class="line"><span class="built_in">print</span>(u,<span class="string">&quot;\n&quot;</span>,s,<span class="string">&quot;\n&quot;</span>,v)</span><br></pre></td></tr></table></figure> 输出 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor([[-<span class="number">0.4046</span>, -<span class="number">0.9145</span>],</span><br><span class="line">        [-<span class="number">0.9145</span>,  <span class="number">0.4046</span>]], dtype=torch.float64) </span><br><span class="line">tensor([<span class="number">5.4650</span>, <span class="number">0.3660</span>], dtype=torch.float64) </span><br><span class="line">tensor([[-<span class="number">0.5760</span>, -<span class="number">0.8174</span>],</span><br><span class="line">        [ <span class="number">0.8174</span>, -<span class="number">0.5760</span>]], dtype=torch.float64)</span><br></pre></td></tr></table></figure></p>
<h5 id="广播机制">2.6 广播机制</h5>
<p>Pytorch的广播规则和numpy是一样的:</p>
<ul>
<li><p>1、如果张量的维度不同，将维度较小的张量进行扩展，直到两个张量的维度都一样。</p></li>
<li><p>2、如果两个张量在某个维度上的长度是相同的，或者其中一个张量在该维度上的长度为1， 那么我们就说这两个张量在该维度上是相容的。</p></li>
<li><p>3、如果两个张量在所有维度上都是相容的，它们就能使用广播。</p></li>
<li><p>4、广播之后，每个维度的长度将取两个张量在该维度长度的较大值。</p></li>
<li><p>5、在任何一个维度上，如果一个张量的长度为1，另一个张量长度大于1，那么在该维度上，就好像是对第一个张量进行了复制。 torch.broadcast_tensors可以将多个张量根据广播规则转换成相同的维度。</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例 1-3-4  广播机制</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">a = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = torch.tensor([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line"><span class="built_in">print</span>(b + a)</span><br><span class="line">a_broad,b_broad = torch.broadcast_tensors(a,b)</span><br><span class="line"><span class="built_in">print</span>(a_broad,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b_broad,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a_broad + b_broad)</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]) </span><br><span class="line"> </span><br><span class="line">tensor([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]) </span><br><span class="line"> </span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure>
<h4 id="其他基础知识">3. 其他基础知识</h4>
<p>上面介绍了pytorch的数据结构Tensor以及Tensor的一些操作函数，这里介绍深度学习必须用到的微分求导和动态计算图。</p>
<h5 id="自动微分机制">3.1 自动微分机制</h5>
<p>神经网络通常依赖<strong>反向传播求梯度来更新网络参数</strong>，求梯度过程通常是一件非常复杂而容易出错的事情。而深度学习框架可以帮助我们自动地完成这种求梯度运算。这就是Pytorch的自动微分机制是指： - <strong>Pytorch一般通过反向传播<code>backward()</code>方法实现这种求梯度计算。</strong>该方法求得的梯度将存在对应自变量张量的<code>grad·属性下。 - 除此之外，也能够调用</code>torch.autograd.grad()`函数来实现求梯度计算。</p>
<h6 id="backward方法求导数">3.1.1 backward方法求导数</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.autograd.backward(</span><br><span class="line">    tensors: <span class="type">Union</span>[torch.Tensor, <span class="type">Sequence</span>[torch.Tensor]],</span><br><span class="line">    gradient: <span class="type">Union</span>[torch.Tensor, <span class="type">Sequence</span>[torch.Tensor], NoneType] = <span class="literal">None</span>,</span><br><span class="line">    retain_graph: <span class="type">Union</span>[<span class="built_in">bool</span>, NoneType] = <span class="literal">None</span>,</span><br><span class="line">    create_graph: <span class="built_in">bool</span> = <span class="literal">False</span>,</span><br><span class="line">    grad_variables: <span class="type">Union</span>[torch.Tensor, <span class="type">Sequence</span>[torch.Tensor], NoneType] = <span class="literal">None</span>,</span><br><span class="line">    inputs: <span class="type">Union</span>[torch.Tensor, <span class="type">Sequence</span>[torch.Tensor], NoneType] = <span class="literal">None</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tensor</code>:表示用于求导的张量，如loss，</li>
<li><code>gradient</code>: 设置梯度权重，在计算矩阵的梯度时会用到，也是一个tensor，shape和前面的tensor保持一致</li>
<li><code>retain_graph</code>:表示保存计算图，由于pytorch采用了动态图机制，在每一次反向传播之后，计算图都会被释放掉。如果不想释放，就设置这个参数为True</li>
<li><code>create_graph</code>:创建导数计算图，用于高阶求导</li>
</ul>
<p><strong><em>注</em></strong>：tensor类的<code>backward()</code>函数内部调用了<code>torch.autograd.backward()</code></p>
<p><code>backward()</code>方法通常在一个标量张量上调用，该方法求得的梯度将存在对应自变量张量的<code>grad</code>属性下。<strong>如果调用的张量非标量，则要传入一个和它同形状的gradient参数张量,改张量是设置梯度权重的</strong>。相当于用该gradient参数张量与调用张量作向量点乘，得到的标量结果再反向传播。</p>
<p><strong>下面分别介绍标量和非标量的反向传播：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#标量的反向传播</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="comment">#f=ax**2+bx+c</span></span><br><span class="line">    x=torch.tensor(<span class="number">1.0</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">    a=torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">    b=torch.tensor(-<span class="number">2.0</span>)</span><br><span class="line">    c=torch.tensor(<span class="number">5.6</span>)</span><br><span class="line">    y=a*torch.<span class="built_in">pow</span>(x,<span class="number">2</span>)+b*x+c</span><br><span class="line">    y.backward()</span><br><span class="line">    dy_dx=x.grad</span><br><span class="line">    <span class="built_in">print</span>(dy_dx)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">tensor(<span class="number">0.</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#非标量的反向传播</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="comment"># f=ax**2+bx+c</span></span><br><span class="line">    x=torch.tensor([[<span class="number">0.0</span>,<span class="number">1.0</span>],[<span class="number">5.0</span>,<span class="number">2.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">    a = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">    b = torch.tensor(-<span class="number">2.0</span>)</span><br><span class="line">    c = torch.tensor(<span class="number">5.6</span>)</span><br><span class="line">    y = a * torch.<span class="built_in">pow</span>(x, <span class="number">2</span>) + b * x + c</span><br><span class="line">    gradient = torch.tensor([[<span class="number">1.0</span>, <span class="number">1.0</span>], [<span class="number">1.0</span>, <span class="number">1.0</span>]])</span><br><span class="line">    y.backward(gradient=gradient)</span><br><span class="line">    dy_dx=x.grad</span><br><span class="line">    <span class="built_in">print</span>(dy_dx)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">tensor([[-<span class="number">2.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">8.</span>,  <span class="number">2.</span>]])</span><br></pre></td></tr></table></figure></p>
<p><strong>注：非标量的反向传播也可以用标量的反向传播实现，如下只需加一句<code>z = torch.sum(y*gradient)</code>，然后以<code>z.backward()</code>即可</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = torch.<span class="built_in">sum</span>(y*gradient)</span><br><span class="line">z.backward()</span><br><span class="line">x_grad = x.grad</span><br><span class="line"><span class="built_in">print</span>(x_grad)</span><br></pre></td></tr></table></figure></p>
<h6 id="利用autograd.grad方法求导数">3.1.2 利用autograd.grad方法求导数</h6>
<p><code>torch.autograd.grad()</code>这个方法的功能也是求梯度，可以实现高阶的求导。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.autograd.grad(</span><br><span class="line">    outputs: <span class="type">Union</span>[torch.Tensor, <span class="type">Sequence</span>[torch.Tensor]],</span><br><span class="line">    inputs: <span class="type">Union</span>[torch.Tensor, <span class="type">Sequence</span>[torch.Tensor]],</span><br><span class="line">    grad_outputs: <span class="type">Union</span>[torch.Tensor, <span class="type">Sequence</span>[torch.Tensor], NoneType] = <span class="literal">None</span>,</span><br><span class="line">    retain_graph: <span class="type">Union</span>[<span class="built_in">bool</span>, NoneType] = <span class="literal">None</span>,</span><br><span class="line">    create_graph: <span class="built_in">bool</span> = <span class="literal">False</span>,</span><br><span class="line">    only_inputs: <span class="built_in">bool</span> = <span class="literal">True</span>,</span><br><span class="line">    allow_unused: <span class="built_in">bool</span> = <span class="literal">False</span>,</span><br><span class="line">) -&gt; <span class="type">Tuple</span>[torch.Tensor, ...]</span><br></pre></td></tr></table></figure> - <code>outputs</code>：用于求导的张量； - <code>inputs</code>: 需要梯度的张量； - <code>create_graph</code>:创建导数计算图，用于高阶求导 - <code>retain_graph</code>:保存计算图 - <code>grad_outputs</code>:多梯度权重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例2-1-2 利用autograd.grad方法求导数</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># f(x) = a*x**2 + b*x + c的导数</span></span><br><span class="line">x = torch.tensor(<span class="number">0.0</span>,requires_grad = <span class="literal">True</span>) <span class="comment"># x需要被求导</span></span><br><span class="line">a = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">b = torch.tensor(-<span class="number">2.0</span>)</span><br><span class="line">c = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">y = a*torch.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c</span><br><span class="line"><span class="comment"># create_graph 设置为 True 将允许创建更高阶的导数</span></span><br><span class="line">dy_dx = torch.autograd.grad(y,x,create_graph=<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(dy_dx.data)</span><br><span class="line"><span class="comment"># 求二阶导数</span></span><br><span class="line">dy2_dx2 = torch.autograd.grad(dy_dx,x)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(dy2_dx2.data)</span><br><span class="line"> </span><br><span class="line">out：</span><br><span class="line">tensor(-<span class="number">2.</span>)</span><br><span class="line">tensor(<span class="number">2.</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#例1-2-2 利用autograd.grad方法求导数，对多个自变量求导数</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x1 = torch.tensor(<span class="number">1.0</span>,requires_grad = <span class="literal">True</span>) <span class="comment"># x需要被求导</span></span><br><span class="line">x2 = torch.tensor(<span class="number">2.0</span>,requires_grad = <span class="literal">True</span>)</span><br><span class="line">y1 = x1*x2</span><br><span class="line">y2 = x1+x2</span><br><span class="line"><span class="comment"># 允许同时对多个自变量求导数</span></span><br><span class="line">(dy1_dx1,dy1_dx2) = torch.autograd.grad(outputs=y1,inputs =</span><br><span class="line">[x1,x2],retain_graph = <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(dy1_dx1,dy1_dx2)</span><br><span class="line"><span class="comment"># 如果有多个因变量，相当于把多个因变量的梯度结果求和</span></span><br><span class="line">(dy12_dx1,dy12_dx2) = torch.autograd.grad(outputs=[y1,y2],inputs = [x1,x2])</span><br><span class="line"><span class="built_in">print</span>(dy12_dx1,dy12_dx2)</span><br><span class="line"> </span><br><span class="line">out：</span><br><span class="line">tensor(<span class="number">2.</span>) tensor(<span class="number">1.</span>)</span><br><span class="line">tensor(<span class="number">3.</span>) tensor(<span class="number">2.</span>)</span><br></pre></td></tr></table></figure>
<h6 id="利用自动微分和优化器求最小值">3.1.3 利用自动微分和优化器求最小值</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例2-1-3 利用自动微分和优化器求最小值</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># f(x) = a*x**2 + b*x + c的最小值</span></span><br><span class="line">x = torch.tensor(<span class="number">0.0</span>,requires_grad = <span class="literal">True</span>) <span class="comment"># x需要被求导</span></span><br><span class="line">a = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">b = torch.tensor(-<span class="number">2.0</span>)</span><br><span class="line">c = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">optimizer = torch.optim.SGD(params=[x],lr = <span class="number">0.01</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">	result = a*torch.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c</span><br><span class="line">	<span class="keyword">return</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">	optimizer.zero_grad()</span><br><span class="line">	y = f(x)</span><br><span class="line">	y.backward()</span><br><span class="line">	optimizer.step()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y=&quot;</span>,f(x).data,<span class="string">&quot;;&quot;</span>,<span class="string">&quot;x=&quot;</span>,x.data)</span><br><span class="line"> </span><br><span class="line">out：</span><br><span class="line">y= tensor(<span class="number">0.</span>) ; x= tensor(<span class="number">1.0000</span>)</span><br></pre></td></tr></table></figure>
<p><strong><em>注</em></strong>：优化器后续讲解</p>
<h5 id="动态计算图">3.2 动态计算图</h5>
<p>Pytorch的计算图由节点和边组成，<strong>节点表示张量或者Function，边表示张量和Function之间的依赖关系</strong>。Pytorch中的计算图是动态图。 <img src="/2022/10/06/pytorch%E5%9F%BA%E7%A1%80/computgraph.png" width="400"> 从上面可以看出<span class="math inline">\(y = a × b\)</span>，而<span class="math inline">\(a = w + x, b = w + 1\)</span>，只要给出<span class="math inline">\(x\)</span>和<span class="math inline">\(w\)</span>的值，即可根据计算图得出<span class="math inline">\(y\)</span>的值。上图中用求y对w的导数，根据求导规则，如下： <span class="math display">\[
{δy\over δw}={δy\over δa}{δa\over δw}+{δy \over δb}{δb \over δw}\\
=b*1+a*1\\
=b+a\\
=(w+1)+(x+w)\\
=2*w+x+1\\
=2*1+2+1\\
=5
\]</span> 体现到计算图中，就是根节点 y 到叶子节点 w 有两条路径 y -&gt; a -&gt; w和y -&gt;b -&gt; w。根节点依次对每条路径的叶子节点求导，一直到叶子节点w，最后把每条路径的导数相加即可 <img src="/2022/10/06/pytorch%E5%9F%BA%E7%A1%80/compute.png" width="400"> <strong>在tensor中包含一个<code>is_leaf</code>(叶子节点)属性，叶子节点就是用户创建的节点，在上面的例子中，<span class="math inline">\(x\)</span> 和<span class="math inline">\(w\)</span> 是叶子节点，其他所有节点都依赖于叶子节点</strong>。叶子节点的概念主要是为了节省内存，在计算图中的一轮反向传播结束之后，非叶子节点的梯度是会被释放的。</p>
<p>只有叶子节点的梯度保留了下来，而非叶子的梯度为空，如果在反向传播之后仍需要保留非叶子节点的梯度，可以对节点使用<code>retain_grad=True</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看是否是叶子节点</span></span><br><span class="line"><span class="built_in">print</span>(w.is_leaf, x.is_leaf, a.is_leaf, b.is_leaf)</span><br><span class="line"></span><br><span class="line"><span class="comment">###result</span></span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span> <span class="literal">False</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<h6 id="何为动态">3.2.1 何为动态</h6>
<p><strong>这里的动态主要有两重含义:</strong></p>
<ul>
<li><p><strong>第一层含义是</strong>：计算图的正向传播是立即执行的。无需等待完整的计算图创建完毕，每条语句都会在计算图中动态添加节点和边，并立即执行正向传播得到计算结果。</p></li>
<li><p><strong>第二层含义是</strong>：计算图在反向传播后立即销毁。下次调用需要重新构建计算图。如果在程序中使用了<code>backward()</code>方法执行了反向传播，或者利用<code>torch.autograd.grad()</code>方法计算了梯度，那么创建的计算图会被立即销毁，释放存储空间，下次调用需要重新创建</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例2-2-1 计算图的正向传播是立即执行的</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">w = torch.tensor([[<span class="number">3.0</span>,<span class="number">1.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor([[<span class="number">3.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">X = torch.randn(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">Y = torch.randn(<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">Y_hat = X@w.t() + b <span class="comment"># Y_hat定义后其正向传播被立即执行，与其后面的loss创建语句无关</span></span><br><span class="line">loss = torch.mean(torch.<span class="built_in">pow</span>(Y_hat-Y,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(loss.data)</span><br><span class="line"><span class="built_in">print</span>(Y_hat.data)</span><br><span class="line"> </span><br><span class="line">out：</span><br><span class="line">tensor(<span class="number">25.9445</span>)</span><br><span class="line">tensor([[ <span class="number">5.8349</span>],</span><br><span class="line">        [ <span class="number">0.5817</span>],</span><br><span class="line">        [-<span class="number">4.2764</span>],</span><br><span class="line">        [ <span class="number">3.2476</span>],</span><br><span class="line">        [ <span class="number">3.6737</span>],</span><br><span class="line">        [ <span class="number">2.8748</span>],</span><br><span class="line">        [ <span class="number">8.3981</span>],</span><br><span class="line">        [ <span class="number">7.1418</span>],</span><br><span class="line">        [-<span class="number">4.8522</span>],</span><br><span class="line">        [ <span class="number">2.2610</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#计算图在反向传播后立即销毁</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">w = torch.tensor([[<span class="number">3.0</span>,<span class="number">1.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor([[<span class="number">3.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">X = torch.randn(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">Y = torch.randn(<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">Y_hat = X@w.t() + b <span class="comment"># Y_hat定义后其正向传播被立即执行，与其后面的loss创建语句无关</span></span><br><span class="line">loss = torch.mean(torch.<span class="built_in">pow</span>(Y_hat-Y,<span class="number">2</span>))</span><br><span class="line"><span class="comment">#计算图在反向传播后立即销毁，如果需要保留计算图, 需要设置retain_graph = True</span></span><br><span class="line">loss.backward() <span class="comment">#loss.backward(retain_graph = True) </span></span><br><span class="line"><span class="comment">#loss.backward() #如果再次执行反向传播将报错</span></span><br></pre></td></tr></table></figure>
<h6 id="动态图机制">3.2.1 动态图机制</h6>
<p>pytroch采用的是动态图机制，而tensorflow采用的是静态图机制。静态图是先搭建，后运算；动态图是运算和搭建同时进行，也就是可以先计算前面节点的值，再根据这些值搭建后面的计算图。优点是灵活，易调节，易调试。 <img src="/2022/10/06/pytorch%E5%9F%BA%E7%A1%80/dynamicR.png" width="600"></p>
<h4 id="数据的读取">4. 数据的读取</h4>
<p>机器学习的五大模块分别是：数据、模块、损失函数、优化器和迭代训练。这里我们介绍数据模块，要对模型进行训练必须要有数据，怎么讲数据读取进来存储是我们要解决的问题。数据模块又可分为以下几部分：</p>
<ul>
<li>数据的收集：<code>Image、label</code></li>
<li>数据的划分：<code>train、test、valid</code></li>
<li>数据的读取：<code>DataLoader</code>，有两个子模块，<code>Sampler</code>和<code>Dataset</code>，<code>Sampler</code>是对数据集生成索引，<code>DataSet</code>是根据索引读取数据</li>
<li>数据预处理：<code>torchvision.transforms</code>模块</li>
</ul>
<p><strong>Pytorch通常使用<code>Dataset</code>和<code>DataLoader</code>这两个工具类来构建数据管道:</strong></p>
<ul>
<li><p><code>Dataset</code>定义了数据集的内容，它相当于一个类似列表的数据结构，具有确定的长度，能够用索 引获取数据集中的元素。</p></li>
<li><p><code>DataLoader</code>定义了按<code>batch</code>加载数据集的方法，它是一个实现了<code>__iter__</code>方法的可迭代对象，每次迭代输出一个<code>batch</code>的数据。<code>DataLoader</code>能够控制<code>batch</code>的大小，<code>batch</code>中元素的采样方法，以及将batch结果整理成模型所需 输入形式的方法，并且能够使用多进程读取数据。</p></li>
<li><p>在绝大部分情况下，用户只需实现<code>Dataset</code>的<code>__len__</code>方法和<code>__getitem__</code>方法，就可以轻松构 建自己的数据集，并用默认数据管道进行加载</p></li>
</ul>
<h5 id="dataloader和dataset概述">4.1 DataLoader和DataSet概述</h5>
<h6 id="获取一个batch数据的步骤">4.1.1 获取一个batch数据的步骤</h6>
<p>让我们考虑一下从一个数据集中获取一个batch的数据需要哪些步骤。 (假定数据集的特征和标签分别表示为张量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> ，数据集可以表示为 <span class="math inline">\((X,Y)\)</span> , 假定batch大小为<span class="math inline">\(m\)</span> )</p>
<ul>
<li><ol type="a">
<li>首先我们要确定数据集的长度<span class="math inline">\(n\)</span> ,假设$ n = 1000$ 。</li>
</ol></li>
<li><ol start="2" type="a">
<li>然后我们从<span class="math inline">\(0\)</span> 到<span class="math inline">\(n-1\)</span>的范围中抽样出<span class="math inline">\(m\)</span>个数(batch大小)。假定<span class="math inline">\(m=4\)</span>, 拿到的结果是一个列表，类似： <span class="math inline">\(indices = [1,4,8,9]\)</span></li>
</ol></li>
<li><ol start="3" type="a">
<li>接着我们从数据集中去取这 m 个数对应下标的元素。 拿到的结果是一个元组列表，类似： <span class="math inline">\(samples = [(X[1],Y[1]),(X[4],Y[4]),(X[8],Y[8]), (X[9],Y[9])]\)</span></li>
</ol></li>
<li><ol start="4" type="a">
<li>最后我们将结果整理成两个张量作为输出。 拿到的结果是两个张量，类似$ batch = (features,labels)$其中 <span class="math inline">\(features = torch.stack([X[1],X[4],X[8],X[9]]) labels = torch.stack([Y[1],Y[4],Y[8],Y[9]])\)</span></li>
</ol></li>
</ul>
<h6 id="dataset和dataloader的功能分工">4.1.2 Dataset和DataLoader的功能分工</h6>
<ul>
<li><p>上述第a个步骤确定数据集的长度是由<code>Dataset</code>的<code>__len__</code>方法实现的。</p></li>
<li><p>第b个步骤从<span class="math inline">\(0\)</span> 到<span class="math inline">\(n-1\)</span>的范围中抽样出 m 个数的方法是由 <code>DataLoader</code>的 <code>sampler</code> 和 <code>batch_sampler</code> 参数指定的。<code>sampler</code>参数指定单个元素抽样方法，一般无需用户设置，程序默认在<code>DataLoader</code>的参数<code>shuffle=True</code>时采用随机抽样， <code>shuffle=False</code> 时采用顺序抽样。<code>batch_sampler</code>参数将多个抽样的元素整理成一个列表，一般无需用户设置，默认方法在<code>DataLoader</code>的参数 <code>drop_last=True</code>时会丢弃数据集最后一个长度不能被batch大小整除的批次，在 <code>drop_last=False</code>时保留最后一个批次。</p></li>
<li><p>第c个步骤的核心逻辑根据下标取数据集中的元素 是由<code>Dataset</code>的 <code>__getitem__</code>方法实现的。</p></li>
<li><p>第d个步骤的逻辑由<code>DataLoader</code>的参数 <code>collate_fn</code> 指定。一般情况下也无需用户设置。</p></li>
</ul>
<h5 id="使用dataset创建数据集">4.2 使用Dataset创建数据集</h5>
<p>Dataset创建数据集常用的方法有以下几个：</p>
<ul>
<li><ol type="a">
<li>使用 <code>torch.utils.data.TensorDataset</code> 根据<code>Tensor</code>创建数据集(<code>numpy</code>的<code>array</code>，<code>Pandas</code>的 <code>DataFrame</code>需要先转换成<code>Tensor</code>)。</li>
</ol></li>
<li><ol start="2" type="a">
<li>使用 <code>torchvision.datasets.ImageFolder</code> 根据图片目录创建图片数据集。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataset=torchvision.datasets.ImageFolder(</span><br><span class="line">                       root, transform=<span class="literal">None</span>, </span><br><span class="line">                       target_transform=<span class="literal">None</span>, </span><br><span class="line">                       loader=&lt;function default_loader&gt;, </span><br><span class="line">                       is_valid_file=<span class="literal">None</span>)</span><br><span class="line">root：图片存储的根目录，即各类别文件夹所在目录的上一级目录。</span><br><span class="line">transform：对图片进行预处理的操作（函数），原始图片作为输入，返回一个转换后的图片。</span><br><span class="line">target_transform：对图片类别进行预处理的操作，输入为 target，输出对其的转换。如果不传该参数，即对 target 不做任何转换，返回的顺序索引 <span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>…</span><br><span class="line">loader：表示数据集加载方式，通常默认加载方式即可。</span><br><span class="line">is_valid_file：获取图像文件的路径并检查该文件是否为有效文件的函数(用于检查损坏文件)</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><ol start="3" type="a">
<li>继承<code>torch.utils.data.Dataset</code> 创建自定义数据集。</li>
</ol></li>
<li><ol start="4" type="a">
<li>此外，还可以通过 <code>torch.utils.data.random_split</code> 将一个数据集分割成多份，常用于分割训练集，验证集和测试集。</li>
</ol></li>
<li><ol start="5" type="a">
<li>调用<code>Dataset</code>的加法运算符( + )将多个数据集合并成一个数据集。</li>
</ol></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例4-2-1  根据Tensor创建数据集</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> TensorDataset,Dataset,DataLoader,random_split</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 根据Tensor创建数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">ds_iris = TensorDataset(torch.tensor(iris.data),torch.tensor(iris.target))</span><br><span class="line"><span class="comment"># 分割成训练集和预测集</span></span><br><span class="line">n_train = <span class="built_in">int</span>(<span class="built_in">len</span>(ds_iris)*<span class="number">0.8</span>)</span><br><span class="line">n_valid = <span class="built_in">len</span>(ds_iris) - n_train</span><br><span class="line">ds_train,ds_valid = random_split(ds_iris,[n_train,n_valid])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ds_iris))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ds_train))</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;torch.utils.data.dataset.TensorDataset&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;torch.utils.data.dataset.Subset&#x27;</span>&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用DataLoader加载数据集</span></span><br><span class="line">dl_train,dl_valid = DataLoader(ds_train,batch_size =</span><br><span class="line"><span class="number">8</span>),DataLoader(ds_valid,batch_size = <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> features,labels <span class="keyword">in</span> dl_train:</span><br><span class="line"> <span class="built_in">print</span>(features,labels)</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([[<span class="number">6.5000</span>, <span class="number">3.0000</span>, <span class="number">5.2000</span>, <span class="number">2.0000</span>],</span><br><span class="line">        [<span class="number">6.3000</span>, <span class="number">3.4000</span>, <span class="number">5.6000</span>, <span class="number">2.4000</span>],</span><br><span class="line">        [<span class="number">4.9000</span>, <span class="number">2.4000</span>, <span class="number">3.3000</span>, <span class="number">1.0000</span>],</span><br><span class="line">        [<span class="number">6.7000</span>, <span class="number">3.1000</span>, <span class="number">4.7000</span>, <span class="number">1.5000</span>],</span><br><span class="line">        [<span class="number">4.5000</span>, <span class="number">2.3000</span>, <span class="number">1.3000</span>, <span class="number">0.3000</span>],</span><br><span class="line">        [<span class="number">5.7000</span>, <span class="number">2.5000</span>, <span class="number">5.0000</span>, <span class="number">2.0000</span>],</span><br><span class="line">        [<span class="number">5.2000</span>, <span class="number">4.1000</span>, <span class="number">1.5000</span>, <span class="number">0.1000</span>],</span><br><span class="line">        [<span class="number">5.7000</span>, <span class="number">2.6000</span>, <span class="number">3.5000</span>, <span class="number">1.0000</span>]], dtype=torch.float64) tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>], dtype=torch.int32)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 演示加法运算符（`+`）的合并作用</span></span><br><span class="line">ds_data = ds_train + ds_valid</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len(ds_train) = &#x27;</span>,<span class="built_in">len</span>(ds_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len(ds_valid) = &#x27;</span>,<span class="built_in">len</span>(ds_valid))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len(ds_train+ds_valid) = &#x27;</span>,<span class="built_in">len</span>(ds_data))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ds_data))</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"><span class="built_in">len</span>(ds_train) =  <span class="number">120</span></span><br><span class="line"><span class="built_in">len</span>(ds_valid) =  <span class="number">30</span></span><br><span class="line"><span class="built_in">len</span>(ds_train+ds_valid) =  <span class="number">150</span></span><br><span class="line">&lt;<span class="keyword">class</span><span class="string">&#x27;torch.utils.data.dataset.ConcatDataset&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#4-2-2  根据图片目录创建图片数据集</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms,datasets</span><br><span class="line"> </span><br><span class="line"><span class="comment">#演示一些常用的图片增强操作</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;./data/dog2.jpg&#x27;</span>)</span><br><span class="line">img</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 随机数值翻转</span></span><br><span class="line">transforms.RandomVerticalFlip()(img)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#随机旋转</span></span><br><span class="line">transforms.RandomRotation(<span class="number">45</span>)(img)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义图片增强操作</span></span><br><span class="line">transform_train = transforms.Compose([</span><br><span class="line">	 transforms.RandomHorizontalFlip(), <span class="comment">#随机水平翻转</span></span><br><span class="line">	 transforms.RandomVerticalFlip(), <span class="comment">#随机垂直翻转</span></span><br><span class="line">	 transforms.RandomRotation(<span class="number">45</span>), <span class="comment">#随机在45度角度内旋转</span></span><br><span class="line">	 transforms.ToTensor() <span class="comment">#转换成张量</span></span><br><span class="line">	 ]</span><br><span class="line">)</span><br><span class="line">transform_valid = transforms.Compose([</span><br><span class="line">	 transforms.ToTensor()</span><br><span class="line">	 ]</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 根据图片目录创建数据集</span></span><br><span class="line"><span class="comment"># 这里用到的animal数据集是我自己整理的，链接在文章末尾</span></span><br><span class="line"><span class="comment">#注意这里要在train 和  test 目录下按照图片类别分别新建文件夹，文件夹的名称就是类别名，然后把图片分别放入各个文件夹</span></span><br><span class="line">ds_train = datasets.ImageFolder(<span class="string">&quot;data/animal/train/&quot;</span>, transform = transform_train,target_transform= <span class="keyword">lambda</span> t:torch.tensor([t]).<span class="built_in">float</span>())</span><br><span class="line">ds_valid = datasets.ImageFolder(<span class="string">&quot;data/animal/test/&quot;</span>, transform = transform_valid,target_transform= <span class="keyword">lambda</span> t:torch.tensor([t]).<span class="built_in">float</span>())</span><br><span class="line"><span class="built_in">print</span>(ds_train.class_to_idx)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用DataLoader加载数据集</span></span><br><span class="line">dl_train = DataLoader(ds_train,batch_size = <span class="number">2</span>,shuffle = <span class="literal">True</span>,num_workers=<span class="number">1</span>)</span><br><span class="line">dl_valid = DataLoader(ds_valid,batch_size = <span class="number">2</span>,shuffle = <span class="literal">True</span>,num_workers=<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> features,labels <span class="keyword">in</span> dl_train:</span><br><span class="line">    <span class="built_in">print</span>(features)</span><br><span class="line">    <span class="built_in">print</span>(labels)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例4-2-3  创建自定义数据集 </span></span><br><span class="line"><span class="comment">#下面通过继承Dataset类创建douban文本分类任务的自定义数据集。 douban数据集链接在文章末尾。</span></span><br><span class="line"><span class="comment">#大概思路如下：首先，对训练集文本分词构建词典。然后将训练集文本和测试集文本数据转换成 token单词编码。 接着将转换成单词编码的训练集数据和测试集数据按样本分割成多个文件，一个文件代表一个样本。 最后，我们可以根据文件名列表获取对应序号的样本内容，从而构建Dataset数据集。</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> re,string,jieba,csv</span><br><span class="line"> </span><br><span class="line"><span class="comment">#from keras.datasets import imdb</span></span><br><span class="line"><span class="comment">#(train_data, train_labels), (test_data, test_labels) = imdb.load_data(num_words=10000)</span></span><br><span class="line"> </span><br><span class="line">MAX_WORDS = <span class="number">10000</span> <span class="comment"># 仅考虑最高频的10000个词</span></span><br><span class="line">MAX_LEN = <span class="number">200</span> <span class="comment"># 每个样本保留200个词的长度</span></span><br><span class="line">BATCH_SIZE = <span class="number">20</span></span><br><span class="line">train_data_path = <span class="string">&#x27;data/douban/train.csv&#x27;</span></span><br><span class="line">test_data_path = <span class="string">&#x27;data/douban/test.csv&#x27;</span></span><br><span class="line">train_token_path = <span class="string">&#x27;data/douban/train_token.csv&#x27;</span></span><br><span class="line">test_token_path = <span class="string">&#x27;data/douban/test_token.csv&#x27;</span></span><br><span class="line">train_samples_path = <span class="string">&#x27;data/douban/train_samples/&#x27;</span></span><br><span class="line">test_samples_path = <span class="string">&#x27;data/douban/test_samples/&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#print(train_data[0])</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">##构建词典</span></span><br><span class="line">word_count_dict = &#123;&#125;</span><br><span class="line"><span class="comment">#清洗文本</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_text</span>(<span class="params">text</span>):</span><br><span class="line">    bd=<span class="string">&#x27;[’!&quot;#$%&amp;\&#x27;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~]+，。！？“”《》：、． &#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bd:</span><br><span class="line">        text=text.replace(i,<span class="string">&#x27;&#x27;</span>)   <span class="comment">#字符串替换去标点符号</span></span><br><span class="line">    fenci=jieba.lcut(text)</span><br><span class="line">    <span class="keyword">return</span> fenci</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(train_data_path,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&#x27;utf-8&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f,delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="comment">#print(row)</span></span><br><span class="line">        text = row[<span class="number">1</span>]</span><br><span class="line">        label = row[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#print(label,text)</span></span><br><span class="line">        cleaned_text = clean_text(text)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> cleaned_text:</span><br><span class="line">            <span class="comment">#print(word)</span></span><br><span class="line">            word_count_dict[word] = word_count_dict.get(word,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(word_count_dict))</span><br><span class="line"> </span><br><span class="line">df_word_dict = pd.DataFrame(pd.Series(word_count_dict,name = <span class="string">&quot;count&quot;</span>))</span><br><span class="line">df_word_dict = df_word_dict.sort_values(by = <span class="string">&quot;count&quot;</span>,ascending =<span class="literal">False</span>)</span><br><span class="line">df_word_dict = df_word_dict[<span class="number">0</span>:MAX_WORDS-<span class="number">2</span>] <span class="comment"># </span></span><br><span class="line">df_word_dict[<span class="string">&quot;word_id&quot;</span>] = <span class="built_in">range</span>(<span class="number">2</span>,MAX_WORDS) <span class="comment">#编号0和1分别留给未知词&lt;unkown&gt;和填充&lt;padding&gt;</span></span><br><span class="line">word_id_dict = df_word_dict[<span class="string">&quot;word_id&quot;</span>].to_dict()</span><br><span class="line">df_word_dict.head(<span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">    count	word_id</span><br><span class="line">的	<span class="number">68229</span>	<span class="number">2</span></span><br><span class="line">了	<span class="number">20591</span>	<span class="number">3</span></span><br><span class="line">是	<span class="number">15321</span>	<span class="number">4</span></span><br><span class="line">我	<span class="number">9312</span>	<span class="number">5</span></span><br><span class="line">看	<span class="number">7423</span>	<span class="number">6</span></span><br><span class="line">很	<span class="number">7395</span>	<span class="number">7</span></span><br><span class="line">也	<span class="number">7256</span>	<span class="number">8</span></span><br><span class="line">都	<span class="number">7053</span>	<span class="number">9</span></span><br><span class="line">在	<span class="number">6753</span>	<span class="number">10</span></span><br><span class="line">和	<span class="number">6388</span>	<span class="number">11</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#转换token</span></span><br><span class="line"><span class="comment"># 填充文本</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">data_list,pad_length</span>):</span><br><span class="line">    padded_list = data_list.copy()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data_list)&gt; pad_length:</span><br><span class="line">        padded_list = data_list[-pad_length:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data_list)&lt; pad_length:</span><br><span class="line">        padded_list = [<span class="number">1</span>]*(pad_length-<span class="built_in">len</span>(data_list))+data_list</span><br><span class="line">    <span class="keyword">return</span> padded_list</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text_to_token</span>(<span class="params">text_file,token_file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(train_data_path,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&#x27;utf-8&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f,\</span><br><span class="line">        <span class="built_in">open</span>(token_file,<span class="string">&quot;w&quot;</span>,encoding = <span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fout:</span><br><span class="line">        reader = csv.reader(f,delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">            text = row[<span class="number">1</span>]</span><br><span class="line">            label = row[<span class="number">0</span>]</span><br><span class="line">            cleaned_text = clean_text(text)</span><br><span class="line">            word_token_list = [word_id_dict.get(word, <span class="number">0</span>) <span class="keyword">for</span> word <span class="keyword">in</span> cleaned_text]</span><br><span class="line">            pad_list = pad(word_token_list,MAX_LEN)</span><br><span class="line">            out_line = label+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> pad_list])</span><br><span class="line">            fout.write(out_line+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">text_to_token(train_data_path,train_token_path)</span><br><span class="line">text_to_token(test_data_path,test_token_path)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 分割样本</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(train_samples_path):</span><br><span class="line">    os.mkdir(train_samples_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(test_samples_path):</span><br><span class="line">    os.mkdir(test_samples_path)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_samples</span>(<span class="params">token_path,samples_dir</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(token_path,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fin:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fin:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(samples_dir+<span class="string">&quot;%d.txt&quot;</span>%i,<span class="string">&quot;w&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> fout:</span><br><span class="line">                fout.write(line)</span><br><span class="line">            i = i+<span class="number">1</span></span><br><span class="line">split_samples(train_token_path,train_samples_path)</span><br><span class="line">split_samples(test_token_path,test_samples_path)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#创建数据集</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader,Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms,datasets</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">imdbDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,samples_dir</span>):</span><br><span class="line">        self.samples_dir = samples_dir</span><br><span class="line">        self.samples_paths = os.listdir(samples_dir)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.samples_paths)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,index</span>):</span><br><span class="line">        path = self.samples_dir + self.samples_paths[index]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            line = f.readline()</span><br><span class="line">            label,tokens = line.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">            label = torch.tensor([<span class="built_in">float</span>(label)],dtype = torch.<span class="built_in">float</span>)</span><br><span class="line">            feature = torch.tensor([<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> tokens.split(<span class="string">&quot; &quot;</span>)],dtype = torch.long)</span><br><span class="line">            <span class="keyword">return</span> (feature,label)</span><br><span class="line">ds_train = imdbDataset(train_samples_path)</span><br><span class="line">ds_test = imdbDataset(test_samples_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ds_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ds_test))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">dl_train = DataLoader(ds_train,batch_size = BATCH_SIZE,shuffle = <span class="literal">True</span>,num_workers=<span class="number">4</span>)</span><br><span class="line">dl_test = DataLoader(ds_test,batch_size = BATCH_SIZE,num_workers=<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> features,labels <span class="keyword">in</span> dl_train:</span><br><span class="line">    <span class="built_in">print</span>(features)</span><br><span class="line">    <span class="built_in">print</span>(labels)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#创建模型</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"><span class="keyword">from</span> torchkeras <span class="keyword">import</span> Model,summary</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()   <span class="comment">#设置padding_idx参数后将在训练过程中将填充的token始终赋值为0向量</span></span><br><span class="line">        self.embedding = nn.Embedding(num_embeddings = MAX_WORDS,embedding_dim = <span class="number">3</span>,padding_idx = <span class="number">1</span>)</span><br><span class="line">        self.conv = nn.Sequential()</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;conv_1&quot;</span>,nn.Conv1d(in_channels = <span class="number">3</span>,out_channels = <span class="number">16</span>,kernel_size = <span class="number">5</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;pool_1&quot;</span>,nn.MaxPool1d(kernel_size = <span class="number">2</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;relu_1&quot;</span>,nn.ReLU())</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;conv_2&quot;</span>,nn.Conv1d(in_channels = <span class="number">16</span>,out_channels = <span class="number">128</span>,kernel_size = <span class="number">2</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;pool_2&quot;</span>,nn.MaxPool1d(kernel_size = <span class="number">2</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;relu_2&quot;</span>,nn.ReLU())</span><br><span class="line">        self.dense = nn.Sequential()</span><br><span class="line">        self.dense.add_module(<span class="string">&quot;flatten&quot;</span>,nn.Flatten())</span><br><span class="line">        self.dense.add_module(<span class="string">&quot;linear&quot;</span>,nn.Linear(<span class="number">6144</span>,<span class="number">1</span>))</span><br><span class="line">        self.dense.add_module(<span class="string">&quot;sigmoid&quot;</span>,nn.Sigmoid())</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">            x = self.embedding(x).transpose(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">            x = self.conv(x)</span><br><span class="line">            y = self.dense(x)</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">model = Net()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line">model.summary(input_shape = (<span class="number">200</span>,),input_dtype = torch.LongTensor)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_pred,y_true</span>):</span><br><span class="line">    y_pred = torch.where(y_pred&gt;<span class="number">0.5</span>,torch.ones_like(y_pred,dtype = torch.float32),torch.zeros_like(y_pred,dtype = torch.float32))</span><br><span class="line">    acc = torch.mean(<span class="number">1</span>-torch.<span class="built_in">abs</span>(y_true-y_pred))</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">model.<span class="built_in">compile</span>(loss_func = nn.BCELoss(),optimizer=</span><br><span class="line">torch.optim.Adagrad(model.parameters(),lr = <span class="number">0.02</span>),</span><br><span class="line">metrics_dict=&#123;<span class="string">&quot;accuracy&quot;</span>:accuracy&#125;)</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">dfhistory = model.fit(<span class="number">10</span>,dl_train,dl_val=dl_test,log_step_freq= <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<h5 id="使用dataloader加载数据集">4.3 使用DataLoader加载数据集</h5>
<p>DataLoader能够控制batch的大小，batch中元素的采样方法，以及将batch结果整理成模型所需输入形式的方法，并且能够使用多进程读取数据。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataLoader(</span><br><span class="line"> dataset,</span><br><span class="line"> batch_size=<span class="number">1</span>,</span><br><span class="line"> shuffle=<span class="literal">False</span>,</span><br><span class="line"> sampler=<span class="literal">None</span>,</span><br><span class="line"> batch_sampler=<span class="literal">None</span>,</span><br><span class="line"> num_workers=<span class="number">0</span>,</span><br><span class="line"> collate_fn=<span class="literal">None</span>,</span><br><span class="line"> pin_memory=<span class="literal">False</span>,</span><br><span class="line"> drop_last=<span class="literal">False</span>,</span><br><span class="line"> timeout=<span class="number">0</span>,</span><br><span class="line"> worker_init_fn=<span class="literal">None</span>,</span><br><span class="line"> multiprocessing_context=<span class="literal">None</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure> 一般情况下，我们仅仅会配置<code>dataset, batch_size, shuffle, num_workers, drop_last</code>这五个参 数，其他参数使用默认值即可。</p>
<ul>
<li><strong><code>dataset</code></strong> : 数据集</li>
<li><strong><code>batch_size</code></strong>: 批次大小</li>
<li><strong><code>shuffle</code></strong>: 是否乱序</li>
<li><code>sampler</code>: 样本采样函数，一般无需设置。</li>
<li><code>batch_sampler</code>: 批次采样函数，一般无需设置。</li>
<li><code>num_workers</code>: 使用多进程读取数据，设置的进程数。</li>
<li><code>collate_fn</code>: 整理一个批次数据的函数。</li>
<li><code>pin_memory</code>: 是否设置为锁业内存。默认为<code>False</code>，锁业内存不会使用虚拟内存(硬盘)，从锁 业内存拷贝到GPU上速度会更快。</li>
<li><strong><code>drop_last</code></strong>: 是否丢弃最后一个样本数量不足<code>batch_size</code>批次数据。</li>
<li><code>timeout</code>: 加载一个数据批次的最长等待时间，一般无需设置。</li>
<li><code>worker_init_fn</code>: 每个<code>worker</code>中<code>dataset</code>的初始化函数，常用于 <code>terableDataset</code>。一般不使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例3-3 使用DataLoader加载数据集</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader,TensorDataset,Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms,datasets</span><br><span class="line"><span class="comment">#构建输入数据管道</span></span><br><span class="line">ds = TensorDataset(torch.arange(<span class="number">1</span>,<span class="number">50</span>))</span><br><span class="line">dl = DataLoader(ds,</span><br><span class="line"> batch_size = <span class="number">10</span>,</span><br><span class="line"> shuffle= <span class="literal">True</span>,</span><br><span class="line"> num_workers=<span class="number">2</span>,</span><br><span class="line"> drop_last = <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#迭代数据</span></span><br><span class="line"><span class="keyword">for</span> batch, <span class="keyword">in</span> dl:</span><br><span class="line">    <span class="built_in">print</span>(batch)</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">tensor([<span class="number">35</span>, <span class="number">19</span>,  <span class="number">3</span>,  <span class="number">1</span>, <span class="number">24</span>, <span class="number">20</span>,  <span class="number">8</span>, <span class="number">37</span>, <span class="number">32</span>, <span class="number">38</span>])</span><br><span class="line">tensor([<span class="number">28</span>, <span class="number">26</span>,  <span class="number">7</span>, <span class="number">48</span>,  <span class="number">4</span>, <span class="number">41</span>, <span class="number">15</span>, <span class="number">45</span>, <span class="number">11</span>, <span class="number">14</span>])</span><br><span class="line">tensor([<span class="number">23</span>,  <span class="number">5</span>, <span class="number">10</span>,  <span class="number">6</span>, <span class="number">18</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">42</span>, <span class="number">12</span>])</span><br><span class="line">tensor([<span class="number">34</span>, <span class="number">47</span>, <span class="number">30</span>, <span class="number">25</span>, <span class="number">29</span>, <span class="number">49</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">33</span>, <span class="number">13</span>])</span><br></pre></td></tr></table></figure>
<h4 id="数据的预处理模块">5. 数据的预处理模块</h4>
<p>transforms是pytorch中常用的图像预处理方法，这个在torchvision计算机视觉工具包中。在安装pytorch时顺便安装了torchvision，在torchvision中，有三个主要的模块：</p>
<ul>
<li><code>torchvision.transforms</code>:常用的图像预处理方法，比如：标准化、中心化、旋转、翻转等；</li>
<li><code>torchvision.datasets</code>:常用的数据集的<code>dataset</code>实现，例如：MNIST、CIFAR-10、ImageNet等；</li>
<li><code>torchvision.models</code>:常用的预训练模型，AlexNet、VGG、ResNet等。</li>
</ul>
<h5 id="裁剪">5.1 裁剪</h5>
<h6 id="随机裁剪transforms.randomcrop">5.1.1 随机裁剪：transforms.RandomCrop</h6>
<p>该函数根据给定的size进行随机裁剪 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transforms.RandomCrop(</span><br><span class="line">    size,</span><br><span class="line">    padding=<span class="literal">None</span>,</span><br><span class="line">    pad_if_needed=<span class="literal">False</span>,</span><br><span class="line">    fill=<span class="number">0</span>,</span><br><span class="line">    padding_mode=<span class="string">&#x27;constant&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure> - `size·：可为sequence or int，若为sequence，则为（h， w），若为int，则为（int， int);</p>
<ul>
<li><p>`padding·：可为int or sequence，此参数是设置填充多少个pixel；若为int，表示图像上下左右均填充int个pixel，例如padding=4，表示图像上下左右均填充4个pixel，若为32×32，则图像填充后为40×40；若为sequence，若为2个数，第一个数表示左右填充多少，第二个数表示上下填充多少；当有四个数时表示左、上、右、下</p></li>
<li><p>·pad_if_needed·：若图像小于设定的size，则填充；</p></li>
<li><p>fill：表示需要填充的值，默认为0.当值为int时，表示各通道均填充该值，当值为3时，表示RGB三个通道各需要填充的值；</p></li>
<li><code>padding_mode</code>：填充模式，有4中填充模式：
<ul>
<li>1、<code>constant</code>：常数填充；</li>
<li>2、<code>edge</code>：图像的边缘值填充；</li>
<li>3、<code>reflect</code>：镜像填充，最后一个像素不镜像，例如 [1, 2, 3, 4]. -&gt; [3, 2, 1, 2, 3, 4, 3, 2]；</li>
<li>4、<code>symmetric</code>:镜像填充，最后一个元素填充，例如：[1, 2, 3, 4] -&gt; [2, 1, 1, 2, 3, 4, 4, 3]</li>
</ul></li>
</ul>
<h6 id="中心裁剪transforms.centercrop">5.1.2 中心裁剪transforms.CenterCrop</h6>
<p>依据给定的参数进行中心裁剪 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.CenterCrop(size)</span><br><span class="line"></span><br><span class="line">size：若为sequence，则为（h, w）, 若为<span class="built_in">int</span>， 则为（<span class="built_in">int</span>， <span class="built_in">int</span>）</span><br></pre></td></tr></table></figure></p>
<h6 id="随机长宽比裁剪transforms.randomresizedcrop">5.1.3 随机长宽比裁剪transforms.RandomResizedCrop()</h6>
<p>随机大小，随机长宽比裁剪原始图片，最后将图片 resize 到设定好的 size <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomResizedCrop(</span><br><span class="line">    size,</span><br><span class="line">    scale=(<span class="number">0.08</span>, <span class="number">1.0</span>),</span><br><span class="line">    ratio=(<span class="number">0.75</span>, <span class="number">1.3333333333333333</span>),</span><br><span class="line">    interpolation=<span class="number">2</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure> - <code>size</code>：所需裁减图片尺寸 - <code>scale</code>：随机 crop 的大小区间，如 scale=(0.08, 1.0)，表示随机 crop 出来的图片会在的 0.08 倍至 1 倍之间。 - <code>ratio</code>： 随机长宽比设置</p>
<h6 id="上下左右中心裁剪transforms.fivecrop">5.1.4 上下左右中心裁剪transforms.FiveCrop()</h6>
<p>对图片进行上下左右以及中心裁剪，获得 5 张图片，返回一个 4D-tensor <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.FiveCrop(size)</span><br></pre></td></tr></table></figure></p>
<h5 id="翻转和旋转">5.2 翻转和旋转</h5>
<h6 id="翻转">5.2.1 翻转</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#依据概率 p 对 PIL 图片进行水平翻转</span></span><br><span class="line">torchvision.transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#依概率p垂直翻转</span></span><br><span class="line">torchvision.transforms.RandomVerticalFlip(p=<span class="number">0.5</span>)</span><br><span class="line">p为概率值</span><br></pre></td></tr></table></figure>
<h6 id="旋转">5.2.2 旋转</h6>
<p>依 degrees 随机旋转一定角度 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.RandomRotation(degrees, resample=<span class="literal">False</span>, </span><br><span class="line">                                      expand=<span class="literal">False</span>, center=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure> - <code>degress</code>：(sequence or float or int) ，若为单个数，如 30，则表示在（-30，+30）之间随机旋转；若为sequence，如(30，60)，则表示在 30-60 度之间随机旋转； - <code>resample</code>：重采样方法选择，可选 PIL.Image.NEAREST, PIL.Image.BILINEAR,PIL.Image.BICUBIC，默认为最近邻; - <code>expand</code>: 是否扩大图片，以保持原图信息； - <code>center</code>: 设置旋转点，默认是中心旋转</p>
<h5 id="图像变换">5.3 图像变换</h5>
<h6 id="resize">5.3.1 resize</h6>
<p>重置图像分辨率 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.Resize(size, interpolation=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h6 id="标准化">5.3.2 标准化</h6>
<p>对数据按通道进行标准化，即先减均值，再除以标准差，注意是 hwc <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.Normalize(mean, std)</span><br></pre></td></tr></table></figure></p>
<h6 id="转化为tensortransforms.totensor">5.3.3 转化为Tensor:transforms.ToTensor</h6>
<p>将 PIL Image 或者 ndarray 转换为 tensor，并且归一化至[0-1]。注意归一化至[0-1]是直接除以 255，若自己的 ndarray 数据尺度有变化，则需要自行修改。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torchvision.transforms.ToTensor()</span><br></pre></td></tr></table></figure> ###### 5.3.4 例子 data_transforms是一个字典，其指定了所有图像训练集和检验集预处理操作 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#transfomrs.Compose()表示按顺序执行</span></span><br><span class="line">data_transforms = &#123;</span><br><span class="line">    <span class="string">&#x27;train&#x27;</span>: </span><br><span class="line">        transforms.Compose([</span><br><span class="line">        transforms.Resize([<span class="number">96</span>, <span class="number">96</span>]),</span><br><span class="line">        transforms.RandomRotation(<span class="number">45</span>),<span class="comment">#随机旋转，-45到45度之间随机选</span></span><br><span class="line">        transforms.CenterCrop(<span class="number">64</span>),<span class="comment">#从中心开始裁剪</span></span><br><span class="line">        transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>),<span class="comment">#随机水平翻转 选择一个概率概率</span></span><br><span class="line">        transforms.RandomVerticalFlip(p=<span class="number">0.5</span>),<span class="comment">#随机垂直翻转</span></span><br><span class="line">        transforms.ColorJitter(brightness=<span class="number">0.2</span>, contrast=<span class="number">0.1</span>, saturation=<span class="number">0.1</span>, hue=<span class="number">0.1</span>),<span class="comment">#参数1为亮度，参数2为对比度，参数3为饱和度，参数4为色相</span></span><br><span class="line">        transforms.RandomGrayscale(p=<span class="number">0.025</span>),<span class="comment">#概率转换成灰度率，3通道就是R=G=B</span></span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])<span class="comment">#均值，标准差</span></span><br><span class="line">    ]),</span><br><span class="line">    <span class="string">&#x27;valid&#x27;</span>: </span><br><span class="line">        transforms.Compose([</span><br><span class="line">        transforms.Resize([<span class="number">64</span>, <span class="number">64</span>]),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ]),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#使用datasets.ImageFloder()读取数据</span></span><br><span class="line">image_datasets = &#123;x: datasets.ImageFolder(os.path.join(data_dir, x), data_transforms[x]) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;valid&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="pytorch的模型搭建torch.nn模块">6. pytorch的模型搭建torch.nn模块</h4>
<p>机器学习的五大板块之一就是模型，好的模型事半功倍。</p>
<h5 id="nn.functional-和-nn.module">6.1 nn.functional 和 nn.Module</h5>
<p>Pytorch和神经网络相关的功能组件大多都封装在 torch.nn模块下。 这些功能组件的绝大部分既有函数形式<code>nn.funtional</code>实现，也有类形式<code>nn.Module</code>实现。</p>
<p>其中nn.functional(一般引入后改名为F)有各种功能组件的函数实现,例如: - <strong>激活函数</strong>: <code>F.relu 、F.sigmoid 、F.tanh 、F.softmax</code></p>
<ul>
<li><p><strong>模型层</strong>： <code>F.linear(全连接)、F.conv2d(2d卷积)、F.max_pool2d(2d最大池化)、F.dropout2d、 F.embedding</code></p></li>
<li><p><strong>损失函数</strong>：<code>F.binary_cross_entropy 、F.mse_loss 、F.cross_entropy(交叉熵损失函数)</code></p></li>
</ul>
<p><strong>但为了进一步便于对参数进行管理，一般通过继承 nn.Module 转换成为类的实现形式，并直接封装在 nn 模块下，例如：</strong></p>
<ul>
<li><p><strong>激活函数</strong>： <code>nn.ReLU 、 nn.Sigmoid 、 nn.Tanh 、nn.Softmax</code></p></li>
<li><p><strong>模型层</strong>： <code>nn.Linear 、nn.Conv2d 、nn.MaxPool2d 、nn.Dropout2d 、nn.Embedding</code></p></li>
<li><p><strong>损失函数</strong>：<code>nn.BCELoss 、 nn.MSELoss 、 nn.CrossEntropyLoss</code></p></li>
</ul>
<p>实际上nn.Module除了可以管理其引用的各种参数，还可以管理其引用的子模块，功能十分强大</p>
<h5 id="使用nn.module来管理参数">6.2 使用nn.Module来管理参数</h5>
<p>在Pytorch中，模型的参数是需要被优化器训练的，因此，通常要设置参数为<code>requires_grad = True</code>的张量。 同时，在一个模型中，往往有许多的参数，要手动管理这些参数并不是一件容易的事情。 Pytorch一般将参数用<code>nn.Parameter</code>来表示，并且用<code>nn.Module</code>来管理其结构下的所有参数。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#模型，模型自动生成权值矩阵\卷积核</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CNN</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(CNN, self).__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(         <span class="comment"># 输入大小 (1, 28, 28)</span></span><br><span class="line">            nn.Conv2d(</span><br><span class="line">                in_channels=<span class="number">1</span>,              <span class="comment"># 灰度图</span></span><br><span class="line">                out_channels=<span class="number">16</span>,            <span class="comment"># 要得到几多少个特征图</span></span><br><span class="line">                kernel_size=<span class="number">5</span>,              <span class="comment"># 卷积核大小</span></span><br><span class="line">                stride=<span class="number">1</span>,                   <span class="comment"># 步长</span></span><br><span class="line">                padding=<span class="number">2</span>,                  <span class="comment"># 如果希望卷积后大小跟原来一样，需要设置padding=(kernel_size-1)/2 if stride=1</span></span><br><span class="line">            ),                              <span class="comment"># 输出的特征图为 (16, 28, 28)</span></span><br><span class="line">            nn.ReLU(),                      <span class="comment"># relu层</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>),    <span class="comment"># 进行池化操作（2x2 区域）, 输出结果为： (16, 14, 14)</span></span><br><span class="line">        )</span><br><span class="line">        self.conv2 = nn.Sequential(         <span class="comment"># 下一个套餐的输入 (16, 14, 14)</span></span><br><span class="line">            nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),     <span class="comment"># 输出 (32, 14, 14)</span></span><br><span class="line">            nn.ReLU(),                      <span class="comment"># relu层</span></span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),                <span class="comment"># 输出 (32, 7, 7)</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        self.conv3 = nn.Sequential(         <span class="comment"># 下一个套餐的输入 (16, 14, 14)</span></span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),     <span class="comment"># 输出 (32, 14, 14)</span></span><br><span class="line">            nn.ReLU(),             <span class="comment"># 输出 (32, 7, 7)</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        self.out = nn.Linear(<span class="number">64</span> * <span class="number">7</span> * <span class="number">7</span>, <span class="number">10</span>)   <span class="comment"># 全连接层得到的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.conv3(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)           <span class="comment"># flatten操作，结果为：(batch_size, 32 * 7 * 7)</span></span><br><span class="line">        output = self.out(x)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">net = CNN() </span><br><span class="line"><span class="comment">#损失函数</span></span><br><span class="line">criterion = nn.CrossEntropyLoss() </span><br><span class="line"><span class="comment">#优化器，nn.paarameters管理参数</span></span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.001</span>) <span class="comment">#定义优化器，普通的随机梯度下降算法</span></span><br></pre></td></tr></table></figure></p>
<h5 id="使用nn.module来管理子模块">6.2 使用nn.Module来管理子模块</h5>
<p>一般情况下，我们都很少直接使用 nn.Parameter来定义参数构建模型，<strong>而是通过一些拼装一些常用的模型层来构造模型，如上面的<code>CNN</code>类拼接了模型层，自动生成参数值由<code>nn.parameters</code>管理。</strong>这些模型层也是继承自<code>nn.Module</code>的对象,本身也包括参数，<strong>模型层属于我们要定义的模块的子模块。 nn.Module提供了一些方法可以管理这些子模块。</strong></p>
<ul>
<li><p><code>children()</code>: 返回生成器，包括模块下的所有子模块。</p></li>
<li><p><code>named_children()</code>：返回一个生成器，只有模块下的所有子模块，以及它们的名字。</p></li>
<li><p><code>modules()</code>：返回一个生成器，不仅返回模块下的子模块，连子模块下的子模块也会被返回，包括模块本身。</p></li>
<li><p><code>named_modules()</code>：返回一个生成器，包括模块下的所有各个层级的模块以及它们的名字，包括模块本身。</p></li>
</ul>
<p>上面函数返回一个可迭代的生成器，可通过for循环查看返回值。见<a href="https://zhuanlan.zhihu.com/p/349156416">PyTorch中的modules()和children()相关函数简析</a></p>
<h5 id="模型层">6.3 模型层</h5>
<p>深度学习模型一般由各种模型层组合而成，<code>torch.nn</code>中内置了非常丰富的各种模型层。它们都属于<code>nn.Module</code>的子类，具备参数管理功能,如上面提到的<code>nn.Linear、 nn.Flatten、 nn.Dropout, nn.BatchNorm2d、nn.Conv2d、nn.AvgPool2d、nn.Conv1d、nn.ConvTranspose2d、nn.Embedding、nn.GRU、nn.LSTM、nn.Transformer</code>，下面一小结我们将列举pytorch内置的模型层</p>
<p><strong><em>如果这些内置模型层不能够满足需求，我们也可以通过继承nn.Module基类构建自定义的模型层。实际上，pytorch不区分模型和模型层，都是通过继承nn.Module进行构建。因此，我们只要继承nn.Module基类并实现forward方法即可自定义模型层。</em></strong></p>
<h5 id="内置模型层">6.4 内置模型层</h5>
<p>这里只对相应的模型层做一个简介，详细的API文档查阅<a href="https://pytorch.org/vision/stable/models.html">官方文档</a> ###### 6.4.1 基础层 - <code>nn.Linear</code>：全连接层。参数个数 = 输入层特征数× 输出层特征数(weight)＋ 输出层特征数 (bias)</p>
<ul>
<li><p><code>nn.Flatten</code>：压平层，用于将多维张量样本压成一维张量样本。</p></li>
<li><p><code>nn.BatchNorm1d</code>：一维批标准化层。通过线性变换将输入批次缩放平移到稳定的均值和标准差。可以增强模型对输入不同分布的适应性，加快模型训练速度，有轻微正则化效果。一般在激活函数之前使用。可以用afine参数设置该层是否含有可以训练的参数。</p></li>
<li><p><code>nn.BatchNorm2d</code>：二维批标准化层。</p></li>
<li><p><code>nn.BatchNorm3d</code>：三维批标准化层。</p></li>
<li><p><code>nn.Dropout</code>：一维随机丢弃层。一种正则化手段。</p></li>
<li><p><code>nn.Dropout2d</code>：二维随机丢弃层。</p></li>
<li><p><code>nn.Dropout3d</code>：三维随机丢弃层。</p></li>
<li><p><code>nn.Threshold</code>：限幅层。当输入大于或小于阈值范围时，截断之。</p></li>
<li><p><code>nn.ConstantPad2d</code>： 二维常数填充层。对二维张量样本填充常数扩展长度。</p></li>
<li><p><code>nn.ReplicationPad1d</code>： 一维复制填充层。对一维张量样本通过复制边缘值填充扩展长度。</p></li>
<li><p><code>nn.ZeroPad2d</code>：二维零值填充层。对二维张量样本在边缘填充0值.</p></li>
<li><p><code>nn.GroupNorm</code>：组归一化。一种替代批归一化的方法，将通道分成若干组进行归一。不受 batch大小限制，据称性能和效果都优于BatchNorm。</p></li>
<li><p><code>nn.LayerNorm</code>：层归一化。较少使用。</p></li>
<li><p><code>nn.InstanceNorm2d</code>: 样本归一化。较少使用。</p></li>
</ul>
<h6 id="卷积网络相关层">6.4.2 卷积网络相关层</h6>
<ul>
<li><p><code>nn.Conv1d</code>：普通一维卷积，常用于文本。<code>参数个数 = 输入通道数×卷积核尺寸(如3)×卷积核个数 + 卷积核个数</code></p></li>
<li><p><code>nn.Conv2d</code>：普通二维卷积，常用于图像。<code>参数个数 = 输入通道数×卷积核尺寸(如3乘3)×卷积核个数 + 卷积核个数</code>。通过调整<code>dilation</code>参数大于1，可以变成空洞卷积，增大卷积核感受野。 通过调整<code>groups</code>参数不为1，可以变成分组卷积。分组卷积中不同分组使用相同的卷积核，显著减少参数数量。 当<code>groups</code>参数等于通道数时，相当于tensorflow中的二维深度卷积层<code>tf.keras.layers.DepthwiseConv2D</code>。 利用分组卷积和1乘1卷积的组合操作，可以构造相当于<code>Keras</code>中的二维深度可分离卷积层<code>tf.keras.layers.SeparableConv2D</code>。</p></li>
<li><p><code>nn.Conv3d</code>：普通三维卷积，常用于视频。<code>参数个数 = 输入通道数×卷积核尺寸(如3乘3乘3)× 卷积核个数 + 卷积核个数</code> 。</p></li>
<li><p><code>nn.MaxPool1d</code>: 一维最大池化。</p></li>
<li><p><code>nn.MaxPool2d</code>：二维最大池化。一种下采样方式。没有需要训练的参数。</p></li>
<li><p><code>nn.MaxPool3d</code>：三维最大池化。</p></li>
<li><p><code>nn.AdaptiveMaxPool2d</code>：二维自适应最大池化。无论输入图像的尺寸如何变化，输出的图像尺寸是固定的。 该函数的实现原理，大概是通过输入图像的尺寸和要得到的输出图像的 尺寸来反向推算池化算子的<code>padding,stride</code>等参数。</p></li>
<li><p>nn.FractionalMaxPool2d：二维分数最大池化。普通最大池化通常输入尺寸是输出的整数 倍。而分数最大池化则可以不必是整数。分数最大池化使用了一些随机采样策略，有一定的 正则效果，可以用它来代替普通最大池化和Dropout层。</p></li>
<li><p><code>nn.AvgPool2d</code>：二维平均池化。</p></li>
<li><p><code>nn.AdaptiveAvgPool2d</code>：二维自适应平均池化。无论输入的维度如何变化，输出的维度是固定的。</p></li>
<li><p><code>nn.ConvTranspose2d</code>：二维卷积转置层，俗称反卷积层。并非卷积的逆操作，但在卷积核相同的情况下，当其输入尺寸是卷积操作输出尺寸的情况下，卷积转置的输出尺寸恰好是卷积操作的输入尺寸。在语义分割中可用于上采样。</p></li>
<li><p><code>nn.Upsample</code>：上采样层，操作效果和池化相反。可以通过mode参数控制上采样策略 为”nearest”最邻近策略或”linear”线性插值策略。</p></li>
<li><p><code>nn.Unfold</code>：滑动窗口提取层。其参数和卷积操作<code>nn.Conv2d</code>相同。实际上，卷积操作可以等价于<code>nn.Unfold</code>和<code>nn.Linear</code>以及<code>nn.Fold</code>的一个组合。 其中<code>nn.Unfold</code>操作可以从输入中提取各个滑动窗口的数值矩阵，并将其压平成一维。利用<code>nn.Linear</code>将<code>nn.Unfold</code>的输出和卷积核做乘法后，再使用 <code>nn.Fold</code>操作将结果转换成输出图片形状。</p></li>
<li><p><code>nn.Fold</code>：逆滑动窗口提取层。</p></li>
</ul>
<p><strong><em>注意</em></strong>：</p>
<ul>
<li>卷积核个数==输出的feature map（activation map）个数，比如输入是一个<span class="math inline">\(32x32x3\)</span>的图像，<span class="math inline">\(3\)</span>表示RGB三通道，每个<code>filter/kernel</code>是<span class="math inline">\(5x5x3\)</span>，一个卷积核产生一个<span class="math inline">\(feature map\)</span>，下图中，有<span class="math inline">\(6\)</span>个 <span class="math inline">\(5x5x3\)</span>的卷积核，故输出<span class="math inline">\(6\)</span>个<code>feature map（activation map）</code>，大小为<span class="math inline">\(28x28x6\)</span>。 <img src="/2022/10/06/pytorch%E5%9F%BA%E7%A1%80/kernel.png" width="600"></li>
<li>参数个数为：卷积核个数*(卷积核大小)+卷积核个数(偏置数)</li>
<li>偏置数==卷积核个数</li>
</ul>
<h6 id="循环网络相关层">6.4.3 循环网络相关层</h6>
<ul>
<li><p><code>nn.Embedding</code>：嵌入层。一种比<code>Onehot</code>更加有效的对离散特征进行编码的方法。一般用于将输入中的单词映射为稠密向量。嵌入层的参数需要学习。</p></li>
<li><p><code>nn.LSTM</code>：长短记忆循环网络层【支持多层】。最普遍使用的循环网络层。具有携带轨道，遗忘门，更新门，输出门。可以较为有效地缓解梯度消失问题，从而能够适用长期依赖问题。设置<code>bidirectional = True</code>时可以得到双向<code>LSTM</code>。需要注意的时，默认的输入和输出形状是<code>(seq,batch,feature)</code>, 如果需要将<code>batch</code>维度放在第0维，则要设置<code>batch_first</code>参数设置为<code>True</code>。</p></li>
<li><p><code>nn.GRU</code>：门控循环网络层【支持多层】。LSTM的低配版，不具有携带轨道，参数数量少于 LSTM，训练速度更快。</p></li>
<li><p><code>nn.RNN</code>：简单循环网络层【支持多层】。容易存在梯度消失，不能够适用长期依赖问题。 一般较少使用。</p></li>
<li><p><code>nn.LSTMCell</code>：长短记忆循环网络单元。和<code>nn.LSTM</code>在整个序列上迭代相比，它仅在序列上迭代一步。一般较少使用。</p></li>
<li><p><code>nn.GRUCell</code>：门控循环网络单元。和<code>nn.GRU</code>在整个序列上迭代相比，它仅在序列上迭代一步。一般较少使用。</p></li>
<li><p><code>nn.RNNCell</code>：简单循环网络单元。和<code>nn.RNN</code>在整个序列上迭代相比，它仅在序列上迭代一步。一般较少使用。</p></li>
</ul>
<h6 id="transformer相关层">6.4.4 Transformer相关层</h6>
<p><code>Transformer</code>网络结构是替代循环网络的一种结构，解决了循环网络难以并行，难以捕捉长期依赖的缺陷。它是目前NLP任务的主流模型的主要构成部分。<code>Transformer</code>网络结构由<code>TransformerEncoder</code>编码器和<code>TransformerDecoder</code>解码器组成。编码器和解码器的核心是<code>MultiheadAttention</code>多头注意力层。</p>
<ul>
<li><p><code>nn.TransformerEncoder</code>：<code>Transformer</code>编码器结构。由多个<code>nn.TransformerEncoderLayer</code>编 码器层组成。</p></li>
<li><p><code>nn.TransformerDecoder</code>：<code>Transformer</code>解码器结构。由多个<code>nn.TransformerDecoderLayer</code>解码器层组成。</p></li>
<li><p><code>nn.TransformerEncoderLayer</code>：<code>Transformer</code>的编码器层。</p></li>
<li><p><code>nn.TransformerDecoderLayer</code>：<code>Transformer</code>的解码器层。</p></li>
<li><p><code>nn.MultiheadAttention</code>：多头注意力层。</p></li>
</ul>
<h6 id="自定义模型层">6.4.5 自定义模型层</h6>
<p>如果Pytorch的内置模型层不能够满足需求，<strong>我们也可以通过继承<code>nn.Module</code>基类构建自定义的模型层。实际上，pytorch不区分模型和模型层，都是通过继承<code>nn.Module</code>进行构建。 因此，我们只要继承nn.Module基类并实现forward方法即可自定义模型层</strong>。 下面是Pytorch的nn.Linear层的源码，我们可以仿照它来自定义模型层</p>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch常用函数</title>
    <url>/2022/10/29/pytorch%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="torch">1. torch</h4>
<p>包 torch 包含了多维张量的数据结构以及基于其上的多种数学操作。另外，它也提供了多种工具，其中一些可以更有效地对张量和任意类型进行序列化。</p>
<p>它有 CUDA 的对应实现，可以在 NVIDIA GPU 上进行张量运算(计算能力&gt;=2.0)。</p>
<span id="more"></span>
<h5 id="tensor张量">1.1 Tensor张量</h5>
<h6 id="torch.numel">1.1.1 torch.numel</h6>
<p><code>torch.numel(input)-&gt;int</code>，返回 input 张量中的元素个数。</p>
<ul>
<li>参数: input (Tensor)为输入张量对象 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.randn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.numel(a)</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="创建操作">1.2 创建操作</h5>
<h6 id="torch.eye">1.2.1 torch.eye</h6>
<p><code>torch.eye(n, m=None, out=None)</code>,返回一个 2 维张量，对角线位置全 1，其它位置全 0</p>
<ul>
<li><code>n (int )</code> – 行数</li>
<li><code>m (int, optional)</code> – 列数.如果为 None,则默认为 n</li>
<li><code>out (Tensor, optinal)</code> - Output tensor</li>
</ul>
<p>返回值: 对角线位置全 1，其它位置全 0 的 2 维张量 返回值类型: Tensor <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.eye(<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">[torch.FloatTensor of size 3x3]</span><br></pre></td></tr></table></figure></p>
<h6 id="from_numpy">1.2.2 from_numpy</h6>
<p><code>torch.from_numpy(ndarray) → Tensor</code>。将 numpy.ndarray 转换为 pytorch 的 Tensor。返回的张量 tensor 和 numpy的 ndarray 共享同一内存空间。修改一个会导致另外一个也被修改。返回的张量不能改变大小。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = numpy.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = torch.from_numpy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">torch.LongTensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([-<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></p>
<h6 id="torch.linspace">1.2.3 torch.linspace</h6>
<p><code>torch.linspace(start, end, steps=100, out=None) → Tensor</code>返回一个 1 维张量，包含在区间 <code>start</code> 和 <code>end</code> 上均匀间隔的 step 个点。 输出 1 维张量的长度为</p>
<ul>
<li><code>start (float)</code> – 序列的起始点</li>
<li><code>end (float)</code> – 序列的最终值</li>
<li><code>steps (int)</code> – 在 start 和 end 间生成的样本数</li>
<li><code>out (Tensor, optional)</code> – 结果张量 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.linspace(<span class="number">3</span>, <span class="number">10</span>, steps=<span class="number">5</span>)</span><br><span class="line"><span class="number">3.0000</span></span><br><span class="line"><span class="number">4.7500</span></span><br><span class="line"><span class="number">6.5000</span></span><br><span class="line"><span class="number">8.2500</span></span><br><span class="line"><span class="number">10.0000</span></span><br><span class="line">[torch.FloatTensor of size <span class="number">5</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.ones">1.2.4 torch.ones</h6>
<p><code>torch.ones(*sizes, out=None) → Tensor</code>.返回一个全为 1 的张量，形状由可变参数 sizes 定义。 参数:</p>
<ul>
<li><code>sizes (int...)</code> – 整数序列，定义了输出形状</li>
<li><code>out (Tensor, optional)</code> – 结果张量 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.ones(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">[torch.FloatTensor of size 2x3]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.rand">1.2.5 torch.rand</h6>
<p><code>torch.rand(*sizes, out=None) → Tensor</code>返回一个张量，包含了从区间[0,1)的均匀分布中抽取的一组随机数，形状由可变参数sizes 定义。 参数:</p>
<ul>
<li><code>sizes (int...)</code> – 整数序列，定义了输出形状</li>
<li><code>out (Tensor, optinal)</code> - 结果张量 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.rand(<span class="number">4</span>)</span><br><span class="line"><span class="number">0.9193</span></span><br><span class="line"><span class="number">0.3347</span></span><br><span class="line"><span class="number">0.3232</span></span><br><span class="line"><span class="number">0.7715</span></span><br><span class="line">[torch.FloatTensor of size <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.randn">1.2.6 torch.randn</h6>
<p><code>torch.randn(*sizes, out=None) → Tensor</code>.返回一个张量，包含了从标准正态分布(均值为 0，方差为 1，即高斯白噪声)中抽取一组随机数，形状由可变参数 sizes 定义。 参数:</p>
<ul>
<li><code>sizes (int...)</code> – 整数序列，定义了输出形状</li>
<li><code>out (Tensor, optinal)</code> - 结果张量 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1.4339</span> <span class="number">0.3351</span> -<span class="number">1.0999</span></span><br><span class="line"><span class="number">1.5458</span> -<span class="number">0.9643</span> -<span class="number">0.3558</span></span><br><span class="line">[torch.FloatTensor of size 2x3]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.randperm">1.2.7 torch.randperm</h6>
<p><code>torch.randperm(n, out=None) → LongTensor</code>.给定参数 n，返回一个从 0 到 n-1 的随机整数排列。 参数:</p>
<ul>
<li><code>n (int)</code> – 上边界(不包含) <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.randperm(<span class="number">4</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">[torch.LongTensor of size <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.arange">1.2.8 torch.arange</h6>
<p><code>torch.arange(start, end, step=1, out=None) → Tensor</code>。返回一个 1 维张量，长度为 <code>floor((end−start)/step)</code>。包含从<code>start</code>到<code>end</code>，以 <code>step</code> 为步长的一组序列值(默认步长为 1)。 参数:</p>
<ul>
<li><code>start (float)</code> – 序列的起始点</li>
<li><code>end (float)</code> – 序列的终止点</li>
<li><code>step (float)</code> – 相邻点的间隔大小 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.arange(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[torch.FloatTensor of size <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.range">1.2.9 torch.range</h6>
<p><code>torch.range(start, end, step=1, out=None) → Tensor</code>。返回一个 1 维张量，有 <code>floor((end−start)/step)+1</code>个元素。包含在半开区间<code>[start, end）</code>从 start开始，以 step 为步长的一组值。 step 是两个值之间的间隔，即 <code>xi+1=xi+step</code></p>
<p><strong><em>警告：建议使用函数 torch.arange()</em></strong></p>
<ul>
<li><code>start (float)</code> – 序列的起始点</li>
<li><code>end (float)</code> – 序列的最终值</li>
<li><code>step (int)</code> – 相邻点的间隔大小 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;torch.<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">[torch.FloatTensor of size <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.tensor">1.2.10 torch.tensor</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.tensor(data, </span><br><span class="line">             dtype=<span class="literal">None</span>, </span><br><span class="line">             device=<span class="literal">None</span>, </span><br><span class="line">             requires_grad=<span class="literal">False</span>, </span><br><span class="line">             pin_memory=<span class="literal">False</span>) -&gt; Tensor</span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code>：数据，可以是list，也可以是numpy</li>
<li><code>dtype</code>：数据类型，默认和data一致</li>
<li><code>device</code>：tensor所在的设备</li>
<li><code>requires_grad</code>：是否需要梯度，默认False，在搭建神经网络时需要将求导的参数设为True</li>
<li><code>pin_memory</code>：是否存于锁页内存，默认False</li>
</ul>
<h6 id="torch.zeros">1.2.11 torch.zeros</h6>
<p>返回一个全为标量 0 的张量，形状由可变参数 sizes 定义。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.zeros(*size, </span><br><span class="line">            out=<span class="literal">None</span>, </span><br><span class="line">            dtype=<span class="literal">None</span>, </span><br><span class="line">            layout=torch.strided, </span><br><span class="line">            device=<span class="literal">None</span>, </span><br><span class="line">            requires_grad=<span class="literal">False</span>) -&gt; Tensor</span><br></pre></td></tr></table></figure> - <code>size</code>：张量的形状，如（3，3） - <code>layout</code> ：这个是内存中的布局形式,有strided和sparse_coo等 - <code>out</code>：表示输出张量，就是再把这个张量赋值给别的一个张量，但是这两个张量时一样的，指的同一个内存地址 - <code>device</code>：所在的设备，gpu/cpu - <code>requires_grad</code>：是否需要梯度</p>
<h5 id="tensor的常用操作">1.3 Tensor的常用操作</h5>
<p>对于tensor数据我们经常会进行切片、索引、降维、升维、连接等操作。这里介绍一下我们经常用到的。</p>
<h6 id="torch.cat">1.3.1 torch.cat</h6>
<p><code>torch.cat(inputs, dimension=0) → Tensor</code>。在<strong>给定维度</strong>上对输入的张量序列 seq 进行连接操作。<code>torch.cat()</code>可以看做 <code>torch.split()</code>和 <code>torch.chunk()</code>的反操作。</p>
<ul>
<li><code>inputs (sequence of Tensors)</code> – 可以是任意相同 Tensor 类型的 python 序列</li>
<li><code>dimension (int, optional)</code> – 沿着此维连接张量序列。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#沿着0维合并</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">0.5983</span> -<span class="number">0.0341</span> <span class="number">2.4918</span></span><br><span class="line"><span class="number">1.5981</span> -<span class="number">0.5265</span> -<span class="number">0.8735</span></span><br><span class="line">[torch.FloatTensor of size 2x3]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, x, x), <span class="number">0</span>)</span><br><span class="line"><span class="number">0.5983</span> -<span class="number">0.0341</span> <span class="number">2.4918</span></span><br><span class="line"><span class="number">1.5981</span> -<span class="number">0.5265</span> -<span class="number">0.8735</span></span><br><span class="line"><span class="number">0.5983</span> -<span class="number">0.0341</span> <span class="number">2.4918</span></span><br><span class="line"><span class="number">1.5981</span> -<span class="number">0.5265</span> -<span class="number">0.8735</span></span><br><span class="line"><span class="number">0.5983</span> -<span class="number">0.0341</span> <span class="number">2.4918</span></span><br><span class="line"><span class="number">1.5981</span> -<span class="number">0.5265</span> -<span class="number">0.8735</span></span><br><span class="line">[torch.FloatTensor of size 6x3]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.chunk">1.3.2 torch.chunk</h6>
<p><code>torch.chunk(tensor, chunks, dim=0)</code>。在给定维度(轴)上将输入张量进行分块儿。</p>
<ul>
<li><code>tensor (Tensor)</code> – 待分块的输入张量</li>
<li><code>chunks (int)</code> – 分块的个数</li>
<li><code>dim (int)</code> – 沿着此维度进行分块</li>
</ul>
<h6 id="torch.split">1.3.3 torch.split</h6>
<p><code>torch.split(tensor, split_size, dim=0)</code>。将输入张量分割成相等形状的 chunks（如果可分）。 如果沿指定维的张量形状大小不能被<code>split_size</code>整分， 则最后一个分块会小于其它分块。</p>
<ul>
<li><code>tensor (Tensor)</code> – 待分割张量</li>
<li><code>split_size (int)</code> – 单个分块的形状大小</li>
<li><code>dim (int)</code> – 沿着此维进行分割</li>
</ul>
<h6 id="torch.squeeze">1.3.4 torch.squeeze</h6>
<p><code>torch.squeeze(input, dim=None, out=None)</code>。当未给定<code>dim</code>时，将输入张量形状中维度为1 去除并返回。 如果输入是形如<code>(A×1×B×1×C×1×D)</code>，那么输出形状就为：<code>(A×B×C×D)</code></p>
<p>当给定 dim 时 ， 那 么 挤 压 操 作 只 在 给 定 维 度 上 。 例 如 ， 输 入 形 状为: <code>(A×1×B)</code>, <code>squeeze(input, 0)</code> 将会保持张量不变，只有用 <code>squeeze(input, 1)</code>，形状会变成<code>(A×B)</code>。</p>
<p><strong><em>注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。</em></strong> 参数:</p>
<ul>
<li><code>input (Tensor)</code> – 输入张量</li>
<li><code>dim (int, optional)</code> – 如果给定，则 input 只会在给定维度挤压</li>
<li><code>out (Tensor, optional)</code> – 输出张量 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.zeros(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.size()</span><br><span class="line">(<span class="number">2L</span>, <span class="number">1L</span>, <span class="number">2L</span>, <span class="number">1L</span>, <span class="number">2L</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.squeeze(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.size()</span><br><span class="line">(<span class="number">2L</span>, <span class="number">2L</span>, <span class="number">2L</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.squeeze(x, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.size()</span><br><span class="line">(<span class="number">2L</span>, <span class="number">1L</span>, <span class="number">2L</span>, <span class="number">1L</span>, <span class="number">2L</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.squeeze(x, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.size()</span><br><span class="line">(<span class="number">2L</span>, <span class="number">2L</span>, <span class="number">1L</span>, <span class="number">2L</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.stacksource">1.3.5 torch.stack[source]</h6>
<p><code>torch.stack(sequence, dim=0)</code>。沿着一个新维度对输入张量序列进行连接。 序列中所有的张量都应该为相同形状。</p>
<p>参数:</p>
<ul>
<li><code>sqequence (Sequence)</code> – 待连接的张量序列</li>
<li><code>dim (int)</code> – 插入的维度。必须介于 0 与 待连接的张量序列数之间。</li>
</ul>
<h6 id="torch.transpose">1.3.6 torch.transpose</h6>
<p><code>torch.transpose(input, dim0, dim1, out=None) → Tensor</code>。交换维度 dim0 和 dim1。 输出张量与输入张量共享内存，所以改变其中一个会导致另外一个也被修改。</p>
<ul>
<li><code>input (Tensor)</code> – 输入张量</li>
<li><code>dim0 (int)</code> – 转置的第一维</li>
<li><code>dim1 (int)</code> – 转置的第二维 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">0.5983</span> -<span class="number">0.0341</span> <span class="number">2.4918</span></span><br><span class="line"><span class="number">1.5981</span> -<span class="number">0.5265</span> -<span class="number">0.8735</span></span><br><span class="line">[torch.FloatTensor of size 2x3]</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="torch.unsqueeze">1.3.7 torch.unsqueeze</h6>
<p><code>torch.unsqueeze(input, dim, out=None)</code>。返回一个新的张量，对输入的制定位置插入维度1 注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。如果 <code>dim</code> 为负，则将会被转化 <code>dim+input.dim()+1</code> 参数:</p>
<ul>
<li><code>tensor (Tensor)</code> – 输入张量</li>
<li><code>dim (int)</code> – 插入维度的索引</li>
<li><code>out (Tensor, optional)</code> – 结果张量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.Tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.unsqueeze(x, <span class="number">0</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">[torch.FloatTensor of size 1x4]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.unsqueeze(x, <span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">[torch.FloatTensor of size 4x1]</span><br></pre></td></tr></table></figure>
<h4 id="nn模块">2. nn模块</h4>
<p>首先应该知道在nn模块当中有两个重要的，分别是<code>torch.nn.Module</code>和<code>nn.functional</code>。<code>torch.nn.Module</code>是所有网络的基类。你的模型也应该继承这个类。 ##### 2.1 一般函数 ###### 2.1.1 nn.ModuleList() 将<code>submodules</code>保存在一个<code>list</code>中。ModuleList 可以像一般的 Python list 一样被索引。而且 ModuleList 中包含的 modules 已经被正确的注册，对所有的 module method 可见。它与<code>Sequential()</code>相似，只是为了集成一些操作便于管理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> out_channel in vgg_out_channels:</span><br><span class="line">    #M为最大池化操作</span><br><span class="line">    <span class="keyword">if</span> out_channel == <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        layers += [nn.<span class="built_in">MaxPool2d</span>(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)]</span><br><span class="line">    #其他为卷积，输出为指定值，刚开始为<span class="number">3</span>通道</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        conv2d = nn.<span class="built_in">Conv2d</span>(in_channel, out_channel, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        layers += [conv2d, nn.<span class="built_in">ReLU</span>(inplace=True)]</span><br><span class="line">        in_channel = out_channel</span><br><span class="line">self.vgg = nn.<span class="built_in">ModuleList</span>(layers)</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">feats = self.vgg[idx](feats)</span><br></pre></td></tr></table></figure></p>
<h6 id="nn.sequential">2.1.2 nn.Sequential()</h6>
<p><code>torch.nn.Sequential</code>是一个<code>Sequential</code>容器，模块将按照构造函数中传递的顺序添加到模块中。另外，也可以传入一个有序模块。具体理解如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">self.covn1=nn.<span class="built_in">Sequential</span>(nn.<span class="built_in">Conv2d</span>(<span class="number">96</span>, <span class="number">96</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>), nn.<span class="built_in">BatchNorm2d</span>(<span class="number">96</span>), nn.<span class="built_in">ReLU</span>(inplace=True),</span><br><span class="line">              nn.<span class="built_in">Conv2d</span>(<span class="number">96</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>), nn.<span class="built_in">BatchNorm2d</span>(<span class="number">32</span>), nn.<span class="built_in">ReLU</span>(inplace=True))</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">features=self.<span class="built_in">covn1</span>(features)</span><br></pre></td></tr></table></figure></p>
<h6 id="torch.nn.parameter">2.1.3 torch.nn.Parameter()</h6>
<p><code>torch.nn.Parameter</code>继承torch.Tensor，其作用将一个不可训练的类型为Tensor的参数转化为可训练的类型为<code>parameter</code>的参数，并将这个参数绑定到<code>module</code>里面，成为<code>module</code>中可训练的参数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Parameter</span>(Tensor data, <span class="type">bool</span> requires_grad)</span><br></pre></td></tr></table></figure> 其中：data为传入Tensor类型参数，requires_grad默认值为True，表示可训练，False表示不可训练。</p>
<h5 id="卷积函数和层次常用">2.2 卷积函数和层次常用</h5>
<h6 id="conv1d">2.2.1 Conv1d</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Conv1d</span>(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, </span><br><span class="line">groups=<span class="number">1</span>, bias=True)</span><br></pre></td></tr></table></figure>
<h6 id="conv2d">2.2.2 Conv2d</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Conv2d</span>(in_channels, </span><br><span class="line">                out_channels, </span><br><span class="line">                kernel_size, </span><br><span class="line">                stride=<span class="number">1</span>, </span><br><span class="line">                padding=<span class="number">0</span>, </span><br><span class="line">                dilation=<span class="number">1</span>, </span><br><span class="line">                groups=<span class="number">1</span>, </span><br><span class="line">                bias=True, </span><br><span class="line">                padding_mode=<span class="string">&#x27;zeros&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>in_channels(int)</code> – 输入信号的通道</li>
<li><code>out_channels(int)</code> – 卷积产生的通道</li>
<li><code>kerner_size(int or tuple)</code> - 卷积核的尺寸</li>
<li><code>stride(int or tuple, optional)</code> - 卷积步长</li>
<li><code>padding(int or tuple, optional)</code> - 输入的每一条边补充 0 的层数</li>
<li><code>dilation(int or tuple, optional)</code> – <strong>定义了卷积核处理数据时各值的间距。换句话说，相比原来的标准卷积，扩张卷积多了一个超参数称之为dilation rate（扩张率），指的是kernel各点之间的间隔数量，正常的卷积核的dilation为1。</strong></li>
<li><code>groups(int, optional)</code> – 从输入通道到输出通道的阻塞连接数</li>
<li><code>bias(bool, optional)</code> - 如果 bias=True，添加偏置</li>
</ul>
<p><img src="/2022/10/29/pytorch%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/dialation.gif" width="400"> 上图是一个扩张率为2，尺寸为 3×3 的空洞卷积，感受野与5×5的卷积核相同，而且仅需要9个参数。在相同的计算条件下，空洞卷积提供了更大的感受野，获得更为丰富的上下文信息。</p>
<h6 id="conv3d">2.2.3 Conv3d</h6>
<p>三维卷积层, 输入的尺度是<code>(N, C_in,D,H,W)</code>，输出尺度<code>（N,C_out,D_out,H_out,W_out）</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Conv3d</span>(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, </span><br><span class="line">groups=<span class="number">1</span>, bias=True)</span><br></pre></td></tr></table></figure></p>
<h6 id="convtranspose1d">2.2.4 ConvTranspose1d</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">ConvTranspose1d</span>(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, </span><br><span class="line">output_padding=<span class="number">0</span>, groups=<span class="number">1</span>, bias=True)</span><br></pre></td></tr></table></figure>
<p>1 维的解卷积操作（transposed convolution operator，注意改视作操作可视作解卷积操作，但并不是真正的解卷积操作） <strong>该模块可以看作是 Conv1d 相对于其输入的梯度</strong>，有时（但不正确地）被称为解卷积操作</p>
<p><strong><em>注意：由于内核的大小，输入的最后的一些列的数据可能会丢失。因为输入和输出是不是完全的互相关。因此，用户可以进行适当的填充（padding 操作）。</em></strong></p>
<h6 id="convtranspose2d">2.2.5 ConvTranspose2d</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">ConvTranspose2d</span>(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, </span><br><span class="line">output_padding=<span class="number">0</span>, groups=<span class="number">1</span>, bias=True)</span><br></pre></td></tr></table></figure>
<p>2 维的转置卷积操作（transposed convolution operator，注意改视作操作可视作解卷积操作，但并不是真正的解卷积操作） 该模块可以看作是 Conv2d 相对于其输入的梯度，有时（但不正确地）被称为解卷积操作。</p>
<h6 id="nn.linear">2.2.6 nn.Linear</h6>
<p>对输入数据做线性变换：$y=Ax+b#，也是我们MLP中使用的函数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Linear</span>(in_features, out_features, bias=True)</span><br></pre></td></tr></table></figure> - <code>in_features</code> - 每个输入样本的大小 - <code>out_features</code> - 每个输出样本的大小 - <code>bias</code> - 若设置为 False，这层不会学习偏置。默认值：True</p>
<h6 id="dropout">2.2.7 Dropout</h6>
<p>随机以概率p将输入张量中部分元素设置为 0。对于每次前向调用，被置 0 的元素都是随机的 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">Dropout</span>(p=<span class="number">0.5</span>, inplace=False)</span><br></pre></td></tr></table></figure> - <code>p</code> - 将元素置 0 的概率。默认值：0.5 - <code>in-place</code> - 若设置为 True，会在原地执行操作。默认值：False</p>
<h5 id="池化函数">2.3 池化函数</h5>
<h6 id="maxpool2d">2.3.1 MaxPool2d</h6>
<p>对于输入信号的输入通道，提供 2 维最大池化（max pooling）操作。如果输入的大小是<code>(N,C,H,W)</code>，那么输出的大小是<code>(N,C,H_out,W_out)</code>。即只会改变矩阵大小，不会改变通道数量。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nn.<span class="built_in">MaxPool2d</span>(kernel_size, stride=None, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, return_indices=False, ceil_mode=False)</span><br></pre></td></tr></table></figure> - <code>kernel_size(int or tuple)</code> - max pooling的窗口大小 - <code>stride(int or tuple, optional)</code> - max pooling的窗口移动的步长。默认值是kernel_size - <code>padding(int or tuple, optional)</code> - 输入的每一条边补充0的层数 - <code>dilation(int or tuple, optional)</code> – 每个点之间的间隙，空洞卷积会用到 - <code>return_indices</code> - 如果等于True，会返回输出最大值的序号，对于上采样操作会有帮助 - <code>ceil_mode</code> - 如果等于True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</p>
<h6 id="maxunpool2d">2.3.2 MaxUnpool2d</h6>
<p>Maxpool2d的逆过程，不过并不是完全的逆过程，因为在 maxpool2d 的过程中，一些值的已经丢失。 MaxUnpool2d 的输入是 MaxPool2d 的输出，包括最大值的索引，并计算所有 maxpool2d 过程中非最大值被设置为零的部分的反向 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">MaxUnpool2d</span>(kernel_size, stride=None, padding=<span class="number">0</span>)</span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：注意：MaxPool2d 可以将多个输入大小映射到相同的输出大小。因此，反演过程可能会变得模棱两可。 为了适应这一点，可以在调用中将输出大小（output_size）作为额外的参数传入。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pool = nn.<span class="built_in">MaxPool2d</span>(<span class="number">2</span>, stride=<span class="number">2</span>, return_indices=True)</span><br><span class="line">&gt;&gt;&gt; unpool = nn.<span class="built_in">MaxUnpool2d</span>(<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt; input = <span class="built_in">Variable</span>(torch.<span class="built_in">Tensor</span>([[[[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"> ... [ <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"> ... [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"> ... [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]]]]))</span><br><span class="line">&gt;&gt;&gt; output, indices = <span class="built_in">pool</span>(input)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">unpool</span>(output, indices)</span><br><span class="line"> Variable containing:</span><br><span class="line"> (<span class="number">0</span> ,<span class="number">0</span> ,.,.) =</span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span> <span class="number">8</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">14</span> <span class="number">0</span> <span class="number">16</span></span><br><span class="line"> [torch.FloatTensor of size <span class="number">1</span>x1x4x4]</span><br><span class="line">&gt;&gt;&gt; <span class="meta"># specify a different output size than input size</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">unpool</span>(output, indices, output_size=torch.<span class="built_in">Size</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>]))</span><br><span class="line"> Variable containing:</span><br><span class="line"> (<span class="number">0</span> ,<span class="number">0</span> ,.,.) =</span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">6</span> <span class="number">0</span> <span class="number">8</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">14</span> <span class="number">0</span></span><br><span class="line"> <span class="number">16</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> [torch.FloatTensor of size <span class="number">1</span>x1x5x5]</span><br><span class="line"><span class="keyword">class</span> torch.nn.<span class="built_in">MaxUnpool3d</span>(kernel_size, stride=None, padding=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h6 id="avgpool2d">2.3.3 AvgPool2d</h6>
<p>对信号的输入通道，提供 2 维的平均池化（average pooling ）。输入信号的大小(N,C,H,W)，输出大小(N,C,H_out,W_out)和池化窗口大小(kH,kW)的关系是 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">AvgPool2d</span>(kernel_size, stride=None, padding=<span class="number">0</span>, ceil_mode=False, </span><br><span class="line">count_include_pad=True)</span><br></pre></td></tr></table></figure></p>
<h6 id="adaptivemaxpool2d">2.3.4 AdaptiveMaxPool2d</h6>
<p>对输入信号，提供 1 维的自适应最大池化操作 对于任何输入大小的输入，可以将输出尺寸指定为<code>H</code>，但是输入和输出特征的数目不会变化 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">AdaptiveMaxPool2d</span>(output_size, return_indices=False)</span><br></pre></td></tr></table></figure> - <code>output_size</code>: 输出信号的尺寸</p>
<ul>
<li><code>return_indices</code>: 如果设置为 True，会返回输出的索引。对 nn.MaxUnpool1d 有用，默认值是 False</li>
</ul>
<h5 id="归一化函数">2.4 归一化函数</h5>
<h6 id="batchnorm2d">2.4.1 BatchNorm2d</h6>
<p>对于所有的batch中样本的同一个channel的数据元素进行标准化处理，即如果有C个通道，无论batch中有多少个样本，都会在通道维度上进行标准化处理，一共进行C次。</p>
<p><span class="math display">\[

y={{x-mean(x)}\over{\sqrt{var(x)+eps}}}×γ+β

\]</span></p>
<ul>
<li>在训练时，该层计算每次输入的均值与方差，并进行移动平均。移动平均默认的动量值为 0.1。</li>
<li>在验证时，训练求得的均值/方差将用于标准化验证数据。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">BatchNorm2d</span>(num_features, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=True)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>num_features</code>： 来自期望输入的特征数，该期望输入的大小为<code>batch_size × num_features × height × width</code></li>
<li><code>eps</code>： 为保证数值稳定性（分母不能趋近或取 0）,给分母加上的值。默认为 1e-5。</li>
<li><code>momentum</code>： 动态均值和动态方差所使用的动量。默认为 0.1。</li>
<li><code>affine</code>： 一个布尔值，当设为 true，给该层添加可学习的仿射变换参数。</li>
</ul>
<p>momentum的作用：BatchNorm2d里面存储均值（running_mean）和方差（running_var）更新时的参数。 <span class="math display">\[
x_{new}=(1-momentum)*x_{old}+momentum*x_{obser}
\]</span> 其中<span class="math inline">\(x_{old}\)</span>为BatchNorm2d里面的均值<code>（running_mean）</code>和方差<code>（running_var）</code>,<span class="math inline">\(x_{0bser}\)</span>为当前观测值（样本）的均值或方差,<span class="math inline">\(x_{new}\)</span>更新后的均值或方差（最后需要重新存储到BatchNorm2d中），momentum为更新参数</p>
<h5 id="functional模块">2.5 functional模块</h5>
<h6 id="interpolate函数">2.5.1 interpolate()函数</h6>
<p><code>torch.nn.functional.interpolate</code>实现插值和上采样。上采样，在深度学习框架中，可以简单的理解为任何可以让你的图像变成更高分辨率的技术即矩阵升维。 最简单的方式是重采样和插值：将输入图片input image进行rescale到一个想要的尺寸，而且计算每个点的像素点，使用如<strong>双线性插值<code>bilinear</code></strong>等插值方法对其余点进行插值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.functional.<span class="built_in">interpolate</span>(input, size=None, scale_factor=None, mode=<span class="string">&#x27;nearest&#x27;</span>, align_corners=None)</span><br></pre></td></tr></table></figure> - <code>input (Tensor)</code> – 输入张量</p>
<ul>
<li><p><code>size (int or Tuple[int] or Tuple[int, int] or Tuple[int, int, int])</code> – 输出大小.</p></li>
<li><p><code>scale_factor (float or Tuple[float])</code> – 指定输出为输入的多少倍数。如果输入为tuple，其也要制定为tuple类型</p></li>
<li><p><code>mode (str)</code> – 可使用的上采样算法，有’nearest’, ‘linear’, ‘bilinear’, ‘bicubic’ , ‘trilinear’和’area’. 默认使用’nearest</p></li>
</ul>
<h5 id="nn.module">2.6 nn.Module</h5>
<p>注意下面的这些函数都是<code>Module</code>这个类的成员函数，不同于上面的一般函数为全局函数。下面的<code>modle</code>都指代模型对象</p>
<h6 id="parameter">2.6.1 parameter()</h6>
<p><code>model.parameters()</code>，这个是成员函数,指获取该模型的所有参数，一般我们再把模型参数传递给优化器是会使用到。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">params = model.<span class="built_in">parameters</span>()</span><br><span class="line">optimizer = torch.optim.<span class="built_in">Adam</span>(params, config.TRAIN[<span class="string">&#x27;learning_rate&#x27;</span>])</span><br></pre></td></tr></table></figure></p>
<h6 id="add_modulename-module">2.6.2 add_module(name, module)</h6>
<p>该函数是一个成岩函数。将一个 <code>child module</code> 添加到当前 <code>modle</code>。 被添加的 <code>module</code> 可以通过 <code>name</code> 属性来获取 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_module</span>(name, <span class="keyword">module</span>)</span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">import</span> torch.<span class="function">nn as nn</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"><span class="function"> def __init__(self):</span></span><br><span class="line"><span class="function"> super(Model, self).__init__()</span></span><br><span class="line"><span class="function"> self.add_module(<span class="string">&quot;conv&quot;</span>, nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, <span class="number">4</span>))</span></span><br><span class="line"><span class="function"> #self.conv =</span> nn.<span class="built_in">Conv2d</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">4</span>) 和上面这个增加 <span class="keyword">module</span> 的方式等价</span><br><span class="line">model = <span class="built_in">Model</span>()</span><br></pre></td></tr></table></figure></p>
<h6 id="children">2.6.3 children()</h6>
<p>该函数返回当前模型子模块的迭代器。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.<span class="function">nn as nn</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"><span class="function"> def __init__(self):</span></span><br><span class="line"><span class="function"> super(Model, self).__init__()</span></span><br><span class="line"><span class="function"> self.add_module(<span class="string">&quot;conv&quot;</span>, nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, <span class="number">4</span>))</span></span><br><span class="line"><span class="function"> self.add_module(<span class="string">&quot;conv1&quot;</span>, nn.Conv2d(<span class="number">20</span> ,<span class="number">10</span>, <span class="number">4</span>))</span></span><br><span class="line"><span class="function">model =</span> <span class="built_in">Model</span>()</span><br><span class="line"><span class="keyword">for</span> sub_module in model.<span class="built_in">children</span>():</span><br><span class="line"> <span class="built_in">print</span>(sub_module)</span><br><span class="line"> </span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">Conv2d</span>(<span class="number">10</span>, <span class="number">20</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">Conv2d</span>(<span class="number">20</span>, <span class="number">10</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<h6 id="cpudevice_idnone和cudadevice_idnone">2.6.4 cpu(device_id=None)和cuda(device_id=None)</h6>
<p><code>cpu(device_id=None)</code>和cuda<code>(device_id=None)</code>将所有的模型参数(parameters)和 buffers 赋值给CPU或者GPU <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">modle=modle.<span class="built_in">cuda</span>()</span><br><span class="line"><span class="keyword">for</span> i, (images, gts, depths) in <span class="built_in">enumerate</span>(train_loader, start=<span class="number">1</span>):</span><br><span class="line">	optimizer.<span class="built_in">zero_grad</span>()</span><br><span class="line">	images = images.<span class="built_in">cuda</span>()</span><br><span class="line">	gts = gts.<span class="built_in">cuda</span>()</span><br><span class="line">	depths=depths.<span class="built_in">cuda</span>()</span><br></pre></td></tr></table></figure> 上面的式子等价于<code>to()</code>函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">device = torch.<span class="built_in">device</span>(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">images, gts, depths, = images.<span class="built_in">to</span>(device), gts.<span class="built_in">to</span>(device), depths.<span class="built_in">to</span>(device)</span><br></pre></td></tr></table></figure></p>
<h6 id="eval和train模式">2.6.5 eval()和train模式</h6>
<p><code>eval()</code>将模型设置成 evaluation 模式仅仅当模型中有 Dropout 和 BatchNorm 是才会有影响；<code>train()</code>将模型设置为训练模式，会有优化操作，即梯度下降和反向传播算法。</p>
<h6 id="state_dict-dict">2.6.6 state_dict (dict)</h6>
<p><code>state_dict</code>是一个简单的python的字典对象,将每一层与它的对应参数建立映射关系.(如model的每一层的weights及偏置等等)。注意只有那些参数可以训练的layer才会被保存到模型的state_dict中,如卷积层,线性层等等</p>
<ul>
<li><p><code>state_dict</code>是在定义了<code>model</code>或<code>optimizer</code>之后pytorch自动生成的,可以直接调用.常用的保存<code>state_dict</code>的格式是&quot;.pt&quot;或'.pth'的文件,即下面命令的 PATH=&quot;./***.pt&quot; <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.<span class="built_in">save</span>(model.<span class="built_in">state_dict</span>(), PATH)</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>load_state_dict</code>也是<code>model</code>或<code>optimizer</code>之后pytorch自动具备的函数,可以直接调用 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">model = <span class="built_in">TheModelClass</span>(*args, **kwargs)</span><br><span class="line">model.<span class="built_in">load_state_dict</span>(torch.<span class="built_in">load</span>(PATH))</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="modules">2.6.7 modules()</h6>
<p>返回一个包含 当前模型 所有模块的迭代器。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">module</span> in model.<span class="built_in">modules</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="keyword">module</span>)</span><br><span class="line"> </span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">Model</span> (</span><br><span class="line">	(conv): <span class="built_in">Conv2d</span>(<span class="number">10</span>, <span class="number">20</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">	(conv1): <span class="built_in">Conv2d</span>(<span class="number">20</span>, <span class="number">10</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">)</span><br><span class="line"><span class="built_in">Conv2d</span>(<span class="number">10</span>, <span class="number">20</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">Conv2d</span>(<span class="number">20</span>, <span class="number">10</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure> 可以看出，<code>modules()</code>返回的 iterator 不止包含子模块，还有父模块。这是和 <code>children()</code>的不同。</p>
<h6 id="named_children">2.6.8 named_children()</h6>
<p>返回包含模型当前子模块的迭代器，yield 模块<strong>名字和模块本身</strong>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, <span class="keyword">module</span> in model.<span class="built_in">named_children</span>():</span><br><span class="line">	<span class="keyword">if</span> name in [<span class="string">&#x27;conv4&#x27;</span>, <span class="string">&#x27;conv5&#x27;</span>]:</span><br><span class="line">	<span class="built_in">print</span>(<span class="keyword">module</span>)</span><br></pre></td></tr></table></figure> 同理有<code>name_modules</code></p>
<h5 id="激活函数">2.7 激活函数</h5>
<h6 id="relu">2.7.1 ReLU</h6>
<p>对输入运用修正线性单元函数<span class="math inline">\({ReLU}(x)= max(0, x)\)</span>， <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.<span class="built_in">ReLU</span>(inplace=False)</span><br></pre></td></tr></table></figure></p>
<h6 id="sigmoid">2.7.2 Sigmoid</h6>
<p>对每个元素运用 Sigmoid 函数，Sigmoid 定义如下：<span class="math inline">\(f(x)=1/(1+e^{−x})\)</span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.Sigmoid</span><br></pre></td></tr></table></figure></p>
<h6 id="softmax">2.7.3 Softmax</h6>
<p>对 n 维输入张量运用 Softmax 函数，将张量的每个元素缩放到（0,1）区间且和为 1。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">torch.nn.Softmax</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH</title>
    <url>/2023/03/12/ssh/</url>
    <content><![CDATA[<p>SSH（Secure Shell，安全外壳）是一种网络安全协议，通过加密和认证机制实现安全的访问和文件传输等业务。传统远程登录或文件传输方式，例如Telnet、FTP，使用明文传输数据，存在很多的安全隐患。随着人们对网络安全的重视，这些方式已经慢慢不被接受。SSH协议通过对网络数据进行加密和验证，在不安全的网络环境中提供了安全的登录和其他安全网络服务。作为Telnet和其他不安全远程shell协议的安全替代方案，目前SSH协议已经被全世界广泛使用，大多数设备都支持SSH功能。</p>
<span id="more"></span>
<h3 id="ssh是工作流程">SSH是工作流程</h3>
<p>SSH由服务器和客户端组成，在整个通信过程中，为建立安全的SSH通道，会经历如下几个阶段：</p>
<ul>
<li><p><strong>连接建立</strong> SSH服务器在指定的端口(默认22)侦听客户端的连接请求，在客户端向服务器发起连接请求后，双方建立一个TCP连接。</p></li>
<li><p>版本协商 SSH协议目前存在SSH1.X（SSH2.0之前的版本）和SSH2.0版本。SSH2.0协议相比SSH1.X协议来说，在结构上做了扩展，可以支持更多的认证方法和密钥交换方法，同时提高了服务能力。SSH服务器和客户端通过协商确定最终使用的SSH版本号。</p></li>
<li><p>算法协商 SSH支持多种加密算法，双方根据各自支持的算法，协商出最终用于产生会话密钥的密钥交换算法、用于数据信息加密的加密算法、用于进行数字签名和认证的公钥算法以及用于数据完整性保护的HMAC算法。</p></li>
<li><p>密钥交换 服务器和客户端通过密钥交换算法，动态生成共享的会话密钥和会话ID，建立加密通道。会话密钥主要用于后续数据传输的加密，会话ID用于在认证过程中标识该SSH连接。</p></li>
<li><p>用户认证 SSH客户端向服务器端发起认证请求，服务器端对客户端进行认证。SSH支持以下几种认证方式：</p>
<ul>
<li><p>密码（password）认证：客户端通过用户名和密码的方式进行认证，将加密后的用户名和密码发送给服务器，服务器解密后与本地保存的用户名和密码进行对比，并向客户端返回认证成功或失败的消息。</p></li>
<li><p>密钥（publickey）认证：客户端通过用户名，公钥以及公钥算法等信息来与服务器进行认证。</p></li>
<li><p>password-publickey认证：指用户需要同时满足密码认证和密钥认证才能登录。</p></li>
<li><p>all认证：只要满足密码认证和密钥认证其中一种即可。</p></li>
</ul></li>
<li><p>会话请求 认证通过后，SSH客户端向服务器端发送会话请求，请求服务器提供某种类型的服务，即请求与服务器建立相应的会话。</p></li>
<li><p>会话交互 会话建立后，SSH服务器端和客户端在该会话上进行数据信息的交互。</p></li>
</ul>
<h3 id="ssh密钥">SSH密钥</h3>
<p>提高安全性的基本方式就是加密，加密算法通过密钥将明文转换为密文进行安全传输。SSH在工作过程中结合使用了对称加密和非对称加密两种类型的算法，通过事先生成的SSH密钥来保证信息传输的安全性。</p>
<h4 id="对称加密和非对称加密">对称加密和非对称加密</h4>
<ul>
<li><p><strong>对称加密算法使用同一个密钥对数据进行加密和解密</strong>。SSH连接建立过程中生成的会话密钥就是对称密钥，该对称密钥是由客户端和服务器端基于共享的部分信息和各自的私有数据使用密钥交换算法分别生成的。因为对称加密算法加解密的速度很快，所以适用于传输大量数据的场景。 <img src="/2023/03/12/ssh/ssh_secret.png" width="600"></p></li>
<li><p><strong>非对称加密的发送和接收需要使用一对关联的SSH密钥，公钥和私钥</strong>。<strong>私钥由生成的一方自己保管，公钥可以发送给任何请求通信的其他人</strong>。发送方用收到的公钥对自己的通信内容进行加密，只有接收方可以使用私钥进行解密获取通信内容。非对称加密的私钥不需要暴露在网络中，安全性大大增加，但是加解密的速度比对称密钥慢得多。 <img src="/2023/03/12/ssh/ssh_not.png" width="600"></p></li>
</ul>
<p><strong>SSH连接过程中的两个阶段使用了非对称加密</strong>:</p>
<ul>
<li>一个是在密钥交换阶段，服务器和客户端都生成了自己临时的公钥和私钥，用于计算出同一个用于后续加密通信内容的会话密钥。</li>
<li>另外一个就是在用户认证阶段，利用只有匹配的私钥可以唯一解密公钥加密的内容这一特点，通过客户端的公钥私钥对验证客户端的身份</li>
</ul>
<h4 id="密钥认证">密钥认证</h4>
<p><strong>SSH用户认证最基本的两种方式是密码认证和密钥认证。</strong></p>
<ul>
<li>密码认证是将自己的用户名和密码发送给服务器进行认证，这种方式比较简单，且每次登录都需要输入用户名和密码。</li>
<li>密钥认证使用公钥私钥对进行身份验证，实现安全的免密登录，是一种广泛使用且推荐的登录方式。密钥认证的基本原理是服务器端使用客户端的公钥对随机内容加密，客户端使用自己的私钥解密并发送给服务器以证实自己的身份，具体的过程见下图。 <img src="/2023/03/12/ssh/ssh_renzhen.png" width="600"></li>
</ul>
<p><strong>SSH密钥认证登录流程</strong></p>
<ul>
<li><p>在进行SSH连接之前，SSH客户端需要先生成自己的公钥私钥对，并将自己的公钥存放在SSH服务器上。</p></li>
<li><p>SSH客户端发送登录请求，SSH服务器就会根据请求中的用户名等信息在本地搜索客户端的公钥，并用这个公钥加密一个随机数发送给客户端。</p></li>
<li><p>客户端使用自己的私钥对返回信息进行解密，并发送给服务器。</p></li>
<li><p>服务器验证客户端解密的信息是否正确，如果正确则认证通过。</p></li>
</ul>
<h3 id="ssh密钥认证操作">ssh密钥认证操作</h3>
<p>基于密钥的认证主要优点在于，与密码认证相比，它不易遭受暴力破解攻击，且在服务器被攻破的情况下也不会泄露您的有效凭证。不仅如此，与传统的密码认证相比，SSH 密钥认证也可以更加便利。当与被称作 SSH agent 的程序共用时，SSH 密钥可以让您无需记住或输入每个系统的密码，就能够连接到一个或多个服务器。要是有<code>ssh</code>，得安装<code>openssh</code>软件包</p>
<h4 id="背景">背景</h4>
<p>SSH 密钥都是成对生成的，其一称为公钥，另一则称为私钥。私钥只由您所知，必须安全保管。相对地，公钥可以向您想连接的任何 SSH 服务器自由地共享。</p>
<p>如果一个 SSH 服务器在文件中存有您的公钥，并收到了您的连接请求，就会使用您的公钥构建一个质询问题并发送给您。这一质询问题是一条加密信息，必须得到正确应答，服务器才能允许您访问。这条编码信息特别安全是在于，只有私钥持有者才能理解它。公钥可以用来加密信息，但不能用来解密同一条信息。只有您，私钥的持有者，能够正确理解这一质询问题并产生合适的应答。</p>
<p><strong>这一质询-应答过程发生在后台，对用户不可见。只要您持有私钥（一般存放在 <code>~/ .ssh</code> 目录下），您的 SSH 客户端就应当能够向服务器回复正确的应答。</strong></p>
<h4 id="生成密钥对">生成密钥对</h4>
<p>通过运行<code>ssh-keygen</code> 命令可以生成密钥对，默认为3072位的<code>RSA</code>（以及 <code>SHA256</code>），<code>ssh-keygen</code>(1) 手册页称其“一般被认为充足”且应当兼容于几乎所有客户端和服务器：</p>
<ul>
<li>可以使用<code>-a</code> 开关来指定密码加密的 KDF rounds 数量。</li>
<li>也可以用 <code>-C</code> 开关对公钥添加可选的注释栏，从而在 <code>~/.ssh/known_hosts</code>、<code>~/.ssh/authorized_keys</code> 以及 <code>ssh-add -L</code> 输出等处更轻松地辨识它。例如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -C <span class="string">&quot;$(whoami)@$(uname -n)-$(date -I)&quot;</span></span><br></pre></td></tr></table></figure> 会添加一条注释，说明是哪个用户何时在哪台机器上创建的密钥。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ ssh-keygen -t rsa -C <span class="string">&quot;1229413537@qq.com&quot;</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa key pair.</span><br><span class="line"><span class="function">Enter file in which to save the <span class="title">key</span> <span class="params">(/home/trluper/.ssh/id_rsa)</span>: </span></span><br><span class="line"><span class="function">Created directory <span class="string">&#x27;/home/trluper/.ssh&#x27;</span>.</span></span><br><span class="line"><span class="function">Enter passphrase (empty for no passphrase): </span></span><br><span class="line"><span class="function">Enter same passphrase again: </span></span><br><span class="line"><span class="function">Your identification has been saved in /home/trluper/.ssh/id_rsa</span></span><br><span class="line"><span class="function">Your public key has been saved in /home/trluper/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="function">The key fingerprint is:</span></span><br><span class="line"><span class="function">SHA256:<span class="number">1</span>Cj60kKeZzc8eMn1G09kN65qxVQ4FhyiKwumBElPf6I <span class="number">1229413537</span>@qq.com</span></span><br><span class="line"><span class="function">The key<span class="string">&#x27;s randomart image is:</span></span></span><br><span class="line"><span class="string"><span class="function">+---[RSA 3072]----+</span></span></span><br><span class="line"><span class="string"><span class="function">| . .       ..o+  |</span></span></span><br><span class="line"><span class="string"><span class="function">|. + .    o. .= . |</span></span></span><br><span class="line"><span class="string"><span class="function">| o . o..o.. . o  |</span></span></span><br><span class="line"><span class="string"><span class="function">|  . ..oo  .  .   |</span></span></span><br><span class="line"><span class="string"><span class="function">|   Eoo .S.. o o..|</span></span></span><br><span class="line"><span class="string"><span class="function">|  .oo+.+oo . =...|</span></span></span><br><span class="line"><span class="string"><span class="function">|   .= *.O   + .. |</span></span></span><br><span class="line"><span class="string"><span class="function">|     = o o . =.  |</span></span></span><br><span class="line"><span class="string"><span class="function">|          ..o..  |</span></span></span><br><span class="line"><span class="string"><span class="function">+----[SHA256]-----+</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>OpenSSH（对于认证密钥）支持数种签名算法，按照所采用的数学性质可分为两类：</strong></p>
</blockquote>
<blockquote>
<ul>
<li>DSA 以及 RSA，依赖于对两个大质数之积进行分解的实际困难；</li>
<li>ECDSA 以及 Ed25519，依赖于椭圆曲线离散对数问题。（例）</li>
</ul>
</blockquote>
<h4 id="选择密钥存储位置以及密码短语">选择密钥存储位置以及密码短语</h4>
<p>运行 ssh-keygen 时，它会询问您希望的私钥文件名称及位置。默认情况下，密钥保存到 <code>~/.ssh</code> 目录下，并根据所使用的加密类型命名。为使下文中的示例代码正确工作，建议您接受默认的名称和位置。</p>
<p>当系统向您询问密码短语时，如果您在乎私钥的安全性，请选择难以猜到的密码。更长、更随机的密码一般会更强，当私钥落入贼人之手时更不容易被破解掉。</p>
<p>在没有密码短语的情况下生成私钥也是可能的。虽然也许很方便，但您需要明白随之而来的风险。在没有密码短语的情况下，您的私钥会以未加密形式存储在硬盘上。任何能接触到您私钥文件的人之后都能够在您使用基于密钥认证连接的任何 SSH 服务器面前冒用您的身份。更进一步，没有密码短语，您也必须信任 root 用户，因为他可以绕过文件权限并能够随时访问您未加密的私钥文件。</p>
<blockquote>
<p><strong>注意：</strong> 从前，私钥密码都是以一种不安全的方式编码的：仅一遍 MD5 散列。OpenSSH 6.5及之后版本支持一种新的、更安全的格式来编码您的私钥。从 OpenSSH 版本7.8开始默认使用该格式。Ed25519 密钥一直采用新的编码格式。只需按下节所述更改密钥的密码短语即可升级到新格式。</p>
</blockquote>
<h4 id="不修改密钥对的情况下修改密码短语">不修改密钥对的情况下修改密码短语</h4>
<p>如果不希望使用原本选择的 SSH 密钥密码短语或者必须更换，可以使用 ssh-keygen 命令来修改密码短语，而无需改动实际密钥。此法也可用于将密码编码格式改为新标准。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -f ~/.ssh/id_rsa -p</span><br></pre></td></tr></table></figure></p>
<h4 id="管理多组密钥对">管理多组密钥对</h4>
<p>对多台主机使用同一 SSH 密钥对是可能的，尽管受到争议</p>
<p>另一方面，使用您 <code>OpenSSH</code> 配置文件中的 <code>IdentityFile</code> 指令，为多台主机管理不同的密钥对就比较容易了 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/.ssh/config</span><br><span class="line">Host SERVER1</span><br><span class="line">   IdentitiesOnly yes</span><br><span class="line">   IdentityFile ~/.ssh/id_rsa_SERVER1</span><br><span class="line"></span><br><span class="line">Host SERVER2</span><br><span class="line">   IdentitiesOnly yes</span><br><span class="line">   IdentityFile ~/.ssh/id_ed25519_SERVER2</span><br></pre></td></tr></table></figure></p>
<h4 id="将公钥复制到远程服务器上">将公钥复制到远程服务器上</h4>
<p>创建好密钥对之后，您需要将公钥上传到远程服务器上，以便用于 SSH 密钥认证登录。公钥文件名和私钥文件名相同，只不过公钥文件带有扩展名 .pub 而私钥文件名则没有。千万不要将私钥上传，私钥应该保存在本地。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ cat ~/ .ssh/id_rsa.pub</span><br></pre></td></tr></table></figure> 如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ cat /home/trluper/.ssh/id_rsa.pub </span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCwAs3b8z/btHZJ5MeySPVGwKk87JIlNn5Ch6ve8upJwT9AXe/wKdT1Neb7yEWlNlha4VktZdxetlGTq/XVmyb7v5JEnfB7j4byf0/SW4gMCOQeHEwj56+sYe6AxQDGD60FitSaGfcQzhaM89e39o2u1V1hbPO7MsDyTF1pN3V6VS5TStgmWkUSYtVIsbro0u5VjKkRqIYkt8Pyy6CzXky7DBAx8j5lTZN42Ll/hk17huxuP7lGexwumsqR4PPNlhh5QVXAeapDTgzvNL9wDG4MzTjBiyjqzPkijojJqp7dbZIejxvlFzl7ZxiYxRs/V/zt2RfW5iu2OBfUPnXwgGJR1MNCUp0mE45hSmnlkioN81Lo/UQYEBE9oHtS3HGEy8HyNIHL6KDQei2zxwn38GadUvxLbiC0SkNNk8PW+Bi8WK6b941YhaXyTW8tGgzctXcZYKi0TXJA2HuvbTSR+zdj3NT7SxwNwJPuqDPwsrDYjV8PESGDqeMNj2W4kD3kes8= <span class="number">1229413537</span>@qq.com</span><br></pre></td></tr></table></figure> 输出后将公钥复制到你的github服务器上，至于其他的服务器，请参考文章来源操作</p>
<blockquote>
<p><strong>参考来源：</strong> <a href="https://wiki.archlinuxcn.org/wiki/SSH_%E5%AF%86%E9%92%A5">SSH 密钥</a></p>
</blockquote>
]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu使用手册</title>
    <url>/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h4 id="ubuntu常用快捷键">1. Ubuntu常用快捷键</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、打开终端：Ctr+Alt+T</span><br><span class="line"><span class="number">2</span>、关闭终端：Ctrl + Shift + Q</span><br><span class="line"><span class="number">3</span>、复制：Ctrl + Shift + C</span><br><span class="line"><span class="number">4</span>、粘贴：Ctrl + Shift + V</span><br><span class="line"><span class="number">5</span>、跳转回主机操作:ctr+alt</span><br><span class="line"><span class="number">6</span>、跳回虚拟机：Ctr+G</span><br><span class="line"><span class="number">7</span>、新建终端窗口：Ctrl + Shift + N</span><br><span class="line"><span class="number">8</span>、运行命令：Alt + F2</span><br><span class="line"><span class="number">9</span>、全屏切换：F11</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="apt安装">2. apt安装</h4>
<p>对于Ubuntu安装各种软件包的命令格式使用<code>apt-get</code>或者<code>apt</code>。（centOS使用<code>yum</code>），这是在线安装。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在线安装</span></span><br><span class="line">sudo apt-get update		<span class="comment">//更新软件包列表</span></span><br><span class="line">sudo apt-get install	<span class="comment">//安装软件</span></span><br><span class="line">sudo apt-get remove		<span class="comment">//删除软件</span></span><br><span class="line">sudo apt-get clean		<span class="comment">//清理安装包</span></span><br></pre></td></tr></table></figure> <strong><em>附：</em></strong>如果是从Ubuntu官网已经下载好了安装包，相应离线安装的话，因为从Ubuntu的文件为deb格式，所以</p>
<ul>
<li>软件安装<code>sudo dpkg -i xxx.deb</code></li>
<li>软件卸载<code>sudo dpkg -r 软件名</code></li>
</ul>
<blockquote>
<p>推荐安装的包： gcc、g++、vim、aptitude</p>
</blockquote>
<h5 id="安装net-tools网络工具">2.1 安装net-tools网络工具</h5>
<p><code>net-tools</code>工具箱包括<code>arp, hostname, ifconfig, netstat, rarp, route, plipconfig, slattach, mii-tool and iptunnel and ipmaddr</code>等命令。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure></p>
<h5 id="安装ssh">2.2 安装ssh</h5>
<p><code>ssh</code>用于远程登录到<code>Linux</code>服务器来管理维护系统。<code>SSH</code>是专为远程登录会话和其他网络服务提供安全性的协议；使用<code>ssh</code>服务（指实现<code>SSH</code>协议的软件）可远程登录到服务器来管理维护系统，防止远程管理过程中的信息泄露问题。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装</span></span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"><span class="comment">//查看状态</span></span><br><span class="line">service ssh status</span><br><span class="line"><span class="comment">//查看端口</span></span><br><span class="line">netstat -anp |grep <span class="number">22</span> netstat -anp |grep sshlsof -i :<span class="number">22</span></span><br></pre></td></tr></table></figure></p>
<h5 id="aptitude">2.3 aptitude</h5>
<p><code>aptitude</code> 命令与 <code>apt-get</code> 命令一样，都是Debian Linux 及其衍生系统中功能极其强大的包管理工具。与<code>apt-get</code>不同的是，<code>aptitude</code>在处理依赖问题上更佳一些。举例来说，<code>aptitude</code> 在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。它通过文本操作菜单和命令两种方式管理软件包。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装</span></span><br><span class="line">sudo apt-get install aptitude</span><br><span class="line"><span class="comment">//命令</span></span><br><span class="line">aptitude upgrade		<span class="comment">//升级系统所有的软件包</span></span><br><span class="line">aptitude dist-upgrade	<span class="comment">//将系统升级到新的发行版</span></span><br><span class="line">aptitude safe-upgrade	<span class="comment">//安全升级系统的软件包</span></span><br><span class="line">aptitude install net-tools	<span class="comment">//安装软件包</span></span><br><span class="line">ptitude purge net-tools	<span class="comment">//彻底删除软件包</span></span><br><span class="line">aptitude search ssh	<span class="comment">//根据关键词搜索软件包</span></span><br><span class="line">aptitude show ssh	<span class="comment">//查看软件包的详细信息</span></span><br><span class="line">aptitude clean		<span class="comment">//删除缓存目录中的软件包安装文件</span></span><br></pre></td></tr></table></figure></p>
<h5 id="安装gccg">2.3 安装gcc/g++</h5>
<p><code>GCC</code>原名为 <code>GNU C</code> 语言编译器，因为它原本只能处理 C语言。GCC 快速演进，变得可处理 <code>C++、Fortran、Pascal、Objective-C、Java</code> 以及 <code>Ada</code> 等他语言。实际使用中：</p>
<ul>
<li>使用 <code>gcc</code> 指令编译 C 代码</li>
<li>使用 <code>g++</code>指令编译 C++ 代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo  apt-get insatll gcc</span><br><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure>
<h5 id="安装vim">2.4 安装vim</h5>
<p><code>vim</code>是从<code>VI</code>发展而来的一个文本编辑器，功能更强大。而<code>vim.tiny</code>是vim的精简版，所以，安装<code>vim</code>势在必行。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure></p>
<h5 id="安装cmake">2.5 安装Cmake</h5>
<p><code>Camke</code>是一个高级编译工具，当你用不同的语言或者编译器开发一个项目，各就各位code完之后要生成最终的输出（<code>dll</code>或执行文件），这时候就尴尬了，你要手动去MingGW或者GCC下配置成千上万的<code>.cpp .h .o .c</code>路劲和地址吗？这时候神器就出现了<code>CMake</code>，主要功能：</p>
<ul>
<li>配置和生成各大平台的工程（vs的vcxproj，Qt的Pro）</li>
<li>生成makefile文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure>
<h5 id="第三方线程库">2.6 第三方线程库</h5>
<p><code>pthread</code>是第三方线程库，安装如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt-get install glibc-doc</span><br><span class="line"> sudo apt-get install manpages-posix manpages-posix-dev</span><br></pre></td></tr></table></figure></p>
<h5 id="mysql安装">2.7 MySQL安装</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt install mysql-server;</span><br></pre></td></tr></table></figure>
<h4 id="虚拟机网络问题">3. 虚拟机网络问题</h4>
<p>有时候我们的虚拟机会出现无法连接上网的情况，解决方法如下：</p>
<ul>
<li>检查宿主主机，能正常联网</li>
<li><p>linux的ifconfig显示，没有固定IP <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        inet6 ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0x10</span>&lt;host&gt;</span><br><span class="line">        loop  txqueuelen <span class="number">1000</span>  (Local Loopback)</span><br><span class="line">        RX packets <span class="number">2588</span>  bytes <span class="number">197004</span> (<span class="number">197.0</span> KB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">2588</span>  bytes <span class="number">197004</span> (<span class="number">197.0</span> KB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>将网络管理的缓存清除后重新开启即可 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo service network-manager stop</span><br><span class="line">sudo rm /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">sudo service network-manager start</span><br><span class="line">或</span><br><span class="line">sudo service NetworkManager stop</span><br><span class="line">sudo rm /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">sudo service NetworkManager start</span><br><span class="line">sudo vim /etc/NetworkManager/NetworkManager.conf #在这个文件中把第四行的<span class="literal">false</span>改成<span class="literal">true</span></span><br><span class="line">sudo service NetworkManager restart</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="wsl的ubuntu安装">4.WSL的ubuntu安装</h4>
<p>Windows可集成双系统，这里我们推荐使用一下方式来安装Linux系统：</p>
<ul>
<li>在官网下载压缩包后，更改后缀名为<code>zip</code>，之后解压即可</li>
<li>解压后，执行<code>ubuntuxxxx.exe</code>，弹出终端后，设置你的用户名和密码即安装完成</li>
<li>安装后<code>rootfs</code>即为你ubuntu的工作区间</li>
</ul>
<blockquote>
<p>之所以推荐上述安装方式，是因为使用驱动安装是之间安装载C盘的，虽然可以转移但过程繁琐，之间使用压缩包方式更为简洁。</p>
</blockquote>
<h4 id="wsl下的ubuntu的ssh服务器">5. wsl下的ubuntu的ssh服务器</h4>
<p><strong>如果你想用ssh连接远程window上的wsl，你是无法直接连接Linux的ssh的，必须通过走windows端口映射才行：</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove openssh-server <span class="comment">#自带的有问题卸载</span></span><br><span class="line">sudo apt-get install openssh-server <span class="comment">#重新安装</span></span><br><span class="line">sudo vim /etc/ssh/sshd_config <span class="comment">#修改配置文件</span></span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 去掉前面的“#”</span></span><br><span class="line">Port <span class="number">2222</span> <span class="comment"># 端口号 默认22，因为与Window系统自带SSH冲突故改为2222</span></span><br><span class="line">AddressFamily <span class="built_in">any</span></span><br><span class="line">ListenAddress <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">ListenAddress ::</span><br><span class="line">PasswordAuthentication yes <span class="comment"># 是否允许使用密码登录 选“是”</span></span><br><span class="line"><span class="comment"># 其它配置没必要改变</span></span><br></pre></td></tr></table></figure> 生成成功后，我们在重启sshd，这样就可以了。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sudo service ssh --full-restart <span class="comment">#重启SSH服务</span></span><br></pre></td></tr></table></figure> <strong>端口映射：</strong>然后WLS2有一个问题，就是它相当于一个完整的虚拟机，所以IP地址与本机不一样，这就导致我们无法在别的设备上SSH连接</p>
<p>解决办法就是把WSL2虚拟机的IP映射到本机上(假设本机windows的ip为192.168.1.3) <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy <span class="built_in">set</span> v4tov4 listenport=<span class="number">12233</span> listenaddress=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> connectport=<span class="number">2222</span> connectaddress=<span class="number">172.18</span><span class="number">.69</span><span class="number">.154</span></span><br><span class="line"><span class="comment"># listenport win10监听的端口号</span></span><br><span class="line"><span class="comment"># listenaddress win10监听的外网地址，0.0.0.0指所有地址</span></span><br><span class="line"><span class="comment"># connectport 映射的linux的端口 也就是ssh的开启端口</span></span><br><span class="line"><span class="comment"># connectaddress linux的ip</span></span><br><span class="line"><span class="comment"># 可以理解为，所有发往win11:192.168.1.3的12233端口的tcp信息都会转发到172.18.69.154:2222</span></span><br></pre></td></tr></table></figure></p>
<p>测试：你可以在window上运行下面代码验证是否映射成功 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh 用户名@本机IP -p 映射端口 <span class="comment"># 例如 ssh root@192.168.1.3 -p 12233 </span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用内透软件natapp">6. 使用内透软件natapp</h4>
<p>内网内透通过将我们的本机的ubuntu服务器与natapp的服务器连接，以支持另一台主机通过不同网段也能够通过走natapp的服务器连接该ubuntu服务器。即内网穿透。</p>
<p>在natapp中指定服务器地址即可，详细操作见<a href="https://natapp.cn/tunnel/edit/16vldzyrj8">natapp官网</a> <img src="/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/natapp.png" width="700"> <strong><em>注：上面的ip地址和端口号中，如果你是连接wsl的那么就是window的ip地址和相应的端口映射号</em></strong></p>
<h4 id="wsl出现cannot-execute-binary-file-exec-format-error">7. WSL出现<code>cannot execute binary file: Exec format error</code></h4>
<p>出现上述无法执行二进制文件的错误，这是因为该程序的编译链中的GCC是32位版本，而wsl本身是不支持的，WSL64位（微软吊毛没有做向下兼容）。</p>
<p>解决方法：可以使用<code>QEMU</code>来虚拟化内核来解决这个问题</p>
<ul>
<li><p>安装QEMU <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install qemu-user-<span class="type">static</span></span><br><span class="line">sudo update-binfmts --install i386 /usr/bin/qemu-i386-<span class="type">static</span> --magic <span class="string">&#x27;\x7fELF\x01\x01\x01\x03\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x03\x00\x01\x00\x00\x00&#x27;</span> --mask <span class="string">&#x27;\xff\xff\xff\xff\xff\xff\xff\xfc\xff\xff\xff\xff\xff\xff\xff\xff\xf8\xff\xff\xff\xff\xff\xff\xff&#x27;</span></span><br></pre></td></tr></table></figure> 这些命令将通过执行<code>qemu-i386-static</code>来激活i386支持，并将配置文件放入<code>/var/lib/binfmts/</code>中，以供将来重新激活。</p></li>
<li><p>每次重新启动WSL并需要i386支持时，都需要重新激活此功能 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo service binfmt-support start</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>问题解决</p>
<h4 id="wsl下出现mstsc.exe在后台运行">8 WSL下出现mstsc.exe在后台运行</h4>
<p>最近发现窗口总是无缘无故失去焦点，导致好好敲着代码，突然无法输入了</p>
<p>找了一个窗口检点检测工具，根据<code>pid</code>定位到<code>是 mstsc.exe</code>这个进程在搞鬼，每次失去焦点时都是被切换到这个进程上了，而且这个进程在频繁重启</p>
<p><strong>原因是我安装了WSL2，WSL2其中运行着 <code>WSLg XServer</code>、<code>Wayland</code> 服务器和 <code>Pulse Audio</code> 服务器。每个服务器的通信套接字都被投射到用户发行版中，以便客户端应用程序可以连接到它们。</strong><a href="https://github.com/microsoft/wslg#wslgd">来源microsoft/wslg</a></p>
<p><strong>解决办法</strong></p>
<ul>
<li><code>.wslconfig</code>：用户还可以通过在其文件（位于）中添加以下条目来选择完全关闭系统发行版<code>c:\users\MyUser\.wslconfig</code>。这将关闭 WSL 中对 GUI 应用程序的支持。(如果你没有这个文件，那么在这个目录下创建它，然后填下述内容即可) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">guiApplications=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>unity2d</title>
    <url>/2023/03/26/unity2d/</url>
    <content><![CDATA[<h3 id="section">1</h3>
<span id="more"></span>
<h3 id="附录">附录</h3>
<p><strong>unity学习资源：</strong> 官方： <a href="https://learn.unity.com/projects">unity项目学习</a> <a href="https://learn.u3d.cn/tutorial/beginner-gameplay-scripting?chapterId=63562b29edca72001f21d179#603ef869673f740022b02cc9">c#教程</a> <a href>assetstore商店</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity初识</title>
    <url>/2023/03/23/unity%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h3 id="section">1</h3>
<span id="more"></span>
<h3 id="附录">附录</h3>
<p><strong>unity学习资源：</strong> 官方： <a href="https://learn.unity.com/projects">unity项目学习</a> <a href="https://learn.u3d.cn/tutorial/beginner-gameplay-scripting?chapterId=63562b29edca72001f21d179#603ef869673f740022b02cc9">c#教程</a> <a href>assetstore商店</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>vim</title>
    <url>/2022/12/16/vim/</url>
    <content><![CDATA[<h5 id="vim的三种模式">6.1 vim的三种模式</h5>
<p>vi有三种基本工作模式: <strong>命令模式、文本输入模式(编辑模式)、末行模式</strong></p>
<ul>
<li><strong>命令模式：</strong> <strong>任何时候,不管用户处于何种模式,只要按一下<code>ESC</code>键,即可使<code>vi</code>进入命令模式</strong>。我们在<code>shell</code>环境(提示符为<code>$</code>)下输入启动<code>vim</code>命令，进入编辑器时，也是处于该模式下。在命令模式下，用户可以输入各种合法的<code>vi</code>命令，用于管理自己的文档。<strong>此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的<code>vi</code>命令，则<code>vi</code>在接受用户命令之后完成相应的动作</strong>。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是<code>vi</code>的合法命令，<code>vi</code>会响铃报警。</li>
</ul>
<span id="more"></span>
<ul>
<li><p>文本输入模式： 在命令模式下输入插入命令<code>i（I）、附加命令a（A） 、打开命令o（O）、替换命s（S）</code>都可以进入文本输入模式，此时vi窗口的最后一行会显示“插入”,可进行文本编辑.</p></li>
<li><p>末行模式： 末行模式下，用户可以对文件进行一些附加处理。尽管命令模式下的命令可以完成很多功能，但要执行一些如字符串查找、替换、显示行号等操作还是必须要进入末行模式的。<strong>在命令模式下，输入冒号<code>:</code>即可进入末行模式。此时vi窗口的状态行会显示出冒号，等待用户输入命令。用户输入完成后，按回车执行，之后<code>vi</code>编辑器又自动返回到命令模式下</strong> <img src="/2022/12/16/vim/vi-vim.gif"></p></li>
</ul>
<h5 id="命令模式下的命令操作">6.2 命令模式下的命令操作</h5>
<h6 id="切换到编辑模式">6.2.1 切换到编辑模式</h6>
<p><img src="/2022/12/16/vim/vimbianji.png"></p>
<h6 id="光标移动">6.2.2 光标移动</h6>
<p><img src="/2022/12/16/vim/mousemove.png"></p>
<h6 id="删除">6.2.3 删除</h6>
<p><img src="/2022/12/16/vim/delete.png"> <strong>常用：<code>D</code>、<code>dG</code>、<code>nx</code>(n为数字)、<code>ndd</code></strong></p>
<h6 id="查找">6.2.4 查找</h6>
<p><img src="/2022/12/16/vim/find.png"></p>
<h6 id="可视模式">6.2.5 可视模式</h6>
<p><img src="/2022/12/16/vim/copydelete.png"></p>
<h6 id="粘贴和复制">6.2.6 粘贴和复制</h6>
<ul>
<li><code>p</code>:粘贴在光标后面</li>
<li><code>P</code>:粘贴在光标前面</li>
<li><code>y</code>:拷贝行</li>
<li><code>Y</code>:拷贝行</li>
</ul>
<h5 id="末行模式下的命令操作">6.3 末行模式下的命令操作</h5>
<h6 id="保存退出">6.3.1 保存退出</h6>
<p><img src="/2022/12/16/vim/saveexit.png"></p>
<h6 id="替换">6.3.2 替换</h6>
<p><img src="/2022/12/16/vim/tihuan.png"> 可以从上图总结：<code>s(</code>代表本行，<code>g</code>为所有(global)都替换，<code>%</code>指本文件所有行，<code>c</code>每次替换都要求确认</p>
<h6 id="分屏">6.3.3 分屏</h6>
<p><img src="/2022/12/16/vim/fenping.png"></p>
<h6 id="其他用法扩展">6.3.4 其他用法扩展</h6>
<p><img src="/2022/12/16/vim/others.png"></p>
<h5 id="vim的配置文件所在">6.4 vim的配置文件所在</h5>
<p>局部配置文件（推荐）：<code>~/.vimrc</code> 全局配置文件:<code>/etc/vim/vimrc</code></p>
]]></content>
      <categories>
        <category>vim</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字</title>
    <url>/2023/03/04/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="volatile">1 volatile</h3>
<p>C/C++ 中的 <code>volatile</code> 关键字和 <code>const</code> 对应，用来修饰变量，通常用于建立语言级别的 memory barrier。这是 BS 在 &quot;The C++ Programming Language&quot; 对 volatile 修饰词的说明：</p>
<blockquote>
<p>A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.</p>
</blockquote>
<ul>
<li><p><strong><code>volatile</code> 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。</p></li>
<li><p>应对场景：<strong>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化。这是因为<code>volatile</code>提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有<code>volatile</code>关键字，则编译器可能优化读取和存储，就极有可能暂时使用寄存器中的值，此时这个变量由别的线程更新了的话，将出现不一致的现象</strong></p></li>
<li><p>示例：<code>int volatile vInt</code>; 当要求使用<code>volatile</code>声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存</strong>。例如：</p></li>
</ul>
<span id="more"></span>
<h4 id="volatile的功能">1.1 volatile的功能</h4>
<ul>
<li><p>（1）volatile可理解为“编译器警告指示字”</p></li>
<li><p>（2）volatile告诉编译器必须每次去内存中取变量值</p></li>
<li><p>（3）volatile主要修饰可能被多个线程访问的变量</p></li>
<li><p>（4）volatile也可以修饰可能被未知因数更改的变量</p></li>
</ul>
<h4 id="const-volatile-int-i0">1.2 <code>const volatile int i=0;</code></h4>
<p><code>const volatile int i=0;</code>这是一个有趣的语句：</p>
<ul>
<li>首先<code>const</code>修改<code>i</code>，其被定义为一个常量，不能更改，只能初始化( “const”含义是“请做为常量使用”，而并非“放心吧，那肯定是个常量”。)</li>
<li><code>volatile</code>也修饰了<code>i</code>，告诉编译器变量极有可能被未知因素更改，每次访问读值都有去内存取值( “volatile”的含义是“请不要做没谱的优化，这个值可能变掉的”，而并非“你可以修改这个值”。)</li>
</ul>
<p>这两个使用并不矛盾，所以这里的i的属性是在本程序中，i应该是只读的，不应该被修改的，但是它也可能被外部的例如中断，共享的线程通过某种方式修改(<strong>如其他线程直接调用汇编去修改</strong>)，所以这里也不该被编译器优化，虽然它是只读的不该被修改的，但是它还是会改变，我们在本程序中使用的时候，还是要每次都去读它的值，这是一种“双重保险”。</p>
<p>因此，<code>const</code>和<code>volatile</code>放在一起的意义在于：</p>
<ul>
<li>（1）本程序段中不能对a作修改，任何修改都是非法的，或者至少是粗心，编译器应该报错，防止这种粗心；</li>
<li>（2）另一个程序段则完全有可能修改，因此编译器最好不要做太激进的优化。</li>
</ul>
<h4 id="volatile-指针">1.3 volatile 指针</h4>
<p>和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念：</p>
<ul>
<li>修饰由指针指向的对象、数据是 <code>const</code> 或 <code>volatile</code> 的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cpch;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">char</span>* vpch;</span><br></pre></td></tr></table></figure></li>
<li>指针自身的值——一个代表地址的整数变量，是 <code>const</code> 或 <code>volatile</code> 的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="type">const</span> pchc;</span><br><span class="line"><span class="type">char</span>* <span class="keyword">volatile</span> pchv;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="volatile不能保证线程安全">1.4 volatile不能保证线程安全</h4>
<ul>
<li>对于非原子操作，即使有<code>volatile</code>修饰，但也不能保证线程安全： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">volatile</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++)</span><br><span class="line">		++a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;thread&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec[i] = <span class="built_in">thread</span>(fun);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : vec)</span><br><span class="line">		it.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">267423</span></span><br></pre></td></tr></table></figure></li>
<li>对于原子操作，volatile能够保证线程安全 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>&gt; <span class="keyword">volatile</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure> 输出 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1000000</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>内存对齐问题</title>
    <url>/2023/04/11/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="内存对齐规则">内存对齐规则</h3>
<p>在C/C++中的结构体或类，存在内存对齐问题。内存对齐是为了方便计算机进行寻址，优化寻址速度的一个措施，其代价是消耗不必要的内存空间。</p>
<p>内存对齐遵循以下规则：</p>
<ul>
<li><strong>第一个成员在与结构体变量偏移量为0的地址处。</strong></li>
<li><strong>其他成员变量都放在对齐数（成员的大小和默认对齐数的较小值）的整数倍的偏移地址处。</strong>
<ul>
<li>对齐数=编译器默认的一个对齐数与该成员大小的较小值。（不同的编译器其默认对齐数不同，64位系统中VS默认的对齐数是8，在Linux中没有默认的对齐数）</li>
<li>可以在程序开端声明<code>#pragma pack(数字)</code>来设置默认对齐值</li>
</ul></li>
<li><strong>结构体总大小为最大对齐数(每个成员变量都有一个对齐数 )的整数倍。</strong></li>
<li><strong>如果嵌套了结构体的情况,嵌套的结构体对齐到自己的最大对齐数的整数倍处,结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍。---&gt;最大对齐数肯定不超过默认对齐数</strong></li>
</ul>
<p>示例：VS运行（默认对齐数为8） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">test2</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> a;<span class="comment">//4--&gt;8，占0，1，2，3地址处，后续补4，5，6，7</span></span><br><span class="line">     <span class="type">double</span> c;<span class="comment">//8，但由于其只能放在与首地址偏移量为8的地址上，因此4，5，6，7作为填补空缺，它从8存储</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">testMemory</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> a;<span class="comment">//4--&gt;8</span></span><br><span class="line">     <span class="type">long</span> b;<span class="comment">//8</span></span><br><span class="line">     <span class="type">char</span> c;<span class="comment">//1</span></span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">test2</span> l;<span class="comment">//16</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">cout  &lt;&lt;<span class="built_in">sizeof</span>(test2) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(testMemory) &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 输出: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span> <span class="number">40</span></span><br></pre></td></tr></table></figure> <img src="/2023/04/11/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/me.png" widt="400"></p>
<h4 id="class类">class类</h4>
<p>在C++中，class与struct是相同的，除了：</p>
<ul>
<li><p>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p></li>
<li><p>class默认是private继承， 而struct默认是public继承</p></li>
</ul>
<p>因此，对于struct的对齐规则同样是class的对齐规则，在c++中，<strong>还必须注意在存在虚函数时类有一个虚表指针的情况</strong>：(在64位中指针大小为8字节，32为4字节)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">my</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span> a;</span><br><span class="line">     <span class="type">double</span> b;</span><br><span class="line">     <span class="type">char</span> c;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">s</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">//sizeof(my)为32:8+8+8+8</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++动态内存</title>
    <url>/2023/03/06/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h3 id="动态内存">10.动态内存</h3>
<h4 id="生命周期">10.1 生命周期</h4>
<p><strong>目前的我们接触到的对象或者静态static都有着严格的生命周期：</strong></p>
<ul>
<li><strong>全局：</strong>程序启动时自动分配，程序结束时销毁</li>
<li><strong>局部对象：</strong>进入其所定义的程序时被创建，离开块时销毁</li>
<li><strong>静态：</strong>第一次使用前分配，程序结束时销毁</li>
</ul>
<p>上述中的变量只使用了静态内存和栈内存。它们会自动创建和销毁。静态内存保存局部static、类static成员以及定义在任何函数之外的变量。栈内存保存定义在函数内的非static对象</p>
<p>除了上述的自动分配外，<strong>c++还支持动态分配对象</strong>。（其生命周期与它们在哪创建无关，只有显式的被释放时，这些对象才会被销毁）。<strong>它们被分配在内存池，称作自由空间或堆。程序用堆来存储动态分配</strong>。</p>
<span id="more"></span>
<h4 id="new动态内存">10.2 new动态内存</h4>
<h5 id="直接动态内存管理">10.2.1 直接动态内存管理</h5>
<p>c++的动态内存管理是通过一对运算符来完成：</p>
<ul>
<li><code>new</code>,在动态内存中为对象分配空间并返回一个指向该对象的指针</li>
<li><code>delete</code>,接受一个动态对象的指针，销毁该对象，并释放关联的内存。</li>
</ul>
<p>不再使用的动态内存应及时释放，否则会造成内存泄漏。释放<code>delete</code>的时机要适宜，否则在还有指针引用内存的时候释放，会导致引用非法内存的指针错误.<strong>内存泄漏：分配内存使用完毕后不释放将引起内存泄漏，会榨干内存。 相对于智能指针，直接管理内存的类与使用智能指针的类不同，他们不能依赖类拷贝、赋值和销毁操作的任何默认定义。</strong>虽然如此，但有时候我们不得不用的<code>new与delete</code>。在后面我们还会介绍跟高级的内存分配工具<code>allocator类</code></p>
<h5 id="使用new动态分配和初始化对象">10.2.2 使用new动态分配和初始化对象</h5>
<p>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是<strong>返回一个指向该对象的指针</strong>。默认情况下，动态分配的对象是默认初始化的，这意味着<strong>内置类型或组合类型的对象的值是未定义的，而类类型对象将默认构造函数进行初始化</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string *ps=<span class="keyword">new</span> string;	<span class="comment">//初始化为空的string。类类型--&gt;默认构造,等价于与值初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>;	<span class="comment">//p指向一个动态分配、未初始化的无名对象。内置类型--&gt;值初始化</span></span><br></pre></td></tr></table></figure> 也可以直接初始化一个动态分配的对象： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line">string *ps=<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;trluper&quot;</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;* pv=<span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure> <strong><em>注意：对于内置类型，注意值初始化和默认初始化的区别：</em></strong></p>
<ul>
<li>对于定义了自己的构造函数的类类型（如string），要求值初始化是没有意义的，因为不管采用什么形式，对象都会通过默认构造函数来初始化；</li>
<li>对于内置类型，值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。</li>
<li>对于类中那些依赖于编译器合成的默认构造函数的内置类型对象，如果它们未在类内初始化，它们的值也是未定义的</li>
</ul>
<p>如果我们提供了一个括号包围的初始化器，就可以使用auto，此时初始化器可以推断我们想要分配的对象的类型，<strong>只有当括号中仅有单一初始化器才能使用auto</strong>： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1=<span class="keyword">new</span> <span class="built_in">auto</span>(obj);</span><br><span class="line"><span class="keyword">auto</span> p2=<span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125;;	<span class="comment">//错误，括号中只能有单一初始化器</span></span><br></pre></td></tr></table></figure></p>
<h5 id="动态分片的const对象">10.2.3 动态分片的const对象</h5>
<p><strong>动态分配的const对象必须进行初始化</strong>。对于定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* pci=<span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);		<span class="comment">//显示初始化</span></span><br><span class="line"><span class="type">const</span> string *pcs=<span class="keyword">new</span> <span class="type">const</span> string;		<span class="comment">//隐式</span></span><br></pre></td></tr></table></figure></p>
<h5 id="内存耗尽">10.2.4 内存耗尽</h5>
<p>默认情况下，<strong>如果<code>new</code>不能分配所要求的内存空间，会抛出一个类型为<code>bad_alloc</code>的异常</strong>。我们也可以改变使用<code>new</code>的方式来阻止它抛出异常（称为定位new)。<code>bad_alloc</code>和<code>nothrow</code>都定义在头文件<code>new</code>中： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> *p1=<span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//如果分配失败，会抛出一个类型为`bad_alloc`的异常</span></span><br><span class="line"><span class="type">int</span> *p2=<span class="built_in">new</span>(nothrow) <span class="type">int</span>;<span class="comment">//如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure></p>
<h5 id="释放内存">10.2.5 释放内存</h5>
<p><code>delete</code>表达式接受一个指针，指向我们想要释放的对象:<code>delete p</code>。 <strong>指针值和<code>delete</code>：</strong>传递给<code>delete</code>的指针必须指向动态分配的内存，或者是一个空指针。释放一块并<code>非new</code>分配的内存，或者将相同的指针值释放多次，其行为是未定义的。虽然一个<code>const对象</code>的值不能被改变，但它本身是可以被销毁的.<code>delete</code>条件有：</p>
<ul>
<li>应与<code>new</code>配对使用，既只能释放<code>new</code>分配得内存</li>
<li>不要再次释放已经释放得内存</li>
<li>如果使用<code>new[]</code>分配动态数组，应用<code>delete[]</code>释放</li>
<li>对空指针使用<code>delete</code>是安全的</li>
</ul>
<p>不需要再使用该动态分配的内存时，必须释放，否则容易内存泄漏！！以下是两个版本的use_factory函数。（p是已经new分配好的返回指针） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_factory</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//函数结束，不再需要，则释放</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">use_factory</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//函数结束，仍然需要，则返回后由调用这释放</span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="动态数组">10.2.6 动态数组</h5>
<p>某些应用需要一次性为很对对象分配内存（如vector)。为了支持这种需求，c++语言和标准库提供两者方法：</p>
<ul>
<li>分配和初始化一个对象数组</li>
<li>应用allocator类</li>
</ul>
<p>通常第二种法方会提供更好的性能和更灵活的管理内存能力，我们将在后面介绍，同时<strong>“STL源码剖析”</strong>会更详细。这类我们说说<code>new[]</code></p>
<p><strong>new和数组</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[size];		<span class="comment">//返回的指向第一个元素对象指针</span></span><br><span class="line"><span class="comment">//初始化动态分配对象的数组</span></span><br><span class="line"><span class="comment">//不加括号——默认初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];		<span class="comment">//默认初始化</span></span><br><span class="line"><span class="comment">//大小之后加一对空括号——值初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]();		<span class="comment">//10个值初始化为0</span></span><br><span class="line"><span class="comment">//大小之后跟一个花括号列表——初始化器初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放，使用特殊的delete来释放动态数组，在delete前加上一个空方括号对(方括号必须加上)</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure> 当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。但此指针不能解引用——毕竟它不指向任何元素。</p>
<p><strong><em>注意：</em></strong>我们得到的时数组元素的指针，而不是数组的对象，所以我们不能调用标准库函数中的<code>begin()和end()</code>，也不能使用<code>范围for循环</code>。</p>
<h5 id="placement-new">10.2.7 placement new</h5>
<p><code>placement new</code>相当于C语言中的<code>realloc</code>，在已有空间的基础上，重新分配一个空间，可以不破坏原来数据，也可以把数据全部用新值覆盖。这个操作就是把已有的空间当成一个缓冲区来使用，这样子就减少了分配空间所耗费的时间，因为直接用new操作符分配内存的话，在堆中查找足够大的剩余空间速度是比较慢的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//就是在指针p所指向的内存空间创建一个T1类型的对象，但是对象的内容是从T2类型的对象转换过来的,</span></span><br><span class="line"><span class="comment">//就是在已有空间的基础上重新调整分配的空间，类似于realloc函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _construct(T1 * p, <span class="type">const</span> T2&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">new</span>(p) <span class="built_in">T1</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="三种new重要">10.2.8 三种new(重要)</h5>
<p><code>new</code>存在三种操作符，其含义和应用的场景都不同。在这里我们必须再次提到<code>new operator</code>、<code>operator new</code>和<code>placement new</code>三种<code>new</code>。在前面我们介绍的都是具有构造效果的<code>new operator</code></p>
<ul>
<li><p><code>new operator</code>指的就是new操作，使用它会经过两个步骤：一是调用<code>::operator new</code>操作符申请内存；二是使用类型的构造函数对内存地址进行构造。‘new operator`操作符不能被重载 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">classA* p=<span class="keyword">new</span> <span class="built_in">classA</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>operator new</code>操作符是单纯的申请内存，相当于C当中的<code>malloc函数</code>，<code>operator new</code>可以重载。<code>::operator new</code>和<code>::operator delete</code>前面加上<code>::</code>表示全局，使用时就像<code>malloc</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *tmp=(<span class="type">int</span>*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size*<span class="built_in">siezeof</span>(<span class="type">int</span>))));</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>placement new</code>仅仅返回已经申请好内存的指针，它通常应用在对效率要求高的场景下，提前申请好内存，能够节省申请内存过程中耗费的时间</p></li>
</ul>
<h4 id="new-operator与c的malloc的比较">10.3 new operator与C的malloc的比较</h4>
<p>首先我们来看<code>operator new</code>生成的源码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GLIBCXX_WEAK_DEFINITION <span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> sz)</span> _<span class="title">GLIBCXX_THROW</span> <span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">void</span> *p;</span><br><span class="line">  <span class="comment">/* malloc (0) is unpredictable; avoid it.  */</span></span><br><span class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>)</span><br><span class="line">    sz = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (__builtin_expect ((p = <span class="built_in">malloc</span> (sz)) == <span class="number">0</span>, <span class="literal">false</span>))<span class="comment">//底层仍然使用malloc</span></span><br><span class="line">    &#123;</span><br><span class="line">      new_handler handler = std::<span class="built_in">get_new_handler</span> ();</span><br><span class="line">      <span class="keyword">if</span> (! handler)</span><br><span class="line">	_GLIBCXX_THROW_OR_ABORT(<span class="built_in">bad_alloc</span>());</span><br><span class="line">      <span class="built_in">handler</span> ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从上面可以看到operator new的内部实现仍然使用<code>malloc</code>，也就不奇怪new的行为像<code>malloc</code>。</p>
<p>这里主要介绍<code>new operator</code>与malloc主要区别如下：</p>
<ul>
<li><code>new operator</code>分配内存按照数据类型进行分配，<code>malloc</code>分配内存按照指定的大小分配；</li>
<li><code>new</code>返回的是指定对象的指针，而<code>malloc</code>返回的是void*，因此malloc的返回值一般都需要进行类型转化。</li>
<li><code>new</code>不仅分配一段内存，而且会调用构造函数，<code>malloc</code>不会。</li>
<li><code>new</code>分配的内存要用<code>delete</code>销毁，<code>malloc</code>要用<code>free</code>来销毁；<code>delete</code>销毁的时候会调用对象的析构函数，而<code>free</code>则不会。</li>
<li><code>new</code>是一个操作符可以重载，内部实现仍然使用<code>malloc</code>这个库函数。</li>
<li><code>malloc</code>分配的内存不够的时候，可以用<code>realloc</code>扩容。new则能使用<code>replacement new</code>方式来到底<code>realloc</code>功能</li>
<li><code>new</code>如果分配失败了会抛出<code>bad_malloc</code>的异常，而<code>malloc</code>失败了会返回<code>NULL</code>。</li>
<li>8、申请数组时： <code>new[]</code>一次分配所有内存，多次调用构造函数，搭配使用<code>delete[]</code>，<code>delete[]</code>多次调用析构函数，销毁数组中的每个对象。而<code>malloc</code>是通过<code>free(p)</code>来释放。</li>
</ul>
<h4 id="shared_ptr智能指针">10.4 shared_ptr智能指针</h4>
<p>为了更安全地使用动态内存，新标准库提供了两种智能指针。智能指针类似于常规指针，<strong>但区别是它负责自动释放所指向的对象：</strong></p>
<ul>
<li><code>shared_ptr</code>,它允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code>，独占一个对象（一个指针指向一个对象）</li>
<li><code>weak_ptr</code>,弱引用，指向<code>shared_ptr</code>所过来的对象</li>
</ul>
<p>上述的三种类型都定义在<code>memory</code>头文件中</p>
<h5 id="shared_ptr类">10.4.1 shared_ptr类</h5>
<p>类似于vector,智能指针也是模板。使用该类的理由有以下几点：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; p1;		<span class="comment">//p1指向string</span></span><br><span class="line">shared_ptr&lt;list&lt;T&gt;&gt; p2;		<span class="comment">//指向int的list</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/06/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/shared_ptr.png" width="700"></p>
<h5 id="make_shared函数">10.4.2 make_shared函数</h5>
<p>最安全的分配和使用动态内存的方法是调用该函数。<code>make_shared&lt;T&gt;(args)</code>函数在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hared_ptr&lt;<span class="type">int</span>&gt; p3=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//指向一个值为42的int的shared_ptr</span></span><br><span class="line">shared_ptr&lt;string&gt; p4=<span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">//指向一个值为9999999999的string</span></span><br><span class="line">share_ptr&lt;<span class="type">int</span>&gt; p5=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//指向值初始化为0的int</span></span><br><span class="line"><span class="keyword">auto</span> p5=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//指向值初始化为0的int</span></span><br></pre></td></tr></table></figure></p>
<h5 id="shared_ptr的拷贝和赋值和释放">10.4.3 shared_ptr的拷贝和赋值和释放</h5>
<ul>
<li><p>当进行拷贝和赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他<code>shared_ptr</code>指向相同的对象。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;		<span class="comment">//q是p的拷贝，递增了的计数器。对象此时有俩引用者</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>当给相应的<code>shared_ptr</code>赋予一个新值，计数器递减，当为0时，自动释放自己所管理的对象。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);		<span class="comment">//创建shared_ptr,为值43动态分配内存，拷贝</span></span><br><span class="line">p=r;		<span class="comment">//给p新赋值r,令他指向了另一个地址，此时</span></span><br><span class="line">			<span class="comment">//递增r所指向的引用计数</span></span><br><span class="line">			<span class="comment">//递减p原来的指向的对象的引用计数</span></span><br><span class="line">			<span class="comment">//若递减后为0，已没有引用者，自动释放</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong><code>销毁\释放原理</code></strong>：通过一个特殊的成员函数————析构函数完成销毁工作（每个类都有一个析构函数）。<strong>析构函数一般用来来释放对象所分配的的资源</strong>。<code>shared_ptr</code>的析构函数会递减它所指向对象的引用计数，当为0时，就会销毁对象，释放内存。</p>
<ul>
<li>当对象被销毁时，将递减其引用引用计数并检查它是否为0，如下这个例子： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;foo&gt; <span class="title">factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line"><span class="comment">//该函数返回shared_ptr</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_shared</span>&lt;foo&gt;(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">use_factory</span>(T arg)</span><br><span class="line">&#123;	</span><br><span class="line">shared_ptr&lt;Foo&gt; p=<span class="built_in">factory</span>(arg);</span><br><span class="line"><span class="comment">//为arg用智能指针动态分配内存，达到能够自动释放的目的</span></span><br><span class="line">&#125;<span class="comment">//对象p离开了此作用域被销毁，此时计数减一（此例为0--&gt;释放内存）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">shared_ptr&lt;Foo&gt; p=<span class="built_in">factory</span>(arg)	</span><br><span class="line"><span class="comment">//为arg用智能指针动态分配内存，达到能够自动释放的目的</span></span><br><span class="line"><span class="keyword">return</span> p;	<span class="comment">//引用加1，为2</span></span><br><span class="line">&#125;	<span class="comment">//此时p减一，但不为0，不释放</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="shared_ptr的共享数据">10.4.4 shared_ptr的共享数据</h5>
<p>到目前为止，我们使用的类中，分配的资源都与对应对象生存期一致。当我们拷贝一个<code>vector</code>时，<code>原vector</code>和<code>副本vector</code>中的元素是相互分离的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v1;</span><br><span class="line">&#123;<span class="comment">//新作用域</span></span><br><span class="line">    vector&lt;string&gt; v2=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line">    v1=v2; <span class="comment">//从v2拷贝元素到v1</span></span><br><span class="line">&#125; <span class="comment">//v2被销毁，其中的元素也被销毁</span></span><br><span class="line"><span class="comment">//v1依然有三个元素</span></span><br></pre></td></tr></table></figure> 所以此时的<code>V2只是V1</code>的一份赋值过来的值。指向的不是共同地址的数据。(这里的共同是指内存地址是同一个）。为了达到这个目的，<code>shared_ptr</code>就排上了用场--&gt;多个对象共享数据。</p>
<h5 id="定义strblob类">10.4.5 定义StrBlob类</h5>
<p>下面的是创建一个类模板（实现多个对象共享数据），每个<code>strBlob</code>对象设置一个<code>shared_ptr</code>来管理动态分配的vector。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlob</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::vector&lt;std::string&gt;::size_type size_type;</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">StrBlob</span>();</span><br><span class="line">	<span class="comment">//可变形参构造函数，内元素均为字面值且为strig</span></span><br><span class="line">	<span class="built_in">StrBlob</span>(std::initializer_list&lt;std::string&gt; il);</span><br><span class="line">	<span class="comment">//容器大小和判空</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span>  <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> std::string &amp;t)</span> </span>&#123; data-&gt;push_back; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//外部获得类的data</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;* <span class="built_in">get</span>()&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置data</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(shared_ptr&lt;std::vector&lt;std::string&gt;&gt;* p)</span></span>&#123;</span><br><span class="line">		data=p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">std::string &amp;<span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string &amp;<span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//声明智能指针data</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;</span><br><span class="line">	<span class="comment">//如果data[i]不合法，抛出一个异常</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span>()：<span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;()) &#123;&#125;</span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span>(initializer_list&lt;string&gt; il):</span><br><span class="line">       <span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125;</span><br><span class="line"><span class="comment">//检查函数，i&gt;size，抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrBlob::check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取头元素</span></span><br><span class="line"><span class="function">string &amp;<span class="title">StrBlob::front</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;front on empty StrBlob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取尾元素</span></span><br><span class="line"><span class="function">string&amp; <span class="title">StrBlob::back</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;back on empty StrBlob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弹出尾部元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrBlob::pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了该类后，我们创建类的对象，可以通过<code>get</code>函数获得智能指针，通过<code>set</code>赋给类的新对象即可.这样实现了类多个对象的数据共享。这要看很像类的静态成员，但它比静态成员有一个好处就是，当没有对象引用时，会释放，而不像静态成员持续到程序结束时才释放</p>
<h5 id="shared_ptr和new结合使用">10.4.6 shared_ptr和new结合使用</h5>
<p>我们可以用<code>new</code>返回的指针来初始化智能指针。因为接受指针参数的智能指针构造函数是<code>explicit</code>的，<strong>因此我们不能将一个内置指针隐式转换成一个智能指针</strong>，必须使用直接初始化形式而且使用字面值： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);    <span class="comment">//错误：必须使用直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;   <span class="comment">//正确：使用了直接初始化形式</span></span><br></pre></td></tr></table></figure> 同理，一个返回<code>shared_ptr</code>的函数不能在其返回语句中隐式转换成一个普通指针： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(p);  <span class="comment">//错误：隐式转换为shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));  <span class="comment">//正确：显式地用int*创建shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所关联的对象。 <strong><em>注意：</em></strong>内置指针是指内置类型<code>（如int、char)</code>的指针，一般没有默认构造函数。普通指针是普通类型的指针），一般有默认构造函数</p>
<p><img src="/2023/03/06/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/shared.png" width="700"></p>
<h5 id="莫交错使用new和shared_ptr">10.4.7 莫交错使用new和shared_ptr</h5>
<p>当将一个<code>shared_ptr</code>绑定到一个普通指针时，我们就将内存的管理责任交给了这个<code>shared_ptr</code>。一旦这么做了，我们就不应该再使用内置指针来访问<code>shared_ptr</code>所指向的内存了。如下列子: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; p)</span></span>&#123;</span><br><span class="line"><span class="comment">//空函数，离开时p对象被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;  <span class="comment">//危险：x是一个普通指针，而不是一个智能指针</span></span><br><span class="line"><span class="comment">//process(x);           //错误：不能将int*转换成一个shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));   <span class="comment">//临时shared_ptr，合法的，但内存会被释放，引用计数变为0</span></span><br><span class="line"><span class="type">int</span> j=*x;   <span class="comment">//未定义的：x是一个空悬指针</span></span><br></pre></td></tr></table></figure></p>
<p><strong>上述代码中<code>x</code>是一个普通指针，当把<code>x</code>传给<code>process</code>时，报错，因为普通指针不能隐式的转换为智能指针。传入的实参显示转换为智能指针，此时<code>x</code>就将内存交给了<code>shared_ptr</code>管理</strong>，当该函数执行完毕时，该指针指针<code>shared_ptr</code>被销毁（x所指向的内存没了），<code>x</code>也就成了空悬指针。</p>
<p>使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。而且内置指针很可能成为空悬指针</p>
<h5 id="智能指针和异常">10.4.8 智能指针和异常</h5>
<p>使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//如果在这里抛出了异常,其内存也会释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面这种清空就不会释放：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//如果在这里抛出了异常</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;<span class="comment">//因为抛出了异常，无法执行delete p语句</span></span><br></pre></td></tr></table></figure></p>
<h5 id="删除器">10.4.9 删除器</h5>
<p>某些类没有定义析构函数，此时我们可以使用<code>shared_ptr</code>来保证该类生成的对象的内存被正确释放，首先定义一个函数（删除器）来代替得<code>delete</code>。下面以连接为例子，<code>destination</code>类是连接信息类 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一些类和接口</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;		<span class="comment">//该类标识我们连接的信息，如端口，地址</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connnection</span>;		<span class="comment">//连接类，已连接信息记录</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destionatin *p)</span></span>;	<span class="comment">//请求连接,返回一个连接类记录信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnection</span><span class="params">(connection)</span></span>;		<span class="comment">//关闭连接,内含delete操作</span></span><br><span class="line"><span class="comment">//对声明的类和接口定义</span></span><br><span class="line">....</span><br><span class="line"><span class="comment">//定义删除器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connecttion</span><span class="params">(connection *p)</span></span>&#123;</span><br><span class="line">	<span class="built_in">disconnection</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shared_ptr使用删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">	connection c=<span class="built_in">connect</span>(&amp;d)；	<span class="comment">//返回一个连接类信息</span></span><br><span class="line">	shared_ptr&lt;connection&gt; <span class="built_in">p</span>(&amp;c,end_connnection);	<span class="comment">//shared_ptr的用法，自定义删除器</span></span><br><span class="line">	<span class="comment">//这样。当f函数退出时，即使是由异常引起的，Connection也会被释放关掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当对象智能指针对象p离开函数f的作用域时，自动调用end_connection函数，end_connection函数又调用disconnection函数执行delete操作，注意形参时指针类型</p>
<h6 id="shared_ptr与数组">10.4.10 shared_ptr与数组</h6>
<p>与<code>unique_ptr</code>不同，<code>shared_ptr</code>不直接支持管理动态数组。如果我们希望使用<code>shared_ptr</code>管理一个动态数组，<strong>必须提供自己定义的删除器(因为删除是我们默认的是<code>delete</code>而不是<code>delete[]</code>)：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了使用shared_ptr,必须提供一个删除器</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>],[](<span class="type">int</span> *p)&#123;<span class="keyword">delete</span> [] p;&#125;)</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>();   <span class="comment">//使用我们提供的lambda释放数组，它使用delete[]</span></span><br></pre></td></tr></table></figure> <code>shared_ptr</code>未定义下标运算符，<strong>而且智能指针类型不支持指针算数运算</strong>。因此，为了访问数组中的元素，必须用<code>get</code>获取一个内置指针，然后用它来访问数组元素： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</span><br><span class="line">    *(sp.<span class="built_in">get</span>()+i)=i;  <span class="comment">//使用get获取一个内置指针</span></span><br></pre></td></tr></table></figure></p>
<h4 id="unique_ptr">10.5 unique_ptr</h4>
<p><code>unique_ptr</code>是C++的另一个智能指针，与<code>shared_ptr</code>不同的是，任何时刻，都至多只能有一<code>unique_ptr</code>智能指针指向一个对象，当<code>unique_ptr</code>指针被销毁时，其对象也被销毁。</p>
<h5 id="unique_ptr的初始化">10.5.1 unique_ptr的初始化</h5>
<p>与<code>shared_ptr</code>不同，没有类似<code>make_shared</code>的标准函数返回一个<code>unique_ptr</code>。因此，当我们定义一个<code>unique_ptr</code>时，需要将其绑定到一个<code>new</code>返回的指针上。类似于<code>shared_ptr</code>（接受参数的构造函数有<code>explicit修饰</code>），所以初始化<code>unique_ptr</code><strong>必须采用直接初始化方式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p;		<span class="comment">//定义</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;		<span class="comment">//定义并初始化，指向一个值为24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr不支持普通的拷贝和赋值：</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p2</span>(p1);		<span class="comment">//错误，不支持拷贝</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;p3;</span><br><span class="line">p3=p1;						<span class="comment">//或p3(p2)错误，不允许赋值</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/06/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/unique_ptr.png" width="700"></p>
<p>虽然我们无法拷贝或者赋值，但我们可以通过调用<code>release或reset</code>将指针所有权从一个<code>（const)unique_ptr</code>转移给另一个<code>unique_ptr</code>: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;	<span class="comment">//p1转移给p2，p1置空</span></span><br><span class="line">unique_ptr&lt;string&gt;<span class="built_in">p3</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line"><span class="comment">//p3转移给p2ertyui</span></span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">//p2释放原来的，p3被置空，p2指向的p3的</span></span><br></pre></td></tr></table></figure> <strong><code>release</code>函数会切断智能指针和它原来管理的对象的联系</strong>，它返回的指针通常用来初始化另一个智能指针或给另一个智能指针赋值。 如果我们不用另一个智能指针来保存<code>release</code>返回的指针，我们的程序就要负责资源的释放： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=p2.<span class="built_in">release</span>();		<span class="comment">//后面程序应该有delete(p);操作</span></span><br></pre></td></tr></table></figure></p>
<h5 id="向unique_ptr传递删除器">10.5.2 向unique_ptr传递删除器</h5>
<p>和<code>shared_ptr</code>一样，<code>unique_ptr</code>默认情况（源代码）使用<code>delete</code>释放它指向的对象。我们可和<code>shared_ptr</code>一样重载一个<code>unique_ptr</code>中的删除器。</p>
<p>重载一个<code>unique_ptr</code>中的删除器会影响到<code>unique_ptr类型</code>以及如何构造（或<code>reset</code>）该类型的对象：<strong>我们必须在尖括号中<code>unique_ptr</code>指向类型之后提供删除器类型</strong>，即在创建或<code>reset</code>一个这种<code>unique_pt</code>r类型的对象时，必须提供一个指定类型的可调用对象（删除器） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span></span><br><span class="line"><span class="comment">//它会调用一个名为fcn的delT类型对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT,delT&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> objT,fcn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(desitination &amp;d)</span></span>&#123;</span><br><span class="line">	connection c=<span class="built_in">connect</span>(&amp;d)；	<span class="comment">//返回一个连接类信息</span></span><br><span class="line">	<span class="comment">//当p被销毁时，连接会关闭</span></span><br><span class="line">	unique_ptr&lt;connection,<span class="keyword">decltype</span>(end_connection)*&gt; <span class="built_in">p</span>(&amp;c,end_connnection);</span><br><span class="line">	<span class="comment">//这样。当f函数退出时，即使是由异常引起的，Connection也会被释放关掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong><em>注：</em></strong><code>decltype</code>是C++11新增的一个关键字，和<code>auto</code>的功能一样，用来在编译时期进行自动类型推导。引入<code>decltype</code>是因为<code>auto</code>并不适用于所有的自动类型推导场景，在某些特殊情况下auto用起来很不方便，甚至压根无法使用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> varName=value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varName=value;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li><code>auto</code>根据<code>=</code>右边的初始值推导出变量的类型，<code>decltype</code>根据<code>exp</code>表达式推导出变量的类型，跟``=右边的value没有关系</li>
<li><code>auto</code>要求变量必须初始化，这是因为<code>auto</code>根据变量的初始值来推导变量类型的，如果不初始化，变量的类型也就无法推导</li>
<li>而<code>decltype</code>不要求，因此可以写成如下形式 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varName;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h5 id="指向数组的unique_ptr">10.5.3 指向数组的unique_ptr</h5>
<p>标准库提供了一个可以管理<code>new</code>分配的数组的<code>unique_ptr</code>版本。使用<code>unique_ptr</code>管理动态数组时，我们必须在对象类型后面跟一对方括号,下面是用法介绍： <img src="/2023/03/06/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/uniquearry.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">up.<span class="built_in">release</span>();   <span class="comment">//自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>
<p>另外一方面，当一个unique_tr指向一个数组时，我们可以使用下标运算符来访问数组中的元素： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</span><br><span class="line">    up[i]=i;  <span class="comment">//为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure></p>
<h4 id="weak_ptr">10.6 weak_ptr</h4>
<p><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针,是弱用智能指针，<strong>它指向一个有<code>shared_ptr</code>管理的对象。将一个<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变<code>share_ptr</code>的引用计数。</strong> <img src="/2023/03/06/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/weak_ptr.png" width="700"> 当我们创建一个<code>weak_ptr</code>时，我们要用以<code>shared_ptr</code>初始化它： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">43</span>);</span><br><span class="line"><span class="function">weak_ptr <span class="title">wp</span><span class="params">(p)</span></span>;		<span class="comment">//wp若共享p,p的引用计数不变</span></span><br></pre></td></tr></table></figure> 由于对象可能不存在，不能直接使用<code>weak_ptr</code>直接访问对象，必须调用<code>lock(</code>)函数！该函数会检查<code>weak_ptr</code>指向的对象是否存在，若存在，则返回一个指向共享对象的<code>shared_ptr</code>。如： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; q=wp.<span class="built_in">lock</span>())	</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使用q访问对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="allocator类">10.7 allocator类</h4>
<p>在前面我们主要介绍了<code>new,delete和智能指针</code>。但他们分配的内存不是原始的，它们在分配的时候要对内存进行构造。<strong>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</strong> <img src="/2023/03/06/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/allocator.png" width="700"></p>
<h5 id="allocate分配未构造内存">10.7.1 allocate：分配未构造内存</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">allocator&lt;string&gt; allco;	<span class="comment">//定义可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p=alloc.<span class="built_in">allocate</span>(n);	<span class="comment">//分配n个为初始化的string</span></span><br></pre></td></tr></table></figure>
<p><code>alloc</code>完成了分配n个<code>string</code>的连续内存的工作，并且返回一个指向这一块内存的首地址给指针<code>p</code>。我希望p记住这个首地址在哪免得我后边找不到了，所以把它设为<code>const</code>的。</p>
<h5 id="construct创建对象">10.7.2 construct：创建对象</h5>
<p>下面我让<code>alloc</code>为我在这些内存上构造对象：<code>alloc.construct(内存地址，参数......)</code>，括号里的“参数”是给我这块内存的对象类型的构造函数的参数，比如这里对于<code>string</code>，可以这样: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string *S=p;	<span class="comment">//将首地址给S</span></span><br><span class="line">alloc.<span class="built_in">constrcut</span>(S,<span class="number">10</span>,<span class="string">&#x27;A&#x27;</span>);		<span class="comment">//该内存构造string &quot;AAAAAAAAAA&quot;</span></span><br><span class="line">S++;			<span class="comment">//把内存地址往后挪，以便后续的构造</span></span><br></pre></td></tr></table></figure> <strong><em>注意：使用未构造的对象的内存空间是错误</em></strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;*p&lt;&lt;endl;		<span class="comment">//正确，p是指向首地址</span></span><br><span class="line">cout&lt;&lt;*S&lt;&lt;endl;		<span class="comment">//错误，还没构造</span></span><br></pre></td></tr></table></figure></p>
<h5 id="destroy摧毁对象">10.7.3 destroy：摧毁对象</h5>
<p>当我们用完对象后，必须对每个构造的元素调用<code>destory</code>来摧毁它们。我们只能对真正构造了的元素进行<code>destory</code>操作,而且只有摧毁的内存或未构造的内存才能被<code>deallocate</code>回收。<code>destroy</code>参数接受一指针，对指向的对象执行析构函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(q!=p)</span><br><span class="line">alloc.<span class="built_in">destroy</span>(--q);</span><br></pre></td></tr></table></figure> 一旦元素被销毁，我们就可以重新使用这部分内存来保存其他string,也可以将其归还给系统。释放内存通过调用dealloccate来完成： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alloc.<span class="built_in">dealloccate</span>(p,n);	<span class="comment">//p必须是allocate返回的指针，n必须是分配时指定的n</span></span><br></pre></td></tr></table></figure></p>
<h5 id="拷贝和填充未初始化的内存算法">10.7.4 拷贝和填充未初始化的内存算法</h5>
<p>allocator还有两个伴随算法，可以在未初始化内存中创建对象。它们都定义在头文件<code>memory</code>中。 <img src="/2023/03/06/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/allocator_algorithm.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配动态内存</span></span><br><span class="line"><span class="keyword">auto</span> p=alloc.<span class="built_in">allocate</span>(v.<span class="built_in">size</span>()*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//拷贝vi的元素到未构造内存,返回下一个未构造地址</span></span><br><span class="line"><span class="keyword">auto</span> q=<span class="built_in">uninitialized_copy</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),p);</span><br><span class="line"><span class="comment">//将剩余空间构造为42</span></span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(q,vi.<span class="built_in">size</span>(),<span class="number">42</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法思想</title>
    <url>/2022/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h4 id="动态规划">1. 动态规划</h4>
<p>我们遇到的问题中，有很大一部分可以用动态规划<code>Dynamic Programming</code>来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解题</p>
<span id="more"></span>
<h5 id="动态规划的原理">1.1 动态规划的原理</h5>
<p><strong>动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度</strong>， 因此它比回溯法、暴力法等要快许多。动态规划要求我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。由于单纯使用语言来描述动态规划晦涩难懂，因此采用例子来说明：</p>
<p><strong>问题1：假设有1元、3元和5元的硬币，如何用最少的的硬币凑够11元？</strong></p>
<p>学过贪心算法知道，加如使用贪心算法，每次拿面额最高的银币来逼近这个11是一个方法，但它不能保证一定是最少数量的。因此这里介绍动态规划来解答。正如上面所说，动态规划就是将问题小化，以上一次的子问题的最优解推出下一个的最优解：</p>
<ul>
<li>因此我们可想当面额为<code>i</code>时，最少的硬币数量是多少，我们使用<code>dp[i]</code>表示凑够<code>i</code>元时最少的硬币数量。</li>
<li>豪无疑问，当<code>i=0</code>时<code>dp[0]=0</code>，因为题目给出了1元、3元和5元的面额，我们需要对这些进行处理，因此能够得到其他的初始条件，<code>i=1</code>时<code>dp[i]=1</code>,i=3时<code>dp[3]=1</code>,i=5时<code>dp[5]=</code>。</li>
<li>完成了初始化条件后，我们可以继续推其他面额的情况，由提供的三种面额，可以知道当<code>i=2</code>时<code>dp[2]=2</code>，但<code>i=3</code>时，组成它的有两种选择，一种时三个1元硬币，另一种是直接选择3元，有<code>min(dp[3].dp[2]+1)</code>知道<code>dp[3]=1</code>是最优解，同样<code>dp[4]</code>，它可以有<code>4=1+3</code>或者<code>4=3+1</code>，两者的的数量是一致的，只不过是次序的不同，再到<code>dp[5]</code>可以检查<code>min(dp[4]+1,dp[2]+1,dp[5])</code>取最小</li>
<li>由上面的分析，我们可以很容易的分析到这样一个状态转移方程： <span class="math display">\[
dp[i]=
\begin{cases}
min(dp[i-1]+1,dp[i-3]+1,dp[i-5]+1),i&gt;5\\
1,i=1,3,5\\
2,i=2,4
\end{cases}
\]</span></li>
</ul>
<p>这样问题就迎刃而解，得如下代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 有面值1，3，5的硬币，试求组成39元时用到最少的硬币数量</span></span><br><span class="line"><span class="comment">* 首先定义dp[i]表示i元时用到得最少银币数</span></span><br><span class="line"><span class="comment">* 由题得初始化条件dp[0]=0,dp[1]=1,dp[3]=1,dp[5]=5</span></span><br><span class="line"><span class="comment">* 当i&gt;5时，会有状态转移方程dp[i]=min(dp[i-1].dp[i-3],do[i-5])+1;</span></span><br><span class="line"><span class="comment">*当i&lt;=5时，这个范围含的2，4未初始化，</span></span><br><span class="line"><span class="comment">*可以增加以判断条件当i-1&gt;=0,i-3&gt;=0,i-5&gt;0来决定，是否要在状态转移方程添加对应项</span></span><br><span class="line"><span class="comment">* 这里由于能够自己推段2，4的最小数量，直接当作初始化，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCoin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">40</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">5</span>] = <span class="number">1</span>;	</span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	dp[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] = <span class="built_in">Min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">3</span>], dp[i - <span class="number">5</span>]) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">39</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的案例可以知道，解决动态规划的策略最重要的三步是：</p>
<ul>
<li><strong>确定<code>dp</code>数组的含义</strong></li>
<li>确定可从题意得出的临界值</li>
<li><strong>确定状态转移方程</strong></li>
</ul>
<p>有了状态和状态转移方程，问题基本上也就解决了，接下来的问题只是如何写迭代代码而已。</p>
<h5 id="初级问题">1.2 初级问题</h5>
<p>上面的硬币问题只能说是很简单的动态规划问题，我们可以在来看看更复杂一点的。</p>
<p><strong>问题：</strong>一个序列有N个数：A[1],A[2],…,A[N]，求出最长连续非降子序列的长度</p>
<p>同样对于这个问题也能使用动态规划来解决，定义一个<code>dp[i]</code>表示包括当前下标<code>i</code>的非降子序列的长度，那么就有这样的条件：</p>
<ul>
<li>初始条件中，我们肯定可以知道<code>i=0</code>时<code>d[i]=1</code>。</li>
<li>状态转移方程则有<code>d=1+(s[i]&gt;=s[i-1]?d[i-1]:0)</code>，这个状态转移方程指示，我们只需将当前的访问的元素与上一个元素进行对比，如果是<code>&gt;=</code>，则与之前一样是一个非降子序列，反之则不是，重新计数非降子序列长度</li>
<li>最后只需要遍历一次<code>d[i]</code>就能得到最长非降子序列的长度，起始和结束位置也能递推</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">maxLength</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len)</span></span>;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] =<span class="number">1</span>+( s[i] &gt;= s[i - <span class="number">1</span>] ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getmaxValue</span>(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的问题可以进一步升级，不要求连续，如下：</p>
<p><strong>问题：</strong>一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度</p>
<p>虽然这个问题不要求连续，我们同样能够使用一维<code>dp[i]</code>尝试解决，同样要找出初始条件和状态转移方程。<strong>我们可以让<code>dp[i]</code>是表示在以<code>A[i]</code>结尾的即下标<code>0~i</code>的子序列的最长非降长度</strong>，那么就有如下策略：</p>
<ul>
<li>初始条件<code>dp[0]=1</code></li>
<li>状态转移方程有两种情况，一是必须在前面找到所有的个x,使得<code>A[i]&gt;=A[x]</code>，更新<code>dp[x]=dp[x]+1</code>,然后执行取最大值,如果没有找到则直接赋值为<code>dp[i]=1</code>。即</li>
</ul>
<p><span class="math display">\[
dp[i]=
\begin{cases}
max(dp[x]+1)     当之前序列存在A[i]&gt;=A[x]时，\\
1，           之前的序列不存在A[x]&lt;=A[i]时
\end{cases}
\]</span></p>
<ul>
<li>最后遍历一遍<code>dp</code>数组，取最大值，</li>
<li>该算法因为当<code>A[i]&lt;A[i-1]</code>时，需要从后往前遍历dp数组。外部循环为<code>n</code>，内部平均循环为<code>n/2</code>，因此时间复杂度为<code>O(N*N)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSonLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(len);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(i)</span></span>;</span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cap[i] &gt; cap[j]) &#123;</span><br><span class="line">                    tmp[index]=dp[j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> max=<span class="built_in">getmaxValue</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (max==<span class="number">0</span>)</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=max+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getmaxValue</span>(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的算法分时间复杂度达到了<code>O(N*N)</code>,是否有办法使复杂度降到<code>O(NlogN)</code>？我们可以看到上面的程序之所以变为<code>O(N*N)</code>，是因为每次对<code>A[i]</code>都要遍历之前的<code>A[x]</code>，我们是否可以通过增加一个数组来存储形成的最长非降子序列，然后进行二分查找呢，经过二分查找使得复杂度变为<code>O(NlogN)</code>:</p>
<p><strong>要这样做我们必须重新定义<code>dp[i]</code>数组的意义，<code>dp[i]</code>它表示长度为<code>i+1</code>的递增子序列中，最大的序列尾数；再定义一个<code>maxL</code>变量，指示当前最长递增子序列的长度，对数组<code>dp</code>二分查找，判断<code>cap[x]</code>要插入的位置</strong></p>
<ul>
<li>若<code>cap[x]&gt;dp[maxL]</code>,表示当前该值比递增子序列的尾数都大，将<code>cap[x]</code>添加到<code>dp</code>尾部，<code>maxL++</code></li>
<li>若<code>dp[i-1]&lt;cap[x]&lt;dp[i]</code>，更新相应<code>dp[i]</code>即可</li>
</ul>
<p>显然这种方法以及不算动态规划了，是一种特殊解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; storage)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">	<span class="type">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> lo = <span class="number">0</span>, hi = maxL;</span><br><span class="line">		<span class="comment">//二分查找</span></span><br><span class="line">		<span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (dp[mid] &lt; num)</span><br><span class="line">				lo = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				hi = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[lo] = num;</span><br><span class="line">		<span class="keyword">if</span> (lo == maxL)</span><br><span class="line">		&#123;</span><br><span class="line">			maxL++;</span><br><span class="line">			<span class="keyword">if</span>(storage[<span class="number">0</span>].size&lt;maxL)</span><br><span class="line">				storage.<span class="built_in">clear</span>();</span><br><span class="line">			storage.<span class="built_in">push_back</span>(dp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>附加：如果要你返回所有最长递增子序列或者返回最长递增子序列的个数该如何解决？</em></strong> <a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/solution/zui-chang-di-zeng-zi-xu-lie-de-ge-shu-by-w12f/">leetcode第673题.最长递增序列的个数</a></p>
<h5 id="中级">1.3 中级</h5>
<p>上面举的例子都是对一维<code>dp</code>来解决，接下来介绍如何解决二维<code>dp</code>的问题。</p>
<p>**问题：平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果**</p>
<p>当然了，使用动态规划<code>dp</code>就要找初始条件喝状态转移方程</p>
<ul>
<li>定义二维数组<code>dp[N][M]</code>，<code>d[i][j]</code>表示从<code>A[0][0]</code>到<code>A[i][j]</code>能收集到的最多苹果数量</li>
<li>因为只能向下喝右移动，则有状态转移方程<code>d[i][j]=max(d[i-1][j],d[i][j-1])+A[i][j]</code>，其中<code>i&gt;0,j&gt;0</code></li>
<li>为了方便实现状态转移方程，我们可以人增加隔离带，即<code>A[0][j]=0、A[i][0]=0</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxApple</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cap.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> row = cap[<span class="number">0</span>].<span class="built_in">size</span>(),</span><br><span class="line">		col = cap.<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(col+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(row+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= col; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= row; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> Max = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			dp[i][j] = Max + cap[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[col][row];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述算法复杂度为<code>O(N*M)</code></p>
<h4 id="参考文章动态规划从新手到专家">参考文章：<a href="https://hawstein.com/2013/03/26/dp-novice-to-advanced/">动态规划：从新手到专家</a></h4>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="算法总览">1. 算法总览</h4>
<p>常见的排序算法有<strong>插入排序、选择排序、希尔排序、堆排序、冒泡排序、快速排序、归并排序和基数排序</strong>。常见排序算法可以分为两大类：</p>
<ul>
<li><strong>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破<code>O(nlogn)</code>，因此称为非线性时间比较类排序</strong>。</li>
<li><strong>线性时间非比较类排序：</strong>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。排序算法的时间复杂度如下： <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort.png" width="700"></li>
</ul>
<span id="more"></span>
<p><strong>算法的稳定性：</strong>稳定性就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。</p>
<ul>
<li><strong>稳定排序算法</strong>：冒泡排序、插入排序、归并排序、计数排序、桶排序与基数排序</li>
<li><strong>不稳定排序算法</strong>：希尔排序、选择排序、堆排序与快速排序</li>
</ul>
<p><strong>内部排序和外部排序：</strong>内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。上面所列举的都是内部排序。像多路归并可以采用外部排序</p>
<h5 id="插入排序">1.1 插入排序</h5>
<ul>
<li><strong>基本思想：</strong>每次将当前元素插入到左侧（有序区）已经排序的数组中，使得插入之后的左侧数组依然有序。
<ul>
<li>查找出元素要插入的位置：要插的元素与之前排好的子序比较</li>
<li>将要插入位置的元素及后面的元素后移一个位置</li>
<li>将元素插入</li>
</ul></li>
<li><p><strong>复杂度</strong>：插入排序一共需要两重循环，第一重循环确定需要加入有序序列的新元素，一共n-1轮，第二重循环确定新元素在原来有序序列中的位置，平均需要<code>n/4</code>轮可以确定位<code>O(n²)</code>,空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性：</strong>每次比较时遇到第一个小于等于新元素的元素，就将新元素插入到该元素的后面，即可不破坏相等元素的相对顺序，做到算法稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len== <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = cap[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; cap[j] &gt; tmp; j--)</span><br><span class="line">            cap[j + <span class="number">1</span>] = cap[j];</span><br><span class="line">        cap[j + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="希尔排序">1.2 希尔排序</h5>
<p>通过上面对插入排序程序的编写知道，插入排序适用于基本有序和数据量不大的排序表，<strong>希尔排序</strong>是基于这两点改进而来的。</p>
<ul>
<li><p><strong>基本思想</strong>：先将待排序表分割成若干形如 <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">L</span>[i,i+d,i+<span class="number">2</span>d……,i+kd]</span><br></pre></td></tr></table></figure> 既把步长相隔增量d的记录组成一个子表，对各个子表分别进行直接插入排序。当整个表的元素已呈<strong>“基本有序”</strong>时，再次对全体记录进行一次直接插入排序。一般来说，步长取<code>d=n/2</code>，之后都已<code>1/2</code>递减。</p>
<ul>
<li>1.取一步长<code>d1&lt;n</code>，把表中全部记录分发d组</li>
<li>2.所有距离为<code>d1</code>的倍数的记录放到一组。</li>
<li>3.在各组内进行直接插入排序</li>
<li>4.取第二个步长<code>d2&lt;d1</code>，重复上述过程，直到<code>d=1</code>。</li>
<li>5.<code>d=1</code>时，再进行一次直接插入排序</li>
</ul></li>
<li><p><strong>复杂度：</strong>希尔排序的时间复杂度会随着<code>d</code>选取策略的不同而发生变化，但是通常保持在<span class="math inline">\(O(n^{1.3})~O(n^{1.5})\)</span>;希尔排序依旧属于原地排序，不需要额外的空间，所以空间复杂度与插入排序一样为<code>O(1)</code></p></li>
<li><p><strong>稳定性：</strong>虽然插入排序是稳定的排序算法，但是希尔排序因为将序列进行了拆分再进行插入排序，如此不同组中的相等元素相对位置不能保证不变，所以相等元素的相对位置会发生改变，故时不稳定排序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/shellSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = len / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;len ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = cap[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; cap[j] &gt; tmp; j -= d)</span><br><span class="line">                cap[j + d] = cap[j];</span><br><span class="line">            cap[j + d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="选择排序">1.3 选择排序</h5>
<p>选择排序<code>Selection-sort</code>是一种简单直观的排序算法。它的</p>
<ul>
<li><p><strong>基本思想：</strong>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始（末尾）位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></li>
<li><p><strong>复杂度：</strong>选择排序一共需要比较<code>n-1</code>轮（每轮找到最小的元素进行交换），第<code>m</code>轮比较<code>n-m</code>次，所以比较的总次数为：$ _{i=0}^{n-1}n-i <span class="math inline">\(，即为\)</span>O(N^2)<span class="math inline">\(。选择排序不需要额外的空间，故其空间复杂度为\)</span>O(1)$</p></li>
<li><p><strong>稳定性：</strong>由于选择出的元素可能会进行跨越式的交换，所以会破坏原本的顺序，所以不稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//即使终止的选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size = cap.<span class="built_in">size</span>(); !sorted &amp;&amp; size &gt; <span class="number">1</span>; size--)</span><br><span class="line">    &#123;		<span class="comment">//每一轮size-1,最大的放在后面   </span></span><br><span class="line">        <span class="type">int</span> indexOfMax = <span class="number">0</span>;</span><br><span class="line">        sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap[indexOfMax] &lt; cap[i])		<span class="comment">//找出最大的值</span></span><br><span class="line">                indexOfMax = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sorted = <span class="literal">false</span>;	<span class="comment">//无序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Swap</span>(cap[indexOfMax], cap[size - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="冒泡排序">1.4 冒泡排序</h5>
<ul>
<li><p><strong>基本思想：</strong>从后往前（从前往后），两两比较相邻元素的值。若为逆序A[i]&lt;A[i-1]，则交换他们。每一轮将最大的放到后面（即每一次减少一次内循环）</p></li>
<li><p><strong>复杂度：</strong>冒泡排序一共需要比较<code>n-1</code>轮，第<code>m</code>轮比较<code>n-m</code>次，所以其比较总次数应为：<span class="math inline">\(\displaystyle\sum_{i=0}^{n-1}n-i\)</span>，故冒泡排序的时间复杂度为<code>O(n²)</code>。冒泡排序比较和交换的过程中不消耗额外的内存，故冒泡排序的空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性</strong>：比较时如果两个元素相等则不交换，即可做到使算法稳定 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有序时及时终止的冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(T&amp; cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cap.<span class="built_in">size</span>(); sorted &amp;&amp; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        sorted = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (cap[j] &gt; cap[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(cap[j], cap[j + <span class="number">1</span>]);</span><br><span class="line">                sorted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速排序">1.5 快速排序**</h5>
<ul>
<li><strong>基本思想</strong>：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。
<ul>
<li>1.选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</li>
<li>2.分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</li>
<li>3.递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</li>
</ul></li>
<li><p><strong>复杂度</strong>：<strong>快速排序的性能受到基准选择策略的影响</strong>，理论上如果每次选择基准都选择分区的第一个元素，那么这个序列越有序则时间复杂度越趋近于<code>O(n²)</code>，这是因为每次基准都是分区最大或最小的元素，那么左区间将会没有元素，而右区间将会有除了基准外的全部元素，这样就跟普通的插入排序没有区别了，<strong>因此对于快排会有优化措施</strong>。<strong>快速排序的最坏运行情况是<code>O(n²)</code>，比如说顺序数列的快排。但它的平摊期望时间是<code>O(nlogn)</code>，且<code>O(nlogn)</code> 记号中隐含的常数因子很小</strong>，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。<strong>快速排序可以实现原地排序，不需要消耗额外的内存，所以快速排序的空间复杂度为<code>O(1)</code>。</strong></p></li>
<li><p><strong>稳定性</strong>：快速排序不能保证相等元素的相对顺序不发生改变，所以不稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写自己的quickSort,没有优化，遇到最坏情况的时间复杂度会变成O(N*N)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--;</span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="快排优化">1.5.1 快排优化</h6>
<p>对于快排，其性能受到基准选择策略的影响，当出现下面两种情况时为最坏情况：</p>
<ul>
<li>在分解时每次选取的基准点为最小元素</li>
<li>在分解时每次选取的基准点为最大元素</li>
</ul>
<p>为了避免快排出现上述所说的最坏情况，选择哪一个元素作为基准点是关键，<strong>在快排过程中采用三点取中间值的优化方案。三数取中<code>median-of-three</code>指的是在挑选基准元素时，不是简单的选择数组中的第一个元素或最后一个，而是选取某三个元素，常选头、尾和中央三个元素，并且适用三个元素之中的中位数作为基准元素进行划分</strong>。这样即使在最坏的情况下将时间复杂度推进到<code>O(NlogN)</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化后的快排代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">medianOfThree</span>(a, first, (first + last) / <span class="number">2</span>, last);</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--; </span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cap[first] &lt; cap[mid])</span><br><span class="line">        <span class="keyword">if</span> (cap[first] &gt;= cap[last])	<span class="comment">//last=&lt;first&lt;mid</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&lt;mid&lt;last</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[mid];</span><br><span class="line">            cap[mid] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">// first&lt;last&lt;=mid</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[last];</span><br><span class="line">            cap[last] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[first] &lt; cap[last])	<span class="comment">//last&gt;first&gt;=mid</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&gt;=mid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[last];</span><br><span class="line">        cap[last] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[mid];</span><br><span class="line">        cap[mid] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.png" width="600"> 上图对优化后和优化前的快排进行了测试，很明显三数取中后对与升序和降序数组的时间得到了大大的改善，避免了最坏情况，逼近<code>O(NlogN)</code>,<strong>但是对于重复数组的优化还不能得到很好的改善，因此可以在三数取中的快排中加入以下的策略：</strong></p>
<ul>
<li><p>优化一：当待排序序列的长度分割到一定大小后，使用插入排序，这是因为对于很小部分大致有序的数组，快排不如插排效率。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</p></li>
<li><p>优化二：当待排序序列的长度分割到一定大小后如100个，使用计数排序，这样能够很明显的提升大量重复值情况下的效率</p></li>
</ul>
<h5 id="堆排序">1.6 堆排序*</h5>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个完全二叉树的结构，并同时满足堆的的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p>
<p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
<ul>
<li><strong>基本思想</strong>：
<ul>
<li><p><strong>插入：</strong>因为<strong>堆是完全二叉树，所以当加入一个元素形时，必须维持该堆仍为完全二叉树</strong>，即该新节点位置由此定下了肯定为叶子结点。接着元素插入要依据原来是大根堆还是小根堆（即不能破环该堆的性质）。把插入的元素，沿着从新节点到根节点的路径<code>i/2</code>，执行一趟冒泡操作，将新元素与其夫节点的元素比较交换，直到后者大于前者（大根堆为例）。</p></li>
<li><p><strong>删除：在大根堆中删除一个元素，其实就是删除根节点的元素</strong>。此时就需要重新组织，以便保持性质不变 。其策略是，从删除的位置开始为一个树,向下找，找到该树的最后一个叶子节点，删除该节点但保存元素到临时量；然后比较节点的左右孩子，将大的放到该根节点；这时因为大孩子的被放到根节点而成为了空(没有元素），以此类推，直到最后一个叶子我们与之前中间量保存的元素比较，完成删除排序，</p></li>
<li><p><strong>初始化：</strong>当堆刚开始时就要有n个元素，我们就要构建非空堆，我们需要在堆中执行n次插入操作。先将元素按层次插入，取位置在i=n/2的元素，如果以这个元素为根的子树是大根堆则不做操作，如果不是大根堆则从该节点开始的树进行检测替换，依次检查i-1,i-2……1</p></li>
</ul></li>
<li><p><strong>复杂度</strong>：堆排序的时间复杂度是标准的<code>O(nlogn)</code>。用数组实现堆的功能，故空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性</strong>：堆排序并不是进行线性的比较，而是根据堆的结构进行比较，所以在交换时会破坏相等元素原本的相对顺序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/heapSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆插入</span></span><br><span class="line"><span class="comment">该方法通过查询当前堆的大小和元素比较定位插入点，进行大根堆完全二叉树形式插入即`/2`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T&amp; heap,<span class="type">const</span> T&amp; theElement)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> currentNode=++heapsize;</span><br><span class="line">	<span class="comment">//通过比较寻找插入点，比插入值小的元素下沉</span></span><br><span class="line">	<span class="keyword">while</span>(currentNode!=<span class="number">1</span>&amp;&amp;heap[currentNode/<span class="number">2</span>]&lt;theElement)</span><br><span class="line">	&#123;</span><br><span class="line">		heap[currentNode]=heap[currentNode/<span class="number">2</span>];</span><br><span class="line">		currentNode/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入新值</span></span><br><span class="line">	heap[currenNode]=theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆删除</span></span><br><span class="line"><span class="function">templaet&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; heap)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(heapsize==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	heap[<span class="number">1</span>].~<span class="built_in">T</span>();		<span class="comment">//销毁根节点元素</span></span><br><span class="line">	T lastElement=heap[heapsize];	<span class="comment">//最后一个元素保存到临时变量</span></span><br><span class="line">	heap[heapsize--].~<span class="built_in">T</span>();			<span class="comment">//销毁最后一个元素</span></span><br><span class="line">	<span class="type">int</span> currentNode=<span class="number">1</span>,child=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;heapsize)</span><br><span class="line">	&#123;	<span class="comment">//元素进行上升</span></span><br><span class="line">		<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="comment">//判断lastElement是否可以放在heap[child]上</span></span><br><span class="line">		<span class="keyword">if</span>(lastElement&gt;=heap[child])	<span class="comment">//可以就直接退出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		heap[currentNode]=heap[child];</span><br><span class="line">		currentNode=child;</span><br><span class="line">		child*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currentNode]=lastElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(T&amp; Heap,std::<span class="type">size_t</span> _heapsize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	heapsize=_heapsize;</span><br><span class="line">	<span class="comment">//从下往上进行堆化，即从heapsize/2开始，直到root=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> root=heapsize/<span class="number">2</span>;root&gt;=<span class="number">1</span>;root--)</span><br><span class="line">	&#123;</span><br><span class="line">		T rootElement=heap[root];</span><br><span class="line">		<span class="type">int</span> child=<span class="number">2</span>*root;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;=heapsize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span>(rootElement&gt;=heap[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			heap[child/<span class="number">2</span>]=heap[child];</span><br><span class="line">			child*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[child/<span class="number">2</span>]=rootElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你也可以不用写堆排序，直接使用STL当中的<code>push_heap、pop_heap、make_heap</code>进行插入、删除和初始化一个堆。</p>
<h5 id="基数排序">1.7 基数排序*</h5>
<p>基数排序是一种<strong>非比较型整数排序算法</strong>，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<ul>
<li><strong>基本思想</strong>：基数排序排序主要通过将数字分解进行排序，如三位数的925，基数排序可通过十进制分解，将925分解成9、2、5三个数，然后依次以个位、十位、百位进行排序。<strong>在这个过程中，因为数字只有0~9,所有仅仅需要10个桶就，然后调用三次箱子排序即可</strong>：
<ul>
<li>1.将无序集合中的所有元素根据个位的大小分别分配到0-9十个桶中；</li>
<li>2.从个位为0的桶开始依据每个元素的十位将元素分配到0-9十个桶中；</li>
<li>3.每次依据的位数增加一位（百位，千位，万位），直到集合中最大的数的位数为止；</li>
<li>4.最后一次分配完成后从第0个桶开始依次取出元素，直到所有的元素被取出来，这个取出的顺序可以保证元素是从小到大的；</li>
</ul></li>
<li><p><strong>复杂度</strong>：每一次散列需要对每个元素进行分配，即n次操作，最多进行最大的数的位数轮散列分配，即k轮，所以时间复杂度为<code>O(n*k)</code>。基数排序需要<code>n+m</code>个额外空间，其中<code>n</code>为待排序集合大小，<code>m</code>为10（无负数元素）或<code>20</code>（有负数元素）</p></li>
<li><p><strong>稳定性</strong>：基数排序不会破坏相等元素的相对顺序，所以是稳定的 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/radixSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(T&amp; cap,<span class="type">int</span> place)</span> </span>&#123;	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,num=<span class="number">1</span>; i &lt; place; i++,num*=<span class="number">10</span>) &#123;<span class="comment">//num指示对哪一位进行基数排序</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">tempVec</span>(<span class="number">10</span>);<span class="comment">//二维数组，内部vector的大小看数据量 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cap.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = cap[i] / num % <span class="number">10</span>;</span><br><span class="line">            tempVec[index].<span class="built_in">push_back</span>(cap[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cap.<span class="built_in">clear</span>();		<span class="comment">//清除里面的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)		<span class="comment">//放回vec</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = tempVec[i].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (it != tempVec[i].<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cap.<span class="built_in">push_back</span>(*it);</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="归并排序">1.8 归并排序**</h5>
<ul>
<li><strong>基本思想</strong>：归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法<code>Divide and Conquer</code>的一个非常典型的应用。<strong>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序</strong>。若将两个有序表合并成一个有序表，称为二路归并。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：一是自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；二是自下而上的迭代；
<ul>
<li>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>4.重复步骤 3 直到某一指针达到序列尾；</li>
<li>5.将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul></li>
<li><p><strong>复杂度</strong>：很明显归并排序需要<code>logn</code>轮合并，每轮合并需要<code>n-1~n/2</code>次比较，所以时间复杂度为<code>O(nlogn)</code>.归并排序比较占用内存，但却是一种效率高且稳定的算法，其需要临时空间存储归并后的数据，因此空间复杂度为<code>O(N)</code></p></li>
<li><p><strong>稳定性</strong>：归并排序的合并操作并不会影响相同元素的相对顺序，故稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//使用迭代实现二路归并排序</span></span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(len);       <span class="comment">//合并空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)</span><br><span class="line">    &#123;   <span class="comment">//logn趟合并</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//合并相邻两子序列</span></span><br><span class="line">            <span class="type">int</span> next = j + i;</span><br><span class="line">            <span class="type">int</span> k = j;</span><br><span class="line">            <span class="keyword">while</span>(k &lt;(j+i) &amp;&amp; k&lt;len &amp;&amp; next &lt; len &amp;&amp; next &lt; (j+<span class="number">2</span>*i) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cap[k] &lt;= cap[next])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[index] = cap[k];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[index] = cap[next];</span><br><span class="line">                    next++;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k&lt;len &amp;&amp;k &lt; j + i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[index] = cap[k];</span><br><span class="line">                index++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (next &lt; len &amp;&amp; next &lt; j + <span class="number">2</span> * i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[index] = cap[next];</span><br><span class="line">                index++;</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            j = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), cap.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计数排序">1.9 计数排序</h5>
<ul>
<li><p><strong>基本思想：</strong>计数排序的核心在于<strong>将输入的数据值转化为键存储在额外开辟的数组空间中</strong>。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<strong>确定范围的整数</strong>。当输入的元素是<code>n</code>个0到k之间的整数时，它的运行时间是<code>Θ(n + k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。<strong><em>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量内存，因此堆数据范围很大的不适用，该排序算法最号应用于数据范围不大重复值多的情况</em></strong>。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>遍历数组<code>cap</code>，对值<code>i</code>作为cap的下标存入<code>+1</code>,即<code>C[i]++</code>;</li>
<li>对所有的重复值计数累加</li>
<li>从前往后遍历数组C，将对应的下标index作为值存人<code>cap</code>，并在<code>C[index]-1</code></li>
</ul></li>
<li><p><strong>复杂度</strong>：计数排序的时间复杂度与待排序元素的范围相关，其时间复杂度为<code>O(n+k)</code>,其中<code>n</code>为元素数量，<code>k</code>为元素的范围（即最大的元素与最小的元素的差加1）。计数排序需要额外开辟k个桶的空间，所以空间复杂度为<code>(k)</code>。</p></li>
<li><p><strong>稳定性</strong>：计数排序是一个非基于比较的线性时间排序算法,所以看出是一种稳定排序 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/countingSortgif.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxValue = <span class="built_in">getMaxValue</span>(cap)+<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(maxValue)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : cap)</span><br><span class="line">        tmp[i]++;</span><br><span class="line">    <span class="type">int</span> _index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxValue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (tmp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cap[_index] = i;</span><br><span class="line">            tmp[i]--;</span><br><span class="line">            _index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="桶排序">1.10 桶排序*</h5>
<ul>
<li><strong>基本思想</strong>：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：<strong>一是在额外空间充足的情况下，尽量增大桶的数量；二是使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</strong>。同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。
<ul>
<li>1.开辟m大小的空间，生成m个桶，每个桶对应一个范围；</li>
<li>2.将待排序的所有元素依次按照范围散列到对应的桶里；</li>
<li>3.对所有的桶内的元素以桶为单位排序；</li>
<li>4.从第一个桶开始依次将排好序的元素取出；</li>
</ul></li>
<li><p><strong>复杂度</strong>：对于待排序序列大小为<code>N</code>，共分为<code>M</code>个桶，<code>N</code>次循环，将每个元素装入对应的桶中。<code>M</code>次循环，对每个桶中的数据进行排序（平均每个桶有<code>N/M</code>个元素）。一般使用较为快速的排序算法，时间复杂度为 O(N/MlogN/M)，整个桶排序的时间复杂度为：<code>O(N)+O(M∗(N/M∗log(N/M))) = O(N)+O(N∗(log(N/M)) = O(N)+O(C）= O(N∗(log(N/M)+1))</code>；桶排序需要额外的m个桶的空间和n个元素的空间，故空间复杂度为<code>O(m+n)</code>。</p></li>
<li><p><strong>稳定性</strong>：桶排序的稳定性取决于桶内排序使用的算法，所以我们通常认为桶排序是稳定排序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bucketSort.png" width="400"></p></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="操作系统的基本概念">1 操作系统的基本概念</h3>
<ol type="1">
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li>操作系统本质上是一个运行在计算机上的<strong>软件程序</strong> ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li>操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 </strong>内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<h4 id="操作系统的内核kernel">操作系统的内核（Kernel）</h4>
<p>维基百科对于内核的解释： &gt;<strong>内核</strong>（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I/O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 <strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</strong></p>
<blockquote>
<p>早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!</p>
</blockquote>
<p><strong>简单概括两点：</strong></p>
<ul>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li>
<li>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</li>
</ul>
<h4 id="中央处理器cpucentral-processing-unit">中央处理器（CPU，Central Processing Unit）</h4>
<p>关于 CPU 简单概括三点：</p>
<ul>
<li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑</strong>。</li>
<li>** CPU 主要包括两个部分：控制器+运算器。**</li>
<li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li>
</ul>
<h4 id="cpu-vs-kernel内核">CPU vs Kernel(内核)</h4>
<p>可以简单从下面两点来区别：</p>
<ul>
<li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li>
<li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/操作系统概念.png" width="500"></li>
</ul>
<h3 id="操作系统的基本特性">2 操作系统的基本特性</h3>
<p>操作系统的基本特性是<strong>并发性、共享性、虚拟性、异步性。</strong></p>
<h4 id="并发性">并发性</h4>
<p><strong>并行性和并发性(Concurrence)是既相似又有区别的两个概念，</strong>并行性是指两个或多个事件在同一时刻发生；而并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。（宏观并发微观串行）</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h4 id="共享性">共享性</h4>
<p>指系统中的资源可供内存中多个并发执行的进程(线程)共同使用，相应地，把这种资源共同使用称为资源共享，或称为资源复用。目前主要实现资源共享的方式有：</p>
<ul>
<li>互斥共享方式</li>
<li>同时访问方式</li>
</ul>
<h5 id="互斥共享方式">互斥共享方式</h5>
<p>当一个进程 A 要访问某资源时，必须先提出请求。如果此时该资源空闲，系统便可将之分配给请求进程 A 使用。此后若再有其它进程也要访问该资源时(只要 A 未用完)，则必须等待。仅当 A 进程访问完并释放该资源后，才允许另一进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源，例如打印机。</p>
<h5 id="同时访问方式">同时访问方式</h5>
<p>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p>
<h4 id="虚拟性">虚拟性</h4>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：<strong>时（时间）分复用技术和空（空间）分复用技术。</strong></p>
<p><strong>多个进程能在同一个处理器上并发执行使用了时分复用技术</strong>，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p>虚拟内存使用了<strong>空分复用技术</strong>，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<h4 id="异步性">异步性</h4>
<p>在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。进程是以人们不可预知的速度向前推进，此即进程的异步性。</p>
<h3 id="操作系统的基本功能">3 操作系统的基本功能</h3>
<p>操作系统的基本功能包括<strong>进程管理、内存管理、文件管理、设备管理。</strong></p>
<ul>
<li><strong>进程管理</strong>：进程控制、进程同步、进程通信、死锁处理、处理机调度等</li>
<li><strong>内存管理</strong>：内存分配、地址映射、内存保护与共享、虚拟内存等</li>
<li><strong>文件管理</strong>：文件存储空间的管理、目录管理、文件读写管理和保护等</li>
<li><strong>设备管理</strong>：完成用户I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备管理、设备处理、虚拟设备等。</li>
</ul>
<h3 id="什么是系统调用用户态和系统态是">4 什么是系统调用/用户态和系统态是？</h3>
<p>根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：</p>
<ul>
<li>** 用户态(user mode) **: 用户态运行的进程或程序可以直接读取用户程序的数据。</li>
<li><strong>系统态(kernel mode)</strong>:可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ul>
<p>我们运行的程序基本都是运行在用户态，如果要调用操作系统提供的系统态级别的子功能，那就需要系统调用了！</p>
<p>也就是说在运行的用户程序中，<strong>凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</strong></p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/systemcall.png" width="600"></li>
</ul>
<h4 id="为什么要有用户态与内核态">为什么要有用户态与内核态?</h4>
<p><strong>在 cpu 的所有指令中，有些指令是非常危险的，如果使用不当，将会造成系统崩溃等后果。为了避免这种情况发生，cpu 将指令划分为特权级(内核态)指令和非特权级(用户态)指令。</strong></p>
<p><strong>对于那些危险的指令只允许内核及其相关模块调用，对于那些不会造成危险的指令，就允许用户应用程序调用。</strong></p>
<ul>
<li>内核态(核心态,特权态): 内核态是操作系统内核运行的模式。 内核态控制计算机的硬件资源，如硬件设备，文件系统等等，并为上层应用程序提供执行环境。</li>
<li>用户态: 用户态是用户应用程序运行的状态。 应用程序必须依托于内核态运行,因此用户态的操作权限比内核态是要低的，如磁盘，文件等，访问操作都是受限的。</li>
<li>系统调用: 系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。</li>
</ul>
<h4 id="用户态切换到内核态的几种方式">用户态切换到内核态的几种方式</h4>
<ul>
<li><strong>系统调用:</strong> 系统调用是用户态主动要求切换到内核态的一种方式，用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</li>
<li><strong>异常:</strong> 当 cpu 在执行用户态的应用程序时，发生了某些不可知的异常。于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</li>
<li><strong>硬件设备的中断:</strong> 当硬件设备完成用户请求后，会向 cpu 发出相应的中断信号，这时 cpu 会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序，如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核台的转换。</li>
</ul>
<h3 id="计算机的局部性原理">5 计算机的局部性原理</h3>
<p>一个编写良好的计算机程序常常具有良好的<strong>局部性</strong>，即他们更加倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用或的数据项本身，这种特性，常常称为<strong>局部性原理</strong>。局部性由两种不同的形式：<strong>时间局部性和空间局部性</strong></p>
<ul>
<li><strong>时间局部性</strong>：被引用过一次的内存位置很有可能在不久的将来再次被多次引用。</li>
<li><strong>空间局部性</strong>：一个内存被引用过了，那么极有可能在不久的将来会引用器附近的内存位置。在高速缓存中的表现形式是以<strong>数据块</strong>的形式进行缓存，弥补未命中时的惩罚</li>
</ul>
<p>我们应该理解局部性原理，因为一般而言，一个良好局部性的程序比局部性差的程序运行得更快，这是由现代计算机系统得设计结构所决定得，在现代计算系统得各个层次之哦你给，都引入了局部性原理：</p>
<ul>
<li>在硬件层，计算机设计者通过引入称为<strong>高速缓存存储器</strong>这样小而快得快速存储器来保存最近引用得指令和数据项，从而提高对主存得访问速度。</li>
<li>在操作系统中，系统使用主存作为<strong>虚拟地址空间</strong>，来存储最近被引用得数据项，来避免因从磁盘取数据过慢而导致CPU资源的浪费</li>
<li>类似的，用主存来缓存磁盘文件中最近被使用的磁盘块。</li>
<li>局部性原理在应用程序中也有应用，入<code>Web</code>浏览器将最近引用的文档放在本地磁盘上，利用的就是时间局部性。</li>
</ul>
<span id="more"></span>
<h3 id="磁盘调度算法">6 磁盘调度算法</h3>
<p>读写一个传统磁盘块的时间的影响因素有：</p>
<ul>
<li><strong>旋转时间</strong>（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li><strong>寻道时间</strong>（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li><strong>实际的数据传输时间</strong></li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h4 id="先来先服务">先来先服务</h4>
<p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h4 id="最短寻道时间优先">最短寻道时间优先</h4>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p><strong>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</strong></p>
<h4 id="电梯扫描算法">电梯扫描算法</h4>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<h3 id="进程线程和协程的区别和联系">7 进程、线程和协程的区别和联系</h3>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>比较点</th>
<th><strong>进程</strong></th>
<th><strong>线程</strong></th>
<th><strong>协程</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>定义</td>
<td>资源分配和拥有的基本单位</td>
<td>程序执行的基本单位</td>
<td>用户态的轻量级线程，线程内部调度的基本单位</td>
</tr>
<tr class="even">
<td>切换情况</td>
<td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td>
<td>保存和设置程序计数器、少量寄存器和栈的内容</td>
<td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td>
</tr>
<tr class="odd">
<td>切换者</td>
<td>操作系统</td>
<td>操作系统</td>
<td>用户</td>
</tr>
<tr class="even">
<td>切换过程</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态(没有陷入内核)</td>
</tr>
<tr class="odd">
<td>调用栈</td>
<td>内核栈</td>
<td>内核栈</td>
<td>用户栈</td>
</tr>
<tr class="even">
<td>拥有资源</td>
<td>CPU资源、内存资源、文件资源和句柄等</td>
<td>程序计数器、寄存器、栈和状态字</td>
<td>拥有自己的寄存器上下文和栈</td>
</tr>
<tr class="odd">
<td>并发性</td>
<td>不同进程之间切换实现并发，各自占有CPU实现并行</td>
<td>一个进程内部的多个线程并发执行</td>
<td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td>
</tr>
<tr class="even">
<td>系统开销</td>
<td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td>
<td>切换时只需保存和设置少量寄存器内容，因此开销很小</td>
<td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td>
</tr>
<tr class="odd">
<td>通信方面</td>
<td>进程间通信需要借助操作系统</td>
<td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td>
<td>共享内存、消息队列</td>
</tr>
</tbody>
</table>
<p>1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p>
<p>2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位</p>
<h4 id="线程和进程的区别">线程和进程的区别？</h4>
<ul>
<li><strong>进程</strong>：程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。程序是静态的，进程是动态的。是CPU分配资源的最小单位</li>
<li><strong>线程：</strong>线程（thread）是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。线程是CPU调度的最小单位</li>
</ul>
<p><strong>关系：</strong></p>
<ul>
<li>一个进程可有多个线程</li>
<li>进程间很难共享数据，线程很容易实现数据共享</li>
<li>进程比线程消耗更多的计算机资源</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉</li>
</ul>
<p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源，所以我们也说，进程是CPU分配资源的最小单位。</p>
<p>线程存在与进程当中(进程可以认为是线程的容器)，是操作系统调度执行的最小单位。说通俗点，线程就是干活的，轻量级进程。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。（是为避免进程fork()产生写时拷贝的不必要时间和内存支出）</p>
<ul>
<li><p>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</p></li>
<li><p>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</p></li>
<li><p>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</p></li>
<li><p>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构</p></li>
</ul>
<h4 id="协程">协程</h4>
<p><strong>协程本质上是一种用户态的轻量级线程，协程的调度完全由用户控制。</strong></p>
<p>传统意思上来说，线程分为<strong>内核态线程</strong>和<strong>用户态线程</strong>，<strong>用户态线程需要绑定内核态线程</strong>，CPU并不能感知用户态线程的存在，它只知道它在运行1个线程，这个线程实际是内核态线程。用户态线程实际有个名字就叫协程（co-routine），为了容易区分，使用协程指用户态线程，使用线程指内核态线程。</p>
<p>协程跟线程是有区别的，线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p>
<p>协程和线程有3种映射关系：</p>
<ul>
<li><code>N:1</code>，N个协程绑定1个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上，一是某个程序用不了硬件的多核加速能力，二是一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li>
<li><code>1:1</code>，1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，但有一个缺点是协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</li>
<li><code>M:N</code>，M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</li>
</ul>
<p><strong>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</strong></p>
<ul>
<li><strong>协程是属于线程的</strong>。协程程序是在线程里面跑的，因此协程又称微线程和纤程等</li>
<li>** 协程没有线程的上下文切换消耗**。协程的调度切换是用户(程序员)手动切换的，因此更加灵活,因此又叫用户空间线程.</li>
<li><strong>原子操作性</strong>。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁</li>
<li><p><strong>协程的优点：</strong></p></li>
<li>跨平台,跨体系架构</li>
<li>无需线程上下文切换的开销</li>
<li>无需原子操作锁定及同步的开销</li>
<li>方便切换控制流，简化编程模型</li>
<li><p>高并发+高扩展性+低成本：一个 CPU 支持上万的协程都不是问题。所以很适合用于高并发处理。</p></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无法利用多核资源：协程的本质是个单线程，它不能同时将单个 CPU 的多个核用上，协程需要和进程配合才能运行在多 CPU 上。当然我们日常所编写的绝大部分应用都没有这个必要，除非是 cpu 密集型应用。</li>
<li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序：这一点和事件驱动一样，可以使用异步IO操作来解决</li>
</ul>
<h3 id="一个进程可以创建多少线程和什么有关">8 一个进程可以创建多少线程，和什么有关？</h3>
<p>这个要分不同系统去看：</p>
<ul>
<li>如果是32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。</li>
<li>如果是64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。</li>
</ul>
<p>顺便多说一句，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响，无用线程要及时销毁</p>
<h3 id="外中断和异常有什么区别">9 外中断和异常有什么区别？</h3>
<ul>
<li><p>外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p></li>
<li><p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p></li>
</ul>
<h3 id="进程线程模型你知道多少">10 进程线程模型你知道多少？</h3>
<p>对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单</p>
<h4 id="多线程">多线程</h4>
<p>我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量<code>int i = 10</code>，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。</p>
<p>我们必须知道，<strong>做一次简单的<code>i = i + 1</code>在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，</strong>而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p>
<p>但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。</p>
<p>比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p>
<p>对于线程，我认为弄清以下两点非常重要：</p>
<ul>
<li><p>线程之间有无先后访问顺序（线程依赖关系）</p></li>
<li><p>多个线程共享访问同一变量（同步互斥问题）</p></li>
</ul>
<p>另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的<code>tid</code>，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。</p>
<p>而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p>
<p>线程相关接口不少，主要需要了解各个参数意义和返回值意义。</p>
<p><strong>1.线程创建和结束</strong></p>
<ul>
<li>背景知识：</li>
</ul>
<p>在一个文件内的多个函数通常都是按照<code>main</code>函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在<code>main</code>函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照<code>main</code>函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。</p>
<ul>
<li><p>相关接口：</p>
<ul>
<li><p>创建线程：<code>int pthread_create(pthread_t *tidp,const pthread_attr_t *attr, void *(start_rtn)(void),void *arg)</code>;创建一个新线程，<code>pthread和start_routine</code>不可或缺，分别用于标识线程和执行体入口，其他可以填<code>NULL</code>。</p>
<ul>
<li><p><code>pthread</code>：用来返回线程的tid，<code>*pthread</code>值即为tid，类型<code>pthread_t == unsigned long int</code>。</p></li>
<li><p><code>attr</code>：指向线程属性结构体的指针，用于改变所创线程的属性，填<code>NULL</code>使用默认值。</p></li>
<li><p><code>start_routine</code>：线程执行函数的首地址，传入函数指针。</p></li>
<li><p><code>arg：</code>通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。</p></li>
</ul></li>
<li><p>获得线程ID：<code>pthread_t pthread_self();</code>.。调用时，会打印线程<code>ID</code>。</p></li>
</ul></li>
<li>等待线程结束：<code>int pthread_join(pthread_t tid, void** retval);</code>主线程调用，等待子线程退出并回收其资源，类似于进程中<code>wait/waitpid</code>回收僵尸进程，调用<code>pthread_join</code>的线程会被阻塞。
<ul>
<li><p><code>tid</code>：创建线程时通过指针得到<code>tid</code>值。</p></li>
<li><p><code>retval</code>：指向返回值的指针。</p></li>
</ul></li>
<li><p>结束线程：<code>pthread_exit(void *retval);</code>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过<code>pthread_join</code>获得。</p>
<ul>
<li><code>retval：</code>同上。</li>
</ul></li>
<li><p>分离线程：<code>int pthread_detach(pthread_t tid);</code>主线程、子线程均可调用。主线程中<code>pthread_detach(tid)</code>，子线程中<code>pthread_detach(pthread_self())</code>，调用后和主线程分离，子线程结束时自己立即回收资源。</p>
<ul>
<li>tid：同上。</li>
</ul></li>
</ul>
<p><strong>2.线程属性值修改</strong></p>
<ul>
<li><p>背景知识：线程属性对象类型为<code>pthread_attr_t</code>，结构体定义如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> detachstate;    <span class="comment">// 线程分离的状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy;    <span class="comment">// 线程调度策略</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> schedparam;    <span class="comment">// 线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched;    <span class="comment">// 线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope;    <span class="comment">// 线程的作用域</span></span><br><span class="line">    <span class="comment">// 以下为线程栈的设置</span></span><br><span class="line">    <span class="type">size_t</span> guardsize;    <span class="comment">// 线程栈末尾警戒缓冲大小</span></span><br><span class="line">    <span class="type">int</span> stackaddr_set;    <span class="comment">// 线程的栈设置</span></span><br><span class="line">    <span class="type">void</span> *    stackaddr;    <span class="comment">// 线程栈的位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize;    <span class="comment">// 线程栈大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>相关接口：对上述结构体中各参数大多有：<code>pthread_attr_get()</code>和<code>pthread_attr_set()</code>系统调用函数来设置和获取。这里不一一罗列。</p></li>
</ul>
<h4 id="多进程">多进程</h4>
<p>每一个进程是资源分配的基本单位。</p>
<p><strong>进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。</strong></p>
<p><strong>实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。</strong></p>
<p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过<strong>写时复制机制</strong>将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。</p>
<p>如果子进程想要运行自己的代码段，还可以通过调用<code>execv()</code>函数重新加载新的代码段，之后就和父进程独立开了。</p>
<p>我们在shell中执行程序就是通过shell进程先<code>fork()</code>一个子进程再通过<code>execv()</code>重新加载新的代码段的过程。</p>
<p><strong>1.进程创建与结束</strong></p>
<ul>
<li><p>背景知识：进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：<code>0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程</code>。所以我们在命令行中通过 <code>./program</code>执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。</p></li>
<li>相关接口：
<ul>
<li>创建进程：<code>pid_t fork(void);</code>
<ul>
<li>返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid == 0</li>
</ul></li>
<li>结束进程：<code>void exit(int status);</code>
<ul>
<li><code>status</code>是退出状态，保存在全局变量中S?，通常0表示正常退出。</li>
</ul></li>
<li><p>获得PID：<code>pid_t getpid(void);</code>返回调用者pid。</p></li>
<li><p>获得父进程PID：<code>pid_t getppid(void)</code>;返回父进程pid。</p></li>
</ul></li>
<li><p>其他补充：</p>
<ul>
<li>正常退出方式：<code>exit()、_exit()、return（在main中）</code>。</li>
<li><p><code>exit()</code>和<code>_exit()</code>区别：<code>exit()</code>是对<code>__exit()</code>的封装，都会终止进程并做相关收尾工作，最主要的区别是<code>_exit()</code>函数关闭全部描述符和清理函数后不会刷新流，但是<code>exit()</code>会在调用<code>_exit()</code>函数前刷新数据流。</p></li>
<li><p><code>return</code>和<code>exit()</code>区别：<code>exit()</code>是函数，但有参数，执行完之后控制权交给系统。<code>return</code>若是在调用函数中，执行完之后控制权交给调用进程，若是在<code>main</code>函数中，控制权交给系统。</p></li>
<li><p>异常退出方式：<code>abort()</code>、终止信号。</p></li>
</ul></li>
</ul>
<p><strong>2.Linux进程控制</strong></p>
<ul>
<li><p><strong>进程地址空间（地址空间）</strong> 虚拟存储器为每个进程提供了独占系统地址空间的假象。</p>
<p>尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。</p>
<p>有一些&quot;敏感&quot;的地址需要注意下，对于32位进程来说，代码段从<code>0x08048000</code>开始。从<code>0xC0000000</code>开始到<code>0xFFFFFFFF</code>是内核地址空间，通常情况下代码运行在用户态（使用<code>0x00000000 ~ 0xC00000000</code>的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。</p>
<p>也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。</p></li>
<li><p><strong>进程控制块（处理机）进程</strong>：的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。</p></li>
<li><p><strong>上下文切换</strong> 内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。</p>
<p>进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。</p>
<p>一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p></li>
</ul>
<h3 id="进程调度算法你了解多少">11 进程调度算法你了解多少？</h3>
<h4 id="先来先服务-first-come-first-serverdfcfs">先来先服务 first-come first-serverd（FCFS）</h4>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p><strong>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</strong></p>
<h4 id="短作业优先-shortest-job-firstsjf">短作业优先 shortest job first（SJF）</h4>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</p>
<h4 id="最短剩余时间优先-shortest-remaining-time-nextsrtn">最短剩余时间优先 shortest remaining time next（SRTN）</h4>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p>
<p>如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h4 id="时间片轮转">时间片轮转</h4>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。</p>
<p>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/timeP.png" width="500"></li>
</ul>
<h4 id="优先级调度">优先级调度</h4>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h4 id="多级反馈队列">多级反馈队列</h4>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 <code>1,2,4,8,..。</code>进程在第一个队列没执行完，就会被移到下一个队列。</p>
<p>这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/manyque.png" width="600"></p>
<h3 id="进程状态的切换">12 进程状态的切换</h3>
<p><strong>进程的三种基本状态</strong></p>
<ul>
<li><strong>就绪状态</strong>：当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li>
<li><strong>执行状态</strong>：进程已获得 CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</li>
<li><strong>阻塞状态</strong>：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。致使进程阻塞的典型事件有：请求 I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而把处于阻塞状态的进程排成多个队列。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/进程状态切换.png" width="600"></li>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h3 id="linux下进程间通信方式">13 Linux下进程间通信方式？</h3>
<ul>
<li><p><strong>管道：</strong></p>
<ul>
<li><p><strong>无名管道（内存文件）</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</p></li>
<li><p><strong>有名管道（FIFO文件，借助文件系统）</strong>：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</p></li>
</ul></li>
<li><p><strong>共享内存：</strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</p></li>
<li><p><strong>消息队列：</strong>消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li>
<li><p><strong>套接字</strong>：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</p></li>
<li><p><strong>信号：</strong>用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</p></li>
<li><p><strong>信号量：</strong>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问</p></li>
</ul>
<h3 id="linux下同步机制">14 Linux下同步机制？</h3>
<ul>
<li><p><code>POSIX</code>信号量：可用于进程同步，也可用于线程同步。</p></li>
<li><p><code>POSIX</code>互斥锁 + 条件变量：只能用于线程同步</p></li>
</ul>
<h3 id="如果系统中具有快表tlb后那么地址的转换过程变成什么样了">15 如果系统中具有快表(<code>tlb</code>)后，那么地址的转换过程变成什么样了？</h3>
<p>块表其实与缓存存储结构的功能是一样的，只不过<code>TLB</code>缓存的是<strong>页表条目信息</strong>。在没有<code>tlb</code>时，当CPU产生一个虚拟地址，送到<strong>内存管理单元</strong>后，为能够进行地址转换，必须先向主存内的页表请求对应的<strong>页表条目</strong>，在主存中找到页表条目后返回给MMU处理，之后MMU通过<strong>虚拟地址</strong>和相应的<strong>页表条目</strong>生成物理地址，用该物理地址再次去内存取相应的数据，可见在没有<code>tlb</code>的时候，地址转换过程中要两次访问主存，一次是为了获得页表信息来生成物理地址，另一次是通过生成的物理地址来获得数据</p>
<p>有了<code>tlb</code>缓存后，得益于计算机的局部性设计，将会大大减少从主存中获取页表信息的几率，这样</p>
<blockquote>
<p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p>
</blockquote>
<blockquote>
<p>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
</blockquote>
<blockquote>
<p>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</p>
</blockquote>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，–般来说快表的命中率可以达到90%以上。</p>
<p>例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问- -次快表耗时1us， 访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?<code>(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us</code>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是<code>(1+100) * 0.9+ (100+100) *0.1=110.9 us</code> 若未采用快表机制，则访问一个逻辑地址需要<code>100+100 = 200us</code> 显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>
<h3 id="动态分区分配算法有哪几种可以分别说说吗">16 动态分区分配算法有哪几种？可以分别说说吗？</h3>
<h4 id="首次适应算法">1 首次适应算法</h4>
<p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p>
<p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/first.png" width="700"></p>
<h4 id="最佳适应算法">2 最佳适应算法</h4>
<p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p>
<p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/good.png" width="700"></p>
<h4 id="最坏适应算法">3 最坏适应算法</h4>
<p>又称最大适应算法(<code>Largest Fit</code>)</p>
<p>算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/big.png" width="700"></p>
<h4 id="邻近适应算法">4 邻近适应算法</h4>
<p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>
<p>如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/near.png" width="700"></p>
<h4 id="总结">5 总结</h4>
<p>首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p>
<p>最佳导致大量碎片，最坏导致没有大的空间。</p>
<p>进过实验，首次适应比最佳适应要好，他们都比最坏好。</p>
<table style="width:96%;">
<colgroup>
<col style="width: 5%">
<col style="width: 19%">
<col style="width: 19%">
<col style="width: 22%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>算法</th>
<th>算法思想</th>
<th>分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>首次适应</td>
<td>从头到尾找适合的分区</td>
<td><strong>空闲分区以地址递增次序排列 </strong></td>
<td>综合看性能最好。<strong>算法开销小</strong>，回收分区后一般不需要对空闲分区队列重新排序</td>
<td></td>
</tr>
<tr class="even">
<td>最佳适应</td>
<td>优先使用更小的分区，以保留更多大分区</td>
<td>空闲分区以容量递增次序排列</td>
<td>会有更多的大分区被保留下来，更能满足大进程需求</td>
<td>会产生很多太小的、难以利用的碎片;<strong>算法开销大</strong>，回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr class="odd">
<td>最坏适应</td>
<td>优先使用更大的分区，以防止产生太小的不可用的碎片</td>
<td>空闲分区以容量递减次序排列</td>
<td>可以减少难以利用的小碎片</td>
<td>大分区容易被用完，不利于大进程<strong>;算法开销大</strong>(原因同上)</td>
</tr>
<tr class="even">
<td>邻近适应</td>
<td>由首次适应演变而来，每次从上次查找结束位置开始查找</td>
<td>空闲分区以地址递增次序排列(可排列成循环链表)</td>
<td>不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong>(原因同首次适应算法)</td>
<td>会使高地址的大分区也被用完</td>
</tr>
</tbody>
</table>
<h3 id="外部碎片和内部碎片">17 外部碎片和内部碎片</h3>
<p>造成堆利用率低的主要原因是一种称为内存碎片的现象，当虽然有未使用的内存但不能用来满足分配请求时，就会发送这种现象。有两种形式的碎片：<strong>内部碎片和外部碎片</strong></p>
<ul>
<li><p><strong>内部碎片：</strong>内部碎片是在一个已分配块比有实际需要的有效载荷大时发生的。比如计算机的内存对齐机制，虽然实际需要1字节存储，但分配器会分配<code>4</code>或者<code>8</code>字节的块来存储。因此，内部碎片是由计算机本身所造成的，我们只能通过改变变量顺序使得内部碎片尽可能小。<strong>外部碎片的量化也是极为简单，就是已分配快大小和有效载荷之间的差的和</strong></p></li>
<li><p><strong>外部碎片</strong>：外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以满足这个请求块。</p></li>
</ul>
<h3 id="虚拟技术你了解吗">18 虚拟技术你了解吗</h3>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：<strong>时（时间）分复用技术和空（空间）分复用技术。</strong></p>
<p><strong>多进程与多线程</strong>：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p><strong>虚拟内存使用了空分复用技术</strong>，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中</p>
<h3 id="一个cc程序从开始编译到生成可执行文件的完整过程你能说出来多少">19 一个C/C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？</h3>
<p>四个过程：</p>
<ul>
<li><p>（1）<strong>预编译 </strong>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<ul>
<li><p>1、删除所有的#define，展开所有的宏定义。</p></li>
<li><p>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p></li>
<li><p>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。</p></li>
<li><p>4、删除所有的注释，“//”和“/**/”。</p></li>
<li><p>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。</p></li>
<li><p>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</p></li>
</ul></li>
<li><p>（2）<strong>编译</strong> 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<ul>
<li><p>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p></li>
<li><p>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p></li>
<li><p>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p></li>
<li><p>4、优化：源代码级别的一个优化过程。</p></li>
<li><p>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p></li>
<li><p>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p></li>
</ul></li>
<li><p>（3）<strong>汇编</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。</p>
<p>经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。</p></li>
<li><p>（4）链接</p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<ul>
<li>1、<strong>静态链接：</strong> 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li>
</ul>
<p><strong>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</strong></p>
<ul>
<li>2、<strong>动态链接：</strong> 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</li>
</ul>
<p><strong>共享库：</strong>就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失</p></li>
</ul>
<h3 id="操作系统在对内存进行管理的时候需要做些什么">20 操作系统在对内存进行管理的时候需要做些什么?</h3>
<ul>
<li>操作系统负责内存空间的分配与回收。（虚拟内存的堆）</li>
<li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。（虚拟内存）</li>
<li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。（虚拟内存）</li>
<li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰（虚拟内存）</li>
</ul>
<h3 id="进程间通信有哪几种方式">21 进程间通信有哪几种方式</h3>
<p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>细节</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>管道(pipe)</strong></td>
<td>允许一个进程和另一个与它有共同祖先的进程之间进行通信</td>
</tr>
<tr class="even">
<td><strong>命名管道(FIFO)</strong></td>
<td>类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令<code>mkfifo</code>或系统调用<code>mkfifo</code>来创建</td>
</tr>
<tr class="odd">
<td><strong>消息队列(MQ)</strong></td>
<td>消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。<strong>消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点</strong>；</td>
</tr>
<tr class="even">
<td><strong>信号量(semaphore)</strong></td>
<td>信号量主要作为进程间以及同进程不同线程之间的同步手段；</td>
</tr>
<tr class="odd">
<td><strong>共享内存(shared memory)</strong></td>
<td>它使得多个进程可以访问同一块内存空间，<strong>是最快的可用IPC形式。</strong>这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥</td>
</tr>
<tr class="even">
<td><strong>信号(signal)</strong></td>
<td>信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身</td>
</tr>
<tr class="odd">
<td><strong>内存映射(mapped memory)</strong></td>
<td>内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它</td>
</tr>
<tr class="even">
<td><strong>Socket</strong></td>
<td>它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信</td>
</tr>
</tbody>
</table>
<p>进程间通信主要包括管<strong>道、系统IPC（包括消息队列、信号量、信号、共享内存等）</strong>、以及套接字<code>socket</code>。</p>
<p><strong>1.管道</strong>：</p>
<p>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p>
<p><strong>1.1 普通管道PIPE：</strong></p>
<ul>
<li><p>1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p></li>
<li><p>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p></li>
<li><p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p></li>
</ul>
<p><strong>1.2 命名管道FIFO</strong>：</p>
<ul>
<li><p>1)FIFO可以在无关的进程之间交换数据</p></li>
<li><p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中，严格遵守先进先出原则。</p></li>
</ul>
<ol start="2" type="1">
<li>系统IPC：</li>
</ol>
<p><strong>2.1 消息队列</strong></p>
<p><strong>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</strong></p>
<p><strong>特点</strong>：</p>
<ul>
<li><p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p></li>
<li><p>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p></li>
<li><p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p></li>
</ul>
<p><strong>2.2 信号量<code>semaphore</code></strong></p>
<p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<p>特点：</p>
<ul>
<li><p>1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p></li>
<li><p>2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p></li>
<li><p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p></li>
<li><p>4)支持信号量组。</p></li>
</ul>
<p><strong>2.3 信号<code>signal</code></strong></p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p><strong>2.4 共享内存（Shared Memory）</strong></p>
<p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p>
<p>特点：</p>
<ul>
<li><p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p></li>
<li><p>2)因为多个进程可以同时操作，所以需要进行同步</p></li>
<li><p>3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p></li>
</ul>
<p><strong>3.套接字SOCKET</strong>：</p>
<p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p>
<h3 id="虚拟内存是什么作用">22 虚拟内存是什么、作用</h3>
<p>在概念上，<strong>虚拟内存是指存放在磁盘上的N字节大小的内存区域，</strong>每个字节都要相应的虚拟地址，作为寻址索引。<strong>和存储结构的缓存一样，磁盘的数据也被分割成块，在这类为做区别称之为虚拟页，每个虚拟页大小由计算机系统决定为<span class="math inline">\(P=2^p\)</span></strong>，与之对应的是物理页，其大小也应该为<code>P</code>。<strong>可以理解它是一种映射，由虚拟内存映射到真实物理内存上，这样在有限的内存上可以运行更多的程序。</strong></p>
<p>在任何时刻，我们都不能实际真实一股脑的为进程分配全部的存储空间，因此虚拟页面分为三个不相交的子集：</p>
<ul>
<li><strong>未分配的：</strong>VM系统还没有分配的页，此时未分配的块没有任何数据和它们管理，因此此时不会占有任何磁盘空间</li>
<li><strong>缓存的</strong>：当前缓存的虚拟页在占有磁盘中的空间，当然由于缓存到内存。内存当中也会占有一定内存空间</li>
<li><strong>维缓存的</strong>：在磁盘中占用空间，但并未缓存在内存中，当然不占用内存(此时当CPU要寻址该页当中一个数据时，由于未缓存在内存中，就会造成<strong>缺页异常</strong>。) <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/VP.png" width="700"></li>
</ul>
<h4 id="作用">作用</h4>
<ul>
<li>虚拟内存是作为缓存的工具，如<code>L1\L2\L3</code>作为主存的缓存，那么虚拟内存是作为主存与磁盘之间缓存的工具</li>
<li><p>虚拟内存的目的是为了让物理内存扩充成为更大的逻辑内存，从而让程序获得更多的可用内存。</p></li>
<li><p>更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。</p></li>
<li><p><strong>简化了链接，</strong>独立的地址空间允许每个进程的内存映像使用相同的格式，且都是相同的虚拟起始地址,只要保证虚拟内存地址得顺序就可以，而不用管代码和数据实际存放在物理内存的何处。</p></li>
<li><p>当程序引用到不在物理内存中的页时，产生缺页中断，将缺失的部分装入物理内存并重新执行失败的指令。可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p></li>
<li><p>提供了内存保护功能，每个进程的必须在自己的存储空间运行，虚拟内存起到了这个作用，虽然在逻辑地址上它们运行是在同一位置上，但通过地址转换成物理地址后，每个进程都有自己的真实物理地址。</p></li>
</ul>
<p>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<h3 id="几种典型的锁">23 几种典型的锁</h3>
<h4 id="读写锁">读写锁</h4>
<ul>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ul>
<h4 id="互斥锁">互斥锁</h4>
<p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
<p>互斥锁属于sleep-waiting类型的锁，互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，<strong>而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换</strong>。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>
<h4 id="条件变量">条件变量</h4>
<p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</p>
<h4 id="自旋锁">自旋锁</h4>
<p>自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。</p>
<p>虽然它的效率比互斥锁高，但是它也有些不足之处：</p>
<ul>
<li><p>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</p></li>
<li><p>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</p></li>
<li><p>自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</p></li>
</ul>
<h3 id="死锁产生的必要条件">24 死锁产生的必要条件</h3>
<ul>
<li><strong>互斥条件：</strong>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。</li>
<li><strong>请求和保持条件：</strong>指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li><strong>不可抢占条件：</strong>指进程已获得的资源，在未使用完之前，不能被剥夺抢占，只能在使用完时由自己释放。</li>
<li><strong>循环等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合<code>&#123;P0，P1，P2，…，Pn&#125;</code>中的<code>P0</code>正在等待一个<code>P1</code>占用的资源；<code>P1</code>正在等待 <code>P2</code>占用的资源，……，<code>Pn</code>正在等待已被P0占用的资源。</li>
</ul>
<h3 id="处理死锁的基本方法">处理死锁的基本方法</h3>
<p><strong>主要有以下五种方法：</strong></p>
<ul>
<li><strong>鸵鸟策略</strong></li>
<li><strong>预防死锁</strong>：该方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而可能会导致系统资源利用率和系统吞吐量降低。</li>
<li><strong>避免死锁</strong>：是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。这种方法只需事先施加较弱的限制条件，便可获得较高的资源利用率及系统吞吐量，但实现难度较高。</li>
<li><strong>检测死锁</strong>：是允许系统在运行过程中发生死锁，但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源； 然后，采取适当措施，从系统中将已发生的死锁清除掉。</li>
<li>** 解除死锁**：与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤消或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</li>
</ul>
<h4 id="鸵鸟策略">鸵鸟策略</h4>
<p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p><strong>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</strong></p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h4 id="预防死锁">预防死锁</h4>
<p>预防死锁的方法是使四个必要条件中的第<code>2、3、4</code>个条件之一不能成立，来避免发生死锁。至于必要<code>条件 1</code>，因为它是由设备的固有特性所决定的，不仅不能改变，还应加以保证。</p>
<h5 id="摒弃请求和保持条件">摒弃“请求和保持”条件</h5>
<p>在采用这种方法时，<strong>系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。</strong></p>
<ul>
<li>优点：简单、易于实现且很安全</li>
<li>缺点：资源严重浪费，恶化了系统资源的利用率；造成使进程延迟运行</li>
</ul>
<h5 id="摒弃不可抢占条件">摒弃不可抢占条件</h5>
<p>在采用这种方法时系统规定，进程是逐个地提出对资源的要求的。<strong>当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请</strong>。这意味着某一进程已经占有的资源，在运行过程中会被暂时地释放掉，也可认为是被剥夺了，从而摒弃了“不剥夺”条件。</p>
<ul>
<li><strong>缺点</strong>：实现起来比较复杂且要付出很大的代价。一个资源在使用一 段时间后，它的被迫释放可能会造成前段工作的失效，即使是采取了某些防范措施，也还会使进程前后两次运行的信息不连续。此外，这种策略还可能因为反复地申请和释放资源，致使进程的执行被无限地推迟，这不仅延长了进程的周转时间，而且也增加了系统开销，降低了系统吞吐量。</li>
</ul>
<h5 id="摒弃环路等待条件">摒弃“环路等待”条件</h5>
<p><strong>这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。</strong></p>
<ul>
<li><strong>缺点</strong>：是为系统中各类资源所分配(确定)的序号必须相对稳定，这就限制了新类型设备的增加；作业(进程)使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费；这种按规定次序申请的方法，必然会限制用户简单、自主地编程。</li>
</ul>
<h4 id="避免死锁">避免死锁</h4>
<p><strong>所谓安全状态，是指系统能按某种进程顺序<code>(P1，P2，…，Pn)</code>(称<code>〈P1，P2，…，Pn〉</code>序列为安全序列)，来为每个进程<code>Pi</code>分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</strong></p>
<p>并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便有可能进而进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。<strong>因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态。</strong> <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/安全状态.png" width="700"> 图 a 的第二列 <code>Has</code>表示已拥有的资源数，第三列<code>Max</code>表示总共需要的资源数，<code>Free</code> 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时<code>Free</code> 变为 5（图 c）；接着以同样的方式运行 <code>C</code>和<code>A</code>，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<blockquote>
<p>预防死锁和避免死锁这两种方法实质上都是通过施加某些限制条件，来预防发生死锁。两者的主要差别在于：为预防死锁所施加的限制条件较严格，这往往会影响进程的并发执行；而为避免死锁所施加的限制条件则较宽松，这给进程的运行提供了较宽松的环境，有利于进程的并发执行。</p>
</blockquote>
<h5 id="利用银行家算法避免死锁">利用银行家算法避免死锁</h5>
<p><strong>基本思想：</strong></p>
<ul>
<li>在每个新进程进入系统时，他必须声明在运行过程中，可能需要的每种资源类型的最大单元数目（数目不超过系统拥有的资源总量）。</li>
<li><strong>当进程请求一组资源时，系统必须首先在确定是否有足够的资源分配给该进程。</strong></li>
<li>若有，<strong>在进一步计算将这些资源分配给进程后，是否会使系统处于不安全状态。如果处于安全状态，才将资源分配给他；否则，让进程等待。</strong></li>
</ul>
<p><strong>银行家算法中的数据结构</strong>:</p>
<ul>
<li><strong>可利用资源向量<code>Available</code>：</strong>是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 <code>Available[j]=K</code>，则表示系统中现有<code>Rj</code>类资源<code>K</code>个。</li>
<li><strong>最大需求矩阵Max：</strong>是一个 <code>n×m</code>的矩阵，它定义了系统中 <code>n</code>个进程中的每一个进程对<code>m</code>类资源的最大需求。如果<code>Max[i,j]</code>=K，则表示进程<code>i</code>需要<code>Rj</code>类资源的最大数目为<code>K</code>。</li>
<li><strong>分配矩阵<code>Allocation</code>：</strong>是一个 <code>n×m</code>的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果<code>Allocation[i,j]=K</code>，则表示进程<code>i</code>当前已分得Rj类资源的数目为<code>K</code>。</li>
<li><strong>需求矩阵<code>Need</code>：</strong>是一个<code>n×m</code>的矩阵，用以表示每一个进程尚需的各类资源数。如果<code>Need[i,j]=K</code>，则表示进程<code>i</code>还需要<code>Rj</code>类资源<code>K</code> 个，方能完成其任务。</li>
</ul>
<blockquote>
<p><code>Need[i, j]=Max[i, j]-Allocation[i, j]</code></p>
</blockquote>
<p><strong>银行家算法</strong>:</p>
<p>设<code>Request i</code>是进程<code>Pi</code>的请求向量，如果<code>Request i[j]=K</code>，表示进程<code>Pi</code>需要<code>K</code> 个 <code>R j</code>类型的资源。当<code>Pi</code>发出资源请求后，系统按下述步骤进行检查：</p>
<ol type="1">
<li>如果<code>Request i[j]≤Need[i,j]</code>，便转向步骤<code>(2)</code>；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</li>
<li>如果<code>Requesti[j]≤Available[j]</code>，便转向步骤<code>(3)</code>；否则，表示尚无足够资源，Pi须等待。</li>
<li>系统试探着把资源分配给进程 <code>P i</code>，并修改下面数据结构中的数值： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Available[j]= Available[j]-Request i[j];</span><br><span class="line">Allocation[i,j] = Allocation[i,j]+Request i[j];</span><br><span class="line">Need[i,j] = Need[i,j]-Request i[j];</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>系统执行<strong>安全性算法</strong>，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程 Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程<code>Pi</code>等待。</li>
</ul>
<p><strong>安全性算法</strong>: 系统所执行的安全性算法可描述如下：</p>
<ol type="1">
<li>设置两个向量：
<ul>
<li>工作向量<code>work：</code>它表示系统可提供给进程继续运行所需的各类资源数目，它含有<code>m</code>个元素，在执行安全算法开始时，<code>Work=Available</code>。</li>
<li><code>Finish</code>：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做<code>Finish[i]=false；</code>当有足够资源分配给进程时，再令<code>Finish[i]=true。</code></li>
</ul></li>
<li>从进程集合中找到一个能满足下述条件的进程：
<ul>
<li><code>Finish[i]=false;</code></li>
<li><code>Need[i,j]≤Work[j];</code>若找到，执行步骤3，否则，执行步骤4。</li>
</ul></li>
<li>当进程<code>Pi</code>获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Work[j] = Work[j]+Allocation[i,j];</span><br><span class="line">Finish[i] = <span class="literal">true</span>;</span><br><span class="line">go to step <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li>如果所有进程的<code>Finish[i]=true</code>都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</li>
</ol>
<blockquote>
<p>缺点：每一次分配都要执行安全性算法，得到所有的Finish都是true，效率会有一定牺牲，但牺牲&lt;效益</p>
</blockquote>
<h4 id="检测死锁">检测死锁</h4>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/资源分配图.png" width="700"> 上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p><strong>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</strong></p>
<h5 id="每种类型多个资源的死锁检测">每种类型多个资源的死锁检测</h5>
<p><img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/多个资源的死锁检测.png" width="700"> 上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol type="1">
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<blockquote>
<p>就是拓扑排序思想</p>
</blockquote>
<h4 id="死锁解除">死锁解除</h4>
<p>当发现有进程死锁时，便应立即把它们从死锁状态中解脱出来。常采用解除死锁的两种方法是：</p>
<ul>
<li><strong>剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。</strong></li>
<li><strong>撤消进程。最简单的撤消进程的方法是使全部死锁进程都夭折掉；稍微温和一点的方法是按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为止。</strong></li>
</ul>
<h3 id="内存的覆盖是什么有什么特点">25 内存的覆盖是什么？有什么特点？</h3>
<p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</p>
<p>覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。</p>
<h3 id="内存交换是什么有什么特点">26 内存交换是什么？有什么特点？</h3>
<ul>
<li><p><strong>交换(对换)技术的设计思想：</strong>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p></li>
<li>换入：把准备好竞争CPU运行的程序从辅存移到内存。</li>
<li><p>换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。</p></li>
</ul>
<h3 id="操作系统的页表寻址">27 操作系统的页表寻址</h3>
<p>虚拟内存系统必须以某种方法来判断一个虚拟页是否在主存DRAM上，如果在，还必须确定在DRAM的哪个位置。若不命中，触发<strong>缺页异常</strong>，还必须知道它在磁盘的哪个位置，同时还必须用页调度算法在物理内存中牺牲一个页进行替换。</p>
<p>上述的功能由软硬件共同结合作用，包括操作系统软件、MMU和重要的数据结构——页表。页表上是虚拟地址和物理页的关系，它常驻在主存上。每次地址翻译硬件将一个虚拟地址转为物理地址时，都会读取页表。页表的结构如下，页表就是页表条目PTE数组。简而言之，页表是为了配合计算机的虚拟内存而设计出来的数据结构。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/PTE.png" width="500"></p>
<p><strong>页表寻址命中过程</strong>：</p>
<ul>
<li>当CPU为了获取内存当中位于某个页面内某个位置的数据，它会产生一个虚拟地址<code>VA</code>，把它送给MMU</li>
<li>第二步：MMU用<code>VA</code>去高速缓存/主存获得<code>PTE</code>页表条目</li>
<li>第三步：高速缓存/主存向MMU返回一个PTE</li>
<li>第四步：MMU利用PTE和VA构造物理地址，并把它传送给主存</li>
<li>第五步：高数缓存/主存返回所请求的的数据给处理器</li>
</ul>
<p><img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/aimed.png" width="700"> 其中的物理地址构造如图所示，虚拟地址的后<code>p</code>位作为该页偏移地址，<code>PTE</code>内存储相应的物理页号，因此将它们拼接就可以得到真正的物理地址。</p>
<h3 id="页表未命中缺页会发生什么">28 页表未命中，缺页会发生什么？</h3>
<p>此时若CPU要使用<code>VP3</code>该页中某块的某个数据，由于主存并没有缓存该物理页，因此页表的<code>PTE</code>有效位为<code>0</code>，就会触发缺页异常，执行缺页处理程序，进行页面调度替换后再返回原来执行的指令<span class="math inline">\(I_{cur}\)</span>重新执行该虚拟的地址上的数据请求。<strong>在缺页异常处理程序，该程序会选择一个牺牲页作为替换<code>VP3</code>,假如选择了<code>VP4</code>作为替换页，若<code>VP4</code>修改了，那么内核执行写回操作，将他复制回磁盘。</strong></p>
<ul>
<li><strong>步骤：</strong>
<ul>
<li>第一步和第三步：与上述一样</li>
<li>第四步：PTE的有效位是零，所以MMU回触发缺页异常，传递给CPU中的控制到操作系统内核中的缺页异常处理程序。</li>
<li>第五步：缺页异常处理程序确定物理内存的牺牲页，如果这个页面已经被修改，则把它换出到磁盘</li>
<li>第六步：缺页异常处理程序调入新的页面，并且更新页表对应的<code>PTE</code></li>
<li>第七步：缺页异常处理程序返回到原来的进程，再次执行导致缺页的指令。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/miss.png" width="700"></li>
</ul></li>
</ul>
<h3 id="页表也会占用内存计算机是怎么设计">29 页表也会占用内存，计算机是怎么设计。</h3>
<p>上面讨论的都是单级页表的情况，对于单级页表，无论是否分配，我们都要维护PTE,试想一下<code>32位</code>系统，页面大小是<code>4KB</code>和一个<code>4</code>字节的PTE，那么在内存中总需要用<span class="math inline">\(4GB/4KB*4byte=4MB\)</span>的页表，对于64位来说更加复杂。内存是计算机很稀缺的资源，我们当然不希望内存因为存储页表而耗费太多的内存，<strong>虚拟内存并不是所有都会分配使用，因此多级页表利用这个特性解决这个问题的。</strong></p>
<p>多级页表中，第一级页表正常分配<code>1024</code>个PTE，但其中许多<code>PTE</code>都是未分配的即<code>null</code>，那么二级页表就不会去生成它们的二级页表，这样就大大节约了空间。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/manyLevel.png" width="700"> 上图中只占用了内存<span class="math inline">\(1024*4Byte*4=16KB\)</span></p>
<h3 id="页面置换算法">30 页面置换算法</h3>
<h4 id="最佳置换法opt">1 最佳置换法(OPT)</h4>
<p><strong>最佳置换算法(OPT，Optimal) :</strong>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OPT.png" width="700"> 最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的</p>
<h4 id="先进先出置换算法fifo">2 先进先出置换算法(FIFO)</h4>
<p>先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FIFO.png" width="700"> - <strong>Belady异常：</strong>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</p>
<blockquote>
<p>只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p>
</blockquote>
<blockquote>
<p>FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p>
</blockquote>
<h4 id="最近最久未使用置换算法lru">3最近最久未使用置换算法(LRU)</h4>
<ul>
<li>最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面</li>
<li>实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LRU.png" width="700"> LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。</li>
</ul>
<h4 id="时钟置换算法clock">4 时钟置换算法(CLOCK)</h4>
<p>最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p>
<p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。</p>
<p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)</p>
<ul>
<li><strong>简单的CLOCK算法实现方法:</strong>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第1轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描) <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CLOCK.png" width="700"></li>
</ul>
<h4 id="改进型的时钟置换算法">5 改进型的时钟置换算法</h4>
<p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p>
<p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。<code>修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。</code></p>
<p>为方便讨论，用<code>(访问位，修改位)</code>的形式表示各页面状态。如<code>(1, 1)</code>表示一个页面近期被访问过，且被修改过。</p>
<p>改进型的Clock算法需要综合考虑某一内存页面的访问位和修改位来判断是否置换该页面。在实际编写算法过程中，同样可以用一个等长的整型数组来标识每个内存块的修改状态。访问位A和修改位M可以组成一下四种类型的页面。</p>
<p><strong>算法规则：</strong>将所有可能被置换的页面排成一个循环队列</p>
<ul>
<li><p><strong>第一轮：</strong>从当前位置开始扫描到第一个<code>(A =0, M = 0)</code>的页用于替换。表示该页面最近既未被访问，又未被修改，是最佳淘汰页（第一优先级）</p></li>
<li><p><strong>第二轮：</strong>若第一轮扫描失败，则重新扫描，查找第一个<code>(A =0, M = 1)</code>的帧用于替换。本轮扫描会将访问位置<code>0</code>。本轮目的是寻找表示该页面最近未被访问，但被修改的页面，并不是很好的淘汰页。（第二）</p></li>
<li><p><strong>第三轮：</strong>若第二轮扫描失败，则重新扫描，查找第一个<code>(A =0, M = 0)</code>的帧用于替换。本轮扫描不修改任何标志位。表示该页面最近被访问，但未修改。（第三优先级）</p></li>
<li><p><strong>第四轮：</strong>若第三轮扫描失败，则重新扫描，查找第一个<code>(0, 1)</code>的帧用于替换。表示最近被访问，且已被修改的页面（最坏情况） <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pCLOCK.png" width="700"></p></li>
</ul>
<h4 id="总结-1">6 总结</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">算法规则</th>
<th style="text-align: left;">优缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>OPT</code></td>
<td style="text-align: left;">优先淘汰最长时间内不会被访问的页面</td>
<td style="text-align: left;">缺页率最小，性能最好;但无法实现</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FIFO</code></td>
<td style="text-align: left;">优先淘汰最先进入内存的页面</td>
<td style="text-align: left;">实现简单;但性能很差，可能出现Belady异常</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>LRU</code></td>
<td style="text-align: left;">优先淘汰最近最久没访问的页面</td>
<td style="text-align: left;">性能很好;但需要硬件支持，算法开销大</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>CLOCK (NRU)</code></td>
<td style="text-align: left;">最多两轮</td>
<td style="text-align: left;">实现简单，算法开销小;但未考虑页面是否被修改过。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>改进型CLOCK (改进型NRU)</code></td>
<td style="text-align: left;">若用(访问位，修改位)的形式表述，最多四轮</td>
<td style="text-align: left;">算法开销较小，性能也不错</td>
</tr>
</tbody>
</table>
<h3 id="linux中异常和中断的区别">31 Linux中异常和中断的区别</h3>
<h4 id="中断">中断</h4>
<p>大家都知道，当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。下面这张图显示了中断处理的流程：</p>
<h4 id="异常">异常</h4>
<p>CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。所以，大家也需要记住的是，异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常，下面这张图显示了异常处理的流程：</p>
<ul>
<li>相同点
<ul>
<li><p>最后都是由CPU发送给内核，由内核去处理</p></li>
<li><p>处理程序的流程设计上是相似的</p></li>
</ul></li>
<li>不同点
<ul>
<li>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的</li>
<li>内核需要根据是异常还是中断调用不同的处理程序</li>
<li>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</li>
<li>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</li>
</ul></li>
</ul>
<h3 id="上下文切换是什么">32 上下文切换是什么</h3>
<p>上下文切换（Context Switch）是操作系统中的一种机制，用于在多任务环境下，从一个任务（进程或线程）切换到另一个任务时保存和恢复任务的执行环境和状态。</p>
<p>在多任务操作系统中，同时存在多个任务需要并发执行。<strong>每个任务都有自己的执行上下文，包括寄存器状态、程序计数器（PC）值、栈指针、打开的文件、内存映射等</strong>。当操作系统需要切换当前正在执行的任务到另一个任务时，就需要进行上下文切换。</p>
<p><strong>上下文切换的过程包括以下步骤：</strong></p>
<ul>
<li><p>保存当前任务的上下文：操作系统会保存当前任务的寄存器状态、PC值、堆栈指针等信息，并将其保存在任务的上下文数据结构中，以便在之后能够正确地恢复任务的执行状态。</p></li>
<li><p>恢复目标任务的上下文：操作系统会从目标任务的上下文数据结构中读取保存的上下文信息，并将寄存器状态、PC值、堆栈指针等恢复到目标任务的执行状态。</p></li>
<li><p>切换执行：一旦目标任务的上下文恢复完毕，操作系统会将控制权切换到目标任务，开始执行目标任务的代码。</p></li>
</ul>
<p><strong>上下文切换的目的是实现任务的并发执行和共享CPU资源。通过在任务之间进行快速而有效的上下文切换，操作系统可以在有限的处理器资源下，实现多任务的轮转调度或优先级调度，以满足不同任务的执行需求。</strong></p>
<p>上下文切换的开销是一个重要的考量因素。切换过程中，<strong>需要保存和恢复大量的寄存器状态和其他执行环境，还可能涉及内存管理和页表切换等操作，这会带来一定的开销</strong>。因此，在设计操作系统调度算法时需要综合考虑上下文切换的成本和任务切换的频率，以实现高效的任务调度和系统性能。</p>
<h3 id="中断上下文和异常上下文">33 中断上下文和异常上下文</h3>
<p><strong>中断上下文（Interrupt Context）</strong>和<strong>异常上下文（Exception Context）</strong>是指在处理中断和异常时所处的执行环境和状态。</p>
<ul>
<li><p>中断上下文是指在处理硬件中断时保存的处理器状态和相关信息。当硬件设备触发中断时，处理器会立即中断当前执行的程序，保存当前的上下文信息，包括寄存器状态、程序计数器（PC）值、栈指针等。然后，处理器会切换到中断处理程序，执行相应的中断处理逻辑。中断上下文通常是由硬件和操作系统共同管理的，以确保在中断处理程序执行期间，中断不会干扰到正在运行的程序或任务。</p></li>
<li><p>异常上下文是指在处理异常时保存的处理器状态和相关信息。当程序执行过程中发生异常（如除零错误、非法内存访问等），处理器会立即中断当前执行的程序，保存当前的上下文信息，包括寄存器状态、程序计数器（PC）值、栈指针等。然后，处理器会将控制转移到异常处理程序，根据异常类型执行相应的处理逻辑。异常上下文通常是由操作系统提供的异常处理机制管理的，以确保在异常处理程序执行期间能够正确处理异常情况，并继续执行程序或采取适当的措施。</p></li>
</ul>
<p><strong>区别在于触发机制和处理方式：</strong></p>
<ul>
<li>中断是由外部设备或信号触发，可以是硬件中断或软件中断。中断上下文用于处理设备的输入输出操作或请求系统服务。</li>
<li>异常是由程序执行过程中的错误或特殊情况触发，可以是硬件异常或软件异常。异常上下文用于处理程序执行过程中的错误或异常情况</li>
</ul>
<h3 id="内核抢占和非内核抢占">34 内核抢占和非内核抢占</h3>
<p>内核抢占（Kernel Preemption）和非内核抢占（Non-Kernel Preemption）是操作系统中的两种不同的调度机制。</p>
<ul>
<li><p>内核抢占指的是当一个进程或线程正在执行内核态（kernel mode）代码时，如果有更高优先级的任务需要执行，操作系统会强制暂停当前内核态的执行，切换到更高优先级的任务执行。这种机制允许操作系统及时响应紧急的任务或事件，保证系统的可靠性和实时性。内核抢占通常需要硬件支持，例如通过定时器中断或外部中断信号来触发内核抢占。</p></li>
<li><p>非内核抢占是指当一个进程或线程正在执行用户态（user mode）代码时，如果有更高优先级的任务需要执行，操作系统会暂停当前用户态的执行，切换到更高优先级的任务。非内核抢占是由操作系统自身实现的，通常基于时间片轮转或优先级调度等算法来决定任务的切换时机。非内核抢占可以提高系统的响应性能，<strong>但也可能导致一些问题，如上下文切换开销过大、竞争条件等。</strong></p></li>
</ul>
<p>总的来说，内核抢占和非内核抢占都是为了实现多任务调度和提高系统的性能和可靠性。内核抢占在内核态代码执行期间也能被中断，而非内核抢占只在用户态代码执行期间进行切换。</p>
<h3 id="守护进程孤儿进程和僵尸进程">35 守护进程、孤儿进程和僵尸进程</h3>
<h4 id="守护进程">守护进程</h4>
<p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等</p>
<h4 id="孤儿进程">孤儿进程</h4>
<p>如果父进程先退出，子进程还没退出，那么子进程此时就成为孤儿进程，孤儿进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作</p>
<h4 id="僵尸进程">僵尸进程</h4>
<p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为<strong>僵尸进程。</strong></p>
<p>设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用<code>wait</code>或<code>waitpid</code>时就可以得到这些信息。</p>
<p>因此对于僵尸进程，父进程必须进行回收，否则会消耗系统资源，比如进程ID</p>
<h3 id="如何避免僵尸进程">36 如何避免僵尸进程?</h3>
<ul>
<li><p>通过<code>signal(SIGCHLD, SIG_IGN)</code>通知内核对子进程的结束不关心，由内核回收,此时子进程是由<code>init()</code>进程管理和回收。</p></li>
<li><p>父进程调用<code>wait/waitpid</code>等函数等待子进程结束，如果尚无子进程退出<code>wait</code>会导致父进程阻塞。<code>waitpid</code>可以通过传递<code>WNOHANG</code>使父进程不阻塞立即返回。</p></li>
<li><p>如果父进程很忙不要阻塞，可以用<code>signal</code>注册信号处理函数，在信号处理函数调用<code>wait/waitpid</code>等待子进程退出。</p></li>
<li><p>通过两次调用<code>fork</code>。父进程首先调用<code>fork</code>创建一个子进程然后<code>waitpid</code>等待子进程退出，子进程再<code>fork</code>一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由<code>init</code>进程接管，孙进程结束后，<code>init会</code>等待回收。</p></li>
</ul>
<h3 id="计算机大小端">37 计算机大小端</h3>
<p>对于跨域多字节的程序对象，必须有两个规则：</p>
<ul>
<li>这个对象的地址是什么：在几乎所有的机器上，多字节对象都被存储为连续的字节序列，<strong>对象的地址为所使用字节中最小的地址。</strong></li>
<li>这个对象在内存中是如何排列这些字节的：排列ijie有两个通用的规则，一个是大端(网络字节序)，一个是小端(主机序);<strong>大端字节序在内存中按从最高有效位到最低有效位存储；而小端字节序在内存中按照从最低有效位到最高有效位存储</strong>
<ul>
<li>现有一个int型变量，位于初始地址为<code>0x100</code>，它的十六进制值为<code>0x01234567</code>，则大小端存储如下： <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/bigsmall.png" width="700"></li>
</ul></li>
</ul>
<p>如何区分计算机是大端存储还是小端存储： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>* byte_pointer;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start,size_tlen)</span></span>&#123;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%2.x &quot;</span>,start[i]);	<span class="comment">//%2.x表示整数必须用两个16进制输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">0x123456</span>;</span><br><span class="line"><span class="built_in">show_bytes</span>((byte_pointer)&amp;a,<span class="built_in">seziof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure> 输出 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">56</span> <span class="number">34</span> <span class="number">12</span> <span class="number">00</span></span><br></pre></td></tr></table></figure> 观察输出可知本计算机使用小端法存储数据</p>
<h3 id="线程回收方式">38 线程回收方式</h3>
<ul>
<li><code>pthread_join</code>阻塞方式回收：主线程调用，等待子线程退出并回收其资源，类似于进程中<code>wait/waitpid</code>回收僵尸进程，调用的线程会被阻塞。</li>
<li><code>pthread_detach</code>非阻塞形式回收：主线程、子线程均可调用。主线程中<code>pthread_detach(tid)</code>，子线程中<code>pthread_detach(pthread_self())</code>，调用后和主线程分离，子线程结束时自己立即回收资源。</li>
</ul>
<h3 id="linux环境下的内存分布">39 Linux环境下的内存分布</h3>
<p><img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/memoryList.png" width="700"> 过这张图你可以看到，用户空间内存，从低到高分别是 7 种不同的内存段：</p>
<ul>
<li>代码段<code>.txt</code>：程序文件段，包括二进制可执行代码；</li>
<li>已初始化数据段<code>.data</code>：又细分为只读数据段和读写数据段，存储全局变量、静态变量；</li>
<li>未初始化数据段<code>.bss</code>：它存储所有被初始化为0或者未初始化的静态变量，这些为初始化的变量在程序启动时被自动初始化为0。</li>
<li>堆段：包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段：包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</li>
<li>栈段：包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<h3 id="在linuxwindows平台下栈空间的大小">40 在Linux/windows平台下栈空间的大小</h3>
<ul>
<li>Linux环境下有操作系统决定，一般是<code>8MB，8192KB</code>，通过<code>ulimit -a</code>命令查看,通过<code>ulimit -s</code>修改 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:~$ ulimit -a</span><br><span class="line">real-time non-<span class="function">blocking <span class="title">time</span>  <span class="params">(microseconds, -R)</span> unlimited</span></span><br><span class="line"><span class="function">core file <span class="title">size</span>              <span class="params">(blocks, -c)</span> 0</span></span><br><span class="line"><span class="function">data seg <span class="title">size</span>               <span class="params">(kbytes, -d)</span> unlimited</span></span><br><span class="line"><span class="function">scheduling <span class="title">priority</span>                 <span class="params">(-e)</span> 0</span></span><br><span class="line"><span class="function">file <span class="title">size</span>                   <span class="params">(blocks, -f)</span> unlimited</span></span><br><span class="line"><span class="function">pending <span class="title">signals</span>                     <span class="params">(-i)</span> 15393</span></span><br><span class="line"><span class="function">max locked <span class="title">memory</span>           <span class="params">(kbytes, -l)</span> 64</span></span><br><span class="line"><span class="function">max memory <span class="title">size</span>             <span class="params">(kbytes, -m)</span> unlimited</span></span><br><span class="line"><span class="function">open <span class="title">files</span>                          <span class="params">(-n)</span> 1024</span></span><br><span class="line"><span class="function">pipe <span class="title">size</span>                <span class="params">(<span class="number">512</span> bytes, -p)</span> 8</span></span><br><span class="line"><span class="function">POSIX message <span class="title">queues</span>         <span class="params">(bytes, -q)</span> 819200</span></span><br><span class="line"><span class="function">real-time <span class="title">priority</span>                  <span class="params">(-r)</span> 0</span></span><br><span class="line"><span class="function">stack <span class="title">size</span>                  <span class="params">(kbytes, -s)</span> 8192</span></span><br><span class="line"><span class="function">cpu <span class="title">time</span>                   <span class="params">(seconds, -t)</span> unlimited</span></span><br><span class="line"><span class="function">max user <span class="title">processes</span>                  <span class="params">(-u)</span> 15393</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">memory</span>              <span class="params">(kbytes, -v)</span> unlimited</span></span><br><span class="line"><span class="function">file <span class="title">locks</span>                          <span class="params">(-x)</span> unlimited</span></span><br></pre></td></tr></table></figure></li>
<li>Windows环境下由编译器决定，VC++6.0一般是1M</li>
</ul>
<h3 id="程序从堆中动态分配内存时虚拟内存上怎么操作的">41 程序从堆中动态分配内存时，虚拟内存上怎么操作的</h3>
<p><strong>页表：</strong>是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系</p>
<p>在进行动态内存分配时，例如<code>malloc()</code>函数或者其他高级语言中的<code>new</code>关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目<code>（PTE）</code>，使该<code>PTE</code>指向硬盘上这个新创建的虚拟页），通过<code>PTE</code>建立虚拟页和物理页的映射关系。</p>
<h3 id="抖动你知道是什么吗它也叫颠簸现象">42 抖动你知道是什么吗？它也叫颠簸现象</h3>
<p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的实际内存物理块不够)</p>
<p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率 为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程工作集” 的概念</p>
<h3 id="什么是进程工作集">43 什么是进程工作集</h3>
<h3 id="从堆和栈上建立对象哪个快">44 从堆和栈上建立对象哪个快？</h3>
<p>栈比较快，从两方面来考虑：</p>
<ul>
<li><p><strong>分配和释放，</strong>堆在分配和释放时都要调用函数（malloc,free)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看malloc和free的源代码，函数做了很多额外的工作，而栈却不需要这些。</p></li>
<li><p><strong>访问时间</strong>，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次，栈常驻内存中。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的</p></li>
</ul>
<h3 id="常见的内存错误">45 常见的内存错误</h3>
<ul>
<li><p>内存分配未成功，却使用了它。</p>
<p>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为<code>NULL</code>。如果指针p是函数的参数，那么在函数的入口处用<code>assert(p!=NULL)</code>进行检查。如果是用<code>malloc</code>或<code>new</code>来申请内存，应该用<code>if(p==NULL)</code> 或<code>if(p!=NULL)</code>进行防错处理。</p></li>
<li><p>内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</p></li>
<li><p>内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</p></li>
<li><p>忘记了释放内存，造成内存泄露。</p>
<p>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中<code>malloc</code>与<code>free</code>的使用次数一定要相同，否则肯定有错误（<code>new/delete</code>同理）。</p></li>
<li><p>释放了内存却继续使用它。常见于以下有三种情况：</p>
<ul>
<li><p>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</p></li>
<li><p>函数的<code>return</code>语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</p></li>
<li><p>使用<code>free</code>或<code>delete</code>释放了内存后，没有将指针设置为<code>NULL</code>。导致产生“野指针”。</p></li>
</ul></li>
</ul>
<h3 id="内存交换中被换出的进程保存在哪里">46 内存交换中，被换出的进程保存在哪里？</h3>
<p><strong>保存在磁盘中，也就是外存中</strong>。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。</p>
<h3 id="五种io模型">47 五种IO模型</h3>
<h3 id="fork操作原理">48 fork操作原理</h3>
<h3 id="linux常用命令">49 Linux常用命令</h3>
<p>见<a href="https://trluper.cn/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">Linux常用命令</a></p>
<h3 id="生成者-消费者模型">50 生成者-消费者模型</h3>
<h3 id="经典同步问题">51 经典同步问题</h3>
<h4 id="读者写者问题">读者—写者问题</h4>
<h4 id="哲学家进餐问题">哲学家进餐问题</h4>
<p>文章参考来源 &gt;<a href="https://github.com/forthespada/InterviewGuide/tree/main">InterviewGuide</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>CUM15-445数据库原理</title>
    <url>/2023/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>数据库原理</category>
      </categories>
      <tags>
        <tag>数据库原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统_导论</title>
    <url>/2023/02/28/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="学习本书的目的">1 学习本书的目的</h3>
<p>计算机系统由硬件和系统软件组成。<strong>本书是推荐给哪些希望深入了解这些组件如何工作，以及这些组件是如何影响程序正确性和性能，以此来提高自身技能的读者</strong>。学完本书，你将知道：</p>
<ul>
<li>如何避免由计算机表示数字的方式引起的奇怪的数字错误(第二章：信息的表示和处理)</li>
<li>学会一些小窍门来优化自己的C代码，以充分利用现代处理器和存储器系统的设计</li>
<li><strong>你将了解编译器是如何实现过程调用的</strong></li>
<li><strong>如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞</strong></li>
<li><strong>将学会如何识别和避免链接时那些令人讨厌的错误(第七章：链接)</strong></li>
<li><strong>学会如何编写自己的Unix shell、自己的动态存储分配包、自己的web服务器</strong></li>
<li>并发带来的希望和陷阱</li>
</ul>
<span id="more"></span>
<h3 id="信息就是位上下文">2. 信息就是位+上下文</h3>
<p><code>hello</code>程序的生命周期是从一个源程序开始的，源程序实际上由值<code>0</code>和<code>1``组成的位序列，</code>8`位为一个字节。在现代计算机系统中，大部分都使用ASCII码来表示文本字符：</p>
<p><img src="/2023/02/28/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AF%BC%E8%AE%BA/inform.png" width="600"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面的<code>hello.c</code>程序就是以字节序列方式存储在文件的，每个字节都有一个整数值，对应于某些字符，如<code>#</code>对应35；像<code>hello.c</code>这样只由ASCII字符构成的文件<strong>为文本文件</strong>，其他文件则称为<strong>二进制文件</strong></p>
<p><strong>系统中的所有信息:磁盘文件、内存中的程序都由一串比特表示，区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文，比如在不同上下文，一个同样字节序可能表示一整数、浮点数、字符串等。</strong></p>
<h3 id="程序被其他程序翻译成不同格式">3. 程序被其他程序翻译成不同格式</h3>
<p><strong><code>hello</code>程序的生命周期是从一个源程序开始的，是因为这样才能被人读懂；然而计算机世界里，只有<code>01</code>，因此每条C语句都必须被其他程序转化为低级机器语言指令</strong>，然后这些指令按照一种可执行目标程序打包，以二进制磁盘文件形式存放(可执行文件)。</p>
<p>在Unix中，从源程序到可执行文件由<strong>编译驱动程序完</strong>成: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure> <img src="/2023/02/28/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AF%BC%E8%AE%BA/compile.png" width="600"></p>
<ul>
<li><p><strong>预处理阶段</strong>：在这个阶段预处理器(cpp)根据字符<code>#</code>开头命令进行头文件展开、宏替换和除去注释等工作，修改原始的C程序。如<code>#include&lt;stdio.h&gt;</code>命令告诉预处理器读取系统头文件<code>stdio.h</code>的内容，并把它直接插入程序文本中</p></li>
<li><p><strong>编译阶段</strong>：编译器(ccl)将文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>。</p></li>
<li><p><strong>汇编阶段</strong>：汇编器将<code>hello.s</code>翻译成机器语言指令，并把这些指令打包成一种叫做<strong>可重定位目标程序</strong>，并保存在目标文件<code>hello.o</code></p></li>
<li><strong>链接阶段</strong>：<code>hello</code>程序调用了<code>printf</code>函数，它是每个C编译器都提供的标准C库的一个函数，这个函数存在于一个名为<code>printf.o</code>的单独编译好的目标文件中，而这个文件必须合并到我们的<code>hello.o</code>程序中。链接就是负责这种合并。
<ul>
<li>你可能会问为什么不在预处理的时候就以<code>#include</code>导入展开？这是因为性能优化的问题，一个文件从预处理到编译再到汇编会消耗一定的时间资源，如果有现成已经预编译好的目标文件，使用它而不是<code>#include</code>将会节约这些不必要的时间</li>
</ul></li>
</ul>
<blockquote>
<p>理解链接时出现的错误。根据经验，一些令人困扰的程序往往都与链接器有关，如<strong>无法解析一个引用</strong>。 避免安全漏洞，缓冲区溢出错误常发生在大多数网络和Internet服务器上。</p>
</blockquote>
<h3 id="系统的硬件组成">4. 系统的硬件组成</h3>
<p>为例理解程序的运行过程，我们必须知道一些典型系统的硬件知识： <img src="/2023/02/28/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AF%BC%E8%AE%BA/computer.png" width="600"></p>
<ul>
<li><p><strong>总线</strong>：贯穿整个系统的一组电子管道，称为总线，它携带信息并负责在各个部件间传递</p></li>
<li><p><strong>I/O设备</strong>：I/O设备时系统与外部世界的联系通道，主要有<strong>磁盘、鼠标、键盘和显示器</strong></p></li>
<li><p><strong>主存</strong>：一个零时存储设备，在处理执行程序时，用来存放程序和程序处理的数据</p></li>
<li><strong>处理器</strong>：CPU，是执行存储在主存指令的引擎。处理器核心是一个大小为一个子的存储设备即寄存器，称为<strong>程序计数器<code>PC</code></strong>,在任何时候，PC都指向主存中某条机器语言指令地址。处理器从程序计数器指向的内存读取指令，解释指令的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令。
<ul>
<li>CPU的操作围绕主存、寄存器文件和算术/逻辑单元（ALU)进行
<ul>
<li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容</li>
<li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖原来的内容</li>
<li>操作：从两个寄存器的内容复制到ALU，ALU对这两个字做算术处理，并将结果存放到一个寄存器中</li>
<li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器PC中，以覆盖PC原来的值</li>
</ul></li>
</ul></li>
</ul>
<h3 id="高速缓存">5. 高速缓存</h3>
<p>上面的系统硬件组成中我们明白，系统会花费大量的时间把信息从一个地方搬到另一个地方，就比如<code>hello</code>可执行程序：</p>
<ul>
<li>首先我们要在shell兼容<code>./hello</code>,此时通过USB控制器经过总线到达CPU、从CPU再到主存</li>
<li>此时主存并没有<code>hello</code>文件的映射，就会去磁盘找并映射加载</li>
<li><p>加载到主存后，处理器开始执行hello程序的机器语言程序，这些指令将<code>hello, world\n</code>字符串的字节从主存复制到寄存器文件，再从寄存器文件复制到显示设备 <img src="/2023/02/28/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AF%BC%E8%AE%BA/cache.png" width="600"> <strong>较大的存储设备比较小的存储设备运行得慢，而快速设备得造价远高于同类的低速设备。</strong>因此<strong>高速缓冲处理器是一个比主存更小更快的存储设备，它存放近期处理器可能需要的信息。</strong></p></li>
<li>位于处理器的L1高速缓存的容量达到数万字节，访问速度和访问寄存器一样快</li>
<li><p>L2高速缓存容量达数十万到百万字节，其通过一条特殊总线连接带处理器，虽然比L1慢5倍，但比主存快5~10倍 <img src="/2023/02/28/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AF%BC%E8%AE%BA/cache_1.png" width="600"> 因此合理利用高速缓存存储器和存在能够提高程序的性能。（第六章）</p></li>
</ul>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统-优化程序性能</title>
    <url>/2023/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h3 id="导读">1 导读</h3>
<p>程序优化涉及的范围实在是太广了，几乎每个层面都可以进行优化，比如撰写<编译器友好型>以及<缓存友好型>的程序，针对不同的目标硬件平台还可能进行特定的优化，等等，优化的难点在于你需要对系统有充分理解，当然了在你做优化之前<strong>首先要保证原始程序功能正确（并且有回归测试）</strong>，否则一切都是徒劳。</缓存友好型></编译器友好型></p>
<blockquote>
<p>首先需要理解，哪些因素会影响程序的性能 <img src="/2023/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/influence.png" width="700"></p>
</blockquote>
<span id="more"></span>
<h3 id="优化思想">2 优化思想</h3>
<ul>
<li>不要在循环做重复的操作，即可在循环外的准备操作就不要在循环内使用</li>
<li>位运算&lt;加减&lt;乘&lt;除</li>
<li>优化存取操作，尽量少从内存取数据，在循环中能够从寄存器取就从寄存器取</li>
<li>从以上方面优化程序的书写结构</li>
</ul>
<p><img src="/2023/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/op.png" width="700"> <img src="/2023/05/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/CPU.png" width="700"></p>
<blockquote>
<p>文章来源<a href="https://fengmuzi2003.gitbook.io/csapp3e/di-5-zhang-cheng-xu-de-you-hua">CSAPP重点解读</a></p>
</blockquote>
<h3 id="分支预测">3 分支预测</h3>
<p><strong>分支预测和预测错误处罚</strong> 对于分支指令，处理器为了保持流水线的满载，会进行分支预测，一般是称为投机执行的技术。如果预测正确，程序继续执行，投机技术把执行结果提交到程序寄存器或内存；<strong>如果预测错误，那么必须清空所有投机执行的结果，然后重新填充流水线，保证流水线的尽可能满载。</strong> <strong>GCC会编译出使用条件传送的指令，而不是更传统的基于控制的条件转移的实现。</strong> 对于预测错误，不需要很恐慌，正常对待即可，因为：</p>
<ul>
<li>现代处理器中的分支预测逻辑非常善于辨别不同的分支指令的有规律的模式和长期的趋势。所以不要过分关心分支预测</li>
<li><strong>分支预测只对于有规律的模式可行，因此尽可能书写适合条件传送的代码，因为这可以让GCC自己识别并把代码转换成条件传送。</strong></li>
</ul>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="我的思考">0. 我的思考</h4>
<p>两个可供突破的大方向：</p>
<ul>
<li>是否能推动深度学习的训练数据规模减小？</li>
<li>怎么使得训练模型的结果更加精确。</li>
</ul>
<p>资源:</p>
<ul>
<li>kaggle机器学习竞赛</li>
</ul>
<span id="more"></span>
<h4 id="机器学习和深度学习关系概述">1. 机器学习和深度学习关系概述</h4>
<p>人工智能、机器学习和深度学习三者的关系如下所示： <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/relationship.png" width="400"> <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/knowladge.png" width="400"></p>
<ul>
<li><p><strong>机器学习</strong>：机器学习系统是训练出来的，而不是明确用代码编写出来的。人们通过输入数据和从这些数据中预期得到的答案，系统输出相应的规则。</p></li>
<li><p><strong>深度学习</strong>：<strong>深度学习里面的&quot;深度&quot;不是指通过学习获得更深层次的理解，而是指通过一系列连续的表示层来获得更有效果的数据特征。一个深度学习模型有多少层就被称为模型的深度是多少</strong>。一般来说，现代深度学习通常包含数十个甚至上百个连续的表示层。<strong>这些层也被称为神经网络</strong> <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/CNN.png" width="500"></p></li>
</ul>
<h5 id="深度学习的指标">1.2 深度学习的指标</h5>
<p>在上面我们已经知道，深度学习是<strong>通过各层对输入数据不断提取特征</strong>，提取方式的具体操作就是<strong>每层都是对输入数据进行权重计算</strong>，其本质就是一串数字，</p>
<p>如下图所示，<span class="math inline">\(X_i\)</span>是从图片拉伸出来的像素，它是不会变的，无法对其进行操作。而<span class="math inline">\(W\)</span>矩阵就是参数矩阵，<span class="math inline">\(b\)</span>是神经元偏置。<strong>因此对于深度学习，对于参数矩阵的选择是一项艰巨的任务，参数的好坏决定了输出结果的优劣</strong>。但是我们不能糊里糊涂的对参数进行更改，这样可能适得其反，<strong>必须借助某一个评估指标来更改，这就是接下来要介绍的损失函数</strong> <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pixels.png" width="500"></p>
<h5 id="损失函数">1.2.1 损失函数</h5>
<p><strong>损失函数</strong>：损失函数的任务，就是通过一定数学式子衡量出该深度学习的实际输出与预期标准值之间的距离。</p>
<p><strong>通过损失函数计算的损失值作为反馈信号来对参数矩阵中的权值进行微调，来降低对应的损失值</strong>。这种调节右优化器来完成，它实现了所谓的<strong>反向传播</strong>算法。 <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/optimizer.png" width="300"></p>
<blockquote>
<p>一般来说，一开始神经网络的权值是随机赋值的，那么第一次的输出也就通常与预期值相差甚远，但随着权重值的不断微调，损失在也在降低，这就是为什么说学习模型是训练出来的。</p>
</blockquote>
<h6 id="softmax分类器">1.2.2 softmax分类器</h6>
<p>上面我们经过各层神经网络最终得到一个输入的得分值，但我们想一想如果结果给与我们一个概率不是更好，那么把得分值转化为概率就是<code>softmax</code>的作用。</p>
<p><code>softmax</code>分类器将各个得分值<strong>进行放大然后归一化后再计算概率</strong></p>
<h5 id="卷积神经网络">1.3 卷积神经网络</h5>
<p>神经网络本质上就是将我们的输入信息转换为特征矩阵。<strong>卷积神经网络就是对同一个区域可以提取多个特征值，传统的神经网络一般只提取单个特征值，这样卷积更加全面稳实。</strong></p>
<p>卷积神经网络右输入层、隐含层、输出层组成：</p>
<ul>
<li><p>输入层：卷积神经网络的输入层可以处理多维数据，常见地，一维卷积神经网络的输入层接收一维或二维数组，其中一维数组通常为时间或频谱采样；二维数组可能包含多个通道；二维卷积神经网络的输入层接收二维或三维数组；三维卷积神经网络的输入层接收四维数组。由于使用<strong>梯度下降算法</strong>进行学习，卷积神经网络的输入特征需要进行标准化处理。具体地，在将学习数据输入卷积神经网络前，<strong>需在通道或时间/频率维对输入数据进行归一化</strong>，若输入数据为像素，也可将分布于的原始像素值归一化至<span class="math inline">\([0,1]\)</span>区间</p></li>
<li><p><strong>隐含层</strong>：隐含层包含卷积层、池化层和全连接层3类常见构筑。卷积层中的卷积核包含权重系数，而池化层不包含权重系数</p>
<ul>
<li><p><strong>卷积核</strong>：卷积层的功能是对输入数据进行特征提取，其内部包含多个<strong>卷积核</strong>，组成卷积核的每个元素都对应一个权重系数和一个偏差量（bias vector）。卷积核就是图像处理时，给定输入图像，输入图像中一个小区域中像素加权平均后成为输出图像中的每个对应像素，其中权值由一个函数定义，这个函数称为卷积核。</p></li>
<li><p><strong>激励函数</strong>：卷积层中包含激励函数以协助表达复杂特征，卷积神经网络通常使用线性整流函数<code>Rectified Linear Unit, ReLU</code>,它的作用就是对于上一层经过卷积后的数据经过<code>relu</code>的<code>max(0,x)</code>筛选</p></li>
<li><strong>池化层</strong>：在卷积层进行特征提取后，为避免特征量太多计算缓慢，对其进行特征值压缩，输出的特征图会被传递至池化层进行特征选择和信息过滤。池化层包含预设定的池化函数，其功能是将特征图中单个点的结果替换为其相邻区域的特征图统计量。</li>
<li><p><strong>全连接层</strong>：卷积神经网络中的卷积层和池化层能够对输入数据进行特征提取，<strong>全连接层的作用则是对提取的特征进行非线性组合以得到输出，即全连接层本身不被期望具有特征提取能力</strong>，而是试图利用现有的高阶特征完成学习目标 <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/car.png" width="500"></p></li>
</ul></li>
</ul>
<h4 id="机器学习">2. 机器学习</h4>
<p>当我们用机器学习来解决实际任务时，会面对多种多样的数据形式，比如声音、图像、文本等．不同数据的特征构造方式差异很大．对于图像这类数据，我们可以很自然地将其表示为一个连续的向量． 将图像数据表示为向量的方法有很多种，比如直接将一幅图像的所有像素值（灰度值或RGB 值）组成一个连续向量．而对于文本数据，因为其一般由离散符号组成，并且每个符号在计算机内部都表示为无意义的编码，所以通常很难找到合适的表示方式．因此，在实际任务中使用机器学习模型一般会包含以下几个步骤</p>
<ul>
<li><strong>（1）数据预处理</strong>：对数据的原始形式进行初步的数据清理（比如去掉一些有缺失特征的样本，或去掉一些冗余的数据特征等）和加工（对数值特征进行缩放和归一化等），并构建成可用于训练机器学习模型的数据集．</li>
<li><strong>（2）特征提取</strong>：从数据的原始特征中提取一些对特定机器学习任务有用的高质量特征．比如在图像分类中提取边缘、尺度不变特征变换（Scale InvariantFeature Transform，SIFT）特征，在文本分类中去除停用词等．</li>
<li><strong>（3）特征转换</strong>：对特征进行进一步的加工，比如降维和升维． 很多特征转换方法也都是机器学习方法．降维包括特征抽取（Feature Extraction）和特征选择（Feature Selection）两种途径．常用的特征转换方法有主成分分析（Principal Components Analysis，PCA）、 线性判别分析（Linear Discriminant Analysis，LDA）等．</li>
<li><strong>（4）预测</strong>：机器学习的核心部分，学习一个函数并进行预测 <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/MLprocedrue.png" width="500"></li>
</ul>
<p>上述流程中，每步特征处理以及预测一般都是分开进行的．<strong>传统的机器学习模型主要关注最后一步，即构建预测函数．但是实际操作过程中，不同预测模型的性能相差不多</strong>，<strong><em>而前三步中的特征处理对最终系统的准确性有着十分关键的作用．特征处理一般都需要人工干预完成，利用人类的经验来选取好的特征，并最终提高机器学习系统的性能．因此，很多的机器学习问题变成了特征工程（Feature Engineering）问题．开发一个机器学习系统的主要工作量都消耗在了预处理、特征提取以及特征转换上</em></strong>． <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pro.png" width="500"></p>
<h5 id="机器学习类型">2.1 机器学习类型</h5>
<p>常见的机器学习有监督学习、无监督学习和强化学习。</p>
<ul>
<li>监督学习：训练集有标签，学习准则为期望风险最小化，进行最大似然估计</li>
<li>无监督学习：训练集没有标签，学习准则为最大似然估计和最小重构错误</li>
<li>强化学习：智能体和环境交互的规矩t和累积奖励G，学习准则中会使用策略评估和改进。</li>
</ul>
<p>总的来说学习的分类有，有监督主要是回归、分类问题；无监督学习问题主要为聚类、降维和密度估计</p>
<h5 id="机器学习要素">2.2 机器学习要素</h5>
<p>机器学习的主要四要素是数据、模型、学习准则和优化算法。</p>
<h6 id="模型">2.2.1 模型</h6>
<ul>
<li>模型：以回归问题为例，输入空间<span class="math inline">\(X\)</span>和输出空间<span class="math inline">\(Y\)</span>构成了一个样本空间．对于样本空间中的样本<span class="math inline">\((x, y) ∈ X × Y\)</span>，假定x和y 之间的关系可以通过一个未知的真实映射函数<span class="math inline">\(y =g(x)\)</span>或真实条件概率分布<span class="math inline">\(P_r(y|x)\)</span>来描述．机器学习的目标是找到一个模型来近 似真实映射函数<span class="math inline">\(g(x)\)</span>或真实条件概率分布<span class="math inline">\(p_r(y|x)\)</span>．</li>
</ul>
<h6 id="学习准则">2.2.2 学习准则</h6>
<ul>
<li>学习准则：这里使用了损失函数，损失函数是一个非负实数函数，用来量化模型预测和真实标签之间的差异．下面介绍几种常用的损失函数：
<ul>
<li><strong>平方损失函数</strong>：平方损失函数（Quadratic Loss Function）经常用在预测标签<span class="math inline">\(y\)</span>为实数值的任务中，定义为 <span class="math display">\[L(y,f(x;θ))={1 \over 2}(y-f(x;θ))^2\]</span></li>
<li><strong>交叉熵损失函数</strong>：交叉熵损失函数（Cross-Entropy Loss Function）一般用于分类问题．假设样本的标签 <span class="math inline">\(y ∈ {1, ⋯ , C}\)</span> 为离散的类别，模型<span class="math inline">\(f(x; θ) ∈ [0, 1]^C\)</span>的输出为类别标签的条件概率分布。如下：比如对于三分类问题，一个样本的标签向量为 <span class="math inline">\(y = [0, 0, 1]^T\)</span>，模型预测的标签分布为 <span class="math inline">\(f(x; θ) = [0.3, 0.3, 0.4]^T\)</span>，则它们的交叉熵为 <span class="math display">\[ L(y,f(x;θ))=−(0 × log(0.3) + 0 ×log(0.3) + 1 × log(0.4)) = − log(0.4)\]</span></li>
<li><strong>Hinge损失函数</strong>：对于二分类问题，假设<span class="math inline">\(y∈{−1, +1}，f(x; θ)∈ℝ\)</span>，Hinge损失函数（Hinge Loss Function）为： <span class="math display">\[L(y,f(x;θ))=max(0,1-yf(x;θ))\]</span></li>
</ul></li>
</ul>
<h6 id="风险最小化准则">2.2.3 风险最小化准则</h6>
<p>一个好的模型 <span class="math inline">\(f(x;θ)\)</span>应当有一个比较小的期望错误，但由于不知道真实的数据分布和映射函数，实际上无法计算其期望风险 ℛ(θ)．给定一个训练集 <span class="math inline">\(D ={(x^{(n)}, y^{(n)})}_{n=1}^N\)</span>，我们可以计算的是<strong>经验风险（Empirical Risk）</strong>，即在训练集上的<strong>平均损失</strong>: <span class="math display">\[R_D^{emp}(θ)={1\over N} \sum_{n=1}^NL(y^{(n)},f(x^{(n)};θ))\]</span></p>
<p>因此，一个切实可行的学习准则是找到一组参数<span class="math inline">\(θ^*\)</span> 使得经验风险最小，即: <span class="math display">\[θ^*=argminR_D^{emp}(θ)\]</span> 这就是经验风险最小化（Empirical Risk Minimization，ERM）准则</p>
<p><strong>过拟合</strong>：</p>
<p>根据大数定理可知，当训练集大小 |𝒟| 趋向于无穷大时，经验风险就趋于期望风险。然而通常情况下，我们无法获取无限的训练样本，并且训练样本往往是真实数据的一个很小的子集或者包含一定的噪声数据，不能很好地反映全部数据的真实分布．<strong>经验风险最小化原则很容易导致模型在训练集上错误率很低，但是在未知数据上错误率很高．这就是所谓的过拟合（Overfitting）</strong></p>
<p><strong>过拟合问题往往是由于训练数据少和噪声以及模型能力强等原因造成的</strong>．为了解决过拟合问题，一般在经验风险最小化的基础上再引入<strong>参数的正则化（Regularization）来限制模型能力</strong>，使其不要过度地最小化经验风险。这种准则就是<strong>结构风险最小化（Structure Risk Minimization，SRM）准则</strong>： <span class="math display">\[θ^*=argminR_D^{struct}(θ)=argminR_D^{emp}(θ)+{1\over 2}λ||θ||^2\]</span> 其中<span class="math inline">\(‖θ‖\)</span>是<span class="math inline">\(ℓ2\)</span> 范数的正则化项，用来减少参数空间，避免过拟合；<span class="math inline">\(λ\)</span>用来控制正则化的强度．正则化项也可使用其他函数，比如$ ℓ1<span class="math inline">\(范数．\)</span>ℓ1 $范数的引入通常会使得参数有一定稀疏性，因此在很多算法中也经常使用． 从贝叶斯学习的角度来讲，正则化是引入了参数的先验分布，使其不完全依赖训练数据 <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/overAndlack.png" width="400"></p>
<p><strong><em>注</em></strong>：所有损害优化的方法都可称为正则化</p>
<h6 id="最优化">2.2.4 最优化</h6>
<p>在确定了训练集<span class="math inline">\(X\)</span>、假设空间<span class="math inline">\(ℱ\)</span>以及学习准则后，如何找到最优的模型<span class="math inline">\(f(x, θ^∗)\)</span> 就成了一个最优化（Optimization）问题．机器学习的训练过程其实就是最优化问题的求解过程。</p>
<p>参数与超参数 在机器学习中，优化又可以分为<strong>参数优化和超参数优化</strong>．模型<span class="math inline">\(f(x; θ)\)</span>中的<span class="math inline">\(θ\)</span>称为模型的参数，可以通过优化算法进行学习．除了可学习的参数<span class="math inline">\(θ\)</span>之外，<strong>还有一类参数是用来定义模型结构或优化策略的，这类参数叫作超参数(Hyper-Parameter）</strong></p>
<p>常见的超参数包括：<strong>聚类算法中的类别个数、梯度下降法中的步长、正则化项的系数、神经网络的层数、支持向量机中的核函数等</strong>．<em><u>超参数的选取一般都是组合优化问题，很难通过优化算法来自动学习．因此，超参数优化是机器学习的一个经验性很强的技术，通常是按照人的经验设定，或者通过搜索的方法对一组超参数组合进行不断试错调整</u>．</em></p>
<ul>
<li><strong>优化算法：</strong>
<ul>
<li><p><strong>梯度下降法</strong>：为了充分利用凸优化中一些高效、成熟的优化方法，比如共轭梯度、拟牛顿法等，很多机器学习方法都倾向于选择合适的模型和损失函数，以构造一个凸函数作为优化目标．但也有很多模型（比如神经网络）的优化目标是非凸的，只能退而求其次找到局部最优解。在机器学习中，<strong>最简单、常用的优化算法就是梯度下降法</strong>，即首先初始化参数<span class="math inline">\(θ_0\)</span>，然后按下面的迭代公式来计算训练集<span class="math inline">\(D\)</span>上风险函数的最小值: <span class="math display">\[θ_{t+1}=θ_t-α{δR_D(θ)\over δθ}=θ_t-α{1\over N}\sum{_{n=1}^N}{δL(y^{(n)},f(x^{(n)};θ)\over δθ}\]</span> 其中<span class="math inline">\(θ_t\)</span>为第<span class="math inline">\(t\)</span>次迭代时的参数值，<span class="math inline">\(α\)</span>为搜索步长．在机器学习中，<span class="math inline">\(α\)</span>一般称为学习率（Learning Rate）</p></li>
<li><p><strong>提前停止</strong>：针对梯度下降的优化算法，<strong>除了加正则化项之外，还可以通过提前停止来防止过拟合</strong>．在梯度下降训练的过程中，由于过拟合的原因，在训练样本上收敛的参数，并不一定在测试集上最优．因此，除了训练集和测试集之外，有时也会使用一个验证集（Validation Set）来进行模型选择，测试模型在验证集上是否最优. 在每次迭代时，把新得到的模型 <span class="math inline">\(f(x; θ)\)</span> 在验证集上进行测试，并计算错误率．如果在验证集上的错误率不再下降，就停止迭代．这种策略叫提前停止（EarlyStop）．如果没有验证集，可以在训练集上划分出一个小比例的子集作为验证集 <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/EarlyStop.png" width="400"></p></li>
<li><p><strong>随机梯度下降法</strong>：上面的<strong>梯度下降法</strong>的目标函数是整个训练集上的风险函数，批量梯度下降法在每次迭代时需要计算每个样本上损失函数的梯度并求和．当训练集中的样本数量<span class="math inline">\(N\)</span>很大时，空间复杂度比较高，每次迭代的计算开销也很大。<strong>批量梯度下降法相当于是从真实数据分布中采集<span class="math inline">\(N\)</span>个样本</strong>，并由它们计算出来的经验风险的梯度来近似期望风险的梯度．为了减少每次迭代的计算复杂度，我们也可以在每次迭代时只采集一个样本，计算这个样本损失函数的梯度并更新参数，即<strong>随机梯度下降法（Stochastic Gradient Descent，SGD</strong>）．当经过足够次数的迭代时，随机梯度下降 作增量梯度下降法．也可以收敛到局部最优解[Nemirovski et al., 2009] <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/random.png" width="400"></p></li>
</ul>
<p>批量梯度下降和随机梯度下降之间的区别在于，每次迭代的优化目标是对所有样本的平均损失函数还是对单个样 本的损失函数．由于随机梯度下降实现简单，收敛速度也非常快，因此使用非常广泛．随机梯度下降相当于在批 量梯度下降的梯度上引入了随机噪声．在非凸优化问题中，随机梯度下降更容易逃离局部最优点．</p>
<ul>
<li><strong>小批量梯度下降法</strong>：随机梯度下降法的一个缺点是无法充分利用计算机的并行计算能力．小批量梯度下降法（Mini-Batch Gradient Descent）是批量梯度下降和随机梯度下降的折中．每次迭代时，我们随机选取一小部分训练样本来计算梯度并更新参数，这样既可以兼顾随机梯度下降法的优点，也可以提高训练效率： <span class="math display">\[θ_{t+1}←θ_t-α{1\over k}\sum_{(x,y)∈δ_t}{δL(y,f(x;θ))\over δθ}\]</span></li>
</ul></li>
</ul>
<h5 id="线性回归">2.3 线性回归</h5>
<p>本节通过一个简单的模型（线性回归）来具体了解机器学习的一般过程，以及不同学习准则（经验风险最小化、结构风险最小化、最大似然估计、最大后验估计）之间的关系．线性回归（Linear Regression）是机器学习和统计学中最基础和最广泛应用的模型，是一种对自变量和因变量之间关系进行建模的回归分析．自变量数量为1时称为简单回归，自变量数量大于1时称为多元回归。如下： <span class="math display">\[f(x;w,b)=w^Tx+b\]</span> 其中权重向量<span class="math inline">\(w∈ ℝ^D\)</span> 和偏置<span class="math inline">\(b∈ ℝ\)</span>都是可学习的参数，<span class="math inline">\(f(x;w,b)=w^Tx+b\)</span>即为线性模型</p>
<h6 id="参数学习">2.3.1 参数学习</h6>
<p>给定一组包含 𝑁 个训练样本的训练集 <span class="math inline">\(D = {(x^{(n)}, y{(n)})}_{n=1}^N=1\)</span>，我们希望能够学习一个最优的线性回归的模型参数<span class="math inline">\(w\)</span>．我们介绍四种不同的参数估计方法：经验风险最小化、结构风险最小化、最大似然估计、最大后验估计．</p>
<h5 id="经验风险最小化">2.4 经验风险最小化</h5>
<p>由于线性回归的标签𝑦和模型输出都为连续的实数值，因此平方损失函数非常合适衡量真实标签和预测标签之间的差异．根据经验风险最小化准则，训练集<span class="math inline">\(w\)</span>上的经验风险定义 <span class="math display">\[R(w)=\sum_{n=1}^NL(y^{(n)},f(x^{(n)};w)\\
={1\over 2}\sum_{n=1}^N(y^{(n)}-w^Tx^{(n)})^2 \\
={1\over 2}||y-X^Tw||^2
\]</span></p>
<p>风险函数<span class="math inline">\(ℛ(w)\)</span>是关于𝒘的凸函数，其对<span class="math inline">\(w\)</span>的偏导数为: <span class="math display">\[
{δR(w)\over δw}={1\over 2}{δ||y-X^Tw||^2\over δw}\\
=-X(y-X^Tw)
\]</span> 令其等于0，则可得<span class="math inline">\(w^*=(XX^T)^{(-1)}Xy\)</span> 上述求解线性回归参数的方法为<strong>最小二乘法</strong>。在最小二乘法，<span class="math inline">\(XX^T∈R^{(D+1)×(D+1)}\)</span>必须存在逆矩阵。</p>
<h5 id="结构风险最小化">2.5 结构风险最小化</h5>
<p>最小二乘法的基本要求是各个特征之间相互独立，保证<span class="math inline">\(XX^T\)</span>可逆，且即使可逆，如果特征值之间有较大的多重共线性，也会使得<span class="math inline">\(XX^T\)</span>在的逆在数值上无法准确计算。<strong>因此此时给<span class="math inline">\(XX^T\)</span>的对角线加上一个常数<span class="math inline">\(λ\)</span>，使其满秩</strong> <span class="math display">\[R(w)={1\over 2}||y-X^Tw||^2+{1\over 2}λ||w||\]</span></p>
<h5 id="最大似然估计">2.6 最大似然估计</h5>
<p>一类是样本的特征向量<span class="math inline">\(x\)</span>和标签<span class="math inline">\(y\)</span> 之间存在未知的函数关系 <span class="math inline">\(y = ℎ(x)\)</span>，另一类是条件概率$ p(y|x)$ 服从某个未知分布．最小二乘法是属于第一类，直接建模 <span class="math inline">\(x\)</span> 和标签 <span class="math inline">\(y\)</span> 之间的函数关系．此外，线性回归还可以从建模条件概率<span class="math inline">\(p(y|x)\)</span>的角度来进行参数估计。</p>
<p>假设标签<span class="math inline">\(y\)</span>为一个随机变量，并由函数<span class="math inline">\(f(x; w) = w^Tx\)</span> 加上一个随机噪声<span class="math inline">\(ε\)</span>决定，即<span class="math inline">\(f(x; w) = w^Tx+ε\)</span> 其中<span class="math inline">\(ε\)</span>服从均值为0，方差为<span class="math inline">\(δ^2\)</span>的高斯分布，则<span class="math inline">\(y\)</span>服从均值为<span class="math inline">\(w^Tx\)</span>,方差为<span class="math inline">\(δ^2\)</span>的高斯分布： <span class="math display">\[
p(y|x;w,δ)={1\over \sqrt{2\piδ}}exp(-{(y-w^Tx)^2\over2δ^2})
\]</span></p>
<p>接下来计算<span class="math inline">\(w\)</span>在训练集上的似然函数，后对似然函数取对数方便计算，令其导等于0，求出解得: <span class="math display">\[w^{ML}=(XX^T)^{-1}Xy\]</span></p>
<h5 id="最大后验估计">2.7 最大后验估计</h5>
<p><strong>最大似然估计的一个缺点是当训练数据比较少时会发生过拟合，估计的参数可能不准确．为了避免过拟合，我们可以给参数加上一些先验知识</strong>．略，详看书</p>
<h5 id="偏差-方差分解">2.8 偏差-方差分解</h5>
<p>为了避免过拟合，我们经常会在模型的拟合能力和复杂度之间进行权衡．拟合能力强的模型一般复杂度会比较高，容易导致过拟合．相反，如果限制模型的复杂度，降低其拟合能力，又可能会导致欠拟合．因此，如何在模型的拟合能力和复杂度之间取得一个较好的平衡，对一个机器学习算法来讲十分重要．<strong>偏差-方差分解（Bias-Variance Decomposition）为我们提供了一个很好的分析和指导工具．</strong></p>
<h5 id="机器学习算法类型">2.9 机器学习算法类型</h5>
<p>机器学习算法可以按照不同的标准来进行分类．比如按函数<span class="math inline">\(f(y; θ)\)</span>的不同，机器学习算法可以分为<strong>线性模型和非线性模型</strong>；按照学习准则的不同，机器学习算法也可以分为<strong>统计方法和非统计方法</strong>．</p>
<p>但一般来说，我们会<strong>按照训练样本提供的信息以及反馈方式的不同</strong>，将机器学习算法分为以下几类：</p>
<ul>
<li><strong>监督学习</strong>：如果机器学习的目标是建模样本的特征<span class="math inline">\(x\)</span>和标签<span class="math inline">\(y\)</span>之间的关系：<span class="math inline">\(y =f(x; θ)\)</span>或<span class="math inline">\(p(y|x; θ)\)</span>，并且训练集中每个样本都有标签，那么这类机器学习称为监督学习（Supervised Learning）.根据标签类型的不同，监督学习又可以分为<strong>回归问题、分类问题和结构化学习问题</strong>．
<ul>
<li>回归（Regression）问题中的标签<span class="math inline">\(y\)</span>是连续值（实数或连续整数），f(x; θ)$的输出也是连续值．</li>
<li><strong>分类（Classification）问题</strong>中的标签<span class="math inline">\(y\)</span>是离散的类别（符号）．在分类问题中，学习到的模型也称为分类器（Classifier）。分类问题根据其类别数量又可分为二分类（Binary Classification）和多分类（Multi-class Classification）问题．</li>
<li>结构化学习（Structured Learning）问题是一种特殊的分类问题．在结构化学习中，标签𝒚通常是结构化的对象，比如序列、树或图等．由于结构化学习的输出空间比较大，因此我们一般定义一个联合特征空间，将<span class="math inline">\(x, y\)</span>映射为该空间中的联合特征向量<span class="math inline">\(\phi(x, y)\)</span>，预测模型可以写为: <span class="math display">\[y=arg max f(\phi(x,y);θ)\]</span> 计算<span class="math inline">\(argmax\)</span>s得过程也称为解码Decoding过程</li>
</ul></li>
<li><p><strong>无监督学习</strong>：无监督学习（Unsupervised Learning，UL）是指从不包含目标标签的训练样本中自动学习到一些有价值的信息．典型的无监督学习问题有聚类、密度估计、特征学习、降维等．</p></li>
<li><p><strong>强化学习</strong>：强化学习（Reinforcement Learning，RL）是一类通过交互来学习的机器学习算法．在强化学习中，智能体根据环境的状态做出一个动作，并得到即时或延时的奖励．智能体在和环境的交互中不断学习并调整策略，以取得最大化的期望总回报</p></li>
</ul>
<h4 id="线性模型">3. 线性模型</h4>
<p>线性模型（Linear Model）是机器学习中应用最广泛的模型，指通过样本特征的线性组合来进行预测的模型。本节我们主要介绍四种不同线性分类模型：<strong>Logistic回归、Softmax回归、感知器和支持向量机</strong>，这些模型的区别主要在于使用了不同的损失函数</p>
<h5 id="线性判别函数和决策边界">3.1 线性判别函数和决策边界</h5>
<p>一个线性分类模型（Linear Classification Model）或线性分类器（Linear Classifier），是由一个（或多个）线性的判别函数<span class="math inline">\(f(x; w) =w^T + b\)</span> 和非线性的决策函数<span class="math inline">\(g(⋅)\)</span>组成．我们首先考虑二分类的情况，然后再扩展到多分类的情况．</p>
<h6 id="二分类">3.1.1 二分类</h6>
<p>二分类问题是最简单得，其类别标签只有两个值，通常设为<span class="math inline">\({+1,-1}\)</span>。因此只需要一个线性判别函数<span class="math inline">\(f(x; w) =w^T + b\)</span>。在特征空间<span class="math inline">\(R^D\)</span>中所有满足<span class="math inline">\(f(x;w)=0\)</span>得点组成一个<strong>分割超平面</strong>，也称为决策边界或决策平面，它将特征空间一分为二，两个区域各对应一个类边。特征空间中样本点到决策平面得距离为： <span class="math display">\[
\gamma={f(x;w)\over||w||}
\]</span> <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/binaryclassfier.png" width="300"></p>
<h6 id="多分类">3.1.2 多分类</h6>
<p>多分类（Multi-class Classification）问题是指分类的类别数<span class="math inline">\(C\)</span>大于 2．多分类一般需要多个线性判别函数，但设计这些判别函数有很多种方式。一个多分类问题常用以下三种：</p>
<ul>
<li><strong>一对其余方式</strong>：把多分类问题转换为 C个“一对其余”的二分类问题．这种方式共需要<span class="math inline">\(C\)</span>个判别函数，其中第c个判别函数<span class="math inline">\(f_c\)</span> 是将类别c的样本和不属于类别c的样本分开</li>
<li><strong>“一对一”方式</strong>：把多分类问题转换为 <span class="math inline">\(C(C − 1)/2\)</span>个“一对一”的二分类问题．这种方式共需要<span class="math inline">\(C(C − 1)/2\)</span>个判别函数，其中第<span class="math inline">\((i, j)\)</span>个判别函数是把类别i和类别j的样本分开</li>
<li><strong>“argmax”方式</strong>：这是一种改进的“一对其余”方式，共需要<span class="math inline">\(C\)</span>个判别函数: <span class="math display">\[
f_C(x;w_c)=w^T_cx+b_C
\]</span> 表示对于样本<span class="math inline">\(x\)</span>，如果存在一个类边<span class="math inline">\(c\)</span>，相对于所有其他类边<span class="math inline">\(\tilde{c}(\tilde{c}≠c)\)</span>有<span class="math inline">\(f_c(x;w_c)&gt;f_{\tilde{c}(x,w_{\tilde{c}})}\)</span>。那么<span class="math inline">\(x\)</span>属于类边<span class="math inline">\(c\)</span></li>
</ul>
<p>上述得三种分类判别函数中前两个都有缺陷，那就是会存在一些难以区分得区域，二<strong>argmax</strong>方式很好得解决了这个问题</p>
<h5 id="logistic回归">3.2 Logistic回归</h5>
<p>Logistic 回归（Logistic Regression，LR）是一种常用的处理二分类问题的线性模型．在本节中，我们采用<span class="math inline">\(y ∈ [0, 1]\)</span>以符合Logistic回归的描述习惯。为解决连续线性函数不适合分类问题，引入非线性函数g来预测后验概率<span class="math inline">\(p(y=1|x)\)</span>: <span class="math display">\[
p(y=1|x)=g(f(x;w))
\]</span> 上面<span class="math inline">\(g\)</span>也被称为<strong>激活函数</strong>，它得作业其实就是将通过<span class="math inline">\(f(x;w)\)</span>得出得值进行(0,1)间的压缩，使其成为概率。反函数<span class="math inline">\(g^{-1}\)</span>称为<strong>联系函数</strong>。</p>
<p>因此使用LR作为激活函数时，相应的后验概率为（为简单起见，<span class="math inline">\(w\)</span>和<span class="math inline">\(x\)</span>均为增广矩阵）： <span class="math display">\[
p(y=1|x)={1\over 1+exp(-w^Tx)}；
p(y=0|x)=1-p(y=1|x)
\]</span> <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/logistic.png" width="300"></p>
<h6 id="参数学习-1">3.2.1 参数学习</h6>
<p>Logistic 回归采用交叉熵作为损失函数，并使用梯度下降法来对参数进行优化．</p>
<p>给定<span class="math inline">\(N\)</span>个训练样本<span class="math inline">\((x^{(n)},y^{(n)})_{n=1}^N\)</span>，使用LR回归模型对每个样本进行预测，输出其标签为1的后验概率，<strong>记为<span class="math inline">\(\tilde{y}^{(n)}\)</span></strong>。则交叉熵损失函数后，其风险函数为： <span class="math display">\[
R(w)={-1\over N}\sum_{n=1}^N(p_r(y^{(n)}=1|x^{(n)}))log\tilde{y}^{(n)}+p_r(y^{(n)}=0|x^{(n)}))log(1-\tilde{y}^{(n)}))\\
={-1\over N}\sum_{n=1}^N(y^{(n)}log\tilde{y}^{(n)}+(1-y^{(n)})log(1-\tilde{y}^{(n)}))   \qquad式3.2.1
\]</span></p>
<p>然后对其进行求导的<span class="math inline">\({δR(w)\over δw}=-{1\over N}\sum x^{(n)}(y^{(n)}-\tilde{y}^{(n)})\)</span>。然后使用梯度下降法进行迭代更新进行优化： <span class="math display">\[
w_{t+1}=w_t+α{δR(w)\over δw}
\]</span></p>
<p>由式子<span class="math inline">\(3.2.1\)</span>可知，其风险函数是关于参数<span class="math inline">\(w\)</span>连续可导的凸函数，因此除了使用梯度下降，LR回归还可以用高阶的优化方法，如牛顿法。</p>
<h5 id="softmax回归">3.3 softmax回归</h5>
<p>Softmax 回归（Softmax Regression），也称为多项（Multinomial）或多类（Multi-Class）的Logistic回归，<strong>是Logistic回归在多分类问题上的推广</strong>。对于多类问题，类别标签<span class="math inline">\(y∈ {1, 2, ⋯ , C}\)</span>可以有<span class="math inline">\(C\)</span> 个取值．给定一个样本<span class="math inline">\(x\)</span>，Softmax回归预测的属于类别<span class="math inline">\(c\)</span>的条件概率为: <span class="math display">\[
\tilde{y}=p(y=c|x)=softmax(w^T_cx)\\
={exp(w_c^Tx)\over \sum ^C_{\tilde{c}=1}exp(w^T_\tilde{c}x)}
\]</span></p>
<p><strong>其决策函数为：</strong> <span class="math display">\[
\{y=[I(C=c]\}=arg max_{c=1}^C p(y=c|x)
\]</span></p>
<h6 id="参数学习-2">3.3.1 参数学习</h6>
<p>给定<span class="math inline">\(N\)</span>个训练样本<span class="math inline">\({(x^{(n)}, y^{(n)})}_{n=1}^N\)</span>，<strong>Softmax回归使用交叉熵损失函数来学习最优的参数矩阵<span class="math inline">\(W\)</span></strong>．为了方便起见，我们用<span class="math inline">\(C\)</span>维的one-hot向量<span class="math inline">\(y ∈(0, 1)^c\)</span> 来表示类别标签．对于类别<span class="math inline">\(C\)</span>，其向量表示为: <span class="math display">\[
y=[I(1=c),I(2=c),...,I(C=c)]
\]</span></p>
<p>采用交叉熵损失函数时，softmax的风险函数为： <span class="math display">\[
R(w)=-{1\over N}\sum_{n=1}^N\sum_{c=1}^C y_c^{(n)}log\tilde{y}_c^{(n)} \\
=-{1\over N}\sum_{n=1}^N (y^{(n)})^Tlog\tilde{y}^{(n)}
\]</span></p>
<p>利用梯度下降法，对其求导可得梯度： <span class="math display">\[
{δR(W)\over δW}=-{1\over N}\sum_{n=1}^N x^{(n)}(y^{(n)}-\tilde{y}^{(n)})^T
\]</span> 然后进行迭代更新： <span class="math display">\[
w_{t+1}=w_t+α{δR(w)\over δw}
\]</span></p>
<h4 id="深度学习简述">4.深度学习简述</h4>
<p>为了学习一种好的表示，需要构建具有一定“深度”的模型，并通过学习算法来让模型自动学习出好的特征表示（从底层特征，到中层特征，再到高层特征），从而最终提升预测模型的准确率．<strong>所谓“深度”是指原始数据进行非线性特征转换的次数</strong> <img src="/2022/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/DL.png" width="500"></p>
<p>深度学习是将原始的数据特征通过多步的特征转换得到一种特征表示，并进一步输入到预测函数得到最终结果．和“浅层学习”不同，<strong>深度学习需要解决的关键问题是贡献度分配问题（Credit Assignment Problem，CAP）[Minsky,1961]</strong>，即一个系统中不同的组件（component）或其参数对最终系统输出结果的贡献或影响.从某种意义上讲，深度学习可以看作一种强化学习（Reinforcement Learning，RL），每个内部组件并不能直接得到监督信息，需要通过整个模型的最终监督信息（奖励）得到，并且有一定的延时性</p>
<p><strong>深度学习采用的模型主要是神经网络模型，其主要原因是神经网络模型可以使用误差反向传播算法，从而可以比较好地解决贡献度分配问题</strong>．</p>
<h5 id="表示学习">4.1 表示学习</h5>
<p>为了提高机器学习系统的准确率，我们就需要将输入信息转换为有效的特 征，或者更一般性地称为表示（Representation）。如果有一种算法可以自动地学习出有效的特征，并提高最终机器学习模型的性能，那么这种学习就可以叫作<strong>表示学习</strong>。</p>
<p>表示学习的关键是解决<strong>语义鸿沟（Semantic Gap）问题</strong>．语义鸿沟问题是指输入数据的底层特征和高层语义信息之间的不一致性和差异性．比如给定一些关于“车”的图片，由于图片中每辆车的颜色和形状等属性都不尽相同，因此不同图片在像素级别上的表示（即底层特征）差异性也会非常大．但是我们理解这些图片是建立在比较抽象的高层语义概念上的．如果一个预测模型直接建立在底层特征之上，会导致对预测模型的能力要求过高．如果可以有一个好的表示在某种程度上能够反映出数据的高层语义特征，那么我们就能相对容易地构建后续的机器学习模型</p>
<h6 id="局部和分布式表示">4.1.1 局部和分布式表示</h6>
<p>在机器学习中，我们经常使用两种方式来表示特征：<strong>局部表示（Local Representation）和分布式表示（Distributed Representation）．</strong></p>
<ul>
<li><strong>局部表示</strong>：离散表示，one-Hot向量，单一值表示一个东西。
<ul>
<li><strong>优点：</strong>
<ul>
<li>这种离散的表示方式具有很好的解释性，有利于人工归纳和总结特征，并通过特征组合进行高效的特征工程</li>
<li>通过多种特征组合得到的表示向量通常是稀疏的二值向量，当用于线性模型时计算效率非常高</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>one-hot向量的维数很高，且不能扩展．如果有一种新的颜色，我们就需要增加一维来表示</li>
<li>不同颜色之间的相似度都为0，即我们无法知道“红色”和“中国红”的相似度要高于“红色”和“黑色”的相似度</li>
</ul></li>
</ul></li>
<li><strong>分布式表示</strong>：压缩、低维的稠密向量，使用多个值表示一个东西，如表示颜色的方法是用RGB值来表示颜色，不同颜色对应到R、G、B三维空间中一个点，这种表示方式叫作分布式表示
<ul>
<li>分布式表示的表示能力要强很多，分布式表示的向量维度一般都比较低．我们只需要用一个三维的稠密向量就可以表示所有颜色．并且，分布式表示也很容易表示新的颜色名．此外，不同颜色之间的相似度也很容易计算</li>
</ul></li>
</ul>
<h5 id="端到端学习">4.2 端到端学习</h5>
<p><strong>端到端学习（End-to-End Learning），也称端到端训练，是指在学习过程中不进行分模块或分阶段训练，直接优化任务的总体目标</strong>．在端到端学习中，一般不需要明确地给出不同模块或阶段的功能，中间过程不需要人为干预．端到端学习的训练数据为“输入-输出”对的形式，无须提供其他额外信息．因此，端到端学习和深度学习一样，都是要解决贡献度分配问题．目前，大部分采用神经网络模型的深度学习也可以看作一种端到端的学习</p>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(C++实现)</title>
    <url>/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="说在前面">1.说在前面</h4>
<p>c++支持两种类--<strong>抽象类和具体类</strong>。一个抽象类包含着没有实现代码的成员函数（纯虚函数）。具体了类没有纯虚函数。只有具体类才可以实例化（但抽象类实例化指针和引用是运行的），即只能对具体类建立实例或对象。</p>
<p><strong>在这里主要讲解各种数据结构的思想，列举抽象类接口和实现一部分具体类的接口功能。</strong></p>
<span id="more"></span>
<h4 id="数组">2. 数组</h4>
<h5 id="数组介绍">2.1 数组介绍</h5>
<p>数组是有序表的一种，其内存是在物理上是连续的，对于这种数据结构而言，其优缺点如下： <strong>优点</strong>：</p>
<ul>
<li>支持下标访问随机访问，访问指定位置快时间复杂读为<code>O(1)</code></li>
<li>没有额外的存储空间来存储指针之类的</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>对于插入操作比较麻烦，需要将插入位置后的元素后移一位，造成最坏情况下时间复杂度为O(n)</li>
<li>同时分配的内存是连续，一次性分配，若元素装满后还想插入元素，则需要另外开辟，将原来的元素拷贝过去再插入，造成效率低下。</li>
</ul>
<p>对于数组，不建议自己去写一个类实现，而是使用STL中带有的<code>vetcor</code>，这款容器能实现按1.5或2倍扩容机制增长，且支持迭代器，是C++开发中最长用到的功能齐全的容器。</p>
<h5 id="实现">2.2 实现</h5>
<h6 id="linerlist抽象类">2.2.1 linerList抽象类</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">linearList</span></span><br><span class="line">&#123;		<span class="comment">//抽象类ADT</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">linearList</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> tehIndex)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span>  T&amp;  <span class="keyword">operator</span>[](<span class="type">int</span> theIndex)=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T&amp; elements)</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> theIndex)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> theIndex, <span class="type">const</span> T&amp; theInserElement)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">output</span><span class="params">(std::ostream&amp; os)</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="c实现">2.2.2 C++实现</h6>
<p>在线性表的数组描述中，我们用<strong>一维动态分配的数组<code>element</code></strong>，变量<code>lsitsize</code>表示当前存储的线性表元素个数，用<code>arrayLength</code>表示线性表容量。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">arrayList</span> :<span class="keyword">public</span> linearList&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">arrayList</span>(<span class="type">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">arrayList</span>(<span class="type">const</span> arrayList&lt;T&gt;&amp;);</span><br><span class="line">	~<span class="built_in">arrayList</span>() &#123; <span class="keyword">delete</span>[]element; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> listsize == <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> listsize; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> arrayLength; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> )</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> theIndex)<span class="type">const</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T&amp; element)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> theIndex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> theIndex, <span class="type">const</span> T&amp; theInserElement)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">output</span><span class="params">(std::ostream&amp; os)</span><span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">checkIndex</span><span class="params">(<span class="type">const</span> <span class="type">int</span> indexOf)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">//std::shared_ptr&lt;T[]，end_connection&gt; elememt;	</span></span><br><span class="line">	<span class="comment">//不建议使用智能指针形式的动态数组，</span></span><br><span class="line">	<span class="comment">//因为析构函数使用的是默认delete,而不是delete[],</span></span><br><span class="line">	<span class="comment">//若要使用则应该定义自己得删除器</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increaseLength</span><span class="params">(T*&amp; , <span class="type">int</span> , <span class="type">int</span>)</span></span>;<span class="comment">//扩容操作</span></span><br><span class="line">	T* element;</span><br><span class="line">	std::<span class="type">size_t</span> listsize;</span><br><span class="line">	std::<span class="type">size_t</span> arrayLength;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素，后面的元素向前移动一位</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; arrayLisst&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">int</span> index)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;下标访问越界&quot;</span>);</span><br><span class="line">	<span class="built_in">copy</span>(element+index+<span class="number">1</span>,element+listsize,element+index);</span><br><span class="line">	element[--listsize].~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="c实现-1">2.2.3 C实现</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C版本</span></span><br><span class="line"><span class="comment">//结构体定义：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span>	<span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType	*elem;</span><br><span class="line">	<span class="type">int</span>	length;</span><br><span class="line">	<span class="type">int</span>	listsize;</span><br><span class="line"></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//创建一个顺序表：</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="comment">//分配动态内存，malloc函数返回一个void*的指针，强制转换为ElemType*。</span></span><br><span class="line">	L.elem=(ElemType*）<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="built_in">seziof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span>(!L.elem)<span class="built_in">exit</span>(OVERFLOW);		<span class="comment">//分配内存失败。</span></span><br><span class="line">	L.length=<span class="number">0</span>;					<span class="comment">//初始化为0</span></span><br><span class="line">	L.listsize=LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入前，要把插入的位置后面的元素后移，也就是要先判断插入前的内存是否足够元素插入，</span></span><br><span class="line"><span class="comment">//若不足够，则需要扩容。在进行元素后移，元素插入。其时间复杂度为O(n)</span></span><br><span class="line">Status <span class="built_in">Insert_List</span>(SqList &amp;L，<span class="type">int</span> i,ElemType	e)	<span class="comment">//i为插入的位置，e为要插入的元素</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>&amp;&amp;i&gt;L.length+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;=L.listsize)</span><br><span class="line">	&#123;</span><br><span class="line">		ElemType *newbase=(ElemType*)<span class="built_in">realloc</span>(L.elem,LISTINCREMENT*<span class="built_in">seziof</span>(ElemType));</span><br><span class="line">		<span class="keyword">if</span>(!L.elem)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		L.elem=newbase;</span><br><span class="line">		L.listsize+=LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	ElemType *q=&amp;(L.elem[i<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(Elemtype *p=&amp;(L.elem[length<span class="number">-1</span>];q&gt;=p;p--)</span><br><span class="line">		*(p+<span class="number">1</span>）=*p;</span><br><span class="line">	*q=e;</span><br><span class="line">	++L.length;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作，O(n)</span></span><br><span class="line">Status <span class="built_in">Delet_List</span>(SqList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">	ElemType *q=&amp;((L-&gt;Elem)[i<span class="number">-1</span>]);</span><br><span class="line">	e=*q;</span><br><span class="line">	q+=<span class="number">1</span>;</span><br><span class="line">	ElemType *p=&amp;(L.elme[length<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(q;q&lt;=p;q++)</span><br><span class="line">		*(q<span class="number">-1</span>)=*q;</span><br><span class="line">	L.length-=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//取值操作</span></span><br><span class="line">Status <span class="built_in">GetElem_List</span>(SqList L,<span class="type">int</span> i, ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>&amp;&amp;i&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		e=L.elem[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作</span></span><br><span class="line">Status <span class="built_in">LocateElem_List</span>(SqList L,ElemType e,Status （*compare)(ElemType,ElemType))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>	i=<span class="number">1</span>;</span><br><span class="line">	ElemType *p=l.elem;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=L.length&amp;&amp;<span class="built_in">compare</span>(*p++,e))<span class="comment">//回调函数</span></span><br><span class="line">		i++;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=L.length)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">MergeList</span>(SqList La,SqList Lb,SqList &amp;Lc)</span><br><span class="line">&#123;</span><br><span class="line">	ElemType* pa=La.elem;</span><br><span class="line">	ElemType* pb=Lb.elem;</span><br><span class="line">	ElemType* pa_last=pa+La.length<span class="number">-1</span>;</span><br><span class="line">	ElemType* pb_last=pb+Lb.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	Lc.listsize=La.length+Lb.length;</span><br><span class="line">	Lc.elem=(ElemType*)<span class="built_in">malloc</span>(Lc.listsize*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">	ElemType* pc=Lc-&gt;elem;</span><br><span class="line">	<span class="keyword">if</span>(Lc.elem==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(pa&lt;=pa_last&amp;&amp;pb&lt;=pb_last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*pa&lt;=*pb)</span><br><span class="line">		*pc++=*pa++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		*pc++=*pb++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pa&lt;=pa_last)</span><br><span class="line">		*pc++=*pa++;</span><br><span class="line">	<span class="keyword">while</span>(pb&lt;=pb_last)</span><br><span class="line">		*pc++=*pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表">3. 链表</h4>
<h5 id="单链表介绍">3.1 单链表介绍</h5>
<p>链表克服了数组插入删除时的元素移动步骤，但是代价是牺牲一定的内存来存储指针，其优缺点如下 <strong>优点：</strong></p>
<ul>
<li>链表通过指针来指向下一个元素，带来的好处是插入删除无须移动插入位置后的元素的元素，也不必前移删除位置后的元素，只需要将指针指向后方元素即可。</li>
<li>通过指针来指向下一个元素，这就意味着我们不必像数组那样分配严格物理意义上的联系内存，即使内存不连续，也能成功访问。只有在需要的时候才去创建空间。大小不固定，拓展很灵活。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>因为内存是不联系的，那么链表不支持随机访问，如果访问链表中指定位置节点，只能从头或者尾部进行遍历。</li>
<li>因为除了存储数据，还有存储相应的指针，同一长度的数组和链表，链表会造成内存的消耗多</li>
</ul>
<p><img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/simplelist.png" width="600"></p>
<h5 id="实现-1">3.2 实现</h5>
<h6 id="c实现-2">3.2.1 C++实现</h6>
<p><strong>1.存储结构以及类整体声明及定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++实现</span></span><br><span class="line"><span class="comment">//结构类,其思想同c的数据就跟链表一样，只不过在类内其增加构造函数：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chainNode</span>&#123;</span><br><span class="line">	T element;</span><br><span class="line">	chainNode *next;</span><br><span class="line">	<span class="built_in">chainNode</span>(<span class="type">const</span> T&amp; element)</span><br><span class="line">		&#123;<span class="keyword">this</span>-&gt;element=element;&#125;</span><br><span class="line">	<span class="built_in">chainNode</span>(<span class="type">const</span> T&amp; element,chainNode&lt;T&gt; *next)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;element=element;</span><br><span class="line">		<span class="keyword">this</span>-&gt;next=next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对象类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chain</span>:<span class="keyword">public</span> linearList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">chain</span>(<span class="type">int</span> initialCapacity=<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">chain</span>(<span class="type">const</span> chain&lt;T&gt;&amp;);</span><br><span class="line">	~<span class="built_in">chain</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> listSize==<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> listSize;&#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> theIndex)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> theIndex)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> theIndex,<span class="type">const</span> T&amp; theElement)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(ostream&amp; os)</span><span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">checkIndex</span><span class="params">(<span class="type">int</span> theIndex)</span><span class="type">const</span></span>;</span><br><span class="line">	chainNode&lt;T&gt;* firstNode;</span><br><span class="line">	<span class="type">int</span> listSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2. 构造函数和拷贝构造函数</strong></p>
<p>为了创建一个空链表，只需令第一个<code>firstNode</code>的值为<code>NULL</code>，链表不需要预先分配堆空间，它是随用随建立的一个形式。不过为了与<code>arrayList</code>相容，构造函数还是具有一个表示初始容量的形参<code>initialCapacity</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">chain&lt;T&gt;::<span class="built_in">chain</span>(<span class="type">int</span> initialCapacity)&#123;</span><br><span class="line">	<span class="keyword">if</span>(initialCapacity&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;The capacity is wrong&quot;</span>);</span><br><span class="line">	firstNode=<span class="literal">NULL</span>;</span><br><span class="line">	listSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">chain&lt;T&gt;::<span class="built_in">chain</span>(<span class="type">const</span> chain&lt;T&gt;&amp; theList)&#123;</span><br><span class="line">	listSize=theList.listSize;</span><br><span class="line">	<span class="keyword">if</span>(listSize==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		firstNode=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	chainNode&lt;T&gt; *sourceNode=theList.firstNode;		<span class="comment">//使用拷贝构造函数,深拷贝</span></span><br><span class="line">	firstNode=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(sourcNode-&gt;element);</span><br><span class="line">	sourceNode=sourceNode-&gt;next;</span><br><span class="line">	chainNode&lt;T&gt; *intermediateValue=firstNode;</span><br><span class="line">	<span class="keyword">while</span>(sourceNode!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		intermediateValue=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(sourceNode-&gt;element);</span><br><span class="line">		sourceNode=sourceNode-&gt;next;</span><br><span class="line">		intermediate=intermediate-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	intermediate-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">chain&lt;T&gt;::~<span class="built_in">chain</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(firstNode!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		chianNode&lt;T&gt; *nextNode=firstNode-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> firstNode;</span><br><span class="line">		firstNode=nextNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. get函数</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; chain&lt;T&gt;::<span class="built_in">get</span>(<span class="type">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">checkIndex</span>(theIndex);</span><br><span class="line">	chainNode&lt;T&gt; *targetNode=firstNode;</span><br><span class="line">	<span class="keyword">while</span>(theIndex&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNode=targetNode-&gt;next;</span><br><span class="line">		theIndex--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> targetNode-&gt;element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.插入函数</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> chain&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">int</span> theIndex,<span class="type">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">checkIndex</span>(theIndex);</span><br><span class="line">	chainNode&lt;T&gt; *newNode=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(the Element);</span><br><span class="line">	<span class="keyword">if</span>(theIndex==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		newNode-&gt;next=firstNode;</span><br><span class="line">		firstNode=newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		chainNode&lt;T&gt; *insertLocation=firstNode;</span><br><span class="line">		<span class="keyword">while</span>(theIndex&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			insertLocation=inserLocation-&gt;next;</span><br><span class="line">			theIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		newNode-&gt;next=inserLocation-&gt;next;</span><br><span class="line">		inserLocation-&gt;next=newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	++listSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>5. 删除函数</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> chain&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">checkIndex</span>(theIndex);</span><br><span class="line">	chainNode&lt;T&gt;* eraseNode;</span><br><span class="line">	<span class="keyword">if</span>(theIndex==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		eraseNode=fiirstNode;</span><br><span class="line">		firstNode=eraseNode-&gt;next;</span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		chianNode&lt;T&gt; *frontNode=firstNode;</span><br><span class="line">		<span class="keyword">while</span>(theIndex&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			frontNode=frontNode-&gt;next;</span><br><span class="line">			theIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		eraseNode=frontNode-&gt;next;</span><br><span class="line">		frontNode-&gt;next=eraseNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> eraseNode;</span><br><span class="line">	listSize--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 除单链表外还有:</p>
<ul>
<li>循环链表：我们可以采用两个措施使链表的应用代码简洁高效：①把链表描述成一个单向循环链表。②在链表的前面加一个头结点。</li>
<li>双向链表：即有指向后继的指针，又有指向前驱的指针。</li>
</ul>
<p>这里不再介绍这两个，因为实现跟单链表相似，无非就是加了指针指向。</p>
<h6 id="c实现-3">3.2.2 C实现</h6>
<p><strong>1. 存储结构以及实现结构体</strong></p>
<p><code>LinkList、next</code>是指向结构的指针,用间接访问<code>-&gt;</code>符号。其中<code>LinkList</code>是链表的头指针，若<code>LinkList==NULL</code>(为空指针）,则表示链表为空。有时候我们会把头指针指向的是一个头结点（其数据域不存储任何东西或者存储链表长度等附加信息）,指针域<code>next</code>指向下一个结构。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c版本</span></span><br><span class="line"><span class="comment">//单链表的存储结构设置：</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 建立单链表：这个算法是从尾到表头进行建立的（当然也可以从表头到表尾）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatLinkList</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 L=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">	<span class="comment">//L=(LinkList)malloc(sizeof(LNode));</span></span><br><span class="line">	L-&gt;next==<span class="literal">NULL</span>;		<span class="comment">//建立一带头结点的单链表</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		LNode* p=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">		p-&gt;data=<span class="built_in">scanf</span>();</span><br><span class="line">		p-&gt;next=L-&gt;next;</span><br><span class="line">		L-&gt;next=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 插入操作：从头指针开始达到指定的位置，创建新节点（结构），插入。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">status <span class="title">InsertElem</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNoed *p=L-&gt;next;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	s=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));		<span class="comment">//为新结构体分配动态内存</span></span><br><span class="line">	<span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 删除操作：从头指针开始达到指定的位置，改变next指针的指向，释放（free)要删除的结构（节点）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">status  <span class="title">DeleteElem</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	LNode *q=p+<span class="number">1</span>;</span><br><span class="line">	p-&gt;next=q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 查找操作：与顺序表一样，应用回调函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(LinkList L,EemType e,<span class="type">int</span> (*compare)(ElemType,ElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=L-next;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="built_in">compare</span>(p-&gt;data,e)))</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="双向链表介绍">3.3 双向链表介绍</h5>
<p>链表的每一个节点给中既有指向下一个结点的指针，也有指向上一个结点的指针，可以快速的找到当前节点的前一个节点，适用于需要双向查找节点值的情况。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/shuangList.png" width="600"> <strong>双链表相对于单链表的优点：</strong></p>
<ul>
<li><strong>删除单链表中的某个节点时，一定要得到待删除节点的前驱，得到其前驱的方法一般是在定位待删除节点的时候一路保存当前节点的前驱</strong>，这样指针的总的的移动操作为2n次，如果是用双链表，就不需要去定位前驱，所以指针的总的的移动操作为n次。</li>
<li><strong>查找时也是一样的，可以用二分法的思路，从头节点向后和尾节点向前同时进行，这样效率也可以提高一倍。</strong></li>
</ul>
<p>但是市场上对于单链表的使用要超过双链表,，因为从存储结构来看，每一个双链表的节点都比单链表的节点多一个指针，如果长度是<code>n</code>，就需要<code>n*lenght</code>（32位是4字节，64位是8字节）的空间，这在一些追求时间效率不高的应用下就不适用了，因为他占的空间大于单链表的<code>1/3</code>，所以设计者就会一时间换空间。</p>
<h5 id="应用">3.4 应用</h5>
<h6 id="箱子排序链表形式">3.4.1 箱子排序(链表形式)</h6>
<p><strong>1. 箱子排序的原理</strong></p>
<p>对于链表因为若用冒泡选择排序，我们时间复制度是为<code>O(n*n)</code>。采用箱子排序会更快，时间复杂度为<code>O(n)</code>。<strong>所谓的箱子排序就是将值相同的节点放到一个箱子内，然后再将排好序的箱子内的链表串接起来形参有序链表。</strong>事先分好各个箱子大小。每一个箱子都是一个链表。一个箱子的节点数目介于<code>0~n</code>之间。它要做的是：</p>
<ul>
<li>逐个删除输入链表，把删除的节点分配到相应的箱子里；</li>
<li>把每一个箱子中的节点连接起来，使其成为一个有序链表；</li>
</ul>
<p><strong><em>注意</em></strong>：箱子排序适用于对有大量重复的数据进行排序，并且数据范围不大。不然试想一下假设有0~10000范围的数据，这个时候我们就得分好并管理10000个箱子，这是很麻烦的。</p>
<p><strong>2. 下面以学生的划分6个优秀等级作为例子</strong></p>
<p>学生结构包含：学生姓名，学生优秀等级。用大小为6的vector<studentStruct>表示分配了6个箱子。代码如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(2n)</span></span><br><span class="line"><span class="comment">//学生结构类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">studentStruct</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//等级为0，1，2，3，4，5</span></span><br><span class="line">	<span class="type">int</span> rank;		<span class="comment">//方便访问测试，直接将成员变量设为public</span></span><br><span class="line">	string name;</span><br><span class="line">	studentStruct* next;</span><br><span class="line">	<span class="built_in">studentStruct</span>():<span class="built_in">rank</span>(<span class="number">-1</span>),<span class="built_in">name</span>(<span class="string">&quot;&quot;</span>),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">studentStruct</span>(<span class="type">int</span> _rank,string _name):<span class="built_in">rank</span>(_rank),<span class="built_in">name</span>(_name),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">studentStruct</span>(<span class="type">const</span> stduentStrcut&amp; s):<span class="built_in">rank</span>(s.rank),<span class="built_in">name</span>(s.name),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	studentStruct&amp; <span class="keyword">operator</span>=(<span class="type">const</span> studentStruct* s)&#123;</span><br><span class="line">		name=s.name;</span><br><span class="line">		rank=s.rank;</span><br><span class="line">		next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">studentStruct</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箱子排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">boxSort</span><span class="params">(T* head)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//初始化六个空的节点，标识为-1</span></span><br><span class="line">	<span class="function">vector&lt;T*&gt; <span class="title">vec</span><span class="params">(<span class="number">6</span>)</span></span>;		<span class="comment">//当前索引的第一个位置</span></span><br><span class="line">	<span class="function">vector&lt;T*&gt; <span class="title">lastNode</span><span class="params">(<span class="number">6</span>)</span></span>;	<span class="comment">//记录当前索引最后一个节点的位置</span></span><br><span class="line">	<span class="comment">//遍历传入的链表，将学生节点分好箱子</span></span><br><span class="line">	<span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="type">int</span> index = head-&gt;rank % <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">if</span> (vec[index] == <span class="literal">NULL</span>) &#123;<span class="comment">//该位置为空，直接存入</span></span><br><span class="line">			vec[index] = head;</span><br><span class="line">			lastNode[index] = head;	<span class="comment">//刚存入的就是最后一个节点</span></span><br><span class="line">			head = head-&gt;next;</span><br><span class="line">			lastNode[index]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			T* tempNode = head-&gt;next;</span><br><span class="line">			head-&gt;next = lastNode[index]-&gt;next;		<span class="comment">//置NULL</span></span><br><span class="line">			lastNode[index]-&gt;next = head;</span><br><span class="line">			lastNode[index] = head;</span><br><span class="line">			head = tempNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将vector内的各个分散链表串接起来,未使用lastNode版本</span></span><br><span class="line">	T* endNext = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (endNext != <span class="literal">NULL</span>)<span class="comment">//不是第一次进入循环，进行连接</span></span><br><span class="line">			endNext-&gt;next = *it;</span><br><span class="line">		endNext = *it;</span><br><span class="line">		<span class="keyword">while</span> (endNext != <span class="literal">NULL</span> &amp;&amp; endNext-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//endNext!=NULL是防止该所谓位置无值，endNext是索引有值遍历到最后一个</span></span><br><span class="line">			endNext = endNext-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*，将vector内的各个分散链表串接起来，使用lastNode版本 */</span></span><br><span class="line">	T* first=<span class="literal">NULL</span>,*last=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	for(auto i=0;i&lt;lastNode.size();i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		if(last==NULL)&#123;</span></span><br><span class="line"><span class="comment">			last=lastNode[i];</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else if(last!=NULL&amp;&amp;lastNode[i]!=NULL)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			last-&gt;next=vec[i];</span></span><br><span class="line"><span class="comment">			last=lastNode[i];</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></studentStruct></p>
<h6 id="基数排序数组形式">3.4.2 基数排序（数组形式）</h6>
<p>对于上面的箱子排序，对于数据范围很大的数据很难有实践意义，<strong>基数排序</strong>为克服这一点而出现的。基数排序排序主要通过将数字分解进行排序，如三位数的925，技术排序可通过十进制分解，将925分解成9、2、5三个数，然后依次以个位、十位、百位进行排序。<strong>在这个过程中，因为数字只有0~9,所有仅仅需要10个桶就，然后调用三次箱子排序即可</strong>，时间复杂度为O(n<em>m) <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/jishusort.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">potencySort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> num)</span> </span>&#123;	<span class="comment">//num指示按哪位排序</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">tempVec</span>(<span class="number">10</span>);		<span class="comment">//二维数组，内部vector的大小看数据量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> index = vec[i] / num % <span class="number">10</span>;</span><br><span class="line">		tempVec[index].<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	vec.<span class="built_in">clear</span>();		<span class="comment">//清除里面的数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)		<span class="comment">//放回vec</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = tempVec[i].<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">while</span> (it != tempVec[i].<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">			++it;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </em><strong>注意：适用数据重复比较平均的时候，若是全部数据都在一个桶内，则会导致二维数组空间浪费</strong><em>。假设有10000000万数据排序，分配500万，则10</em>500*4=2亿字节，则需要190M内存，因此数据若是分配的比较均匀，则秩序分配200万，需要内存76M就足够了</p>
<h6 id="并查集">3.4.3 并查集</h6>
<p>要知道什么是<strong>并查集</strong>，就要先知道什么是<strong>等价类</strong>。所谓的<strong>等价类</strong>就是指再一个给的n元素的集合R中有两两配对的等价关系且已经是等价关系的最大<strong>集合</strong>（等价类是集合），<strong>如<code>n=14.R=&#123;(1,11),(7,11),(2,12),(12,8),(11,12),(3,13),(13,14)&#125;</code>,如果<code>(a,b)∈R</code>则<code>a,b</code>两个类是等价的，且不能在外部找到其他等价关系。</strong>等价具有自反性、对称性、传递性。即：</p>
<ul>
<li>若<code>a∈R</code>，则<code>(a,a)</code>必属于R，自反性</li>
<li>若<code>(a,b)∈R</code>，则必有<code>(b,a)∈R</code>，对称性</li>
<li>若<code>(a,b)∈R，(b,c)∈R</code>，则<code>(a,c)∈R</code>，传递性</li>
</ul>
<p>等价类分为<strong>离线等价类</strong>和<strong>在线等价类</strong>。在线等价类又称为<strong>并查集</strong></p>
<ul>
<li>离线等价类：n和R已知，确定了所有的等价类关系，且每个元素只能属于一个等价类，即只能在一个集合R</li>
<li><p><strong>在线等价类（并查集）</strong>：初始又n个元素，每个元素刚开始都属于一个独立的等价类。需要执行以下的步骤：</p></li>
<li><code>conbine(a,b)</code>,把包含a和b的等价类合并成一个等价类</li>
<li><p><code>find(theElement)</code>,确定元素在哪一个等价类，目的是对给定的两个元素，确定是否属于同一个类，对同一类元素返回相同结果，否则返回不同结果</p></li>
</ul>
<p><strong>经典的机器调度和布线问题，后续树会讲到</strong></p>
<h4 id="栈">4. 栈</h4>
<h5 id="栈的介绍">4.1 栈的介绍</h5>
<p>栈是一种重要的线性结构，通常称，<strong>栈和队列是限定插入和删除只能在表的“端点”进行操作的线性表。</strong></p>
<ul>
<li>栈的元素必须<code>“后进先出LIFO“</code>。</li>
<li>栈的操作只能在这个线性表的表尾进行。</li>
<li>对于栈来说，这个表尾称为栈的栈顶（top），相应的表头称为栈底（bottom）。</li>
<li>因为栈的本质是一个线性表，线性表有两种存储形式，那么栈也有分为栈的顺序存储结构和栈的链式存储结构。</li>
<li>最开始栈中不含有任何数据，叫做空栈，此时栈顶就是栈底。然后数据从栈顶进入，栈顶栈底分离，整个栈的当前容量变大。数据出栈时从栈顶弹出，栈顶下移，整个栈的当前容量变小。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/stack.gif" width="500"></li>
</ul>
<h5 id="实现-2">4.2 实现</h5>
<p>栈的<strong>顺序存储结构</strong>是利用一组<strong>地址连续的存储单元</strong>依次存放自栈底到栈顶的数据元素，同时附设指针<code>top</code>指示栈顶元素在顺序栈中的位置，先为栈分配一个合理的容量，在应用过程中，当栈的空间不够时再逐渐扩大。</p>
<p>按设定的的初始分量进行第一次存储分配，<code>base</code>可称为栈底指针，在顺序栈中，它始终指向栈底位置。若为<code>base</code>的值为<code>NULL</code>，则表明<strong>栈结构不存在</strong>。<code>top</code>为栈顶指针，其初值指向栈底，既<code>top=base</code>作为<strong>栈空</strong>的标记，每当压入心得栈顶元素时，栈顶<code>top+1</code>，删除<code>-1</code>.因此非空栈的栈顶指针始终在栈顶元素的下一个位置上</p>
<h6 id="c实现-4">4.2.1 C++实现</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Stack</span>();</span><br><span class="line">	<span class="built_in">stack</span>(<span class="type">int</span> cap):<span class="built_in">capacity</span>(cap),<span class="built_in">elements</span>(<span class="keyword">new</span> T[capacity])&#123;&#125;</span><br><span class="line">	<span class="built_in">Stack</span>(<span class="type">const</span> Stack&amp;);</span><br><span class="line">	Stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Stack&amp;);</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Stack</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">capacity</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">increaseCapaciyu</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="type">int</span> base=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> capacity=<span class="number">10</span>;</span><br><span class="line">	T* elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="c实现-5">4.2.2 C实现</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序栈的存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType *base;</span><br><span class="line">	ElemType  *top;</span><br><span class="line">	<span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个顺序栈：注意此时top=base;</span></span><br><span class="line"><span class="function">status <span class="title">InitialStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//构造一个空栈</span></span><br><span class="line">	s.base=(ElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span>（S.base==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stackszie=STACK_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶元素：先判断栈不空</span></span><br><span class="line"><span class="function">status <span class="title">GetTopElem</span><span class="params">(SqStack S,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//取栈顶元素</span></span><br><span class="line">	<span class="keyword">if</span>(S.base==S.top)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	e=*(S.top<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素：判断当前的容量是否足够吗、不够则增加，再插入</span></span><br><span class="line"><span class="function">status 	<span class="title">PushElem</span><span class="params">(SqStack &amp;S,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//插入栈顶元素</span></span><br><span class="line">	<span class="type">int</span> length=(S.top-S.base)/<span class="built_in">sizeof</span>(ElemType);</span><br><span class="line">	<span class="keyword">if</span>(length&gt;=S.stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		ElemType *newbase=(ElemType*)<span class="built_in">realloc</span></span><br><span class="line">			(S.base,(S.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">		<span class="keyword">if</span>(newbase==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		S.base=newbase;</span><br><span class="line">		S.top=S.base+S.stacksize;</span><br><span class="line">		S.stacksize+=STACKINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++=e;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素：</span></span><br><span class="line"><span class="function">Status <span class="title">pop</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	e=*--S.top;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="应用-1">4.3 应用</h5>
<p>栈的能应用于各式各样的后进先出的地方，比如表达式括号匹配，四则运算、迷宫问题等。</p>
<h6 id="健壮四则运算">4.3.1 健壮四则运算</h6>
<p><strong>我的思路：</strong></p>
<ul>
<li>1、把输入的式子中其它<code>&#123;&#125;[]</code>转化为<code>()</code>的形式</li>
<li>2、输入的式子可能有负值，将其转化为减法运算，既前面加0</li>
<li>3、对于<code>(</code>和空运算符栈情况下，运算符直接入栈</li>
<li>4、数字判断长度后，转化为int入栈</li>
<li>5、对于<code>* /</code>，运算符栈顶元素若是同级，则栈顶元素出栈运算，这样避免同出现<code>8/2/2=8</code>的情况</li>
<li>6、对于<code>+ -</code>同级或高级的栈顶运算符也要出栈运算，注意<code>2-2*3+2</code>的特殊情况处理，代码129-142就是处理这种情况。</li>
<li>7、对于)，则直接出栈运算直到(即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">change_bracket</span><span class="params">(string&amp; str)</span></span>;    <span class="comment">//改变&#x27;&#123;&#x27;[&#x27;为&#x27;(&#x27;,改&#x27;]&#x27;,&#x27;&#125;&#x27;为&#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">addZero</span><span class="params">(string&amp; str)</span></span>;    <span class="comment">//判断表达式的是否为有负值，有则前面加0,改为减法</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">handler</span><span class="params">(string&amp; str)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">caculate</span><span class="params">(<span class="type">char</span> s, <span class="type">int</span> a, <span class="type">int</span> b)</span></span>;    <span class="comment">//进行计算</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line">    <span class="built_in">change_bracket</span>(input);</span><br><span class="line">    <span class="built_in">addZero</span>(input);</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">handler</span>(input);</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_bracket</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;&#123;&#x27;</span> || *it == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            *it = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;&#125;&#x27;</span> || *it == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            *it = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addZero</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*str.<span class="built_in">begin</span>() == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>(), <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m = str.<span class="built_in">begin</span>() + <span class="number">1</span>; m != str.<span class="built_in">end</span>(); m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (((*m == <span class="string">&#x27;-&#x27;</span> &amp;&amp; *(m - <span class="number">1</span>) &lt; <span class="string">&#x27;0&#x27;</span>) || (*m == <span class="string">&#x27;-&#x27;</span> &amp;&amp; *(m - <span class="number">1</span>) &gt; <span class="string">&#x27;9&#x27;</span>))&amp;&amp;*(m<span class="number">-1</span>)!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            m = str.<span class="built_in">insert</span>(m, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">caculate</span><span class="params">(<span class="type">char</span> s, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (s)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        c = a * b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        c = a / b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        c = a + b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        c = a - b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">handler</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; in_num;      <span class="comment">//数字栈</span></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; in_char;    <span class="comment">//运算符栈</span></span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">        &#123;<span class="comment">//处理数字</span></span><br><span class="line">            <span class="type">int</span> j = i, num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; str.<span class="built_in">length</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[i + <span class="number">1</span>]))</span><br><span class="line">             &#123;  i++;		&#125;</span><br><span class="line">            <span class="comment">//拷贝子串数字</span></span><br><span class="line">            string str_num = str.<span class="built_in">substr</span>(j, i - j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; str_num.<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;<span class="comment">//转为数字</span></span><br><span class="line">                num = num * <span class="number">10</span> + str_num[k] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//压入数字栈</span></span><br><span class="line">            in_num.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理(，空运算符栈，直接压入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || in_char.<span class="built_in">empty</span>())</span><br><span class="line">            in_char.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        <span class="comment">//处理*,/，既同级的直接前一个先算</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>() &amp;&amp; (tmp == <span class="string">&#x27;/&#x27;</span> || tmp == <span class="string">&#x27;*&#x27;</span>))<span class="comment">//要弹出/进行计算</span></span><br><span class="line">            &#123;</span><br><span class="line">                b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                in_char.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            in_char.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理+ -</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//同理，同级和高级的先处理</span></span><br><span class="line">            tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>() &amp;&amp; (tmp == <span class="string">&#x27;+&#x27;</span> || tmp == <span class="string">&#x27;-&#x27;</span> || tmp==<span class="string">&#x27;*&#x27;</span> ||tmp==<span class="string">&#x27;/&#x27;</span> ))</span><br><span class="line">            &#123;</span><br><span class="line">                b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                in_char.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (tmp == <span class="string">&#x27;+&#x27;</span> || tmp == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                    in_num.<span class="built_in">pop</span>();</span><br><span class="line">                    a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                    in_num.<span class="built_in">pop</span>();</span><br><span class="line">                    in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                    in_char.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            in_char.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                in_char.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//更新tmp</span></span><br><span class="line">                tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出(</span></span><br><span class="line">            in_char.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!in_char.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">        b = in_num.<span class="built_in">top</span>();</span><br><span class="line">        in_num.<span class="built_in">pop</span>();</span><br><span class="line">        a = in_num.<span class="built_in">top</span>();</span><br><span class="line">        in_num.<span class="built_in">pop</span>();</span><br><span class="line">        in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">        in_char.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in_num.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="括号匹配">4.3.2 括号匹配</h6>
<p>给的一个括号字符串，判断这个字符串是否有效即括号是否匹配。有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/kuohao.gif" width="200"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketsOK</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	stack&lt;<span class="type">char</span>&gt; in_char;</span><br><span class="line">	<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (it != s.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">&#x27;(&#x27;</span> || *it == <span class="string">&#x27;&#123;&#x27;</span> || *it == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">			in_char.<span class="built_in">push</span>(*it);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="type">char</span> c = in_char.<span class="built_in">top</span>();</span><br><span class="line">			in_char.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> &amp;&amp; (c + <span class="number">1</span>) != *it)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &amp;&amp; (c + <span class="number">2</span>) != *it)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="队列">5. 队列</h4>
<p><strong>队列是一先进先出的线性结构，允许插入的一端叫做队尾，允许删除的一端叫队头。</strong></p>
<h5 id="链队列">5.1 链队列</h5>
<p>一个链队列需要两个分别<strong>指示队头和队尾的指针（头指针和尾指针）</strong>才能唯一确定。和线性表的单链表一样，为操作方便，也给队列添加一头结点，并令头指针指向头结点。所以空队列的判决条件为头指针和尾指针均指在头结点。链队列的操作为单链表插入和删除操作的特殊情况，只需修改尾指针和头指针即可。读取时的时间复杂度为O(1)。插入、删除时的时间复杂度为O(1)。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/listqueue.png" width="500"> <strong>优点：</strong></p>
<ul>
<li>相比普通的队列，元素出队时无需移动大量元素，只需移动头指针。</li>
<li>可动态分配空间，不需要预先分配大量存储空间。</li>
<li>适合处理用户排队等待的情况。</li>
</ul>
<p><strong>缺点：</strong> -- 需要为表中的逻辑关系增加额外的存储空间。</p>
<h5 id="循环队列">5.2 循环队列</h5>
<p>在循环队列中，空队特征是front = rear, 队满时也会有front = rear; 判断条件将出现二义性（到底是空还是满？） <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/jiaqueque.png" width="500"> <strong>解决方案有三种：</strong></p>
<ul>
<li><ol type="1">
<li>加设标志位，让删除动作使其为1，插入动作使其为0， 则可识别当前front == rear;</li>
</ol></li>
<li><ol start="2" type="1">
<li>使用一个计数器记录队列中元素个数（即队列长度）</li>
</ol></li>
<li><ol start="3" type="1">
<li>人为浪费一个单元，令队满特征为 front = (rear +1)%N---空闲单元法</li>
</ol></li>
</ul>
<p><strong>这里采用空闲单元法解决二义性问题。</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/xunqueue.gif" width="500"></p>
<h5 id="实现-3">5.3 实现</h5>
<p>这里我们均采用C来实现链队列和循环队列</p>
<h6 id="链队列实现">5.3.1 链队列实现</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链队列的存储结构：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">QNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType	data;</span><br><span class="line">	<span class="keyword">struct</span>  <span class="title class_">QNode</span>  *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	QueuePtr front;	<span class="comment">//队头指针（指向头结点）</span></span><br><span class="line">	QueuePtr  rear;	<span class="comment">//队尾指针（指向尾结点）</span></span><br><span class="line">&#125;LinkQueue</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链队列：</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//构造一空队列</span></span><br><span class="line">	Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">	Q.front=Q.rear;	<span class="comment">//队头队尾指针均指向头结点。</span></span><br><span class="line">	<span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列：</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(Q.front!=<span class="literal">NULL</span>)&#123;		<span class="comment">//从队头开始一步步free队头</span></span><br><span class="line">		Q.rear=Q.front-&gt;next;     <span class="comment">//队尾移至队头结点的下一个结点（结构体）</span></span><br><span class="line">		<span class="built_in">free</span>(Q.front);			<span class="comment">//释放动态内存</span></span><br><span class="line">		Q.front=Q.rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入操作：从队尾插入</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QNode *p=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">	<span class="comment">//QNode *p=(QNode*)malloc(sizeof(QNode));</span></span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	p-&gt;data=e;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q.rear-&gt;next=p;</span><br><span class="line">	Q.rear=p;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function">Status <span class="title">DeletQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)<span class="keyword">return</span> ERROR;</span><br><span class="line">	QNode *p=Q.front-&gt;next;</span><br><span class="line">	e=p-&gt;data;</span><br><span class="line">	Q.front-&gt;next=p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==p)<span class="comment">//判断是否为空了，若空了，则队头和队尾指向头结点（相等）。</span></span><br><span class="line">		Q.rear=Q.front;</span><br><span class="line">	<span class="built_in">free</span>(p)</span><br><span class="line">	<span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="跳表和哈希散列">6. 跳表和哈希散列</h4>
<p>有序链表、有序数组、跳表和哈希表的渐进性能如下：</p>
<table>
<thead>
<tr class="header">
<th>数据结构</th>
<th>最坏情况</th>
<th>平均情况</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>有序数组</td>
<td>查找<code>O(lngn)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(lngn)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
</tr>
<tr class="even">
<td>有序链表</td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
</tr>
<tr class="odd">
<td>跳表</td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(logn)</code>、插入<code>O(logn)</code>、删除<code>O(logn)</code></td>
</tr>
<tr class="even">
<td>哈希表</td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(1)</code>、插入<code>O(1)</code>、删除<code>O(1)</code></td>
</tr>
</tbody>
</table>
<p>在C+的STL中适用了哈希散列的容器有：<code>unordered_map、unordered_set、hash_map、hash_multimap、hash_multiset、hash_set</code></p>
<h5 id="跳表">6.1 跳表</h5>
<p>对于有序数组，我们进行二分查找所需要的时间为<code>O(logn)</code>。但是在有序链表上仍然需要的时间为<code>O(n)</code>，<strong>为了提高有序链表的查找性能，可以在全部或者部分节点增加额外的指针，在查找时，通过这些指针，可以跳过链表的若干个点，不必查看所有节点来寻找</strong> <strong>调表</strong>采用<strong>随机技术</strong>来决定链表的哪些节点应增加额外的指针，以及增加多少个指针，基于这种技术，跳表的查找、插入、删除的<strong>平均时间复杂度为<code>O(logn)</code></strong>,最坏情况为<code>O(n)</code>. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构skipNOde</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">skipNode</span>&#123;</span><br><span class="line">	K element;</span><br><span class="line">	skipNode&lt;K&gt; **next;			<span class="comment">//指针数组</span></span><br><span class="line">	<span class="built_in">skipNode</span>(<span class="type">const</span> K&amp; ele,<span class="type">int</span> size):</span><br><span class="line">		<span class="built_in">element</span>(ele)&#123;next=<span class="keyword">new</span> skipNode&lt;K&gt;* [size];&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体的指针域有next数组统一管理，next[i]表示i级链表的指针，元素存储在element内</span></span><br></pre></td></tr></table></figure></p>
<h6 id="实现原理">6.1.1 实现原理</h6>
<p>在一个用有序链表中查找指定值，至多需要N次值的比较。如果链表的中部节点加一个指针，则比较次数可以减少到<code>N/2+1</code>。这个时候我们在查找一个数时，首先是与中部的这个节点进行值比较，如果查找的数对关键字小，则只在左半部分继续查找，若大，则在右半部分查找。如下图所示: <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/skiplist.gif" width="500"> 上图非常形象的展现了跳表的查找操作：如果跳表有多级索引，如图建立了一级索引，则从一级索引出发.</p>
<p><strong>1. 索引级数的分配</strong></p>
<ul>
<li>在跳表中对<code>n</code>个元素而言，以均等分<code>p=0.5</code>,则最多可有链表级数为<code>maxLevel=logn-1</code>。</li>
<li>对于第<code>i</code>级链表，每<code>2^i</code>个元素取一个进行连接 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/skiplist.png" width="500"></li>
</ul>
<p><strong>2. 插入和删除</strong></p>
<p>在插入和删除的时候，如果要保持索引级数分配的规则结构，要耗时<code>O(n)</code>，我们指定i级链表有<code>n/(2^i)</code>个元素，在插入的时候新数据属于<code>i</code>级链表的概率为<code>1/(2^i)</code>。</p>
<p><strong>插入步骤：</strong></p>
<ul>
<li>进行查找<code>O(logn)</code>，找到要插入的位置</li>
<li>插入时，要为新数据分配一个级，分配过程就是我们之前说的<strong>随机数生成器</strong>完成（随机数只是尽可能的维护这种结构规则，不是严格意义上的）</li>
<li>当新数据插入<code>i</code>级链表的时候，只会对<code>0~i</code>级链表产生影响，因此要记住这些链表的前驱</li>
<li>然后只需对next[0~i]进行重新next指针指向</li>
</ul>
<p>对于删除，我们无法控制结构即没有生成随机数操作来中和，<strong>删除操作：</strong></p>
<ul>
<li>要删除指定节点，就必须先找到该节点所在处</li>
<li>知道节点的所找链表级数<code>i</code>，则只会影响<code>0~i</code>级的链表</li>
<li>对<code>0~i</code>级进行<code>next</code>指针重指向</li>
</ul>
<p><strong>为什么插入要随机数：</strong>试想一下，如果插入一直指定一个级数去插入，那么极端情况下将会使跳表退化成单链表，也就失去了跳表的作用，作为一种动态数据结构，我们需要某种手段来维护级数与元素个数之间的平衡。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> skipList&lt;T&gt;::<span class="built_in">level</span>()<span class="type">const</span>&#123;</span><br><span class="line">	<span class="comment">//返回一个链表级数随机数</span></span><br><span class="line">	<span class="type">int</span> lev=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">rand</span>()&lt;=cutoff)</span><br><span class="line">		lev++;</span><br><span class="line">	<span class="keyword">return</span> (lev&lt;maxLevel)?lev:maxLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="哈希表散列表">6.2 哈希表（散列表）</h5>
<p><strong>哈希表就是根据设定的哈希函数和处理冲突的方法将关键字映射到一个有限的连续的地址集（哈希数组）</strong>。当关键字的范围太大，不能用理想方法表示时，可以采用并不理想的哈希表和哈希函数：哈希表的位置的数量比关键字少，哈希函数把若干个不同关键字映射到哈希表的同一个位置（哈希表的每一个位置叫一个桶），桶的数量等于哈希表的长度。</p>
<p>构造哈希表，最常遇到的问题无非就是：</p>
<ul>
<li><strong>冲突</strong>：当两个不同关键字经哈希函数计算后的桶相同时，冲突就发生了。但这对于一个桶可以容纳多个数对的桶来说，并没有什么影响</li>
<li><strong>溢出</strong>：桶没有位置可以存储新的数对，就会溢出</li>
</ul>
<h6 id="实现原理-1">6.2.1 实现原理</h6>
<p><strong>哈希表的建立会适用特定的哈希函数将关键字进行计算转化生成我们访问的下标</strong>，这样就能够建立起<strong>访问、插入、删除</strong>的<code>O(1)</code>操作。因此最重要的是哈希函数的选择和对下标的实现。构造哈希函数的原则是：</p>
<ul>
<li><strong>①函数本身便于计算；</strong></li>
<li><strong>②计算出来的地址分布均匀，即对任一关键字k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突。</strong></li>
</ul>
<p>以下是对哈希函数的常用思想：</p>
<ul>
<li><strong>直接定址法</strong>：<strong>取关键字某个线性函数值为哈希地址</strong>，即<code>H(key)=a*key+b</code></li>
<li><strong>数字分析法</strong>：<strong>前提关键字都是知道的，在此基础上分析数据，依数据选择取哪些位作为<code>key</code>值</strong>。例子：比如现有<code>80</code>个<code>8</code>位的十进制数，只能分配长为<code>100</code>的哈希表供你使用，此时就要依据这<code>8</code>位中哪些位取值分散而从中选取2位为哈希地址来尽可能避免冲突。</li>
<li><strong>平方取中法</strong>：<strong>取关键字平方后的中间几位为哈希地址</strong>，平方取中法比较适用于不清楚关键字的分布，且位数也不是很大的情况。</li>
<li><strong>折叠法</strong>：<strong>将关键字分成位数相同的几部分（最后一部分的位数可以不同），然后取这些部分叠加和作为哈希地址</strong>。折叠法比较适用于不清楚关键字的分布，但是关键字位数较多 的情况</li>
<li><strong>除留余数法</strong>：<strong>取关键字被某个不大于哈希表长m的数<code>p</code>除后所得余数为哈希地址</strong>，即<code>h（k）=k  %  p</code> ，其中<code>%</code>为模p取余运算。一般<code>p</code>选为质数</li>
<li><strong>位与法</strong>：哈希数组的长度一般选择2的幂，在C/C++中位运算相对较为高效，选择2的幂作为数组长度，可以将取模运算转换成<strong>二进制位与</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//专业版hash&lt;string&gt;</span></span><br><span class="line"><span class="comment">//将string关键字转换为size_t的整型哈希值</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash</span>&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string thekey)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> hashValue=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> length=(<span class="type">int</span>) theKey.<span class="built_in">length</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">			hashValue=<span class="number">5</span>*hashValue+thekey.<span class="built_in">at</span>(i);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_t</span>(hashValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="解决hash冲突方案">6.2.2 解决hash冲突方案</h6>
<ul>
<li><strong>开放定址法</strong>: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</li>
<li><strong>再哈希法</strong>：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。</li>
<li><strong>链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中</strong></li>
<li><strong>建立公共溢出区</strong>：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。</li>
</ul>
<h4 id="二叉树">7. 二叉树</h4>
<h5 id="树的概念">7.1 树的概念</h5>
<p>树型结构是一类重要的非线性结构。树（Tree)是n个结点的有限集，在任一非空树中：</p>
<ul>
<li>有且只有一个特定的称为根（Root)的结点，没有前驱的结点称为根结点。</li>
<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、T3.....Tm，每一个集合本身又是一颗树，并且称为根Root的子树。</li>
<li>每一个非根结点有且只有一个父结点；</li>
</ul>
<p><strong>基本术语</strong>：</p>
<ul>
<li><strong>节点的度：一个节点含有的子树的个数称为该节点的度</strong></li>
<li><strong>叶子：度为0的节点</strong></li>
<li><strong>非终端节点或分支节点</strong>：度不为零的节点；</li>
<li><strong>树的度</strong>：树内所有节点的度的最大值；</li>
<li><strong>双亲节点或父节点</strong>：若一个结点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点或子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li><strong>堂兄弟节点</strong>：双亲在同一层的节点互为堂兄弟；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙；</li>
<li><strong>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</strong></li>
<li><strong>树的高度或深度：树中节点的最大层次；</strong></li>
<li>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
<li><strong>有序树/无序树：如果将树中节点的各个子树看成从左到右是有次序的，则称该树为有序树，否则为无序树；</strong></li>
</ul>
<h5 id="二叉树-1">7.2 二叉树</h5>
<p>二叉树是另一种树型结构，它的特定是每个结点至多只有两棵子树。且二叉树的子树有左右之分，其次序不能任意颠倒。也可为空树。<strong>二叉树和树的根本区别是：</strong></p>
<ul>
<li>二叉树的每个元素恰好有两颗子树。而树可有任意数量的子树</li>
<li>在二叉树中，每个元素的子树都是有序的，即左子树和右子数之分。而树的子树是无序的</li>
<li>二叉树可以为空。而树不能为空</li>
</ul>
<h5 id="二叉树特性">7.3 二叉树特性</h5>
<p>二叉树具有较多的特性，使用也比较广泛：</p>
<ul>
<li><strong>在二叉树的第<code>i</code>层上至多有<code>2^(i-1)</code>个结点<code>i&gt;=1</code>;</strong></li>
<li>深度为K的二叉树至多有<code>2^(k)-1</code>个结点<code>K&gt;=1</code>;</li>
<li><strong>对任何一颗二叉树<code>T</code>，如果其终端结点数为<code>n0</code>，度为2的结点数为<code>n2</code>，则<code>n0=n2+1</code>;</strong></li>
<li>具有n个结点的完全二叉树的深度为<code>L[log2(n)]+1</code>;<code>(L[X]表示取不大于X的最大整数）</code></li>
<li><strong>如果对一颗有<code>n</code>个结点的完全二叉树（深度为<code>L[log2(n)]+1</code>）的结点按层序编号（从第一层到<code>L[log2(n)]+1</code>层，每层从左到右），则对任一结点<code>i(1&lt;=i&lt;=n)</code>,，有：</strong></li>
<li>①<code>i=1</code>，则结点<code>i</code>是二叉树的根，无双亲；<code>i&gt;1</code>,则其双亲时结点<code>[i/2]</code></li>
<li>②如果<code>2i&gt;n</code>，则结点<code>i</code>无左孩子，否则其左孩子为<code>2i</code></li>
<li>③如果<code>2i+1&gt;n</code>，则结点无右孩子，否则其右孩子为<code>2i+1</code></li>
</ul>
<p><strong>满二叉树和完全为叉树</strong>： <strong>满二叉树：</strong>当高度为<code>h</code>的二叉树恰好有<code>2^h-1</code>个元素时，为满二叉树 <strong>完全二叉树：</strong>最后一层的叶子只能空右左节点，不能有右节点而没有左节点,下图为完全被二叉树 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/binaryTree.png" width="400"></p>
<h5 id="二叉树的存储结构">7.4 二叉树的存储结构</h5>
<p>二叉树的存储结构一般有顺序存储和链式存储。顺序存储也成为数组形式的描述，而链式存储是二叉树最常用的存储结构，它是用两个左右孩子指针指向其左右孩子节点。</p>
<h6 id="顺序存储">7.4.1 顺序存储</h6>
<p>顺序存储就是用一组地址连续的存储单元依次至上而下、从左到右存储完全二叉树的节点元素，所以顺序存储结构仅适用于完全二叉树和满二叉树（否则会造成空间浪费）。二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。如上图的完全二叉树在数组形式的存储如下： <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/arrayTree.png" width="400"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> ElemType sqBiTree[MAX_TREE_SIZE];</span><br><span class="line">sqBiTree bt;</span><br></pre></td></tr></table></figure></p>
<h6 id="链式存储结构">7.4.2 链式存储结构</h6>
<p>既然顺序存储不能满足二叉树的存储需求，那么考虑采用链式存储。由二叉树定义可知，二叉树的每个结点最多有两个孩子。因此，可以将结点数据结构定义为一个数据和两个指针域。表示方式如图 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/listTree.png" width="300"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> stuct BiTNode&#123;</span><br><span class="line">TElemType data;</span><br><span class="line">strcut BiTNode *lchild,*rchlid;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></p>
<h5 id="实现-4">7.5 实现</h5>
<p>对于二叉树的实现这里主要讲解C++语言的实现</p>
<h6 id="结构体和实现类">7.5.1 结构体和实现类</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点类，用于构建树中的节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T data;</span><br><span class="line">	binaryTreeNode&lt;T&gt;* lchid,* rchild;</span><br><span class="line">	<span class="built_in">binaryTreeNode</span>() :<span class="built_in">lchild</span>(<span class="literal">NULL</span>),<span class="built_in">rchild</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTreeNode</span>(<span class="type">const</span> T&amp; _data) :<span class="built_in">data</span>(_data),<span class="built_in">lchild</span>(<span class="literal">NULL</span>),<span class="built_in">rchild</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTreeNode</span>(<span class="type">const</span> T&amp; _data,binaryTreeNode&lt;T&gt;* left,binaryTreeNode&lt;T&gt;* right) :</span><br><span class="line">		<span class="built_in">data</span>(_data),<span class="built_in">lchild</span>(left),<span class="built_in">rchild</span>(right) &#123;&#125;</span><br><span class="line">	~<span class="built_in">binaryTreeNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">binaryTree</span>() :<span class="built_in">size</span>(<span class="number">1</span>), <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">binaryTreeNode</span>&lt;T&gt;()) &#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTree</span>(<span class="type">const</span> T&amp; _data):<span class="built_in">size</span>(<span class="number">1</span>),<span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">binaryTreeNode</span>&lt;T&gt;(_data))&#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTree</span>(binaryTreeNode&lt;T&gt;* node) :<span class="built_in">size</span>(<span class="number">1</span>), <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">binaryTreeNode</span>&lt;T&gt;(node-&gt;data, node-&gt;lchid, node-&gt;rchild)) &#123;&#125;</span><br><span class="line">	~<span class="built_in">binaryTree</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">binaryTreeNode&lt;T&gt;* <span class="title">getRoot</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTree&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">leveltOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">indsert</span><span class="params">(binaryTreeNode&lt;T&gt;* insert_Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">del</span><span class="params">(<span class="type">int</span> index)</span></span>;						<span class="comment">//使用层次遍历定位</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::<span class="type">size_t</span> <span class="title">height</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="type">size_t</span> size;</span><br><span class="line">	binaryTreeNode&lt;T&gt;* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="前序遍历">7.5.2 前序遍历</h6>
<p>前序遍历是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/preOrder.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Node==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(Node-&gt;data);</span><br><span class="line">	<span class="built_in">preOrder</span>(vec,Node-&gt;lchild);</span><br><span class="line">	<span class="built_in">preOrder</span>(vec,Node-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归版本,使用栈这个辅助数据结构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	stack&lt;binaryTreeNode&lt;T&gt;*&gt; _sta;</span><br><span class="line">	<span class="keyword">if</span>(Node!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">auto</span> p=Node;</span><br><span class="line">		<span class="keyword">while</span>(!_sta.<span class="built_in">empty</span>()||p!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">				vec.<span class="built_in">push_back</span>(p-&gt;data);</span><br><span class="line">				_sta.<span class="built_in">push</span>(p);</span><br><span class="line">				p=p-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!_sta.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				p=_sta.<span class="built_in">top</span>();</span><br><span class="line">				_sta.<span class="built_in">pop</span>();</span><br><span class="line">				p=p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="中序遍历">7.5.3 中序遍历</h6>
<p>中序遍历就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/inOrder.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTree&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Node==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inOrder</span>(vec,Node-&gt;lchild);</span><br><span class="line">	vec.<span class="built_in">push_back</span>(Node-&gt;data);</span><br><span class="line">	<span class="built_in">inOrder</span>(vec,Node-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 非递归使用栈结构进行辅助 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">binaryTree&lt;T&gt; *<span class="title">GoFarLeft</span><span class="params">(binaryTree&lt;T&gt;* t,stack&lt;binaryTreeNode&lt;T&gt;*&gt; &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//找到t树的最左孩子的指针，用指针返回，同时压栈所有遍历过的最左指针</span></span><br><span class="line">	<span class="keyword">if</span>(!t)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(t-&gt;lchild)&#123;</span><br><span class="line">		S.<span class="built_in">push</span>(t);</span><br><span class="line">		t=t-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec,binaryTree&lt;T&gt;*	root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;binaryTreeNode&lt;T&gt;*&gt; _sta</span><br><span class="line">	aotu t=<span class="built_in">GoFarLeft</span>(root,_sta);</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(t-&gt;data);</span><br><span class="line">		<span class="keyword">if</span>(t-&gt;rchild)</span><br><span class="line">			t=<span class="built_in">GoFarLeft</span>(t-&gt;rchild,_sta);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!_sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			t=_sta.<span class="built_in">top</span>();</span><br><span class="line">			_sta.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="后序遍历">7.5.4 后序遍历</h6>
<p>后序遍历就是从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/postOrder.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Node==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">postOrder</span>(vec,Node-&gt;lchild);</span><br><span class="line">	<span class="built_in">postOrder</span>(vec,Node-&gt;rchild);</span><br><span class="line">	vec.<span class="built_in">push_back</span>(Node-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 后序遍历的非递归算法，同样采用栈数据结构辅助 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//strcut TreeNode &#123;</span></span><br><span class="line"><span class="comment">//  ElemType data;</span></span><br><span class="line"><span class="comment">//  TreeNode *left, *right;</span></span><br><span class="line"><span class="comment">//  TreeNode() &#123;</span></span><br><span class="line"><span class="comment">//      left = right = NULL;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(vector&lt;T&gt;&amp; vec,binaryTreeNode&lt;T&gt; *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *p = root, *r = <span class="literal">NULL</span>;</span><br><span class="line">    stack&lt;binaryTreeNode&lt;T&gt;*&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (p || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;<span class="comment">//走到最左边</span></span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild &amp;&amp; p-&gt;rchild != r)<span class="comment">//右子树存在，未被访问</span></span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(p-&gt;data)</span><br><span class="line">                r = p;<span class="comment">//记录最近访问过的节点</span></span><br><span class="line">                p = <span class="literal">NULL</span>;<span class="comment">//节点访问完后，重置p指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="层次遍历">7.5.5 层次遍历</h6>
<p>层次遍历中一般使用<strong>队列</strong>作为辅助工具，将根节点压入后，访问其左右孩子节点并压入，然后根节点出队列，依据队列的先进先出，再访问根节点的左孩子节点的孩子节点并压入，然后是根节点的右孩子节点的孩子节点压入，以此递推下去。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/level.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">level</span><span class="params">(vector&lt;T&gt;&amp; vec,binaryTreeNode&lt;T&gt; *root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		queue&lt;binaryTreeNode&lt;T&gt;*&gt; _que;</span><br><span class="line">		_que.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span>(!_que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="keyword">auto</span> t=_que.<span class="built_in">front</span>();</span><br><span class="line">			_que.<span class="built_in">pop</span>();</span><br><span class="line">			vec.<span class="built_in">push_back</span>(t-&gt;data);</span><br><span class="line">			<span class="keyword">if</span>(t-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">				_que.<span class="built_in">push</span>(t-&gt;lchild);</span><br><span class="line">			<span class="keyword">if</span>(t-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">				_que.<span class="built_in">push</span>(t-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="求树的深度">7.5.6 求树的深度</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">height</span><span class="params">(binaTreeNode&lt;T&gt;* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> hl=<span class="built_in">heught</span>(root-&gt;lchild);</span><br><span class="line">	<span class="type">size_t</span> hr=<span class="built_in">height</span>(root-&gt;rchild);</span><br><span class="line">	<span class="keyword">if</span>(hl&gt;hr)</span><br><span class="line">		<span class="keyword">return</span> hl++;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> hr++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="应用-2">7.6 应用</h5>
<h6 id="并查集-1">7.6.1 并查集</h6>
<p>在介绍链表时侯我们将来并查集的概念，知道<strong>在线等价类</strong>就是并查集。但是使用链表解决并查集不是最优解，这里我们介绍树来解决并查集问题。在在线等价类的问题当中，初始时有n个元素，每个元素都属于一个独立的等价类。需要执行以下的操作:</p>
<ul>
<li>①<code>conbine(a,b)</code>,把包含a,b的等价类合并为一个等价类</li>
<li>②<code>find(Element)</code>,确定元素<code>Element</code>在哪一个类，目的是对给定的两个元素，确定是否属于同一个类（同类，返回相同结果，否则不同）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">combine</span>(a,b)</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">classA=<span class="built_in">find</span>(a);</span><br><span class="line">classB=<span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span>(classA!=classB)</span><br><span class="line"><span class="built_in">unite</span>(classA,classB);</span><br></pre></td></tr></table></figure>
<p>并查集问题的求解策略：<strong>把每一个集合表示为一棵树。</strong></p>
<ul>
<li><strong>在查找时</strong>：把根元素作为集合标识符，因此find(a)返回的会是根元素。当且仅当a和b属于同一集合，<code>find(a)==find(b)</code>为真.</li>
<li><strong>在合并时</strong>：假设调用语句<code>unite(classA,classB)</code>,<code>classA</code>和<code>classB</code>分别是不同集合的根，为了把两集合合并，得让一颗树成为另一颗树的子树。<strong>合并采用重量规则：若根为i的树的结点数少于根为j的树的节点数，则将j作为i的父节点。否则，将i作为j的父节点。</strong></li>
</ul>
<p><strong>1. 重量规则使用的结构（顺序结构）</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重量规则使用的结构（顺序结构）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unionFindNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElementType data;</span><br><span class="line">	<span class="type">int</span> parent;	<span class="comment">///root为true时，表示树的重量，false时，为夫节点的指针(索引)</span></span><br><span class="line">	<span class="type">bool</span> root;</span><br><span class="line">	<span class="built_in">unionFindNode</span>()&#123;parent=<span class="number">1</span>;root=ture;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong>节点点内数字是<code>parent</code>的值,节点外的数字是该节点的索引，索引也同时是该节点所表示的元素，即中间的节点的元素值是下面一个节点的<code>parent</code>值（下面的<code>find</code>函数就说明了这一点）</p>
<p><strong>2. 构建重量规则的树（该树使用顺序结构的形式）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">int</span> numberOfElements)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//初始化numberiOfElements课树，每棵树包含一个元素</span></span><br><span class="line">	unionFindNode node=<span class="keyword">new</span> unionFindNode[unmberOfElements+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 查找</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回元素所在树的根</span></span><br><span class="line"><span class="comment">//theRoot是要返回的根，同时紧缩根到下标为index的节点路径上的节点到根的路径长度</span></span><br><span class="line">	<span class="type">int</span> theRoot=index;</span><br><span class="line">	<span class="keyword">while</span>(!node[theRoot].root)</span><br><span class="line">		theRoot=node[theRoot].parent;</span><br><span class="line">	<span class="type">int</span> currentNode=index;</span><br><span class="line">	<span class="keyword">while</span>(currentNode!=theRoot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> parentNode=node[currentNode].parent;</span><br><span class="line">		node[currentNode].parent=theRoot;</span><br><span class="line">		currentNode=parentNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> theRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 合并</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> rootA,<span class="type">int</span> rootB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node[rooaA].parent&lt;node[rootB].parent)</span><br><span class="line">	&#123;</span><br><span class="line">		node[rootB].parent+=node[rootA].parent;</span><br><span class="line">		node[rootA].root=<span class="literal">false</span>;</span><br><span class="line">		node[rootA].parent=rootB;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node[rootA].parent+=node[rootB].parent;</span><br><span class="line">		node[rootB].root=<span class="literal">false</span>;</span><br><span class="line">		node[rootB].parent=rootA;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="二叉树的右视图">7.6.2 二叉树的右视图</h6>
<h6 id="完全二叉树">7.6.3 完全二叉树</h6>
<h6 id="对称二叉树">7.6.4 对称二叉树</h6>
<h6 id="平衡二叉树">7.6.5 平衡二叉树</h6>
<h6 id="二叉树剪枝">7.6.6 二叉树剪枝</h6>
<h4 id="堆">8. 堆</h4>
<ul>
<li><strong>大根树/小根树</strong>：定义是指它的每个节点都大于/小于或等于其子节点的值。</li>
<li>大根堆/小根堆：一个大根堆/小根堆既是大根树/小根树，也是完全二叉树</li>
</ul>
<p>下图演示的堆的初始化和删除根节点的动态演示： <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/heapSort.gif" width="500"></p>
<h5 id="堆的操作">8.1 堆的操作</h5>
<h6 id="堆的插入">8.1.1 堆的插入</h6>
<p>因为<strong>堆是完全二叉树，所以当加入一个元素形时，必须维持该堆仍为完全二叉树</strong>，即该新节点位置由此定下了。接着元素插入要依据原来是大根堆还是小根堆（即不能破环该堆的性质）。把插入的元素，沿着从新节点到根节点的路径，执行一趟冒泡操作，将新元素与其夫节点的元素比较交换，直到后者大于前者（大根堆为例）。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该方法通过查询当前堆的大小和元素比较定位插入点，进行大根堆完全二叉树形式插入即`/2`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> currentNode=++heapsize;</span><br><span class="line">	<span class="comment">//通过比较寻找插入点，比插入值小的元素下沉</span></span><br><span class="line">	<span class="keyword">while</span>(currentNode!=<span class="number">1</span>&amp;&amp;heap[currentNode/<span class="number">2</span>]&lt;theElement)</span><br><span class="line">	&#123;</span><br><span class="line">		heap[currentNode]=heap[currentNode/<span class="number">2</span>];</span><br><span class="line">		currentNode/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入新值</span></span><br><span class="line">	heap[currenNode]=theElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="堆的删除">8.1.2 堆的删除</h6>
<p><strong>在大根堆中删除一个元素，其实就是删除根节点的元素</strong>。此时就需要重新组织，以便保持性质不变 。其策略是，从删除的位置开始为一个树,向下找，找到该树的最后一个叶子节点，删除该节点但保存元素到临时量；然后比较删除（这个删除只是指元素替换了，而不是前面那个销毁删除）节点的左右孩子，将大的放到该根节点；这时因为大孩子的被放到根节点而成为了空(没有元素），此时我们像之前一样比较该结点的左右孩子，将大的放到该结点，以此类推……，直到最后一个叶子我们与之前中间量保存的元素比较，完成删除排序，如下图所示（小根堆）： <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/heap.png" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">templaet&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(heapsize==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	heap[<span class="number">1</span>].~<span class="built_in">T</span>();		<span class="comment">//销毁根节点元素</span></span><br><span class="line">	T lastElement=heap[heapsize];	<span class="comment">//最后一个元素保存到临时变量</span></span><br><span class="line">	heap[heapsize--].~<span class="built_in">T</span>();			<span class="comment">//销毁最后一个元素</span></span><br><span class="line">	<span class="type">int</span> currentNode=<span class="number">1</span>,child=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;heapsize)</span><br><span class="line">	&#123;	<span class="comment">//元素进行上升</span></span><br><span class="line">		<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="comment">//判断lastElement是否可以放在heap[child]上</span></span><br><span class="line">		<span class="keyword">if</span>(lastElement&gt;=heap[child])	<span class="comment">//可以就直接退出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		heap[currentNode]=heap[child];</span><br><span class="line">		currentNode=child;</span><br><span class="line">		child*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currentNode]=lastElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong><em>附：</em></strong>若是指定位置或元素删除，也是一样的方法，先遍历定位要删除的元素，将其销毁，它的消耗只会影响到它的子树，而不会向上影响，因此只需要将子树的元素比较大小然后抬升即可，方法同删除根节点是一模一样的</p>
<h6 id="堆的初始化">8.1.3 堆的初始化</h6>
<p>初始化：当堆刚开始时就要有n个元素，我们就要构建非空堆，我们需要在堆中执行n次插入操作。先将元素按层次插入，取位置在i=n/2的元素，如果以这个元素为根的子树是大根堆则不做操作，如果不是大根堆则从该节点开始的树进行检测替换，依次检查i-1,i-2……1 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(T *theHeap,std::<span class="type">size_t</span> _heapsize)</span></span>&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]heap;</span><br><span class="line">	heap =theheap;</span><br><span class="line">	heapsize=_heapsize;</span><br><span class="line">	<span class="comment">//从下往上进行堆化，即从heapsize/2开始，直到root=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> root=heapsize/<span class="number">2</span>;root&gt;=<span class="number">1</span>;root--)</span><br><span class="line">	&#123;</span><br><span class="line">		T rootElement=heap[root];</span><br><span class="line">		<span class="type">int</span> child=<span class="number">2</span>*root;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;=heapsize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span>(rootElement&gt;=heap[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			heap[child/<span class="number">2</span>]=heap[child];</span><br><span class="line">			child*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[child/<span class="number">2</span>]=rootElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉搜索树">9. 二叉搜索树</h4>
<p>主要有二叉搜索树和索引二叉搜索树。二叉搜索树的查找、插入和删除操作的所需平均时间为O(log2n),最坏的情况为O(n)。对于给定一个关键字，使用二叉搜索树，可以在O(n)时间内，找到最接近它的关键字。二叉搜索树是一颗二叉树，可能为空，一颗非空的二叉搜索树满足以下特点：</p>
<ul>
<li>每个元素有一个关键字，并且任意两个元素的关键字都不同（有重复值的二叉搜索树除外），<strong>因此所有的关键字都是唯一的</strong></li>
<li><strong>在根节点的左子树中，元素的关键字(如果有的话）都小于根节点关键字</strong></li>
<li><strong>在根节点的右子树中，元素的关键字都大于根节点的关键字</strong></li>
<li>根节点的左右子树也都是二叉树</li>
</ul>
<h5 id="实现-5">9.1 实现</h5>
<h6 id="搜索">9.1.1 搜索</h6>
<p>要查找关键字为<code>theKey</code>的元素，先从根查找，如果根为空，则搜索树为空的；若不为空，则将<code>theKey</code>与根关键字比较大小，由二叉树搜索树的性质知，比根的大，则向右子数查找，若小，则向左子树查找，依次类推，直到找到或者到<code>NULL</code>为止。如下图查找<code>5</code> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/search.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">pair&lt;<span class="type">const</span> K,E&gt;*binarySearchTree&lt;K,E&gt;::<span class="built_in">find</span>(<span class="type">const</span> K&amp; theKey,</span><br><span class="line">	binaryTreeNode&lt;<span class="type">const</span>  K,E&gt;*p)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(theKey&lt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(theKey&lt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;rightChild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> &amp;p-&gt;element;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="插入">9.1.2 插入</h6>
<p>重复的关键字进行值更新，从根节点开始比较，直到遇到相同的关键或<code>NULL</code> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/insert.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="type">void</span> binarySearchTree&lt;K,E&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;<span class="type">const</span> K,E&gt;&amp;</span><br><span class="line">thePair,binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt; *p)</span><br><span class="line">&#123;</span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt; *pp=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pp=p;</span><br><span class="line">		<span class="keyword">if</span>(thePair.first&lt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(thePair.first&gt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;rightChild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;element.second=thePair.second;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt; *newNode</span><br><span class="line">		=<span class="keyword">new</span> binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;(thePair);</span><br><span class="line">	<span class="keyword">if</span>(rootNode==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode=newNode;</span><br><span class="line">		rootNode-&gt;leftChild=rootNode-&gt;rightChild=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(pp-&gt;element.first&lt;thePair.first)</span><br><span class="line">		pp-&gt;rightChild=newNode;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		pp-&gt;leftChild=newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	stSize++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从上面的程序来看，二叉搜索树如果不添平衡操作容易退化成单链表，那么这是就会造成结构的失效，下一节我们会介绍一个平衡的办法。</p>
<h6 id="删除">9.1.3 删除</h6>
<p>假设要删除接节点<code>p</code>，我们要考虑三种情况：<strong>①<code>p</code>是叶子；②<code>p</code>只有一颗非空子树；③<code>p</code>有两颗非空子树</strong></p>
<ul>
<li>第一种情况非常好做，只有释放叶子节点的空间即可，若是根节点，置为<code>NULL</code> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/one.gif" width="500"></li>
<li>第二种情况也较为简单 ，如果<code>p</code>是根节点，则<code>p</code>的唯一子树的根节点成为新的搜索树的根节点。若<code>p</code>有父节点<code>pp</code>，则修改<code>pp</code>的指针域，使它指向<code>p</code>的唯一孩子，然后释放节点<code>p</code> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/two.gif" width="500"></li>
<li>第三种情况较复杂，我们先将该节点的元素替换为它左子树的最大元素（或者右子树的最小的一个元素）。然后把替换的节点删除，该删除的结点如果有左子树，则该左子树变为该结点的双亲的右子树（或者删除的结点如果有右子树，则该右子树变为该结点的双亲的左子树） <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/three.gif" width="500"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="type">void</span> binarySearchTree&lt;K,E&gt;::<span class="built_in">erase</span>(<span class="type">const</span> K&amp; theKey)</span><br><span class="line">&#123;</span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;* p=rootNode,*pp=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p.element.first!=theKey)</span><br><span class="line">	&#123;											<span class="comment">//定位关键值相等的节点</span></span><br><span class="line">		pp=p;</span><br><span class="line">		<span class="keyword">if</span>(p.element.first&lt;theKey)<span class="number">8</span> </span><br><span class="line">		p=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		p=p-&gt;rightChild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)	<span class="comment">//不存在</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;leftChild!=<span class="literal">NULL</span>&amp;&amp;p-&gt;rightChild!=<span class="literal">NULL</span>)		<span class="comment">//第三种情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;* theMaxNode=p-&gt;leftNode,*s=p;</span><br><span class="line">		<span class="keyword">while</span>(theMaxNode-&gt;rightChild!=<span class="literal">NULL</span>)	<span class="comment">//寻找左子树最大值进行替换</span></span><br><span class="line">		&#123;</span><br><span class="line">			s=theMaxNode;</span><br><span class="line">			theMaxNode=theMaxNode-&gt;rightChild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//p-&gt;element=theMaxNode-&gt;element;  无法这样移动，因为key是常量</span></span><br><span class="line">		binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;* q=<span class="keyword">new</span> binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;</span><br><span class="line">			(theMaxNode-&gt;element,p-&gt;leftChild,p-&gt;rightChild);		<span class="comment">//这样移动合法</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pp==<span class="literal">NULL</span>)		<span class="comment">//即删除的是根节点的情况</span></span><br><span class="line">			rootNode=q;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p==pp-&gt;leftNode)		<span class="comment">//不是根节点，判断p是pp的左树还是右树</span></span><br><span class="line">			pp-&gt;leftChild=q;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pp-&gt;rightChild=q;</span><br><span class="line">		<span class="keyword">if</span>(s==p) q-&gt;leftChild=theMaxNode-&gt;leftChild;</span><br><span class="line">			<span class="keyword">delete</span> p;</span><br><span class="line">		p=s						<span class="comment">//为简化下面判断if(p-&gt;leftChild!=NULL)语句</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;*c;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;leftChild!=<span class="literal">NULL</span>)</span><br><span class="line">		c=p-&gt;leftChild;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		c=p-&gt;rightChild;</span><br><span class="line">	<span class="comment">//删除p</span></span><br><span class="line">	<span class="keyword">if</span>(p==rootNode)</span><br><span class="line">		rootNode=c;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p==pp-&gt;leftChild)</span><br><span class="line">			pp-&gt;leftChild=c;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pp-&gt;rightChild=c;</span><br><span class="line">	&#125;</span><br><span class="line">	stSize--;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="平衡二叉搜索树avl">10. 平衡二叉搜索树AVL</h4>
<p>如果搜索树的高度总是<code>O(logn)</code>，我们能保证查找、插入、删除的时间为<code>O(logn)</code>。最坏情况下的高度为O(logn)的树为<strong>平衡树（balanced tree)</strong>。<strong>但是正如上面搜索树所讲的，在大量的插入后搜索树极其容易不平衡导致元素大量在一个分支上，退化成链表，这时候查找、插入、删除的时间复杂的就不为<code>O(logn)</code></strong>。平衡二叉搜索树就是为解决这个问题而得出的数据结构。</p>
<h5 id="平衡二叉搜索树的定义">10.1 平衡二叉搜索树的定义</h5>
<p>一颗空的二叉树是AVL树；如果T是一颗非空的二叉树，<code>T1</code>和<code>T2</code>分别是其左子树和右子数，那么当<code>T</code>满足以下条件时，<code>T</code>是一颗AVL树：</p>
<ul>
<li>①<code>T1</code>和<code>T2</code>是AVL树；</li>
<li>②<code>|hl-hr|≤1</code>，其中<code>hl</code>和<code>hr</code>分别是<code>Tl</code>和<code>TR</code>的高。</li>
</ul>
<p>一颗AVL搜索树既是二叉搜索树，也是AVL树。如果用AVL搜索树来描述字典，并在对数级时间内完成每一种字典操作，那么，我们必须确定AVL树的下列特征：</p>
<ul>
<li><strong>一颗<code>n</code>个元素的AVL树，其高度是<code>O(logn)</code></strong></li>
<li>对于每一个<code>n.n≥0</code>，都存在一颗AVL树</li>
<li>对一颗<code>n</code>元素的AVL搜索树，在<code>O(高度)=O(logn)</code>的时间内可以实现查找</li>
<li><strong>将一个新元素插入一颗<code>n</code>元素AVL搜索树种，可以得到一颗<code>n+1</code>元素的AVL树，且插入用时为<code>O(logn)</code></strong></li>
<li><strong>一个元素从一颗<code>n</code>元素的AVL搜索树删除，可以得到一颗<code>n-1</code>的AVL搜索树，而且用时为<code>O(logn)</code></strong></li>
</ul>
<p><strong>AVL树的描述：</strong>AVL树一般用链表进行描述，为简化插入和删除操作，我们为每一个节点添加一个平衡因子<code>bf</code>，假设x的左子树高度为<code>hl</code>,右子树高度为<code>hr</code>，节点<code>x</code>的平衡因子<code>bf(x)</code>定义为：</p>
<ul>
<li><code>bf(x)=hl-hr</code></li>
<li><code>bf(x)</code>取值只能为<code>0，-1，1</code></li>
</ul>
<p><img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/balanceTree.png" width="500"></p>
<p>这里主要讲解平衡二叉搜索树的搜索、插入和删除操作。</p>
<h5 id="搜索-1">10.2 搜索</h5>
<p>同二叉搜索树一样的操作，<code>n</code>元素的AVL树的高度是<code>O(logn)</code>，所以搜索时间为<code>O(logn)</code>。要查找关键字为theKey的元素，先从根查找，如果根为空，则搜索树为空的；若不为空，则将theKey与根关键字比较大小，由二叉树搜索树的性质知，比根的大，则向右子数查找，若小，则向左子树查找，依次类推，直到找到或者到<code>NULL</code>为止。如下图查找<code>5</code>。实现略</p>
<h5 id="插入操作">10.3 插入操作</h5>
<p>AVL树因为要保证每个结点的平衡因子要时时刻刻都符合要求，则树中每插入一个结点，都可能引起平衡被打破，所以每次插入一个结点，<strong>都要从插入的结点往上进行检查是否有哪个结点需要调整。要在插入新结点后进行平衡检查，则需要把插入结点的插入过程的下行路线上的每一个结点都依次记录下来，这个可以借助于栈来实现，在查找插入位置的过程，把每一个结点指针放入栈中</strong>．</p>
<h6 id="插入的具体步骤">10.3.1 插入的具体步骤</h6>
<ul>
<li><strong>第一步：</strong>从根结点开始，首先查找要插入的位置。如果结点值相等则更新，如果小于则向左走，如果大于则向右走，把这个过程中的每一个结点都放入一个栈中，这样直到到达叶子结点，即找到了插入的位置．然后<code>new</code>出来一个结点进行插入</li>
<li><strong>第二部</strong>：插入完成以后进行平衡调整。取出栈中的元素进行检查：插入的结点对于取出的结点如果是左边插入，则平衡因子<code>+１</code>，如果右边插入则平衡因子<code>-１</code>．</li>
<li><strong>第三步1</strong>：如果加减<code>１</code>以后平衡因子是<code>０</code>，即意味着插入节点之前平衡因子只能是<code>±１</code>，插入该节点以后，该子树的左右子树高度相等，因此并不改变该子树的高度，也就并不影响整棵树的高度，所以树是平衡的，不需要<strong>第三步2</strong>：调整，调整结束<code>break</code> ；</li>
<li><p>如果插入后平衡因子是<code>+1</code>或者<code>-1</code>，则意味着该节点所在的子树的高度发生变化（因为在此之前该节点的平衡因子只能是０），所以以该节点为root的子树的高度一定是增加了，所以要向上继续检查是否有哪个节点的平衡因子因为插入了一个节点平衡因子变为<code>±２</code>，所以继续取出stack中的下一个节点进行上述同样的检查</p></li>
<li><strong>第四步</strong>：如果平衡因子是正负２，则平衡打破，需要进行调整，下面详述调整过程：
<ul>
<li>１．<code>bf=-2</code>: 如果该节点的孩子节点平衡因子是负值：则对该节点进行一次左旋转即调整完成；如该该节点的孩子节点的平衡因子是正值：则需要进行先左后右旋转．</li>
<li>２．<code>bf=+2:</code>如果该孩子节点<code>bf</code>是正值：则对该节点进行一次右旋转即可；如果孩子节点<code>bf</code>是负值：则对该节点进行先右后左旋转即可．</li>
</ul></li>
</ul>
<p>调整平衡完成以后需要将该子树的新根节点挂到之前的根节点下面．以上即整个插入过程．</p>
<h6 id="失衡的情况">10.3.2 失衡的情况</h6>
<p>如果按二叉搜索树的插入算法会影响AVL树将不在是AVL树。如下图按二叉搜索树的方式将32插入VAL搜索树而导致失衡 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/compare.png" width="500"> 因此，插入操作必须维护各节点的<code>|bf|≤1</code>。<strong>插入破环原AVL搜索二叉树结构是以下情形：</strong></p>
<ul>
<li>在不平衡树中，平衡因子的值限于<code>2，1，0，-1，-2</code></li>
<li>平衡因子为<code>2</code>的节点插入前平衡因子为<code>1</code>，同样<code>-2</code>的插入前为<code>-1</code></li>
<li><strong>只有从根到新插入节点路径上的节点，其平衡因子在插入后会改变</strong></li>
<li><strong>假设<code>A</code>是离新插入节点最近的</strong>祖先<strong>，且平衡因子是<code>-2</code>或<code>2</code>（在上面的图中A是关键字为40的节点），在插入前，从<code>A</code>到新插入节点的路径上，所有节点的平衡因子都是0</strong></li>
</ul>
<p>对于平衡与失衡的判断存在与否，主要就是看<code>A</code>这一节点存不存在，即平衡因子变为<code>2</code>或<code>-2</code>的最近祖先节点存在与否：</p>
<p><strong><code>A</code>节点不存在</strong>：那么从根节点至新插入节点的途中，所有节点在插入前的平衡因子都为<code>0</code>或者为-1但插入左则或者为1但插入右侧，由于插入操作平衡因子增减0或1，所以从根节点到插入新节点的途径的节点平衡因子可能改变，但树的平衡不会改变。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/Aisnot.png" width="500"></p>
<h6 id="失衡的种类">10.3.3 失衡的种类</h6>
<p><strong><code>A</code>节点存在</strong>：就出现平衡因子<code>|bf|=2</code>的情况，破坏了平衡，此时就需要进行平衡操作。其不平衡的情况有两类</p>
<ul>
<li><code>L</code>型不平衡,新插入的节点在A的左子树中</li>
<li><code>R</code>型不平衡,新插入的节点在A的右子树中</li>
</ul>
<p>同时，从根到新插入节点的路径上，根据A的孙节点情况，还可在细分（包含新节点的A的子树高度至少为2，因为有定义知A的平衡因子为2或-2,A才存在孙节点），此时细分为<code>LL,LR,RL,RR</code>。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/four.png" width="500"></p>
<ul>
<li><ol type="1">
<li><code>6</code>节点的左子树<code>3</code>节点高度比右子树<code>7</code>节点<strong>大<code>2</code></strong>，左子树<code>3</code>节点的左子树<code>1</code>节点高度<strong>大于</strong>右子树<code>4</code>节点，这种情况成为左左<code>LL</code>(左孩子的左子树深度大)。</li>
</ol></li>
<li><ol start="2" type="1">
<li><code>6</code>节点的左子树<code>2</code>节点高度比右子树<code>7</code>节点<strong>大<code>2</code></strong>，左子树<code>2</code>节点的左子树<code>1</code>节点高度<strong>小于</strong>右子树<code>4</code>节点，这种情况成为左右<code>LR</code>。</li>
</ol></li>
<li><ol start="3" type="1">
<li><code>2</code>节点的左子树<code>1</code>节点高度比右子树<code>5</code>节点<strong>小<code>2</code></strong>，右子树<code>5</code>节点的左子树<code>3</code>节点高度<strong>大于</strong>右子树<code>6</code>节点，这种情况成为右左<code>RL</code>。</li>
</ol></li>
<li><ol start="4" type="1">
<li><code>2</code>节点的左子树<code>1</code>节点高度比右子树<code>4</code>节点<strong>小<code>2</code></strong>，右子树<code>4</code>节点的左子树<code>3</code>节点高度<strong>小于</strong>右子树<code>6</code>节点，这种情况成为右右<code>RR</code>。</li>
</ol></li>
</ul>
<h6 id="ll型平衡操作">10.3.4 LL型平衡操作</h6>
<p><strong>右旋：</strong>在最小平衡子树根节点平衡因子&gt;=2且在根节点的左孩子的左孩子插入元素即<code>LL</code>，要进行右旋 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rightxuan.gif" width="500"> 右旋如上所示，绕<code>|bf|=2</code>的节点（以下统称为<code>root</code>）进行旋转，根节点的左孩子成为新的根节点，而原来的<code>root</code>成为其右孩子，同时若新的根节点原来的右子树成为<code>root</code>的左子树,如下 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rightxuan.png" width="500"></p>
<h6 id="rr型平衡操作">10.3.5 RR型平衡操作</h6>
<p>在最小平衡子树根节点<code>bf&gt;=-2</code>且在根节点的右孩子的右孩子插入元素，进行<strong>左旋。</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/leftxuan.gif" width="500"> 其动作与<code>LL</code>一样，只不过方向相反。</p>
<h6 id="lr型平衡操作">10.3.6 LR型平衡操作</h6>
<p>在最小平衡子树根节点<code>80</code>的左孩子<code>50</code>的右孩子<code>70</code>的子节点插入新元素，先绕根节点的左孩子节点<code>50</code>右旋，再围根节点<code>80</code>左旋 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/lr.png" width="600"></p>
<h6 id="rl型平衡操作">10.3.7 RL型平衡操作</h6>
<p>最小平衡子树根节点<code>80</code>的右孩子<code>100</code>的左孩子<code>90</code>的子节点<code>95</code>插入新元素，先绕根节点的右孩子节点<code>100</code>右旋，再围根节点<code>80</code>左旋 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rl.png" width="600"> 其动态展示如下： <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rl.gif" width="500"></p>
<h5 id="删除操作">10.4 删除操作</h5>
<h6 id="删除节点">10.4.1 删除节点</h6>
<p>执行二叉搜索树得删除操作，AVL树删除节点，首先查找要删除的节点，找到以后，要删除的节点分为两种情况：</p>
<ul>
<li>１.要删除的节点左右两个孩子都存在，直接删除不方便，则在右子树中查找最小的节点，将其值替换为要删除的节点的值，因为右子树的最小节点必然没有左孩子，即只有一个孩子．然后问题转化为删除这个右子树中最小的节点．（或者也可以将问题转化为删除左子树里最大的节点）</li>
<li>２.要删除的孩子节点只有一个孩子节点，则直接将仅有的一个孩子节点提上来即可．</li>
</ul>
<h6 id="平衡性检查">10.4.2 平衡性检查</h6>
<p>删除以后将进行从删除节点向上进行平衡性的检查。<strong>在查找要删除的节点的过程中，将经过的路径上的节点位置全部存放到一个<code>stack</code></strong>。在平衡型检查过程种取出栈顶元素<code>pr</code>并弹出栈顶元素，如果删除的节点<code>pr</code>的<code>key</code>值比该节点的<code>key</code>值小,则必定是左树删除则<code>pr-&gt;bf-1</code>了，否则<code>pr-&gt;bf+1</code>。会造成以下三种情况：</p>
<ul>
<li>１．删除后如果<code>|pr-&gt;bf|=1</code>：则在删除节点之前<code>pr-&gt;bf０</code>，即左右平衡，<strong>删除了以后左树或者右树少了一个节点，但<code>pr</code>这个子树的高度并没发生变化．对与pr的上面的所有节点而言树高并没有发生变化，所以调整完成．</strong></li>
<li>２．如果删除后|pr-&gt;bf|=０<code>,则在删除之前平衡因子是</code>±１<code>，现在删除节点以后变为</code>０<code>，则</code>pr<code>子树的高度减</code>１`（发生了变化，影响到了上面的节点），则要向上（出栈）继续检查，</li>
<li>３．如果删除后造成<code>|pr-&gt;bf|==２</code>,则平衡打破，进行平衡调整.</li>
</ul>
<h4 id="红黑树">11. 红黑树</h4>
<p>平衡索引二叉树是高度平衡的二叉树，频繁的插入和删除，会引起频繁的<code>rebalance</code>,导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转的数据结构，所以红黑树在查找，插入删除的性能都是接近<code>O(logn)</code>,且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RB树的节点结构:</span><br><span class="line"><span class="comment">//由于红黑树的各种操作常需要上溯其父级节点，因此特别安排一个parent指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> _rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> _rb_tree_color_type _rb_tree_red=<span class="literal">false</span>;	<span class="comment">//红色为0</span></span><br><span class="line"><span class="type">const</span> _rb_tree_color_type _rb_tree_black=<span class="literal">true</span>;	<span class="comment">//黑色为1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_color_type	 color_type;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node_base*	 base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span>				 value_type;</span><br><span class="line">	</span><br><span class="line">	color_type color;		<span class="comment">//结点颜色</span></span><br><span class="line">	base_ptr parent;		<span class="comment">//父节点指针</span></span><br><span class="line">	base_ptr left;</span><br><span class="line">	base_ptr right;</span><br><span class="line">	value_type value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="红黑树特点">11.1 红黑树特点</h5>
<p><strong>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍</strong>，因此，红黑树是一种<strong>弱平衡二叉树</strong>，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。红黑树具有以下的性质：</p>
<ul>
<li>每个节点非红即黑</li>
<li><strong><code>RB1</code>：根节点是黑的;</strong></li>
<li><strong><code>RB1</code>：每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</strong></li>
<li><strong><code>RB2</code>：</strong>如果一个节点是红色的，则它的子节点必须是黑色的，即红节点不能连续**</li>
<li><strong><code>RB3</code>：</strong>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</li>
</ul>
<p><strong>一个节点的阶</strong>是指从该节点到一外部节点路径上黑色指针的数量，定理：</p>
<ul>
<li>设根到外部节点的路径长度length是该路径上的指针数量。如果P和Q是红-黑树中的两条从根至外部节点的路径，那么<code>length(P)≤2length(Q)</code></li>
<li>令<code>h</code>是一颗红-黑树的高度（不包括外部节点），<code>n</code>是树的内部节点数量，而<code>r</code>是根节点的阶，则有:
<ul>
<li>①<code>h≤2r</code></li>
<li>②<code>n≥2^r-1</code></li>
<li>③<code>h≤2log2(n+1)</code></li>
</ul></li>
</ul>
<h5 id="红黑树操作">11.2 红黑树操作</h5>
<ul>
<li><strong>搜索：</strong>使用普通的二叉搜索树的搜索代码。对红黑树来说，时间复杂度为<code>O(logn)</code>。比较而言，二叉搜索树、AVL、红黑树搜索都使用相同代码，而且在最坏的情况下AVL树的高度是最小的，所以在搜索为主的应用中，avl是最优的。</li>
<li><strong>插入：</strong>红黑树的插入使用的是普通二叉搜索树插入算法，对插入的元素，需要上色。如果插入前树是空的，那么新节点是根节点，颜色应是黑色。</li>
</ul>
<p><strong>对红黑树的插入删除要维护其原本的性质：</strong>假设插入前的树是非空的，如果新节点的颜色是黑色，那么从根到外部节点路径上，将有一个特殊的黑色节点作为新节点的孩子。如果新节点是红色，那么可能出现两个连续的红色节点。所以把新节点赋为黑色肯定不符合<code>RB3</code>，而把新节点赋为红色虽然一定符合<code>RB3</code>,但可能违反了<code>RB2</code>。对红黑树的插入删除要维护其原本的性质。</p>
<h6 id="赋为红色而造成的不平衡类型">11.2.1 赋为红色而造成的不平衡类型</h6>
<p>如果是新节点赋为红色而造成<code>RB2</code>规则被破坏，我们就说树的平衡杯破坏了。<strong>此时平衡破坏则必有有两连续红色节点，一个是新节点<code>u</code>,一个是其父结点<code>pu</code>。而此时祖父节点<code>gu</code>一定是黑色的</strong>。有以下情况</p>
<ul>
<li>当<code>pu</code>是<code>gu</code>的左孩子，<code>u</code>也是<code>pu</code>的左孩子时且<code>gu</code>的另一个孩子（右孩子）是黑色的（为外部节点），该不平衡类型为<code>LLb</code>类型。</li>
<li>当<code>pu</code>是<code>gu</code>的左孩子，<code>u</code>是<code>pu</code>的左孩子时且<code>gu</code>的另一个孩子（右孩子）是红色的（不是外部节点），该不平衡类型为<code>LLr</code>类型。</li>
</ul>
<p>依次类推出<code>LRb、LRr、RRb、RRr、RLb、RLr</code></p>
<p><strong>平衡方法；</strong></p>
<ul>
<li><p><code>XYr</code>型的不平衡<strong>可以通过改变颜色来处理</strong>：将<code>pu</code>节点变为黑色，对于LLr和LRr的<code>gu</code>的右孩子要由红色变为黑色，另外如果gu不是根则改为红色，如果是根节点则保持gu为黑色不变；<strong>因为<code>gu</code>由黑变红的情况可能导致上一层平衡破坏，如果破坏了（即原<code>gu</code>与<code>gu</code>父结点都为红）此时将<code>gu</code>变为<code>u</code>,<code>gu</code>父结点变为<code>pu</code>,<code>gu</code>祖父节点为<code>gu</code>,分析是<code>XYr</code>类型还是<code>XYb</code>类型，继续恢复平衡操作。</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/blackRed.png" width="600"></p></li>
<li><p>XYb型则需要旋转。插入后依次旋转足以保持平衡。<strong>该旋转的改变同AVL相似</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/brxuan.png" width="600"></p></li>
</ul>
<p><strong><em>附：</em></strong>对于删除操作，首先使用二叉搜索树的删除算法。然后进行颜色变动，需要的话还要进行一次旋转。 - 删除红色节点，不会影响规则，只需将相应的需要变色的指针变色即可。 - 删除黑色节点，会影响RB3（不是根节点时）。使用该删除算法，不会违反除RB3外的其它红黑树规则。</p>
<p><a href="https://blog.csdn.net/cy973071263/article/details/122543826">红黑树详解</a></p>
<h4 id="图">12. 图</h4>
<p><strong>图是一个用线或边连接在一起的节点(顶点）的集合。严格地说图是有限集<code>V</code>和<code>E</code>的有序对<code>G=(V,E)</code>。<code>V</code>中的元素为顶点，<code>E</code>为边。</strong>对于图我们需要先了解以下预备知识：</p>
<ul>
<li>图的术语：顶点、边、邻接、关联、度、回路、路径、连通构件、<strong>生成树</strong></li>
<li>图的类型：无向图、有向图和加权图</li>
<li>常用描述方法：邻接矩阵、<strong>矩阵邻接表和邻接链表</strong></li>
<li><strong>图的标准搜索方法：广度优先搜索和深度优先搜索</strong></li>
<li>图的算法：寻找图的路径、寻找无向图的联通构件、<strong>寻找连通无向图的生成树</strong></li>
</ul>
<h5 id="图的基本概念">12.1 图的基本概念</h5>
<ul>
<li>每一条边连接两个顶定，用元组<code>(i,j)</code>表示，<code>i\j</code>表示连接的顶点。带方向的叫有向边，不带方向叫无向边。</li>
<li>当且仅当<code>(i,j)</code>是图的边，称顶定<code>i</code>和<code>j</code>是<strong>邻接</strong>的。边<code>(i,j)</code>关联</li>
<li>如果图的所以边都是无向的，则称图为无向图；都是有向的为有向图</li>
<li>一个图不能有重复的边，即任意两个顶点，在无向图只有一条边，有向图是<code>i</code>到<code>j</code>即<code>(i,j)</code>,<code>j</code>到<code>i</code>即<code>(j,i)</code>各一条</li>
<li>为每条边赋予值，成为权。此时成为加权有向图和加权无向图</li>
<li>简单路径：除最后一个和第一个顶点之外，其余所有顶点都要求不同（如521，525）</li>
<li><strong>环路：一条始点和终点相同的简单路径</strong></li>
<li><strong>连通：图的每一对顶点之间都有一条路径</strong></li>
<li><strong>生成树：没有环路的连通无向图是一颗树。一个G的子图，包含G的所有顶点，且为一棵树，则称为G的生成树</strong></li>
<li>二分图：顶点被分为两个子集A，每条边都有一个顶点在A，另一个在B</li>
<li><strong>度：一个顶点相关联的边数</strong></li>
</ul>
<h5 id="无权图的描述">12.2 无权图的描述</h5>
<p>无向图最常用的描述方法都是基于邻接的方式，如<strong>邻接矩阵、邻接链表和邻接数组</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">graph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">graph</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">numberOfVertices</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;	<span class="comment">//顶点数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">numberofEdge</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;		<span class="comment">//边数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">exitsEdge</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span>)</span><span class="type">const</span></span>=<span class="number">0</span>;	<span class="comment">//判断两顶点是否关联</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">insertEdg</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>=<span class="number">0</span>;			<span class="comment">//添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eraseEdge</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>=<span class="number">0</span>;			<span class="comment">//删除边</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">degree</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>=<span class="number">0</span>;			<span class="comment">//指定顶点的度</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">inDegree</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> </span>=<span class="number">0</span>;			<span class="comment">//入度</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">outDegree</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>=<span class="number">0</span>;			<span class="comment">//出度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/graph.png" width="200"></p>
<h6 id="邻接矩阵">12.2.1 邻接矩阵</h6>
<p>一个<code>n</code>顶点图<code>G=(V,E)</code>的邻接矩阵是一个<code>n*n</code>矩阵，其中每个元素是<code>0</code>或<code>1</code>（对角线上的元素都为0，因为没有自连边）。将矩阵映射到一个<code>n*n</code>布尔型二维数组进行存储。因为无向图的邻接矩阵是对称的即<code>A(i,j)=A(j,i)</code>，所以只需存储上三角或下三角元素。因为采用布尔类型1字节，所以共用了<code>n^2</code>字节。</p>
<ul>
<li><strong>优势：</strong>因为无向图的邻接矩阵是对称的即<code>A(i,j)=A(j,i)</code>，所以只需存储上三角或下三角元素。无向图的度为所在行（或列）的元素和。同时对于有向图，出度为该行的元素和，入度为该列的元素和</li>
<li><strong>缺点：</strong>内存空间浪费</li>
</ul>
<h6 id="邻接链表">12.2.2 邻接链表</h6>
<p><strong>一个顶点<code>i</code>的邻接表是一个线性表，它包含了所有邻接i的顶点。在一个图的邻接表中，图的每一个顶点都有一个邻接表。当邻接表用链表表示时，就是邻接链表</strong>。 我们可使用类型为链表的数组<code>aList</code>来描述所有邻接表（指针数组）。<code>aList[i]-&gt;next</code>指向顶点<code>i</code>的邻接表的第一个顶点的数组下标索引<code>index</code>，通过访问<code>aList[index]</code>得到该点的邻接表，<code>(i,index)</code>是图的一条边。。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/linList.png" width="500"></p>
<p>一个指针和一个整数需要4字节的存储空间，顶点需要<code>8(n+1)</code>(为了数组下标对应，不使用下标0的空间，所以<code>n+1</code>)字节存储<code>n+1</code>个<code>next</code>指针和<code>index</code>域。</p>
<h6 id="邻接数组">12.2.3 邻接数组</h6>
<p>在邻接数组中同邻接链表相似，只不过每一个邻接表用一个<strong>数组线性表如vector</strong>而非链表来描述。</p>
<h5 id="链表类的实现">12.3 链表类的实现</h5>
<p>下面的程序给出了邻接链表的的数据成员和一些实现方法，仅供参考，构造函数的时间复杂度为<code>O(n)</code>，方法<code>existsEdgr(i,j)</code>的时间复杂度为<code>O(d^out)</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">linkedDigraph</span>:<span class="keyword">public</span> graph&lt;<span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> n;		<span class="comment">//顶点数</span></span><br><span class="line">	<span class="type">int</span> e;		<span class="comment">//边数</span></span><br><span class="line">	vector&lt;List&gt; vlist;	<span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">linkedDigraph</span>(<span class="type">int</span> numberOfv=<span class="number">0</span>)</span><br><span class="line">	&#123;	<span class="comment">//构造函数</span></span><br><span class="line">		<span class="keyword">if</span>(numberOfv&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">illegalParameterValue</span>(<span class="string">&quot;Number of vertices must be &gt;=0)</span></span><br><span class="line"><span class="string">		n=numberOfv;</span></span><br><span class="line"><span class="string">		e=0;</span></span><br><span class="line"><span class="string">		aList=new graphChain&lt;int&gt;[n+1];</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//析构函数</span></span><br><span class="line"><span class="string">	~linkedDigraph()&#123;delete[] aList;&#125;</span></span><br><span class="line"><span class="string">	//边是否存在</span></span><br><span class="line"><span class="string">	bool existsEdge(int i,int j)const</span></span><br><span class="line"><span class="string">	&#123;//当且仅当(i,j)时返回treu</span></span><br><span class="line"><span class="string">		if(i&lt;1||j&lt;1||i&gt;n||j&gt;n||vList[i].indexOf(j)==-1)</span></span><br><span class="line"><span class="string">			return false;</span></span><br><span class="line"><span class="string">		else</span></span><br><span class="line"><span class="string">			return true;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//插入边</span></span><br><span class="line"><span class="string">	void insertEdge(int i，int j)</span></span><br><span class="line"><span class="string">	&#123;</span></span><br><span class="line"><span class="string">		if(aLsit[i].indexOf(j)==-1)</span></span><br><span class="line"><span class="string">		&#123;</span></span><br><span class="line"><span class="string">			//新边</span></span><br><span class="line"><span class="string">			aList[i].Insert(j);</span></span><br><span class="line"><span class="string">			aList[j].Insert(i);</span></span><br><span class="line"><span class="string">			e++;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;；</span></span><br></pre></td></tr></table></figure></p>
<h5 id="图的遍历">12.4 图的遍历</h5>
<p>图的遍历有<strong>广度优先搜索(BFS)</strong>和<strong>深度优先搜索(DFS)</strong>两种</p>
<h6 id="广度优先搜索bfs">12.4.1 广度优先搜索(BFS)</h6>
<p>广度优先搜索(BFS),从一个顶点开始，搜索该顶点所有可到达顶点的，新顶点再重复搜索可到达的顶点的方法(已到达的标记为已达，避免重复到达记录，因为顶点是<code>1~n</code>,可使用<code>record[u]=0</code>(未到达)/<code>lable</code>(已到达),<code>u</code>为<code>1~n</code>）。<strong>这种搜索性质可使用队列实现</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">arrayQueue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	reach[v]=label;</span><br><span class="line">	q.<span class="built_in">push</span>(v);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> w=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vertexIterator&lt;T&gt;*iw=<span class="built_in">iterator</span>(w);</span><br><span class="line">		<span class="type">int</span> u;</span><br><span class="line">		<span class="keyword">while</span>((u=iw-&gt;<span class="built_in">next</span>())!=<span class="number">0</span>)	<span class="comment">//u的相邻点，无则返回0</span></span><br><span class="line">			<span class="keyword">if</span>(reach[u]==<span class="number">0</span>)		<span class="comment">//相邻点是没有到达过的</span></span><br><span class="line">			&#123;</span><br><span class="line">				q.<span class="built_in">push</span>(u);</span><br><span class="line">				reach[u]=label;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">delete</span> iw;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="深度优先搜索dfs">12.4.2 深度优先搜索(DFS)</h6>
<p>深度优先搜索(DFS).从一个顶点<code>v</code>出发，首先将v标记为已到达，后选择一个邻接于<code>v</code>的尚未到达的顶点<code>u</code>。<code>u</code>再重复上述操作，直到新<code>u</code>不存在，即无法找到<code>u</code>。---&gt;<strong>一次搜一个/递归/或栈来实现</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	graph&lt;T&gt;::reach=reach;</span><br><span class="line">	graph&lt;T&gt;::label=label;</span><br><span class="line">	<span class="built_in">rDfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rDfs</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//递归</span></span><br><span class="line">	<span class="built_in">reach</span>(v)=label;</span><br><span class="line">	vertexIterator&lt;T&gt;*iv=<span class="built_in">iterator</span>(v);</span><br><span class="line">	<span class="type">int</span> u;</span><br><span class="line">	<span class="keyword">while</span>((u=iv-&gt;<span class="built_in">next</span>())!=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span>(reach[u]==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">rDfs</span>(u);</span><br><span class="line">	<span class="keyword">delete</span> iv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="图的应用">12.5 图的应用</h5>
<h6 id="最短路径">12.5.1 最短路径</h6>
<p>主要讨论带权有向图，将路径上的第一个顶点称为源点，最后一个顶点为终点。</p>
<p><strong>1. 迪杰斯特拉算法</strong></p>
<p><strong>迪杰斯特拉算法是求从某个源点到其余各顶点的最短路径</strong>的算法。该算法思想是<strong>按路径长度递增的次序产生一个最短路径</strong>。描述要借助两个集合<code>S、U</code></p>
<ul>
<li><ol type="1">
<li>初始时，<code>S</code>只包含起点<code>s</code>；<code>U</code>包含除<code>s</code>外的其他顶点，且<code>U</code>中顶点的距离为<strong>起点s到该顶点的距离</strong>(例如，<code>U</code>中顶点<code>v</code>的距离为<code>(s,v)</code>的长度，如果<code>s</code>和<code>v</code>不相邻，则<code>v</code>的距离为<code>∞</code>]。</li>
</ol></li>
<li><ol start="2" type="1">
<li>从U中选出<strong>距离最短的顶点k</strong>，并将顶点k加入<code>S</code>中；同时，从<code>U</code>中移除顶点k。</li>
</ol></li>
<li><ol start="3" type="1">
<li>更新<code>U</code>中各个顶点到起点<code>s</code>的距离。这是由于上一步中确定了<code>k</code>是求出最短路径的顶点，从而可以利用<code>k</code>来更新其它顶点的距离；例如，<code>l(sv)&gt;l(sk)+l(kv)</code>,那么就得用<code>l(sk)+l(kv)</code>替换<code>l(sv)</code></li>
</ol></li>
<li><ol start="4" type="1">
<li>重复步骤(2)和(3)，直到遍历完所有顶点。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/D.png" width="350"> <strong>如下所示解法：</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/D2.png" width="500"></li>
</ol></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//D算法最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec, map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//该集合指示未进行迭代的顶点</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; notDofVertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (i != V)</span><br><span class="line">            notDofVertices.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="type">int</span> currentVertice = V; <span class="comment">//记录迭代的顶点</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">2048</span><span class="number">-1</span>;	<span class="comment">//2048表示∞</span></span><br><span class="line">    <span class="keyword">while</span> (!notDofVertices.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//确定点V到点notDofVertices[index]最短路径min，确定顶点index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; notDofVertices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[currentVertice][notDofVertices[i]]&gt; min)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                index = notDofVertices[i];</span><br><span class="line">                min = vec[currentVertice][index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先保存一些原来的顶点</span></span><br><span class="line">        <span class="type">int</span> originV = currentVertice;</span><br><span class="line">        <span class="comment">//下一次迭代要遍历的顶点</span></span><br><span class="line">        currentVertice = index;</span><br><span class="line">        <span class="comment">//从notDofVertices删除顶点index</span></span><br><span class="line">        <span class="keyword">auto</span> t = <span class="built_in">find</span>(notDofVertices.<span class="built_in">begin</span>(), notDofVertices.<span class="built_in">end</span>(),index);</span><br><span class="line">        notDofVertices.<span class="built_in">erase</span>(t, t + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//点放入w</span></span><br><span class="line">        w[index] = min;</span><br><span class="line">        <span class="comment">//更新vec</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; notDofVertices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            index = notDofVertices[i];</span><br><span class="line">            vec[currentVertice][index] = vec[originV][index] &lt;= vec[currentVertice][index] + min?</span><br><span class="line">                vec[originV][index] : vec[currentVertice][index] + min;</span><br><span class="line">        &#125;</span><br><span class="line">        min = <span class="number">2048</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用int main()&#123;</span></span><br><span class="line">	 vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec&#123; &#123;<span class="number">2048</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2048</span>,<span class="number">2048</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2</span>,<span class="number">2048</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2048</span>,<span class="number">2048</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2048</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2048</span>,<span class="number">1</span>,<span class="number">2048</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2048</span>,<span class="number">2048</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2048</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2048</span>,<span class="number">2048</span>,<span class="number">5</span>,<span class="number">2048</span>,<span class="number">2</span>,<span class="number">2048</span>&#125; &#125;;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mymap;</span><br><span class="line">    <span class="built_in">dijkstra</span>(vec, mymap, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 弗洛伊德算法</strong></p>
<p><strong>弗洛伊德算法是求每一对顶点之间的最短路径</strong>，其实调用<code>n</code>次<code>dijkstra</code>函数也能求出每一对顶点之间的最短路径，时间复杂度为<code>O(n*n*n)</code>。但是在这里我们介绍比较简洁的<code>Floyd</code>算法。<code>Floyd</code>算法的<strong>基本思想,可以将问题分解:</strong></p>
<ul>
<li><strong>第一先找出最短的距离</strong></li>
<li><strong>第二再考虑如何找出对应的行进路线。</strong></li>
</ul>
<p>如何找出最短路径呢，这里还是用到<strong>动态规划的知识</strong>，对于任何一个城市而言，<code>i</code>到<code>j</code>的最短距离不外乎存在<code>i</code>到<code>j</code>之间经过<code>k</code>和不经过<code>k</code>两种可能，所以可以令<code>k=1，2，3，...，n</code>(n是城市的数目)，<strong>在检查<code>d(ij)</code>与<code>d(ik)+d(kj)</code>的值；在此<code>d(ik)</code>与<code>d(kj)</code>分别是目前为止所知道的<code>i</code>到<code>k</code>与<code>k</code>到<code>j</code>的最短距离，因此<code>d(ik)+d(kj)</code>就是<code>i</code>到<code>j</code>经过<code>k</code>的最短距离</strong>。所以，若有<code>d(ij)&gt;d(ik)+d(kj)</code>，就表示从<code>i</code>出发经过<code>k</code>再到<code>j</code>的距离要比原来的<code>i</code>到<code>j</code>距离短，自然把<code>i</code>到<code>j</code>的<code>d(ij)</code>重写为<code>d(ik)+d(kj)</code>，<strong>每当一个k查完了，<code>d(ij)</code>就是目前的<code>i</code>到<code>j</code>的最短距离。重复这一过程，最后当查完所有的<code>k</code>时，<code>d(ij)</code>里面存放的就是i到j之间的最短距离了。</strong></p>
<p><strong>实现过程：</strong></p>
<ul>
<li>写出图的初始距离矩阵<code>W0</code>和初始路由矩阵<code>R0</code></li>
</ul>
<p><span class="math display">\[
W^0=
\begin{cases}
d_{ij}，当v_i与v_j间有边时\\
∞，当v_i与v_j间无边时\\
0，i=j
\end{cases}
\]</span> <span class="math display">\[
R^0=
\begin{cases}
j，当W^0&lt;∞，i→j前次经过的中间点\\
0，W^0=∞或i=j
\end{cases}
\]</span></p>
<ul>
<li>依次将G中的各节点<code>K</code>作为中间节点，求<code>Wij</code>的最短路径,<code>k=1,2,3...n</code>。当节点<code>K</code>为中间节点时,要更新矩阵：</li>
</ul>
<p><span class="math display">\[
W^K=
\begin{cases}
min(W^{K-1}_{ij},W^{k-1}_{ik}+W^{k-1}_{kj})
\end{cases}
\]</span> <span class="math display">\[
R^k_{ij}=
\begin{cases}
k，,W^{k-1}_{ik}+W^{k-1}_{kj}时进行更新\\
r^{k-1}_{ij}，不更新
\end{cases}
\]</span></p>
<ul>
<li>当<code>k=n</code>时，得到的W矩阵即为各顶点间的最短距离，<code>R</code>为路径选择 <strong>如下的例题：</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/F.png" width="200"> 由<code>R0</code>知道经过V1作为中间节点可得<code>W1</code>和<code>R1</code>： <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/F2.png" width="600"> 再由<code>R1</code>知道经过<code>V2</code>可得<code>W2</code>和<code>R2</code> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/F3.png" width="600"></li>
</ul>
<p><strong>经过上面的两个图可以知道，我们对矩阵的改变其实只用看当前节点所在的行和列，有数字时可能会发生改变，此时进行<code>d(ij)</code>与<code>d(ik)+d(kj)</code>的比较看是否要更新。</strong></p>
<h6 id="拓扑排序">12.5.2 拓扑排序</h6>
<p>当且仅当一个有向图为有向无环图<code>DAG，directed acyclic graph</code>时，才能得到对应于该图的拓扑排序。每个有向无环图都至少存在一种拓扑排序。<strong>一般来说拓扑排序主要应用于判断有向图是否有环</strong>。</p>
<p><strong>实现：</strong>对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则必无环。一般采用邻接表，每个头节点增加一存储入度的数据域。一般为避免重复检测入度为0的点，可设一栈或队列暂存入度为0的点，也可以设置标志位<code>isnotPutInSet</code></p>
<ul>
<li>在有向图中选择一个没有前驱即入度为<code>0</code>的顶点输出之</li>
<li>从图中删除该顶点和所有以他为头的弧，并且相应的尾顶点<code>入度-1</code></li>
<li>重复上述两步直至无法输出</li>
<li>若此时输出的顶点数小于有向图的定点数，则说明有向图中存在回路，否则输出的顶点的顺序即为一个拓扑序列</li>
</ul>
<p><img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/topoSort.png" width="300"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(n*n)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">graph</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> indegree;</span><br><span class="line">    <span class="type">int</span> numberofVertices;</span><br><span class="line">    <span class="built_in">graph</span>(<span class="type">int</span> _in, <span class="type">int</span> vertices) :<span class="built_in">indegree</span>(_in), <span class="built_in">numberofVertices</span>(vertices) &#123;&#125;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; linkV;</span><br><span class="line">    <span class="type">bool</span> isnotPutInSet = <span class="literal">true</span>;</span><br><span class="line">    ~<span class="built_in">graph</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">(vector&lt;graph&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; zeroIndegreeVertices;</span><br><span class="line">   <span class="comment">// int Size = vec.size();</span></span><br><span class="line">    <span class="comment">//int count = 0;</span></span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (it != vec.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;indegree == <span class="number">0</span> &amp;&amp; it-&gt;isnotPutInSet)</span><br><span class="line">        &#123;</span><br><span class="line">            zeroIndegreeVertices.<span class="built_in">insert</span>(it-&gt;numberofVertices);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = it-&gt;linkV.<span class="built_in">begin</span>(); iter != it-&gt;linkV.<span class="built_in">end</span>(); iter++)</span><br><span class="line">            &#123;</span><br><span class="line">                --vec[*iter<span class="number">-1</span>].indegree;</span><br><span class="line">            &#125;</span><br><span class="line">            it-&gt;isnotPutInSet = <span class="literal">false</span>;</span><br><span class="line">            it = vec.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() == zeroIndegreeVertices.<span class="built_in">size</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;该图无环路&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;该图有环路&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调试</span></span><br><span class="line">	vector&lt;graph&gt; gvec;</span><br><span class="line">    <span class="function">graph <span class="title">v1</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    v1.linkV.<span class="built_in">insert</span>(&#123; <span class="number">2</span>,<span class="number">4</span> &#125;);</span><br><span class="line">    <span class="function">graph <span class="title">v2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    v2.linkV.<span class="built_in">insert</span>(&#123; <span class="number">3</span>,<span class="number">4</span> &#125;);</span><br><span class="line">    <span class="function">graph <span class="title">v3</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">graph <span class="title">v4</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    v4.linkV.<span class="built_in">insert</span>(&#123; <span class="number">3</span> &#125;);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v4);</span><br><span class="line">    <span class="built_in">topoSort</span>(gvec);</span><br></pre></td></tr></table></figure></p>
<h6 id="最小生成树">12.5.3 最小生成树</h6>
<p>最小代价生成树即指对带权无向图包含所有<code>n</code>个顶点和<code>n-1</code>条边，联通所有结点后代价最小的树。假设<code>N =(V，&#123; E &#125;)</code>是一个连通网，<code>U</code>是顶点集<code>V</code>的一个非空子集。若<code>(u , v)</code>是一条具有最小权值（代价）的边，其中<code>u∈U</code>， <code>v∈(V - U)</code>，则必存在一棵包含边（u，v）的最小生成树。最小生成树的算法有<strong>普里姆算法和克鲁斯卡尔算法。</strong></p>
<p><strong>1. 普里姆(prim)算法</strong></p>
<p><strong>算法思路：</strong>首先就是从图中的一个起点<code>a</code>开始，把<code>a</code>加入<code>U</code>集合，然后，寻找从与<code>a</code>有关联的边中，权重最小的那条边并且该边的终点<code>b</code>在顶点集合：<code>(V-U)</code>中，我们也把<code>b</code>加入到集合<code>U</code>中，并且输出边<code>(a，b)</code>的信息，这样我们的集合U就有：<code>&#123;a,b&#125;</code>，然后，我们寻找与<code>a</code>关联和<code>b</code>关联的边中，权重最小的那条边并且该边的终点在集合：<code>(V-U)</code>中，我们把<code>c</code>加入到集合<code>U</code>中，并且输出对应的那条边的信息，这样我们的集合U就有：<code>&#123;a,b,c&#125;</code>这三个元素了，依次类推，直到所有顶点都加入到了集合<code>U</code>。其实就是<strong>贪心算法</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/prim.png" width="600"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用邻接矩阵结构，复杂度为O(n*n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ve;     <span class="comment">//U集合记录顶点，</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; reachV;    <span class="comment">//记录已到达过的顶点</span></span><br><span class="line">    ve.<span class="built_in">push_back</span>(<span class="number">0</span>);    <span class="comment">//直接将V0加入集合U</span></span><br><span class="line">    reachV.<span class="built_in">insert</span>(<span class="number">0</span>);   <span class="comment">//0已到达过</span></span><br><span class="line">    <span class="keyword">while</span> (ve.<span class="built_in">size</span>() != vec.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX;</span><br><span class="line">        <span class="type">int</span> sourceV = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> toVertice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ve.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> vertice = ve[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vec[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &lt; vec[vertice][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;   <span class="comment">//若当前记录的的min权值大于当前两节点边的权值，进行更新</span></span><br><span class="line">                    <span class="keyword">if</span> (reachV.<span class="built_in">find</span>(j)==reachV.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        min = vec[vertice][j];</span><br><span class="line">                        toVertice = j;</span><br><span class="line">                        sourceV = vertice;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ve.<span class="built_in">push_back</span>(toVertice);</span><br><span class="line">        reachV.<span class="built_in">insert</span>(toVertice);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;V&quot;</span>&lt;&lt;sourceV+<span class="number">1</span> &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; <span class="string">&quot;V&quot;</span></span><br><span class="line">			&lt;&lt; toVertice+<span class="number">1</span> &lt;&lt; <span class="string">&quot; 权值:&quot;</span> &lt;&lt; min &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec&#123; &#123;INT_MAX,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,INT_MAX,INT_MAX&#125;,</span><br><span class="line">                            &#123;<span class="number">6</span>,INT_MAX,<span class="number">5</span>,INT_MAX,<span class="number">3</span>,INT_MAX&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>,<span class="number">5</span>,INT_MAX,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>,INT_MAX,<span class="number">5</span>,INT_MAX,INT_MAX,<span class="number">2</span>&#125;,</span><br><span class="line">                            &#123;INT_MAX,<span class="number">3</span>,<span class="number">6</span>,INT_MAX,INT_MAX,<span class="number">6</span>&#125;,</span><br><span class="line">                            &#123;INT_MAX,INT_MAX,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,INT_MAX&#125; &#125;;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">auto</span> i : it)</span><br><span class="line">               <span class="keyword">if</span> (i == INT_MAX)</span><br><span class="line">                   cout &lt;&lt; <span class="string">&quot;∞ &quot;</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">           cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">prim</span>(vec);</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 克鲁斯卡算法</strong></p>
<p>算法思路：</p>
<ul>
<li>（1）将图中的所有边都去掉。</li>
<li>（2）将边按权值从小到大的顺序添加到图中，保证添加的过程中不会形成环</li>
<li>（3）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/kelusika.png" width="700"></li>
</ul>
<h4 id="b-tree">13. B-Tree</h4>
<p>对存储在磁盘上的数据，<code>B-Tree</code>是一种适合索引方法的数据结构。</p>
<h5 id="b-tree的特点">13.1 B-Tree的特点</h5>
<p><code>B-Tree</code>也称B树是一种平衡的多路查找树。一颗3阶的B树，其内部节点必须有2~3个孩子。因此可知道一颗m阶B树（空树/m叉树），必须满足以下特性：</p>
<ul>
<li><strong>树中每个结点至多有<code>m</code>棵子树，即至多含有<code>m-1</code>个关键字</strong></li>
<li><strong>若根结点不是叶子结点，则至少有两棵子树</strong></li>
<li>除根之外的所有非终端结点至少有<code>[m/2]</code>棵子树，<code>[]</code>表示向上取整。</li>
<li>所有非终端结点包含下列信息数据<code>n,P0,K1,P1,K2......Kn,Pn</code>;其中<code>Kn</code>为关键字，<code>Pn</code>为指向下面子树根节点的指针。他有：
<ul>
<li>①当<code>i&lt;j</code>时，<code>Ki&lt;Kj</code>；</li>
<li>②当<code>i&lt;j</code>时，对于指针<code>Pi</code>指向的子树根节点的关键子都必须小于<code>Kj</code>，而当<code>i&gt;j</code>时必须<code>Pi</code>所指子树根节点的关键子都必须大于<code>Kj</code>（即从小到大）；</li>
<li>③关键子个数<code>[m/2]-1≤n≤m-1</code></li>
</ul></li>
<li><strong>所有叶子结点都在同一层</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTree.png" width="600"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> m 3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span>&#123;</span><br><span class="line"><span class="type">int</span> keyNum;						<span class="comment">//该节点关键字数量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span> *parent;			<span class="comment">//指向父亲结点</span></span><br><span class="line">KeyTyep	key[m+<span class="number">1</span>];				    <span class="comment">//关键字大小，0号单元未使用</span></span><br><span class="line"><span class="keyword">struct</span>	<span class="title class_">BTNode</span>	*ptr[m+<span class="number">1</span>];		<span class="comment">//指向子树的指针，0号单元未使用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>	*recptr[m+<span class="number">1</span>]；			<span class="comment">//指向该关键字的数据域</span></span><br><span class="line">&#125;BTNode,*BTree;</span><br></pre></td></tr></table></figure>
<h5 id="b-tree的高">13.2 B-Tree的高</h5>
<p>对于B-Tree的定理有：设T为一颗高度为<code>h</code>的<code>m</code>阶B-Tree，n为T的元素个数，<code>d=[m/2]</code>,则有：</p>
<ul>
<li><span class="math inline">\(2d^{h-1}≤n≤m^k-1\)</span></li>
<li><span class="math inline">\(log_m{n+1}≤h≤log_d \frac{n+1}2+1\)</span></li>
</ul>
<p>则有上面的公式可以知道，一颗高度为5的200阶B-Tree至少有<span class="math inline">\(2*10^8-1\)</span>个元素。这种高度低且一个节点有多个元素的结构很符合磁盘的一次性存储与取出大小适当数据量。</p>
<h5 id="b-tree的操作">13.3 B-Tree的操作</h5>
<h6 id="b-tree的搜索">13.3.1 B-Tree的搜索</h6>
<p>B-Tree的搜索算法与m叉搜索树的搜索算法相同。在搜索过程中，从根部至外部节点路径上的所有内部节点通过比较关键子大小选择以哪条路径行进，直到相等或者到<code>NULL</code>，因此，磁盘访问次数最多是<code>h</code></p>
<h6 id="b-tree的插入">13.3.2 B-Tree的插入</h6>
<p>对于B-Tree的插入，首先经过关键字搜索比较找到插入的节点，之后有如下法则</p>
<ul>
<li>为空时直接插入到根节点记录</li>
<li>插入的节点为不饱和节点，则直接插入，不必做其他操作</li>
<li><strong>如果插入的时饱和节点，则先插入，然后取中上升，其余的进行分裂</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeInsert.png" width="600"></li>
</ul>
<h6 id="b-tree的删除">13.3.3 B-Tree的删除</h6>
<p>B-Tree的删除会破坏规则：每个非终端节点至少含有<code>[m/2]</code>棵子树，即每个非终端节点的要有<code>[m/2]-1</code>个关键字；或者破坏了指针指向。因此为恢复该规则进行操作有：</p>
<p><strong>删除叶子关键字：</strong></p>
<ul>
<li>若该叶子节点删除该关键字后，仍满足关键字数量范围，直接删除</li>
<li>若叶子结点删除该关键字后，不满足关键字数量范围，但兄弟结点关键字＞<code>[m/2]-1</code>,兄弟借（途经父亲）</li>
<li>若叶子结点删除该关键字后，不满足关键字数量范围，且兄弟结点关键字=<code>[m/2]-1</code>,向父借，拖父下水 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeDeleteLeaf.png" width="500"></li>
</ul>
<p><strong>删除非叶子关键字</strong>:</p>
<ul>
<li>向该节点要删除的关键字的左子树最大关键字或右子树最小关键字借。</li>
<li>题目已规定要向谁借，但借完不符合要求，但此时兄弟可借，直接借兄弟的</li>
<li>借完不和，兄也不可借，兄弟合并 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeDeleteNotLeaf.png" width="700"></li>
</ul>
<h4 id="b树">14. B+树</h4>
<h5 id="b树与b树的不同点">14.1 B+树与B树的不同点</h5>
<p><strong>B+树是应文件系统所需而出的一种B-树的变型树</strong>。一棵m阶的B+树和m阶的B-树的差异在于：</p>
<ul>
<li><p><strong>非叶子结点的子树指针与关键字个数相同或者子树指针数=关键字个数+1</strong>；</p></li>
<li><p><strong>非叶结点仅具有索引下一层作用，不存储数据的指针，跟记录有关的信息均存放在叶结点中</strong>。</p></li>
<li><p>非叶子结点的子树指针<code>P[i]</code>，指向关键字值属于<code>[K[i], K[i+1])</code>的子树（B树是开区间）；</p></li>
<li><p><strong>为所有叶子结点增加一个链指针；树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</strong></p></li>
<li><p><strong>所有关键字具体数据或者数据“地址”只存储在叶子结点。</strong></p></li>
</ul>
<p><img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeadd.png" width="700"></p>
<p><strong><em>注意：说到B+Tree的叶子节点，必须区分MySQL中的聚簇索引和非聚簇索引（二级索引），在聚簇索引的叶子节点存储的是完整的行数据，而二级索引叶子节点存储的是数据<code>行指针</code>,这里的<code>行指针</code>的实质是叶子节点保存只是行的主键值，因此非聚簇索引必须还要在聚簇索引结构上进行查找，这也是为什么它被称为二级索引</em></strong></p>
<h5 id="为什么b树更适合做索引">14.2 为什么B+树更适合做索引</h5>
<p><strong>我们先分析B+d与众不同的特点：</strong></p>
<ul>
<li>第一个就是B+树在B树的基础之上最重要的改进就是非叶子结点只存储关键字和下一层的索引，不存储Data域，只在叶子结点存储Data域；</li>
<li>第二点就是所有叶子结点增加一个链指针，使所有叶结点构成一个有序链表，因此当我们需要有序遍历所有关键字时，直接从最小关键字的叶子结点开始遍历即可。</li>
</ul>
<h6 id="非叶子结点不存储data域的好处">14.2.1非叶子结点不存储Data域的好处</h6>
<ul>
<li><p><strong>每一个结点可以存放更多的关键字和下一层的索引。数据库是存储在磁盘上的，我们读取数据是从磁盘读取到内存中，我们在进行磁盘预读取时，是以块的单位进行数据读取，我们在检索B/B+树的结点时，每次以块为单位将一个结点读取到内存中，若一块磁盘包含了树结点以外的数据，就造成了浪费，因此我们需要使每一个结点的数据大小正好或者接近一块磁盘的大小</strong>。于是我们在构建B+/B树时，树的阶数其实就取决于一块磁盘中能容纳多少个关键字以及相关的索引和Data域。<strong>B+树的非叶子结点不存储Data域，因此它可以存储更多个关键字和下一层索引，因此B+树会比B树更宽胖</strong>。若我需要查找的关键字正好在叶子结点，B+树所进行的I/O次数更少,因为途中经过每一层，我们都需要进行一次I/O读取一个结点，B+树会更矮，途径的层数会更少。</p></li>
<li><p>使得B+树查询速度更稳定，B+树所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p></li>
</ul>
<h6 id="所有叶结点构成一个有序链表的好处">14.2.2所有叶结点构成一个有序链表的好处</h6>
<ul>
<li><p><strong>B+树便于区间查找（这点才是B+树作为索引的关键）</strong>，我们进行数据库查询大多为区间查询，B+树天然具备排序功能，B+树所有的叶子结点构成了一个有序链表，在查询大小区间的数据时候更方便，B+树查询，只需通过头结点往下找到第一个叶子结点，然后在叶子结点的链表上就行遍历即可完成区间查询，而B树的关键字大小相邻近的结点可能隔得很远，要想进行区间查询需要不停的进行中序遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li>
<li><p>B+树全结点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要进行中序遍历，这有利于数据库做全表扫描。</p></li>
</ul>
<p><strong>总结B+树优点(选择B+树作为索引的原因)</strong></p>
<ul>
<li>因为没有非叶子节点没有存储数据，因此单一非叶子结点能存储更多的关键字索引</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；</li>
<li>所有叶子节点形成有序链表，便于范围查询以及全结点遍历更快。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统_信息表示和处理</title>
    <url>/2023/03/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="信息的存储">1 信息的存储</h3>
<p>大多数的计算机使用8位的块，或者说是字节(byte)，作为<strong>最小的可寻址内存单位</strong>，而不是访问内存中单独的位。机器级程序将<strong>内存视为一个非常大的字节数组，我们称为虚拟内存</strong>，内存的每个字节都由一个唯一的数字来标识，即称为<strong>地址</strong>；所有可能的地址空间的集合就是<strong>虚拟地址空间</strong>。</p>
<p>顾名思义，虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现(第九章：虚拟内存)是将DRAM、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，位程序提供一个看上去统一的字节数组。</p>
<span id="more"></span>
<h4 id="十六进制">1.1 十六进制</h4>
<p>在机器世界当中是二进制的，而二进制和十六进制之间的转换比较简单直接，因此在讨论中我们通常不会去说二进制与十进制的转换。</p>
<ul>
<li>在C语言中，十六进程以<code>0x</code>或者<code>0X</code>开头，字符<code>A~F</code>代表<code>10~15</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">0xa8</span>;</span><br></pre></td></tr></table></figure></li>
<li>在C++中，延续了C的这个特点。同时<code>cout</code>对象有相应的十六进制输出方式</li>
</ul>
<table>
<thead>
<tr class="header">
<th>ostream成员函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>flags(fmtfl)</code></td>
<td>当前格式状态全部替换为 <code>fmtfl</code>。注意，<code>fmtfl</code> 可以表示一种格式，也可以表示多种格式。</td>
</tr>
<tr class="even">
<td><code>precision(n)</code></td>
<td>设置输出浮点数的精度为 n。</td>
</tr>
<tr class="odd">
<td><code>width(w)</code></td>
<td>指定输出宽度为 <code>w</code> 个字符。</td>
</tr>
<tr class="even">
<td><code>fill(c)</code></td>
<td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）。</td>
</tr>
<tr class="odd">
<td><code>setf(fmtfl, mask)</code></td>
<td>在当前格式的基础上，追加 <code>fmtfl</code> 格式，并删除 <code>mask</code> 格式。其中，<code>mask</code> 参数可以省略。</td>
</tr>
<tr class="even">
<td><code>unsetf(mask)</code></td>
<td>在当前格式的基础上，删除 mask 格式。</td>
</tr>
</tbody>
</table>
<p>其中，对于上表中 <code>flags()</code> 函数的 <code>fmtfl</code> 参数、<code>setf()</code> 函数中的 <code>fmtfl</code> 参数和 <code>mask</code> 参数以及 <code>unsetf()</code> 函数 <code>mask</code> 参数，可以选择下表中列出的这些值。</p>
<table>
<thead>
<tr class="header">
<th>标 志</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ios::boolapha</code></td>
<td>把 true 和 false 输出为字符串</td>
</tr>
<tr class="even">
<td><code>ios::left</code></td>
<td>输出数据在本域宽范围内向左对齐</td>
</tr>
<tr class="odd">
<td><code>ios::right</code></td>
<td>输出数据在本域宽范围内向右对齐</td>
</tr>
<tr class="even">
<td><code>ios::internal</code></td>
<td>数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</td>
</tr>
<tr class="odd">
<td><code>ios::dec</code></td>
<td>设置整数的基数为 10</td>
</tr>
<tr class="even">
<td><code>ios::oct</code></td>
<td>设置整数的基数为 8</td>
</tr>
<tr class="odd">
<td><code>ios::hex</code></td>
<td>设置整数的基数为 16</td>
</tr>
<tr class="even">
<td><code>ios::showbase</code></td>
<td>强制输出整数的基数（八进制数以 0 开头，十六进制数以 0x 打头）</td>
</tr>
<tr class="odd">
<td><code>ios::showpoint</code></td>
<td>强制输出浮点数的小点和尾数 0</td>
</tr>
<tr class="even">
<td><code>ios::uppercase</code></td>
<td>在以科学记数法格式 E 和以十六进制输出字母时以大写表示</td>
</tr>
<tr class="odd">
<td><code>ios::showpos</code></td>
<td>对正数显示“+”号</td>
</tr>
<tr class="even">
<td><code>ios::scientific</code></td>
<td>浮点数以科学记数法格式输出</td>
</tr>
<tr class="odd">
<td><code>ios::fixed</code></td>
<td>浮点数以定点格式（小数形式）输出</td>
</tr>
<tr class="even">
<td><code>ios::unitbuf</code></td>
<td>每次输出之后刷新所有的流</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=oxa8;</span><br><span class="line">cout.<span class="built_in">unsetf</span>(ios::dec)</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::hex);</span><br><span class="line">cou&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">cout&lt;&lt;hex&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="字数据大小">1.2 字数据大小</h4>
<p>每台计算机都有有一个字长(word)，指明指针数据的标称大小，<strong>因为虚拟地址是以这样的一个字来编码的，所有字长决定的最重要的系统参数就是虚拟地址空间的最大空间</strong>，也就是说一个字长位m位的机器，虚拟地址空间的范围为<span class="math inline">\(0\)</span>~<span class="math inline">\(2^{(m-1)}\)</span>，即32为系统来说，器虚拟内存空间最大为4G，而64位最大可为16EB.</p>
<p>64位机器先后兼容，可运行32位机器编码程序,因此对于下面的伪指令编译 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//32、64均可运行</span></span><br><span class="line">gcc -m32 prog.c</span><br><span class="line"><span class="comment">//只能在64运行</span></span><br><span class="line">gcc -m64 prog.c</span><br></pre></td></tr></table></figure></p>
<p>值得一提的是各基础类型在不同机器的字节数： <img src="/2023/03/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/bytenums.png" width="700"></p>
<ul>
<li><code>int</code>不管在哪个机器上都是4字节</li>
<li>而<code>long</code>在32位位4字节，在64位上位8字节</li>
<li>另外为了克服这种在不同机器上字节长度不同的区别，IOS引入了数据大小固定，不随编译器设置带来的变化的类型，如<code>int32_t</code>和<code>int64_t</code>等等</li>
<li>指针为4字节</li>
</ul>
<h4 id="寻址和字节顺序">1.3 寻址和字节顺序</h4>
<p>对于跨域多字节的程序对象，必须有两个规则：</p>
<ul>
<li>这个对象的地址是什么：在几乎所有的机器上，多字节对象都被存储为连续的字节序列，<strong>对象的地址为所使用字节中最小的地址。</strong></li>
<li>这个对象在内存中是如何排列这些字节的：排列ijie有两个通用的规则，一个是大端(网络字节序)，一个是小端(主机序);<strong>大端字节序在内存中按从最高有效位到最低有效位存储；而小端字节序在内存中按照从最低有效位到最高有效位存储</strong>
<ul>
<li>现有一个int型变量，位于初始地址为<code>0x100</code>，它的十六进制值为<code>0x01234567</code>，则大小端存储如下： <img src="/2023/03/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/bigsmall.png" width="700"></li>
</ul></li>
</ul>
<p>试用一个程序来输出类型位<code>int</code>、<code>float</code>和<code>void*</code>的字节表示： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>* byte_pointer;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start,size_tlen)</span></span>&#123;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%2.x &quot;</span>,start[i]);	<span class="comment">//%2.x表示整数必须用两个16进制输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_int</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">show_bytes</span>((byte_pointer)&amp;x,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_float</span><span class="params">(<span class="type">float</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">show_bytes</span>((byte_pointer)&amp;x,<span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_pointer</span><span class="params">(<span class="type">void</span>*x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">show_bytes</span>((byte_pointer)&amp;x,<span class="built_in">sizeof</span>(<span class="type">void</span>*));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> val=<span class="number">12345</span>;</span><br><span class="line">	<span class="type">float</span> fval=(<span class="type">float</span>)val;</span><br><span class="line">	<span class="type">int</span> *pval=&amp;val;</span><br><span class="line">	<span class="built_in">show_int</span>(val);</span><br><span class="line">	<span class="built_in">show_float</span>(fval);</span><br><span class="line">	<span class="built_in">show_pointer</span>(pval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">39</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> e4 <span class="number">40</span> <span class="number">46</span></span><br><span class="line"><span class="number">74</span> f5 cf <span class="number">38</span> a3</span><br></pre></td></tr></table></figure> 可以很清楚的值得<code>int</code>是采用了小端字节序，<code>float</code>也是使用了小端，但数值比较奇怪，而指针的值是每次都可能会不一样的。</p>
<p>对于<code>int</code>和<code>float</code>的值，看起来很不一样，但是我们把它按位展开，则发现下面有些许相似,如<code>*</code>号处： <img src="/2023/03/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/same.png" width="700"></p>
<p>这是IEEE单精度标准化的结果</p>
<h4 id="表示字符串">1.4 表示字符串</h4>
<p>C语言中字符串编码为一个以<code>null</code>(值为0)字符结尾的字符数组。<strong>并且每个字符都以标准编码来表示，如ASCII码</strong>。比如，我们若以字符串&quot;12345&quot;来运行<code>show_bytes</code>，得到的结果会是<code>31 32 33 34 35 00</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0~9的数字x的ascii码正好对应0x3x,终止字符对应0x00</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="built_in">show_bytes</span>((byte_pointer)s, <span class="built_in">sizeof</span>(s));</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">31</span> <span class="number">32</span> <span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">00</span></span><br></pre></td></tr></table></figure></p>
<h4 id="计算机中的正数和负数是怎么表示的">1.5 计算机中的正数和负数是怎么表示的</h4>
<p>计算机中数据都有二进制位来存储，目前大多数的计算机都是以补码的形式去存储计算机。正数我们一般都称为正树，正常表示，<strong>而负数则采用补码的形式来表达。对于有符号位的数字，最高位为符号位，<code>0</code>为正，<code>1</code>为负</strong></p>
<ul>
<li>正数数：如6，比特为存储为<code>0110</code>，其计算公式是<span class="math inline">\(2^2+2^1\)</span></li>
<li>负数：如-7，其在计算这样存储<code>1001</code>，其计算公式为<span class="math inline">\(-2^7+2^0\)</span>，这就是补码的表达方式</li>
</ul>
<blockquote>
<p>负数使用补码来存储，是因为在进行算术运算是与正数没有区别，遵循同一个规则。 也可以这样说有符号数以补码形式存储，只不过非负数得补码是它本身</p>
</blockquote>
<p>补码得取反很有意思： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="type">int</span> a = INT_MIN;</span><br><span class="line">   	<span class="type">int</span> b = -a;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">-10</span>;</span><br><span class="line">    <span class="type">int</span> d = -c;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">-2147483648</span>	<span class="number">-2147483648</span>	<span class="number">-10</span> <span class="number">10</span></span><br><span class="line"><span class="comment">//对于TMIN得取反还是它本身，其他得正常取反</span></span><br></pre></td></tr></table></figure> 取反规律： <span class="math display">\[
x=\begin{cases}
Tmin&amp; x=Tmin\\
-x&amp; x!=Tmin\\
\end{cases}
\]</span></p>
<h4 id="算术右移和逻辑右移">1.6 算术右移和逻辑右移</h4>
<p><strong>在计算机中对左移没有做什么要求，其逻辑左移移总是正确的</strong>。但对于右移，则会有相应的算术右移和逻辑右移</p>
<ul>
<li><strong>对于无符号数，我们应当总是采用逻辑右移</strong>，如果我们采用了算术右移对<code>1010</code>右移一位：<span class="math inline">\(1010-----&gt;1101\)</span>，然而实际应该是<code>0101</code></li>
<li>对于有符号数，C语言标准没有明确定义使用哪种右移方式，<strong>但是一般而言都采用算术右移。</strong>
<ul>
<li>比如说-6，补码表示是<span class="math inline">\(1010\)</span>，算术右移一位成<span class="math inline">\(1101\)</span>为-3，没有错，再右移一位成<span class="math inline">\(1110\)</span>为-2，但实际上为-1，<strong>因此实际上计算机的对负数的算术右移，都会添加一个偏移量。</strong></li>
<li>如：<span class="math inline">\(1010\)</span>加上<span class="math inline">\(0001\)</span>偏移量得<span class="math inline">\(1011\)</span>，右移得<span class="math inline">\(1101\)</span>，右移再加一个偏移量得<span class="math inline">\(1110\)</span>，右移得<span class="math inline">\(1111\)</span>,此时为<code>-1</code>正常</li>
</ul></li>
</ul>
<h4 id="布尔运算">1.7 布尔运算</h4>
<p>以下操作是按位运算：</p>
<ul>
<li><code>&amp;</code>代表位逻辑运算<code>AND</code></li>
<li><code>|</code>代表位逻辑运算<code>OR</code></li>
<li><code>^</code>代表位逻辑运算异或</li>
<li><code>~</code>代表位逻辑运算非</li>
<li><code>y&gt;&gt;x</code>对数字y右移x位，相当于<span class="math inline">\(y/2^x\)</span></li>
<li><p><code>y&lt;&lt;x</code>对数字y左移x位,相当于<span class="math inline">\(y*2^x\)</span></p></li>
<li><p>从位运算比普通运算效率更高，位运算能够高效率的完成数值的计算，因为机器本身就是基于二进制的存储和计算，所有的数值或者对象最终都要转化为二进制，对象的话，可能需要一些编解码的动作，位运算主要是针对数据运算的，把人们熟悉的数字转化为机器熟悉的数字，其中又牵扯到原码，反码和补码，补码的出现是为了减低机器运算的复杂度，把减法转变为加法，可以这么说机器运算只有加法和移位，乘法最终是通过加法和移位操作完成的，而除法首先转变为乘法。</p></li>
<li><p>交换两个数字，不使用中间变量： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a^=b;	<span class="comment">//a=a^b;</span></span><br><span class="line">b^=a;	<span class="comment">//b=a^b^b=a</span></span><br><span class="line">a^=b;	<span class="comment">//a=a^b^a=b</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="无符号和有符号的转换">1.8 无符号和有符号的转换</h4>
<p>有符号数如<code>-8</code>：1000 <span class="math display">\[计算方式:-2^4+0*2^3+2*2^1+0*2^0\]</span> 在C/C++中，会有无符号类型的定义，因此当涉及都无符号和有符号整型的转换时，我们必须知道计算机的工作低层原理：</p>
<ul>
<li><strong>计算机中有符号数和无符号数之间的转换规则：数值可能发送了改变，但是位模式不变</strong></li>
<li>即在转换当中位不会改变，<code>-8变为</code>+8<code>：1000</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f = INT_MIN;<span class="comment">//32位：100000...000</span></span><br><span class="line"><span class="type">unsigned</span> o = f;<span class="comment">//32位：100000...000</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">-2147483648</span> <span class="number">2147483648</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>无符号有符号转换发送的场景 - <strong>无符号与有符号进行比较，有符号的会向无符号整型提升，此时不安全</strong>（向上转换） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="type">int</span> f = <span class="number">-2</span>;</span><br><span class="line">    <span class="type">unsigned</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f &gt; o)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;surprise!!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//上面的程序在我们人类开来不应该会输出，但是真正情况是：</span></span><br><span class="line">surprise!!</span><br></pre></td></tr></table></figure> - 强制类型转换的时候</p>
</blockquote>
<h4 id="溢出与截断">1.9 溢出与截断</h4>
<p>数据存在溢出情况，<strong>这是因为计算机要求不能无限制的为能保存一个数而扩充表示位，如int是4字节，对于溢出的数据会进行截断，因此由于截断的存在导致数据的发送错误</strong>。</p>
<ul>
<li>正溢出：由正溢出则会导致数据由正变为负值，如<code>INT_MAX+1</code>,变为<code>INT_MIN</code></li>
<li>负溢出：由正溢出则会导致数据由负值变为正值，如<code>INT_MIN-1</code>,变为<code>INT_MIN</code></li>
</ul>
<h4 id="浮点数">1.10 浮点数</h4>
<p>浮点数不同于上面所讲的整数，由IEEE规定特定的存储方式： <span class="math display">\[V=(-1)^s*M*2^E\]</span></p>
<ul>
<li><span class="math inline">\(s\)</span>为标符号位：标志当前浮点数是正数还是负数</li>
<li><span class="math inline">\(M\)</span>为尾数：它是一个二进制小数，是frac字段的十进制表示。它的范围在规格化是值在<span class="math inline">\([1,2-\epsilon]\)</span>；在非规格化时值在<span class="math inline">\([0,1-\epsilon]\)</span></li>
<li><span class="math inline">\(E\)</span>:为阶数，其值位阶码字段<span class="math inline">\(e_{k-1}e_{k-2}...e_0\)</span>的十进制值 <img src="/2023/03/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/float.png" width="700"></li>
</ul>
<blockquote>
<p>对于单精度float来说，其位分布为：1--8--23 双精度double:位分布为1---11---52</p>
</blockquote>
<h5 id="三种形式">1.10.1 三种形式</h5>
<ul>
<li><strong>规格化的值：</strong>在规格化下，即<code>exp</code>的位模式不全为0也不全为1，此时E和M计算方式如下： <span class="math display">\[E=e-Bias \]</span> <span class="math display">\[M=1+f\]</span></li>
</ul>
<p>其中<span class="math inline">\(Bias=2^{k-1}-1\)</span>, <span class="math inline">\(f为frac的小数区域十进制表示\)</span></p>
<ul>
<li><p><strong>非规格化的值：当阶码字段的位模式均为0，此时处于非规格化。非规格化的作用是补充规格化无法趋近于0的，此时E和M计算方式如下：</strong> <span class="math display">\[E=1-Bias \]</span> <span class="math display">\[M=f\]</span></p></li>
<li>特殊值：当阶码位模式均为1时，此时处于特殊值情况：
<ul>
<li>当小数域<code>frac</code>均为0时，此时表示值位无穷大，当<code>s=0</code>时是<span class="math inline">\(+∞\)</span>，当<code>s=1</code>时是<code>-∞</code></li>
<li>当<code>frac</code>位非0时，此时结果值被表示位<code>NaN</code>,不是一个数。 <img src="/2023/03/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/normal.png" width="700"></li>
</ul></li>
</ul>
<h5 id="浮点数与整数的关系">1.10.2 浮点数与整数的关系</h5>
<p>现在来看之前提到过的int和float的关系 <img src="/2023/03/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/same.png" width="500"> 它们有相似的区域，这是怎么得来的呢，仔细观察，可由下面推得：</p>
<ul>
<li>首先将int型数字左移13位得到<span class="math inline">\(1.1000000111001*2^{13}\)</span></li>
<li>由于其<span class="math inline">\(E=13\)</span>，由其计算公式可知，<span class="math inline">\(e=E+Bias=13+127=140\)</span>，处于规格化，符号位为正</li>
<li>所以前面的e编码为<span class="math inline">\(10001100\)</span></li>
<li>将符号位、Exp、frac字段拼接，其中frac中小数点前的1可省略，节约一个位，得到<span class="math inline">\(01000110010000001110011\)</span></li>
<li>由于单精度，小数区域为23为，在其后面补10个0，得到<span class="math inline">\(01000110010000001110010000000000\)</span>,即如上图所示</li>
</ul>
<h5 id="浮点数的舍入">1.10.3 浮点数的舍入</h5>
<p>因为表示方法限制了浮点数的范围和精度，所以浮点数运算只能近似地表示实数运算。在规范当中有四种舍入方式 <img src="/2023/03/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/roundingoff.png" width="600"></p>
<h5 id="c中的浮点数">1.10.4 C中的浮点数</h5>
<p>C中提供了两种浮点数<code>float</code>和<code>double</code>。挡在<code>int、float和double</code>直接进行强制类型转换时，程序改变数值和位模式的原则如下：</p>
<ul>
<li>从<code>int</code>转为<code>float</code>,数字不会溢出，但是会被舍入</li>
<li>从<code>int</code>或<code>float</code>转为<code>doubel</code>，能够保留原来的精确的值</li>
<li>从<code>double</code>转为<code>float</code>，值可能会溢出，精度减小，可能会被舍入 -** 从<code>float</code>或<code>double</code>转为<code>int</code>,值会向0舍入，例如<code>1.99</code>将被转换为<code>1</code>**</li>
</ul>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统-存储器层次结构</title>
    <url>/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="存储技术">1 存储技术</h3>
<p>作为一名程序员，你必须了解存储器的层次结构，因为它对应用程序的性能有着巨大的影响。</p>
<ul>
<li><strong>如果你的数据是在cpu寄存器上，那么指令执行期间在0个周期就能访问到</strong></li>
<li>如果是在高速缓存中，需要4-75个周期</li>
<li>如果在主存，需要上百个周期</li>
<li><strong>如果是在磁盘，那么就需要大约几千万个周期，时间大概是毫秒级，比主存慢10万倍，比高速缓存慢100万倍</strong></li>
</ul>
<h4 id="随机访问存储器">1.1 随机访问存储器</h4>
<p>随机访问存储器(RAM)有两类：静态和动态。静态RAM(SRAM)比动态DRAM(DRAM)更快，但也更贵，<strong>因此SRAM一般集成在CPU上作为高速缓存，DRAM则作为主存。</strong>断电以后，DRAM和SRAM都会丢失它们的信息</p>
<p><strong>访问主存：</strong>每次CPU和主存之间的数据传送都是通过一系列的步骤来完成，这些步骤称为<strong>总线事务</strong>。<strong>读事务</strong>从主存传输数据到CPU，<strong>写事务</strong>从CPU传送数据到主存。总线是一组并行的导线，能携带地址、数据和控制信号。 <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/bus.png" width="600"></p>
<span id="more"></span>
<h4 id="磁盘">1.2 磁盘</h4>
<p>磁盘由盘片构成，每个盘片有两面或者称为表面，表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常在<code>5400-15000</code>转没分钟。</p>
<p><strong>下图展示了一个典型的磁盘表面结构。每个表面都是由一组称为磁道的同心圆组成的。每个磁道被划分为一组扇区。每个扇区包含相等数量的数据位，通常是512个字节。扇区之间由一些间隙分隔开，这些间隙不存储数据位，它们用来存储标识扇区的格式化位</strong> <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/disk.png" width="700"></p>
<ul>
<li><strong>旋转磁盘</strong>：b图的整个装置被称为磁盘驱动器，也简称磁盘，为了与固态硬盘SSD区分，也叫旋转磁盘，SSD是没有移动结构的，也因为这种特性，SSD读取数据更快。</li>
<li><strong>柱面</strong>：柱面是所有盘面上到主轴中心距离相等的磁道组合。</li>
</ul>
<h4 id="磁盘容量">1.3 磁盘容量</h4>
<p>一个磁盘可记录的最大位数就是它的最大容量，它由记录密度、磁道密度和面密度所决定。磁盘容量的计算公式如下：</p>
<p><span class="math display">\[
磁盘容量=每个扇区字节数×每个磁道平均扇区数×每个面磁道数×每个磁盘表面数×磁盘数
\]</span> 值得一提的是，我们在电脑或者手机中，会发现所显示的逻辑磁盘容量&lt;实际容量，这是因为由两个原因：</p>
<ul>
<li>一是厂商的磁盘容量计算不是按2进制的，即<span class="math inline">\(1GB=10^9字节\)</span>，而不是<span class="math inline">\(1GB=2^{30}字节\)</span>，明显<span class="math inline">\(2^{10}&gt;10^3\)</span></li>
<li>二是在电脑或手机中不会把所有的磁盘都用上，它会保留一些柱面作为预留手段，当磁盘的一些存储区域出现损坏时，这些预留柱面能作为应对策略，将数据拷贝到这些预留柱面来使用 。这就是为什么逻辑容量要小于实际容量</li>
</ul>
<h4 id="磁盘操作-磁盘用读写头来读写存储在磁性表面的位读写头的另一端连接到一个传动臂">1.4 磁盘操作* 磁盘用读/写头来读写存储在磁性表面的位，读写头的另一端连接到一个传动臂。</h4>
<ul>
<li><strong>寻道：通过沿着半径轴前后移动这个传动臂，驱动可以将读写头定位在盘面的任何磁道上，</strong></li>
<li><strong>旋转</strong>：一旦读写头完成寻道定位在某个磁道上，驱动器就会等待期望的扇区的第一位旋转到读写头下，这样就能够读写数据 <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/rwirte.png" width="700"></li>
</ul>
<p>磁盘一扇区大小的块来读写数据，对扇区的访问时间由三个主要的部分：寻道时间、旋转时间和传送时间</p>
<ul>
<li><strong>寻道时间：</strong>位读取某个扇区的内容，传动臂首先将读写头定位到包含目标扇区的磁道上，移动传动臂所需要的时间称为<strong>寻道时间</strong>。其平均寻道时间是在<code>ms</code>级，大概为<code>3~ms</code>，一次寻道的最大时间为<code>20ms</code>s</li>
<li><p><strong>x旋转时间</strong>：一旦读写头定位到了期望的磁道，驱动器等待目标扇区的一个位旋转到读写头下。最大的旋转延迟数以<code>ms</code>为单位，为<span class="math inline">\(1/RPM*1000ms\)</span>，其中RPM是转速</p></li>
<li><p><strong>传送时间</strong>：当目标扇区的第一位位于读写头下时，驱动器就可以开始读写扇区内容，一个扇区的传送时间依赖与旋转速度和每条磁道的三区数目。</p></li>
</ul>
<p>值得一提的是，磁盘操作中消耗时间的主要是寻道时间和旋转时间，传送时间所占的延迟是可忽略的的</p>
<h4 id="固态硬盘">1.5 固态硬盘</h4>
<p>固态硬盘是一种基于闪存的存储技术，一个SSD封装由一个或多个闪存芯片和闪存翻译层组成，闪存芯片代替传统的旋转磁盘中的器械驱动器，而闪存翻译层是一个硬件设备，扮演与磁盘控制器相同的角色。将对逻辑块的请求翻译成对低层物理设备的访问。 <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/SSD.png" width="700"> <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/SSDspead.png" width="700"></p>
<h3 id="局部性-一个编写良好的计算机程序常常具有良好的局部性即他们更加倾向于引用邻近于其他最近引用过的数据项的数据项或者最近引用或的数据项本身这种特性常常称为局部性原理局部性由两种不同的形式时间局部性和空间局部性">2 局部性* 一个编写良好的计算机程序常常具有良好的<strong>局部性</strong>，即他们更加倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用或的数据项本身，这种特性，常常称为<strong>局部性原理</strong>。局部性由两种不同的形式：<strong>时间局部性和空间局部性</strong></h3>
<ul>
<li><strong>时间局部性</strong>：被引用过一次的内存位置很有可能在不久的将来再次被多次引用。</li>
<li><strong>空间局部性</strong>：一个内存被引用过了，那么极有可能在不久的将来会引用器附近的内存位置。</li>
</ul>
<p>我们应该理解局部性原理，因为一般而言，一个良好局部性的程序比局部性差的程序运行得更快，这是由现代计算机系统得设计结构所决定得，在现代计算系统得各个层次之哦你给，都引入了局部性原理：</p>
<ul>
<li>在硬件层，计算机设计者通过引入称为<strong>高速缓存存储器</strong>这样小而快得快速存储器来保存最近引用得指令和数据项，从而提高对主存得访问速度。</li>
<li>在操作系统中，系统使用主存作为<strong>虚拟地址空间</strong>，来存储最近被引用得数据项，来避免因从磁盘取数据过慢而导致CPU资源的浪费</li>
<li>类似的，操作吸引还用主存来缓存磁盘文件中最近被使用的磁盘块。</li>
<li>局部性原理在应用程序中也有应用，入<code>Web</code>浏览器将最近引用的文档放在本地磁盘上，利用的就是时间局部性。</li>
</ul>
<p>从上可以看出，局部性原理贯穿现代计算机系统的方方面面，因此设计局部性良好的程序是编程应该注意的事项。 <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/local.png" width="700"> <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/localbad.png" width="700"></p>
<ul>
<li><strong>原则</strong>：
<ul>
<li>1.重复引用相同变量的程序有良好的局部性</li>
<li>对于具有步长位k的引用模式程序，步长越小，空间局部性越好。</li>
<li>对于取指令，循环有好的时间和空间局部性，循环越小，循环迭代次数越多，局部性越好。</li>
</ul></li>
</ul>
<h3 id="存储器的层次结构">3 存储器的层次结构</h3>
<p>现代计算机系统都是使用了一种组织存储器系统的方法，称为<strong>存储器层次结构</strong>，从高层往低层走，存储设备变得更慢、更便宜和更大，在最高层，是少量的CPU寄存器，CPU可以在一个始终周期访问它们；接下啦是<code>L1~L3</code>的高速缓存。 <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/hierarchy.png" width="700"></p>
<p>高速缓存<code>cache</code>是一个小而快速的存储设备，他作为存储在更大、也更慢的设备中的对象的缓冲区域。<strong>存储器层次结构的中心思想是，对于每个<code>K</code>，位于<code>K</code>层的更快更小的存储设备作为位于<code>K+1</code>层的更大更慢的存储设备的缓存。即层次结构的设计是为了每一层都缓存来自较低一层的数据对象</strong> <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/cache.png" width="700"> 数据总是以块大小为传送单元在第<code>K</code>层和第<code>K+1</code>层之间来回复制，这不过这个<code>块大小</code>在各层是不一样的，在<code>L0</code>和<code>L1</code>是一个字大小，在<code>L1</code>和<code>L2</code>是几十个字节。一般而言，层次结构中较低层的设备访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用更大的块。</p>
<p><strong>命中和未命中</strong>：说到缓存层次结构就必须提到缓存命中和未命中的情况。</p>
<ul>
<li><strong>缓存命中：</strong>当程序需要第<code>K+1</code>层的某个数据对象<code>d</code>时，它首先会正在当前存储在<code>k</code>层之前的存储层次中查找<code>d</code>，如果<code>d</code>刚好缓存在<code>K</code>层中，那么就是我们所说的<strong>缓存命中</strong>。缓存命中读数据明显会快于缓存未命中时的情形。</li>
<li><strong>缓存未命中</strong>：缓存未命中恰好是缓存命中相反的情况，这时就会去下层存储结构找到包含数据<code>d</code>的数据块。并且会将数据缓存至<code>K</code>层，如果<code>K</code>层已满，可能会覆盖现存在<code>K</code>层中的数据块
<ul>
<li><p><strong>冷不命中：冷不命中是由于冷缓存所导致，这是因为计算机刚启动时，缓存肯定是空的，这时候在高层存储结构肯定是没有数据被命中</strong>。冷不命中是短暂事件，因为反复访问存储器器会使得缓存暖身，直至缓存占满。冷不命中也称为<strong>强制性不命中</strong></p></li>
<li><p><strong>冲突不命中：这时因为硬件缓存使用的是像哈希一样的缓存放置策略，就是第<code>k+1</code>的某个块被限制在放置在第<code>k</code>层的一个小子集里（甚至是某一个块），比如某些缓存放置策略使用<code>mod</code>，即<code>k+1</code>的数据块i，必须放置在<code>k</code>层<code>i mod len(k)</code>上。</strong>这样可能导致<code>k</code>层的缓存并不是满，但是也没有位置存储数据<code>d</code>，导致冲突未命中，这样就会在<code>k+1</code>层查找数据<code>d</code>，找到后放置在<code>k</code>层并覆盖原缓存数据</p></li>
</ul></li>
</ul>
<p>缓存与局部性是浑然一体的，这时因为：</p>
<ul>
<li><strong>利用时间局部性原理</strong>：由于时间局部性，同一数据对象可能会被多次使用。一旦一个数据对象在第一次不命中是被复制到缓存中，我们期望后面对该目标有一系列的访问命中，因为缓存比低一层的存储设备更快，对后面的命中服务会比最开始的不命中快很多</li>
<li><strong>利用空间局部性原理</strong>：块通常包含多个数据对象，。由于空间局部性，我们会期望后面对该块中其他对象的访问能够补偿不命中后复制该块的花费。 <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/list.png" width="700"></li>
</ul>
<h3 id="高速缓存存储器">4.高速缓存存储器</h3>
<p>高速缓存存储器因为可以缓存数据，那么这些数据是如何被寻址查找、替换的呢。在高速缓存存储器中存在四个参数：<code>S</code>标识有几组高速缓存存储器、<code>E</code>表示每组有多少行、<code>B</code>表示每行有<span class="math inline">\(2^B\)</span>字节数据块组成、m位标记位,即使用<span class="math inline">\((S,E,B,m)\)</span>： <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/cachelevel.png" width="700"></p>
<p>在寻址的过程中通过确定<strong>所在的组S、查看有效位是否有效和标记为是否对应，如果满足上面三个，那么就说明数据在这个缓存区域内，通过行偏移地址得到该数据块的指定数据</strong>，如下面所示： <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/cacheWork.png" width="700"></p>
<ul>
<li>从上面的结构我们可以分析知道，造成冲突不命中的情况是源于每个缓存组只有一行,即<code>E=1</code>，那么为了减小冲突不命中情况，可以增加行，此时称为组相联高速缓存 <img src="/2023/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/cachegroup.png" width="700"></li>
</ul>
<h4 id="读写时情况">4.1 读写时情况</h4>
<p><strong>高速缓存出现不命中时，由不命中带来的开销是很大的，为了弥补这种开销，计算机设计者们充分利用空间局部性，以数据块的形式进行缓存</strong>。</p>
<p>同时在缓存未命中的清况下，高速缓存就必须从内存中取出包含这个数据的块，不过一旦高速缓存取出该块，该替换哪一行呢(直接映射高速缓存没有这种困扰，因为它就只有一行）。我们之前讲过不同的计算机使用不同的策略，有一些使用哈希所有它们的形式不尽相同。如果有一个空行可替换，那最好，但是如果没有空行，在组相联高速缓存中，替换哪一行是一个问题。</p>
<p>在计算机中，有使用<strong>最不常使用(LFU)</strong>和<strong>最近最少使用(LRU)</strong></p>
<ul>
<li><p><strong>读</strong>：高速缓存的读非常简单，首先，在高速缓存查找所需数据，若命中，立即返回该数据给CPU；若未命中，从存储器层次结构的较低层中取出包含该数据的块，将这个块存储到某个高速缓存行中（可能会驱逐某一行），然后返回该数据给CPU.</p></li>
<li><strong>写</strong>：写要复杂一些。
<ul>
<li>首先考虑写命中，加入我们写一个已经缓存的数据<code>W</code>之后，它会怎么来<strong>保持数据的一致性</strong>呢。有两种方法：
<ul>
<li><strong>直写（write-through)</strong>：直接将数据<code>w</code>写回紧接着缓存的低一层。这种方法简单，但是每次写都会引起总线流量</li>
<li><strong>写回(write-back)</strong>：尽可能的推迟这种更新，只有当替换算法要驱逐这个更新过的块时，才将它写到紧接着的下一层。由于局部性，这种放松明显减少了总线流量，但是缺点是在缓存的硬件中要额外维护一个修改标志位，这样才能识别是否被修改过。<br>
</li>
</ul></li>
<li>写不命中时，也有两种情况：
<ul>
<li><strong>写分配（write-allocate)</strong>：加载相应低一层的数据块到高速缓存中，然后更新这个高速缓存块。利用空间局部性来弥补未命中情况</li>
<li><strong>写不分配(not write-allocate)</strong>：避开高速缓存，直接把这个字写到低一层中，</li>
</ul></li>
</ul></li>
</ul>
<h4 id="高速缓存参数的性能影响">4.2 高速缓存参数的性能影响</h4>
<ul>
<li>未命中率：在一个程序执行或程序的一部分执行期间，内存引入不命中的比率<code>不命中数量/引用数量</code></li>
<li>命中率：<code>1-未命中率</code></li>
<li>命中时间：从高速缓存传送一个字节到CPU的时间，包括<strong>组选择、行确认和字选择的时间</strong>。L1只需几个时钟周期</li>
<li>未命中时间：由于不命中需要额外的时间。L1不命中需要从L2得到服务的惩罚，通常为数十个周期；L2不命中从L3得到服务的惩罚，50个周期；从主存得到服务的惩罚，200个周期。</li>
</ul>
<p><strong>高速缓存大小、块大小和相联度的影响：</strong></p>
<ul>
<li><strong>高速缓存的大小：</strong>较大的高速缓存能够提升命中率，然后却会增加命中时间，这时因为缓存越多，要<strong>组、行和字偏移</strong>就越复杂，那么寻址中的<strong>组选择、行确认和字选择的时间</strong>越多。</li>
<li><strong>块大小</strong>：大的数据块充分利用空间局部性，帮助提高命中率；但是，由于给定的高速缓存大小，块越大说明行越少，会损害时间局部性。同样较大的块也会对未命中惩罚造成负面影响，因为块越大，传送的时间就越多，</li>
<li><strong>相联度</strong>：<code>E</code>较高可以降低高速缓存的冲突不命中情况；但较高的相联度，造价昂贵，也增加了命中时间。</li>
</ul>
<h4 id="高速缓存友好的代码特点">4.3 高速缓存友好的代码特点</h4>
<ul>
<li><p>让最常见的情况运行得快。程序通常把大部分时间都花在少量的核心函数上，而这些函数通常把大部分时间都花在了少量的循环上。所以要把注意力集中在核心函数的循环上，而忽略其他部分。</p></li>
<li><p>在每个循环内部使缓存不命中数量最小。在其他条件，例如加载和存储的总次数相同的情况下，不命中率低的程序运行得更快。</p></li>
</ul>
<blockquote>
<p>注意：编译器将局部变量存储到寄存器中，因此循环内对局部变量的引用不需要任何加载或存储指令。</p>
</blockquote>
<p><strong>高速缓存对程序性能的影响</strong></p>
<ul>
<li><p>通过重新排列循环以提高空间局部性：降低高速缓冲的不命中率。例子（求两个矩阵的乘积）</p></li>
<li><p>使用分块来提高时间局部性。</p></li>
</ul>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统-异常控制流</title>
    <url>/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<h3 id="异常控制流">1 异常控制流</h3>
<p>现代系统通过使控制流发生突变来对这些情况做出反应，我们把这些突变称为异常控制流(ECF)。</p>
<ul>
<li>在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序；</li>
<li>在操作系统层，内核通过<strong>上下文切换</strong>将控制从一个用户进程转移到另一个用户进程；</li>
<li>在应用层，一个进程可发发送信号到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序。</li>
</ul>
<p>作为程序员，理解ECF很重要：</p>
<span id="more"></span>
<ul>
<li><p>理解<code>ECF</code>将帮助你理解重要的系统概念。<strong><code>ECF</code>是操作系统用来实现I/O、进程和虚拟内存的基本机制。</strong></p></li>
<li><p>理解<code>ECF</code>将帮助你理解应用程序是如何与操作系统交互的。应用程序通过使用一个叫做<strong>陷阱或者系统调用(system call)</strong>的<code>ECF</code>形式，向操作系统请求服务。比如，向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程。</p></li>
<li><p>理解<code>ECF</code>将帮助你理解并发。ECF是计算机系统中实现并发的基本机制</p></li>
</ul>
<h4 id="异常">1.1 异常</h4>
<p>异常就是控制流中的突变，用来响应处理器状态红的某些变化。状态变化称为<strong>事件<code>event</code></strong>，比如发送<strong>虚拟内存缺页、算术溢出</strong>。 <img src="/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/event.png" widtg="500"> 在任何情况下，当处理器检测到事件发生时，<strong>会通过一张叫做异常表的跳转表，进行一个间接过程调用，到一个专门处理该类事件的异常处理程序。</strong></p>
<p><strong>当系统启动时，会分配和初始化一个异常表，里面包含各种对应异常号的处理程序地址，当检测到一个异常号<code>k</code>,处理器就会触发一个异常，通过在异常表寻找相应的异常号，然后间接调用对应处理程序</strong>。异常表的起始地址会放在一个叫做<strong>异常表基址寄存器的特殊CPU寄存器里</strong>。当异常处理程序执行完毕后，有三个状况：</p>
<ul>
<li>处理程序将控制返回给当前指令<span class="math inline">\(I_{curr}\)</span>，即事件发送时正在执行的指令</li>
<li>处理程序将控制返回给当前指令<span class="math inline">\(I_{next}\)</span>，即事件发送时正在执行的下一条指令</li>
<li>处理程序终止被中断的程序 <img src="/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/table.png" widtg="500"></li>
</ul>
<p><strong>异常类似于过程(函数)调用，但也有一些重要的不同之处；</strong></p>
<ul>
<li>过程调用时，在跳转处理程序前，处理器会把返回地址压入栈中。然而，异常会有不同的反应，要么返回当前指令，要么使下一条指令，也有可能直接终止这个触发异常的程序。</li>
<li>处理器会把一些额外的处理器状态压入到栈中，处理程序返回时，重新执行被中断的程序会需要这些状态。</li>
<li>如果控制从用户态撞到内核态，所有的这些项目都被压入到内核栈中，而不是用户栈。</li>
<li>异常处理程序在内核态下，意味着他们对所有的系统资源都有完全访问权限。</li>
</ul>
<h4 id="异常类别">1.2 异常类别</h4>
<p>异常有四类：<strong>中断、陷阱、故障和终止。</strong> <img src="/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/exce.png" widtg="700"></p>
<h5 id="中断">1.2.1 中断</h5>
<p><strong>中断是异步的，是来自处理器外部的I/O设备信号的结果</strong>。硬件中断不是由任何一条专门的指令造成的而是由于处理器外部发送状态变化而引起的 ，因此是异步的，同时硬件中断的异常处理程序称为中断处理程序。如定时器中断 <img src="/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/exce.png" widtg="700"></p>
<h5 id="陷阱和系统调用">1.2.2 陷阱和系统调用</h5>
<p>陷进是有意为之的异常，陷进处理程序将控制返回下一条指令。<strong>陷阱最重要的用途是在用户态和内核态之间提供一个像过程样的接口，叫做系统调用</strong>。比如<strong>读一个文件，创建一个新的进程、加载一个新的程序、或者之中当前的进程</strong>。 <img src="/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/systemcall.png" widtg="700"> 系统调用和普通函数的调用是一样的。但是它们的实现非常不同：</p>
<ul>
<li><strong>普通函数运行在用户态下，用户模式限制了函数可以执行的指令类型，而且只能访问与调用函数相同的栈。</strong></li>
<li><strong>系统调用则运行在内核模式下，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。</strong></li>
</ul>
<h5 id="故障">1.2.3 故障</h5>
<p>故障由错误情况引起，它可能会被故障处理程序修正，处理器将控制转移给故障处理程序，如果处理器能够修复这个错误情况，就会把控制返回到引起故障的指令，从而重新执行它，否则返回到内核中的<code>abort</code>例程，<code>abort</code>例程会终止引起故障的程序。 <img src="/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/abort.png" widtg="700"> 一个经典的故障就是<strong>缺页异常</strong>，当指令引用一个虚拟地址，而该地址相对于物理页面来说还未加载到内存中，必须从磁盘中取出是，就会产生故障。（一般来说，一个页面就是虚拟内存的一个连续的块，经典的是4KB）</p>
<h5 id="终止">1.2.4 终止</h5>
<p>终止是不可恢复的致命错误造成的，通常是一些硬件错误处理程序会将控制返回给一个<code>abort</code>例程，终止这个应用程序。</p>
<blockquote>
<p>在x86-64系统定义了高达256中不同的异常类型。<code>0~31</code>是Intel架构师定义的异常，<code>32~255</code>是对应操作系统定义的中断和陷阱。</p>
</blockquote>
<h4 id="用户模式和内核模式">1.3 用户模式和内核模式</h4>
<p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及可访问的地址空间范围。处理器通常用控制寄存器的某一个<strong>模式位</strong>来提供这种功能。当设置了模式位，进程就运行在内核模式，否则运行在用户模式。</p>
<p>内核模式和用户模式的区别：</p>
<ul>
<li><p><strong>用户模式：</strong>用户模式中的进程不允许执行特权指令，比如停止处理器，改变模式位，或者发起一个I/O操作；也不允许进程直接引用地址空间中内核区的代码和数据；要使用上面操作，用户进程就必须通过系统调用由用户态切换到内核态才可以。</p></li>
<li><p><strong>内核模式</strong>：一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中内存的任何位置。</p></li>
</ul>
<h4 id="上下文切换">1.4 上下文切换</h4>
<p>操作系统内核使用一种称为<strong>上下文切换</strong>的较高层形式异常控制流实现多任务，</p>
<ul>
<li><strong>上下文：上下文是由程序的正确运行所需的状态组成，是存放在内存程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器和打开的文件描述符等的集合</strong></li>
</ul>
<p>当进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策就叫做<strong>调度</strong>，由内核中的<strong>调度器</strong>代码处理的。</p>
<p>当内核选择了一个新的进程运行是，我们就说内核调度了这个进程。当内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为<strong>上下文切换</strong>的机制来将控制转移到新的进程，上下文切换工作：</p>
<ul>
<li>保持当前进程的上下文</li>
<li>恢复某个先前被抢占的进程被保持的上下文</li>
<li>将控制传递给这个新恢复的进程 <img src="/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/context.png" widtg="700"></li>
</ul>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统-虚拟内存</title>
    <url>/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h3 id="虚拟内存">1 虚拟内存</h3>
<p>一个系统中的进程是与其他进程共享CPU和主存资源的。在之前我们明白一个进程会有4GB的内存，但实际中不可能为一个进程真实的分配这么多，否则对于8G的主存，只要两个进程就占满了。因此，计算机系统的设计者们引入了一中很聪明的做法——<strong>虚拟内存</strong>。</p>
<p>虚拟内存是硬件异常、硬件地址翻译、主存和磁盘文件和内核软件的完美交互：</p>
<h4 id="虚拟寻址和地址空间">1.1 虚拟寻址和地址空间</h4>
<p>在计算机中每个字节都存在它唯一的地址，该地址就是<strong>物理地址</strong>，我们将通过真实物理地址进行寻址的方法称为<strong>物理地址</strong>。</p>
<p>而虚拟地址，是指由CPU生成一个<strong>虚拟地址（VA）</strong>来访问主存，如下图，这个虚拟地址在送到内存之前会经过<code>MMU内存管理单元</code>来翻译成物理地址，在这里会结合到后面的<strong>页表</strong>来进行翻译。通过虚拟地址寻址的方式就是<strong>虚拟寻址</strong>。现在计算绝大部分都是使用<strong>寻你寻址</strong>。 <img src="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/MMU.png" width="700"></p>
<p><strong>地址空间</strong>：</p>
<ul>
<li><strong>虚拟地址空间</strong>：虚拟地址空间一般以地址总线条数为基准，如32位的位<span class="math inline">\(2^{32}=4GB\)</span></li>
<li><strong>物理地址空间</strong>：对应与实际内存挡住的M字节，一般来说，物理地址空间由进程运行过程中所实际使用的内存大小所决定</li>
</ul>
<p>物理地址空间和虚拟地址空间是对应关系的，即由虚拟地址找到真实的物理地址。</p>
<h4 id="虚拟内存是作为缓存的工具">1.2 虚拟内存是作为缓存的工具</h4>
<p>在概念上，<strong>虚拟内存是指存放在磁盘上的N字节大小的内存区域，</strong>每个字节都要相应的虚拟地址，作物寻址索引。<strong>和存储结构的缓存一样，磁盘的数据也被分割成块，在这类为做区别称之为虚拟页，每个虚拟页大小由计算机系统决定为<span class="math inline">\(P=2^p\)</span></strong>，与之对应的是物理页，其大小也应该为<code>P</code>。</p>
<p>在任何时刻，我们都不能实际真实一股脑的为进程分配全部的存储空间，因此虚拟页面分为三个不相交的子集：</p>
<ul>
<li><strong>未分配的：</strong>VM系统还没有分配的页，此时未分配的块没有任何数据和它们管理，因此此时不会占有任何磁盘空间</li>
<li><strong>缓存的</strong>：当前缓存的虚拟页在占有磁盘中的空间，当然由于缓存到内存。内存当中也会占有一定内存空间</li>
<li><strong>维缓存的</strong>：在磁盘中占用空间，但并未缓存在内存中，当然不占用内存(此时当CPU要寻址该页当中一个数据时，由于未缓存在内存中，就会造成<strong>缺页异常</strong>。) <img src="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/VP.png" width="700"></li>
</ul>
<span id="more"></span>
<blockquote>
<p>为与存储结构的缓存做区分<code>L1、L2、L3</code>的缓存机制称为<code>SRAM缓存</code>，主存和磁盘之间的缓存即虚拟内存缓存称为<code>DRAM缓存</code></p>
</blockquote>
<h4 id="页表">1.3 页表</h4>
<p>虚拟内存系统必须以某种方法来判断一个虚拟页是否在主存DRAM上，如果时，还必须缺点在DRAM的哪个位置。若不命中，还必须知道它在磁盘的哪个位置，同时还必须用<strong>页调度算法</strong>在物理内存中牺牲一个页进行替换。</p>
<p>上述的功能由软硬件共同结合作用，包括操作系统软件、MMU和重要的数据结构——<strong>页表</strong>。<strong>页表上是虚拟地址和物理页的关系，它常驻在主存上</strong>。每次地址翻译硬件将一个虚拟地址转为物理地址时，都会读取页表。页表的结构如下，页表就是<strong>页表条目<code>PTE</code>数组</strong> <img src="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/PTE.png" width="500"> 在页表条目中会有三种情况，</p>
<ul>
<li><strong>缓存的：已经缓存的有效位会置<code>1</code>,同时后面存储着相应的物理页号。</strong></li>
<li><strong>未缓存的</strong>：有效位置<code>0</code>,后面存储着在磁盘的地址。</li>
<li><strong>未分配</strong>：有效位为<code>0</code>，后面是<code>null</code></li>
</ul>
<h4 id="页命中和缺页">1.4 页命中和缺页</h4>
<ul>
<li><p><strong>页命中：在上图中，当cpu想读包含在<code>VP2</code>中的虚拟内存的一个字时，VP2此时已被缓存在主存中，地址翻译硬件此时将虚拟地址的作为一个索引来定位页表的<code>PTE2</code>，并从内存中读取它。因为设置了有效位，地址翻译硬件知道<code>VP2</code>此时已经缓存在主存中。所有使用<code>PTE</code>中的物理页号来该数据的构造物理地址。</strong> <img src="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/aimed.png" width="700"></p>
<ul>
<li><strong>步骤：</strong>
<ul>
<li>第一步：处理器生成一个虚拟地址<code>VA</code>，并把它传送给MMU</li>
<li>第二步：MMU用VA生成寻址索引<code>PTEA</code>来定位<code>PTE</code>，从高速缓存/主存得到它</li>
<li>第三步：高速缓存/主存MMU返回一个PTE</li>
<li>第四步：MMU利用PTE和VA构造物理地址，并把它传送给高速缓存</li>
<li>第五步：高数缓存/主存返回所请求的的数据给处理器</li>
</ul></li>
</ul></li>
<li><strong>缺页</strong>：此时若CPU要使用<code>VP3</code>该页中某块的某个数据，由于主存并没有缓存该物理页，因此页表的<code>PTE</code>有效位为<code>0</code>，就会触发缺页异常，执行缺页处理程序，进行页面调度替换后再返回原来执行的指令<span class="math inline">\(I_{cur}\)</span>重新执行该虚拟的地址上的数据请求。<strong>在缺页异常处理程序，该程序会选择一个牺牲页作为替换<code>VP3</code>,假如选择了<code>VP4</code>作为替换页，若<code>VP4</code>修改了，那么内核执行写回操作，将他复制回磁盘。</strong>
<ul>
<li><strong>步骤：</strong>
<ul>
<li>第一步和第三步：与上述一样</li>
<li>第四步：PTE的有效位是零，所以MMU回触发缺页异常，传递给CPU中的控制到操作系统内核中的缺页异常处理程序。</li>
<li>第五步：缺页异常处理程序确定物理内存的牺牲页，如果这个页面已经被修改，则把它换出到磁盘</li>
<li>第六步：缺页异常处理程序调入新的页面，并且更新页表对应的<code>PTE</code></li>
<li>第七步：缺页异常处理程序返回到原来的进程，再次执行导致缺页的指令。 <img src="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/miss.png" width="700"></li>
</ul></li>
</ul></li>
</ul>
<h4 id="多级页表">1.5 多级页表</h4>
<p>对于单级页表，无论是否分配，我们都要维护PTE,试想一下<code>32位</code>系统，页面大小是<code>4KB</code>和一个<code>4</code>字节的PTE，那么在内存中总需要用<span class="math inline">\(4GB/4KB*4byte=4MB\)</span>的页表，对于64位来说更加复杂。内存是计算机很稀缺的资源，我们当然不希望内存因为存储页表而耗费太多的内存，<strong>虚拟内存并不是所有都会分配使用，因此多级页表利用这个特性解决这个问题的。</strong></p>
<p>下面展示的是二级页表，<strong>在一级页表中只有<code>1024</code>个PTE，它常驻内存，接下啦是二级页表，二级页表当中只有在一级页表中能够确定分配的才会驻存在内存，其他的未分配则不会生成，因此这样就能够大大节约内存</strong> <img src="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/manyLevel.png" width="700"> 上图中只占用了内存<span class="math inline">\(1024*4Byte*4=16KB\)</span></p>
<h4 id="局部性和页面分配">1.5 局部性和页面分配</h4>
<p>上述的缺页异常，就是页未命中，不命中的惩罚代价是很大的，很可能会影响程序性能。然而实际上，虚拟内存工作的很好，这归公与我么之前提到的<strong>局部性原理</strong>。</p>
<p>通过以页面形式进行缓存，来补偿未命中的惩罚。局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面集合上活动，这个集合可称为<strong>常驻集合</strong>。</p>
<p><strong>分配页面</strong>：</p>
<p>上述图中存在未分配的页面，当我们相要分配时，可使用<code>malloc</code>，<code>VP5</code>的分配过程就是在磁盘上创建空间并更新<code>PTE5</code>.</p>
<h4 id="虚拟内存的作用">1.6 虚拟内存的作用</h4>
<p><strong>虚拟内存和按需页面调度进主存</strong>的机制，不仅大大较少了主存的空间压力，也使得在<code>8G</code>主存的计算机上能够运行上百个进程。同样<code>虚拟内存VM</code>还简化了程序的连接、加载，代码和数据共享已经应用程序的内存分配。</p>
<ul>
<li><strong>简化链接</strong>：独立的地址空间允许每个进程的内存映像使用相同的格式，且都是相同的虚拟起始地址,只要保证虚拟内存地址得顺序就可以，而不用管代码和数据实际存放在物理内存的何处。</li>
<li><strong>简化加载</strong>：虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。把目标文件<code>.txt</code>和<code>.data</code>加载到一个进程中，只要Linux加载器为代码和数据段分配对应虚拟页就可。</li>
<li><strong>简化共享：</strong>进程间共享内存更加简便，只要在每个进程得页表维护一个相同得<code>PTE</code></li>
<li><strong>简化内存分配</strong>：当一个允许得用户进程想要额外得堆空间时，操作系统通过分配一个适当数字k的连续虚拟内存，并将它们映射到物理内存的K个任意物理页面即可（即虚拟内存上看时连续的，但实际物理上任意）</li>
</ul>
<blockquote>
<p>虚拟内存存在也使得进程无法去访问修改一个页表中不存在的地址，同时进程页表的设置不像上面那么简单，他还设置了三个许可位，如<code>SUP\READ\WRITE</code>，表示是否内核模式下才能访问，若过程序访问一个位置没有遵循上述条件，就会产生大家熟悉的<strong>段错误(<code>Segmentation fault</code>)</strong></p>
</blockquote>
<h4 id="理解写时复制">1.7 理解写时复制</h4>
<p>一个对象被樱色到虚拟内存中的区域，要么作为<strong>共享对象</strong>，要么作为<strong>私有对象</strong>。</p>
<ul>
<li><p><strong>共享对象：</strong>如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到虚拟内存内存的其他进程来说也是可见的 <img src="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/shared.png" width="700"></p></li>
<li><p><strong>私有对象</strong>：即对象进程私有，本进程的修改对其他进程不可见。值得一提的是私有对象使用了一种<strong>读时共享、写时复制</strong>的技术，以此节约了内存。<strong>当一个进程试图写一个私有对象，这个写操作就会触发一个保护故障，当故障处理程序注意到保护异常由于进程写私有区域时，它就会在物理内存创建一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的写权限</strong> <img src="/2023/05/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/private.png" width="700"> &gt;<code>fork()</code>函数也时采用了<code>读时共享，写时复制</code>的技术。</p></li>
</ul>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统-链接</title>
    <url>/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h3 id="链接器">1 链接器</h3>
<h4 id="链接是什么">1.1 链接是什么</h4>
<p><strong>链接是将各种代码和数据片段收集并组合成为一个单一文件的过程</strong>，这个文件可被加载到内存并执行。</p>
<ul>
<li>链接可以执行与编译时，也就是源代码被翻译成机器代码时；</li>
<li>也可以执行与加载时，也就是在程序被加载器（loader)加载带内存并执行时</li>
<li><strong>甚至也可执行于运行时，也就是有程序来执行</strong></li>
</ul>
<p>链接器在开发中是一个关键角色，因为它使得<strong>分离编译</strong>成为可能，我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以分解成更小、更好管理的模块。可以单独修改和编译这些模块。理解<strong>链接</strong>有以下的好处：</p>
<ul>
<li><p><strong>理解链接器将帮助你构造大型程序</strong>。构造大型程序的程序员经常会遇到<strong>缺少模块、库或者不兼容版本引起的链接器错误</strong>，当你理解了链接器如何<strong>解析引用、什么是库以及链接器是如何使用库来解析引用时，你就能够较好的解决这类问题</strong></p></li>
<li><p><strong>理解链接器将帮助你避免一些危险的编程错误</strong>。Linux链接器解析引用时所做的决定可以不动声色影响你程序的正确性。在默认情况下，错误的定义多个全局变量的程序将通过链接器，而不产生任何警告信息。</p></li>
<li><p><strong>理解链接器将帮助你理解语言的作用域规则是如何实现的</strong>。全局变量和局部变量、static变量和static函数，在低层到底有何区别？</p></li>
<li><p><strong>理解链接器帮助你理解其他重要系统概念</strong>。链接器产生的可执行目标文件咋子系统功能中扮演关键角色，如<strong>加载运行程序、虚拟内存、分页、内存映射。</strong></p></li>
<li><p><strong>理解链接器将使你能够利用共享库</strong>。共享库和动态链接在现代操作系统日益重要，掌握如何动态链接原理极其重要。</p></li>
</ul>
<span id="more"></span>
<h4 id="编译器驱动程序">1.2 编译器驱动程序</h4>
<p>我们将以下面两个源程序<code>main.c</code>和<code>sum.c</code>作为例子，来说明静态链接器<code>ld</code>的工作流程。 <img src="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/main.png" width="700"></p>
<ul>
<li><p>首先我们在<code>shell</code>输入以下命令来调用GCC驱动程序（下面分析以<code>main.c</code>为例）： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -Og -o prog main.c sum.c</span><br></pre></td></tr></table></figure> 下图概括了从源文件翻译成可执行文件时的行为（若想看这些步骤，加入<code>-v</code>): <img src="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/staticlink.png" width="600"></p>
<ul>
<li>输入上述语句后，会先执行C预处理器<code>cpp</code>，它将源程序<code>main.c</code>经过宏替换、头文件展开后生成一个中间文件<code>main.i</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cpp [other arguments] main.c /tmp/main.i</span><br></pre></td></tr></table></figure></li>
<li>接下来，运行C编译器<code>ccl</code>，它将预处理后的文件<code>main.i</code>进行编译，生成汇编文件<code>main.s</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ccl /tmp/main.i -Og [other arguments] -o /tmp/main.s</span><br></pre></td></tr></table></figure></li>
<li>接着，驱动程序运行汇编器<code>as</code>，它将汇编文件翻译成一个可重定位目标文件<code>mian.o</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">as [other arguments] -o tmp.main.o /tmp/main.s</span><br></pre></td></tr></table></figure></li>
<li>同样方式得到<code>sum.o</code>。最后，运行链接器程序<code>ld</code>，将<code>main.o</code>和<code>sum.o</code>以及一些比如的系统目标文件组合起来，创建一个可执行文件<code>prog</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ld -o prog [system object files <span class="keyword">and</span> args] /tmp/main.o tmp/sum.o</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="静态链接器">1.3 静态链接器</h4>
<p>静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接、可加载运行的可执行文件作为输出。<strong>输入的可重定位目标文件由各种代码和数据节组成</strong>。在构造可执行文件中，链接器主要完成两个任务：</p>
<ul>
<li><strong>符号解析：</strong>每个符号对应一个函数、一个全局变量和一个静态变量，符号解析的目的就是将每个符号引用正好和一个符号定义关联起来。那么当然在不同目标文件中引用的同一全局变量或函数，链接器需要将其解析为同一个实体。**</li>
<li><strong>重定位</strong>：地址重定位指的是在链接过程中，需要将不同目标文件中的函数和变量的地址进行调整，使得它们在最终的可执行文件中能够正确地链接到一起。生成可执行文件</li>
</ul>
<p><strong>目标文件有三种形式：</strong></p>
<ul>
<li><strong>可重定位目标文件</strong>：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行文件</li>
<li><strong>可执行文件</strong>：包含二进制代码和数据，其形式可直接复制到内存并执行</li>
<li><strong>共享目标文件</strong>：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ul>
<h4 id="可重定位目标文件">1.4 可重定位目标文件</h4>
<p><img src="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/ELF.png" width="500"></p>
<ul>
<li><p><code>.text</code>段存放编译好的机器代码。查看机器代码，需要使用反汇编工具objdump将机器代码转换成汇编代码。由于4字节对齐，<code>.text</code>大小为0x51，实际占用空间大小为0x54。</p></li>
<li><p><strong><code>.data</code>段用来存放已初始化的全局变量和静态变量的值。</strong></p></li>
<li><p><strong><code>.bss</code>段存放未初始化的全局变量和静态变量，需要注意的是，被初始化为<code>0</code>的全局变量和静态变量也存放在bss中</strong>。<code>bss</code>可理解为<code>Better Save Space</code>。局部变量既不在<code>data</code>中，也不在<code>bss</code>中。实际上<code>bss</code>段并不占据实际的空间，它仅仅是只是一个占位符。</p></li>
<li><p><strong><code>.rodata</code>段存放只读数据。例如 <code>printf</code>中的格式串和<code>switch</code>语句中的跳转表以及<code>const全局变量</code>就是存放在这个区域。</strong></p></li>
<li><p><code>.symtab</code>符号表，它存放在程序中定义和引用的函数和全局变量的信息</p></li>
</ul>
<h4 id="符号和符号表">1.5 符号和符号表</h4>
<p>每个可重定位模块<code>m</code>都有一个符号表、它包含<code>m</code>定义的和引用的符号的信息，在链接器上下文，有三种不同符号：</p>
<ul>
<li>全局符号：由模块<code>m</code>定义并能被其他模块引用的去安居符号，其对应于非静态的函数和全局变量</li>
<li>外部符号：由其他模块定义被被模块<code>m</code>引用的去安居符号，称为外部符号，对应于其他模块定义的非静态C函数和全局变量</li>
<li>局部符号：只被模块m定义和引用的局部符号，对应于static函数、static全局变量。这些符号在模块<code>m</code>中可见，单不能被其他模块引用</li>
</ul>
<blockquote>
<p>局部变量由堆栈管理，因此链接器是不知道局部变量的，因此在链接器对变量的是对函数和全局变量</p>
</blockquote>
<p><strong>链接器解析多重定义的全局符号：</strong>对于全局符号，若有多个模块定义同名的全局符号的情况，会发生什么？</p>
<p>首先编译器向汇编器输出每个全局符号，这些符号或是强或是弱，汇编器把这个信息隐含的编码在可重定位文件的符号表里。函数和以初始化的全局变量是强符号，未初始化的全局变量是弱符号，Linux有以下规则：</p>
<ul>
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，那么选择强符号</li>
<li>如果有多个弱符号同名，那么可任选一个</li>
</ul>
<h4 id="静态库">1.6 静态库</h4>
<ul>
<li><strong>静态库：将所有编译好的目标模块(<code>sum.o\mul.o</code>等待)打包成一个单独的文件，这个文件就是静态库</strong>。它可以用作链接器的输入，当链接器构造一个可执行文件时，它只复制静态库里被应用程序引用的目标模块。一般都以<code>libxxx.a</code>作为静态库标识</li>
</ul>
<p><strong>制作静态库</strong>：</p>
<ul>
<li>首先编译处<code>xxx.o文件</code></li>
<li>接着利用AR工具打包<code>**.o</code>文件 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -c add.c mul.c</span><br><span class="line">ar rcs libmath.a add.o mul.o</span><br></pre></td></tr></table></figure></li>
<li>使用第三方静态库 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -o main main.c -L. -lmath</span><br></pre></td></tr></table></figure> 示例如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ ar rcs libmath.a mul.o sum.o Math.h</span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ ls</span><br><span class="line">Math.h  libmath.a  main.cpp  mul.cpp  mul.o  sum.cpp  sum.o</span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ g++ -o main main.cpp -L. -lmath</span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ ls</span><br><span class="line">Math.h  libmath.a  main  main.cpp  mul.cpp  mul.o  sum.cpp  sum.o</span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ ./main</span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ rm -rf Math.h</span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ rm -rf main</span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ g++ -o main main.cpp -L. -lmath</span><br><span class="line">main.cpp:<span class="number">2</span>:<span class="number">10</span>: fatal error: Math.h: No such file <span class="keyword">or</span> directory</span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Math.h&quot;</span></span></span><br><span class="line">          ^~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ ls</span><br><span class="line">libmath.a  main.cpp  mul.cpp  mul.o  sum.cpp  sum.o</span><br></pre></td></tr></table></figure></li>
<li>从上面可看出，<code>-L.</code>表示从当前目录找该库；</li>
<li>删除<code>Math.h</code>后出错，说明头文件寻找并不会在<code>libmath.a</code>寻找</li>
</ul>
<h5 id="链接器如何使用静态库来解析引用">1.6.1 链接器如何使用静态库来解析引用</h5>
<p>在符号解析阶段，<strong>链接器会安装我们键入的命令行顺序从左到右来扫描可重定位文件和静态库存档文件</strong>，在这次扫描中，链接器会维护三个集合<code>E、U、D</code></p>
<ul>
<li><code>E</code>：可重定位目标文件集合，在这个集合的可重定位目标文件最后会被合并起来形成可执行文件</li>
<li><code>U</code>：一个未解析符号（即应用了但尚未定义的符号）集合，这个集合扫描完成后，应该是空的，否则会程序终止，出现解析错误</li>
<li><code>D</code>：已经定义的符号集合</li>
</ul>
<p>初始化上述的三个集合都为空，执行命令行：</p>
<ul>
<li>对于命令的每个文件<code>f</code>，链接器先判断是一个目标文件还是库存档文件。
<ul>
<li><strong>若<code>f</code>是目标文件，则会把<code>f</code>添加到<code>E</code>，并且修改<code>U\D</code>来来反映<code>f</code>中的符号定义和引用</strong></li>
<li><strong>若<code>f</code>是静态库存档文件，那么链接器就尝试匹配<code>U</code>中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员<code>m</code>，定义了一个符号解析<code>U</code>中的一个引用，那么九将<code>m</code>加入到<code>E</code>中。对存档文件的成员目标文件依次进行这个过程，直到<code>U\D</code>都不再变化。此时，任何不在<code>E</code>中的成员目标文件被丢弃。</strong></li>
</ul></li>
<li>如果当前链接器完成命令行上输入文件的扫描后，<code>U</code>非空，链接器就会输出一个错误终止，否则，就是要E中目标文件构建合并可执行文件。</li>
</ul>
<p><strong>下面就是一个典型因命令行顺序不对，造成的解析引用错误（未定义引用错误）</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ g++ -L. -lmath -o main main.cpp</span><br><span class="line">/tmp/ccZFaj3X.o: In function `main<span class="number">&#x27;</span>:</span><br><span class="line">main.cpp:(.text+<span class="number">0x13</span>): undefined reference to `<span class="built_in">Sum</span>(<span class="type">int</span>, <span class="type">int</span>)&#x27;</span><br><span class="line">main.cpp:(.text+<span class="number">0x25</span>): undefined reference to `<span class="built_in">Mul</span>(<span class="type">int</span>, <span class="type">int</span>)&#x27;</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> exit status</span><br></pre></td></tr></table></figure> 正确的命令行：</p>
<ul>
<li><strong>一般生成的可执行文件在最前面</strong></li>
<li><strong>接着是各种源文件</strong></li>
<li><strong>把库文件放在最后</strong></li>
</ul>
<h4 id="共享库">1.7 共享库</h4>
<p>链接器将目标文件和库文件的代码和数据全部拷贝到可执行文件中，形成一个独立的、包含所有必需代码和数据的可执行文件。在运行时，可执行文件不需要依赖外部库文件，所有需要的代码和数据都已经包含在可执行文件中，因此</p>
<ul>
<li><strong>优点：对运行环境的依赖性较小，具有较好的兼容性,方便分发和部署，不需要外部依赖</strong></li>
<li><strong>缺点：生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间；库函数有了更新，必须重新编译应用程序</strong></li>
</ul>
<p>共享库是为了解决静态缺点的一种方法，<strong>共享库也是目标模块，在运行或加载时，可以加载带任意的内存地址，并行一个内存中的程序链接起来，这个过程称为动态链接</strong>。动态库在Linux当中未<code>libxxx.so</code>，在windows中称为<code>ddl</code></p>
<p><img src="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/share.png" width="500"></p>
<ul>
<li>首先，在任何给定的文件系统中，对于一个库只有一个<code>so</code>文件，所有引用该库的可执行目标文件共享这个<code>.so</code>文件的代码和数据，而不是像静态库的内容那样复制和嵌入带引用它们的可执行文件中</li>
<li>其次，在内存中，一个共享库的<code>.txt</code>节的一个副本可以被不同正在运行的进程共享。</li>
</ul>
<p>构造共享库 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -shared -fpic -o libmath.so sum.cpp mul.cpp</span><br></pre></td></tr></table></figure> 使用： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ g++ -shared -fpic -o libmath.so sum.cpp mul.cpp</span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ ls</span><br><span class="line">Math.h  libmath.a  libmath.so  main.cpp  mul.cpp  sum.cpp</span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ g++ -o prog2 main.cpp ./libmath.so</span><br><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:/home/project/code/link$ ./prog2</span><br></pre></td></tr></table></figure> <strong>动态库链接虽然克服了静态库的缺点，但是由于其依赖动态库，不能独立运行，因此动态库依赖版本问题严重。如果库文件版本或路径发生变化，可能会导致程序无法正常运行</strong></p>
<h4 id="从应用程序中加载和链接共享库">1.8 从应用程序中加载和链接共享库</h4>
<p>上面介绍的静态库和动态库链接都是在编译时链接到应用的，<strong>然而有些程序还可能在它运行时进行动态链接器加载和链接某个共享库，这就是运行时加载和链接。</strong></p>
<ul>
<li><strong>分发软件</strong>：微软应用常常利用共享库来分发软件更新。</li>
<li><strong>高性能Web服务器</strong>：许多We服务器生成动态内容，比如个性化的Web页面、和广告标语。</li>
</ul>
<p>上面的思路是将每个生成动态内容的函数打包在共享库，当一个Web浏览器的请求到达时，服务器动态加载和链接适当的函数，然后直接调用它。</p>
<p>Linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库 <img src="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/dlopen.png" width="700"> <code>dlsym</code>的函数参数是一个指向前面已经打开的共享库句柄和一个symbol，如果该名字存在，返回呼号地址，否则返回<code>NULL</code> <img src="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/DLSYM.png" width="700"> <code>dlclose</code>果没有其他人在使用这个共享库，就关闭 <img src="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/dlclose.png" width="700"> <code>dlerror</code>打印调用三个函数最近的错误 <img src="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/dlerror.png" width="700"></p>
<p>示例： <img src="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/example.png" width="700"> <img src="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/example2.png" width="700"></p>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统-程序的机器级表示</title>
    <url>/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="程序的机器级表示">程序的机器级表示</h2>
<p>在本章，会学习观察汇编代码和机器代码。说到汇编语言就不得不提编译器和汇编器。**编译器是基于编程语言规则、目标机器的指令集和操作系统遵循的惯例，经过一系列阶段如图：</p>
<p><img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/compile.png" width="700"></p>
<p>gcc编译器以汇编代码的形式产生输出，然后gcc调用汇编器和链接器生成二进制机器文件和可执行文件。对于Linux机，可以使用 <code>gcc -Og -S xxx.c</code>来进行学习。因为参数-Og表明不进行优化，这可以让汇编代码尽可能地保持和C源码一样的顺序，位置，排列等。</p>
<span id="more"></span>
<p><strong>编译器的作用：</strong></p>
<ul>
<li>编译器的存在使得高级语言能够被翻译成汇编语言，最终生成机器代码，供操作系统认识并执行</li>
<li>编译器提供了类型检查能够帮助我们发现许多的程序错误，保证按照一致的方式来引用和处理数据。</li>
</ul>
<p><strong>为什么要学习汇编：</strong></p>
<ul>
<li><p>能够阅读和理解汇编是一项很重要的技能。当我们以适当的命令调用编译器时，编译器就会产生一个以汇编代码形式表示的输出文件，通过去阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。</p></li>
<li><p>了解不同线程时如何共享程序数据或保持数据私有的，以及准确指导如何阿紫哪里访问共享数据，这些在并发编程非常重要，这些信息在机器代码级是可见的，</p></li>
</ul>
<h3 id="程序编码">1 程序编码</h3>
<h4 id="机器级代码">1.1 机器级代码</h4>
<p>对于机器编程来说，有两种很重要的抽象。一种是对于程序执行的抽象(使用指令集架构定义程序执行的具体情况)，一种是对于内存的抽象，使得整个虚拟地址空间在OS的加持下成为一个超大的可用数组。</p>
<p>x86-64的机器代码和原始的C代码相差颇大，比如：</p>
<ul>
<li><p><strong>程序计数器(PC)</strong>在x86-64机中代表下一条指令的位置。</p></li>
<li><p><strong>整数寄存器文件包含了16个命名的位置(就是寄存器可见的意思)，分别存储64位的值</strong>。寄存器可以用来存储地址(就像C语言的指针)，或者保存程序状态，再或者某些寄存器用于保存临时数据，列如过程调用的参数和局部变量，以及函数返回值。</p></li>
<li><p><strong>条件码寄存器，用来实现控制和数据流中的条件变化，比如<code>if</code>和<code>while</code>语句。</strong></p></li>
<li><p>一组向量寄存器可以用来存放一个或多个整数或浮点数值。</p></li>
</ul>
<h4 id="汇编文件的格式注解">1.2 汇编文件的格式注解</h4>
<p>先看一个C文件，假如其定义如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">mult2</span><span class="params">(<span class="type">long</span>,<span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multstore</span><span class="params">(<span class="type">long</span> x,<span class="type">long</span> y,<span class="type">long</span>* dest)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> t=<span class="built_in">mult2</span>(x,y);</span><br><span class="line">	*dest=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 通过gcc命令: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -Og -c mstore.c</span><br><span class="line"><span class="comment">//-Og告诉编译器使用符合原始C代码整体结构的机器代码的优化等级</span></span><br></pre></td></tr></table></figure> 得到<code>.s</code>汇编文件,完整内容如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	.file	<span class="string">&quot;010-mstore.c&quot;</span></span><br><span class="line">	.text</span><br><span class="line">	.globl multstore</span><br><span class="line">	.type	multstore,@function</span><br><span class="line">multstore:</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	movq	%rdx,%rbx</span><br><span class="line">	call	mult2</span><br><span class="line">	movq	%rax,(%rbx)</span><br><span class="line">	popq	%rbx</span><br><span class="line">	ret</span><br><span class="line">	.size	multstore, .-multstore</span><br><span class="line">	.ident	<span class="string">&quot;GCC:(Ubuntu 4.8.1-2ubuntu1-12.04) 4.8.1&quot;</span></span><br><span class="line">	.section		.note.GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span><br></pre></td></tr></table></figure> 其中，以<code>.</code>开头的行为汇编器和链接器工作的伪指令。它描述了C语言种插入汇编的方法，对于一些应用程序来说，必须使用汇编代码来访问机器的低级特性：</p>
<ul>
<li>一种方法是用汇编代码编写整个函数，在链接阶段把它们和C程序链接起来</li>
<li>另一种方法是利用GCC的支持，直接在C程序中嵌入汇编代码</li>
</ul>
<h3 id="数据格式和寄存器">2 数据格式和寄存器</h3>
<h4 id="数据格式">2.1 数据格式</h4>
<p>由于计算机发展是从16位到32位再到64位的，所以Intel使用字(word)表示16位数据类型，用双字(double word)表示32位数据类型，四字(quad word)表示64位数据类型。 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/type.png" width="700"> 一般而言，指令后面都会跟着一个后缀，表明操作数的大小。<strong>浮点数和整数使用的是完全不同的指令和寄存器。</strong></p>
<h4 id="寄存器初识">2.2 寄存器初识</h4>
<p>一个标准的x86-64CPU包含一组16个用来存储64位数据的通用寄存器。他们用来存储整数数据和指针. <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/registers.png" width="700"> <strong>指令可以对这16个寄存器的低位字节存放的大小不同的有效数据进行操作。</strong>这些寄存器可以向前兼容，就是64位可以存储32位，16位和8位的数据，但是32位无法存储64位的数据，<strong>如果是大寄存器存小数据，那么只能存在低位中，高位有相对应的填充措施。</strong></p>
<p>对于高位的数据填充，一般有两个策略：一是生成1字节和2字节的指令保持其他高位不变；生成4字节(2字)的指令会把高位填充为0。</p>
<p>几个重要的寄存器：</p>
<ul>
<li><code>rax</code>:用来存储返回值</li>
<li><code>rsp</code>:栈指针，用来指向运行时栈的结束位置,即当前运行栈的栈顶</li>
</ul>
<h3 id="访问信息">3 访问信息</h3>
<h4 id="操作数指示符">3.1 操作数指示符</h4>
<p>大多数指令都有一个或多个操作数，指出执行一个操作中要使用的源数据和目的地位置。源数据可以是立即数(常量)，寄存器，或从内存地址里读出；操作结果可以存放到寄存器或内存里。完整的表示方法如下： <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/operator.png" width="700"> 在这张表里，只有前两个得到的是直接的值，其余都要翻译成内存地址来进行寻址操作然后取值。</p>
<p>对于指令，习惯把它们划分成不同的类，每一类的指令作用相同，只是操作的数据大小不同。 #### 3.2 数据传送指令 先来看看数据传送指令，它有点像C语言的赋值运算。MOV类指令有四条指令，他们的主要区别是操作的数据大小不同： <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/mov.png" width="700"> <strong>x86-64对于MOV指令加了一个限制，就是不能直接把一个值从内存的某个位置复制到另一个位置，而必须使用寄存器作为中介。</strong>MOV指令的后缀表明了操作数据的大小，也就是寄存器的大小，不管这个寄存器是源数据还是目的地址，都必须符合指令指定的大小。<strong>MOV指令只会更新目的操作数指定的寄存器字节或内存位置(就是只更新指定的低位字节)，高位字节有其他的设置，但是有一个例外，就是movl指令，当它把寄存器作为目的地址时，会把高32位设为0。</strong> <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/movexample.png" width="700"></p>
<ul>
<li>常规的movq指令只能以表示32位补码的数字的立即数作为源数据利用符号扩展放到64位寄存器里去；<strong>movabsq能以任意64位立即数值作为源数据，并且只能以寄存器作为目的地址。</strong></li>
<li>有两类指令，适用于把较小(位长)的源数据复制到较大(位长)的目的地时使用:
<ul>
<li>MOVZ使用0扩展位长；</li>
<li>MOVS使用符号扩展位长，就是复制源数据的最高有效位。</li>
</ul></li>
</ul>
<p><img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/movz.png" width="700"> <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/movs.png" width="700"> <strong>它们的后两个字符表示位长，第一个指定了源数据的大小，第二个指定了目的的大小。</strong></p>
<h4 id="压入和弹出数据">3.3 压入和弹出数据</h4>
<p>这两个数据传送操作可以把数据压入栈中，以及从中弹出数据。<strong>在x86-64的机器中，程序栈存放在内存中的某个区域</strong>。<strong>栈向下增长，因此栈顶元素时所有栈元素里地址最小的</strong>。所以为了方便理解，栈是倒过来画的，也是向下增长的。 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/stack.png" width="700"> 涉及到栈的操作： <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/stackoperator.png" width="700"> <code>pushq</code>指令的功能是把数据压入栈中，而<code>popq</code>是弹出指令。不过它们都涉及两个操作，<code>pushq</code>是首先在栈底指针<code>%rsp</code>里存着新的值得地址，然后设置内存中的这个位置得值为准备压入得数据。所以它的操作数是数据源，而<code>popq</code>则是首先把栈顶的值复制到操作数里，然后指针回退，也就是<code>+8</code>(栈顶指针<code>+8</code>意味着减小8字节的空间，因为它是向下增长，<code>+</code>的话就代表往上回去了)。这操作的都是8字节下，64位。</p>
<p><strong>因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置。 </strong></p>
<h3 id="算术和逻辑运算">4 算术和逻辑运算</h3>
<p>下图给出了x86-64的一些整数和逻辑操作。大多数操作都分为了不同大小操作数的变种（只有lead没有其他大小的变种），比如<code>add</code>指令有<code>addb、addw、addl和addq</code>四种变种，分别表示对不同大小的操作数操作，它们一样可向下兼容，但不能向上兼容。 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/algorithmoperators.png" width="700"> 除了第一个<code>leaq</code>操作之外，其他的都会改变条件码</p>
<h4 id="加载有效地址">4.1 加载有效地址</h4>
<p>加载有效地址指令<code>leaq</code>实际上是<code>movq</code>指令的变形。<strong>它形式上是将内存数据读到寄存器，但实际上它根本没有引用内存，它并不是从指定位置读出数据，而是将有效地址写入到目的操作数。这就是C语言当中的<code>&amp;s</code>取地址操作符，也是产生指针的重要语句。</strong></p>
<p>比<code>如leaq (%rdi,%rsi,4)</code>, <code>%rax</code>的操作结果是<code>R[rax] = R[rsi]*4+R[rdi]</code>。而不是<code>R[rax] = M[R[rsi]*4+R[rdi]]</code>。 #### 4.2 一元和二元操作 在上面的算术指令表中，第二组只有1个操作数就是一元操作，其他为二元操作。</p>
<ul>
<li>一元操作指令只有一个操作数，这个操作数既是源又是目的。所以它们就像C语言的自增，自减操作一样。</li>
<li>对于二元操作，一般都是第二个操作数 减去/加上/除以/乘以/异或/或/且第一个操作数。注意，如果第二个操作数是内存地址，那么必须先从内存中读出值，再把结果写回内存。</li>
</ul>
<h4 id="移位操作">4.3 移位操作</h4>
<p><strong>移位指令很特别，因为它们只允许以特定的寄存器作为操作数。一般来说，选择长度为8的寄存器就可以了，因为移位数值一定是无符号数，所以8位最长可以移动255位</strong>，可是255位长的计算机还没出现，所以一定够用了。</p>
<p>在对位长为<span class="math inline">\(w\)</span>位的数据进行移位操作时，移位量是寄存器的低<span class="math inline">\(m\)</span>位决定的(也就是只有低<span class="math inline">\(m\)</span>位的值会被当做移位量，哪怕存放移位量的寄存器是8位，也可能只读取低3位的值，此时最多移动7位)，其中<span class="math inline">\(m=log2(w)m=log_2(w)m=log2​(w)\)</span>，高位会被忽略。</p>
<p><code>SAL</code>和<code>SHL</code>执行逻辑移位，高位补0；SAR执行算术右移，补最高位，SHR执行逻辑右移，补0.移位操作的目的操作数可以是寄存器，也可以是内存地址。</p>
<h3 id="控制">5 控制</h3>
<p>机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据结果来改变控制流或数据流。</p>
<h4 id="条件码">5.1 条件码</h4>
<p><strong>除了整数寄存器，CPU还维护一组单个位的条件码寄存器，它们描述了最近的算术或逻辑操作的属性。</strong></p>
<ul>
<li><code>CF</code>:进位标志。最近的操作使得最高位产生了进位。可以用来检测无符号数的溢出。</li>
<li><code>ZF</code>:零标志。表明最近的操作得出的结果为0。</li>
<li><code>SF</code>:符号标志。最近的操作得到的结果是负数。</li>
<li><code>OF</code>:溢出标志。最近的操作导致了一个补码的溢出——正溢出或负溢出。</li>
</ul>
<p>刚刚说的那些一元二元操作（除了<code>leaq</code>)以及移位操作，会改变条件码和寄存器的值。也有一些只改变条件码而不改变任何其他寄存器的操作：如下所示的<code>CMP</code>家族和<code>TEST</code>家族，它们仅仅根据两个操作数之差来设置条件码。除了只设置条件码而不进行目的寄存器的更新外，<code>CMP</code>和<code>SUB</code>指令是一样的。<code>TEST</code>指令的行为和<code>AND</code>指令一样，除了它们不会更改目的寄存器的值外。 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/conditional.png" width="700"></p>
<h4 id="访问条件码">5.2 访问条件码</h4>
<p>条件码通常不会直接读取，常用的使用方法有3种：</p>
<ul>
<li>一是可以根据条件码的某种组合将一个字节设置为0或1，</li>
<li><strong>二是可以跳转到程序的其他某个部分，</strong></li>
<li><strong>三是可以有条件地传送数据。</strong></li>
</ul>
<p>对于第一种情况，常用来实现<code>SET</code>指令，<code>SET</code>成员之间的区别就在于它们考虑的条件码组合是什么，这些指令的后缀指明了这一点，它们在此不作为寄存器长度要求来使用。 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/set.png" width="700"> 一般而言，<code>SET</code>指令存在于那些可以更改条件码的指令的后面，这样就可以读取到最新的值了，当然也可以不这么做。至于每个指令把目的操作数到底设置成了什么,可以通过条件码计算，也可以通过<code>a-b</code>(如果前面是<code>CMP b,a</code>)或<code>a+b</code>(如果前面是<code>TEST b,a</code>指令)的计算结果来判断。</p>
<p>表格中的第三组只作用于有符号数操作，第四组只作用于无符号数操作。至于究竟用哪个，编译器会在编译期根据源码进行判断选择。条件跳转只能是直接跳转。</p>
<h4 id="跳转指令">5.3 跳转指令</h4>
<p>对于需要指定执行位置时，可以使用跳转指令。跳转的目的地通常使用一个标号指明。这些指令的命名格式和跳转条件和<code>SET</code>指令是一致的。 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/jump.png" width="700"> - 对于<code>jmp</code>指令来说，它是无条件跳转，它既可以是直接跳转，也可以是间接跳转，此时跳转目标从寄存器或内存位置中读出。</p>
<h4 id="跳转指令编码">5.4 跳转指令编码</h4>
<p>对于如何确定跳转的位置，有多种方法，但是最常用的是<code>PC</code>相对法。这种方法会把目标指令的地址和紧跟在跳转指令后面的指令的地址的差值作为值编码在跳转指令后面。 在执行<code>PC</code>相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址。 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/pcjump.png" width="700"> 使用<code>PC</code>相对法进行编码，好处就是指令很简洁，而且目标代码可以不做修改就移植到别的机器上。</p>
<h4 id="条件控制实现条件分支">5.5 条件控制实现条件分支</h4>
<p>将条件表达式和语句<code>if-else</code>从C语言翻译成机器代码，最常用的方式就是结合有条件和无条件跳转。另一种方式使用数据的条件转移实现，这里是介绍<strong>控制的条件转移实现</strong>。其形式如下 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c代码</span></span><br><span class="line"><span class="keyword">if</span>(test-expr)</span><br><span class="line">	then statement;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">else</span>-statement;</span><br><span class="line"><span class="comment">//接近于汇编的代码</span></span><br><span class="line">	t=test-expr;</span><br><span class="line">	<span class="keyword">if</span>(!t)</span><br><span class="line">		<span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">	then-statement;</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">	<span class="keyword">else</span>-statement;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure> 也就是说，汇编器为<code>then-statement</code>和<code>else-statement</code>产生各自的代码块，他会插入条件和无条件分支，以保证能正确执行代码。</p>
<h4 id="条件传送实现条件分支">5.6 条件传送实现条件分支</h4>
<p>对于使用条件控制来实现条件转移，在现代处理器中可能会很低效。而可以通过使用数据的条件分支来实现高效，后者先计算出所有的分支的结果，再在最后进行条件判断，输出分支结果之一。</p>
<p><strong>现代处理器使用了称为流水线的处理结构，使得一个时钟周期内可以处理多条指令的不同阶段操作。但是这种高效率依赖于流水线的满载，如果流水线空荡荡的那反而是降低了性能。于是需要CPU提前把指令填充到流水线，而有些指令没法提前填充，于是CPU使用它的预测算法，把那些未来的指令放到它可能被执行的流水线上。但是！一旦放错了，后果开销更大，此时因为指令的跳转，需要清空流水线，重新载入新的指令。当代CPU可以做到90%准确率，不过有时如果输入偏于随机的话，那么性能就下来了。</strong></p>
<p>使用条件传送高效是因为它不需要预测结果，因为所有的可能结果全部完成运算，仅仅在最后输出时选择一个正确的结果就好，这就把预测取消了。同时因为取消了预测，此时控制流与输入数据无关，流水线一直是满载。就如<code>V=test-expr?then-statement:else-statement;</code>。在C中实现两种条件分支如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用控制实现条件分支</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">absdiff</span><span class="params">(<span class="type">long</span> x,<span class="type">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> result;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y)</span><br><span class="line">		result=x-y;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		result=y-x;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用条件传送来实现条件分支</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">absdiff</span><span class="params">(<span class="type">long</span> x,<span class="type">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> xby=x-y;</span><br><span class="line">	<span class="type">long</span> xly=y-x;</span><br><span class="line">	<span class="type">long</span> ntest=x&gt;=y;</span><br><span class="line">	<span class="keyword">if</span>(ntest)</span><br><span class="line">		<span class="keyword">return</span> xby;</span><br><span class="line">	<span class="keyword">return</span> xly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>循环和switch略</p>
</blockquote>
<h3 id="过程-过程是软件中的一种很重要的抽象它提供了一种封装代码的方式用一组指定的参数和一个可选的返回值实现了某种功能然后可以在程序的不同地方调用这个过程不同的编程语言中过程描述不同在c语言中它们被称为函数在java和c中它们被称为方法在进程中它们可能被称为子进程在多线程中可能又叫子线程虽然很多但是它们有一些共有的特性">6 过程* 过程是软件中的一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能，然后可以在程序的不同地方调用这个过程。不同的编程语言中，过程描述不同，在C语言中，它们被称为函数，在Java和C++中，它们被称为方法，在进程中，它们可能被称为子进程，在多线程中，可能又叫子线程。虽然很多，但是它们有一些共有的特性。</h3>
<p>为了方便，这里就以函数调用为例，函数P调用函数Q,他要包含以下机制：</p>
<ul>
<li><strong>传递控制：</strong>在进入函数Q之前，程序计数器PC必须被设置为Q代码的起始地址，然后在返回后，程序计数器PC设置为P中调用Q后面那条指令地址</li>
<li><strong>传递数据：</strong>P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值</li>
<li><strong>分配和释放内存</strong>：在Q中能为局部遍历分配空间，而在返回时释放这些空间</li>
</ul>
<h4 id="运行时栈">6.1 运行时栈</h4>
<p>程序是运行在内存中的，一般来说，<strong>内存里包括程序正文，程序运行堆栈</strong>。程序正文就是可执行机器代码，程序运行堆栈就是程序运行需要的额外空间，比如内存分配，数组，局部变量等。</p>
<p><strong>C语言的内存管理采用栈的结构，先进后出的顺序。程序可以通过这种方式来管理它所需要的存储空间，当P调用Q时，会把Q添加到栈顶，然后运行结束通过改变rsp栈顶指针来释放。</strong>因此，程序可以用栈来管理它的过程所需要的存储空间<strong>，栈和寄存器存放在着传递控制和数据。</strong></p>
<p>当x86-64程序需要的空间超过寄存器所能满足的时候，就会在栈上分配空间，这个部分称为过程的栈帧。 来看一个一般的程序堆栈结构： <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/StackOfRun.png" width="700"></p>
<ul>
<li><p><strong><code>%rsp</code>：寄存器<code>%rsp</code>保存着栈指针，它指向栈顶(图中底部)</strong>，而前面提过，内存向下增长，所以把<code>%rsp</code>减少一个值就完成了对于空间的分配，加上一个值就是对空间的回收。</p></li>
<li><p><strong>栈帧</strong>：每一个函数都有属于自己的栈帧，如图上的<code>Frame for calling function P</code>是调用者P函数的栈帧，<code>Earlier Frames</code>是之前的调用者较早栈帧，还有当前Q函数栈帧。栈帧主要又三个部分组成：<code>save registers</code>、<code>local variables</code>和<code>Argument build area</code></p></li>
<li><p><strong>调用函数P:P函数首先会从右向左去存储被调用函数的参数，因此可存储的参数的寄存器为6个（<code>rdi、rsi、rdx、rcx</code>等，因此当参数的数量大于6时，其他的参数会右向左的被压入当前P的栈帧中，这也是为什么返回地址的上一个地址存储的时<code>Argument 7</code>（位于该栈帧的参数构建区域<code>Argument build area</code>)。之后为了能够在Q返回时知道P程序从哪个位置继续执行，会压入一个返回地址</strong></p></li>
<li><p><strong>被调用函数Q：Q的代码会扩展当前栈的边界，分配它的栈帧所需空间。它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数的过程的栈帧都是定长的，在过程开始就分配好了。当Q执行完毕之后，会把返回值寄存在在寄存器<code>%rax</code>中，之后释放当前自己的栈帧，弹出返回地址恢复现场，并弹出压入的参数。</strong></p></li>
<li><p><strong>保存寄存器</strong>：为了保证被调用者不会覆盖调用者稍后会使用的寄存器，需要设置寄存器值的保存，这就是寄存器保存区域。在惯例中，分为了<strong>被调用者保存寄存器</strong>和<strong>调用者保存寄存器</strong></p></li>
</ul>
<h4 id="转移控制">6.2 转移控制</h4>
<p><strong>将控制从函数<code>P</code>转移到函数<code>Q</code>只需简单的将程序计数器<code>PC</code>(<code>%rip</code>)设置为<code>Q</code>的代码起始位置即可，不过为了能够恢复现场，必须保存<code>P</code>的下一个执行指令地址。</strong></p>
<p>对于过程Q的调用汇编上是通过<code>CALL</code>指令实现的。该指令后面跟着<code>Q</code>的地址。此时，过程P把PC设置成Q的地址，然后CALL指令会把将紧跟它的指令的地址压入栈中，这个就是返回地址，当<code>Q</code>调用<code>ret</code>指令进行返回时，会弹出这个返回地址，设置到<code>PC</code>(<code>%rip</code>)上。<code>call</code>的指令格式如下： <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/call.png" width="700"></p>
<p><code>call</code>指令有一个目标，即指明被调用过程起始指令地址。既可以是直接的，也可以是间接的。直接调用的目标是一个符号，间接调用的时<code>*</code>后面跟一个操作数指示符。 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/Control.png" width="700"> 上面的的图片详细展示了<code>mian--&gt;top(100)--&gt;leaf(95)</code>的调用和返回过程。</p>
<ul>
<li>在调用中<code>call</code>指令完成两个工程，将当前<code>pc</code>的下一个指令地址压入栈中，设置<code>pc</code>的跳转地址。</li>
<li>在返回时，将返回值存入<code>%rax</code>，然后从栈中弹出返回地址设置到<code>pc</code>上，恢复栈顶指针的指向</li>
</ul>
<h4 id="数据传送">6.3 数据传送</h4>
<p>当过程P调用过程Q时，P的代码必须首先设置参数，如果参数数目小于等于6个，直接设置在寄存器就可以；而Q在返回到P之前，必须首先设置%rax来实现返回值。</p>
<p>在x86-64架构中，寄存器的使用是有顺序的，而且它们的名字取决于参数的大小。 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/TransferData.png" width="700"></p>
<p>一旦参数到位，就可以调用CALL指令来把控制移交至Q了。</p>
<blockquote>
<p><strong>问题1：对于数组参数，是怎么传递的？</strong> 回答：对于数组，很明显8字节的寄存器是无法完全存储的。有数组知识可知，数组是连续的一系列内存，数组名是第一个元素的地址，因此寄存器可以存储数组的首地址，对于后续的元素通过变址寻址方式去访问。 <strong>问题2：对于像vector这样的数组，我们在没有按指针/引用的形式传递的时候，它会如何传参呢?</strong> 回答：我认为是会发生一份拷贝，将数组拷贝进参数区域传递给被调函数</p>
</blockquote>
<h4 id="栈上的局部存储">6.4 栈上的局部存储</h4>
<p>有时寄存器可能不能够存储参数，这时就需要使用栈上的空间来完成存储。常见的情况包括：</p>
<ul>
<li>寄存器不足以存放所有的本地数据</li>
<li>对一个局部变量使用取地址符，就一定需要栈，因为寄存器没有地址这一说。</li>
<li>对于局部变量时数组或结构的情况，因为访问它们需要产生地址引用。</li>
</ul>
<p>一般来说，过程通过减小栈指针来实现空间的分配，分配的结果作为栈帧的一部分。</p>
<h4 id="寄存器中局部存储空间">6.5 寄存器中局部存储空间</h4>
<p>寄存器是唯一被所有过程共享的资源，虽然给定时刻只有一个过程是活动的，单我们仍然必须确保当一个过程（调用者）调用另外一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器。</p>
<p>在惯例中，分为了<strong>被调用者保存寄存器</strong>和<strong>调用者保存寄存器</strong>：</p>
<ul>
<li><strong>被调用者保存寄存器</strong>：由被调用者去负责保存调用者的寄存器值。寄存器<code>%rbx、%rbp</code>和<code>%r12~%15</code>都被分为被调用者寄存器。因此P调用Q时，Q必须保存这些寄存器的值，以保证返回P时寄存器的值与Q被调用时一样。
<ul>
<li>一种方法是Q不使用这些寄存器，也就当然不会改变</li>
<li>另一种方法是Q将这些寄存器的值压栈，返回时弹出恢复</li>
</ul></li>
<li><strong>调用者保存寄存器</strong>：由调用者自己去负责保存寄存器的值。除<code>%rsp</code>和上面被调用者保存寄存器，其他的寄存器都分类位<strong>调用者保存寄存器</strong>。</li>
</ul>
<h4 id="递归过程">6.5 递归过程</h4>
<p>介于每个过程调用在栈中都有它们自己的私有空间，因此多个未完成调用的局部变量并不会相互影响。这就为递归的实现提供了可能。</p>
<p>递归地调用一个函数与调用其他函数是一样的。栈机制就可以保证每个函数调用都有它自己私有的状态信息存储空间。比如局部变量，返回地址等。</p>
<p>栈分配和释放的规则很自然地就与函数调用-返回的顺序一致。即使对于更加复杂的情况，甚至是相互调用也可以适用。</p>
<h3 id="数组分配和访问">7 数组分配和访问</h3>
<p>在讨论之前，来约束一些规则： <span class="math display">\[T A[N];\]</span> 起始位置是<span class="math inline">\(x_A\)</span>，<span class="math inline">\(L\)</span>是<span class="math inline">\(T\)</span>类型的大小。这个声明有两个效果，首先，它在内存分配了一段长度为<span class="math inline">\(L⋅N\)</span>的连续空间。其次，它引入了标识符A，可以用来当作指向数组开头的指针。这个指针的值就是数组首元素的地址，也就是这里的<span class="math inline">\(x_A\)</span>。数组元素i(从0开始)的地址是<span class="math inline">\(x_A+L⋅i\)</span>。</p>
<p>x86-64的数组引用指令可以简化对于数组的访问。假设数组的首地址放在<code>%rdx</code>中，而下标i放在<code>%rcx</code>中。那么指令 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">movl</span> (%rdx,%rcx,<span class="number">4</span>),%eax</span><br></pre></td></tr></table></figure> 会把元素i的值放在<code>%eax</code>中。其中的常数<code>4</code>代表数据大小，如果是<code>int64</code>类型，那么可以改成8。伸缩因子1，1，4，8覆盖了所有基本数据类型的大小。</p>
<h4 id="指针运算">7.1 指针运算</h4>
<p>C语言允许对指针进行运算，运算的结果会根据该指针引用的数据类型的大小进行伸缩。如果p是一个指向类型T的指针，p的值是<span class="math inline">\(x_p\)</span>，那么表达式<span class="math inline">\(p+i\)</span>的值就是<span class="math inline">\(x_p+L⋅i\)</span>，这里<span class="math inline">\(L\)</span>是数据类型T的大小。</p>
<p>对于指针操作，有取地址符<code>&amp;</code>和解引用符<code>*</code>，在数组里，可以有些骚操作。比如<code>A[i]</code>等价于<code>*(A+i)</code>。 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/pointer.png" width="700"></p>
<h4 id="变长数组">7.2 变长数组</h4>
<p>C语言运行数组的维度是表达式，在数组被分配的时候才计算出来： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> A[expr][expre2];</span><br></pre></td></tr></table></figure> 这就意味者C语言支持边长数组，即数组的长度在编译的时候才能确定。</p>
<h3 id="内存越界引用和缓冲区溢出">8 内存越界引用和缓冲区溢出</h3>
<p>数组是保存在栈里的，所以对数组的越界访问可能会破坏栈结构。想一想，如果某时某个数组长度为10而访问其第12个元素，就有可能访问到上一个过程设置的返回地址，再修改就会造成当前调用返回到未知区域。</p>
<p>缓冲区溢出的一个更加致命的使用就是使得程序调用一个它本来不应该调用的函数，这也是一种常见的计算机网络攻击的方法。</p>
<h4 id="对抗缓冲区溢出攻击">8.1 对抗缓冲区溢出攻击</h4>
<p>缓冲区溢出攻击是很可怕的，所以应该采取措施来进行防范。</p>
<ul>
<li><p><strong>栈随机化：</strong>这种方法旨在随机化每次栈的起始位置，来让恶意程序无法推算出栈的位置。不过攻击代码还是可以通过多次执行nop指令(只是单纯的递增程序计数器而不执行行为)来推算栈的位置。</p></li>
<li><p><strong>栈破化检测</strong>：在缓冲区末尾和其他栈区域之间添加一个特殊的值。程序通过检测这个值与内存中的只读的备份值是否一致，如果不一致证明发生了不被允许的访问。此时程序终止。这个值称为金丝雀值，因为早期金丝雀用于检测矿洞的有毒气体。所以在汇编代码里看到的%fs:40指令就是通过段寻址的方式从内存读入值设置金丝雀值。</p></li>
<li><p><strong>最后一种方法是通过限制代码的可执行区域来实现的</strong>。这种方法把内存区域划分成可执行区，可读取，可读写区。只有可执行区的代码才是可执行的。这样可以限制程序对于栈的更改触及到可执行代码。</p></li>
</ul>
<h3 id="浮点代码">10 浮点代码</h3>
<p>处理器的浮点体系包括多个方面：</p>
<ul>
<li>如何存储和访问浮点值。通常是通过某种寄存器完成的。</li>
<li>对浮点数据操作的指令。</li>
<li>向函数传递浮点数据以及从中返回浮点数据。</li>
<li>函数调用过程中保存寄存器的规则。</li>
</ul>
<p>说到浮点计算，就会提及x8664架构的浮点指令集。为了支持浮点计算，Intel和AMD对指令集追加了扩展，比如现在的AVX2标准。为了计算浮点数，计算机有这处理浮点数的寄存器： <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/float.png" width="700"> 其中每个<code>XMM</code>寄存器都是对应的<code>YMM</code>寄存器的低128位。</p>
<ul>
<li><code>XMM</code>寄存器<code>%xmm0~%xmm7</code>，最多可以传递8个浮点数。按照参数列出的顺序使用这些寄存器，可以通过栈传递额外的浮点参数。</li>
<li>函数使用寄存器<code>%xmm0</code>来返回浮点值。</li>
<li>所有的<code>XMM</code>寄存器都是调用者保存的。</li>
</ul>
<p>当调用过程时，参数到寄存器的映射取决于它们的类型和排列的顺序。</p>
<h4 id="浮点传送和转换操作">10.1 浮点传送和转换操作</h4>
<p>下表给出了一组在内存和<code>XMM</code>或者<code>YMM</code>寄存器之间不做任何转换的浮点数指令。引入内存的指标是<strong>标量指令</strong>，说明他们只对单个而不是一组封装豪的数据值进行操作 <img src="/2023/04/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/movess.png" width="700"></p>
<p>对于传送数据来说，程序复制整个寄存器或者只复制寄存器低位值既不会影响程序功能，也不会影响执行速度。所以使用这些指令还是针对标量数据的指令没有实质上的差别。</p>
<p>把浮点数值换成整数时，指令会执行截断，把值向0进行舍入，这是C和大多数其他编程语言的要求。</p>
<p>文章部分来源： <a href="https://juejin.cn/post/6855129008108273678">深入理解计算机系统-程序的机器级表示</a></p>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习</title>
    <url>/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="深度学习简述">1.深度学习简述</h4>
<p>为了学习一种好的表示，需要构建具有一定“深度”的模型，并通过学习算法来让模型自动学习出好的特征表示（从底层特征，到中层特征，再到高层特征），从而最终提升预测模型的准确率．<strong>所谓“深度”是指原始数据进行非线性特征转换的次数</strong> <img src="/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/DL.png" width="500"></p>
<p>深度学习是将原始的数据特征通过多步的特征转换得到一种特征表示，并进一步输入到预测函数得到最终结果．和“浅层学习”不同，<strong>深度学习需要解决的关键问题是贡献度分配问题（Credit Assignment Problem，CAP）[Minsky,1961]</strong>，即一个系统中不同的组件（component）或其参数对最终系统输出结果的贡献或影响.从某种意义上讲，深度学习可以看作一种强化学习（Reinforcement Learning，RL），每个内部组件并不能直接得到监督信息，需要通过整个模型的最终监督信息（奖励）得到，并且有一定的延时性</p>
<span id="more"></span>
<p><strong>深度学习采用的模型主要是神经网络模型，其主要原因是神经网络模型可以使用误差反向传播算法，从而可以比较好地解决贡献度分配问题</strong>．</p>
<h5 id="表示学习">1.1 表示学习</h5>
<p>为了提高机器学习系统的准确率，我们就需要将输入信息转换为有效的特 征，或者更一般性地称为表示（Representation）。如果有一种算法可以自动地学习出有效的特征，并提高最终机器学习模型的性能，那么这种学习就可以叫作<strong>表示学习</strong>。</p>
<p>表示学习的关键是解决<strong>语义鸿沟（Semantic Gap）问题</strong>．语义鸿沟问题是指输入数据的底层特征和高层语义信息之间的不一致性和差异性．比如给定一些关于“车”的图片，由于图片中每辆车的颜色和形状等属性都不尽相同，因此不同图片在像素级别上的表示（即底层特征）差异性也会非常大．但是我们理解这些图片是建立在比较抽象的高层语义概念上的．如果一个预测模型直接建立在底层特征之上，会导致对预测模型的能力要求过高．如果可以有一个好的表示在某种程度上能够反映出数据的高层语义特征，那么我们就能相对容易地构建后续的机器学习模型</p>
<h6 id="局部和分布式表示">4.1.1 局部和分布式表示</h6>
<p>在机器学习中，我们经常使用两种方式来表示特征：<strong>局部表示（Local Representation）和分布式表示（Distributed Representation）．</strong></p>
<ul>
<li><strong>局部表示</strong>：离散表示，one-Hot向量，单一值表示一个东西。
<ul>
<li><strong>优点：</strong>
<ul>
<li>这种离散的表示方式具有很好的解释性，有利于人工归纳和总结特征，并通过特征组合进行高效的特征工程</li>
<li>通过多种特征组合得到的表示向量通常是稀疏的二值向量，当用于线性模型时计算效率非常高</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>one-hot向量的维数很高，且不能扩展．如果有一种新的颜色，我们就需要增加一维来表示</li>
<li>不同颜色之间的相似度都为0，即我们无法知道“红色”和“中国红”的相似度要高于“红色”和“黑色”的相似度</li>
</ul></li>
</ul></li>
<li><strong>分布式表示</strong>：压缩、低维的稠密向量，使用多个值表示一个东西，如表示颜色的方法是用RGB值来表示颜色，不同颜色对应到R、G、B三维空间中一个点，这种表示方式叫作分布式表示
<ul>
<li>分布式表示的表示能力要强很多，分布式表示的向量维度一般都比较低．我们只需要用一个三维的稠密向量就可以表示所有颜色．并且，分布式表示也很容易表示新的颜色名．此外，不同颜色之间的相似度也很容易计算</li>
</ul></li>
</ul>
<h5 id="端到端学习">1.2 端到端学习</h5>
<p><strong>端到端学习（End-to-End Learning），也称端到端训练，是指在学习过程中不进行分模块或分阶段训练，直接优化任务的总体目标</strong>．在端到端学习中，一般不需要明确地给出不同模块或阶段的功能，中间过程不需要人为干预．端到端学习的训练数据为“输入-输出”对的形式，无须提供其他额外信息．因此，端到端学习和深度学习一样，都是要解决贡献度分配问题．目前，大部分采用神经网络模型的深度学习也可以看作一种端到端的学习</p>
<h4 id="前馈神经网络">2. 前馈神经网络</h4>
<h5 id="神经元">2.1 神经元</h5>
<p>神经网络一般可以看作一个非线性模型，其基本组成单元为具有非线性激活函数的神经元，通过大量神经元之间的连接，使得神经网络成为一种高度非线性的模型．<strong>神经元之间的连接权重就是需要学习的参数，可以在机器学习的框架下通过梯度下降方法来进行学习</strong>． <img src="/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Neuron.png" width="300"></p>
<p>激活函数在神经元中非常重要的．为了增强网络的表示能力和学习能力，<strong>激活函数</strong>需要具备以下几点性质：</p>
<ul>
<li>（1） 连续并可导（允许少数点上不可导）的非线性函数．可导的激活函数可以直接利用数值优化的方法来学习网络参数．</li>
<li>（2） 激活函数及其导函数要尽可能的简单，有利于提高网络计算效率．</li>
<li>（3） 激活函数的导函数的值域要在一个合适的区间内，不能太大也不能太小，否则会影响训练的效率和稳定性．</li>
</ul>
<p>下面介绍几种在神经网络中常用的激活函数．</p>
<h6 id="sigmoid函数">2.1.1 sigmoid函数</h6>
<p><code>Sigmoid</code>型函数是指一类 S 型曲线函数，为两端饱和函数．常用的<code>Sigmoid</code>型函数<strong>有<code>Logistic</code>函数和<code>Tanh</code>函数</strong>．<strong>所谓饱和是指</strong>对于函数 <span class="math inline">\(f(x)\)</span>，若 <span class="math inline">\(x → −∞\)</span> 时，其导数 <span class="math inline">\(f^′(x) → 0\)</span>，则称其为左饱和．若<span class="math inline">\(x → +∞\)</span>时，其导数<span class="math inline">\(f′(x) → 0\)</span>，则称其为右饱和．当同时满足左、右饱和时，就称为两端饱和。</p>
<p>在机器学习篇章我们以及介绍果LR函数： <span class="math display">\[
σ(x)={1\over 1+exp(-x)}
\]</span></p>
<p><strong>Logistic 函数可以看成是一个“挤压”函数，把一个实数域的输入“挤压”到(0, 1)</strong>．当输入值在0附近时，Sigmoid型函数近似为线性函数；当输入值靠近两端时，对输入进行抑制．输入越小，越接近于 0；输入越大，越接近于 1．和感知器使用的阶跃激活函数相比，Logistic函数是连续可导的，其数学性质更好．</p>
<p>因为Logistic函数的性质，使得装备了Logistic激活函数的神经元具有以下两点性质： - 1）其输出直接可以看作概率分布，使得神经网络可以更好地和统计学习模型进行结合． - 2）其可以看作一个软性门（Soft Gate），用来控制其他神经元输出信息的数量．</p>
<p><img src="/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/sigmoid.png" width="300"></p>
<p><strong><code>Tanh</code>函数</strong>： <span class="math display">\[
tanh(x)={exp(x)-exp(-x)\over exp(x)+exp(-x)}
\]</span></p>
<h6 id="relu函数">2.1.2 Relu函数</h6>
<p>ReLU（Rectified Linear Unit，修正线性单元）是目前深度神经网络中经常使用的激活函数．<strong>ReLU实际上是一个斜坡（ramp）函数</strong>，定义为： <span class="math display">\[
Relu(x)=\begin{cases}
x&amp;x≥0\\
0&amp;x&lt;0
\end{cases}
\]</span></p>
<p><strong>优点：</strong></p>
<ul>
<li>采用 ReLU 的神经元只需要进行加、乘和比较的操作，计算上更加高效</li>
<li>具有生物学合理性，比如单侧抑制、宽兴奋边界。Sigmoid 型激活函数会导致一个非稀疏的神经网络，而 ReLU 却具有很好的稀疏性，大约50%的神经元会处于激活状态</li>
<li>在优化方面，相比于Sigmoid型函数的两端饱和，ReLU函数为左饱和函数，且在 $x &gt; 0 $时导数为 1，在一定程度上缓解了神经网络的梯度消失问题，加速梯度下降的收敛速度．</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>ReLU 函数的输出是非零中心化的，给后一层的神经网络引入偏置偏移，会影响梯度下降的效率</li>
<li>ReLU 神经元在训练时比较容易“死亡”．在训练时，如果参数在一次不恰当的更新后，第一个隐藏层中的某个 ReLU 神经元在所有的训练数据上都不能被激活，那么这个神经元自身参数的梯度永远都会是0，在以后的训练过程中永远不能被激活．这种现象称为死亡 ReLU 问题</li>
</ul>
<p>为克服上述缺陷，几种变种Relu被广泛使用：</p>
<ul>
<li><p><strong>带泄露的Relu</strong>:带泄露的ReLU（Leaky ReLU）在输入 <span class="math inline">\(x&lt; 0\)</span>时，保持一个很小的梯度𝛾．这样当神经元非激活时也能有一个非零的梯度可以更新参数，避免永远不能被激活[Maas et al., 2013]．带泄露的ReLU的定义如下： <span class="math display">\[
LeakyRelu(x)=\begin{cases}
x&amp;x&gt;0\\
γx&amp;x≤0
\end{cases}
\]</span> 其中<span class="math inline">\(γ\)</span>是一个很小的常数，如0.001</p></li>
<li><p><strong>带参数的ReLU：</strong>带参数的 ReLU（Parametric ReLU，PReLU）引入一个可学习的参数，不同神经元可以有不同的参数 [He et al., 2015]．对于第<span class="math inline">\(i\)</span>个神经元，其 PReLU的定义为 <span class="math display">\[
PRelu(x)=\begin{cases}
x&amp;x&gt;0\\
γ_ix&amp;x≤0
\end{cases}
\]</span> 其中<span class="math inline">\(γ_i\)</span>为 <span class="math inline">\(x≤ 0\)</span> 时函数的斜率．因此，PReLU 是非饱和函数．如果<span class="math inline">\(γ_i=0\)</span>，那么PReLU就退化为ReLU．如果<span class="math inline">\(γ_i\)</span>为一个很小的常数，则PReLU可以看作带泄露的ReLU．PReLU可以允许不同神经元具有不同的参数</p></li>
<li><p><strong>ELU（Exponential Linear Unit，指数线性单元）</strong>：[Clevert et al., 2015] 是一个近似的零中心化的非线性函数，其定义为: <span class="math display">\[
Elu(x)=\begin{cases}
x&amp;x&gt;0\\
γ(exp(x)-1)&amp;x≤0
\end{cases}
\]</span> 其中<span class="math inline">\(γ ≥ 0\)</span>是一个超参数，决定<span class="math inline">\(x≤ 0\)</span>时的饱和曲线，并调整输出均值在0附近</p></li>
<li><p><strong>Softplus函数：</strong>Softplus 函数[Dugas et al., 2001] 可以看作 Rectifier 函数的平滑版本，其定义为 <span class="math display">\[
softplus(x)=log(1+exp(x))
\]</span> Softplus函数其导数刚好是Logistic函数．Softplus函数虽然也具有单侧抑制、宽兴奋边界的特性，却没有稀疏激活性 <img src="/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Relu.png" width="400"></p></li>
</ul>
<h5 id="swish函数">2.1.3 Swish函数</h5>
<p>Swish 函数[Ramachandran et al., 2017] 是一种<strong>自门控（Self-Gated）激活函数</strong>，定义为: <span class="math display">\[
swish(x)=xσ(βx)
\]</span> 其中<strong><span class="math inline">\(δ(⋅)\)</span>为 Logistic 函数</strong>，<span class="math inline">\(β\)</span>为可学习的参数或一个固定超参数.<span class="math inline">\(δ(⋅) ∈ (0, 1)\)</span>可以看作一种软性的门控机制．当<span class="math inline">\(δ(βx)\)</span>接近于1时，门处于“开”状态，激活函数的输出近似于<span class="math inline">\(x\)</span>本身；当<span class="math inline">\(δ(βx)\)</span>)接近于0时，门的状态为“关”，激活函数的输出近似于0． <img src="/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/swish.png" width="400"></p>
<p>Swish函数可以看作线性函数和ReLU函数之间的非线性插值函数，其程度由参数<span class="math inline">\(β\)</span>控制．</p>
<h6 id="gelu函数">2.1.4 GELU函数</h6>
<p>GELU（Gaussian Error Linear Unit，高斯误差线性单元）[Hendrycks et al.,2016] 也是一种通过<strong>门控机制来调整其输出值的激活函数</strong>，和 Swish 函数比较类似 <span class="math display">\[
GELU(x)=xp(X≤x)
\]</span> 其中<span class="math inline">\(p(X ≤ x)\)</span>是高斯分布<span class="math inline">\(N(μ, σ^2)\)</span>的累积分布函数，其中<span class="math inline">\(μ, σ\)</span>为超参数，一般设<span class="math inline">\(μ= 0, σ= 1\)</span>即可．由于高斯分布的累积分布函数为S型函数，因此GELU函数可以用Tanh函数或Logistic函数来近似， <span class="math display">\[
GELU(x)=xσ(1.702x)
\]</span></p>
<h6 id="maxout单元">2.1.5 Maxout单元</h6>
<p>Maxout 单元[Goodfellow et al., 2013] 也是一种<strong>分段线性函数函数</strong>。不同的是Sigmoid 、ReLU 等激活函数的输入是神经元的净输入<span class="math inline">\(z\)</span>，是一个标量而 Maxout 单元的输入是上一层神经元的全部原始输出，是一个向量<span class="math inline">\(x = [x_1; x_2; ⋯ ; x_D]\)</span>．</p>
<p>每个Maxout单元有<span class="math inline">\(K\)</span>个权重向量$w_k ∈ ℝ^D <span class="math inline">\(和偏置\)</span>b_k(1 ≤ k ≤ K)<span class="math inline">\(．对于输入\)</span>x<span class="math inline">\(，可以得到\)</span>K<span class="math inline">\(个净输入\)</span>z_k, 1 ≤ k ≤ K$ <span class="math display">\[
z_k=w^T_k+b_k
\]</span> 其中<span class="math inline">\(w_k= [w_{k,1}, ⋯ , w_{k,D}]^T\)</span> 为第<span class="math inline">\(k\)</span>个权重向量</p>
<h5 id="网络结构">2.2 网络结构</h5>
<p>样通过一定的连接方式或信息传递方式进行协作的神经元可以看作一个网络，就是神经网络．．目前常用的神经网络结构有以下三种：</p>
<ul>
<li><p><strong>前馈网络</strong>：前馈网络中各个神经元按接收信息的先后分为不同的组．<strong>每一组可以看作一个神经层．每一层中的神经元接收前一层神经元的输出，并输出到下一层神经元．整个网络中的信息是朝一个方向传播</strong>，没有反向的信息传播，可以用一个有向无环路图表示。<strong>前馈网络包括全连接前馈网络和卷积神经网络等</strong>．</p></li>
<li><p><strong>记忆网络</strong>：记忆网络，也称为反馈网络，<strong>网络中的神经元不但可以接收其他神经元的信息，也可以接收自己的历史信息．和前馈网络相比，记忆网络中的神经元具有记忆功能，在不同的时刻具有不同的状态．记忆神经网络中的信息传播可以是单向或双向传递</strong>。记忆网络包括循环神经网络、Hopfield 网络、玻尔兹曼机、受限玻尔兹曼机等</p></li>
<li><p><strong>图网络</strong>：<strong>图网络是定义在图结构数据上的神经网络．图中每个节点都由一个或一组神经元构成．节点之间的连接可以是有向的，也可以是无向的．每个节点可以收到来自相邻节点或自身的信息</strong>。图网络是前馈网络和记忆网络的泛化，包含很多不同的实现方式，比如<em>图卷积网络（Graph Convolutional Network，<strong>GCN</strong>）[Kipf et al., 2016]、图注意力网络（Graph Attention Network，<strong>GAT</strong>）[Veličković et al., 2017]、消息传递神经网络（Message Passing Neural Network，<strong>MPNN</strong>）[Gilmer et al., 2017]等</em>． <img src="/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/neuralStructure.png" width="500"></p></li>
</ul>
<h5 id="反向传播算法">2.3 反向传播算法</h5>
<p>假设采用随机梯度下降进行神经网络参数学习，给定一个样本<span class="math inline">\((x, y)\)</span>，将其输入到神经网络模型中，得到网络输出为<span class="math inline">\(\tilde{𝒚}\)</span>．假设损失函数为$ ℒ(𝒚,)$，<strong>要进行参数学习就需要计算损失函数关于每个参数的导数</strong>．</p>
<p>不失一般性，对第<span class="math inline">\(l\)</span>层中的参数<span class="math inline">\(W^{(l)}\)</span> 和<span class="math inline">\(b{(l)}\)</span>计算偏导数．因为<span class="math inline">\(𝜕ℒ(𝒚,\tilde{y})\over𝜕𝑾^{(𝑙)}\)</span>的计算涉及向量对矩阵的微分，十分繁琐，因此我们先计算<span class="math inline">\(ℒ(𝒚,\tilde{𝒚})\)</span> 关于参数矩阵中每个元素的偏导数$ ℒ(y,)w^{(l)}_{ij}$．根据链式法则: <span class="math display">\[
{δℒ(𝒚,\tilde{y}) \over δw^{(l)}_{ij}}={δz^{(l)}\over δw^{(l)}_{ij} }{δℒ(𝒚,\tilde{y})\over δz^{(l)}} \\
{δℒ(𝒚,\tilde{y}) \over δb^{(l)}}={δz^{(l)}\over δb^{(l)}}{δℒ(𝒚,\tilde{y})\over δz^{(l)}}
\]</span> 上式的第二项都是目标函数关于第<span class="math inline">\(l\)</span>层的神经元<span class="math inline">\(z^{(l)}\)</span>的偏导数，称为误差项，可以一次计算得到．这样我们只需要计算三个偏导数，分别为<span class="math inline">\({δz^{(l)}\over δw^{(l)}_{ij}}、{δz^{(l)}\over δb^{(l)}}、{δℒ(𝒚,\tilde{y})\over δz^{(l)}}\)</span></p>
<p>下面分别计算它们：</p>
<ul>
<li><span class="math inline">\({δz^{(l)}\over δw^{(l)}_{ij}}\)</span>：因为<span class="math inline">\(z=Wx+b\)</span>，则其导数为可以很方便计算得到</li>
<li><span class="math inline">\({δℒ(𝒚,\tilde{y})\over δz^{(l)}}\)</span>：<strong>该偏导数表示第<span class="math inline">\(l\)</span>层神经元对最终损失的影响，也反映了最终损失对第<span class="math inline">\(l\)</span>层神经元的敏感度</strong>，因此一般称为误差项<span class="math inline">\(δ^{(l)}\)</span>，<strong>它也间接反映了神经元对网络的共享程度</strong>，是解决贡献的分配问题的一个指标。详细公式见书p94</li>
</ul>
<h5 id="梯度消失">2.4 梯度消失</h5>
<p>上面可以知道在神经网络中误差反向传播的迭代公式为 <span class="math display">\[
δ^{(l)}=f^{&#39;}_l(z^{(l)})⊙(W^{(l+1)})^Tδ^{(l+1)}
\]</span> 误差从输出层反向传播时，在每一层都要乘以该层的激活函数的导数，当采取Sigmoid型激活函数时，由于其导数<code>&lt;1</code>,经过深度学习，一层一层下去，其误差项不断趋近于0，梯度就会不断衰减,甚至消失，导致网络难以训练.这就是<strong>梯度消失</strong></p>
<p>在深度神经网络中，减轻梯度消失问题的方法有很多种．一种简单有效的方式是使用导数比较大的激活函数，比如ReLU等．</p>
<h4 id="卷积神经网络">3 卷积神经网络</h4>
<p>卷积神经网络（Convolutional Neural Network，CNN或ConvNet）是一种具有<strong>局部连接、权重共享</strong>等特性的深层前馈神经网络．卷积神经网络有个重要的专有词叫<strong>感受野</strong>，，即神经元只接受其所支配的刺激区域内的信号。卷积神经网络的出现解决了全连接前馈网络的两个问题<strong>参数太多</strong>和<strong>局部不变性特征</strong>。</p>
<p><strong>目前的卷积神经网络一般是由卷积层、汇聚层和全连接层交叉堆叠而成的前馈神经网络．卷积神经网络有三个结构上的特性：局部连接、权重共享以及汇聚</strong>．这些特性使得卷积神经网络具有一定程度上的平移、缩放和旋转不变性．和前馈神经网络相比，<strong>卷积神经网络的参数更少</strong>．</p>
<h5 id="卷积和卷积核">3.1 卷积和卷积核</h5>
<p>卷积（Convolution），也叫褶积，是分析数学中一种重要的运算．在信号处理或图像处理中，经常使用一维或二维卷积．</p>
<p>如二维卷积<span class="math inline">\(Y=W*X\)</span>为卷积操作，其中<span class="math inline">\(W\)</span>称为卷积核，<span class="math inline">\(X\)</span>为特征矩阵。 <img src="/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Convolution.png" width="400"></p>
<h5 id="互相关">3.2 互相关</h5>
<p>在机器学习和图像处理领域，卷积的主要功能是在一个图像（或某种特征）上滑动一个卷积核（即滤波器），通过卷积操作得到一组新的特征．在计算卷积的过程中，需要进行卷积核翻转。而在计算<strong>自相关</strong>时,则不需要翻转，所谓的翻转是对<strong>卷积核</strong>进行从上到下，从左到右的的颠倒。<strong>因此互相关和卷积的区别仅仅在于卷积核是否进行翻转</strong></p>
<p>在深度学习中我们一般使用自相关，它也称为<strong>不翻转卷积</strong>。</p>
<p><em>注：卷积核是否进行翻转和其特征抽取的能力无关．特别是当卷积核是可学习的参数时，卷积和互相关在能力上是等价的．因此，为了实现上（或描述上）的方便起见，我们用互相关来代替卷积</em></p>
<h5 id="卷积神经网络-1">3.3 卷积神经网络</h5>
<p>卷积神经网络一般由卷积层、汇聚层和全连接层构成．</p>
<h6 id="卷积层">3.3.1 卷积层</h6>
<p>卷积层的作用是提取一个局部区域的特征，<strong>不同的卷积核相当于不同的特征提取器</strong>。而图像为二维结构，因此为了更充分地利用图像的局部信息，通常将神经元组织为三维结构的神经层，其大小为高度M×宽度N×深度D，由<span class="math inline">\(D\)</span>个<span class="math inline">\(M × N\)</span>大小的特征映射构成。<strong>特征映射（Feature Map）为一幅图像（或其他特征映射）在经过卷积提取到的特征</strong>，每个特征映射可以作为一类抽取的图像特征．为了提高卷积网络的表示能力，可以在每一层使用多个不同的特征映射，以更好地表示图像的特征． <img src="/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/featureMap.png" width="400"> <strong>在输入层，特征映射就是图像本身．如果是灰度图像，就是有一个特征映射，输入层的深度 <span class="math inline">\(D = 1\)</span>；如果是彩色图像，分别有 RGB 三个颜色通道的特征映射，输入层的深度<span class="math inline">\(D = 3\)</span>．</strong></p>
<p>假设现在有一个卷积层的结构如下：</p>
<ul>
<li><p>输入特征映射组：<span class="math inline">\(X∈ ℝ^{M×N×D}\)</span>为三维张量（Tensor），其中每个切片（Slice）矩阵<span class="math inline">\(X^d ∈ ℝ^{M×N }\)</span>为一个输入特征映射，<span class="math inline">\(1 ≤ d ≤D\)</span>；</p></li>
<li><p>输出特征映射组：<span class="math inline">\(y∈ ℝ^{M×N×P}\)</span>为三维张量，其中每个切片矩阵<span class="math inline">\(Y^p ∈ ℝ^{M×N}\)</span>为一个输出特征映射，<span class="math inline">\(1 ≤ p ≤ P\)</span>；</p></li>
<li><p>卷积核：<span class="math inline">\(W∈ ℝ^{M×N×P×D}\)</span>为四维张量，其中每个切片矩阵<span class="math inline">\(W^{pd}∈ ℝ^{U×V}\)</span> 为一个二维卷积核，<span class="math inline">\(1 ≤ p ≤P , 1 ≤ d ≤ D\)</span>．</p></li>
</ul>
<p>因此参数个数为：每一个输出特征映射都需要<span class="math inline">\(D\)</span>个卷积核以及一个偏置．假设每个卷积核的大小为<span class="math inline">\(U × V\)</span>，那么输出<span class="math inline">\(P\)</span>个特征映射共需要<span class="math inline">\(P × D × (U × V ) + P\)</span> 个参数</p>
<h6 id="池化层汇聚层">3.3.2 池化层(汇聚层)</h6>
<p>卷积层虽然可以显著减少网络中连接的数量，但特征映射组中的神经元个数并没有显著减少．如果后面接一个分类器，分类器的输入维数依然很高，很容易出现过拟合．为了解决这个问题，可以在卷积层之后加上一个<strong>汇聚层</strong>，从而降低特征维数，避免过拟合．<strong>汇聚层（Pooling Layer）也叫子采样层（Subsampling Layer），其作用是进行特征选择，降低特征数量，从而减少参数数量</strong>，也叫<strong>池化</strong></p>
<p>假设汇聚层的输入特征映射组为<span class="math inline">\(X∈ ℝ^{M×N×D}\)</span>，对于其中每一个特征映射<span class="math inline">\(X^d ∈ ℝ^{M×N }，1 ≤ d ≤D\)</span>，将其划分为很多区域，这些区域可以重叠，也可以不重叠．<strong>汇聚（Pooling）是指对每个区域进行下采样（Down Sampling）得到一个值，作为这个区域的概括．</strong></p>
<p><strong>常用的池化(汇聚)函数有：</strong></p>
<ul>
<li>最大池化(最大汇聚)：对于一个区域，选择这个区域内所有神经元的最大活性值作为这个区域的表示，即<span class="math inline">\(x^d=max x_i\)</span></li>
<li>平均池化(平均汇聚)：一般是取区域内所有神经元活性值的平均值，即<span class="math inline">\(y^d=avg(\sum x_i)\)</span></li>
</ul>
<p>下图给出了采样最大汇聚进行子采样操作的示例．可以看出，汇聚层不但可以有效地减少神经元的数量，还可以使得网络对一些小的局部形态改变保持不变性，并拥有更大的感受野． <img src="/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/poolinglayer.png" width="400"></p>
<h4 id="网络优化和正则化">4. 网络优化和正则化</h4>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习算法</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生学习方法</title>
    <url>/2022/09/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="步骤">1. 步骤</h4>
<ul>
<li>阅读大量文献：需要阅读该方向的经典论文和最新论文文献</li>
<li>在阅读这些文献之后，需要自己提出一个具体的研究问题。</li>
<li>制定详细的研究计划</li>
<li>论文的写作和投稿</li>
</ul>
<h4 id="论文检索与下载">2. 论文检索与下载</h4>
<p>正如前面所说的，阅读文献的选择应该是在你确定了一个大的研究方向之后，选择经典和最新的文献进行阅读其摘要是否与自己领域相关，相关都建议下载阅读，所谓经典和最新是指：</p>
<ul>
<li>经典（重要）：高被引用的文献</li>
<li>最新（重要）：你所研究方向进一两年的最新成果，在此基础上提出你的具有创新性的研究小方向</li>
<li>其他相关文献</li>
</ul>
<span id="more"></span>
<h5 id="文献检索方法">2.1 文献检索方法</h5>
<ul>
<li>中文文献：中国知网、百度学术</li>
<li>外文文献：谷歌学术</li>
</ul>
<p>在查询后找到相应的DIO，渠道sci-hub进行下载。</p>
<h4 id="论文文献阅读与管理">3. 论文文献阅读与管理</h4>
<h5 id="文献阅读的大致顺序">3.1 文献阅读的大致顺序</h5>
<p><code>经典文献-&gt;最新文献-&gt;相关文献。</code></p>
<ul>
<li>经典文献：帮助你了解你研究领域的基本情况</li>
<li>最新文献：帮助你快速了解研究领域的最新进展，对提出研究方向、研究方案和思路已经是否具有创新性的重要一环。</li>
<li>相关文献：学习相关与研究领域知识，提供灵感和创造性</li>
</ul>
<h5 id="如何进行阅读">3.2 如何进行阅读</h5>
<ul>
<li>经典文献和最新文献应该持续以恒的进行全篇阅读</li>
</ul>
<p>不要用软件大段翻译，最好是划词翻译，长久来看比较有好处</p>
<ul>
<li>（1）文献阅读前首先要确定好自己的研究方向，将研究方向中的关键点找出来，这样在阅读文献前就弄清楚自己想要了解的内容是哪个方面的。<br>
</li>
<li>（2）在阅读某篇具体文献时，先看标题和摘要，了解文章大致内容，同时确定该篇文献中和自己研究方向相关的部分，作为阅读重点</li>
<li>（3）作为一个求知者，最重要的是一个新的看待问题的视角或者说一个新的思考问题的思路，很多问题没有一个明确的答案，我们需要在学习他人研究成果的同时，加强自己对问题的思考能力</li>
</ul>
<h5 id="文献管理">3.3 文献管理</h5>
<p>使用ENDNOTE对文献进行分类管理，记录每个文献主要讲了什么，有什么创新点和对自己的启发，同时讲不同的文献进行分组，方便后续的查看。</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h4 id="get请求和post请求的区别">1. get请求和post请求的区别</h4>
<p><strong>在实际应用中，get和post请求的区别主要有以下几个：</strong></p>
<ul>
<li><strong><code>get</code>请求用于从服务器上获得资源，而<code>post</code>请求用于向服务器提交数据</strong></li>
<li><code>get</code>将表单中的数据按照<code>key=value</code>的形式，添加到<code>action</code>指定的<code>URL</code>后面，并且两者之间使用<code>?</code>连接，各个变量之间使用&amp;连接；post是将表单的数据放在HTTP协议的请求头或者消息体中，传递到action所指向的URL</li>
<li><strong><code>get</code>传输的数据要受到URL长度的限制（最大长度是2048个字符）；而<code>post</code>可以传输大量数据，上传文件通常使用post</strong></li>
<li><strong>使用<code>get</code>时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用<code>get</code>，对于敏感数据应使用<code>post</code></strong></li>
<li><code>get</code>使用<code>MIME</code>类型<code>application/x-www-form-urlencoded</code>的URL编码（也叫百分号编码）文本格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是<code>%20</code></li>
<li><strong><code>get</code>请求参数会被完整保留在浏览器历史记录里，而<code>post</code>中的参数不会被保留。</strong></li>
</ul>
<p><strong>但是在本质上，get和post请求没有区别：</strong></p>
<p><code>get</code>和<code>post</code>是HTTP协议中的两种发送请求的方法，而HTTP是基于<code>TCP/IP</code>的关于数据如何在万维网中如何通信的协议。因此，<code>get</code>和<code>post</code>的底层也是<code>TCP/IP</code>,也就是说，<code>get</code>和<code>post</code>都是TCP链接。</p>
<p><strong>此外，get和post还有一个重要的区别：</strong></p>
<p><code>get</code>产生一个<code>TCP</code>数据包；<code>POST</code>产生两个TCP数据包。对于<code>get</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应200（返回数据）；而对于<code>post</code>，浏览器先发送<code>header</code>，服务器响应<code>100 continue</code>，浏览器再发送<code>data</code>，服务器响应<code>200 ok</code>（返回数据）。</p>
<span id="more"></span>
<h4 id="tcp和udp的区别">2. TCP和UDP的区别</h4>
<ul>
<li><strong>连接性：</strong>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。UDP无连接。</li>
<li><strong>服务对象</strong>：TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；UDP支持一对一，一对多，多对一，多对多的交互通信。</li>
<li><strong>可靠性</strong>：TCP是有保证数据安全可靠的措施，可靠交付：无差错，不丢失，不重复，按序到达。UDP是尽最大努力交付，不保证可靠交付。</li>
<li><strong>拥塞控制和流量控制</strong>：TCP有拥塞控制和流量控制保证数据传输的安全性。UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li>
<li><strong>报文长度</strong>：TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li>
<li><strong>首部开销</strong>：TCP首部开销大，首部20个字节。UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</li>
<li><strong>TCP和UDP适用场景</strong>：从特点上我们已经知道，TCP是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</li>
</ul>
<p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP.png" width="600"> TCP的各个字段有着不同的作用，对于TCP来说，<strong>最重要的就是序列号(seq)、确认序列号(ack)、控制位、窗口大小、校验和和紧急指针</strong>。它们的作用如下：</p>
<ul>
<li><strong>序列号</strong>：报文的序列号，标识TCP发端向TCP接收端发送的数据字节流</li>
<li><strong>确认序列号</strong>：如果设定了ACK,那么从这个字段包含了接收放期望从发送方接收到的下一个数据字节的序列号</li>
<li><strong>首部长度</strong>：该字段标识了TCP报文首部长度，该字段4个比特网位，则表示首部长度最大可达60字节</li>
<li><strong>保留位</strong>：该字段有4位未使用的比特位</li>
<li><strong>控制位</strong>：用来指示相应字段是否有效，主要包括以下控制位：
<ul>
<li><code>CWR</code>：拥塞窗口减小标记</li>
<li><code>ECE</code>：显示的拥塞通知回显标记</li>
<li><code>URG</code>：若设置了该位，则紧急指针字段包含的信息有效</li>
<li><code>ACK</code>：若设置了该位，则确认序列号字段包含的信息有效</li>
<li><code>PSH</code>：将所有收到的数据发送接收的进程</li>
<li><code>RST</code>：重置连接</li>
<li><code>SYN</code>：同步序列号</li>
<li><code>FIN</code>：发送端提示已经完成了发送任务</li>
</ul></li>
<li><strong>窗口大小</strong>：该字段用在接收端发送ACK确认时提示自己可接受数据的空间大小</li>
<li><strong>校验和</strong>：16位的检验，通过在首部添加一些位，在接收端通过CRC校验和来判断数据在传输过程中是否发生错误</li>
<li><strong>紧急指针</strong>：告诉接收端数据包应该马上向上交付给应用层。</li>
</ul>
<h4 id="tcp三次握手">3. TCP三次握手</h4>
<ul>
<li>只有<code>SYN</code>位置1表示连接请求。</li>
<li>只有<code>ACK</code>置1表示<code>ACK</code>报文段，携带数据时会消耗序号<code>seq</code>，不携带则不消耗</li>
<li><code>ACK</code>和<code>SYN</code>都置1，不能携带数据，但消耗1个序号<code>seq</code> <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/threeAndFour.png" width="600"></li>
</ul>
<h5 id="三次握手">3.1 三次握手</h5>
<ul>
<li>1、Client将标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，并将该数据包发送给Server，Client进入<code>SYN_SENT</code>状态，等待Server确认。</li>
<li>2、Server收到数据包后由标志位<code>SYN=1</code>知道Client请求建立连接，Server将标志位<code>SYN</code>和<code>ACK</code>都置为1，<code>ack=J+1</code>，随机产生一个值<code>seq=K</code>，并将该数据包发送给Client以确认连接请求，Server进入<code>SYN_RCVD</code>状态。</li>
<li>3、Client收到确认后，检查<code>ack</code>是否为J+1，ACK若为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给Server，Server检查<code>ack</code>是否为K+1，<code>ACK</code>为1，如果正确则连接建立成功，Client和Server进入<code>ESTABLISHED</code>状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<h5 id="三次握手出现的一些错误怎么办">3.2 三次握手出现的一些错误怎么办</h5>
<ul>
<li><strong>①第一次握手失败：</strong>
<ul>
<li>第一次握手失败由于服务器并没有收到任何消息，因此不会有任何反应，而客户端由于长时间没有收到答复，触发超时重传机制重发ACK数据包。（超时重传机制有次数限制，单个包不能重传超5次）</li>
</ul></li>
<li>②第二次握手失败：
<ul>
<li>客户端：久久没有收到服务器的<code>SYS/ACK</code>包，则超时重传请求连接包</li>
<li>服务器：服务器是发送了<code>SYS/ACK</code>处于<code>SYN_RCVD</code>状态，由于久久没有收到<code>ACK</code>回复，则也好触发超时重传，重传<code>SYN/ACK</code>包</li>
</ul></li>
<li>③第三次握手失败：
<ul>
<li><strong>若客户端先发送数据包</strong>：第三次握手失败，由于客户端已经处于<code>ESTABILSHED</code>状态，后续它可以发送一些请求数据的包给服务器，服务器收到这些请求数据的包，但是服务器还未收到<code>ACK</code>确认报文，还未处于<code>ESTABILSHED</code>状态，因此会回发一个连接异常包，通知客户端重新建立连接，此时包的RST重置连接位会置1</li>
<li><strong>若客户端发送数据包给服务器</strong>：服务器是发送了<code>SYS/ACK</code>处于<code>SYN_RCVD</code>状态，由于久久没有收到<code>ACK</code>回复，则也好触发超时重传，重传<code>SYN/ACK</code>包</li>
</ul></li>
<li>④第三次要回ACK的原因：
<ul>
<li>如果没有第三次回ACK，会导致已经失效的连接请求报文突然又传输到服务器端，又建立客户端与服务器的连接，但客户端又不发送数据，此时导致的服务器资源浪费。 所谓已经失效的连接请求是指客户端发出的连接请求滞留在网络中，超时后但又被服务器接收到。</li>
<li>第三次握手失败（超时）时，服务器并重传一定次数的 <code>SYN/ACK</code> 报文，如果重传机制过完还没有收到，则server 会发送 RTS 复位报文段并主动关闭至<code>closed</code>，以防止 syn 洪泛攻击。</li>
</ul></li>
</ul>
<blockquote>
<p>syn洪泛攻击：通俗的理解是，当第三次握手没有发送确认信息时，等待一段时间后，主机就会断开之前的半开连接并回收资源。如果不这样做将会为 dos（deny of service） 攻击埋下隐患，当主动方主动发送大量的 syn 数据包，但并不做出第三次握手响应，server 就会为这些 syn 包分配资源（但并未使用），就会使 server 占用大量内存，使 server 连接环境耗尽，这就是 syn 洪泛攻击</p>
</blockquote>
<ul>
<li>⑤为什么要三次？一次、两次握手不可以吗？
<ul>
<li><p><strong>假如可以一次握手</strong>：这将致服务器于危险处境——SYN洪泛攻击。如果存在恶意用户发送大量的虚假连接请求，会导致服务器疲于应付无用的连接请求，消耗系统资源，无法为正常用户提供服务。</p></li>
<li><p><strong>假如可以两次握手</strong>：考虑这样一个场景，假如客户端发送了两个请求连接阻塞在网络中。其中第一个丢失，第二个到达了服务端。但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，此时没有三次握手，双方就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p></li>
</ul></li>
</ul>
<h5 id="思考connect为什么会阻塞即第三次ack丢失下客户端怎么办">3.3 思考：connect为什么会阻塞（即第三次ACK丢失下客户端怎么办）</h5>
<p><strong>server端：</strong></p>
<blockquote>
<p>第三次的ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。 而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为&gt;5.如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。</p>
</blockquote>
<p><strong>client端</strong>：</p>
<blockquote>
<p>在linux c 中，client 一般是通过<code>connect()</code>函数来连接服务器的，而<code>connect()</code>是在TCP的三次握手的第二次握手完成后就成功返回值。也就是说client在接收到 SYN+ACK包，它的TCP连接状态就为established （已连接），表示该连接已经建立。 那么如果第三次握手中的ACK包丢失的情况下，Client 向<code>server</code>端发送数据，Server端将以<code>RST</code>包响应，方能感知到Server的错误。</p>
</blockquote>
<h4 id="tcp四次挥手">4. TCP四次挥手</h4>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个<code>FIN</code>来终止这一方向的连接，收到一个<code>FIN</code> 只是意味着这一方向上没有数据流动了，即不会再发送到数据了，但是在这个TCP连接上仍然能够收数据，直到另一方也发送了<code>FIN</code>。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<h5 id="四次挥手过程">4.1 四次挥手过程</h5>
<ul>
<li>1.数据传输结束后，客户端的应用进程发出连接释放<code>FIN</code>报文段，并停止发送数据，客户端进入<code>FIN_WAIT_1</code>状态，此时客户端依然可以接收服务器发送来的数据。</li>
<li>2.服务器接收到<code>FIN</code>后，发送一个<code>ACK</code>给客户端，确认序号为收到的序号<code>+1</code>，服务器进入<code>CLOSE_WAIT</code>状态。客户端收到后进入<code>FIN_WAIT_2</code>状态。</li>
<li>3.当服务器没有数据要发送时，服务器也发送一个<code>FIN</code>报文，此时服务器进入<code>LAST_ACK</code>状态，等待客户端的确认</li>
<li>4.客户端收到服务器的<code>FIN</code>报文后，给服务器发送一个<code>ACK</code>报文，确认序列号为收到的序号<code>+1</code>。此时客户端进入<code>TIME_WAIT</code>状态，等待<code>2MSL</code>（MSL：报文段最大生存时间），然后关闭连接。</li>
</ul>
<p>应用层可以使用系统调用函数read函数==0来判断对端是否关闭连接。</p>
<h5 id="为什么要等待2msl才关闭链接">4.2 为什么要等待2MSL才关闭链接</h5>
<ul>
<li>①为保证客户端发送的最后一个ACK报文段能够到达服务器。若第4次挥手的报文段丢失了，服务器就会超时重传第3次挥手的报文段。</li>
<li>②经过2MSL时间，可以使本次连接持续时间内所以产生的报文段(主要针对滞留在网络中的）都失效，这样就可避免已失效的本次链接请求影响下一次链接请求。</li>
</ul>
<h5 id="为什么要4次挥手">4.3 为什么要4次挥手</h5>
<p>因为主动关闭的一方是已经确定没有数据要发送了，而被动关闭的一方还未<code>FIN</code>报文，先回一个<code>ACK</code>确认报文，其在<code>FIN</code>发生前可能还要发送数据，只有等待数据发生完，才能回一个<code>FIN</code>报文，主动关闭方再回一个<code>ACK</code>确认,才能达到双向关闭，</p>
<h4 id="tcp机的状态转移">5. TCP机的状态转移</h4>
<p><img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/statusSwitch.png" width="600"> [^上半部分为3次握手，下半部分为4次挥手，实线表示主动，虚线为被动，细线为特殊情况]</p>
<p><strong>状态解释：</strong></p>
<ul>
<li><code>CLOSED</code>：表示初始状态。</li>
<li><code>LISTEN</code>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li>
<li><code>SYN_SENT</code>：这个状态与<code>SYN_RCVD</code>遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。<code>SYN_SENT</code>状态表示客户端已发送SYN报文。</li>
<li><code>SYN_RCVD</code>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</li>
<li><p><code>ESTABLISHED</code>：表示连接已经建立。</p></li>
<li><strong><code>FIN_WAIT_1</code>: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文</strong>。区别是：
<ul>
<li><code>FIN_WAIT_1</code>状态是当socket在<code>ESTABLISHED</code>状态时，想主动关闭连接，向对方发送了<code>FIN</code>报文，此时该socket进入到FIN_WAIT_1状态。</li>
<li><code>FIN_WAIT_2</code>状态是当对方回应<code>ACK</code>后，该socket进入到<code>FIN_WAIT_2</code>状态，正常情况下，对方应马上回应<code>ACK</code>报文，所以<code>FIN_WAIT_1</code>状态一般较难见到，而<code>FIN_WAIT_2</code>状态可用netstat看到。</li>
</ul></li>
<li><p><code>FIN_WAIT_2</code>：<strong>主动关闭链接的一方，发出<code>FIN</code>收到<code>ACK</code>以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发，既socket上还有数据流动。</strong></p></li>
<li><p><code>TIME_WAIT</code>: <strong>表示收到了对方的<code>FIN</code>报文，并发送出了<code>ACK</code>报文，等2MSL后即可回到CLOSED可用状态。如果<code>FIN_WAIT_1</code>状态下，收到对方同时带<code>FIN</code>标志和<code>ACK</code>标志的报文时，可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code>状态。</strong></p></li>
<li><p><code>CLOSING</code>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p></li>
<li><code>CLOSE_WAIT</code>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。（服务器）</li>
<li><p><code>LAST_ACK</code>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。（服务器）</p></li>
</ul>
<h4 id="tcp的拥塞控制对整个网络">6. TCP的拥塞控制：对整个网络</h4>
<p>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。<strong>流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口<code>cwnd</code>。</strong></p>
<ul>
<li><p><strong>慢开始</strong>：最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免<code>cwnd</code>增长过大。</p></li>
<li><p><strong>拥塞避免</strong>：每经过一个往返时间<code>RTT</code>，<code>cwnd</code>只增长1。在慢开始和拥塞避免的过程中，一旦发现网络拥塞（超时），就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）</p></li>
<li><p><strong>快重传</strong>：接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。</p></li>
<li><p><strong>快恢复</strong>：当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），并将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/controlOfcrowd.png" width="600"></p></li>
</ul>
<h4 id="tcp的可靠性保证">7. TCP的可靠性保证</h4>
<p>TCP主要提供了<strong>检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制</strong>等方法实现了可靠性传输。</p>
<ul>
<li><p><strong>序列号/确认应答：</strong>TCP报文中有序列号和确认序列号，对于接收和发送都具有缓存区的性质，保证了数据能够丢失重传和解决包乱序的问题。</p></li>
<li><p><strong>检验和</strong>：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部</p></li>
<li><p>最大长度：在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</p></li>
<li><p><strong>流量控制：TCP为它的应用程序提供了流量控制服务来避免发送方因为发送速率过快导致接收方缓存溢出数据丢失的问题。说白了流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。流量控制只是适应点对点而采取的措施。双方可通过在TCP报文的“窗口大小”进行设置己端的窗口大小。端对端的流量控制，也解决包乱序问题（数据包格式有SequenceNumber，是数据包的序号seq，ACK用于确认收到，用来解决不丢包的问题)</strong>。每一次读取数据之后,回ack报文,报文中会携带当前缓冲区大小,用来告知对方发送的数据不能超过我接收的缓冲区大小。 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WindowSize.png" width="700"></p></li>
<li><p><strong>滑动窗口：</strong>我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。这就提出了一个滑动窗口的概念:不必等等确认，发送端直接发送数据，在连续收到三个重复确认应答时，重新发生要求的序列号包。已经接收到的数据包放在窗口缓存内，但下一个期望的数据包序列号是最需要的也是最靠近滑动窗口前面但还未收到的，直到收到后窗口才会后移 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/resend.png" width="600"></p></li>
</ul>
<h4 id="tcp的滑动窗口">8. TCP的滑动窗口</h4>
<p>端对端的流量控制,也解决包乱序问题（数据包格式有SequenceNumber，是数据包的序号seq,ACK——用于确认收到，用来解决不丢包的问题)。每一次读取数据之后,回ack报文,报文中会携带当前缓冲区大小,用来告知对方发送的数据不能超过我接收的缓冲区大小。</p>
<h4 id="tcp黏包问题">9. TCP黏包问题</h4>
<p><strong>原因：</strong> TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p>
<p><strong>解决：</strong></p>
<ul>
<li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li>
<li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li>
<li>在数据包之间设置边界，如添加特殊符号 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 ，则会误判为消息的边界。</li>
</ul>
<h4 id="简述域名解析过程本机如何干预域名解析">10. 简述域名解析过程，本机如何干预域名解析</h4>
<ul>
<li><p>1）在浏览器中输入<code>www.qq.com</code>域名，操作系统会先检查自己本地的<code>hosts</code>文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p></li>
<li><p>2）如果<code>hosts</code>里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p></li>
<li><p>3）如果<code>hosts</code>与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p></li>
<li><p>4）如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p></li>
<li><p>5）如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名<code>.com</code>是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责<code>.com</code>域的这台服务器。这台负责<code>.com</code>域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址<code>qq.com</code>给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找<code>qq.com</code>域服务器，重复上面的动作，进行查询，直至找到<code>www.qq.com</code>主机。</p></li>
<li><p>6）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></li>
</ul>
<p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>
<h4 id="section">10.</h4>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉课程笔记</title>
    <url>/2022/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="深度学习cnn卷积神经网络算法精讲">1. 深度学习CNN卷积神经网络算法精讲</h4>
<h5 id="cnn与transformer的不同点">1.1 CNN与Transformer的不同点</h5>
<ul>
<li>要明白CNN就是对图像提取特征，提取不是一次性提取，而是多次，由局部向全局做特征。</li>
<li>Transformer则与CNN不同，直接全局考提取特征，这就避免了多次提取特征。</li>
</ul>
<h4 id="ai当下最火模块注意力机制解读">2. AI当下最火模块注意力机制解读</h4>
<h4 id="视觉领域transformer应用实例">3. 视觉领域transformer应用实例</h4>
<p>Transformer则与CNN不同，直接全局考提取特征，这就避免了多次提取特征。</p>
<h5 id="应用">3.1 应用</h5>
<h4 id="视觉当下最新研究方向与进展">4. 视觉当下最新研究方向与进展</h4>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>项目：游戏服务器</title>
    <url>/2023/03/06/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，密码有误，请重新输入" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="76f8899e1a2fffc5813d7c389cccfb22dcb0f4810917de84c65b85e199cd108a">14b4468ea0248010a84551233908590e31a633046e2248aeb466c3bff9009b7d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码访问</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题解</title>
    <url>/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="刷题规划">0. 刷题规划</h2>
<p>读者在看到这篇文章的时候不应该以本文的讲解顺序进行刷题。正常来说，按模块刷题是最好的，我的刷题是按照<strong>数组-&gt;链表-&gt;树-&gt;dp</strong>的循环进行，然后对各模块的方法进行总结，比如遇到 - <strong>数组一类</strong>的，其可使用的方法最多：<strong>二分查找、快慢指针、双指针、滑动窗口、前缀和数组、差分数组</strong>等。 - 遇到<strong>链表</strong>，那么<strong>快慢指针是最多的</strong>。 - 遇到<strong>树</strong>，那么递归（广度or深度）是最常用的形式、非递归遍历也要顺序，记住对称性解题方式。 - 遇到<strong>动态规划</strong>，先分类其是属于哪种形式的dp（<strong>线性dp、区间dp、背包dp和状压dp</strong>），然后确定dp含义，分析状态转移方程。 - 其他方法，比如**单调栈、单调队列的实现、拓扑排序、归并排序、KMP算法、分治、广度*等算法就就需要在刷题中不断掌握</p>
<p><strong><em>注意：在解题中一定不要忽略暴力解，许多奇妙的解法就是从暴力解的思路上想出来的，一旦遇到一道不会优解的题，可以先想一想暴力解的思路，有什么地方可以优化暴力解，来达到降低时间复杂度的效果</em></strong></p>
<h2 id="动态规划类">1. 动态规划类</h2>
<p>动态规划的思想就是：<strong>如果一个问题能够由子问题一步步递推得来，即当前子问题的解将由上一次子问题的解推出，利用这种特性，使用一个数据结构<code>dp</code>来存储上一次子问题的结果，避免重复计算</strong>。</p>
<p>所以动态规划最重要的有三点：</p>
<ul>
<li>确定dp的含义</li>
<li>确定dp的初始状态</li>
<li>确定dp间的状态转移方程</li>
</ul>
<p>知道上述三点，问题也就迎刃而解。在算法当中，常见的dp类型有<strong>线性dp、区间dp、背包dp和状压dp</strong>。下面将对这几个进行讲解。</p>
<p><strong>总结</strong>：对于是否使用DP，那么就得看你能不能确定dp数组的含义，以及能够确定状态转移方程。</p>
<h3 id="线性dp">1.1 线性DP</h3>
<h4 id="打家劫舍">打家劫舍</h4>
<p><strong>问题：</strong>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态规划：当我们以nums[i]作为结尾计算其最大金额时，每次都要遍历得到当0~i-2结尾时的最大金额</span></span><br><span class="line"><span class="comment">因此我们可以使用动态规划来存储这些值，避免重复计算</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义：dp[i]表示nums[0]-nums[i]能偷的最大金额</span></span><br><span class="line"><span class="comment">- 初始条件：dp[0]=nums[0],dp[1]=max(nums[0],nums[1])</span></span><br><span class="line"><span class="comment">- 状态转移方程：dp[i]=max(dp[i-2]+nums[i],dp[i-1])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">2</span>);i&lt;len;++i)</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="打家劫舍-1">打家劫舍Ⅱ</h4>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。<strong>这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的</strong>。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<p><strong>解题思路：与打家劫舍多了一个约束：这个地方所有的房屋都 围成一圈，第一个房屋和最后一个房屋是相连的,需要考虑这种情况</strong></p>
<p>还是使用动态规划：<code>dp[i]</code>表示截至到<code>i+1</code>号房能够偷盗的最大金额，此时需要做两次不同的<code>dp</code>比较，</p>
<ul>
<li>一个是选择<code>1</code>号房屋，此时就不能选择最后一个房屋
<ul>
<li>初始状态：<code>dp1[0]=nums[0],dp[1]=max(dp1[1],dp1[0])</code></li>
<li>状态转移: <code>dp1[i]=max(dp1[i-2]+nums[i],d1[i-1])  1&lt;i&lt;n-1</code></li>
</ul></li>
<li>另一个是不选择1号屋，此时对最后一个房屋没有要求
<ul>
<li>初始状态：<code>dp2[1]=nums[1],dp2[2]=max(dp2[1],dp2[2]);</code></li>
<li>状态转移：<code>dp2[i]=max(dp2[i-2]+nums[i],dp2[i-1])  2&lt;i&lt;n</code></li>
</ul></li>
<li>最后<code>max(dp1[n-2],dp2[n-1])</code></li>
</ul>
<p>上面的dp数组可省略，因为当前状态只与前两个有关</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*/</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//vector&lt;int&gt;dp1(n-1,0);</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt;dp2(n,0);</span></span><br><span class="line">        <span class="comment">//dp1[0]=nums[0],dp1[1]=max(nums[0],nums[1]);</span></span><br><span class="line">        <span class="type">int</span> dp1_1=nums[<span class="number">0</span>],dp1_2=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="comment">//dp1[i]=max(dp1[i-2]+nums[i],dp1[i-1]);</span></span><br><span class="line">            <span class="type">int</span> temp=dp1_1;</span><br><span class="line">            dp1_1=dp1_2;</span><br><span class="line">            dp1_2=<span class="built_in">max</span>(temp+nums[i],dp1_2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp2[1]=nums[1],dp2[2]=max(nums[1],nums[2]);</span></span><br><span class="line">        <span class="type">int</span> dp2_1=nums[<span class="number">1</span>],dp2_2=<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//dp2[i]=max(dp2[i-2]+nums[i],dp2[i-1]);</span></span><br><span class="line">            <span class="type">int</span> temp=dp2_1;</span><br><span class="line">            dp2_1=dp2_2;</span><br><span class="line">            dp2_2=<span class="built_in">max</span>(temp+nums[i],dp2_2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//return max(dp1[n-2],dp2[n-1]);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp1_2,dp2_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="打家劫舍-2">打家劫舍Ⅲ</h4>
<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root </code>。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p>
<p>给定二叉树的<code> root</code> 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p>
<p><strong>解题思路：</strong></p>
<p><strong>使用动态规划+深度搜索：</strong>使用分解成子问题的方式来解决，因为一个节点只有选与不选两者可能，选会对其他节点产生影响，那么我们从自低向上的方式来解决，将一颗树分解成多个子树的求解过程，通过子树不断向整颗树递进进行求解，比如对于root，我们向求出其左右子树选与不选时的金额，我们用<code>dp[2]</code>记录，<code>dp_r[0]</code>表示不选择该右节点时右子树能得到的最大金额，<code>dp_r[1]</code>表示选择该右节点时右子树能得到的最大金额，同理<code>dp_l[0]</code>和<code>dp_l[1]</code>，那么对于<code>root</code>，它的 <code>dp_root[1]=dp_r[0]+dp_l[0]+root,dp_root[0]=max(dp_r[0],dp_l[1])+max(dp_l[0],dp_l[1]);</code></p>
<p>因此，解题步骤：</p>
<ul>
<li>构建一个<code>rootdfs(left,right)</code>，返回<code>vector&lt;int&gt;</code></li>
<li>每一次递归都要构建<code>dp[2],dp[0]</code>表示不选择改节点，<code>dp[1]</code>选择</li>
<li>初始条件<code>dp[]=0</code></li>
<li>状态转移条件：<code>dp[0]=max(dp_r[0],dp_l[1])+max(dp_l[0],dp_l[1]); dp[1]=dp_r[0]+dp_l[0]+root</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> vector&lt;<span class="type">int</span>&gt; <span class="title">robdfs</span><span class="params">(TreeNode* l,TreeNode* r,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp_l</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span>,<span class="title">dp_r</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="literal">nullptr</span>) dp_l=<span class="built_in">robdfs</span>(l-&gt;left,l-&gt;right,l-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="literal">nullptr</span>) dp_r=<span class="built_in">robdfs</span>(r-&gt;left,r-&gt;right,r-&gt;val);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="built_in">max</span>(dp_r[<span class="number">0</span>],dp_r[<span class="number">1</span>])+<span class="built_in">max</span>(dp_l[<span class="number">0</span>],dp_l[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">1</span>]=dp_r[<span class="number">0</span>]+dp_l[<span class="number">0</span>]+value;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>) dp=<span class="built_in">robdfs</span>(root-&gt;left,root-&gt;right,root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>],dp[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最大子数组的和">最大子数组的和</h4>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*动态规划：dp[i][j]，表示[i,j]范围的子数组和，我们只需记录出现的最大和即可maxValue</span></span><br><span class="line"><span class="comment">*  - 初始条件时dp[i][i]=nums[i]</span></span><br><span class="line"><span class="comment">*  - 状态转移条件时dp[i][j]=dp[i][j-1]+nums[j]</span></span><br><span class="line"><span class="comment">*时间复杂度为O(n*n)，空间复杂度为O(n*n)</span></span><br><span class="line"><span class="comment">：超时：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*优化：空间复杂度为O(1),时间复杂度为为O(n*n):超时</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*时间复杂度O(n)解法：dp</span></span><br><span class="line"><span class="comment">*从前往后遍历一下即可，要记录前面包含i-1连续子数组的和sum：</span></span><br><span class="line"><span class="comment">*- 若当前nums[i]&gt;=0，sum&gt;=0,则子数组和为sum+nums[i]</span></span><br><span class="line"><span class="comment">*- 若当前nums[i]&gt;=0，当sum&lt;0，则当前子数组和为nums[i]</span></span><br><span class="line"><span class="comment">*- 若当前nums[i]&lt;0，当sum+nums[i]&gt;=0时，可选择nums[i]继续作为连续子数组</span></span><br><span class="line"><span class="comment">*- 当nums[i]&lt;0,当sum+nums[i]&lt;0时，放弃nums[i],重新以i+1作为开始</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 上面分析总结为动态规划就是，dp[i]，i表示以nums[i]为结尾的子数组和的最大值</span></span><br><span class="line"><span class="comment">- 初始条件dp[0]=nums[0]</span></span><br><span class="line"><span class="comment">- 状态转移dp[i]=max(dp[i-1]+nums[i],nums[i])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxValue=nums[<span class="number">0</span>];</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(maxValue&lt;dp[i])</span><br><span class="line">                maxValue=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="剑指offer-丑数">剑指offer 丑数</h4>
<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 &gt;质数：因子除了1和它本身外，无其他因子</p>
<p><strong>思路：</strong>优化方法我们只需要考虑2的倍数、3的倍数和5的倍数即可</p>
<ul>
<li>此时需要更改<code>dp[i]</code>数组含义，<code>dp[i]</code>表示目前得到<code>i+1</code>个丑数是<code>dp[i]</code>，这就要保证dp[i]是递增顺序的无重复的</li>
<li>初始条件<code>dp[0]=1</code></li>
<li>难点：为了得到状态转移方程，因为有三个乘积因子2，3，5，如果一股脑不加以判断的添加，会出现非递增存储和重复的结果。比如，从dp[0]于2、3、5相乘后会得到1、2、3、5，之后dp[1]得到1、2、3、5、4、6、10，再dp[2]得到1、2、3、5、4、6、10、6、9、15...明显存在重复和乱序以及重复计算</li>
<li>因此可以使用<code>a、b、c</code>去记录分别要与<code>2、3、5</code>将要相乘的<code>dp[j]</code>，能够很好的解决乱序和重复问题,初始时<code>a=b=c=0</code></li>
<li>所以状态转移方程为：<code>dp[i]=min(min(dp[a]*2,dp[b]*3),dp[c]*5)</code>,然后于<code>dp[i]</code>相等的索引即<code>a、b、c</code>进行<code>++</code></li>
<li>直到<code>dp.size()==n</code>，然后对dp排序去最后一个元素得到第<code>n</code>个丑数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*动态规划：dp[i]记录数字i是否为丑数，是则为true,</span></span><br><span class="line"><span class="comment">*初始dp[0]=false,dp[1]=true</span></span><br><span class="line"><span class="comment">*状态转移方程dp[i]=dp[i/2]||dp[i/3]||dp[i/5],其中i/2、i/3和i/5必须为整数</span></span><br><span class="line"><span class="comment">*会超时</span></span><br><span class="line"><span class="comment">*优化：我们只需要考虑2的倍数、3的倍数和5的倍数即可</span></span><br><span class="line"><span class="comment">*此时需要更改dp[i]数组含义，dp[i]表示目前得到i+1个丑数是dp[i]</span></span><br><span class="line"><span class="comment">*- 初始条件dp[0]=1</span></span><br><span class="line"><span class="comment">*- 难点：为了得到状态转移方程，因为有三个乘积因子2，3，5，如果一股脑不加以判断的添加，会出现非递增存储和重复的结果。比如，从dp[0]于2、3、5相乘后会得到1、2、3、5，之后dp[1]得到1、2、3、5、4、6、10，再dp[2]得到1、2、3、5、4、6、10、6、9、15...明显存在重复和乱序以及重复计算</span></span><br><span class="line"><span class="comment">*- 因此可以使用a、b、c去记录分别要与2、3、5将要相乘的dp[j],初始时a=b=c=0</span></span><br><span class="line"><span class="comment">*- 所以状态转移方程为：dp[i]=min(min(dp[a]*2,dp[b]*3),dp[c]*5),然后于dp[i]相等的索引即a、b、c进行++</span></span><br><span class="line"><span class="comment">*直到dp.size()==n，然后对dp排序去最后一个元素得到第n个丑数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*超时规划</span></span><br><span class="line"><span class="comment">    int nthUglyNumber(int n) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;bool&gt; dp;</span></span><br><span class="line"><span class="comment">        dp.push_back(false);//dp[0]</span></span><br><span class="line"><span class="comment">        dp.push_back(true);//dp[1]</span></span><br><span class="line"><span class="comment">        n--;</span></span><br><span class="line"><span class="comment">        for(int i=2;n&gt;0;++i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if((i%2==0&amp;&amp;dp[i/2])||(i%3==0&amp;&amp;dp[i/3])||(i%5==0&amp;&amp;dp[i/5]))&#123;</span></span><br><span class="line"><span class="comment">                dp.push_back(true);</span></span><br><span class="line"><span class="comment">                --n;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            dp.push_back(false);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return dp.size()-1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//得到顺序丑数</span></span><br><span class="line">            <span class="type">int</span> n2=dp[a]*<span class="number">2</span>,n3=dp[b]*<span class="number">3</span>,n5=dp[c]*<span class="number">5</span>;</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(<span class="built_in">min</span>(n2,n3),n5);</span><br><span class="line">			<span class="comment">//避免重复丑数</span></span><br><span class="line">            <span class="keyword">if</span>(n2==dp[i]) ++a;</span><br><span class="line">            <span class="keyword">if</span>(n3==dp[i]) ++b;</span><br><span class="line">            <span class="keyword">if</span>(n5==dp[i]) ++c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="n个骰子的点数">n个骰子的点数</h4>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p><strong>思路：</strong></p>
<ul>
<li><code>n(n&gt;1)</code>个骰子的点数与<code>n-1</code>个骰子的点数有着密切联系，假设<code>f(n-1)</code>是<code>n</code>个骰子的点数概率结果，和为<code>x</code>的概率为<code>f(n-1,x)</code>，那么<code>f(n,x)</code>的概率结果是<code>Σf(n-1,x-i)*1/6</code>，其中<code>i=1,...,6;</code>且<code>6(n-1)&gt;=x-i&gt;=(n-1)</code></li>
<li>因为只与上一个结果有关，因此可以使用两个数组来完成，第一个是存储<code>n-1</code>个骰子的概率结果，第二个依据<code>n-1</code>来构建</li>
</ul>
<p><strong>算法过程：</strong></p>
<ul>
<li>因此上面的思想是动态规划：使用<code>dp1[i]</code>，表示<code>k-1</code>个骰子的概率结果，<code>dp[i]</code>为<code>k</code>个骰子的概率结果</li>
<li>初始条件： <code>dp1[1]=dp1[2]=..=dp1[6]=1/6</code></li>
<li>状态转移方程<code>dp[j]=Σdp1[j-i]*1/6</code> 其中<code>6(k-1)&gt;j-i&gt;=(k-1)和i=1,...,6</code></li>
<li>更新<code>dp1=dp</code>，继续上述步骤，直到<code>k&gt;n</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> a=<span class="number">1.0</span>/<span class="number">6.0</span>;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt;<span class="built_in">dp1</span>(<span class="number">7</span>,a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">k</span>(<span class="number">2</span>);k&lt;=n;++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len=<span class="number">6</span>*k+<span class="number">1</span>;</span><br><span class="line">            vector&lt;<span class="type">double</span>&gt;<span class="built_in">dp</span>(len,<span class="number">0.0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">j</span>(k);j&lt;len;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>);i&lt;<span class="number">7</span>;++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>((j-i)&gt;=(k<span class="number">-1</span>)&amp;&amp;(j-i)&lt;=<span class="number">6</span>*(k<span class="number">-1</span>))</span><br><span class="line">                        dp[j]+=dp1[j-i]*a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp1=dp;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;dp1.<span class="built_in">size</span>();++i)</span><br><span class="line">            ret.<span class="built_in">push_back</span>(dp1[i]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="单词拆分">单词拆分</h4>
<p>给你一个字符串<code>s</code>和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p><strong>思路：</strong> 遍历<code>s</code>的字符串进行拼接，查看该子串是否在<code>wordDict</code>中，子串的状态会被上一个状态所影响，因此可采用动态规划的思想来解决（比如<code>&quot;catsandog&quot;</code>和<code>[&quot;c&quot;,&quot;cats&quot;,&quot;an&quot;,&quot;dog&quot;]</code>）</p>
<p><strong>解题步骤</strong>：</p>
<ul>
<li>动态规划+哈希：使用<code>dp[i]</code>表示字符串从<code>[1,i]</code>是否可有<code>wordDict</code>构成，是则为<code>true</code>,否则为<code>false</code></li>
<li>初始状态：<code>dp[0]=true</code>,表示空串，是能够表示的，</li>
<li>状态转移方程：<code>dp[i+1]=dp[j]&amp;&amp;(s[j,i] in wordDict?)</code>,其中<code>j</code>取值满足<code>i-j&lt;=20</code>（或者也可得到<code>wordDict</code>字符串的最大长度，以此达到剪枝的目的）</li>
<li>其中从字典中查找<code>s[j,i]</code>会消耗大多是时间，我们可将<code>wordDict</code>放在哈希上，使查找的时间复杂度为<code>O(1)</code></li>
<li>因此以上时间复杂度为<code>O(n*n)</code>，空间复杂度为<code>O(n)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">bool</span>&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">       unordered_set&lt;string&gt; Set;</span><br><span class="line">       dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">       <span class="type">int</span> maxLen=<span class="number">0</span>;    <span class="comment">//记录字典的最长字符串的长度，达到剪枝目的</span></span><br><span class="line">       <span class="keyword">for</span>(string t:wordDict)</span><br><span class="line">       &#123;</span><br><span class="line">           Set.<span class="built_in">insert</span>(t);</span><br><span class="line">           maxLen=maxLen&gt;t.<span class="built_in">size</span>()?maxLen:t.<span class="built_in">size</span>();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i;!dp[i+<span class="number">1</span>]&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;len&lt;=maxLen;--j)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="function">string <span class="title">str</span><span class="params">(s.substr(j,len))</span></span>;</span><br><span class="line">               ++len;</span><br><span class="line">               <span class="keyword">if</span>(dp[j]&amp;&amp;Set.<span class="built_in">find</span>(str)!=Set.<span class="built_in">end</span>())</span><br><span class="line">                    dp[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="接雨水">接雨水</h4>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>题解思路：</strong></p>
<ul>
<li><p><strong>暴力方法：</strong> 对每一个遍历得到的柱子，分别遍历得到其左右的柱子的最大值，可得当前位置可接雨水<code>min(height[l],height[h])-height[i]</code>,此时时间复杂度为<code>O(n*n</code>，不能接受</p></li>
<li><strong>动态规划类型：</strong> 上面暴力方法中，为了得到当前位置可接雨水数量，要遍历左右两边，存在大量的重复计算，可以使用两个数组<code>leftmax[i]</code>和<code>rightmax[i]</code>来记录当前位置i左右两边的最高柱子高度，其中<code>leftmax[max]</code>在计算中更新，<code>right[max]</code>事前全部准备好，此时时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(n)</code>
<ul>
<li>即<code>leftmax[i]</code>和<code>rightmax[i]</code>来记录当前位置i左右两边的最高柱子高度</li>
<li>初始条件为<code>leftmax[0]=height[0]</code>,<code>leftmax为倒叙遍历后的最大值情况</code></li>
<li>状态转移方程是leftmax[i]=max(height[i,leftmxa[i-1]]),根据比较记录<code>sum=min(leftmax[i],rightmax[i])-height[i]</code></li>
</ul></li>
<li><strong>双指针类型：</strong> 上面的动态规划由于要存储左右最大值使得空间复杂度为<code>O(n)</code>，进一步分析可知可使用双指针，其中<code>l</code>为左指针，<code>h</code>为右指针，我们发现存水多少取决于左右最大值较小的那一个，那么无论最大那个多大，都不是它决定，而是较小的决定。
<ul>
<li>所有我们定义<code>leftmax，rightmax</code>，来记录左右指针目前走过区域的最大值，其中<code>l</code>只会向右走，<code>h</code>只会向左走</li>
<li>更新策略是用<code>height[l]</code>，<code>height[h]</code>更新<code>leftmax、rightmax</code></li>
<li>当<code>height[l]&gt;height[h]</code>时,可以肯定<code>lefmax&gt;rightmax</code>,因此可接雨水是<code>rightmax-height[h]</code>，此时--h;</li>
<li>当<code>height[l]&lt;=height[h]</code>时，可以肯定<code>lefmax&lt;=rightmax</code>,因此可接雨水是<code>leftmax-height[l]</code>，此时<code>++l</code>; -当<code>l&gt;h</code>时退出，累计的雨水即为所求</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,h=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> leftmax=<span class="number">0</span>,rightmax=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;h)</span><br><span class="line">        &#123;</span><br><span class="line">            leftmax=<span class="built_in">max</span>(leftmax,height[l]);</span><br><span class="line">            rightmax=<span class="built_in">max</span>(rightmax,height[h]);</span><br><span class="line">            <span class="keyword">if</span>(height[l]&gt;height[h])</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=rightmax-height[h];</span><br><span class="line">                --h;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=leftmax-height[l];</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*dp</span></span><br><span class="line"><span class="comment">        int n=height.size();</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; rightmax(n,0);</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt;leftmax(n,0);</span></span><br><span class="line"><span class="comment">        rightmax[n-1]=height[n-1];</span></span><br><span class="line"><span class="comment">        leftmax[0]=height[0];</span></span><br><span class="line"><span class="comment">        int sum=0;</span></span><br><span class="line"><span class="comment">        for(int i=height.size()-2;i&gt;=0;--i)</span></span><br><span class="line"><span class="comment">            rightmax[i]=max(height[i],rightmax[i+1]);</span></span><br><span class="line"><span class="comment">        for(int i(1);i&lt;n;++i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            leftmax[i]=max(leftmax[i-1],height[i]);</span></span><br><span class="line"><span class="comment">            sum+=min(leftmax[i],rightmax[i])-height[i];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最佳买股票时机含冷冻期">最佳买股票时机含冷冻期</h4>
<p>给定一个整数数组<code>prices</code>，其中第  <code>prices[i]</code> 表示第<code> i </code>天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
<li>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>因为多了个冷冻期的约束，这表示对于卖出股票后，后续能否买入，要看是否处于冷冻期 动态规划：使用二维dp解决，<code>dp[i][j]</code>中，其中第一维度表示到第<code>i</code>天能够得到最大利润，<code>p[i][0]</code>表示目前没持有股票且不处于冷冻期的最大利润；<code>p[i][1]</code>表示未持有股票且处于冷冻期，这表示在第i天卖出；<code>dp[i][2]</code>表示持有一个股票时的最大利润</p>
<ul>
<li>初始条件：<code>dp[0][0]=0,dp[0][1]=0,dp[0][2]=-prices[0]</code></li>
<li>状态转移方程：<code>dp[i][0]=max(dp[i-1][0],dp[i-1][1]);dp[i][1]=dp[i-1][2]+prices[i];dp[i][2]=max(dp[i-1][2],dp[i-1][0]-prices[i])</code></li>
</ul>
<p><strong>总结：像这样对于中间状态有多个不同的情况，在运用动态规划的时候，单个维度dp无法表示，通常可以扩展到二维，定义二维度含义表示（比如<code>打家劫舍Ⅲ</code>也是一样的道理）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">2</span>]+prices[i];</span><br><span class="line">            dp[i][<span class="number">2</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最长递增序列">最长递增序列</h4>
<p>给你一个整数数组<code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code>的子序列。</p>
<p><strong>解题思路：利用动态规划的思想一步步求解并优化</strong></p>
<p><strong>方法一：</strong> <code>dp[i]</code>数组存储表示以<code>nums[i]</code>结尾的最长递增子序列，那么对于该<code>dp</code>有</p>
<ul>
<li>初始状态：<code>dp[0]=1</code></li>
<li>状态转移：以当前位置逆序方式进行查找，直到找到第一个<code>nums[j]&lt;nums[i]</code>，那么<code>dp[i]=1+dp[j]</code>,没找到则<code>dp[i]=1</code></li>
</ul>
<p>上面的方法一的时间复杂度为<code>O(n*n)</code>，原因是对于当前的<code>nums[i]</code>，我们都必须逆序在<code>[0,i-1]</code>去寻找第一个满足<code>nums[j]&lt;nums[i]</code>的元素。</p>
<p><strong>方法二：</strong> 基于上面的思想，为了优化时间复杂度，能否对逆序寻找进行优化呢，使复杂度降为O(N)或者O(nlogn)，O(n)算法就必须使得查找为<code>O(1)</code>，这是比较难办到的。而对于<code>O(nlogn)</code>来说，是较容易，想优化到<code>logn</code>复杂度，那么不是二分就是归并了，这里我们重定义<code>dp</code>数组的意义，使得寻找遍历能够使用二分法。</p>
<p>由于题意只要求返回最大长度，因为我们只需一个<code>maxL</code>来记录当前遍历到<code>nums[i]</code>时的最大长度，<strong>我们用dp[]来有序记录当前的最长子序列数组</strong>，对于得到的<code>nums[i]</code>,器更新策略如下：</p>
<ul>
<li>对<code>nums[i]</code>先确定其插入位置，使用二分方法，初始<code>lo=0,hi=maxL</code>,</li>
<li>经过二分后确定插入位置为更新后的<code>lo</code>,另<code>dp[lo]=nums[i]</code></li>
<li>判断<code>lo==maxL?</code>,若是则说明当前的<code>nums[i]</code>在此时的递增子序列的末尾，则<code>++maxL</code></li>
</ul>
<p>时间复杂度为<code>O(nlogn)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> lo = <span class="number">0</span>, hi = maxL;</span><br><span class="line">            <span class="comment">//二分查找</span></span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[mid] &lt; num)</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[lo] = num;</span><br><span class="line">            <span class="keyword">if</span> (lo == maxL)</span><br><span class="line">                maxL++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="粉刷房子">粉刷房子</h4>
<p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>
<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个<code> n x 3</code> 的正整数矩阵<code>costs</code> 来表示的。</p>
<p>例如，<code>costs[0][0]</code> 表示第 0 号房子粉刷成红色的成本花费；<code>costs[1][2]</code> 表示第 1 号房子粉刷成绿色的花费，以此类推。</p>
<p>请计算出粉刷完所有房子最少的花费成本。</p>
<p><strong>解题思路：</strong></p>
<p>由于粉刷房子只有三种颜色可选择，却要求相邻房子不能相同，要求满足上面条件的最小花费，这是一个多中间值的dp问题，因此可以使用二维动态规划</p>
<p>使用动态规划：<code>dp[i][j]</code>，其中<code>i</code>为<code>[0:n-1]</code>表示第<code>i</code>栋方正，<code>j</code>为<code>[0:2]</code>表示颜色，<strong>0为红色，1为蓝色，2为绿色</strong>，<code>dp[i][j]</code>即表示满足相邻方正不同色情况下，到<code>[0:i]</code>栋房子的粉刷策略的最低消费,最后一个房子以<code>j</code>颜色结尾。所以：</p>
<ul>
<li>初始状态：<code>dp[0][0]=costs[0][0],dp[0][1]=costs[0][1],dp[0][2]=costs[0][2]</code></li>
<li>状态转移方程：<code>dp[i][0]=costs[i][0]+min(dp[i-1][1],dp[i-1][2]);``dp[i][1]=costs[i][1]+min(dp[i-1][0],dp[i-1][2]);``dp[i][2]=costs[i][2]+min(dp[i-1][1],dp[i-1][0])</code></li>
</ul>
<p>时间复杂度为O(n),空间复杂度为O(n)，由于只与上一个状态有关，因此空间复杂度可优化至O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=costs.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=costs[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]=costs[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">2</span>]=costs[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=costs[i][<span class="number">0</span>]+<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=costs[i][<span class="number">1</span>]+<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=costs[i][<span class="number">2</span>]+<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],<span class="built_in">min</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>],dp[n<span class="number">-1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间dp">1.2 区间DP</h3>
<h4 id="最长回文子串">最长回文子串</h4>
<p><strong>问题：</strong>给你一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]:表示s[i]是否等于s[j],相等且回文则置为true，否则为false</span></span><br><span class="line">    <span class="comment">//初始条件：dp[i][i]=true;</span></span><br><span class="line">    <span class="comment">//状态转移方程：</span></span><br><span class="line">	<span class="comment">//①若i和j是相邻的即i+1=j且s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//②若不相邻，则判断内侧是否为true，若dp[i+1][j-1]=true&amp;&amp;s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//通过增加两变量记录当前回文串的最长长度Maxlen,初始为1,以及记录回文串的下标开始index_min，初始为最后一个元素</span></span><br><span class="line">    <span class="comment">//算法的时间复杂度为O(n*n)</span></span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>||len==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(len,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> Maxlen=<span class="number">1</span>,index_min=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])<span class="comment">//如果两元素相等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i+<span class="number">1</span>)<span class="comment">//如果相邻</span></span><br><span class="line">                    dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//不相邻，判断两元素内部是否为回文串</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;Maxlen&lt;j-i+<span class="number">1</span>)<span class="comment">//更新Maxlen和index_min</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Maxlen=j-i+<span class="number">1</span>;</span><br><span class="line">                    index_min=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ret=s.<span class="built_in">substr</span>(index_min,Maxlen);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="最长回文子序列">最长回文子序列</h4>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*动态规划：dp[i][j]，其中0=&lt;i&lt;=j&lt;=n,dp[i][j]表示序列s在i~j范围内的最长回文子序列长度。</span></span><br><span class="line"><span class="comment">                    对于回文序列的问题，我们必须注意循环的顺序，首先i从大到小，j从小到大且满足j&gt;=i，直                  到得到dp[0][n-1]</span></span><br><span class="line"><span class="comment">            初始条件：①当i=j时，dp[i][j]=1</span></span><br><span class="line"><span class="comment">                     ②当i&gt;j时，dp[i][j]=0</span></span><br><span class="line"><span class="comment">            状态转移方程：①当s[i]=s[j且相邻即i+1=j,dp[i][j]=dp[i][j-1]+1</span></span><br><span class="line"><span class="comment">                         ②当s[i]=s[j]且不相邻,dp[i][j]=dp[i+1][j-1]+2</span></span><br><span class="line"><span class="comment">                         ③当s[i]!=s[j]且相邻，dp[i][j]=1</span></span><br><span class="line"><span class="comment">                         ④当s[i]!=s[j]，此时s[i]和s[j]不能同时作为回文子序列的首尾，则有</span></span><br><span class="line"><span class="comment">                         dp[i][j]=max(dp[i][j-1],dp[i+1][j])</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxLen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>==j)</span><br><span class="line">                        dp[i][j]=dp[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>==j)</span><br><span class="line">                        dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;maxLen)</span><br><span class="line">                    maxLen=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最长公共子序列">最长公共子序列</h4>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 <strong>公共子序列 </strong>的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：<strong>它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</strong></p>
<p>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但<code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code>的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<p><strong>解法一：</strong> 暴力解：以<code>text1</code>的<code>text1[i]</code>作为开头，得到以它开头的最长公共子序列，最后得到最长序列，时间复杂度为<code>O(nmm)</code></p>
<p><strong>解法二：</strong> 暴力解的时间复杂度较高，其原因是进行了一些不必要的比较，使用动态规划来优化。该题可以由子问题一步一步构建而来。</p>
<p>最长公共子序列是典型的二维dp例题，需要记住这个思想：</p>
<ul>
<li>给出<code>dp[i][j]</code>，其中行数为<code>1+text1.size()</code>,列数为<code>1+text2.size()</code></li>
<li>那么定义<code>dp[i][j]</code>其表示<code>text1[0:i-1]</code>和<code>text2[0:j-1]</code>的最长公共子序列，那么对于更新，则有</li>
<li>初始状态<code>dp[0][0:m]=0,dp[0:n][0]=0</code></li>
<li>状态转移方程：
<ul>
<li>当<code>text1[i-1]==text2[j-1]</code>，那么此时<code>dp[i][j]=1+dp[i-1][j-1]</code>(写对角线)</li>
<li>当<code>text1[i-1]!=text2[j-1]</code>，对于<code>dp[i][j]</code>的取值分析，我们需要考虑
<ul>
<li><code>text1[0:i-2]</code>和<code>text2[0:j-1]</code>的最长公共子序列（上）</li>
<li><code>text1[0:i-1]</code>和<code>text2[0:j-2]</code>的最长公共子序列（左）</li>
</ul></li>
<li>由于之前已经计算过两者，因此<code>dp[i][j]</code>取它们两者较大者即可，即<code>dp[i][j]=max(dp[i][j-1],dp[i-1][j])</code></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=text1.<span class="built_in">size</span>(),m=text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>该题与编辑距离有共同相似处。</strong></p>
</blockquote>
<h4 id="编辑距离">编辑距离</h4>
<blockquote>
<p>给你两个单词<code>word1</code>和<code>word2</code>， 请返回将 <code>word1</code>转换成<code>word2</code>所使用的最少操作数 。</p>
</blockquote>
<blockquote>
<p>你可以对一个单词进行如下三种操作：</p>
</blockquote>
<blockquote>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
</blockquote>
<h5 id="思路">思路</h5>
<p><strong>借鉴于官方题解，更加清晰得描述解题思路：</strong> 使用动态规划来解决，尝试使用由前一个子问题推导得到下一个子问题的答案，最终回到最终解。</p>
<p><strong>分析：</strong> 当我们直到word1的前<code>i-1</code>和<code>j-1</code>字符的最小编辑距离，如何利用它们得到前<code>i</code>和<code>j</code>字符的最小编辑记录。</p>
<p>假如用<code>A=horse</code>和<code>B=ros</code>作为例子，我们因为有三种操作，因此也就得比较三种操作得到最小值：</p>
<ul>
<li><p><strong>在单词 <code>A</code> 中插入一个字符</strong>：如果我们知道 <code>horse</code> 到 <code>ro</code>的编辑距离为<code>a</code>(即 <code>horse</code> 经过a步就能变为<code>ro</code>,<code>dp[i][j-1]</code>=a)，那么显然<code>horse</code> 到<code>ros</code>的编辑距离不会超过 <code>a + 1</code>。这是因为经过<code>dp[i][j-1]</code>后，在单词<code>A</code>的末尾添加字符<code>s</code>，就能在<code>a + 1</code>次操作后将 <code>horse</code> 和 <code>ros</code> 变为相同的字符串；</p></li>
<li><p><strong>在单词 A中删除一个字符</strong>：如果我们知道 <code>hors</code> 到<code>ros</code> 的编辑距离为<code>b</code>,即<code>dp[i-1][j]=b</code>，那么显然 <code>horse</code> 到 <code>ros</code> 的编辑距离不会超过 <code>b + 1</code>，原因是只需要多删除一个<code>e</code>即可；</p></li>
<li><p><strong>在A中替换一个单词</strong>，如果我们知道 <code>hors</code> 到<code>ro</code>的编辑距离为 <code>c</code>，那么显然 <code>horse</code> 到 <code>ros</code> 的编辑距离不会超过 <code>c + 1</code>，原因是因为<code>A</code>中加入了<code>e</code>，而B中加入了<code>s</code>，因此在<code>e</code>替换为<code>s</code>时，需要额外加1个操作上，如果相等，那么dp[i][j]=dp[i-1][j-1]</p></li>
</ul>
<p>因此基于上述分析： - 当<code>A[i]==B[i]</code>时，<code>dp[i][j]=min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1])</code> - 当<code>A[i]!=B[i]</code>时,<code>dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1</code></p>
<h4 id="步骤">步骤</h4>
<ul>
<li>定义<code>dp[i][j]</code>，表示<code>word1</code>的前i个字符与<code>word2</code>的前<code>j</code>个字符的最小编辑距离。</li>
<li>初始化<code>dp[0][i]=i</code>,<code>dp[i][0]=i</code>，当另一个字符串为空时，最小编辑距离当然时另一个字符串得长度</li>
<li>状态转移方程：
<ul>
<li>当<code>A[i]==B[i]</code>时，<code>dp[i][j]=min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1])</code></li>
<li>当<code>A[i]!=B[i]</code>时,<code>dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1</code></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=word1.<span class="built_in">size</span>(),m=word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n*m==<span class="number">0</span>) <span class="keyword">return</span> n&gt;<span class="number">0</span>?n:m;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//初始状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m+<span class="number">1</span>;++i)</span><br><span class="line">            dp[<span class="number">0</span>][i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m+<span class="number">1</span>;++j)&#123;</span><br><span class="line">                <span class="type">int</span> Aadd=dp[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> Adelete=dp[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> ASwitch=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]!=word2[j<span class="number">-1</span>]) ASwitch+=<span class="number">1</span>;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(Aadd,<span class="built_in">min</span>(Adelete,ASwitch));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="背包dp">1.3 背包DP</h3>
<h3 id="状压dp">1.4 状压DP</h3>
<h3 id="剑指offer62-圆圈中最后剩余的数字">1.5 剑指offer62 圆圈中最后剩余的数字</h3>
<p><strong>1、约瑟夫问题：</strong> 这个问题实际上是<strong>约瑟夫问题</strong>，这个问题描述是 &gt;N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。</p>
<p><strong>2、问题转化</strong> 既然约塞夫问题就是用人来举例的，那我们也给每个人一个编号（索引值），每个人用字母代替</p>
<p>下面这个例子是<code>N=8 m=3</code>的例子</p>
<p>我们定义<code>F(n,m)</code>表示最后剩下那个人的索引号，因此我们只关系最后剩下来这个人的索引号的变化情况即可 <img src="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/offer69.png" width="700"> 从8个人开始，每次杀掉一个人，去掉被杀的人，然后把杀掉那个人之后的第一个人作为开头重新编号</p>
<ul>
<li>第一次C被杀掉，人数变成7，D作为开头，（最终活下来的G的编号从6变成3）</li>
<li>第二次F被杀掉，人数变成6，G作为开头，（最终活下来的G的编号从3变成0）</li>
<li>第三次A被杀掉，人数变成5，B作为开头，（最终活下来的G的编号从0变成3）</li>
<li>以此类推，当只剩一个人时，他的编号必定为0！（重点！）</li>
</ul>
<p><strong>3、反推（动态规划的思想）</strong> 现在我们知道了G的索引号的变化过程，那么我们反推一下 从<code>N = 7</code> 到<code>N = 8</code> 的过程</p>
<p>如何才能将<code>N = 7</code> 的排列变回到<code>N = 8</code> 呢？</p>
<p>我们先把被杀掉的<code>C</code>补充回来，然后右移<code>m</code>个人，发现溢出了，再把溢出的补充在最前面</p>
<p>神奇了 经过这个操作就恢复了<code>N = 8</code>的排列了！ <img src="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/69.png" width="700"> 因此我们可以推出递推公式<span class="math inline">\(f(8,3) = [f(7, 3) + 3] % 8\)</span> 进行推广泛化，即$ f(n,m) = [f(n-1, m) + m] % n$ <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">2</span>);i&lt;=n;++i)</span><br><span class="line">            ans=(ans+m)%i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/">该题题解来自leetcode的爱吃火锅的木易</a></p>
<h2 id="树类">2. 树类</h2>
<blockquote>
<p>引用leetcode上<a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">星晴大佬的笔记</a></p>
</blockquote>
<ul>
<li>引言：</li>
</ul>
<p>力扣上很多树的题目都是可以用递归很快地解决的，而这一系列递归解法中蕴含了一种很强大的递归思维：对称性递归(symmetric recursion) 什么是对称性递归？就是对一个对称的数据结构（这里指二叉树）从整体的对称性思考，把大问题分解成子问题进行递归，即不是单独考虑一部分(比如树的左子树)，<strong>而是同时考虑对称的两部分(左右子树)，从而写出对称性的递归代码</strong></p>
<ul>
<li><p>题型分类： 可以用对称性递归解决的二叉树问题大多是判断性问题(bool类型函数),这一类问题又可以分为以下两类：</p>
<ul>
<li>1、不需要构造辅助函数。这一类题目有两种情况：
<ul>
<li>第一种是单树问题，且不需要用到子树的某一部分(比如根节点左子树的右子树)，只要利用根节点左右子树的对称性即可进行递归。</li>
<li>第二种是双树问题，即本身题目要求比较两棵树，那么不需要构造新函数。该类型题目如下： <a href="https://leetcode.cn/problems/same-tree/">100.相同的树</a> <a href="https://leetcode.cn/problems/invert-binary-tree/">226.翻转二叉树</a> <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度</a> <a href="https://leetcode.cn/problems/balanced-binary-tree/">110.平衡二叉树</a> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543.二叉树的直径</a> <a href="https://leetcode.cn/problems/merge-two-binary-trees/">617.合并二叉树</a> <a href="https://leetcode.cn/problems/subtree-of-another-tree/">572.另一个树的子树</a> <a href="https://leetcode.cn/problems/univalued-binary-tree/">965.单值二叉树</a></li>
</ul></li>
<li>2、需要构造辅助函数。这类题目通常只用根节点子树对称性无法完全解决问题，必须要用到子树的某一部分进行递归，即要调用辅助函数比较两个部分子树。形式上主函数参数列表只有一个根节点，辅助函数参数列表有两个节点。该类型题目如下： <a href="https://leetcode.cn/problems/symmetric-tree/">101.对称二叉树</a> <a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指offer26.s树的子结构</a></li>
</ul></li>
<li>解题模板 下面给出二叉树对称性递归的解题模板
<ul>
<li><p>1、递归结束条件：特殊情况的判断 如果是单树问题，一般来说只要进行以下判断： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>/递归函数;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>/递归函数;。</span><br></pre></td></tr></table></figure> 如果是双树问题(根节点分别为p,q)，一般来说进行以下判断： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p &amp;&amp; !q)<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!p || !q)<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br></pre></td></tr></table></figure> 当然也不完全是这些情况，比如有的需要加上节点值的判断，需要具体问题需要具体分析</p></li>
<li>2、返回值
<ul>
<li>通常对称性递归的返回值是多个条件的复合判断语句</li>
<li>可能是以下几种条件判断的组合：
<ul>
<li>节点非空的判断</li>
<li>节点值比较判断</li>
<li>(单树)调用根节点左右子树的递归函数进行递归判断</li>
<li>(双树)调用两棵树的左右子树的递归函数进行判断</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="二叉树">2.1 二叉树</h3>
<h4 id="i-从上到下打印二叉树层次遍历">2.1.1 I-从上到下打印二叉树（层次遍历）</h4>
<p>【剑指offer】从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//使用队列实现这种遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; myqueue;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            myqueue.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            myqueue.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!myqueue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp=myqueue.<span class="built_in">front</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            myqueue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">                myqueue.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">                myqueue.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> #### 2.1.2 III-从上到下打印二叉树(之字型) 【剑指offer】实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*通过两个栈存储来实现，一个是奇数层的队列，一个为偶数层栈</span></span><br><span class="line"><span class="comment">*不同的是入栈的方式不同：</span></span><br><span class="line"><span class="comment">*- 如果把第一层认为是奇数层，那么对于奇数栈来说，它从左向右遍历，则必须左子树先入栈</span></span><br><span class="line"><span class="comment">*- 对于偶数栈来说，从右往左遍历，则必须右子树先入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; evenS;</span><br><span class="line">        stack&lt;TreeNode*&gt; oddS;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        oddS.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!oddS.<span class="built_in">empty</span>()||!evenS.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur=<span class="literal">NULL</span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span>(!oddS.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cur=oddS.<span class="built_in">top</span>();</span><br><span class="line">                oddS.<span class="built_in">pop</span>();</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    evenS.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                    evenS.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!tmp.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!evenS.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cur=evenS.<span class="built_in">top</span>();</span><br><span class="line">                evenS.<span class="built_in">pop</span>();</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                    oddS.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    oddS.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="树的子结构">2.1.3 树的子结构</h4>
<p>【剑指offer】输入两棵二叉树<code>A</code>和<code>B</code>，判断<code>B</code>是不是<code>A</code>的子结构。(约定空树不是任意一个树的子结构)</p>
<p><code>B</code>是<code>A</code>的子结构， 即 <code>A</code>中有出现和<code>B</code>相同的结构和节点值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">给定的树 B：</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span> </span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">返回 <span class="literal">true</span>，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br></pre></td></tr></table></figure> <strong>题解：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对称性</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *两个树的结构相同，则根节点相同，左右子树的结构也要相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果任一子树为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(!A||!B)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如不为空，则可判断以根节点为根，以根节点的左子树为根，或者以根节点的右子树为根，</span></span><br><span class="line">        <span class="comment">//三者中只要满足一个与B相同，则可认为B是A的子结构</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasSameDfs</span>(A,B)||<span class="built_in">isSubStructure</span>(A-&gt;left,B)||<span class="built_in">isSubStructure</span>(A-&gt;right,B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasSameDfs</span><span class="params">(TreeNode*A,TreeNode*B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件1：B为NULL时，说明B可全部由A表示</span></span><br><span class="line">        <span class="keyword">if</span>(!B)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//条件2是：A为NULL，但B不为NULL，说明A不能完全表示B；或者值不相等</span></span><br><span class="line">        <span class="keyword">if</span>(!A||A-&gt;val!=B-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//上面都不满足，则说明当前A-&gt;val==B-&gt;val，继续比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasSameDfs</span>(A-&gt;left,B-&gt;left)&amp;&amp;<span class="built_in">hasSameDfs</span>(A-&gt;right,B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="树的镜像翻转二叉树">2.1.4 树的镜像(翻转二叉树)</h4>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *对称递归：在递归中交换左右子树,无需</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//交换左右子树</span></span><br><span class="line">        TreeNode* tmp=root-&gt;left;</span><br><span class="line">        root-&gt;left=root-&gt;right;</span><br><span class="line">        root-&gt;right=tmp;</span><br><span class="line">        <span class="comment">//对称递归</span></span><br><span class="line">        <span class="built_in">mirrorTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="重建二叉树">2.1.5 重建二叉树</h4>
<p>入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><strong>思路：</strong>自顶向下构造</p>
<ul>
<li>二叉树的中序遍历中根节点将数组分为左右子树,前序遍历的结果第一个元素总是当前分支的根，因此可构造一个辅助函数<code>TreeNode* build(preorder,inorder,preB,preE,inB,inE)</code></li>
<li><code>preB、preE</code>表示当前要构建根节点及其子树的所有节点的始末位置，<code>inB、inP</code>则表示中序遍历的</li>
<li>递归构造规律
<ul>
<li>用前序结果的第一个<code>preorder[preB]</code>构造根节点</li>
<li>在中序遍历中寻找该根节点位置Incur，此时知道中序遍历的<code>[inB,Incur-1](Incur-1&gt;=inB)</code>为左子树，对应于前序遍历的<code>[preB+1,PreB+Incur-inB](PreB+Incur-inB&gt;=preB+1)</code></li>
<li>同理中序遍历的<code>[Incur+1,inE]</code>为右子树，对应于前序遍历的<code>[preB+Incur-inB+1,preE]</code></li>
</ul></li>
<li>终止条件
<ul>
<li><code>if(preB&gt;preE) return NULL;</code></li>
</ul></li>
<li>优化
<ul>
<li>优化：在构造的第二步中每次都要寻找中序遍历的根节点，导致时间复杂度为<code>O(n*n)</code>，用<code>unorder_map</code>来存储，时间复杂度为<code>O(n)</code></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *二叉树的前序遍历和中序遍历，在中序遍历中根节点将数组分为左右子树,前序遍历的结果第一个元素总是当前分支的根</span></span><br><span class="line"><span class="comment"> *因此，可构造一个辅助函数TreeNode* build(preorder,inorder,preB,preE,inB,inE)</span></span><br><span class="line"><span class="comment"> *preB、preE表示当前要构建根节点及其子树的所有节点的始末位置，inB、inP则表示中序遍历的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *构造规律：</span></span><br><span class="line"><span class="comment"> - 用前序结果的第一个preorder[preB]构造根节点</span></span><br><span class="line"><span class="comment"> - 在中序遍历中寻找该根节点位置Incur，此时知道中序遍历的[inB,Incur-1](Incur-1&gt;=inB)为左子树，对应于前序遍历的[preB+1,PreB+Incur-inB](PreB+Incur-inB&gt;=preB+1)</span></span><br><span class="line"><span class="comment"> - 同理中序遍历的[Incur+1,inE]为右子树，对应于前序遍历的[preB+Incur-inB+1,preE]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *终止条件：</span></span><br><span class="line"><span class="comment"> *if(preB&gt;preE) return NULL;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *优化：在构造的第二步中每次都要寻找中序遍历的根节点，导致时间复杂度为O(n*n)，用unorder_map来存储，时间复杂度为O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;inorder.<span class="built_in">size</span>();++i)</span><br><span class="line">            hmap[inorder[i]]=i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(preorder,hmap,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; hmap,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> preB,<span class="type">int</span> preE,<span class="type">int</span> inB,<span class="type">int</span> inE)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preB&gt;preE)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preB]);</span><br><span class="line">        <span class="type">int</span> Incur=hmap[preorder[preB]];</span><br><span class="line">        <span class="comment">//构造左右子树</span></span><br><span class="line">        root-&gt;left=<span class="built_in">build</span>(preorder,hmap,preB+<span class="number">1</span>,preB+Incur-inB,inB,Incur<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">build</span>(preorder,hmap,preB+Incur-inB+<span class="number">1</span>,preE,Incur+<span class="number">1</span>,inE);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="序列化二叉树">2.1.6 序列化二叉树</h4>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>思路：</p>
<ul>
<li>上面的重建二叉树利用了前序遍历和中序遍历的分布性质，但前提是数中不存在相同的值，此题并未说明值保证不同，因此无法使用前序和中序的性质。</li>
<li>可考虑层序遍历来构造，<strong>在序列化中构造含空的层序遍历结果，然后用该层序遍历能够还原出二叉树</strong></li>
<li>在下方程序中最聪明的就是用<code>ostringstream\istringstream</code>来记录层序结果，然后构造节点数组，最关键的是<code>index</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//unordered_map&lt;char,int&gt;myMap;</span></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用层序遍历，空节点用&#x27;#&#x27;表示</span></span><br><span class="line">        <span class="comment">//考虑到ostringstream能够以&quot; &quot;自动分割，可采用ostringstream对像来存储</span></span><br><span class="line">        ostringstream output;</span><br><span class="line">        queue&lt;TreeNode*&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            root=Q.<span class="built_in">front</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                output&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">                Q.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                output&lt;&lt;<span class="string">&quot;# &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过带有null的层序遍历来构造二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        vector&lt;TreeNode*&gt; vec;</span><br><span class="line">        <span class="function">istringstream <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">while</span>(input&gt;&gt;s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="string">&quot;#&quot;</span>)</span><br><span class="line">                vec.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                vec.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(s)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;vec.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i]==<span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            vec[i]-&gt;left=vec[++index];</span><br><span class="line">            vec[i]-&gt;right=vec[++index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树">2.2 二叉搜索树</h3>
<p>二叉搜索树具有左子树比根节点小，右子树比根节点大的特点。</p>
<h4 id="不同的二叉搜索树">2.2.1 不同的二叉搜索树</h4>
<p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
<ul>
<li><p>解法一：递归+记忆 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/下面这个方法更上面的递归是一样的，只不过优化了重复计算</span><br><span class="line"><span class="comment">//发现存在许多的重复计算，用unordered_map来存储n与子树数量的计算过的结果，后续可以直接用</span></span><br><span class="line">*/</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果存在已经计算的结果，直接使用</span></span><br><span class="line">        <span class="keyword">if</span>(result.<span class="built_in">find</span>(n)!=result.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> result[n];</span><br><span class="line">        <span class="type">long</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//还是使用递归，当以i为根节点时，计算其左右子树各有多少种类，此时m*n即可得到以i为根时的种类</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//以i为根时的总数</span></span><br><span class="line">            <span class="comment">//左子树有多少种</span></span><br><span class="line">            <span class="type">long</span> leftnums=<span class="built_in">numTrees</span>(i<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//右子树有多少种</span></span><br><span class="line">            <span class="type">long</span> rightnums=<span class="built_in">numTrees</span>(n-i);</span><br><span class="line">            <span class="comment">//相乘就是以节点i为根的种类数</span></span><br><span class="line">            count+=leftnums*rightnums;</span><br><span class="line">        &#125;</span><br><span class="line">        result[n]=count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>解法二：动态规划</p></li>
</ul>
<h4 id="二叉搜索树的最近公共祖先节点">2.2.2 二叉搜索树的最近公共祖先节点</h4>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  <code>root = [6,2,8,0,4,7,9,null,null,3,5]</code>，寻找2、4的最近祖先，那么2就是最近的公共祖先</p>
<p><strong>思路：</strong>自顶向下的搜索（循环和递归均可）</p>
<ul>
<li>树为二叉搜索树，那么又左子树小于根节点，右子树大于根节点的规则，可有这样几种情况</li>
<li><code>p-&gt;val&gt;root-&gt;val&amp;&amp;q-&gt;val&gt;root-&gt;val</code>，说明<code>p、q</code>都位于右子树，此时最近的公共祖先必不是<code>root</code>,向右前进</li>
<li><code>p-&gt;val&lt;root-&gt;cal&amp;&amp;q-&gt;val&lt;root-&gt;val</code>，说明<code>p、q</code>都位于左子树，此时最近的公共祖先必不是<code>root</code>,向左前进</li>
<li>若有任一<code>p</code>或<code>q</code>的<code>val</code>值等于<code>root-&gt;val</code>，那么<code>root</code>必然是最近祖先节点</li>
<li>当<code>p\q</code>分别位于<code>root</code>的左右子树时，<code>root</code>为最近的祖先节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//优化，减少在循环当中的条件判断，保证p-&gt;val&gt;q-&gt;val</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val&lt;q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=tmp;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val&gt;root-&gt;val)</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val&lt;root-&gt;val)</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的最近公共祖先">2.2.3 二叉树的最近公共祖先</h4>
<p>这是<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/?envType=study-plan&amp;id=lcof&amp;plan=lcof&amp;plan_progress=xxf1bgos">二叉搜索树的最近公共祖先</a>的升级版本。不具有二叉搜索树的大小性质。</p>
<p>题目：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>思路：<strong>因为节点一定在树上且唯一，那么在不同分支找到的节点一定是不同的即分别是p、q</strong></p>
<ul>
<li>情况总结，若<code>root</code>是它们的最近公共祖先，那么有以下3种情况：
<ul>
<li><code>p、q</code>分别位于<code>root</code>的左右子树 (2)</li>
<li><code>p==root</code>，<code>q</code>位于<code>root</code>的左子树或者右子树(3)</li>
<li><code>q==root</code>，<code>p</code>位于<code>root</code>的左子树或者右子树(4)</li>
</ul></li>
<li>退出条件：<code>root==NULL,return NULL;root==p,return root;root==q,return root</code> (1)</li>
<li>递归规则：用<code>isleft</code>记录<code>root</code>左子树的遍历结果；<code>isright</code>记录<code>root</code>右子树的遍历结果，因此采用的是自底向上的回溯，因此返回的一定是最近的祖先节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>||root==p||root==q)	<span class="comment">//(1)</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* isleft=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* isright=<span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(isleft&amp;&amp;isright)		<span class="comment">//(2)</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(isleft)		<span class="comment">//(3)</span></span><br><span class="line">            <span class="keyword">return</span> isleft;</span><br><span class="line">        <span class="keyword">else</span>			<span class="comment">//(4)</span></span><br><span class="line">            <span class="keyword">return</span> isright;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树的后续遍历">2.2.4 二叉搜索树的后续遍历</h4>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p><strong>思路：</strong>后序遍历的结果由[左|右|根]的特点，由根节点一知，很容易构造根节点，关键点是如何确定左右分界处。二叉搜索树中，左子树均小于根节点，右子树均大于根节点，因此可通过遍历比较来确定其左右子树的分界线 <strong>解法1：</strong> 算法步骤：</p>
<ul>
<li>构造一辅助函数<code>verify(postorder,int b,int e)</code>，<code>b、e</code>分别表示当前树的后序遍历范围</li>
<li>通过由前往后的遍历确定左右子树分界点，当<code>postorder[i]&gt;postorder[e]</code>时，即可确定[b,i-1]为左子树节点，<code>[i,e-1]</code>为右子树节点</li>
<li>继续遍历<code>[i,e-1]</code>范围，确定在该范围不存在小于<code>postorder[e]</code>的元素，则进入下一个递归</li>
<li>递归退出条件：<code>b&gt;=e，return true;</code></li>
<li>上述算法时间复杂度为<span class="math inline">\(O(n^2)\)</span>，空间复杂度为<span class="math inline">\(O(n)\)</span>，原因是，每一次递归为确定分界处，需要遍历数组， <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder,<span class="type">int</span> b,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&gt;=e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>,i=b;</span><br><span class="line">        <span class="keyword">while</span>(postorder[i]&lt;postorder[e])</span><br><span class="line">            ++i;</span><br><span class="line">        index=i;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;e&amp;&amp;postorder[i]&gt;postorder[e])</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">return</span> i==e&amp;&amp;<span class="built_in">verify</span>(postorder,b,index<span class="number">-1</span>)&amp;&amp;<span class="built_in">verify</span>(postorder,index,e<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">verify</span>(postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>解法二：</strong></p>
<ul>
<li>我们发现是可以通过记录根节点的大小即当前节点的上下界将比较推迟到当前递归，这样就避免了数组的遍历使得时间复杂度为<span class="math inline">\(O(n)\)</span>。</li>
<li><code>左子树&lt;根节点</code>，<code>右子树&gt;根节点</code>，那么引入辅助函数<code>vrify(postorder,ma,mi)</code>，其中<code>ma</code>为上界，<code>mi</code>为下限。刚开设设为<code>INT_MAX</code>和<code>-INT_MIN</code></li>
<li>取最后一个元素val，比较其值时候在该范围内，不在直接返回<code>false</code></li>
<li>若在，则删除最后一个元素，进入下一轮递归</li>
<li>必须先对右子树递归，并更新其下限在<code>val</code>;然后在左子树递归中，更新其上界在<code>val</code></li>
<li>当数组为空时，说明符合搜索时的后序遍历，返回<code>true</code>；否则返回<code>false</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">verify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder,<span class="type">int</span> MA,<span class="type">int</span> MI)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> postorder.<span class="built_in">empty</span>();</span><br><span class="line">        <span class="type">int</span> curr=postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(curr&lt;=MI||curr&gt;=MA)</span><br><span class="line">            <span class="keyword">return</span> postorder.<span class="built_in">empty</span>();</span><br><span class="line">        postorder.<span class="built_in">erase</span>(postorder.<span class="built_in">end</span>()<span class="number">-1</span>,postorder.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">verify</span>(postorder,MA,curr);</span><br><span class="line">        <span class="built_in">verify</span>(postorder,curr,MI);</span><br><span class="line">        <span class="keyword">return</span> postorder.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">verify</span>(postorder,INT_MAX,-INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="平衡二叉树">2.3 平衡二叉树</h3>
<p>平衡二叉树又称为AVL树，它的设计是为了防止在二叉搜索树中退化成链表的一种数据结果，特点：</p>
<ul>
<li>规定左右子树的的深度差不能超过1，即平衡因子<code>|bf|&lt;=1</code></li>
<li>左子树值小于根节点，右子树大于</li>
</ul>
<h4 id="平衡二叉树判断">2.3.1 平衡二叉树判断</h4>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line"> *解法<span class="number">1</span>：自顶向上(暴力解)，得到每个节点左右深度，当&gt;<span class="number">1</span>时返回<span class="number">-1</span>，由于存在大量的重复计算</span><br><span class="line"> *时间复杂度为<span class="built_in">O</span>(n*n)</span><br><span class="line"> *</span><br><span class="line"> *解法<span class="number">2</span>：自低向上，规避了重复计算，时间复杂度为<span class="built_in">O</span>(n)</span><br><span class="line"> *借辅助函数<span class="built_in">height</span>(root)计算节点的深度，返回两种情况</span><br><span class="line"> 返回值：</span><br><span class="line"> - 当节点root 左 / 右子树的深度差 ≤<span class="number">1</span> ：则返回当前子树的深度，即节点 root 的左 / 右子树的深度最大值 +<span class="number">1</span> </span><br><span class="line"> （  <span class="built_in">max</span>(left, right) + <span class="number">1</span> ）；</span><br><span class="line"> - 当节点root 左 / 右子树的深度差 &gt;<span class="number">2</span> ：则返回 −<span class="number">1</span> ，代表 此子树不是平衡树 。</span><br><span class="line">   终止条件</span><br><span class="line">root=<span class="literal">NULL</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">leftheight==<span class="number">-1</span>||rightheight==<span class="number">-1</span>||<span class="built_in">abs</span>(leftheight,rightheight)&gt;<span class="number">1</span> <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> <span class="built_in">isBalanced</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root)&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftheight=<span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightheight=<span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftheight==<span class="number">-1</span>||rightheight==<span class="number">-1</span>||<span class="built_in">abs</span>(leftheight-rightheight)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(leftheight,rightheight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="链表类">3. 链表类</h2>
<h3 id="两数相加">3.1 两数相加</h3>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head=l1;</span><br><span class="line">        <span class="type">int</span> jingwei=<span class="number">0</span>;</span><br><span class="line">        ListNode* prio;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val=l1-&gt;val+l2-&gt;val+jingwei;</span><br><span class="line">            prio=l1;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1&amp;&amp;!l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val+=jingwei;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1&amp;&amp;l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prio=l1;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                    l1-&gt;val+=jingwei;</span><br><span class="line">                    jingwei=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            prio-&gt;next=l2;</span><br><span class="line">            l1=l2;</span><br><span class="line">            l1-&gt;val+=jingwei;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1&amp;&amp;l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prio=l1;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                    l1-&gt;val+=jingwei;</span><br><span class="line">                    jingwei=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jingwei)</span><br><span class="line">            &#123;</span><br><span class="line">                prio-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(jingwei,<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除链表倒数第n个节点">3.2 删除链表倒数第N个节点</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        ListNode* tmp=head;</span><br><span class="line">        <span class="keyword">while</span>(tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=head;</span><br><span class="line">		<span class="comment">//删除头节点单独考虑</span></span><br><span class="line">        <span class="keyword">if</span>(len-n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> tmp-&gt;next;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len-n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next=tmp-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="合并k个有序链表">3.3 合并K个有序链表</h3>
<p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用分治的思想，分别两两合并</span></span><br><span class="line">        <span class="comment">//使用递归实现：</span></span><br><span class="line">        <span class="comment">//递归退出条件为：一是传入的只有一个链表另一个为NUL，二是传入的均为NULL，直接返回</span></span><br><span class="line">        <span class="comment">//程序结构：mergeKList为主调用，不做其他功能，merge递归入口，当达到底层是使用mergeTwoList   </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>()<span class="number">-1</span>);     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoList</span><span class="params">(ListNode* a,ListNode* b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==a||<span class="literal">NULL</span>==b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>==a?b:a;</span><br><span class="line">        ListNode* head=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;val&gt;b-&gt;val)&#123;</span><br><span class="line">            head=b;</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head=a;</span><br><span class="line">            a=a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tempNode=head;</span><br><span class="line">        <span class="keyword">while</span>(a&amp;&amp;b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;val&gt;b-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                tempNode-&gt;next=b;</span><br><span class="line">                b=b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tempNode-&gt;next=a;</span><br><span class="line">                a=a-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tempNode=tempNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a)</span><br><span class="line">            tempNode-&gt;next=a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempNode-&gt;next=b;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=(r+l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(r==l)</span><br><span class="line">            <span class="keyword">return</span> lists[r];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r&lt;l)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">mergeTwoList</span>(<span class="built_in">merge</span>(lists,l,m),<span class="built_in">merge</span>(lists,m+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="两两交换链表中的节点">3.4 两两交换链表中的节点</h3>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用双指针，前一指针比后一指针快一步，然后交换指向即可</span></span><br><span class="line">        <span class="comment">//为方便，在链表头部添加一节点pHead</span></span><br><span class="line">        ListNode* front=<span class="literal">NULL</span>,*back=<span class="literal">NULL</span>,*pHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        pHead-&gt;next=head;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        back=head;</span><br><span class="line">        front=head-&gt;next;</span><br><span class="line">        ListNode* ret=pHead;</span><br><span class="line">        <span class="keyword">while</span>(front!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            back-&gt;next=front-&gt;next;</span><br><span class="line">            front-&gt;next=back;</span><br><span class="line">            pHead-&gt;next=front;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            pHead=back;</span><br><span class="line">            <span class="keyword">if</span>(back-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                back=back-&gt;next;</span><br><span class="line">                front=back-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                front=<span class="literal">NULL</span>;</span><br><span class="line">                back=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="k个一组翻转链表">3.5 K个一组翻转链表</h3>
<p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针：前一个指针front比后一个指针快K-1</span></span><br><span class="line">        <span class="comment">//为方便，增加辅助头指针pHead</span></span><br><span class="line">        ListNode* front=<span class="literal">NULL</span>,*back=<span class="literal">NULL</span>,*pHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(),*ret=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        pHead-&gt;next=head;</span><br><span class="line">        front=back=head;</span><br><span class="line">        ret=pHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k&amp;&amp;front!=<span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">            front=front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(front!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;   <span class="comment">//记录下一组节点</span></span><br><span class="line">            ListNode* tmp_back=front-&gt;next;</span><br><span class="line">            ListNode* tmp_front=tmp_back;</span><br><span class="line">            <span class="comment">//pHead记录</span></span><br><span class="line">            pHead-&gt;next=front;</span><br><span class="line">            pHead=back;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">                <span class="comment">//记录下一个翻转节点</span></span><br><span class="line">                ListNode* tmp=back-&gt;next;</span><br><span class="line">                <span class="comment">//翻转</span></span><br><span class="line">                back-&gt;next=front-&gt;next;</span><br><span class="line">                front-&gt;next=back;</span><br><span class="line">                <span class="comment">//更新</span></span><br><span class="line">                back=tmp;</span><br><span class="line">                <span class="comment">//下一组更新</span></span><br><span class="line">                <span class="keyword">if</span>(tmp_front)</span><br><span class="line">                    tmp_front=tmp_front-&gt;next;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            back=tmp_back;</span><br><span class="line">            front=tmp_front;         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="环形链表ii">3.6 环形链表II</h3>
<p>给定一个链表的头节点<code>head</code>，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p><strong>分析：</strong> 假设链表有环，分为两部分<code>a</code>和<code>b</code>,<code>a</code>为无环长度，<code>b</code>为有环长度，使用快慢指针<code>fast、slow</code>进行遍历，快指针步长为<code>2</code>，慢指针步长为<code>1</code> - 那么当有环时，快慢指针必定会相遇，另快指针走过节点为<code>f</code>,慢指针为<code>s</code>，则第一次相遇后有<code>f=2s</code>，<code>f=s+nb</code>, - 所以<code>f=2nb</code>，此时另<code>slow</code>从头节点重写走，<code>fast</code>从<code>f</code>处变成慢指针走，当他们走<code>a</code>步时再次相遇，此时就是环的入口节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast=head,*slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow=head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字符串类">4. 字符串类</h2>
<p>字符串也是数组类型，因此与数组一样，类型繁多。</p>
<h3 id="n字形变换">4.1 N字形变换</h3>
<p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。如输入字符串为 <code>PAYPALISHIRING</code> 行数为 4 时，排列如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;PAYPALISHIRING&quot;</span>, numRows = <span class="number">4</span></span><br><span class="line">输出：<span class="string">&quot;PINALSIGYAHRPI&quot;</span></span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于numRows有这样的一个规律：</span></span><br><span class="line"><span class="comment">//按规定第一列取s的前numRows个字符，即i=0.....numRows</span></span><br><span class="line"><span class="comment">//对于i行后面的列每隔(numRows-1)*2+i取一个，直到(numrow-1)*2*j&gt;s.size()为止,j&gt;=1</span></span><br><span class="line"><span class="comment">//同时对于第i行，在取s[(numRow-1)*2*j+i]时，</span></span><br><span class="line"><span class="comment">//前面应该还有当(numRows-1)*2*j+i-2i!=(numRows-1)*2*(j-1)+i时添加一个字符为s[(numsRow-1)*2*j+i-2i]</span></span><br><span class="line"><span class="comment">//或者只需排除第一行和最后一行即可</span></span><br><span class="line"><span class="comment">//时间复杂度为O(N)，空间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="built_in">convert</span>(string s, <span class="type">int</span> numRows) &#123;</span><br><span class="line">        string ret=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numRows&amp;&amp;i&lt;s.<span class="built_in">size</span>();i++)  <span class="comment">//第i行存储</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret+=s[i];</span><br><span class="line">            <span class="type">int</span> gapDistance=(numRows<span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;gapDistance*j-i&lt;s.<span class="built_in">size</span>();j++)<span class="comment">//寻找下一个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows<span class="number">-1</span>)             <span class="comment">//判断是不是第一行或者最后一行,不是则进入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret+=s[gapDistance*j-i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(gapDistance*j+i&lt;s.<span class="built_in">size</span>())</span><br><span class="line">                    ret+=s[gapDistance*j+i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="字符串最大公因子">4.2 字符串最大公因子</h3>
<blockquote>
<p>对于字符串<code>s</code> 和<code>t</code>，只有在<code>s = t + ... + t（</code>t 自身连接 1 次或多次）时，我们才认定 “t 能除尽 s”。 给定两个字符串 <code>str1</code> 和 <code>str2</code> 。返回 最长字符串<code>x</code>，要求满足<code>x</code> 能除尽 <code>str1</code> 且<code>x</code>能除尽<code>str2</code></p>
</blockquote>
<p><strong>思路：</strong> 给定了<code>str1</code>和<code>str2</code>,设其长度为<code>n</code>和<code>m</code>，这道题需要记住的两个性质</p>
<ul>
<li><p>如果存在一个符合要求的字符串<code>X</code>，那么也一定存在一个符合要求的字符串 <code>X'</code>，它的长度为 <code>str1</code> 和 <code>str2</code> 长度的最大公约数。</p></li>
<li><p>如果 <code>str1</code> 和 <code>str2</code> 拼接后等于 <code>str2</code>和 <code>str1</code> 拼接起来的字符串（注意拼接顺序不同），那么一定存在符合条件的字符串 X，<code>str1</code> 和 <code>str2</code> 由X拼接而成</p></li>
</ul>
<p>有了该性质以及方法二的性质，我们就可以先判<code>str1</code> 和 <code>str2</code>拼接后是否等于 <code>str2</code> 和<code>str1</code> 拼接起来的字符串，如果等于直接输出长度为 <code>gcd(len1,len2)</code>的前缀串即可，否则返回空串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">gcdOfStrings</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1+str2!=str2+str1) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">substr</span>(<span class="number">0</span>,__gcd(str1.<span class="built_in">size</span>(),str2.<span class="built_in">size</span>()));<span class="comment">//__gcd()是C++11自带的求最大公约数函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最长回文子串manacher算法解决">4.3 最长回文子串（Manacher算法解决）</h3>
<blockquote>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
</blockquote>
<blockquote>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
</blockquote>
<p>思路：使用<a href="https://trluper.cn/2023/08/11/Manacher%E7%AE%97%E6%B3%95/">Manacher算法</a>以<span class="math inline">\(O(N)\)</span>时间复杂度解决 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">	string str=<span class="string">&quot;@&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">		str+=<span class="string">&quot;#&quot;</span>+s.<span class="built_in">substr</span>(i,<span class="number">1</span>);</span><br><span class="line">	str+=<span class="string">&quot;#%&quot;</span>;</span><br><span class="line">	n=str.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> r=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//构造L</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;r) L[i]=<span class="built_in">min</span>(L[(k*<span class="number">2</span>)-i],r-i);</span><br><span class="line">		<span class="keyword">else</span> L[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//执行暴力匹配</span></span><br><span class="line">		<span class="keyword">while</span>(str[i-L[i]<span class="number">-1</span>]==str[i+L[i]+<span class="number">1</span>]) ++L[i];</span><br><span class="line">		<span class="comment">//更新k,r</span></span><br><span class="line">		<span class="type">int</span> R=L[i]+i;</span><br><span class="line">		<span class="keyword">if</span>(R&gt;r)&#123;</span><br><span class="line">			r=R,k=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//找最长回文串</span></span><br><span class="line">	<span class="type">int</span> Max=<span class="number">0</span>,idx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(L[i]&gt;Max)&#123;</span><br><span class="line">			Max=L[i];</span><br><span class="line">			idx=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> start=(idx-Max)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">substr</span>(start,Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong><em>Manacher算法解决回文串一类题目，KMP算法解决字符串匹配一类题目，注意，要明白L数组和next数组的含义</em></strong></p>
</blockquote>
<h3 id="重复的子字符串">4.4 重复的子字符串</h3>
<blockquote>
<p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成</p>
</blockquote>
<p><strong>分析</strong>：果长度为n的字符串<code>s</code>是字符串 <code>t=s+s</code>的子串，并且<code>s</code>在<code>t</code>中的起始位置不为<code>0 或 n，那么可证明</code>s<code>由子串</code>s'`构成。那么这样就可以利用<a href="https://trluper.cn/2023/08/06/KMP%E7%AE%97%E6%B3%95/">KMP算法</a>来解答此题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">KMP</span><span class="params">(string txt,string pat)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n=txt.<span class="built_in">size</span>(),m=pat.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">next</span>(m,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,now=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now&gt;<span class="number">0</span>&amp;&amp;pat[i]!=pat[now])&#123;</span><br><span class="line">                now=next[now<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pat[i]==pat[now]) ++now;</span><br><span class="line">            next[i]=now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> startIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//控制首尾不参与，因此i=1,i&lt;n-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;txt[i]!=pat[j]) j=next[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(txt[i]==pat[j])&#123;</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">if</span>(j==m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">KMP</span>(s+s,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最小覆盖子串">4.5 最小覆盖子串</h3>
<blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</p>
</blockquote>
<p><strong>思路：</strong> 可尝试使用滑动窗口思路解决，先用哈希<code>Hash</code>记录<code>t</code>的字母出现次数，之后对<code>s</code>进行滑动窗口排查</p>
<ul>
<li><code>l,r</code>表示窗口的左右边界，该问题现在转化为求最满足题意得最小窗口</li>
<li>当<code>t</code>出现在窗口内，<code>++l</code></li>
<li>当<code>t</code>不在窗口内，<code>++r</code></li>
</ul>
<p>对于<code>t</code>是否出现在窗口，必须使用一个数据结构来记录当前窗口出现字母,在<code>right</code>右移的时候能够判断该字符是否是t当中的字符，并且判断加入这个字符后当前窗口是否满足<code>t</code>，满足则进入<code>left</code>右移；对于<code>left</code>右移，能够判断当前窗口移除该字符后，是否破坏满足条件，若破坏了就必须能够知道破坏后的窗口缺了多少个什么字符才能再次满足·</p>
<ul>
<li>使用哈希<code>need</code>记录<code>t</code>中各字符出现的次数。</li>
<li>使用<code>count</code>来指示当前窗口还有多少各字符为满足。<code>count==0</code>时说明满足</li>
<li>再使用一个哈希来<code>windows</code>来记录窗口中出现<code>t</code>中字符的数量，当<code>windows</code>于<code>need</code>一一对应时，则认为当前窗口满足了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希need记录所需字符及数量,windows记录当前窗口</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; windows;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span> c:t)</span><br><span class="line">            ++need[c];</span><br><span class="line">        <span class="type">int</span> startIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,minLen=INT_MAX,count=t.<span class="built_in">size</span>(),n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            <span class="type">char</span> c=s[right];</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(c)!=need.<span class="built_in">end</span>()&amp;&amp;need[c]&gt;(windows[c]++)) --count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//先记录这个满足串</span></span><br><span class="line">                <span class="type">int</span> len=right-left+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(minLen&gt;len)&#123;</span><br><span class="line">                    startIndex=left;</span><br><span class="line">                    minLen=len;</span><br><span class="line">                &#125;</span><br><span class="line">                c=s[left];</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(c)!=need.<span class="built_in">end</span>()&amp;&amp;need[c]&gt;=(windows[c]--)) ++count;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minLen&lt;INT_MAX) <span class="keyword">return</span> s.<span class="built_in">substr</span>(startIndex,minLen);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="双指针类">5. 双指针类</h2>
<h3 id="无重复字符的最长子串">5.1 无重复字符的最长子串</h3>
<p><strong>问题：</strong>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<blockquote>
<p>示例： 输入: s = &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用滑动窗口的思路，即双指针的应用，左指针first表示以该元素为起始点</span></span><br><span class="line">   <span class="comment">//右指针last表示[first,last)是以s[first]开头最长无重复子串，以first为起始</span></span><br><span class="line">   <span class="comment">//不断向右移动右指针，直到遇到重复的为止</span></span><br><span class="line">   <span class="comment">//用unordered_set记录来判断是否有重复元素</span></span><br><span class="line">   <span class="comment">//虽然是双循环，但是内部右指针不重置，移动次数为常数，因此时间复杂度为O(N)</span></span><br><span class="line">   <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">0</span>==len||<span class="number">1</span>==len)</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    <span class="type">int</span> last=<span class="number">0</span>,maxLen=<span class="number">1</span>;</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; hSet;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;len;first++)  <span class="comment">//左指针向前</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不是第一次进入循环，说明当前元素s[last]与hSet存在重复，不断去除前一个</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>!=first)</span><br><span class="line">            hSet.<span class="built_in">erase</span>(s[first<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//不断右移右指针，直到遇到重复的</span></span><br><span class="line">        <span class="keyword">while</span>(last&lt;len&amp;&amp;!hSet.<span class="built_in">count</span>(s[last]))</span><br><span class="line">        &#123;</span><br><span class="line">            hSet.<span class="built_in">insert</span>(s[last]);</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen=<span class="built_in">max</span>(maxLen,last-first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="盛最多水的容器">5.2 盛最多水的容器</h4>
<p><strong>问题</strong>：给定一个长度为<code>n</code>的整数数组<code>height</code>。有<code>n</code>条垂线，第<code>i</code>条线的两个端点是<code>(i, 0)</code>和<code>(i, height[i])</code>。找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//双指针，一头指向头，一个指向尾</span></span><br><span class="line">    <span class="comment">//原理不用多说，看代码即可知</span></span><br><span class="line">    <span class="comment">//复杂度O(N)</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> maxCap=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="built_in">Min</span>(height[left],height[right])*(right-left);</span><br><span class="line">        <span class="keyword">if</span>(maxCap&lt;tmp)</span><br><span class="line">            maxCap=tmp;</span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三数之和">5.3 三数之和</h3>
<p><strong>算法思路：</strong></p>
<ul>
<li>1、特判，对于数组长度<code>n</code>，如果数组为<code>null</code>或者数组长度小于<code>3</code>，返回<code>[]</code></li>
<li>2、对数组进行排序。</li>
<li>3、遍历排序后数组：
<ul>
<li>若<code>nums[i]&gt;0</code>：因为已经排序好，所以后面不可能有三个数加和等于0，直接返回结果。</li>
<li>对于重复元素：跳过，避免出现重复解</li>
<li>令左指针<code>L=i+1</code>，右指针<code>R=n-1</code>，当 <code>L&lt;R</code>时，执行循环：
<ul>
<li>当<code>nums[i]+nums[L]+nums[R]==0</code>，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解</li>
<li>若和大于0，说明<code>nums[R]</code>太大，<code>R</code>左移</li>
<li>若和小于0，说明<code>nums[L]</code>太小，<code>L</code>右移</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line"><span class="comment">/*方法一：转化为两数之和</span></span><br><span class="line"><span class="comment">*先将nums的元素拷贝一份到unordered_set处</span></span><br><span class="line"><span class="comment">*再将将nums内的数据两两求和存储回到tmp</span></span><br><span class="line"><span class="comment">*通过在set寻找是否有符合tmp的数据求得其解</span></span><br><span class="line"><span class="comment">*时间复杂度为O(N*N),空间复杂度为O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*方法二：双指针和排序</span></span><br><span class="line"><span class="comment">*先对数组nums进行升序排序，</span></span><br><span class="line"><span class="comment">*后依次从负值取一个元素作为第一个选取的值</span></span><br><span class="line"><span class="comment">*之后定义左右指针，从左指向右前进一位选取一个元素，这里选取了两个元素执行求和得target</span></span><br><span class="line"><span class="comment">*右指针向左移动若干个位置，寻找元素与target和为0得元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line"><span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; nums[i] &lt;= <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    left = i + <span class="number">1</span>;</span><br><span class="line">    right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[left]);</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="comment">//判断下一个值是否重复，是则跳过</span></span><br><span class="line">            <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                left++;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;len<span class="number">-1</span>&amp;&amp;nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">        i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最接近的三数之和">5.4 最接近的三数之和</h3>
<p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *使用三数之和的方法：</span></span><br><span class="line"><span class="comment">    *1、先对数组进行排序</span></span><br><span class="line"><span class="comment">    *2、之后想三数之和一样遍历排序后的数组：</span></span><br><span class="line"><span class="comment">    *时间复杂度为O(N*N)，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> ret=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> right=len<span class="number">-1</span>,left=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较ret是否要更新</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(target-(nums[i]+nums[left]+nums[right]))</span><br><span class="line">                    &lt;<span class="built_in">abs</span>(target-ret))</span><br><span class="line">                    ret=nums[i]+nums[left]+nums[right];</span><br><span class="line">            <span class="comment">//双指针应该向哪边移动</span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[i]+nums[left]+nums[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[i]+nums[left]+nums[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="四数之和">5.5 四数之和</h3>
<p>给你一个由 n 个整数组成的数组<code>nums</code>，和一个目标值<code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组<code>[nums[a], nums[b], nums[c], nums[d]]</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//解决方法同三数求和一样，使用排序+双指针方法</span></span><br><span class="line">        <span class="comment">//只不过此时多加了一层循环，则时间复杂度为O(N^3),</span></span><br><span class="line">        <span class="type">long</span> Target=target;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>;i++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>&amp;&amp;Target&lt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=i+<span class="number">3</span>;j--)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="type">int</span> left=i+<span class="number">1</span>,right=j<span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="type">long</span> result=(<span class="type">long</span>)nums[i]+(<span class="type">long</span>)nums[j]+</span><br><span class="line">					 			(<span class="type">long</span>)nums[left]+(<span class="type">long</span>)nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(Target&lt;result)</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(Target&gt;result)</span><br><span class="line">                        left++;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        ret.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(right&gt;left&amp;&amp;nums[right]==nums[right<span class="number">-1</span>])</span><br><span class="line">                            right--;</span><br><span class="line">                        <span class="keyword">while</span>(right&gt;left&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])</span><br><span class="line">                            left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//跳过重复</span></span><br><span class="line">                 <span class="keyword">while</span>(j&gt;=i+<span class="number">3</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])</span><br><span class="line">                    j--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//跳过重复</span></span><br><span class="line">             <span class="keyword">while</span>(i&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>&amp;&amp;nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="深度优先搜索类">6. 深度优先搜索类</h2>
<h3 id="括号组合">6.1 括号组合</h3>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*dfs思路:</span></span><br><span class="line"><span class="comment">*- 1、使用n1\n2记录&#x27;(&#x27;和&#x27;)&#x27;的剩余个数，初始均为n</span></span><br><span class="line"><span class="comment">*- 2、用一个整数k记录目前组合的字符串前面还有多少个&#x27;(&#x27;未形成组合，如&quot;(()&quot;前面还有一个&#x27;(&#x27;未形成组合</span></span><br><span class="line"><span class="comment">*- 3、递归条件：当前字符串前面没有&#x27;(&#x27;可组合只能进入&#x27;(&#x27;递归，前面有&#x27;(&#x27;可组合则&#x27;(&#x27;和&#x27;)&#x27;均可进入</span></span><br><span class="line"><span class="comment">*- 4、到达递归结束时直接将组合成的字符串压入vector即可，退出递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">dfsGP</span>(ret,s,n,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfsGP</span><span class="params">(vector&lt;string&gt;&amp;vec,string s,<span class="type">int</span> n1,<span class="type">int</span> n2,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n1==<span class="number">0</span>&amp;&amp;n2==<span class="number">0</span>)&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s+=<span class="string">&quot;(&quot;</span>;</span><br><span class="line">            <span class="built_in">dfsGP</span>(vec,s,n1<span class="number">-1</span>,n2,k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n1!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                string s1=s+<span class="string">&quot;(&quot;</span>;</span><br><span class="line">                <span class="built_in">dfsGP</span>(vec,s1,n1<span class="number">-1</span>,n2,k+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n2!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s+=<span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="built_in">dfsGP</span>(vec,s,n1,n2<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="组合总和">6.2 组合总和</h3>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p><code>candidates</code> 中的 同一个 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<ul>
<li>方法一：搜索回溯 思路与算法</li>
</ul>
<p><strong>对于这类寻找所有可行解的题，我们都可以尝试用「搜索回溯」的方法来解决。</strong></p>
<ul>
<li>回到本题，我们定义递归函数 <code>dfs(target,combine,idx)</code> 表示当前在 <code>candidates</code> 数组的第 <code>idx</code> 位，还剩<code>target</code> 要组合，已经组合的列表为 <code>combine</code>。</li>
<li>递归的终止条件为 <code>target≤0</code> 或者 <code>candidates</code> 数组被全部用完。</li>
<li>那么在当前的函数中，每次我们可以选择跳过不用第 <code>idx</code> 个数，即执行 <code>dfs(target,combine,idx+1)</code>。</li>
<li>也可以选择使用第<code>idx</code> 个数，即执行 <code>dfs(target−candidates[idx],combine,idx)</code>，注意到每个数字可以被无限制重复选取，因此搜索的下标仍为 <code>idx</code>。</li>
</ul>
<p>更形象化地说，如果我们将整个搜索过程用一个树来表达，即如下图呈现，每次的搜索都会延伸出两个分叉，直到递归的终止条件，这样我们就能不重复且不遗漏地找到所有可行解 <img src="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/39.png" width="600"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; combine, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(combine);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接跳过</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            combine.<span class="built_in">emplace_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; combine;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面算法没有用到剪枝，利用剪枝可以节省一些时间</p>
</blockquote>
<h3 id="全排列">6.3 全排列</h3>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure> 将题目给定的 <code>n</code> 个数的数组 <code>nums</code> 划分成左右两个部分，左边的表示已经填过的数，右边表示待填的数，我们在回溯的时候只要动态维护这个数组即可。</p>
<ul>
<li>具体来说，假设我们已经填到第 <code>first</code> 个位置，那么<code>nums</code>数组中 <code>[0,first−1]</code> 是已填过的数的集合，<code>[first,n−1]</code>是待填的数的集合。</li>
<li>我们肯定是尝试用 <code>[first,n−1]</code> 里的数去填第 <code>first</code> 个数，假设待填的数的下标为 <code>i</code>，那么填完以后我们将第 <code>i</code> 个数和第 <code>first</code> 个数交换，即能使得在填第 <code>first+1</code> 个数的时候 <code>nums</code> 数组的 <code>[0,first]</code> 部分为已填过的数，<code>[first+1,n−1]</code> 为待填的数，</li>
<li><strong>回溯的时候交换回来即能完成撤销操作。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; output, <span class="type">int</span> first, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了</span></span><br><span class="line">        <span class="keyword">if</span> (first == len) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(output);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = first; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="comment">// 动态维护数组</span></span><br><span class="line">            <span class="built_in">swap</span>(output[i], output[first]);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            <span class="built_in">backtrack</span>(res, output, first + <span class="number">1</span>, len);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            <span class="built_in">swap</span>(output[i], output[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">backtrack</span>(res, nums, <span class="number">0</span>, (<span class="type">int</span>)nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先搜索类">7. 广度优先搜索类</h2>
<h2 id="数学">8. 数学</h2>
<h3 id="下一个排列">8.1 下一个排列</h3>
<p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 arr 的排列：<code>[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code>。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是<code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code>，找出<code>nums</code> 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。 <img src="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/31.gif" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*/</span><br><span class="line"><span class="comment">/*双遍历：</span></span><br><span class="line"><span class="comment">*- 1、数组从后往前遍历，直到遇到第一个nums[i-1]&lt;nums[i],记录该index_1=i-1</span></span><br><span class="line"><span class="comment">*- 2、数组再次从后往前遍历，遇到第一个nums[j]&gt;nums[index],记录下标index_2=j</span></span><br><span class="line"><span class="comment">*- 3、交换nums[index_1]和nums[index_2]的值</span></span><br><span class="line"><span class="comment">*- 4、交换完成后，由上面的步骤一定可知道从[nums.begin()+index_1+1,nums.end()]一定是降序的，直接reverse该范围即可得到下一个子序列</span></span><br><span class="line"><span class="comment">*- 5、如果遍历完都不存在，就说明全部是逆序，直接reverse返回</span></span><br><span class="line"><span class="comment">*时间复杂度为O(N)，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index_1=<span class="number">-1</span>,index_2=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i<span class="number">-1</span>&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            index_1=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index_1==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;index_1;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;=nums[index_1])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                index_2=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[index_1]^=nums[index_2];</span><br><span class="line">            nums[index_2]^=nums[index_1];</span><br><span class="line">            nums[index_1]^=nums[index_2];</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+index_1+<span class="number">1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵">9. 矩阵</h2>
<h2 id="图类">10. 图类</h2>
<h3 id="拓扑排序课程表">10.1 拓扑排序：课程表</h3>
<p>你这个学期必须选修<code>numCourses</code> 门课程，记为<code> 0 </code>到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 必须 先学习课程 <code>bi</code></p>
<p><strong>解题思路：</strong></p>
<p>**拓扑排序，先对输入记录每门课程的入度，当入度为0时，说明这么课程已经完成了所有的预修课程，可以学习该课程 暴力的拓扑排序时间复杂度为O(n*n)，看测试用例大小不可接受**</p>
<ul>
<li>步骤1：由于课程<code>id</code>号为<code>(0~numCourses-1)</code>，使用数组<code>record[i]</code>记录第<code>i</code>门课需要预修的课程数，即入度</li>
<li>步骤2：使用<code>unordermap&lt;id(int),vector&lt;int&gt;&gt;</code>记录课程与课程间的关系</li>
<li>步骤3：遍历<code>record</code>得到入度为0，遍历得到<code>unordermap</code>中的值<code>vector&lt;int&gt;</code>遍历对<code>record</code>中对于入度--</li>
<li>重复上述步骤</li>
<li>上面在<code>record</code>寻找入度为<code>0</code>的点，时间复杂度最坏会达到<code>O(n)</code>,一共要进行<code>n</code>次，平均复杂度为<code>O(n*n)</code></li>
</ul>
<p><strong>优化思路：</strong> BFS思路，使用队列来使用递归</p>
<ul>
<li>为避免每次全表反复扫描寻找入度为0的点，我们使用队列来记录入度为0的点</li>
<li>当我们完成步骤1，即初始化完record后，遍历入度为0的节点入队列</li>
<li>在步骤3中，出队头，并更新record，对更新后入度为0的也入队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//入度数组和邻接表</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">record</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;  umap;</span><br><span class="line">        <span class="comment">//初始化record和umap</span></span><br><span class="line">        <span class="type">int</span> n=prerequisites.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            ++record[prerequisites[i][<span class="number">0</span>]];</span><br><span class="line">            umap[prerequisites[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立队列模拟bfs</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录可学习课程数目</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="comment">//更新umap</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp=umap[q.<span class="built_in">front</span>()];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> course:tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>((--record[course])==<span class="number">0</span>) q.<span class="built_in">push</span>(course);</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==numCourses) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="模拟">11. 模拟</h2>
<h3 id="字符串转整数">11.1 字符串转整数</h3>
<p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：</p>
<ul>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</li>
<li>返回整数作为最终结果。</li>
</ul>
<p><strong><em>注意：</em></strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 ' ' 。</li>
<li>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//易错点：</span></span><br><span class="line"><span class="comment">//        1、题目要求对于前面没遇到数字前，若为非空格非&#x27;-+&#x27;，则为非法输入，直接退出</span></span><br><span class="line"> <span class="comment">//       2、&#x27;-&#x27;或&#x27;+&#x27;号后只能是数字，不能为其他，否则直接退出循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> isFu=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> isfirst=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> Nodigital=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">long</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(isfirst&amp;&amp;Nodigital&amp;&amp;s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(isfirst&amp;&amp;Nodigital&amp;&amp;(<span class="string">&#x27;-&#x27;</span>==s[i]||<span class="string">&#x27;+&#x27;</span>==s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&#x27;-&#x27;</span>==s[i])</span><br><span class="line">                    isFu=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    isFu=<span class="literal">false</span>;</span><br><span class="line">                isfirst=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(isFu)</span><br><span class="line">                    <span class="keyword">if</span>(INT_MIN&gt;result*<span class="number">10</span>-tmp)&#123;</span><br><span class="line">                        result=INT_MIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        result=result*<span class="number">10</span>-tmp;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(INT_MAX&lt;result*<span class="number">10</span>+tmp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        result=INT_MAX;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        result=result*<span class="number">10</span>+tmp;</span><br><span class="line">                Nodigital=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指offer29.-顺时针打印矩阵">11.2 剑指offer29. 顺时针打印矩阵</h3>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>思路：首先从外圈向内圈进行打印，圈按顺时针方向，分别为从左向右，从上到下，从右到左，从下到上。用四个遍历分别记录上边界、下边界、左边界和右边界</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*首先从外圈向内圈进行打印，圈按顺时针方向，分别为从左向右，从上到下，从右到左，从下到上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回值</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">		<span class="comment">//下边界和右边界</span></span><br><span class="line">        <span class="type">int</span> _clo=matrix.<span class="built_in">size</span>()<span class="number">-1</span>,_row=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> N=matrix.<span class="built_in">size</span>()*matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">		<span class="comment">//上边界和左边界</span></span><br><span class="line">        <span class="type">int</span> clo=<span class="number">0</span>,row=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ret.<span class="built_in">size</span>()!=N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从左向右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=row;i&lt;=_row;++i)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(matrix[clo][i]);</span><br><span class="line">            <span class="comment">//从上到下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=clo+<span class="number">1</span>;j&lt;=_clo;++j)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(matrix[j][_row]);</span><br><span class="line">            <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=_row<span class="number">-1</span>;_clo&gt;clo&amp;&amp;i&gt;row;--i)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(matrix[_clo][i]);</span><br><span class="line">            <span class="comment">//从下到上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=_clo;_row&gt;row&amp;&amp;j&gt;clo;--j)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(matrix[j][row]);</span><br><span class="line">            <span class="comment">//更新边界</span></span><br><span class="line">            --_clo;</span><br><span class="line">            --_row;</span><br><span class="line">            ++clo;</span><br><span class="line">            ++row;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="顺时针转90">11.3 顺时针转90°</h3>
<h3 id="包含min函数的栈">11.4 包含min函数的栈</h3>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="type">long</span> num_min;</span><br><span class="line">    stack&lt;<span class="type">long</span>&gt; stack_diff;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *压入：我们以差值的形式压入，即currValue-min，</span></span><br><span class="line"><span class="comment">        *- 为空时，直接设min=currValue,因此压入0</span></span><br><span class="line"><span class="comment">        *- 当差值&lt;0时，说明此时压入的值比之前最小值还小，因此要更新最小值，此时先压入currValue-max，之后</span></span><br><span class="line"><span class="comment">            更新min=currValue</span></span><br><span class="line"><span class="comment">        *- 当差值&gt;=0时，说明压入值比之前最小值大，不要更新，直接压入差值即可</span></span><br><span class="line"><span class="comment">        *取栈顶：</span></span><br><span class="line"><span class="comment">        *- 当stack[top]&gt;0，说明其不是最小值，要返回min+stack[top]</span></span><br><span class="line"><span class="comment">        *- 当stack[top]&lt;=0，说明此时栈顶是最小值，直接返回min即可</span></span><br><span class="line"><span class="comment">        *弹出：</span></span><br><span class="line"><span class="comment">        *- 当stack[top]&gt;0，说明其不是最小值，不用更新最小值，直接弹出pop即可</span></span><br><span class="line"><span class="comment">        *- 当stack[top]&lt;=0时，说明当前栈顶是最小值，弹出后要更新最小值，右上面推导知道，当前值currvalue是最小值,差值=currValue-min&lt;=0，那么弹出后的最小值是min=currValue-差值，即min-=stack[top]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(stack_diff.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            num_min = x;</span><br><span class="line">            stack_diff.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack_diff.<span class="built_in">push</span>((<span class="type">long</span>)x-num_min);</span><br><span class="line">        <span class="keyword">if</span>(x &lt; num_min)</span><br><span class="line">        &#123;</span><br><span class="line">            num_min = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每次pop都有更新现有栈的num_min</span></span><br><span class="line">        <span class="keyword">if</span>(stack_diff.<span class="built_in">top</span>() &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num_min -= stack_diff.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stack_diff.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack_diff.<span class="built_in">top</span>() &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> stack_diff.<span class="built_in">top</span>()+num_min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> num_min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num_min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="剑指offer59-ii.-队列的最大值">11.5 剑指offer59-II. 队列的最大值</h3>
<p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数<code>max_value、push_back</code> 和 <code>pop_front</code> 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
<p><strong>思路：</strong> - 使用两个队列来实现，一个是普通的先进先出队列q，另一个是双端队列d； - 主要是双端队列，它是单调递减形式，队头最是当前进队列数字的最大值，每次插入都会与队尾元素不断比较，如果<code>d.back()&lt;value</code>，则弹出，这就保证了<code>max_Value</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*使用两个队列来实现，一个是普通的先进先出队列q，另一个是双端队列d；</span></span><br><span class="line"><span class="comment">*其中：普通队列记录正常进出顺序，保证push_back和pop_front的功能，双端队列为单调减队列，它存储当前的最大值</span></span><br><span class="line"><span class="comment">*即在双端队列中，每次插入都会与队尾元素不断比较，如果d.back()&lt;value，则弹出，这就保证了max_Value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> d.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双端队列进行比较</span></span><br><span class="line">        <span class="keyword">while</span>(!d.<span class="built_in">empty</span>()&amp;&amp;d.<span class="built_in">back</span>()&lt;value)</span><br><span class="line">            d.<span class="built_in">pop_back</span>();</span><br><span class="line">        d.<span class="built_in">push_back</span>(value);</span><br><span class="line">        q.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ret=q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(ret==d.<span class="built_in">front</span>())</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="滑动窗口最大值">11.6 滑动窗口最大值</h3>
<p>给你一个整数数组<code>nums</code>，有一个大小为 <code>k</code>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code>个数字。滑动窗口每次只向右移动一位。<span class="math inline">\(1&lt;=k&lt;=nums.size()\)</span></p>
<ul>
<li>暴力解会超时，暴力复杂度为O(nk)</li>
<li>滑动窗口的滑动中，数字的进出很想队列的先进先出，因此可使用单调队列来优化时间复杂度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*单调队列实现，可以先看&quot;队列的最大值&quot;这一题</span></span><br><span class="line"><span class="comment">*使用普通队列去记录当前窗口的k个值，使用双端队列去单调记录当前窗口的最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">        q.<span class="built_in">push</span>(nums[<span class="number">0</span>]),d.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>);i&lt;k;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!d.<span class="built_in">empty</span>()&amp;&amp;d.<span class="built_in">back</span>()&lt;nums[i])</span><br><span class="line">                d.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            d.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(d.<span class="built_in">front</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(k);i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//弹出移动后不在窗口的值</span></span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">front</span>()==d.<span class="built_in">front</span>())</span><br><span class="line">                d.<span class="built_in">pop_front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//压入新值</span></span><br><span class="line">            <span class="keyword">while</span>(!d.<span class="built_in">empty</span>()&amp;&amp;d.<span class="built_in">back</span>()&lt;nums[i])</span><br><span class="line">                d.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            d.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            ret.<span class="built_in">push_back</span>(d.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配">11.7 正则表达式匹配</h3>
<p>请实现一个函数用来匹配包含<code>.</code>和<code>*</code>的正则表达式。模式中的字符<code>.</code>表示任意一个字符，而<code>*</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>aaa</code>与模式<code>a.a</code>和<code>ab*ac*a</code>匹配，但与<code>aa.a</code>和<code>ab*a</code>均不匹配。</p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 . 和 <code>*</code>，无连续的 <code>'*'</code>。</li>
</ul>
<h3 id="lru">11.8 LRU</h3>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。 实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 <code>LRU</code> 缓存</li>
<li><code>int get(int key)</code> 如果关键字<code>key</code> 存在于缓存中，则返回关键字的值，否则返回<code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值<code> value</code> ；如果不存在，则向缓存中插入该组<code> key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code>，则应该 逐出 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以<code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>思路</strong>：用双向链表和哈希定位实现，双向链表的目的就是实现逐出最久未使用的关键字</p>
<ul>
<li>按定义，最久未使用的关键字在链表尾部，</li>
<li>在更新中会把get</li>
<li>为了实现上述查找的O(1)时间复杂度，使用哈希来存储key-节点映射</li>
<li>为了能够快速定位头尾节点，使用额外的两个节点pHead、pBack作为头节点和尾部节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> key,val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* prior;</span><br><span class="line">    <span class="built_in">Node</span>():<span class="built_in">val</span>(<span class="number">-1</span>),<span class="built_in">next</span>(<span class="literal">NULL</span>),<span class="built_in">prior</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val):<span class="built_in">val</span>(_val),<span class="built_in">next</span>(<span class="literal">NULL</span>),<span class="built_in">prior</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val,Node* _next,Node* _prior):<span class="built_in">val</span>(_val),<span class="built_in">next</span>(_next),<span class="built_in">prior</span>(_prior)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,Node*&gt; LRU;</span><br><span class="line">    Node* pHead=<span class="literal">NULL</span>,*pBack=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> capacity=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity=capacity;</span><br><span class="line">        pHead=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        pBack=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        pBack-&gt;prior=pHead;</span><br><span class="line">        pHead-&gt;next=pBack;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!LRU[key])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* node=LRU[key];</span><br><span class="line">        <span class="built_in">moveToBegin</span>(node);</span><br><span class="line">        <span class="keyword">return</span> LRU[key]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LRU[key])<span class="comment">//存在则更新</span></span><br><span class="line">        &#123;</span><br><span class="line">            LRU[key]-&gt;val=value;</span><br><span class="line">            <span class="built_in">moveToBegin</span>(LRU[key]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(capacity&lt;=<span class="number">0</span>)&#123;<span class="comment">//不存在且容量已满，删除最后一个</span></span><br><span class="line">            <span class="built_in">removeLast</span>();</span><br><span class="line">            ++capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* newNode=<span class="keyword">new</span> <span class="built_in">Node</span>(value,pHead-&gt;next,pHead);</span><br><span class="line">        newNode-&gt;key=key;</span><br><span class="line">        pHead-&gt;next-&gt;prior=newNode;</span><br><span class="line">        pHead-&gt;next=newNode;</span><br><span class="line">        LRU[key]=newNode;</span><br><span class="line">        --capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新双向链表，实现LRU核心功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToBegin</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//更新节点处两边节点指向</span></span><br><span class="line">        node-&gt;prior-&gt;next=node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prior=node-&gt;prior;</span><br><span class="line">        <span class="comment">//将节点放置在头部</span></span><br><span class="line">        node-&gt;prior=pHead;</span><br><span class="line">        node-&gt;next=pHead-&gt;next;</span><br><span class="line">        pHead-&gt;next-&gt;prior=node;</span><br><span class="line">        pHead-&gt;next=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node* p=pBack-&gt;prior;</span><br><span class="line">        p-&gt;prior-&gt;next=pBack;</span><br><span class="line">        pBack-&gt;prior=p-&gt;prior;</span><br><span class="line">        LRU.<span class="built_in">erase</span>(p-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最小覆盖子串-1">11.9 最小覆盖子串</h3>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot;</p>
<p><strong>解题思路</strong>：</p>
<p>可尝试使用滑动窗口思路解决，先用哈希<code>Hash</code>记录<code>t</code>的字母出现次数，之后对<code>s</code>进行滑动窗口排查</p>
<ul>
<li><code>l,r</code>表示窗口的左右边界，该问题现在转化为求最满足题意得最小窗口</li>
<li>当<code>t</code>出现在窗口内，<code>++l</code></li>
<li>当<code>t</code>不在窗口内，<code>++r</code></li>
</ul>
<p>对于<code>t</code>是否出现在窗口，必须使用一个数据结构来记录当前窗口出现字母,在<code>right</code>右移的时候能够判断该字符是否是t当中的字符，并且判断加入这个字符后当前窗口是否满足<code>t</code>，满足则进入<code>left</code>右移；对于<code>left</code>右移，能够判断当前窗口移除该字符后，是否破坏满足条件，若破坏了就必须能够知道破坏后的窗口缺了多少个什么字符才能再次满足·</p>
<ul>
<li>使用哈希<code>need</code>记录<code>t</code>中各字符出现的次数。</li>
<li>使用<code>count</code>来指示当前窗口还有多少各字符为满足。<code>count==0</code>时说明满足</li>
<li>再使用一个哈希来<code>windows</code>来记录窗口中出现<code>t</code>中字符的数量，当<code>windows</code>于<code>need</code>一一对应时，则认为当前窗口满足了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希need记录所需字符及数量,windows记录当前窗口</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; windows;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span> c:t)</span><br><span class="line">            ++need[c];</span><br><span class="line">        <span class="type">int</span> startIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,minLen=INT_MAX,count=t.<span class="built_in">size</span>(),n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            <span class="type">char</span> c=s[right];</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(c)!=need.<span class="built_in">end</span>()&amp;&amp;need[c]&gt;(windows[c]++)) --count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//先记录这个满足串</span></span><br><span class="line">                <span class="type">int</span> len=right-left+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(minLen&gt;len)&#123;</span><br><span class="line">                    startIndex=left;</span><br><span class="line">                    minLen=len;</span><br><span class="line">                &#125;</span><br><span class="line">                c=s[left];</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(c)!=need.<span class="built_in">end</span>()&amp;&amp;need[c]&gt;=(windows[c]--)) ++count;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minLen&lt;INT_MAX) <span class="keyword">return</span> s.<span class="built_in">substr</span>(startIndex,minLen);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>推荐：</strong>更巧妙的做法，优化了空间复杂度,也提升了速度，该解题思路来源力扣的<code>zrita</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">map</span><span class="params">(<span class="number">128</span>)</span></span>;   </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, need = t.<span class="built_in">size</span>(), minStart = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : t)    ++map[ch];      <span class="comment">//统计t中字符出现次数      </span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[s[right]] &gt; <span class="number">0</span>) --need;   <span class="comment">//窗口右移，每包含一个t中的字符，need-1</span></span><br><span class="line">            --map[s[right]];</span><br><span class="line">            <span class="keyword">while</span>(need == <span class="number">0</span>)    <span class="comment">//完全覆盖子串时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt; minLen)   <span class="comment">//此时字符被包含在[left,right)中</span></span><br><span class="line">                &#123;</span><br><span class="line">                    minStart = left;</span><br><span class="line">                    minLen = right - left + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(++map[s[left]] &gt; <span class="number">0</span>) ++need;  <span class="comment">//窗口左移</span></span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minLen != INT_MAX)   <span class="keyword">return</span> s.<span class="built_in">substr</span>(minStart, minLen);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="o1时间插入删除和随机获取元素">11.10 O(1)时间插入、删除和随机获取元素</h3>
<blockquote>
<p>实现<code>RandomizedSet</code> 类：</p>
</blockquote>
<blockquote>
<p><code>RandomizedSet()</code> 初始化<code>RandomizedSet</code>对象</p>
<p><code>bool insert(int val)</code> 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。</p>
<p><code>bool remove(int val)</code> 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。</p>
<p><code>int getRandom()</code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。</p>
<p>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1</p>
</blockquote>
<p><strong>分析：</strong> 因为题目多了一个随机获取元素。而要随机获取元素，那么只能是在项<code>vector</code>，数组<code>array</code>这类支持随机访问的数据结构上才能实现，但它们无法在<code>insert</code>和<code>remove</code>上做到<span class="math inline">\(O(1)\)</span>，要做到的话只能是在数组末尾才能达到<span class="math inline">\(O(1)\)</span>，而且还必须支持访问是<span class="math inline">\(O(1)\)</span>，要做到这点那么只能依赖哈希建立值与数组索引之间的映射关系</p>
<p>因此借助两个数据结构可完成，用<code>vector&lt;in&gt;hash</code>存储值，<code>unordered_map&lt;int,int&gt;hmap</code>来存储值与数组索引之间的映射关系：</p>
<ul>
<li><code>insert</code>:若插入，在<code>hmap</code>中建立值与索引关系</li>
<li><p><code>remove</code>:我们remove只在数组尾部进行，这样就避免了元素的移动。具体做法就是将<code>hash</code>的尾部元素复制到要删除的元素处，并以此旧的<code>hmap</code>映射关系，建立新的<code>hmap</code>映射关系，然后删除'hash`尾部元素。</p></li>
<li><p><code>getRandom</code>：直接在数组大小内取随机值返回即可</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//存储值</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="comment">//存储值和索引的映射，方便以O(1)形式在hash中找到</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hmap;</span><br><span class="line">    <span class="comment">//记录hash大小</span></span><br><span class="line">    <span class="type">int</span> lenght=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hmap.<span class="built_in">find</span>(val)!=hmap.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        hash.<span class="built_in">push_back</span>(val);</span><br><span class="line">        ++lenght;</span><br><span class="line">        hmap[val]=lenght<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hmap.<span class="built_in">find</span>(val)==hmap.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//获得hash最后一个元素值</span></span><br><span class="line">        <span class="type">int</span> last=hash[lenght<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//找到val元素所在hash的位置</span></span><br><span class="line">        <span class="type">int</span> index=hmap[val];</span><br><span class="line">        <span class="comment">//将末尾元素放入hash[index]</span></span><br><span class="line">        hash[index]=last;</span><br><span class="line">        <span class="comment">//建立新映射last-index</span></span><br><span class="line">        hmap[last]=index;</span><br><span class="line">        <span class="comment">//弹出最后一个元素</span></span><br><span class="line">        hash.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">//从hmap中删除val-index映射</span></span><br><span class="line">        hmap.<span class="built_in">erase</span>(val);</span><br><span class="line">        --lenght;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index=<span class="built_in">rand</span>()%lenght;</span><br><span class="line">        <span class="keyword">return</span> hash[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数组类型">12 数组类型</h2>
<p>数组一类的题目由于其所采用的数据结构为数组，因此其可考察的东西不是固定的，可以说什么方法的题目都可能涉及到数组，因此对于数组，应该多总结归纳，刷多了后，想到数组，出现在脑海的应该由：<strong>双指针、滑动窗户、动态规划、深度（递归）、前缀和、前缀差、二分查找、以及一些只针对题目的解法如数学、位运算</strong>等等，需要你对数组内的元素以及题目意思有比较深的理解。</p>
<h3 id="跳跃游戏55">12.1 跳跃游戏55</h3>
<p>给定一个非负整数数组<code>nums</code>，你最初位于数组的 第一个下标 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*方法一：</span></span><br><span class="line"><span class="comment">*回溯：dfs(nums,loc),loc为当前位置，step为当前位置的值即nums[loc],超时</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*方法二：O(n)算法</span></span><br><span class="line"><span class="comment">*发现：如果无法跳出当前可跳区间，那么可以认为无法达到最后一个下标，</span></span><br><span class="line"><span class="comment">举例：比如[3,2,1,0,4]，对应下标为[0,1,2,3,4]；</span></span><br><span class="line"><span class="comment">*刚开始对于下标0的3我们的可跳区间是下标[1,3]；对应数字是[2,1,0]；</span></span><br><span class="line"><span class="comment">*在该可跳区间中由于2+1=3；1+2=3；0+3=3，表示下一个可跳区间的最大下标是3，仍在当前的可跳区间，无法出去，</span></span><br><span class="line"><span class="comment">*那么即可认为无法到达最后一个下标</span></span><br><span class="line"><span class="comment">*思路：</span></span><br><span class="line"><span class="comment">* - 先排除一些特殊情况，当数组大小为0或1，必能达到；当数组大小&gt;1,当第一个数就是0不能达到</span></span><br><span class="line"><span class="comment">* - 我们定义beginOfJump和endOfJump，分别表示当前可跳区间的范围。</span></span><br><span class="line"><span class="comment">* - 为了确定下一个区间的最大下标，我们需要遍历[beginOfJump,endofJump]范围的数字，确定下一个区间最大下标nextMaxIndex</span></span><br><span class="line"><span class="comment">* -如果nextMaxIndex&gt;=nums.size()-1,肯定能够到达最后一个下标位置，之间返回true</span></span><br><span class="line"><span class="comment">* - 如果没有到达，且跳不出当前区间，无法到达，返回false</span></span><br><span class="line"><span class="comment">* - 如果没有到达，但能够跳出，进行下一个区间的遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">       return dfs(nums,0);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    bool dfs(vector&lt;int&gt;&amp;nums, int loc)&#123;</span></span><br><span class="line"><span class="comment">        if(loc&gt;=nums.size()-1)</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        else if(!nums[loc]&amp;&amp;loc&lt;nums.size()-1)</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=nums[loc];i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(dfs(nums,loc+i))</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()!=<span class="number">1</span>&amp;&amp;nums[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> beginOfJump=<span class="number">1</span>,endOfJump=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(beginOfJump&lt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历该可跳区间能确定的下一个区间范围</span></span><br><span class="line">            <span class="type">int</span> nextMaxIndex=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=beginOfJump;i&lt;=endOfJump;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp=i+nums[i];</span><br><span class="line">                <span class="comment">//若循环中就可达到，直接返回(剪枝)</span></span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;nextMaxIndex)</span><br><span class="line">                    nextMaxIndex=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否可跳出该区间，不可则说明不能到达</span></span><br><span class="line">            <span class="keyword">if</span>(nextMaxIndex&lt;=endOfJump)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//直接在下一区间判断</span></span><br><span class="line">            beginOfJump=endOfJump+<span class="number">1</span>;</span><br><span class="line">            endOfJump=nextMaxIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="合并区间56">12.2 合并区间56</h3>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p>思路：</p>
<ul>
<li>先对数组</li>
<li>然后判断：
<ul>
<li>首先返回数组为空时，只能选择<code>intervals</code>内的第1和第2个区间比较，若第2区间与第一区间有共同区间，则执行合并操作</li>
<li>若返回数组不为空，则先对返回数组的最后一个区间与<code>intervals</code>当前区间比较，看是否合并，合并的话执行合并操作；不合并则直接插入到返回数组即可</li>
</ul></li>
<li>合并操作：要判断是包含关系还是拼接关系
<ul>
<li>包含关系：即第一区间包含第二区间，则直接是第一区间不变即可</li>
<li>拼接关系：第一个区间的结尾替换为第二区间的结尾 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*排序+遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">if</span>(!ret.<span class="built_in">empty</span>()&amp;&amp;(*(ret.<span class="built_in">end</span>()<span class="number">-1</span>))[<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((*(ret.<span class="built_in">end</span>()<span class="number">-1</span>))[<span class="number">1</span>]&lt;intervals[i][<span class="number">1</span>])</span><br><span class="line">                    (*(ret.<span class="built_in">end</span>()<span class="number">-1</span>))[<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span>&lt;intervals.<span class="built_in">size</span>()&amp;&amp;intervals[i][<span class="number">1</span>]&gt;=intervals[i+<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(intervals[i][<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">//拼接关系</span></span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&lt;intervals[i+<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(intervals[i+<span class="number">1</span>][<span class="number">1</span>]); </span><br><span class="line">                <span class="comment">//包含关系</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(intervals[i][<span class="number">1</span>]);</span><br><span class="line">                ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">               ret.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="剑指offer45-把数组排成最小的数">12.3 剑指offer45 把数组排成最小的数</h3>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>思路：</p>
<ul>
<li>要自定义排序法则，将其排序成组成的数组是最小顺序</li>
<li>排序法则：从数组中任取两个数字字符串x和y，若x+y&gt;=y+x，则说明x&gt;=y；若x+y&lt;y+x，则x&lt;y</li>
<li>使用快排或者带谓词的内置函数，实现时间复杂度为O(nlogn)，最坏情况为O(n*n)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*这道题目是排序题，这不过需要自定义排序法则：</span></span><br><span class="line"><span class="comment">*可以发现从nums中任意取两个数字x和y,若x+y&gt;=y+x，说明x&gt;=y;若x+y&lt;y+x，说明x&lt;y</span></span><br><span class="line"><span class="comment">*使用自定义的快排或者带谓词的内置函数，实现时间复杂度为O(nlogn)，最坏情况为O(n)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">vec</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">            vec[i]=<span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">        <span class="built_in">quickSort</span>(vec,<span class="number">0</span>,vec.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:vec)</span><br><span class="line">            ret+=it;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;string&gt;&amp; vec,<span class="type">int</span> l,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=h)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//基准点为vec[l]</span></span><br><span class="line">        <span class="type">int</span> l_cursor=l,h_cursor=h;</span><br><span class="line">        <span class="keyword">while</span>(l_cursor&lt;h_cursor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(l_cursor&lt;=h&amp;&amp;vec[l_cursor]+vec[l]&lt;=vec[l]+vec[l_cursor])</span><br><span class="line">                ++l_cursor;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=h_cursor&amp;&amp;vec[h_cursor]+vec[l]&gt;vec[l]+vec[h_cursor])</span><br><span class="line">                --h_cursor;</span><br><span class="line">            <span class="keyword">if</span>(l_cursor&lt;h_cursor)</span><br><span class="line">                <span class="built_in">swap</span>(vec[l_cursor],vec[h_cursor]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放置基准点</span></span><br><span class="line">        <span class="built_in">swap</span>(vec[l],vec[h_cursor]);</span><br><span class="line">        <span class="built_in">quickSort</span>(vec,l,h_cursor<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(vec,h_cursor+<span class="number">1</span>,h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带谓词的内置函数</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](string&amp; x,string&amp; y)&#123;<span class="keyword">return</span> x+y&lt;y+x;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="剑指offer56-i.数组中数字出现的次数位运算">12.4 剑指offer56-I.数组中数字出现的次数（位运算）</h3>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是<code>O(n)</code>，空间复杂度是<code>O(1)</code>。</p>
<p>思路：有多种解法</p>
<p><strong>解法一</strong>：使用排序,时间复杂度为<code>O(nlogn)</code>，空间复杂度为<code>O(1)</code> <strong>解法二</strong>：使用哈希，时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(n)</code> <strong>解法三</strong>：其他数字出现了两次，则可说明当数组中只有一个数是出现一次时，数组所有元素异或后，会得到这个只出现一次的数字。此时时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code></p>
<p>对于解法三：</p>
<ul>
<li>现在是有两个出现一次的数字<code>x</code>和<code>y</code>，那么得到的结果就是<code>x^y</code></li>
<li>现在的重点是如何去划分两个数组使得其<code>x</code>,<code>y</code>各在这两个数组内
<ul>
<li><code>x^y</code>肯定存在位为<code>1</code>，表示<code>x</code>和<code>y</code>的不同点，现在我们要找到第一个<code>1</code>位</li>
<li>我们借助辅助变量<code>m=1</code>去寻找，没找到<code>m</code>就会左移一位，找到则得到最终的<code>m</code></li>
<li>之后用<code>m</code>与数组内的元素进行相<code>&amp;</code>，如果<code>num&amp;m</code>为真，划分到数组<code>1</code>执行异或，否则划分到数组<code>2</code>执行异或</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">            xy^=num;    </span><br><span class="line">        <span class="type">int</span> m=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(xy&amp;m))</span><br><span class="line">            m&lt;&lt;=<span class="number">1</span>;  </span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">            <span class="keyword">if</span>(num&amp;m)</span><br><span class="line">                x^=num; <span class="comment">//数组1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y^=num; <span class="comment">//数组2</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ret&#123;x,y&#125;;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>位运算总结：
<ul>
<li>x&amp;1：得到最底位是<code>0</code>还是<code>1</code>，与右移结合，可统计给定整数二进制形式<code>1</code>的个数</li>
<li>x^=y：得到无进位的和；检查x和y是否相同</li>
<li>x&amp;y：与<code>左移&lt;&lt;</code>结合得到进位</li>
</ul></li>
</ul>
<p>例如：不用加减乘除做加法 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*                      ^   &amp;(进位)</span></span><br><span class="line"><span class="comment">* 1011  11       0  0   0   0       1011   1011    0110   0110    1000  1000   10000   10000</span></span><br><span class="line"><span class="comment">* 0111   7       0  1   1   0     &amp; 0111 ^ 0111  &amp; 1100 ^ 1100  &amp; 1010  1010  &amp; 0010 ^  0010</span></span><br><span class="line"><span class="comment">*10010  18       1  0   1   0       0011   1100    0100   1010    1000  0010   00000   10010</span></span><br><span class="line"><span class="comment">*                1  1   0   1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//进位</span></span><br><span class="line">            <span class="type">int</span> c=(<span class="type">unsigned</span> <span class="type">int</span>)(a&amp;b)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//当前</span></span><br><span class="line">            a^=b;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="剑指offer39.-数组中出现次数超过一半的数字">12.5 剑指offer39. 数组中出现次数超过一半的数字</h3>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。要求时间为O(n)，空间为O(1)</p>
<ul>
<li>解法：<strong>摩尔投票法，因为数字超过了一办，是大众数，那么可理解成数字不同的双方同归于尽，相同的则一起存活，用count取记录存活数量，res记录存的数字，最后活下来的一定是大众数</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*解法一：排序，此时数字一定出现在中位数，取中位数即可，时间复杂度O(nlogn)，空间O(1)</span></span><br><span class="line"><span class="comment">*解法二：哈希，时间复杂度位O(n)，空间复杂度位O(n)</span></span><br><span class="line"><span class="comment">*解法三：摩尔投票法，因为数字超过了一办，是大众数，那么可理解成数字不同的双方同归于尽，相同的则一起存活，用count取记录存活数量，res记录存的数字，最后活下来的一定是大众数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>,res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                res=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res==nums[i]?++count:--count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="根据身高重建队列">12.6 根据身高重建队列</h3>
<p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第<code>i</code>个人的身高为<code>hi</code> ，前面 正好 有 <code>ki</code> 个身高大于或等于<code>hi</code> 的人。</p>
<p>请你重新构造并返回输入数组<code> people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
<p><strong>解法1：</strong></p>
<p><strong>思路：从头到尾构造该队列，每次从people中取出适合的人在该位置，适合的人确定算法如下，假设前面已有排好的x个人，x个人中已知最低身高是min,最高身高是max：</strong> - 先对数组按身高排序（剪枝操作，执行一次），这是因为当存在多个位次即<code>people[i][j]</code>满足需求时，个子矮的才是正确人选，这是因为如果个子高的在这个位置，个子矮的在后续位置无法满足,就比如<code>[5,0]</code>和<code>[7,0]</code>，若<code>[7,0]</code>在头，无论<code>[5,0]</code>在后面的哪个位置，其位次都不应是0，至少是1。 - 遍历数组，查看当前<code>people[i]</code>中的位次是否满足该位置，如果满足，则这个位置站的就是<code>people[i]</code>，否则取一下，反复执行直到满足 - 我们使用<code>map</code>来存储当前位置前出现比<code>map.first</code>高的人的个数 为避免重复，我们将已经拍好序的人升高赋值为<code>-1</code></p>
<p>上述时间复杂度是<code>O(nlogn)+O(n*n)=O(n*n)</code>,排序达到了剪枝效果，因此实际复杂度 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; record;</span><br><span class="line">        <span class="type">int</span> n=people.<span class="built_in">size</span>(),m=<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ret</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//对people按h排序</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            record.<span class="built_in">insert</span>(&#123;people[i][<span class="number">0</span>],<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;n)&#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="comment">//该people已经排序</span></span><br><span class="line">                <span class="keyword">if</span>(people[i][<span class="number">0</span>]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//判断该people是否符合条件</span></span><br><span class="line">                <span class="keyword">if</span>(people[i][<span class="number">1</span>]==record[people[i][<span class="number">0</span>]]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ret插入</span></span><br><span class="line">            ret[x][<span class="number">0</span>]=people[i][<span class="number">0</span>];</span><br><span class="line">            ret[x][<span class="number">1</span>]=people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//people标记已排序</span></span><br><span class="line">            people[i][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//更新record</span></span><br><span class="line">            <span class="keyword">auto</span> End = record.<span class="built_in">find</span>(ret[x][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">auto</span> it = record.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (it != End) &#123;</span><br><span class="line">                ++(it-&gt;second);</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">            ++(End-&gt;second);</span><br><span class="line">            ++x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二（该题想要讲述的解法）：数对分别不同规则排序+插入</strong></p>
<p>思路：我们发现当我们对升高按<strong>低到高</strong>排序，，低身高的插入操作不会对高身高的人产生任何影响；反而高身高的人若插入在低身高的前面就会对低身高的产生影响。我们设人数为<code>n</code>，在进行排序后，它们的身高依次为<span class="math inline">\(h_0、h_1...h_n\)</span>。如果我们按照排完序后的顺序，依次将每个人放入队列中，那么当我们放入第<code>i</code>个人时:</p>
<ul>
<li>第<span class="math inline">\(1,...,i-1\)</span>个人已经在队列中被安排了位置，并且他们无论站在哪里，对第<span class="math inline">\(i\)</span>个人没有任何影响。</li>
<li>而<span class="math inline">\(i+1,...,n\)</span>个人还没有插入，但他们只要站在第<code>i</code>个人前面，就会对第<code>i</code>个人产生影响。</li>
</ul>
<p>因此对于第二种情况，我们需要为这种插入留空，我们根据<code>people[i][1]</code>决定留空多少个。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比如：[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span></span><br><span class="line"><span class="comment">排序：身高低到高，ki由高到低排序，得[[4,4],[5,2],[5,0],[6,1],[7,1],[7,0]]</span></span><br><span class="line"><span class="comment">插入：_ _ _ _ [4,4] _</span></span><br><span class="line"><span class="comment">	 _ _ [5,2] _ [4,4] _</span></span><br><span class="line"><span class="comment">	 [5,0] _ [5,2] _ [4,4] _</span></span><br><span class="line"><span class="comment">	 [5,0] _ [5,2] [6,1] [4,4] _</span></span><br><span class="line"><span class="comment">	 [5,0] _ [5,2] [6,1] [4,4] [7,1]</span></span><br><span class="line"><span class="comment">	 [5,0] [7,0] [5,2] [6,1] [4,4] [7,1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),[](vector&lt;<span class="type">int</span>&gt;&amp; u,vector&lt;<span class="type">int</span>&gt;&amp; v)&#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">0</span>]&lt;v[<span class="number">0</span>]||(u[<span class="number">0</span>]==v[<span class="number">0</span>]&amp;&amp;u[<span class="number">1</span>]&gt;v[<span class="number">1</span>]);&#125;);</span><br><span class="line">        <span class="type">int</span> n=people.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ret</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>,index=<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> k=people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n&amp;&amp;count&lt;=k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ret[j].<span class="built_in">empty</span>()) ++count;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; temp&#123;people[i][<span class="number">0</span>],people[i][<span class="number">1</span>]&#125;;</span><br><span class="line">            ret[index]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>总结：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。</strong></p>
<h3 id="除自身以外数组的乘积">12.7 除自身以外数组的乘积</h3>
<blockquote>
<p><strong>题目：</strong> 给你一个整数数组 <code>nums</code>，返回 数组<code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p>
</blockquote>
<blockquote>
<p>题目数据 保证 数组<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。</p>
</blockquote>
<blockquote>
<p><strong>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</strong></p>
</blockquote>
<p><strong>思路</strong>：类比于前后缀和和前后缀差，这里可以使用前缀乘积和后缀乘积解决该问题，定义<code>l[i]</code>和<code>r[i]</code>，</p>
<ul>
<li><code>l[i]</code>表示在<code>nums[i]</code>左边的所有元素乘积</li>
<li><code>r[i]</code>表述<code>nums[i]</code>右边的所有元素乘积</li>
<li>那么利润<code>l[i]</code>和<code>r[i]</code>就能得出<code>multi[i]=l[i]*r[i]</code></li>
</ul>
<p>算法的时间复杂度为<span class="math inline">\(O(n)\)</span>,空间复杂度为<span class="math inline">\(O(N)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">类比于前后缀和和前后缀差，这里可以使用前缀乘积和后缀乘积解决该问题，定义l[i]和r[i]，</span><br><span class="line">- l[i]表示在nums[i]左边的所有元素乘积</span><br><span class="line">- r[i]表述nums[i]右边的所有元素乘积</span><br><span class="line">- 那么利润l[i]和r[i]就能得出multi[i]=l[i]*r[i]</span><br><span class="line"></span><br><span class="line">算法的时间复杂度为<span class="built_in">O</span>(n),空间复杂度为<span class="built_in">O</span>(N)</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; <span class="built_in">productExceptSelf</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multi</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            l[i]=l[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">            r[n-i<span class="number">-1</span>]=r[n-i]*nums[n-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            multi[i]=l[i]*r[i];</span><br><span class="line">        <span class="keyword">return</span> multi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="section">12.8</h3>
<h2 id="分治和二分">13 分治和二分</h2>
<p>分治和二分法可以说是O(logn)时间复杂度的代名词，因此学会分治和二分法是必须的。运用分治的诸如归并排序、二分法如二分查找和查找第k大数字 ### 13.1 寻找两个正序数组的中位数 给定两个大小分别为<code>m</code>和<code>n</code>的正序（从小到大）数组 <code>nums1</code>和<code> nums2</code>。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为<code>O(log (m+n))</code>。</p>
<p><strong>解题思路：</strong>题目要求时间复杂度为<code>O(log (m+n))</code>,那么必然是使用二分法</p>
<p><strong>二分法：</strong> 使用类似于二分法的操作，计算出<code>nums1</code>和<code>nums2</code>的长度和<code>m+n</code>,那么可以肯定，当为奇数时，中位数所在位置为<code>(m+n)/2</code>;当偶数时中位数所在位置为<code>(m+n)/2</code>与<code>(m+n)/2-1</code>的均值；因此计算出<code>k=(m+n)/2</code>，表示第K大的数，当为奇数时，即得到第<code>k+1</code>大的数字即可；当为偶数是，得到第<code>k</code>大和<code>k+1</code>大数字的和平均</p>
<p><strong>我们可以通过一下适用于两个数组的二分法实现，构造一个新的辅助函数，该函数功能为得到第<code>k</code>大的数字</strong></p>
<ul>
<li>首先定义出起始位置<code>start1</code>和<code>start2</code></li>
<li>由于<code>m=k&gt;&gt;1</code>情况对某一数组而言存在越界情况，因此需取<code>min(len,start+m)</code>的较小值，由于数组下标从<code>0</code>开始，需<code>-1</code>，后得到<code>index1、index2</code></li>
<li>比较<code>nums1[index1]</code>与nums<code>[index2]</code>的大小
<ul>
<li>当<code>nums1[index1]&gt;=nums2[index2]</code>，那么就说明可以去除<code>nums2</code>数组中<code>[0,k/2]</code>范围的数字，更新k值和数组<code>nums1</code>的起始位置<code>start1</code></li>
<li>当<code>nums1[index1]&lt;nums2[index2]</code>，那么就说明可以去除<code>nums1</code>中的<code>[0,k/2]</code>，更新<code>k</code>值和<code>start2</code></li>
</ul></li>
<li><strong>退出条件：</strong>
<ul>
<li>当某一数组遍历完后，那么可知第k大数组必定在另一个数组，且<code>k\start</code>更新过，可以直接返回<code>nums[start+k-1]</code></li>
<li>当<code>k==1</code>，返回<code>min(nums1[start1],nums2[start2])</code></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=nums1.<span class="built_in">size</span>(),n=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>((m+n)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElems</span>(nums1,nums2,(m+n)/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElems</span>(nums1,nums2,(m+n)/<span class="number">2</span>)+<span class="built_in">getKthElems</span>(nums1,nums2,(m+n)/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到第K大数字</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getKthElems</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1,vector&lt;<span class="type">int</span>&gt;&amp; nums2,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">start1</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">start2</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">len1</span><span class="params">(nums1.size())</span>,<span class="title">len2</span><span class="params">(nums2.size())</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//边界情况可以退出</span></span><br><span class="line">            <span class="keyword">if</span>(start1&gt;=len1)</span><br><span class="line">                <span class="keyword">return</span> nums2[start2+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(start2&gt;=len2)</span><br><span class="line">                <span class="keyword">return</span> nums1[start1+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[start1],nums2[start2]);</span><br><span class="line">            <span class="comment">//进行更新k和start</span></span><br><span class="line">            <span class="type">int</span> m=k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> index1=<span class="built_in">min</span>(len1,m+start1)<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> index2=<span class="built_in">min</span>(len2,m+start2)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums1[index1]&gt;=nums2[index2])</span><br><span class="line">            &#123;</span><br><span class="line">                k-=(index2-start2+<span class="number">1</span>);</span><br><span class="line">                start2=index2+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k-=(index1-start1+<span class="number">1</span>);</span><br><span class="line">                start1=index1+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数组中的第k个最大元素">13.2 数组中的第K个最大元素</h3>
<p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>思路：</strong>我们知道快速排序是以分治的思想来降低复杂度，其算法流程是</p>
<ul>
<li><strong>分解</strong>：将数组<span class="math inline">\(a[l...r]\)</span>划分成两个子数组<span class="math inline">\(a[l...q-1]、a[q+1...r]\)</span>,使得<span class="math inline">\(a[l...q-1]\)</span>中的元素小于等于<span class="math inline">\(a[q]\)</span>，且<span class="math inline">\(a[q]\)</span>小于等于<span class="math inline">\(a[q+1...r]\)</span>中的每一个元素。其中，计算下标q也是<strong>划分</strong>过程的一部分</li>
<li><strong>解决</strong>：通过递归调用快速排序，对于数组<span class="math inline">\(a[l...q-1]、a[q+1...r]\)</span>进行排序</li>
<li><strong>合并：</strong>因为子数组都是原址排序的，所以不需要进行合并操作，<span class="math inline">\(a[l...r]\)</span>已经有序</li>
<li>上文中提到的 「划分」 过程是：从子数组<span class="math inline">\(a[l...r]\)</span>中选择任意一个元素 <span class="math inline">\(x\)</span> 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， <span class="math inline">\(x\)</span> 的最终位置就是 <span class="math inline">\(q\)</span></li>
</ul>
<p><strong>可以发现每次划分后都会确定一个元素在数组中的位置，因此对于第k个最大元素，我们只需要关注该位置即可，对于区间有序性并不在乎。为避免最坏的时间复杂度，使用随机法取基准点</strong>，随机法能够避免最坏复杂度，</p>
<p>算法步骤：</p>
<ul>
<li>利用快速排序的方法，只确定数组中的第K个最大的元素。</li>
<li>为避免最坏情况，使用随机法规范</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">//选择快排</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">RandomPivot</span>(nums, l, r);</span><br><span class="line">        <span class="keyword">if</span> (index == k) <span class="keyword">return</span> nums[index];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> index &gt; k ? <span class="built_in">quickSelect</span>(nums, l, index - <span class="number">1</span>, k) : <span class="built_in">quickSelect</span>(nums, index + <span class="number">1</span>, r, k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机选择基准点</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">RandomPivot</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">swap</span>(nums[r], nums[index]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partirion</span>(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">partirion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = nums[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums.<span class="built_in">size</span>() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上题目均来自leetcode 题目来源：<a href="https://leetcode.cn/problemset/all/">leetcode</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>GOF23</title>
    <url>/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="概览">1 概览</h3>
<p>23种设计模式主要可以分为三种类型：</p>
<ul>
<li><p><strong>创建型模式：用来创建对象</strong></p>
<ul>
<li>单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。</li>
</ul></li>
<li><p><strong>结构型模式：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。（关注对象和类的组成关系）</strong></p>
<ul>
<li>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</li>
</ul></li>
<li><p><strong>行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责</strong></p>
<ul>
<li>模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。 <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/GOF23.png" width="700"> <span id="more"></span></li>
</ul></li>
</ul>
<h4 id="六大原则">1.1 六大原则</h4>
<ul>
<li><p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码</strong>，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p></li>
<li><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。 <strong>里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现</strong>。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></li>
<li><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容<strong>：针对接口编程，依赖于抽象而不依赖于具体。</strong></p></li>
<li><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：<strong>使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度</strong>。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p></li>
<li><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：<strong>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</strong>。</p></li>
<li><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：<strong>尽量使用合成/聚合的方式，而不是使用继承</strong>。</p></li>
</ul>
<p><strong>其他：</strong></p>
<ul>
<li>高内聚：一个模块或一个类被设计成只支持一组相关的功能时，它具有高内聚。反之，被设计成一组不相关的功能时，我们说它具有低内聚。</li>
<li>低耦合：每个个模块之间或类的关联性降到可控范围的最低</li>
<li>单一职责原则(SRP)：一个类或者模块只负责完成一个职责（或者功能）。</li>
</ul>
<h3 id="单例模式">2 单例模式*</h3>
<p>保证证一个类只有一个实例，并且提供一个访问该实例的全局访问点。</p>
<ul>
<li><strong>主要解决</strong>：一个全局使用的类频繁地创建与销毁。</li>
</ul>
<p><strong>单例模式同时解决了两个问题</strong></p>
<ul>
<li>保证一个类只有一个实例。
<ul>
<li>为什么会想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。它的运作方式是这样的： 如果创建了一个对象， 同时过一会儿后决定再创建一个新对象， 此时会获得之前已创建的对象， 而不是一个新对象。</li>
</ul>
<p>注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。</p></li>
<li><p>为该实例提供一个全局访问节点。 全局变量在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</p>
<p>和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p>
<p>还有一点： 我们不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</p></li>
</ul>
<p><strong>常见的五种单例模式实现方式</strong></p>
<ul>
<li>饿汉式（线程安全，调用效率高。 但是，不能延时加载。）</li>
<li>普通懒汉式（线程不安全，调用效率不高。 但是，可以延时加载。）</li>
<li>双重检测锁式（加锁的懒汉式，使用互斥锁保证线程安全）</li>
<li>静态局部变量的懒汉单例(线程安全，调用效率高。 但是，可以延时加载)</li>
<li>std::call_once 实现单例（C++11线程安全）(线程安全，调用效率高，不能延时加载)</li>
</ul>
<p><strong><em>注意</em></strong>：</p>
<ul>
<li>懒汉式的名称来源是因为系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例；这种方式要考虑线程安全。<strong>而饿汉式则是系统一运行，就初始化创建实例，当需要时，直接调用即可。这种方式本身就线程安全，没有多线程的线程安全问题。</strong></li>
<li><strong>这里的线程安全是指创建单例对象时的，使用单例对像时的安全要开发者自己保证</strong></li>
</ul>
<blockquote>
<p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p>
</blockquote>
<h4 id="饿汉式">2.1 饿汉式</h4>
<p>饿汉式之所以线程安全是因为其实例是在代码一运行就初始话创建的，其本身就是线程安全的 <strong>实现步骤</strong>：</p>
<ul>
<li>设置构造、析构、拷贝和赋值函数私有化，禁止外部构造和析构</li>
<li>创建静态接口，以获得单例对象，并定义一个类内私有的类静态成员指针</li>
<li><strong>类外静态初始化一个单例对象</strong></li>
</ul>
<p>头文件： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singelton* <span class="title">getsingle</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//释放单例，进程退出时调用</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">delteSingle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>();</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; single);</span><br><span class="line">	<span class="type">const</span> Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; single);</span><br><span class="line">	~<span class="built_in">Singleton</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> Singleton *g_singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 源文件： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//装载类时就会初始化创建实例，本身就是线程安全</span></span><br><span class="line">Singleton* Singleton::g_singleton = <span class="built_in">new</span>(std::nothrow)<span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getsingle</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> g_singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Singleton::delteSingle</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(g_singleton)&#123;</span><br><span class="line">		<span class="keyword">delete</span> g_singleton;</span><br><span class="line">		g_singleton = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h4 id="加锁懒汉模式双重检测锁">2.2 加锁懒汉模式（双重检测锁）</h4>
<p>懒汉模式因为需要使用时才创建该实例，因此一般对线程来说是不安全的，需要通过加互斥锁来保证线程安全，但加锁的开销还是很大的，<strong>因此加锁的懒汉模式用两个<code>if</code>判断语句来检测是否加锁，也叫双重检测锁式</strong> <strong>步骤</strong></p>
<ul>
<li>设置构造、析构、拷贝和赋值函数私有化，禁止外部构造和析构</li>
<li>创建静态接口，以获得单例对象，<strong>并定义一个类内私有的类静态成员指针并在类外设置为nullptr</strong></li>
<li>在静态接口使用双重<code>if</code>即双捡锁判断是否加锁来赋值 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singelton* <span class="title">getsingle</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//释放单例，进程退出时调用</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">delteSingle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>();</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; single);</span><br><span class="line">	<span class="type">const</span> Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; single);</span><br><span class="line">	~<span class="built_in">Singleton</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">static</span> Singleton *g_singleton;</span><br><span class="line">	<span class="type">static</span> std::mutex m_Mutex;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//源文件</span></span><br><span class="line"><span class="comment">//初始化静态成员变量</span></span><br><span class="line">Singleton* Singleton:: g_singleton = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::m_Mutex;</span><br><span class="line"><span class="function">Singelton* <span class="title">Singleton::getsingle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//使用两个if，双检锁：只有判断指针为空在加锁，每次调用该方法式避免每次都要加锁</span></span><br><span class="line">	<span class="comment">//若是空，则进入进行赋值</span></span><br><span class="line">	<span class="keyword">if</span>(g_singleton==<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">			std::unique_lock&lt;std::mutex&gt;<span class="built_in">lock</span>(m_Mutex);	<span class="comment">//加锁</span></span><br><span class="line">			<span class="keyword">if</span>(g_singleton==<span class="literal">nullptr</span>)</span><br><span class="line">				g_singleton=<span class="built_in">new</span>(std::nothrow)<span class="built_in">Singleton</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g_singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="静态局部变量的懒汉单例">2.3 静态局部变量的懒汉单例</h4>
<p>静态局部变量的懒汉单例，顾名思义就是在静态接口初始化一个静态变量(利用了静态变量只初始化一次的特性)</p>
<p>步骤：</p>
<ul>
<li>设置构造、析构、拷贝和赋值函数私有化，禁止外部构造和析构</li>
<li>创建静态接口，以获得单例对象</li>
<li><strong>在静态接口初始化一个局部静态变量</strong>(只初始化一次)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singelton&amp; <span class="title">getsingle</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//释放单例，进程退出时调用</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">delteSingle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>();</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; single);</span><br><span class="line">	<span class="type">const</span> Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; single);</span><br><span class="line">	~<span class="built_in">Singleton</span>();</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//源文件</span></span><br><span class="line"></span><br><span class="line"><span class="function">Singelton&amp; <span class="title">Singleton::getsingle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> Singleton g_single;</span><br><span class="line">	<span class="keyword">return</span> g_single;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>但是，这种方法也有点问题：在多线程场景下还是有可能会存在线程安全的问题，因为多线程同时调用 <code>gessingle()</code> 方法有可能还是会产生竞争。</p>
<p>解决这个问题的一种做法是：在程序的单线程启动阶段就调用 <code>gessingle()</code> 方法。</p>
<h4 id="stdcall_once-实现单例">2.4 std::call_once 实现单例</h4>
<p>std::call_once修饰的代码表示只被执行一次，常与lambda联合使用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Singleton&gt; <span class="title">getSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::shared_ptr&lt;Singleton&gt; singleton = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> std::once_flag singletonFlag;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Singleton&gt; <span class="title">Singleton::getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(singletonFlag, [&amp;] &#123;</span><br><span class="line">        singleton = std::<span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> <span class="built_in">Singleton</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="适用场景">2.5 适用场景</h4>
<ul>
<li><p>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。 单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。</p></li>
<li><p>如果需要更加严格地控制全局变量， 可以使用单例模式。 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p></li>
<li><p>如要解决一个全局使用的类频繁的创建和销毁的问题，可以考虑单例模式</p></li>
</ul>
<p>请注意， 可以随时调整限制并设定生成单例实例的数量， 只需修改获取实例方法。</p>
<h4 id="优缺点">2. 6 优缺点</h4>
<ul>
<li>优点
<ul>
<li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</li>
<li>单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理</li>
</ul></li>
<li>缺点
<ul>
<li>单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</li>
<li>该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。</li>
<li>单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</li>
</ul></li>
</ul>
<h4 id="与其他设计模式的关系">2.7 与其他设计模式的关系</h4>
<ul>
<li>外观模式类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。</li>
<li>如果能将对象的所有共享状态简化为一个享元对象， 那么享元模式就和单例类似了。 但这两个模式有两个根本性的不同。
<ul>
<li>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。 享元对象是不可变的。</li>
</ul></li>
<li>抽象工厂模式、 生成器模式和原型模式都可以用单例来实现。</li>
</ul>
<h3 id="工厂模式">3 工厂模式*</h3>
<p><strong>工厂模式实现了创建者和调用者分离，本质上是实例化对象，用工厂方法代替创建对象</strong>。 同时，将选择实现类、创建对象统一管理和控制。<strong>从而将调用者跟我们的实现类解耦。</strong></p>
<ul>
<li><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li>
<li><strong>主要解决：</strong>主要解决接口选择的问题。</li>
</ul>
<p>工厂模式可以分为三类：</p>
<ul>
<li><strong>简单工厂模式</strong>：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li>
<li><strong>工厂方法模式</strong>：用来生产同一等级结构中的固定产品。（支持增加任意产品）</li>
<li><strong>抽象工厂模式</strong>：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）</li>
</ul>
<blockquote>
<p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过定义、new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
</blockquote>
<h4 id="简单工厂模式">3.1 简单工厂模式</h4>
<p>简单工厂模式也叫静态工厂模式，<strong>就是工厂类一般是使用静态方法， 通过接收的参数的不同来返回不同的对象实例</strong>。 其缺陷是对于增加新产品无能为力，不修改代码的话，是无法扩展的。</p>
<p>因此对于简单工厂模式来说客户端只知道传入工厂类的参数，对于如何创建对象，调用什么产品类创建对象不关心，客户端只需要指定工厂类的公共方法即可； <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不同品牌手机的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huawei</span>:<span class="keyword">public</span> Phone</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;HUAWEI&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iPhone</span>:<span class="keyword">public</span> Phone</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;iPhone&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">phone_Factory</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Phone* <span class="title">Create</span><span class="params">(<span class="type">char</span> Type)</span></span>&#123;</span><br><span class="line">		Phone* ret=<span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">switch</span>(Type)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span><span class="number">&#x27;</span>H<span class="number">&#x27;</span>:</span><br><span class="line">				ret=<span class="keyword">new</span> <span class="built_in">Huawei</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span><span class="number">&#x27;</span>i<span class="number">&#x27;</span>:</span><br><span class="line">				ret=<span class="keyword">new</span> <span class="built_in">iPhone</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	Phone* phone_Object=phone_Factory::<span class="built_in">Create</span>(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">	phone_Object-&gt;<span class="built_in">run</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 简单工厂模式中的静态方法根据输入的条件产生不同的类对象。</p>
<ul>
<li><p><strong>优点：</strong>工厂类是整个模式的关键.包含了必要的逻辑判断,根据客户端给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。</p></li>
<li><strong>缺点：</strong>
<ul>
<li>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。</li>
<li>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；</li>
</ul></li>
</ul>
<h4 id="工厂方法模式">3.2 工厂方法模式</h4>
<p>修正了简单工厂模式中不遵守开放－封闭原则。工厂方法模式把选择判断交给客户端去实现，工厂只负责实例化各个实现类；</p>
<p>即工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，内部要逻辑判断实例化哪一个类，<strong>而工厂方法模式有一组继承工厂基类的工厂类，各个工厂类各自实现对应的类实例化，其逻辑判断交由客户端去处理。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Phone* <span class="title">create</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huawei_Factory</span>:<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Phone* <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Phone* ret =<span class="keyword">new</span> <span class="built_in">Huawei</span>();</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iPhone_Factory</span>:<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Phone* <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Phone* ret=<span class="keyword">new</span> <span class="built_in">iPhone</span>();</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Phone* phone1=<span class="keyword">new</span> <span class="built_in">Huawei_Factory</span>().<span class="built_in">create</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>根据设计理论建议：工厂方法模式。但实际上，我们一般都用简单工厂模式。</p>
</blockquote>
</blockquote>
<h4 id="工厂模式的优缺点">3.3 工厂模式的优缺点</h4>
<ul>
<li>可以避免创建者和具体产品之间的紧密耦合。工厂模式创建对象时不会对客户端暴露具体产品创建逻辑，并且是通过使用一个共同的接口来创建的新对象。</li>
<li>单一职责原则。 可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li>
<li>开闭原则。 无需更改现有客户端代码， 就可以在程序中引入新的产品类型。</li>
</ul>
<h4 id="工厂模式的应用场景">3. 4 工厂模式的应用场景</h4>
<ul>
<li><p>当在编写代码的过程中，如果无法预知对象确切类别及其依赖关系，可使用工厂方法。</p>
<p>工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。</p>
<p>例如， 如果需要向应用中添加一种新产品， 只需要开发新的创建者产品子类， 然后重写其工厂方法即可。</p></li>
</ul>
<h4 id="与其他设计模式的关系-1">3.5 与其他设计模式的关系</h4>
<ul>
<li>在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制），随后演化为使用抽象工厂模式、 原型模式或生成器模式（更灵活但更加复杂）。</li>
<li>抽象工厂模式通常基于一组工厂方法， 但也可以使用原型模式来生成这些类的方法。</li>
<li>可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</li>
<li>原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。</li>
<li>工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。与其他设计模式的关系</li>
</ul>
<h3 id="抽象工厂模式">4 抽象工厂模式*</h3>
<p><strong>抽象工厂模式是简单工厂和工厂方法的结合。</strong>工厂类：</p>
<ul>
<li><strong>抽象工厂模式有多个工厂（即抽象工厂-&gt;具体工厂），每个具体工厂又可以生产多种产品；因此抽象工厂模式是多个工厂，每个工厂一对多</strong></li>
<li>简单工厂模式是一个工厂，自己一对多；</li>
<li>工厂方法模式是多个工厂，每个工厂一对一</li>
</ul>
<blockquote>
<p><strong>注意事项</strong>：产品族难扩展，产品等级易扩展。 <strong>何时使用</strong>：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
</blockquote>
<h4 id="section">4.1</h4>
<p>且如果说简单工厂和工厂方法是对单个产品系列，那抽象工厂模式针对的是<strong>产品族</strong>，<strong>用来生产不同产品族的全部产品</strong>。在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。就比如产品类：</p>
<ul>
<li>对于简单工厂和工厂方法，我们只讨论了华为和苹果手机，这样产品类从<code>手机-&gt;(Huawei/iPhone)</code> <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/factory.png" width="600"></li>
<li>而对于抽象工厂模式来说，其产品可对系列来说，比如说多加了一个电脑，这样可以以这样方式设计:<code>抽象产品类-&gt;HUAWEI、iPhone产品工厂-&gt;HUAWEI、iPhone手机/电脑</code> <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/abstract.png" width="600"></li>
</ul>
<p>总结来说抽象工厂如下： <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ab.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">----------------产品-------------------------------------------</span><br><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">product</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">product</span>(<span class="type">int</span> _price):<span class="built_in">prince</span>(_price)&#123;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">product</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getPrince</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> prince;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象产品细分--HUAWEI</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huawei_product</span>:<span class="keyword">public</span> product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Huawei_product</span>(<span class="type">int</span> price,string color):<span class="built_in">product</span>(price),<span class="built_in">m_color</span>(color)&#123;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Huawei_product</span>()&#123;&#125;</span><br><span class="line">	<span class="comment">//获取颜色</span></span><br><span class="line">	<span class="function">string <span class="title">getColor</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_color;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HUAWEI具体产品类：手机和电脑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Huawei_phone</span>:<span class="keyword">public</span> Huawei_product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Huawei_phone</span>(<span class="type">int</span> price,string color,<span class="type">int</span> _type):</span><br><span class="line">		<span class="built_in">Huawei_product</span>(price,color),<span class="built_in">type</span>(_type&#123;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Huawei_phone</span>()&#123;&#125;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">getType</span>()&#123;<span class="keyword">return</span> type;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Huawei_computer:<span class="keyword">public</span> Huawei_computer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Huawei_computer</span>(<span class="type">int</span> price,string color,string _type):</span><br><span class="line">		<span class="built_in">Huawei_product</span>(price,color),<span class="built_in">cpu_type</span>(_type&#123;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Huawei_computer</span>()&#123;&#125;</span><br><span class="line">	string <span class="built_in">getType</span>()&#123;<span class="keyword">return</span> type;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> cpu_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...苹果产品略</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">工厂：</span><br><span class="line"><span class="keyword">class</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> product* <span class="built_in">getPhone</span>()=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span> product* <span class="built_in">getComputer</span>()=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体工厂--HUAWEI工厂</span></span><br><span class="line"><span class="keyword">class</span> Huawei_factory:<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> product* <span class="built_in">getPhone</span>()&#123;</span><br><span class="line">		product* H_phone=<span class="keyword">new</span> <span class="built_in">Huawei_phone</span>(<span class="number">4399</span>,<span class="string">&quot;白色&quot;</span>,<span class="number">203</span>);</span><br><span class="line">		<span class="keyword">return</span> H_phone;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> product* <span class="built_in">getComputer</span>()&#123;</span><br><span class="line">			product* H_computer=<span class="keyword">new</span> <span class="built_in">Huawei_computer</span>(<span class="number">5699</span>,<span class="string">&quot;银色&quot;</span>,<span class="string">&quot;i7-12500h&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> H_computer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂类---Apple</span></span><br><span class="line"><span class="keyword">class</span> Apple_factory:<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> product* <span class="built_in">getPhone</span>()&#123;</span><br><span class="line">		product* A_phone=<span class="keyword">new</span> <span class="built_in">Apple_phone</span>(<span class="number">4399</span>,<span class="string">&quot;白色&quot;</span>,<span class="number">203</span>);</span><br><span class="line">		<span class="keyword">return</span> A_phone;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> product* <span class="built_in">getComputer</span>()&#123;</span><br><span class="line">			product* A_computer=<span class="keyword">new</span> <span class="built_in">Apple_computer</span>(<span class="number">5699</span>,<span class="string">&quot;银色&quot;</span>,<span class="string">&quot;i7-12500h&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> A_computer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="抽象工厂的优缺点">4.2 抽象工厂的优缺点</h4>
<p><strong>优点</strong>：</p>
<ul>
<li>具体类分离。具体产品类在具体工厂的实现中进行了分离和归类。</li>
<li>易于更换产品族。当客户端想要使用哪个整个产品族时，只需要切换具体工厂即可。也避免客户端和具体产品代码的耦合。</li>
<li>利于产品一致性。当产品族的各个产品需要在一起执行时，抽象工厂可以确保客户只操作同系列产品，而不会进行跨品牌的组合</li>
<li>单一职责原则。 可以将产品生成代码抽取到同一位置， 使得代码易于维护。</li>
</ul>
<h4 id="抽象工厂适用场景">4.3 抽象工厂适用场景</h4>
<ul>
<li>如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 不希望代码基于产品的具体类进行构建， 在这种情况下， 可以使用抽象工厂。</li>
<li>抽象工厂提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么就不会生成与应用程序已生成的产品类型不一致的产品。</li>
<li>如果有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。</li>
<li>在设计良好的程序中， 每个类应该仅负责一件事。 如果在应用场景中一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。</li>
</ul>
<h4 id="与其他模式的关系">4.4 与其他模式的关系</h4>
<ul>
<li>在许多设计工作的初期都会使用工厂方法模式（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、原型模式或生成器模式](更灵活但更加复杂）。</li>
<li>生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许在获取产品前执行一些额外构造步骤。</li>
<li>抽象工厂模式通常基于一组工厂方法， 但也可以使用原型模式来生成这些类的方法。</li>
<li>当只需对客户端代码隐藏子系统创建对象的方式时， 可以使用抽象工厂来代替外观模式。</li>
<li>可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</li>
<li>抽象工厂、 生成器和原型都可以用单例模式来实现。</li>
</ul>
<h3 id="建造者生成器模式">5 建造者(生成器)模式*</h3>
<p>当某个类的创建需要很多的其他类组成时，建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>一个 <code>Builder</code> 类会一步一步构造最终的对象。该 <code>Builder</code> 类是独立于其他对象的。</p>
<ul>
<li><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着&quot;一个复杂对象&quot;的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</li>
</ul>
<p><strong>建造者模式的本质：</strong></p>
<ul>
<li><p>存在一个复杂对象，其内部有许多子组件(子对象)。生成器模式分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。</p></li>
<li><p>由于实现了构建和装配的解耦。不同的构建器builder，相同的装配Director，也可以做出不同的对象； 相同的构建器，不同的装配顺序也可以做出不同的对象。<strong>也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</strong></p></li>
</ul>
<blockquote>
<p><strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序，并最终实现复杂对象，而工厂模式使依据需要生成需要的产品</strong> <strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p>
</blockquote>
<h4 id="实现">5.1 实现</h4>
<p>这里以汽车Car为例：<strong>完整的汽车由几个组件组成：发动机、中控、轮胎和外观；即复杂对象是汽车</strong></p>
<p><strong>其过程为：</strong></p>
<ul>
<li>首先肯定有一个复杂类Car，其内部由组件对象成员和各种功能方法</li>
<li>组件类，单一职责，实现各个组件的功能</li>
<li><code>Builder</code>基类作为接口，后续的具体builder类都继承它来实现各个组件的创建，以此达到程序易扩展；同理也有一个<code>Director</code>基类，使组件聚合在一起最终得到我们的Car对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*组件类声明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CenterControl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tyre</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复杂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Engine engine;	<span class="comment">//发动机</span></span><br><span class="line">	CenterControl centerControl;	<span class="comment">//中控</span></span><br><span class="line">	Tyre tyre;		<span class="comment">//轮胎</span></span><br><span class="line">	Facade facade;	<span class="comment">//外观</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//省略set、get方法和其他功能函数</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//组件类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Engine</span>(std::string _name):<span class="built_in">name</span>(_name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CenterControl</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CenterControl</span>(std::string _name):<span class="built_in">name</span>(_name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tyre</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Tyre</span>(std::string _name):<span class="built_in">name</span>(_name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Facade</span>(std::string _name):<span class="built_in">name</span>(_name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Builder和Director基类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Engine <span class="title">builderEngine</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> CenterControl <span class="title">builderCenterControl</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Tyre <span class="title">builderTyre</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Facade <span class="title">builderFacade</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarDirector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//组装函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Car* <span class="title">carDirector</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">---------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrluperCarBuilder</span>:<span class="keyword">public</span> carBuilder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Engine <span class="title">builderEngine</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;trluper发动机&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Engine</span>(<span class="string">&quot;trluper发动机&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> CenterControl <span class="title">builderCenterControl</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;trluper中控&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CenterControl</span>(<span class="string">&quot;trluper中控&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Tyre <span class="title">builderTyre</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;trluper轮胎&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Tyre</span>(<span class="string">&quot;trluper轮胎&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Facade <span class="title">builderFacade</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;trluper外观&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Facade</span>(<span class="string">&quot;trluper外观&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment">//对组件进行组装</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">trluperCarDirector</span>:<span class="keyword">public</span> CarDirector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	TrluperCarBuilder builder;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="built_in">trluperCarDirector</span>(TrluperCarBuilder _builder):<span class="built_in">builder</span>(_builder)&#123;&#125;</span><br><span class="line">	<span class="comment">//进行组装</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Car* <span class="title">carDirector</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//使用builder获得子组件</span></span><br><span class="line">		Engine* engine=builder.<span class="built_in">builderEngine</span>();</span><br><span class="line">		CenterControl centerControl = builder.CenterControl <span class="built_in">builderCenterControl</span>();</span><br><span class="line">		Tyre* tyre=builder. <span class="built_in">builderTyre</span>();</span><br><span class="line">		Facade* facade = builder.<span class="built_in">builderFacade</span>();</span><br><span class="line">		<span class="comment">//组件进行组装</span></span><br><span class="line">		Car car =<span class="keyword">new</span> <span class="built_in">Car</span>();</span><br><span class="line">		car.<span class="built_in">setEngine</span>(engine);</span><br><span class="line">		car.<span class="built_in">setCenterControl</span>(centerControl);</span><br><span class="line">		car.<span class="built_in">setTyre</span>(tyre);</span><br><span class="line">		car.<span class="built_in">setFacade</span>(facade);</span><br><span class="line">		<span class="keyword">return</span> car;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">trluperCarDirector <span class="title">director</span><span class="params">()</span></span>;</span><br><span class="line">	Car* car=director.<span class="built_in">carDirector</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点-1">5.2 优缺点</h4>
<p><strong>优点</strong>：</p>
<ul>
<li>可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。</li>
<li>生成不同形式的产品时， 可以复用相同的制造代码。</li>
<li>单一职责原则。 可以将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li>
</ul>
<h4 id="适用场景-1">5.3 适用场景</h4>
<ul>
<li><p>使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。</p>
<p>假设构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line"><span class="built_in">Pizza</span>(<span class="type">int</span> size) &#123; ... &#125;</span><br><span class="line"><span class="built_in">Pizza</span>(<span class="type">int</span> size, boolean cheese) &#123; ... &#125;</span><br><span class="line"><span class="built_in">Pizza</span>(<span class="type">int</span> size, boolean cheese, boolean pepperoni) &#123; ... &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure> 只有在 C++或 Java 等支持方法重载的编程语言中才能写出如此复杂的构造函数。</p>
<p>生成器模式可以分步骤生成对象， 而且允许仅使用必须的步骤。 应用该模式后， 再也不需要将几十个参数塞进构造函数里了。</p></li>
<li>使用生成器构造组合树或其他复杂对象。
<ul>
<li><p>生成器模式能分步骤构造产品。 可以延迟执行某些步骤而不会影响最终产品。 甚至可以递归调用这些步骤， 这在创建对象树时非常方便。</p></li>
<li><p>生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。</p></li>
</ul></li>
<li><p>当希望使用代码创建不同形式的产品 （例如石头房屋或木头房屋） 时， 可使用生成器模式。</p>
<p>如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。</p>
<p>基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。</p></li>
</ul>
<h4 id="与其他模式的关系-1">5.4 与其他模式的关系</h4>
<ul>
<li><p>在许多设计工作的初期都会使用工厂方法模式（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式（更灵活但更加复杂）。</p></li>
<li><p><strong>生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许在获取产品前执行一些额外构造步骤。</strong></p></li>
<li><p>可以在创建复杂组合模式树时使用生成器， 因为这可使其构造步骤以递归的方式运行。</p></li>
<li><p>可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p></li>
<li><p>抽象工厂、 生成器和原型都可以用单例模式来实现。</p></li>
</ul>
<h3 id="原型模式">6 原型模式*</h3>
<ul>
<li><p><strong>原型模式的设计思想：</strong>在软件系统中，创建某一类型的对象，为了简化创建的过程，可以只创建一个对象，然后通过克隆的方式复制出多个相同的对象。</p></li>
<li><p><strong>原型模式（Prototype Pattern）</strong>：是一种对象创建模式，用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象。</p></li>
<li><p><strong>主要解决：</strong>在运行期建立和删除原型。</p></li>
</ul>
<blockquote>
<p><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p>
</blockquote>
<h4 id="实现-1">6.1 实现</h4>
<ul>
<li><p><strong>（Prototype）抽象原型类</strong>：抽象原型类是定义具有克隆自己的方法的接口，是所有具体原型类的公共父类。</p></li>
<li><p><strong>ConcretePrototype（具体原型类）</strong>：具体原型类实现具体的克隆方法，在克隆方法中返回自己的一个克隆对象。<strong>原型模式说白了就是在类实现克隆操作，提供该接口给客户端调用</strong></p></li>
<li><p><strong>Client (客户端)</strong>：客户端让一个原型克隆自身，从而创建一个新的对象。在客户类中只需要直接实例化或通过工厂方法等创建一个对象，再通过调用该对象的克隆方法复制得到多个相同的对象。</p></li>
</ul>
<p><img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/prototype.png" width="600"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">prototype</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">prototype</span>(string _name,<span class="type">int</span> _id):<span class="built_in">name</span>(_name),<span class="built_in">id</span>(_id)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> prototype* <span class="title">clone</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentPrototype</span>:<span class="keyword">public</span> prototype</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StudentPrototype</span>(string _name,<span class="type">int</span> _id):<span class="built_in">prototype</span>(_name,_id)&#123;&#125;</span><br><span class="line">	<span class="built_in">StudentPrototype</span>(<span class="type">const</span> StudentPrototype&amp; s);</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> prototype* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">		prototype* new_object=<span class="keyword">new</span> <span class="built_in">StudentPrototype</span>(*<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">return</span> new_object;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">StudentPrototype <span class="title">ob1</span><span class="params">(<span class="string">&quot;trluper&quot;</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">	prototype* ob2=ob1.<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>原生模型与拷贝构造函数的区别： <strong>相同点：</strong>原型模式和拷贝构造函数都是要产生对象的复制品。</p>
</blockquote>
<blockquote>
<p><strong>不同点</strong>：原型模式实现的是一个clone接口，注意是接口，也就是基于多态的clone虚函数。也就是说原型模式能够通过基类指针来复制派生类对象。拷贝构造函数完不成这样的任务。</p>
</blockquote>
<blockquote>
<p>原型模式的核心是克隆，构造函数只是克隆的一个办法而已</p>
</blockquote>
<h4 id="优缺点-2">6.2 优缺点</h4>
<p><strong>优点</strong>：</p>
<ul>
<li><p>可以克隆对象， 而无需与它们所属的具体类相耦合</p></li>
<li><p>可以克隆预生成原型， 避免反复运行初始化代码。</p></li>
<li><p>可以更方便地生成复杂对象。</p></li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，当克隆包含循环引用的复杂对象可能会非常麻烦</li>
</ul>
<h4 id="适用场景-2">6.3 适用场景</h4>
<ul>
<li><strong>资源优化场景</strong>：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。通过原生模型的复制可以绕过这些资源消耗
<ul>
<li>对象的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），抑或是需要从 RPC、网络、数据库、文件系统等非常慢速的IO中读取，这个时候就可以利用原型模式从其他对象直接拷贝，从而减少资源的消耗。</li>
</ul></li>
<li><strong>当初始化一个对象需要非常繁琐的数据准备或访问权限时，如构造函数的参数很多，而自己又不完全的知道每个参数的意义，可以考虑原生模型</strong></li>
</ul>
<h4 id="与其他模式的关系-2">6.4 与其他模式的关系</h4>
<ul>
<li><p>在许多设计工作的初期都会使用工厂方法模式（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式（更灵活但更加复杂）。</p></li>
<li><p>抽象工厂模式通常基于一组工厂方法， 但也可以使用原型模式来生成这些类的方法。</p></li>
<li><p>原型可用于保存命令模式的历史记录。</p></li>
<li><p>大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p></li>
<li><p>原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承，但是它不需要初始化步骤。</p></li>
<li><p>有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</p></li>
<li><p>抽象工厂、 生成器和原型都可以用单例模式来实现。</p></li>
</ul>
<blockquote>
<p>原型模式通过复制原型（原型）而获得新对象创建的功能，这里原型本身就是&quot;对象工厂&quot;（因为能够生产对象），实际上原型模式和 <code>Builder</code> 模式、<code>AbstractFactory</code> 模式都是通过一个类（对象实例）来专门负责对象的创建工作（工厂对象），它们之间的区别是： <code>Builder</code> 模式重在复杂对象的一步步创建（并不直接返回对象），<code>AbstractFactory</code> 模式重在产生多个相互依赖类的对象，而原型模式重在从自身复制自己创建新类。</p>
</blockquote>
<h3 id="适配器模式">7 适配器模式*</h3>
<p><strong>适配器模式属于结构型模式，其功能是作为两个不兼容的接口之间的桥梁，它结合了两个独立接口的功能。这个模式涉及到单一的适配器类，该类负责加入独立的或不兼容的接口功能</strong>。如读卡器是作为内存卡和笔记本之间的适配器，将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p>
<ul>
<li><p><strong>作用</strong>：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。因此其主要解决在软件系统中，新环境要求的接口是现对象不能满足的，因此需要适配器类来整合适配。</p></li>
<li><p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。</p></li>
</ul>
<blockquote>
<p><strong>何时使用</strong>： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中</p>
</blockquote>
<blockquote>
<p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
</blockquote>
<h4 id="实现-2">7.1 实现</h4>
<ul>
<li><strong>目标接口（Target）</strong>：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。</li>
<li><strong>需要适配的类（Adaptee）</strong>：需要适配的类或适配者类，客户端需要调用该类，但是没有接口可以调用，需要被适配。</li>
<li><strong>适配器（Adapter）</strong>：通过包装一个需要适配的对象，把原接口转换成目标接口。 <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/adapter.png" width="600"></li>
</ul>
<p>现在举例：顾客进一家服装店的动作为目标接口<code>Target</code>，然后顾客在该店买不同品种的衣服是需要适配的类<code>adaptee</code>,适配器通过继承与目标接口实现相应的适配，即各个客户是买不同的衣服的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target_shop</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Taeget_shop</span>(<span class="type">int</span> _id):<span class="built_in">id</span>(_id)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要适配的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer_shopping</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string Clothname;</span><br><span class="line">	<span class="type">double</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Customer_shopping</span>(string _cloth,<span class="type">double</span> _price):<span class="built_in">Clothname</span>(_cloth),<span class="built_in">price</span>(_price)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShoppingList</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;顾客购买了：&quot;</span>&lt;&lt;Clothname&lt;&lt;<span class="string">&quot;，价格为：&quot;</span>&lt;&lt;price&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer_Adaptor</span>:<span class="keyword">public</span> Target_shop</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Customer_shopping* customer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Customer_Adaptor</span>(<span class="type">int</span> _id,Customer_shopping* cus):<span class="built_in">Target_shop</span>(_id),<span class="built_in">customer</span>(cus)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;id&lt;&lt;<span class="string">&quot;位顾客来店！&quot;</span>&lt;&lt;endl;</span><br><span class="line">		customer-&gt;<span class="built_in">ShoppingList</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Customer_shopping *cus=<span class="keyword">new</span> <span class="built_in">Customer_shopping</span>(<span class="string">&quot;衬衫&quot;</span>,<span class="number">199.0</span>);</span><br><span class="line">	<span class="function">Customer_shopping <span class="title">customer</span><span class="params">(<span class="number">1</span>,cus)</span></span>;</span><br><span class="line">	customer-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="优缺点-3">7.2 优缺点</h4>
<p>优点：</p>
<ul>
<li>可以让任何两个没有关联的类一起运行。</li>
<li>提高了类的复用。</li>
<li>增加了类的透明度。</li>
<li>灵活性好</li>
<li>符合开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li>
</ul>
<p>缺点：</p>
<ul>
<li>代码整体复杂度增加， 因为需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li>
</ul>
<h4 id="适用场景-3">7.3 适用场景</h4>
<ul>
<li><p>当使用某个类时， 但是其接口与其他代码不兼容时， 可以使用适配器类。</p>
<ul>
<li>适配器模式允许创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。</li>
</ul></li>
<li><p>如果需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。</p>
<ul>
<li>我们是可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 必须在所有新子类中重复添加这些代码， 这会显得很不方便。可以通过将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 <strong>这种方式同装饰模式非常相似。</strong></li>
</ul></li>
</ul>
<h4 id="与其他模式的关系-3">7.4 与其他模式的关系</h4>
<ul>
<li><p>桥接模式通常会于开发前期进行设计， 能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p></li>
<li><p>适配器可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p></li>
<li><p>适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</p></li>
<li><p>外观模式为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p></li>
<li><p>桥接、 状态模式和策略模式（在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 还可以使用它们来和其他开发者讨论模式所解决的问题。</p></li>
</ul>
<h3 id="桥接模式">8 桥接模式*</h3>
<p><strong>桥接（Bridge）模式属于结构型模式，</strong>通过提供抽象化和实现化之间的桥接结构<strong>，使得二者可以独立变化。</strong></p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响</p>
<ul>
<li><strong>主要解决</strong>：在有多种可能会变化的情况下，用继承会造成类爆炸的问题，扩展起来不灵活。
<ul>
<li><p>桥接模式可以取代多层继承的方案。</p></li>
<li><p>多层继承违背了单一职责原则， 复用性较差，类的个数也非常多。桥接模式可以极大的减少子类的个 数，从而降低管理和维护的成本。极大的提高了系统可扩展性，在两个变化维度中任意扩展一 个维度，都不需要修改原有的系统，符合开闭原则。</p></li>
</ul></li>
</ul>
<blockquote>
<p>比如说游戏里面有成长进化的武器、宠物，其都是由基础武器、基础宠物成长而来，这样如果采用继承，则会有很多子类，且随着游戏版本迭代，武器子类只会越来越多，此时使用桥接模式是可采纳的</p>
</blockquote>
<p>抽象部分 （也被称为接口） 是一些实体的高阶控制层。** 该层自身不完成任何具体的工作， 它需要将工作委派给实现部分层 （也被称为平台）**</p>
<h4 id="实现-3">8.1 实现</h4>
<p>以游戏装备为例：有两个基类<strong>基础打野刀</strong>和**进化打野刀，如果按继承我们应该是三个进化打野刀继承与基础打野刀的，现在我们采用桥接的模式：在两个基类当中建立桥接结构： <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/bridge.png" width="600"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进化打野刀基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeniorJungle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//战士</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zhanshi</span>:<span class="keyword">public</span> SeniorJungle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;这是战士打野刀&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fashi</span>:<span class="keyword">public</span> SeniorJungle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;这是法师打野刀&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cike</span>:<span class="keyword">public</span> SeniorJungle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;这是刺客打野刀&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">basicJungle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	SeniorJungle* ptr_senior;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretebasicJungle</span>:<span class="keyword">public</span> basicJungle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;你够买了基础打野刀，你可以选择进化为战士/法师/刺客打野刀&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(SeniorJungle* _ptr)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ptr_senior=_ptr;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;升级成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SeniorJungle* senior=<span class="keyword">new</span> <span class="built_in">Cike</span>();</span><br><span class="line">	ConcretebasicJungle* con=<span class="keyword">new</span> <span class="built_in">ConcretebasicJungle</span>();</span><br><span class="line">	con.<span class="built_in">run</span>();</span><br><span class="line">	con-&gt;<span class="built_in">update</span>(senior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点-4">8.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li>符合开闭原则。 可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li>
<li>符合单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</li>
<li>实现细节对客户透明。客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。因此对高内聚的类使用该模式可能会让代码更加复杂。</li>
</ul>
<h4 id="适用场景-4">8.3 适用场景</h4>
<ul>
<li><p>1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</p></li>
<li><p>2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</p></li>
<li><p>3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p></li>
</ul>
<h4 id="与其他模式的关系-4">8.4 与其他模式的关系</h4>
<ul>
<li><p>桥接模式通常会于开发前期进行设计， 使能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p></li>
<li><p>桥接、 状态模式和策略模式（在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 还可以使用它们来和其他开发者讨论模式所解决的问题。</p></li>
<li><p>可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p></li>
<li><p>可以结合使用生成器模式和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p></li>
</ul>
<h3 id="装饰模式">9 装饰模式*</h3>
<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<ul>
<li><p><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀</p></li>
<li><p><strong>何时使用</strong>：在不想增加很多子类的情况下扩展类。</p></li>
</ul>
<h4 id="实现-4">9.1 实现</h4>
<ul>
<li>首先有一个基类,其有相应的功能方法；</li>
<li>后续的装饰器类<code>Decirator</code>继承于他，而具体的装饰类<code>decorator_xx</code>继承与装饰器类<code>Decorator</code>，实现添加新功能，即装饰目的</li>
<li><p>同样，后续的具<strong>体被装饰类也会继承基类，实现一些共同方法</strong> <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/decorator.png" width="600"></p></li>
<li>这里还是以汽车<code>Car</code>为例，</li>
<li>其有一个子类位<code>BenzCar</code>，该子类实现一些正常功能；</li>
<li><p>同样还有还有一个<code>Decorator</code>装饰器类继承与<code>Car</code>，在装饰器类的子类实现该类型车的不同颜色的喷漆操作，这里以白色为例<code>WhiteBenzCarDecorator</code></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">double</span> price;</span><br><span class="line">	string type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">Car</span>(<span class="type">double</span> _price, string _type) :<span class="built_in">price</span>(_price), <span class="built_in">type</span>(_type) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CarIntroduction</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">//Benz类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span> :<span class="keyword">public</span> Car &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Benz</span>(<span class="type">double</span> _price, string _type) :<span class="built_in">Car</span>(_price, _type) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CarIntroduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这辆是Benz,价格为：&quot;</span> &lt;&lt; price &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">//装饰器基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> :<span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Car* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Decorator</span>(Car* _ptr) :<span class="built_in">ptr</span>(_ptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体装饰类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhiteBenzCarDecorator</span> :<span class="keyword">public</span> Decorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WhiteBenzCarDecorator</span>(Car* _ptr) :<span class="built_in">Decorator</span>(_ptr) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CarIntroduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ptr-&gt;<span class="built_in">CarIntroduction</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;补充一点，您看的现在这款是白色的！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Benz <span class="title">car</span><span class="params">(<span class="number">350000</span>,<span class="string">&quot;Benz&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">WhiteBenzCarDecorator <span class="title">decoratorBenz</span><span class="params">(&amp;car)</span></span>;</span><br><span class="line">	decoratorBenz.<span class="built_in">CarIntroduction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点-5">9.2 优缺点</h4>
<p><strong>优点</strong></p>
<ul>
<li>装饰模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</li>
<li>装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>产生很多小对象。大量小对象占据内存，一定程度上影响性能。</li>
</ul>
<h4 id="应用场景">9.3 应用场景</h4>
<ul>
<li>如果希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。
<ul>
<li>装饰能将业务逻辑组织为层次结构， 可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。</li>
</ul></li>
<li>如果用继承来扩展对象行为的方案难以实现或者根本不可行， 可以使用该模式。
<ul>
<li>许多编程语言使用 <code>final</code>最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。</li>
</ul></li>
</ul>
<h4 id="与其他模式的关系-5">9.4 与其他模式的关系</h4>
<ul>
<li><p>适配器模式可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p></li>
<li><p>适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</p></li>
<li><p>责任链模式和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p></li>
<li><p>责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p></li>
<li><p>组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p></li>
<li><p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>但是， 模式也可以相互合作： 可以使用装饰来扩展组合树中特定对象的行为。</p></li>
<li><p>大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p></li>
<li><p>装饰可更改对象的外表， 策略模式则能够改变其本质。</p></li>
<li><p>装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p></li>
<li><p>装饰模式和桥接模式的区别：两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。</p></li>
</ul>
<h3 id="组合模式">10 组合模式*</h3>
<p>组合模式（Composite Pattern）是结构型模式。<strong>组合模式又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</strong>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<ul>
<li><strong>主要解决</strong>：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦</li>
</ul>
<h4 id="实现-5">10.1 实现</h4>
<ul>
<li><strong>抽象构件(Component)角色:</strong> 定义了叶子和容器构件的共同点</li>
<li><strong>叶子(Leaf)构件角色</strong>：无子节点</li>
<li><strong>容器(Composite)构件角色</strong>： 有容器特征，可以包含子节点</li>
</ul>
<p>模拟病毒文件和文件夹查杀：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*抽象构建</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFile</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AbstractFile</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">killVirus</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*叶子构建角色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImgeFile</span> :<span class="keyword">public</span> AbstractFile</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ImgeFile</span>(std::string _name) : <span class="built_in">name</span>(_name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">killVirus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;图像文件&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;：开始病毒查杀！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wordFile</span> :<span class="keyword">public</span> AbstractFile</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">wordFile</span>(std::string _name) : <span class="built_in">name</span>(_name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">killVirus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;文档文件&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;：开始病毒查杀！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*容器构建角色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FloderFile</span> :<span class="keyword">public</span> AbstractFile</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	std::vector&lt;AbstractFile*&gt;vec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FloderFile</span>(std::string _name) :<span class="built_in">name</span>(_name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(AbstractFile* file)</span> </span>&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(file);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(AbstractFile* file)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), file);</span><br><span class="line">		<span class="keyword">if</span> (it != vec.<span class="built_in">end</span>())</span><br><span class="line">			vec.<span class="built_in">erase</span>(it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">AbstractFile* <span class="title">getFile</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (index &lt; vec.<span class="built_in">size</span>() &amp;&amp; index &gt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> vec[index];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">killVirus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;文件夹&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;:开始查杀病毒！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it : vec)</span><br><span class="line">			it-&gt;<span class="built_in">killVirus</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//客户端调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AbstactFile* leaf_1=<span class="keyword">new</span> <span class="built_in">wordFile</span>(<span class="string">&quot;trluper.doc&quot;</span>);</span><br><span class="line">	AbstractFile* leaf_2=<span class="keyword">new</span> <span class="built_in">ImgeFile</span>(<span class="string">&quot;trluper.png&quot;</span>);</span><br><span class="line">	FloderFile* floder=<span class="keyword">new</span> <span class="built_in">FloderFile</span>(<span class="string">&quot;我的文件夹&quot;</span>);</span><br><span class="line">	floder-&gt;<span class="built_in">add</span>(leaf_1);</span><br><span class="line">	floder-&gt;<span class="built_in">add</span>(leaf_2);</span><br><span class="line">	floder-&gt;<span class="built_in">killVirus</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点-6">10.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li><p>可以利用多态和递归机制更方便地使用复杂树结构。</p></li>
<li><p>开闭原则。 无需更改现有代码， 就可以在应用中添加新元素， 使其成为对象树的一部分。</p></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 需要过度一般化组件接口， 使其变得令人难以理解</p></li>
<li><p>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p></li>
</ul>
<h4 id="适用场景-5">10.3 适用场景</h4>
<ul>
<li>部分、整体场景，如树形菜单，文件、文件夹的管理。</li>
<li>如果希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。 组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。</li>
</ul>
<h4 id="与其他模式的关系-6">10.4 与其他模式的关系</h4>
<ul>
<li><p>桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 还可以使用它们来和其他开发者讨论模式所解决的问题。</p></li>
<li><p>可以在创建复杂组合树时使用生成器模式， 因为这可使其构造步骤以递归的方式运行。</p></li>
<li><p>责任链模式通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p></li>
<li><p>可以使用迭代器模式来遍历组合树。</p></li>
<li><p>可以使用访问者模式对整个组合树执行操作。</p></li>
<li><p>可以使用享元模式实现组合树的共享叶节点以节省内存。</p></li>
<li><p>组合和装饰模式的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p></li>
<li><p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p></li>
<li><p>但是， 模式也可以相互合作： 可以使用装饰来扩展组合树中特定对象的行为。</p></li>
<li><p>大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p></li>
</ul>
<h3 id="外观模式">11 外观模式*</h3>
<p><strong>外观模式为结构性模式，其为子系统提供统一的入口（门面），封装子系统的复杂性，便于客户端调用。</strong>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<ul>
<li><strong>主要解决</strong>：降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。</li>
<li><strong>何时使用：</strong>
<ul>
<li>1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个&quot;接待员&quot;即可。</li>
<li>2、定义系统的入口。</li>
</ul></li>
</ul>
<h4 id="实现-6">11.1 实现</h4>
<ul>
<li>外观模式，最重要的是外观类(这个模式也就只有这一个类)，其提供统一入口: <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/facade.png" width="600"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*子系统</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span>:<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;这是Benz&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span>:pubic Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;这是BMW&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BYD</span>:<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;这是BYD&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*外观类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade_Car</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Benz* car1;</span><br><span class="line">	BMW* car2;</span><br><span class="line">	BYD* car3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Facade_Car</span>()&#123;</span><br><span class="line">		car1=<span class="keyword">new</span> <span class="built_in">Benz</span>();</span><br><span class="line">		car2=<span class="keyword">new</span> <span class="built_in">BMW</span>();</span><br><span class="line">		car3=<span class="keyword">new</span> <span class="built_in">BYD</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">delete</span>()&#123;</span><br><span class="line">		<span class="keyword">delete</span> car1;</span><br><span class="line">		<span class="keyword">delete</span> car2;</span><br><span class="line">		<span class="keyword">delete</span> car3;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BenzPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		car1-&gt;<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BMWPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">		car2-&gt;<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">BYDprint</span><span class="params">()</span></span>&#123;</span><br><span class="line">		car3-&gt;<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Facade_Car* test=<span class="keyword">new</span> <span class="built_in">Facade_Car</span>();</span><br><span class="line">	test-&gt;<span class="built_in">BenzPrint</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点-7">11.2 优缺点</h4>
<p><strong>优点</strong>：</p>
<ul>
<li>可以让自己的代码独立于复杂子系统。减少系统相互依赖，提高灵活性，也提高了安全性</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</li>
</ul>
<h4 id="适用场景-6">11.3 适用场景</h4>
<ul>
<li><p>如果需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。</p>
<p>子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。</p></li>
<li><p>如果需要将子系统组织为多层结构， 可以使用外观。</p>
<p>创建外观来定义子系统中各层次的入口。 可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。</p></li>
</ul>
<h4 id="与其他模式的关系-7">11.4 与其他模式的关系</h4>
<ul>
<li>外观模式为现有对象定义了一个新接口， 适配器模式则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</li>
<li>当只需对客户端代码隐藏子系统创建对象的方式时， 可以使用抽象工厂模式来代替外观。</li>
<li>享元模式展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。</li>
<li>外观和中介者模式的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。
<ul>
<li>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</li>
<li>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</li>
</ul></li>
<li>外观类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。</li>
<li>外观与代理模式的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</li>
</ul>
<h3 id="享元模式">12 享元模式*</h3>
<p><strong>享元模式属于结构性模式，享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能</strong>。内存属于稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。</p>
<p><strong>享元模式以尝试共享的方式高效地支持大量细粒度对象的重用，如果未找到匹配的对象，则创建新对象</strong>。享元对象能做到共享的关键是区分了内部</p>
<ul>
<li><strong>主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建</strong></li>
</ul>
<p><strong>元对象能做到共享的关键是区分了内部状态和外部状态，必须划分外部状态和内部状态，否则可能会引起线程安全问题。</strong></p>
<ul>
<li>内部状态：可以共享，不会随环境变化而改变</li>
<li>外部状态：不可以共享，会随环境变化而改变</li>
</ul>
<h4 id="实现-7">12.1 实现</h4>
<ul>
<li><code>FlyweightFactory</code>享元工厂类:创建并管理享元对象，享元池一般设计成键值对</li>
<li><code>FlyWeight</code>抽象享元类:通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，同时可以设置外部状态</li>
<li><code>ConcreteFlyWeight</code>具体享元类:为内部状态提供成员变量进行存储</li>
<li><code>UnsharedConcreteFlyWeight</code>非共享享元类:不能被共享的子类可以设计为非共享享元类</li>
</ul>
<p>实例：这里用多用户访问一个相同网站为例，网站这个对象应该共享，而用户的鉴权的密码应该是共享的 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象享元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flyweight</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Use</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//具体非共享用户信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightUserInfo</span>:<span class="keyword">public</span> Flyweight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string account;</span><br><span class="line">	string secretKey;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string Username;</span><br><span class="line">	<span class="built_in">FlyweightUserInfo</span>(string _name,string _secretKey):</span><br><span class="line">		<span class="built_in">acount</span>(_name),<span class="built_in">secretKey</span>(_secretKey)&#123;</span><br><span class="line">		<span class="comment">//数据库鉴权..省略</span></span><br><span class="line">		Username=sqlname;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;登录成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Use</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;正在访问共享网站&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体共享网站</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightWebsite</span>:<span class="keyword">public</span> Flyweight&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	FlyweightUserInfo* uInfo;</span><br><span class="line">	<span class="built_in">FlyweightWebsite</span>(string s,Flyweight* _info):<span class="built_in">str</span>(s),<span class="built_in">uInfo</span>(_info)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Use</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;uInfo-&gt;Username&lt;&lt;<span class="string">&quot;,你好！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//享元工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Map&lt;string,Flyweight*&gt;myMap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FlyweightFactory</span>()&#123;&#125;</span><br><span class="line">	<span class="function">FlyweightWebsite* <span class="title">getFlyshared</span><span class="params">(string s,Flyweight* _info)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(map[s]!=myMap.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">return</span> myMap[s];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			myMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,Flyweight*&gt;(s,<span class="keyword">new</span> <span class="built_in">FlyweightWebsite</span>(s,_info)));</span><br><span class="line">		<span class="keyword">return</span> myMap[s];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//非共享鉴权</span></span><br><span class="line">	Flyweight* user=<span class="keyword">new</span> <span class="built_in">FlyweightUserInfo</span>(<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line">	FlyweightFactory* fac =<span class="keyword">new</span> <span class="built_in">FlyweightFactory</span>();</span><br><span class="line">	Flyweight* web = fac-&gt;<span class="built_in">getFlyshared</span>(<span class="string">&quot;设计模式&quot;</span>,user);</span><br><span class="line">	web-&gt;<span class="built_in">Use</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="优缺点-8">12.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li>极大减少内存中对象的数量</li>
<li>相同或相似对象内存中只存一份，极大的节约资源，提高系统性能</li>
<li>外部状态相对独立，不影响内部状态</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>模式较复杂，使程序逻辑复杂化</li>
<li>为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间</li>
</ul>
<h4 id="适用场景-7">12.3 适用场景</h4>
<ul>
<li><p><strong>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式</strong>。应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：</p>
<ul>
<li>程序需要生成数量巨大的相似对象</li>
<li>这将耗尽目标设备的所有内存</li>
<li>对象中包含可抽取且能在多个对象间共享的重复状态。</li>
</ul></li>
<li><p>还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用较少的共享对象取代多组对象，此时可以考虑使用享元。</p></li>
</ul>
<h4 id="与其他模式的关系-8">12.4 与其他模式的关系</h4>
<ul>
<li>可以使用享元模式实现组合模式树的共享叶节点以节省内存。</li>
<li>享元展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。</li>
<li>如果能将对象的所有共享状态简化为一个享元对象， 那么享元就和单例模式类似了。 但这两个模式有两个根本性的不同：
<ul>
<li>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。 享元对象是不可变的。</li>
</ul></li>
</ul>
<h3 id="代理模式">13 代理模式*</h3>
<p><strong>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式</strong>。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<ul>
<li><p><strong>意图</strong>：为其他对象提供一种代理以控制对这个对象的访问。</p></li>
<li><p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p></li>
</ul>
<h4 id="实现-8">13.1 实现</h4>
<ul>
<li>抽象角色：定义代理角色和真实角色的公共对外方法</li>
<li>真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。（关注真正的业务逻辑）</li>
<li>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。（将统一的流程控制放到代理角色中处理！）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span>=<span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//真实类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealClass</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;真实的请求&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyClass</span> : <span class="keyword">public</span> Interface</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	RealClass* m_realClass; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_realClass= <span class="keyword">new</span> <span class="built_in">RealClass</span>(); </span><br><span class="line">		m_realClass­&gt;<span class="built_in">Request</span>(); </span><br><span class="line">		<span class="keyword">delete</span> m_realClass; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">客户端：</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123; </span><br><span class="line">	ProxyClass* test=<span class="keyword">new</span> <span class="built_in">ProxyClass</span>(); </span><br><span class="line">	test­&gt;<span class="built_in">Request</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-9">13.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li>可以在客户端毫无察觉的情况下控制服务对象。</li>
<li>如果客户端对服务对象的生命周期没有特殊要求， 可以对生命周期进行管理。</li>
<li>即使服务对象还未准备好或不存在， 代理也可以正常工作。</li>
<li>开闭原则。 可以在不对服务或客户端做出修改的情况下创建新代理。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li>
<li>2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂，因为要创建许多新的类。</li>
</ul>
<h4 id="应用场景-1">13.3 应用场景</h4>
<p><strong>按职责来划分，通常有以下使用场景</strong>：</p>
<ul>
<li><p><strong>延迟初始化 （虚拟代理）</strong>。 如果有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</p></li>
<li><p><strong>访问控制 （保护代理）</strong>。 如果只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此<strong>时可使用代理模式。代理可仅在客户端凭据满足要求时将请求传递给服务对象。</strong></p></li>
<li><p>本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。</p></li>
<li><p><strong>记录日志请求 （日志记录代理）</strong>。 <strong>适用于当需要保存对于服务对象的请求历史记录时。代理可以在向服务传递请求前进行记录。</strong></p></li>
<li><p><strong>缓存请求结果 （缓存代理）</strong>。<strong>适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。</strong></p>
<p>代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。</p></li>
<li><p>智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。</p>
<p>代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。</p>
<p>代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。</p></li>
</ul>
<h4 id="与其他模式的关系-9">13.4 与其他模式的关系</h4>
<ul>
<li><p>适配器模式能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。</p></li>
<li><p>外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p></li>
<li><p>装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p></li>
</ul>
<h3 id="模板方法模式">14 模板方法模式</h3>
<p>模版方法定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。把不变的代码部分都转移到父类中， 将可变的代码用 virtual 留到子类重写</p>
<ul>
<li><strong>主要解决</strong>：一些方法通用，却在每一个子类都重新写了这一方法</li>
</ul>
<h4 id="实现-9">14.1 实现</h4>
<p><img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/moudle.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象算法骨架</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="comment">//通用方法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;我是&quot;</span>&lt;&lt;<span class="built_in">GetName</span>()&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">GetName</span><span class="params">()</span></span>=<span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子类实现具体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Naruto</span> : <span class="keyword">public</span> AbstractClass </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;火影史上最帅的六代目­­­一鸣惊人 naruto&quot;</span>; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> OnePice : <span class="keyword">public</span> AbstractClass </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">protected</span>: </span><br><span class="line">	<span class="keyword">virtual</span> string <span class="built_in">GetName</span>()</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;我是无恶不做的大海贼­­­路飞&quot;</span>; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123; </span><br><span class="line">	Naruto* man = <span class="keyword">new</span> <span class="built_in">Naruto</span>(); </span><br><span class="line">	man­&gt;<span class="built_in">Show</span>(); </span><br><span class="line">	OnePice* man2 = <span class="keyword">new</span> <span class="built_in">OnePice</span>(); </span><br><span class="line">	man2­&gt;<span class="built_in">Show</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="优缺点-10">14.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li>封装不变部分，扩展可变部分。</li>
<li>提取公共代码，便于维护。</li>
<li>行为由父类控制，子类实现。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li>
</ul>
<h4 id="适用场景-8">14.3 适用场景</h4>
<ul>
<li>有多个子类共有的方法，且逻辑相同时可考虑</li>
<li>重要的、复杂的方法，可以考虑作为模板方法。</li>
</ul>
<h3 id="命令模式">15 命令模式*</h3>
<p>命令模式属于行为型模式。<strong>请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</strong>。</p>
<ul>
<li><p><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化</p></li>
<li><p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p></li>
<li><p><strong>何时使用：</strong>在某些场合，比如要对行为进行&quot;记录、撤销/重做、事务&quot;等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将&quot;行为请求者&quot;与&quot;行为实现者&quot;解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p></li>
</ul>
<blockquote>
<p><strong>注意事项</strong>：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式</p>
</blockquote>
<h4 id="实现-10">15.1 实现</h4>
<ul>
<li><code>Command</code>抽象命令类</li>
<li><code>ConcreteCommand</code>具体命令类</li>
<li><code>Invoker</code>请求的调用者/请求者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的<code>execute</code>方法，间接调用接受者的相关操作</li>
<li><code>Receiver</code>接收者：接收者执行与请求相关的操作，具体实现对请求的业务处理。（实际执行操作内容的对象）</li>
<li><code>Client</code>客户类，需要创建调用者对象，具体命令类对象，在创建具体命令类对象时指定对应的接受者。发送者和接收者之间没有直接关系，都通过命令对象间接调用 <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/command.png" width="600"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//命令接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reciver</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Reciver</span>(std::string _name) :<span class="built_in">name</span>(_name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeLunch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;忙碌了一早上的&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;开始做午餐了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDinner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;忙碌了一天的&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;开始做晚餐了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//命令抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Reciver* reciver;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Command</span>(Reciver* rec) :<span class="built_in">reciver</span>(rec) &#123;&#125;</span><br><span class="line">	<span class="comment">//命令</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体命令,午餐命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LunchCommand</span> :<span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LunchCommand</span>(Reciver* rec) :<span class="built_in">Command</span>(rec) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		reciver-&gt;<span class="built_in">MakeLunch</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体命令，晚餐命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DinnerCommand</span> :<span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DinnerCommand</span>(Reciver* rec) : <span class="built_in">Command</span>(rec) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		reciver-&gt;<span class="built_in">MakeDinner</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//请求调用着</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;Command*&gt;Command_list;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addCommand</span><span class="params">(Command* cmd)</span> </span>&#123;</span><br><span class="line">		Command_list.<span class="built_in">push_back</span>(cmd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = Command_list.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">while</span> (it != Command_list.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			(*it)-&gt;<span class="built_in">Execute</span>();</span><br><span class="line">			++it;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Reciver* zhang=<span class="keyword">new</span> <span class="built_in">Reciver</span>(<span class="string">&quot;张师傅&quot;</span>);</span><br><span class="line">	Command* cmd1=<span class="keyword">new</span> <span class="built_in">LunchCommand</span>(zhang);</span><br><span class="line">	Command* cmd2=<span class="keyword">new</span> <span class="built_in">DinnerCommand</span>(zhang);</span><br><span class="line">	Invoker invoker;</span><br><span class="line">	invoker.<span class="built_in">addCommand</span>(cmd1);</span><br><span class="line">	invoker.<span class="built_in">addCommand</span>(cmd2);</span><br><span class="line">	invoker.<span class="built_in">Notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点-11">15.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li>单一职责原则。 可以解耦触发和执行操作的类。</li>
<li>开闭原则。 可以在不修改已有客户端代码的情况下在程序中创建新的命令。</li>
<li>可以实现撤销和恢复功能。</li>
<li>可以实现操作的延迟执行。</li>
<li>可以将一组简单命令组合成一个复杂命令。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类，代码可能会变得更加复杂。</li>
</ul>
<h4 id="适用场景-9">15.3 适用场景</h4>
<ul>
<li><p>1.在某些场合，比如要对行为进行&quot;记录、撤销/重做、事务&quot;等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将&quot;行为请求者&quot;与&quot;行为实现者&quot;解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p></li>
<li><p>2.如果需要通过操作来参数化对象， 可使用命令模式。 命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。</p></li>
<li><p>3.如果想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式. 同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 还可以将命令放入队列、 记录命令或者通过网络发送命令。</p></li>
<li><p>4.如果想要实现操作回滚功能， 可使用命令模式。 尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。</p>
<p>为了能够回滚操作， 需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。</p>
<p>这种方法有两个缺点。 首先， 程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 可以使用备忘录模式来在一定程度上解决这个问题。</p>
<p>其次， 备份状态可能会占用大量内存。 因此， 有时需要借助另一种实现方式： 命令无需恢复原始状态， 而是执行反向操作。 反向操作也有代价： 它可能会很难甚至是无法实现。</p></li>
</ul>
<h3 id="迭代器模式">16 迭代器模式</h3>
<p><strong>提供一种方法顺序访问一个聚敛对象的各个元素，而又不暴露该对象的 内部表示。 </strong></p>
<p>为遍历不同的聚集结构提供如开始，下一个，是否结束，当前一项等统一接口</p>
<ul>
<li><strong>主要解决</strong>：不同的方式来遍历整个整合对象。</li>
</ul>
<h4 id="实现-11">16.1 实现</h4>
<p><img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/iterator.png" width="700"> - 迭代器抽象类，声明一些迭代器常用的方法，如`begin\end++</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">MyVector</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 迭代器类抽象类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T* <span class="title">first</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T* <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体迭代器类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> :<span class="keyword">public</span> MyIterator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line">	MyVector&lt;T&gt;* ptr_toV;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcreteIterator</span>(MyVector&lt;T&gt;* _ptr) :<span class="built_in">index</span>(<span class="number">0</span>), <span class="built_in">ptr_toV</span>(_ptr) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T* <span class="title">first</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!ptr_toV-&gt;<span class="built_in">Empty</span>())</span><br><span class="line">			<span class="keyword">return</span> &amp;ptr_toV-&gt;vec[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T* <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		++index;</span><br><span class="line">		<span class="keyword">if</span> (index &lt; ptr_toV-&gt;Size)</span><br><span class="line">			<span class="keyword">return</span> &amp;ptr_toV-&gt;vec[index];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 容器聚合，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RONGQI</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Push_back</span><span class="params">(T val)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVector</span> :<span class="keyword">public</span> RONGQI&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;T&gt; vec;</span><br><span class="line">	ConcreteIterator&lt;T&gt;* iter;		<span class="comment">//迭代器</span></span><br><span class="line">	<span class="type">int</span> Size;</span><br><span class="line">	<span class="type">int</span> elemNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyVector</span>() &#123; </span><br><span class="line">		iter = <span class="keyword">new</span> <span class="built_in">ConcreteIterator</span>&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Push_back</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(val);</span><br><span class="line">		++elemNum;</span><br><span class="line">		++Size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (elemNum == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ConcreteIterator&lt;T&gt;* <span class="title">getIter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ConcreteIterator&lt;T&gt;* MyVector&lt;T&gt;::<span class="built_in">getIter</span>() &#123;</span><br><span class="line">	<span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyVector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	ConcreteIterator&lt;<span class="type">int</span>&gt;* itr = vec.<span class="built_in">getIter</span>();</span><br><span class="line">	vec.<span class="built_in">Push_back</span>(<span class="number">1</span>);</span><br><span class="line">	vec.<span class="built_in">Push_back</span>(<span class="number">2</span>);</span><br><span class="line">	vec.<span class="built_in">Push_back</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; *itr-&gt;<span class="built_in">first</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *itr-&gt;<span class="built_in">next</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点-12">16.2 优缺点</h4>
<p>优点：</p>
<ul>
<li>单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。</li>
<li>开闭原则。 可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。</li>
<li>可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。</li>
<li>相似的， 可以暂停遍历并在需要时继续。</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。</li>
<li>对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。</li>
</ul>
<blockquote>
<p>在C++ STL库中已经提供迭代器的实现。本文的实现主要是了解迭代器的大致原理。</p>
</blockquote>
<h4 id="适用场景-10">16.3 适用场景</h4>
<ul>
<li><p>当集合背后为复杂的数据结构， 且希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</p>
<p>迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。</p></li>
<li><p>使用该模式可以减少程序中重复的遍历代码。</p>
<p>重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。</p></li>
<li><p>如果希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</p>
<p>该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。</p></li>
</ul>
<h4 id="与其他模式的关系-10">16.4 与其他模式的关系</h4>
<ul>
<li><p>可以使用迭代器模式来遍历组合模式树。</p></li>
<li><p>可以同时使用工厂方法模式和迭代器来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</p></li>
<li><p>可以同时使用备忘录模式和迭代器来获取当前迭代器的状态， 并且在需要的时候进行回滚。</p></li>
<li><p>可以同时使用访问者模式和迭代器来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。</p></li>
</ul>
<h3 id="观察者模式">17 观察者模式*</h3>
<p>我们可以把多个订阅者、客户称之为观察者； 需要同步给多个订阅者的数据封装到对象中，称之为目标。</p>
<ul>
<li><p><strong>意图</strong>：观察者模式主要用于1:N的通知。当一个对象（目标对象<code>Subject</code>或<code>Objservable</code>的状态变化时，它需要及时告知一系列对象（观察者对象<code>Observer</code>），令它们作出响应</p></li>
<li><p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p></li>
<li><p><strong>何时使用</strong>：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p></li>
</ul>
<p><strong>通知观察者的方式有：</strong></p>
<ul>
<li>推：每次都会把通知以广播方式发送给所有观察者，所有观察者只能被动接收</li>
<li>拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定</li>
</ul>
<h4 id="实现-12">17.1 实现</h4>
<p><img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/observer.png" width="600"></p>
<ul>
<li>首先是目标类，在目标类内定义一集合保存观察者对象，当目标类发生变化时，调用通知接口<code>Notify</code>通知观察者们</li>
<li>观察者类（多个），收到通知会根据自身条件响应</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#icclude <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namspace std;</span><br><span class="line"><span class="comment">//class targetSubject;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者类：这里这举一个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Observer</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Respond</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StockObserver</span>:<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	targetSubject* target;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StockObserver</span>(string _name):<span class="built_in">name</span>(_name)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Respond</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;name&lt;&lt;<span class="string">&quot;：服务器发生变化了,我要&quot;</span>&lt;&lt;target-&gt;action&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">targetSubject</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string action;	<span class="comment">//状态</span></span><br><span class="line">	vector&lt;Observer*&gt; observers;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">targetSubject</span>(string _action):<span class="built_in">action</span>(_action)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Observer* optr)</span></span>&#123;</span><br><span class="line">		observers.<span class="built_in">push_back</span>(optr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		vector&lt;Observer*&gt;::iterator p= observers.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">while</span>(p!=observers.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			(*p)-&gt;<span class="built_in">Respond</span>();</span><br><span class="line">			p++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setaction</span><span class="params">(string _action)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;action=_action;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	targetSubject *p=<span class="keyword">new</span> <span class="built_in">targetSubject</span>(<span class="string">&quot;开始工作&quot;</span>);  <span class="comment">//创建通知者</span></span><br><span class="line">	<span class="comment">//观察者</span></span><br><span class="line">	StockObserver *s1= <span class="keyword">new</span> <span class="built_in">StockObserver</span>(<span class="string">&quot;小李&quot;</span>,p); </span><br><span class="line">	StockObserver *s2 = <span class="keyword">new</span> <span class="built_in">StockObserver</span>(<span class="string">&quot;小赵&quot;</span>,p); </span><br><span class="line">	<span class="comment">//加入通知队列</span></span><br><span class="line">	p-&gt;<span class="built_in">Add</span>(s1); </span><br><span class="line">	p-&gt;<span class="built_in">Add</span>(s2); </span><br><span class="line">	<span class="comment">//通知</span></span><br><span class="line">	p-&gt;<span class="built_in">Notify</span>(); </span><br><span class="line">	<span class="comment">//更改状态</span></span><br><span class="line">	p-&gt;<span class="built_in">setaction</span>(<span class="string">&quot;休息&quot;</span>);</span><br><span class="line">	<span class="comment">//通知</span></span><br><span class="line">	p-&gt;<span class="built_in">Notify</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点-13">17.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li>1、观察者和被观察者是抽象耦合的。</li>
<li>2、建立一套触发机制，A发生变化，与它相关的会收到这种变化通知，然后依据自身条件是否响应。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
<li>3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
<h4 id="适用场景-11">17.3 适用场景</h4>
<ul>
<li><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</p></li>
<li><p>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</p></li>
<li><p>一个对象必须通知其他对象，而并不知道这些对象是谁。</p></li>
<li><p>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</p></li>
</ul>
<h3 id="中介者模式">18 中介者模式*</h3>
<p>如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系极其复杂，这些对象被称为同事对象，可以引入一个中介者对象，使各个同事只跟中介者对象打交道，将复杂的网络结构简单化。</p>
<p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性,解耦多个同事对象之间的交互关系，这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。每个同事对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理这些交互关系。</p>
<ul>
<li><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理</li>
</ul>
<h4 id="实现-13">18.1 实现</h4>
<ul>
<li>抽象同事类<code>Departement</code>和抽象中介者类<code>Mediator</code></li>
<li>具体实现同事类，内含中介者指针成员变量</li>
<li>具体中介类，内部维护一个<code>map</code>，管理同事类对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 抽象同事类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Mediator* mediator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Department</span>(Mediator* _mediator) :<span class="built_in">mediator</span>(_mediator) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">selfAction</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">outAction</span><span class="params">(std::string depart)</span> </span>= <span class="number">0</span>;	<span class="comment">//向中介者发送请求,联系另一个同事</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 抽象中介者类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Register</span><span class="params">(std::string name,Department* department)</span> </span>= <span class="number">0</span>;	<span class="comment">//登记同事对象</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setCommand</span><span class="params">(std::string name)</span> </span>= <span class="number">0</span>;	<span class="comment">//将接到的请求发送给相应同事对象处理</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 具体同事类，研发部门</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Development</span> :<span class="keyword">public</span> Department</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Development</span>(Mediator* _mediator) :<span class="built_in">Department</span>(_mediator) &#123;</span><br><span class="line">		mediator-&gt;<span class="built_in">Register</span>(<span class="string">&quot;Development&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">selfAction</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;研发部门进行产品开发工作&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">outAction</span><span class="params">(std::string depart=<span class="string">&quot;Financial&quot;</span>)</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;研发需要资金，财务部赶紧拨钱&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		mediator-&gt;<span class="built_in">setCommand</span>(<span class="string">&quot;Development&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//市场部门</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Market</span> :<span class="keyword">public</span> Department</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Market</span>(Mediator* _mediator) :<span class="built_in">Department</span>(_mediator) &#123;</span><br><span class="line">		mediator-&gt;<span class="built_in">Register</span>(<span class="string">&quot;Market&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">selfAction</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;市场部门进行市场规划制定&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">outAction</span><span class="params">(std::string depart=<span class="string">&quot;Financial&quot;</span>)</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;市场扩展需要资金，财务部赶紧拨钱&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		mediator-&gt;<span class="built_in">setCommand</span>(<span class="string">&quot;Market&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//财务部</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Financial</span> :<span class="keyword">public</span> Department</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Financial</span>(Mediator* _mediator) :<span class="built_in">Department</span>(_mediator) &#123;</span><br><span class="line">		mediator-&gt;<span class="built_in">Register</span>(<span class="string">&quot;Financial&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">selfAction</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;财务部门管理资金&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">outAction</span><span class="params">(std::string depart=<span class="string">&quot;Financial&quot;</span>)</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;财务部没钱了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">responed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout&lt;&lt; <span class="string">&quot;财务部拨钱&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 中介者具体类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> :<span class="keyword">public</span> Mediator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::map&lt;std::string, Department*&gt;managerMap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Register</span><span class="params">(std::string _name,Department* _depart)</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		managerMap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string, Department*&gt;(_name, _depart));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setCommand</span><span class="params">(std::string _name)</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (managerMap[_name]) &#123;</span><br><span class="line">			Financial* s = (Financial *) managerMap[<span class="string">&quot;Financial&quot;</span>];</span><br><span class="line">			s-&gt;<span class="built_in">responed</span>();</span><br><span class="line">			managerMap[_name]-&gt;<span class="built_in">selfAction</span>();</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;This Department have not register&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Mediator* manager = <span class="keyword">new</span> <span class="built_in">Manager</span>();</span><br><span class="line">	Department* development = <span class="keyword">new</span> <span class="built_in">Development</span>(manager);</span><br><span class="line">	Department* market = <span class="keyword">new</span> <span class="built_in">Market</span>(manager);</span><br><span class="line">	Department* financial = <span class="keyword">new</span> <span class="built_in">Financial</span>(manager);</span><br><span class="line">	development-&gt;<span class="built_in">outAction</span>(<span class="string">&quot;Financial&quot;</span>);</span><br><span class="line">	market-&gt;<span class="built_in">outAction</span>(<span class="string">&quot;Financial&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">研发需要资金，财务部赶紧拨钱</span><br><span class="line">财务部拨钱</span><br><span class="line">研发部门进行产品开发工作</span><br><span class="line">市场扩展需要资金，财务部赶紧拨钱</span><br><span class="line">财务部拨钱</span><br><span class="line">市场部门进行市场规划制定</span><br></pre></td></tr></table></figure></p>
<h4 id="优缺点-14">18.2 优缺点</h4>
<p><strong>优点</strong>：</p>
<ul>
<li>单一职责原则。 可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。</li>
<li>开闭原则。 无需修改实际组件就能增加新的中介者。</li>
<li>可以减轻应用中多个组件间的耦合情况。</li>
<li>可以更方便地复用各个组件。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>一段时间后， 中介者可能会演化成为上帝对象。（一个上帝对象(God object)是一个了解过多或者负责过多的对象）</li>
</ul>
<h4 id="适用场景-12">18.3 适用场景</h4>
<ul>
<li><p>当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。</p>
<p>该模式让你将对象间的所有关系抽取成为一个单独的类， 以使对于特定组件的修改工作独立于其他组件。</p></li>
<li><p>当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。</p>
<p>应用中介者模式后， 每个组件不再知晓其他组件的情况。尽管这些组件无法直接交流，但它们仍可通过中介者对象进行间接交流。如果希望在不同应用中复用一个组件， 则需要为其提供一个新的中介者类。</p></li>
<li><p>如果为了能在不同情景下复用一些基本行为，导致需要被迫创建大量组件子类时，可使用中介者模式。</p>
<p>由于所有组件间关系都被包含在中介者中， 因此无需修改组件就能方便地新建中介者类以定义新的组件合作方式。</p></li>
</ul>
<h4 id="与其他模式的关系-11">18.4 与其他模式的关系</h4>
<ul>
<li><p>责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。</li>
<li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求。</li>
</ul></li>
<li><p>外观模式和中介者的职责类似：它们都尝试在大量紧密耦合的类中组织起合作。</p>
<ul>
<li>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</li>
<li>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</li>
</ul></li>
<li><p>中介者和观察者之间的区别往往很难记住。在大部分情况下，可以使用其中一种模式，而有时可以同时使用。</p>
<ul>
<li><p>中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。观察者的目标是在对象之间建立动态的单向连接，使得部分对象可作为其他对象的附属发挥作用。</p></li>
<li><p>有一种流行的中介者模式实现方式依赖于观察者。中介者对象担当发布者的角色，其他组件则作为订阅者，可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时，它可能看上去与观察者非常相似。</p></li>
<li><p>当你感到疑惑时，记住可以采用其他方式来实现中介者。 例如，可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同，但这仍是一种中介者模式。</p></li>
<li><p>假设有一个程序，其所有的组件都变成了发布者，它们之间可以相互建立动态连接。这样程序中就没有中心化的中介者对象，而只有一些分布式的观察者。</p></li>
</ul></li>
</ul>
<h3 id="备忘录模式">19 备忘录模式*</h3>
<p>用于保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。</p>
<ul>
<li><p><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p></li>
<li><p><strong>何时使用</strong>：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有&quot;后悔药&quot;可吃。如我们常说的<strong>回滚</strong>就可以用备忘录实现</p></li>
</ul>
<blockquote>
<p>注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p>
</blockquote>
<h4 id="实现-14">19.1 实现</h4>
<ul>
<li><code>Originator</code>源发器类：要做备份的内容，其中有方法负责创建一个备忘录，用以记录当前时刻它的内部状态，并可以使用备忘录恢复到内部状态</li>
<li><code>Memonto</code>备忘录类，负责存储<code>Originator</code>对象的内部状态，并可防止<code>Originator</code>以外的其他对象访问</li>
<li><code>CareTaker</code>负责人类：负责保存好备忘录<code>Memento</code>,从 <code>Memento</code> 中恢复对象的状态 <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Meonto.png" width="700"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memonto</span>;</span><br><span class="line"><span class="comment">//`Originator`，被备份的类，有其中有方法负责创建一个备忘录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Originator</span>(string _state):<span class="built_in">state</span>(_state)&#123;&#125;</span><br><span class="line">	<span class="function">string <span class="title">getState</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> state;&#125;</span><br><span class="line">	<span class="function">Memonto* <span class="title">saveMemonto</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Memonto*mem=<span class="keyword">new</span> <span class="built_in">Memonto</span>(state);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getStateFromMemonto</span><span class="params">(Memonto* mem)</span></span>&#123;</span><br><span class="line">		state=mem-&gt;<span class="built_in">getState</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Memonto类，存储`Originator`对象的内部状态state</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memonto</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Memonto</span>(string _state):<span class="built_in">state</span>(_state)&#123;&#125;</span><br><span class="line">	<span class="function">string <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CareTaker,负责保存好备忘录`Memento`</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CareTaker</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	deque&lt;Memonto*&gt; dque;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addMem</span><span class="params">(Originator ori)</span></span>&#123;</span><br><span class="line">		dque.<span class="built_in">push_back</span>(ori.<span class="built_in">saveMemonto</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Memonto* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> ret=dque.<span class="built_in">back</span>();</span><br><span class="line">		dque.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="优缺点-15">19.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li>1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</li>
<li>2、实现了信息的封装，使得用户不需要关心状态的保存细节。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li>
</ul>
<h3 id="解释器模式">20 解释器模式</h3>
<p><strong>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式</strong>，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p>
<ul>
<li><strong>意图：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</li>
<li><p><strong>主要解决</strong>：对于一些固定文法构建一个解释句子的解释器</p></li>
<li><p><strong>何时使用：</strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题</p></li>
</ul>
<blockquote>
<p>解释器模式可可使用的场景较少</p>
</blockquote>
<h4 id="实现-15">20.1 实现</h4>
<ul>
<li>定义一个抽象类 AbstractExpression 和实现了 Expression 的实体类。</li>
<li>定义作为上下文中主要解释器的 TerminalExpression 类，终结符表达式，实现与文中的终结符相关联的解释操作。非终结符表达式类， <code>OrExpression、AndExpression</code> 用于创建组合式表达式.</li>
<li><code>Context</code>包含解释器之外的一些全局信息</li>
</ul>
<p><img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/explain.png" width="700"></p>
<h4 id="优缺点-16">20.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li>1、可扩展性比较好，灵活。</li>
<li>2、增加了新的解释表达式的方式。</li>
<li>3、易于实现简单文法。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>1、可利用场景比较少。</li>
<li>2、对于复杂的文法比较难维护。</li>
<li>3、解释器模式会引起类膨胀。</li>
<li>4、解释器模式采用递归调用方法。</li>
</ul>
<h3 id="状态模式">21 状态模式*</h3>
<p>在状态模式（State Pattern）属于行为型模式，类的行为是基于它的状态改变的。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p>
<ul>
<li><strong>意图</strong>：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类</li>
<li><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。因此当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，可考虑用到状态模式。</li>
</ul>
<blockquote>
<p>注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p>
</blockquote>
<h4 id="实现-16">21.1 实现</h4>
<p><img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/status.png" width="700"> - <code>state</code>抽象类，后续的状态子类继承于它实现 - <code>Context</code>是一个带有某个状态的类，依据状态而改变它的行为</p>
<p>下面举例一个机器人收到不同的行为命令处于不同的状态，如行走、停止、蹲下 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*state抽象类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">state</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">actionOfState</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*state具体类，行走WalkSate、StopState</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WalkState</span>:<span class="keyword">public</span> state</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">actionOfState</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;收到行走指令，开始行走&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StopState</span>:<span class="keyword">public</span> state</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">actionOfState</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;收到停止指令，停止走动&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*受命令约束的机器人，依据状态而改变行为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	state* robotState;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Robot</span>(state* _state):<span class="built_in">robotState</span>(_state)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setStatus</span><span class="params">(state* _state)</span></span>&#123;<span class="keyword">this</span>-&gt;robotState=_state;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		robotState-&gt;<span class="built_in">actionOfState</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	state* walk=<span class="keyword">new</span> <span class="built_in">WalkState</span>();</span><br><span class="line">	state* stop=<span class="keyword">new</span> <span class="built_in">StopState</span>();</span><br><span class="line">	<span class="function">Robot <span class="title">carRobot</span><span class="params">(walk)</span></span>;</span><br><span class="line">	carRobot.<span class="built_in">doSomething</span>();</span><br><span class="line">	carRobot.<span class="built_in">setStatus</span>(stop);</span><br><span class="line">	carRobot.<span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="优缺点-17">21.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li>1、封装了转换规则。</li>
<li>2、枚举可能的状态，在枚举状态之前需要确定状态种类。</li>
<li>3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li>
<li>4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li>
<li>5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>1、状态模式的使用必然会增加系统类和对象的个数。</li>
<li>2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>3、状态模式对&quot;开闭原则&quot;的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ul>
<h4 id="适用场景-13">21.3 适用场景</h4>
<ul>
<li><p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，可考虑用到状态模式。</p></li>
<li><p>条件、分支语句的代替者。</p></li>
</ul>
<h4 id="与其他模式的关系-12">21.4 与其他模式的关系</h4>
<ul>
<li>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。</li>
<li>状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句。</li>
<li>多个环境对象共享一个状态对象，从而减少系统中对象的个数，此时跟享元模式相似</li>
</ul>
<h3 id="策略模式">22 策略模式*</h3>
<p><strong>策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。</strong></p>
<p><strong>从上面的思想可以看到策略模式和简单工厂很相像，但简单工厂模式只能解决对象创建问题，对于经常动的算法应使用策略模式。</strong></p>
<ul>
<li><p><strong>意图</strong>：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换，算法的变化，不会影响到用户。</p></li>
<li><p><strong>主要解决</strong>：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。</p></li>
</ul>
<blockquote>
<p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
</blockquote>
<h4 id="实现-17">22.1 实现</h4>
<ul>
<li>一个策略基类<code>Strategy</code>，后续各种不同的策略继承于他实现。</li>
<li>继承于<code>Strategy</code>的各种策略的具体实现</li>
<li>一个聚合类<code>Context</code>，作用时提供给客户端调用不同的策略方法，因此内部要有<strong><code>策略基类的指针成员变量、设置采用哪种策略的接口、以及调用接口</code></strong>等基本方法 <img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/strategy.png" width="600"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namspace std;</span><br><span class="line"><span class="comment">//策略基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">double</span> discount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Strategy</span>(<span class="type">double</span> _dis):<span class="built_in">discount</span>(_dis)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_discount</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//各种不同的策略算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">newCustomerFewStrategy</span>:<span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">newCustomerFewStrategy</span>(<span class="type">double</span> _dis):<span class="built_in">Strategy</span>(_dis)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_discount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;普通用户小批量,不打折&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;discount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">newCustomerManyStrategy</span>:<span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">newCustomerManyStrategy</span>(<span class="type">double</span> _dis):<span class="built_in">Strategy</span>(_dis)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_discount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;普通用户大批量,打&quot;</span>&lt;&lt;discount&lt;&lt;<span class="string">&quot;折&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;discount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">oldCustomerFewStrategy</span>:<span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">newCustomerManyStrategy</span>(<span class="type">double</span> _dis):<span class="built_in">Strategy</span>(_dis)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_discount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;老用户小批量,打&quot;</span>&lt;&lt;discount&lt;&lt;<span class="string">&quot;折&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;discount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">oldCustomerManyStrategy</span>:<span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">newCustomerManyStrategy</span>(<span class="type">double</span> _dis):<span class="built_in">Strategy</span>(_dis)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get_discount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;老用户大批量,打&quot;</span>&lt;&lt;discount&lt;&lt;<span class="string">&quot;折&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;discount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Context负责和具体的策略类交互，实现具体算法与客户端调用分离</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Strategy* strategy;		<span class="comment">//当前采用的策略算法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Context</span>(Strategy* _sta):<span class="built_in">strategy</span>(_sta)&#123;&#125;</span><br><span class="line">	<span class="function">Strategy* <span class="title">getStrategy</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> strategy;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(Strategy* _sta)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;strategy=_sta;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print_price</span><span class="params">(<span class="type">double</span> price)</span></span>&#123;</span><br><span class="line">		<span class="type">double</span> ret*=strategy-&gt;get_discount/<span class="number">10</span>;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;最终价格为:&quot;</span>&lt;&lt;ret&lt;&lt;<span class="string">&quot;元&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Strategy* st=<span class="keyword">new</span> <span class="built_in">oldCustomerManyStrategy</span>(<span class="number">8.5</span>);</span><br><span class="line">	<span class="function">Context <span class="title">con</span><span class="params">(st)</span></span>;</span><br><span class="line">	con.<span class="built_in">print_price</span>(<span class="number">700</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="优缺点-18">22.2 优缺点</h4>
<p><strong>优点</strong>:</p>
<ul>
<li>1、算法可以自由切换。</li>
<li>2、避免使用多重条件判断。</li>
<li>3、扩展性良好。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>1、策略类会增多。</li>
<li>2、所有策略类都需要对外暴露。</li>
</ul>
<h4 id="使用场景">22.3 使用场景</h4>
<ul>
<li><p>1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</p></li>
<li><p>2、一个系统需要动态地在几种算法中选择一种。</p></li>
<li><p>3、如果一个对象有很多的行为，这些行为使用多重的条件选择语句来实现，现在有了策略模式，我们就可以省略它们，由客户端决定使用哪一个行为方法。</p></li>
</ul>
<h3 id="责任链模式">23 责任链模式*</h3>
<ul>
<li><p>责任链模式在面向对象程式设计里是一种软件设计模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些客户端的哪些请求，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象；</p></li>
<li><p>由于责任链的创建完全在客户端，因此新增新的具体处理者对原有类库没有任何影响，只需添加新的类，然后在客户端调用时添加即可。 符合开闭原则。</p></li>
<li><p>因此发出这个请求的客户端可以不知道链上的哪一个对象最终处理这个请求，只需要发送即可，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任</p></li>
<li><p><strong>主要解决</strong>：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p></li>
</ul>
<h4 id="实现-18">23.1 实现</h4>
<p>责任链的实现方法有两种：</p>
<ul>
<li>链表方式定义职责链</li>
<li><strong>非链表方式实现职责链：通过集合、数组生成职责链更加实用！</strong>实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追加的，所以使用链表方式定义COR链就很困难。</li>
</ul>
<p>下面代码以管理者为例：首先管理者为基类，其子类又经理、总监和普通员工,其责任链顺序为<code>经理-&gt;总监-&gt;普通员工</code>；基类声明了两个必须的接口：</p>
<ul>
<li><code>RequestHandler</code>：在该接口实现经过判断是处理请求，还是将请求传递给下一个,因此要重写，因此为虚函数</li>
<li><code>setSuccessor</code>：该接口实现当前处理者能将请求传递给下一个处理者，即请求处理继任者，以此实现责任链的形式；不需重写</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//请求类：封装了责任链当中客户端发送的请确包：信息+哪个对象处理该请求的判断条件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_str;</span><br><span class="line">	<span class="type">int</span> m_number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//责任链上对象的基类,</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	Manager* manager;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Manager</span>(string _name):<span class="built_in">name</span>(_name)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置责任链上的后继者</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setSuccessor</span><span class="params">(Manager* nextManager)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		manager=nextmanager;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理请求的核心业务函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RequestHanlder</span><span class="params">(Request* request)</span></span>=<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//经理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommonManager</span>:<span class="keyword">public</span> Manager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CommonManager</span>(string _name):<span class="built_in">Manager</span>(_name)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理请求的核心业务函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RequestHandler</span><span class="params">(Request* request)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(request-&gt;m_number&gt;<span class="number">0</span>&amp;&amp;request-&gt;m_numer&lt;<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//该请求是由经理处理</span></span><br><span class="line">			<span class="built_in">Common_handler</span>(request-&gt;m_str);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//由下一个继任者处理</span></span><br><span class="line">			manager-&gt;<span class="built_in">RequestHandler</span>(request);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">//总监</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MajorDomo</span>:<span class="keyword">public</span> Manager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MajorDomo</span>(string _name):<span class="built_in">Manager</span>(_name)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RequsetHanlder</span><span class="params">(Request* request)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(request-&gt;m_number&gt;<span class="number">10</span>&amp;&amp;request-&gt;m_numer&lt;<span class="number">20</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//该请求是由总监处理</span></span><br><span class="line">				<span class="built_in">Major_handler</span>(request-&gt;m_str);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				manager-&gt;<span class="built_in">RequestHandler</span>(request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NormalEmployee</span>:<span class="keyword">public</span> Manager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">NormalEmployee</span>(string _name):<span class="built_in">Maanager</span>(_name)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RequsetHanlder</span><span class="params">(Request* request)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(request-&gt;m_number&gt;=<span class="number">20</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//该请求是由普通处理</span></span><br><span class="line">				<span class="built_in">Normal_handler</span>(request-&gt;m_str);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				manager-&gt;<span class="built_in">RequestHandler</span>(request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Manager* common=<span class="keyword">new</span> <span class="built_in">CommonManager</span>(<span class="string">&quot;张经理&quot;</span>)；</span><br><span class="line">	Manager* major=<span class="keyword">new</span> <span class="built_in">MajorDomo</span>(<span class="string">&quot;李总监&quot;</span>);</span><br><span class="line">	Manager* normal=<span class="keyword">new</span> <span class="built_in">NormalManager</span>(<span class="string">&quot;刘职员&quot;</span>);</span><br><span class="line">	<span class="comment">//设置后继者</span></span><br><span class="line">	common-&gt;<span class="built_in">SetSuccessor</span>(mojor);</span><br><span class="line">	major-&gt;<span class="built_in">SetSuccessor</span>(normal);</span><br><span class="line">	</span><br><span class="line">	Requesst* req=<span class="keyword">new</span> <span class="built_in">Request</span>();</span><br><span class="line">	req-&gt;m_number=<span class="number">23</span>;</span><br><span class="line">	req-&gt;m_str=<span class="string">&quot;video&quot;</span>;</span><br><span class="line">	common-&gt;<span class="built_in">RequestHanlder</span>(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点-19">23.2 优缺点</h4>
<ul>
<li>优点
<ul>
<li>可以控制请求处理的顺序。</li>
<li>单一职责原则。 可对发起操作和执行操作的类进行解耦。</li>
<li>开闭原则。 可以在不更改现有代码的情况下在程序中新增处理者。</li>
</ul></li>
<li>缺点
<ul>
<li>部分请求可能未被处理</li>
</ul></li>
</ul>
<h4 id="适用场景-14">23.3 适用场景</h4>
<ul>
<li><p>当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序预先未知时，可以使用责任链模式。</p></li>
<li><p>该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。</p></li>
<li><p>当必须按顺序执行多个处理者时， 可以使用该模式。</p></li>
<li><p>无论以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。</p></li>
<li><p>如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。</p></li>
<li><p>如果在处理者类中有对引用成员变量的设定方法， 将能动态地插入和移除处理者， 或者改变其顺序。</p></li>
</ul>
<h4 id="与其他模式的关系-13">23.4 与其他模式的关系</h4>
<ul>
<li><p>责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：</p></li>
<li><p>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</p></li>
<li><p>命令在发送者和请求者之间建立单向连接。</p></li>
<li><p>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</p></li>
<li><p>观察者允许接收者动态地订阅或取消接收请求。</p></li>
<li><p>责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p></li>
<li><p>责任链的管理者可使用命令模式实现。 在这种情况下， 可以对由请求代表的同一个上下文对象执行许多不同的操作。</p></li>
<li><p>还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 可以对由一系列不同上下文连接而成的链执行相同的操作。</p></li>
<li><p>责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p></li>
<li><p>责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p></li>
</ul>
<h3 id="访问者模式">24 访问者模式</h3>
<p>对于存储在一个集合中的对象，他们可能具有不同的类型(即使有一个公共的接口)，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同。访问者模式表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作</p>
<ul>
<li><strong>意图：</strong>主要将数据结构与数据操作分离。</li>
<li><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</li>
<li><strong>何时使用：</strong>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&quot;污染&quot;这些对象的类，使用访问者模式将这些封装到类中。</li>
</ul>
<blockquote>
<p><strong>注意事项</strong>：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p>
</blockquote>
<h4 id="实现-19">24.1 实现</h4>
<p><img src="/2023/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/visiter.png" width="700"></p>
<h4 id="优缺点-20">24.2 优缺点</h4>
<p><strong>优点：</strong></p>
<ul>
<li>1、符合单一职责原则。</li>
<li>2、优秀的扩展性。</li>
<li>3、灵活性。</li>
</ul>
<p><strong>缺点： </strong></p>
<ul>
<li>1、具体元素对访问者公布细节，违反了迪米特原则。</li>
<li>2、具体元素变更比较困难。</li>
<li>3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>
</ul>
<h4 id="适用场景-15">24.3 适用场景</h4>
<ul>
<li>当需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&quot;污染&quot;这些对象的类，可以使用访问者模式将这些封装到类中。</li>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作</li>
</ul>
<blockquote>
<p>文章来源：本文笔记主要来源腾讯大佬<code>Sliverming</code>的笔记和菜鸟总结</p>
<p><a href="https://xiaoming.net.cn/2019/07/29/GOF23/#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">Sliverming博客地址</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能MySQL</title>
    <url>/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/</url>
    <content><![CDATA[<h3 id="mysql的架构">1. MySQL的架构</h3>
<p>MySQL最重要最与众不同的就是它的存储引擎架构，这种架构设计将查询处理(<code>QUERY PROCESSING</code>)及其他系统任务和数据存储/提取相分离。在这里主要介绍MySQL的服务器架构、各种存储引擎之间的区别。</p>
<h4 id="逻辑架构">1.1 逻辑架构</h4>
<p>MySQL各组件协同工作的示意图如下：</p>
<ul>
<li>最上层的客户端不是MySQL独有的，像许多C/S结构都具有。</li>
<li>第二层架构是大多数MySQL的核心服务功能所在的一层，如查询解析、分析、优化、缓存和所有的内置函数，所有跨存储引擎的功能也在这一层实现：存储过程、视图、触发器等。</li>
<li>第三层包含了存储引擎，存储引擎负责MySQL中数据的存储和提取 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/Fram.png" width="400"></li>
</ul>
<span id="more"></span>
<h5 id="连接管理与安全性">1.1.1 连接管理与安全性</h5>
<p>每个客户端连接到MySQL服务器进程有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU时间片中执行语句。服务器会负责缓存管理线程，因此不需要为每一个新建的连接创建或者销毁线程。</p>
<p>当有来自于客户端的连接请求时，服务器会对连接信息进行认证，认证基于用户名、密码和主机信息进行。</p>
<h5 id="优化与执行">1.1.2 优化与执行</h5>
<p><strong>进行解析的过程：</strong></p>
<ul>
<li>MySQL会解析查询，并创建内部数据结构（解析树），<strong>然后对其进行各种优化：包括重写查询、决定表的读取顺序以及选择合适的索引等。</strong></li>
<li>用户可以通过特殊的关键字提示优化器来影响它的优化决策过程，也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器时如何进行优化决策的。</li>
<li>优化器不关心表使用哪种存储引擎，但存储引擎对优化查询是有影响的，因为优化器会请求存储引擎提供容量或某个具体操作的开销。</li>
</ul>
<p><strong>当然不要忘了还有查询缓存：</strong></p>
<p>对于select语句，在解析查询之前，服务器会先检查查询缓存，如果能在查询缓存中找到对应查询，服务器就不必执行解析器、优化和执行的整个过程，直接返回查询缓存中的结果集即可。</p>
<h4 id="并发控制">1.2 并发控制</h4>
<p>在MySQL当中是在两个面讨论的并发控制：服务器层和存储引擎层。在并发场景下，如果不对并发进行控制，则会导致数据的损坏无效，一般来说我们都是用锁<code>lock</code>来对其进行控制。在MySQL中的锁有共享锁(<code>shared lock</code>)、排他锁(<code>exclusive lock</code>)，也叫读锁(<code>read lock</code>)和写锁(<code>write lock</code>)</p>
<h3 id="锁">2. 锁</h3>
<p>锁这个知识点比较繁杂，下图是对锁的各个概念范围进行分类： <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/Lockrecord.png" width="700"></p>
<h4 id="锁类型兼容性">2.1 锁类型（兼容性）</h4>
<p>对于读取内容来说一般不会发生什么问题，因为本线程没有对数据进行修改，<strong>但是试想一下你正在对读的使用，另一个人正在对数据进行写入，这时候问题就来了，你读的数据会是确定呢吗?答案肯定是不确定的</strong>，因此对于读操作也要注意。而写操作就更不用说了，每一次的写入都会改变数据，必定加入排斥锁。在MySQL中读锁即为共享锁，写锁即为排斥锁。</p>
<ul>
<li><p><strong>共享锁（读锁）</strong>：读锁是共享的，或者说是不阻塞的，多个线程可以在同一时刻可以同时读取同一个资源而互不干扰，但是当有一个线程试图写时，是不被允许的，即读锁不阻塞其他的读操作，但是阻塞写操作。</p></li>
<li><p><strong>排斥锁（写锁）</strong>：写锁是排他的，一个写锁会阻塞其他的写锁和读锁。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//共享锁</span></span><br><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line"><span class="comment">//排他锁（X)</span></span><br><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></table></figure>
<h4 id="锁的粒度">2.2 锁的粒度</h4>
<p><strong>为提供共享资源并发性就是让锁的对象更具有选择性，即尽量只锁定需要修改的部分数据，而不是所有的资源，任何时候，在给定资源锁的粒度越小精度越高，则系统的并发程度越高。但是我们不能无限制的只加最小粒度的锁，因为锁也需要消耗资源的，如锁的各种操作、包括获得锁、检查锁是否解除、释放锁都会增加系统开销</strong>，因此对锁选择策略是在锁的开销和数据安全性之间寻找平衡折中。</p>
<h5 id="表级锁">2.2.1 表级锁</h5>
<p>表级锁是对整个表加锁的一种操作。MyISAM和InnoDB引擎都支持表级锁，</p>
<ul>
<li><strong>优点：</strong>是MySQL中锁定粒度最大的一种锁，实现简单，资源消耗也比较少，加锁快，只对一个表操作不会出现死锁。</li>
<li><strong>缺点</strong>：其锁定粒度最大，触发锁冲突的概率最高，并发度最低。</li>
</ul>
<p>表锁的语法是<code>lock tables … read/write</code>。可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。<code>lock tables</code>语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#为表t1上读锁，t2上写锁</span><br><span class="line">lock tables t1 read,t2 wirte;</span><br><span class="line">#释放锁</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line">mysql&gt; lock tables employee read;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; insert into employee <span class="title">values</span><span class="params">(<span class="string">&#x27;crf&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="number">15000</span>,now(),<span class="number">300</span>)</span></span>;</span><br><span class="line">ERROR <span class="number">1099</span> (HY000): Table <span class="string">&#x27;employee&#x27;</span> was locked with a READ lock <span class="keyword">and</span> can<span class="number">&#x27;</span>t be updated</span><br></pre></td></tr></table></figure></p>
<h5 id="行级锁">2.2.2 行级锁</h5>
<p>行级锁是MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁，在MySQL中MyISAM不支持行锁，InnoDB支持。<strong>记住行级锁只能对是有索引字段进行加锁从而锁住改行。</strong></p>
<ul>
<li><strong>优点：</strong>行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，</li>
<li><strong>缺点：</strong>因为粒度小，因此加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将退化使用的是表锁</strong>。</p>
<p><strong>其他注意事项：</strong></p>
<ul>
<li><p>在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁。</p></li>
<li><p>如果MySQL的行锁是针对范围索引加的锁，不是针对记录加的锁，所以即使是访问不同行的记录，如果使用了相同的索引键，也是会出现锁冲突的，这是因为间隙锁的原因（接下来会讲）</p></li>
<li><p>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</p></li>
<li><p>即便在条件中使用了索引字段，但具体是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p></li>
</ul>
<p><strong>隐式默认加锁</strong>：</p>
<ul>
<li>InnoDB自动加意向锁。</li>
<li>对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，<code>InnoDB</code>会自动给涉及数据集加排他锁<code>（X)</code>；</li>
<li>对于普通<code>SELECT</code>语句，InnoDB不会加任何锁；</li>
</ul>
<p><strong>显示加锁</strong>：</p>
<ul>
<li><strong>共享锁（S）</strong>：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code></li>
<li><strong>排他锁（X)</strong> ：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code></li>
</ul>
<p><strong><em>注意</em></strong>：正如上面所说的，行锁是根据索引上的索引项加锁实现的，即上面的对于的列必须有加索引才能是为行级锁，否则为表级锁，如下开两个客户端连接MySQL,因为不是索引，所以为表锁 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#客户端<span class="number">1</span>：不是索引，粒度为表锁，类型为排他锁</span><br><span class="line">mysql&gt; select id,<span class="function">job_name from employee_job where id <span class="title">in</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span> <span class="keyword">for</span> update</span>;</span><br><span class="line">+----+--------------+</span><br><span class="line">| id | job_name     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">2</span>  | 老板         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">#客户端2：</span></span><br><span class="line"><span class="function">mysql&gt; select id,job_name from employee_job where id <span class="title">in</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">ERROR <span class="number">1100</span> (HY000): Table <span class="string">&#x27;employee_job&#x27;</span> was <span class="keyword">not</span> locked with LOCK TABLES</span><br></pre></td></tr></table></figure></p>
<h5 id="页级锁">2.2.3 页级锁</h5>
<p>页级锁的粒度介于行级锁和表级锁中间的一种锁。它比表级锁速度快，比表级锁的冲突多，比行级锁的冲突少，但速度慢。因此页级是一种折中锁，一次锁定相邻的一组记录。BDB 支持页级锁。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p>
<p><strong><em>注意：行级锁不一定比表级锁要好，锁的粒度越细，代价越高，相比表级锁在表的头部直接加锁，行级锁还要扫描找到对应的行对其上锁，这样的代价其实是比较高的，所以表锁和行锁各有所长。</em></strong></p>
<h5 id="全局锁">2.2.4 全局锁</h5>
<p>MySQL提供了一个加全局读锁的方法，命令是<code>Flush tables with read lock</code>,当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#对所有数据库实例加读锁</span><br><span class="line">Flush tables with read lock</span><br><span class="line">#对所有数据库实例加写锁</span><br><span class="line">Flush tables with write lock</span><br><span class="line">#之后执行插入，则会出现</span><br><span class="line">mysql&gt; <span class="function">INSERT INTO DEPARTMENT <span class="title">VALUES</span><span class="params">(<span class="number">2</span>,<span class="string">&#x27;血液内科&#x27;</span>)</span></span>;</span><br><span class="line">ERROR <span class="number">1223</span> (HY000): Can<span class="number">&#x27;</span>t execute the query because you have a conflicting read lock</span><br></pre></td></tr></table></figure></p>
<h4 id="死锁">2.3 死锁</h4>
<p>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，</p>
<h5 id="引起死锁的原因">2.3.1 引起死锁的原因</h5>
<ul>
<li>①竞争不可抢占资源引起死锁（不可抢占是指没有使用完的资源，不能被抢占）</li>
<li>②竞争可消耗资源引起死锁</li>
<li>③线程推进顺序不当引起死锁</li>
</ul>
<p>情况1：有线程<code>p1</code>，<code>p2</code>，都需要资源<code>A</code>，<code>B</code>，本来可以<code>p1运行A</code> --&gt; <code>p1运行B</code> --&gt; <code>p2运行A</code> --&gt; <code>p2运行B</code>，但是顺序换了，<code>p1</code>运行<code>A</code>时<code>p2</code>运行<code>B</code>，容易发生第一种死锁。互相抢占资源对放持有的资源。</p>
<p>情况2：有<code>p1，p2，p3</code>三个线程，<code>p1</code>向<code>p2</code>发送消息并接受<code>p3</code>发送的消息，<code>p2</code>向<code>p3</code>发送消息并接受<code>p1</code>的消息，<code>p3</code>向<code>p1</code>发送消息并接受<code>p2</code>的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成死锁。</p>
<h5 id="产生死锁的必要条件">2.3.2 产生死锁的必要条件</h5>
<ul>
<li><p><strong>互斥条件</strong>：某资源只能被一个进程使用，其他进程请求该资源时，只能等待，直到资源使用完毕后释放资源。</p></li>
<li><p><strong>请求和保持条件</strong>：程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。</p></li>
<li><p><strong>不可抢占条件</strong>：进程已获得的资源没有使用完，不能被抢占。</p></li>
<li><p><strong>循环等待条件</strong>：必然存在一个循环链。</p></li>
</ul>
<h5 id="解决死锁的方式">2.3.3 解决死锁的方式</h5>
<p>在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在</p>
<ul>
<li><strong>预防死锁：</strong>在设计时，对锁的使用进行预防，以确保业务不会发生死锁，通过破坏死锁产生的后三个必要条件：即破坏请求持、不可抢占、循环等待条件之一来预防死锁。
<ul>
<li><strong>破坏请求和保持条件</strong>：所有线程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生。</li>
<li><strong>破坏不可抢占条件</strong>：当一个已经保持了某种不可抢占资源的线程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请</li>
<li><strong>破坏循环等待条件</strong>：对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</li>
</ul></li>
<li><p><strong>解除死锁：</strong>产生死锁时，能够从死锁中解脱处理，比如一种策略超时退出。在MySQL中这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置，默认为<code>50s</code>.</p></li>
<li><p><strong>检查死锁：</strong>在MySQL种有这样的机制，线程发现死锁后，会主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。可将参数<code>innodb_deadlock_detect</code>设置为<code>on</code>，表示开启这个逻辑。但是它有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，消耗大。</p></li>
<li><p><strong>一种特殊情况：</strong>在<code>REPEATABLE-READ</code>隔离级别下，如果两个线程同时对相同条件记录用<code>SELECT…FOR UPDATE</code>加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成<code>READ COMMITTED</code>，就可避免问题。</p></li>
</ul>
<h4 id="三种行级锁模式原理">2.4 三种行级锁模式（原理）</h4>
<h5 id="记录锁">2.4.1 记录锁</h5>
<p><strong>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，粒度是行级锁，类型是排他锁</strong>。一般记录锁出现在<code>select、update</code>语句，比如下面这句，它会在<code>id=1</code>的记录上加上记录锁，以阻止其他事务插入，更新，删除和更新<code>id=1</code>这一行。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//id 列必须为主键列或唯一索引列</span></span><br><span class="line">SELECT * FROM test WHERE id=<span class="number">1</span> FOR UPDATE;</span><br><span class="line">UPDATE SET age = <span class="number">50</span> WHERE id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure> <strong>记录锁的条件：</strong></p>
<ul>
<li><code>id</code> 列必须为唯一索引列或主键列(主键索引)，否则上述语句加的锁就会变成临键锁(有关临键锁下面会讲)。</li>
<li>同时查询语句的条件子句必须为精准匹配即为<code>=</code>，不能为<code>&gt;、&lt;、like</code>等，否则也会退化成间隙锁或者临键锁</li>
</ul>
<p><strong><em>注意：如果要锁的列没有索引，进行全表记录加锁（行级锁的性质）</em></strong></p>
<h5 id="间隙锁">2.4.2 间隙锁</h5>
<p><strong>间隙锁<code>Gap Lock</code>是指在InnoDB存储引擎中锁可以加在不存在的空闲空间的一种锁</strong>。它能在两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。<strong>间隙锁是一种行级锁，是 InnoDB在 RR(可重复读) 隔离级别下为了解决幻读问题时引入的锁机制。</strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</p>
<p><strong>产生间隙锁的条件：</strong></p>
<ul>
<li>使用普通索引锁定，或者使用多列唯一索引，或者使用唯一索引锁定多行记录。</li>
<li>条件子句不为精确匹配，为范围</li>
</ul>
<p><strong>可能光说不好理解，看例子：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建test表，id为主键索引</span></span><br><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` <span class="built_in">int</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="built_in">varchar</span>(<span class="number">8</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">INSERT INTO `test` <span class="built_in">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;小罗&#x27;</span>),(<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;小黄&#x27;</span>),(<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>),(<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>);</span><br></pre></td></tr></table></figure> 上面的插入语句完成后，<code>test</code>表中存在的隐藏间隙如下： <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/gaplock.png" width="600"> 即有范围：<code>(-∞, 1]、(1, 5]、(5, 7]、(7, 11]、(11, +∞]</code>，那么当我使用下面语句的时候就会触发间隙锁 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM `test` WHERE `id` BETWEEN <span class="number">5</span> AND <span class="number">7</span> FOR UPDATE;</span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;小张1&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">9</span>, <span class="string">&#x27;大东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">11</span>, <span class="string">&#x27;李西&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务8插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">12</span>, <span class="string">&#x27;张三&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure> 从上面我们可以看到，<code>(5, 7]、(7, 11]</code>这两个区间被事务1锁住，在此期间的其他事务的插入操作失败，而其它区间，都可以正常插入数据。所以我们可以得出结论：当我们给 <code>(5, 7]</code>这个区间加锁的时候，会锁住 <code>(5, 7]、(7, 11]</code>这两个区间。</p>
<p><strong>间隙锁的缺点</strong>:</p>
<ul>
<li>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。虽然解决了幻读，但在某些场景下这可能会对性能造成很大的危害</li>
<li>当Query无法利用索引的时候， Innodb会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；</li>
</ul>
<p><strong>间隙锁的作用：</strong></p>
<ul>
<li><strong><code>next-key-value</code>解决可重复读隔离级别下的幻读</strong></li>
<li>为了数据恢复和复制的需要。</li>
</ul>
<p><strong><em>注意：可重复读级别下才会有间隙锁！还有如果对不存的记录操作即使使用<code>=</code>也会产生间隙锁，如<code>select id,name from test where id=3 for update;</code>,id=3是不存在的记录</em></strong></p>
<h5 id="临键锁next-key-locks">2.4.3 临键锁（Next-Key Locks）</h5>
<p><strong><code>Next-key locks</code>是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。</strong></p>
<p>也可以理解为一种特殊的间隙锁，因此临建锁肯定也可以解决幻读的问题。 <strong>每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据</strong>。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，<strong>而临键锁只与非唯一索引列有关，在唯一索引列（包括主键索引）上不存在临键锁。</strong>即临键锁是对非唯一索引而言的。</p>
<p>假设有如下表：InnoDB，RR隔离级别，<code>id</code>主键, <code>age</code>普通索引 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/nextkeylocks.png" width="600"> 则有<code>age</code>范围:<code>(-∞, 10],(10, 24],(24, 32],(32, 45],(45, +∞]</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/事务A执行下述语句</span><br><span class="line">-- 根据非唯一索引列 UPDATE 某条记录 </span><br><span class="line">UPDATE table SET name = Vladimir WHERE age = <span class="number">24</span>; </span><br><span class="line">-- 或根据非唯一索引列 锁住某条记录 </span><br><span class="line">SELECT * FROM table WHERE age = <span class="number">24</span> FOR UPDATE;</span><br><span class="line"><span class="comment">//事务B执行下述语句</span></span><br><span class="line"><span class="function">INSERT INTO table <span class="title">VALUES</span><span class="params">(<span class="number">100</span>, <span class="number">26</span>, <span class="string">&#x27;tianqi&#x27;</span>)</span></span>; </span><br></pre></td></tr></table></figure> 上面因为<code>age=26</code>恰好在<code>(24,32]范围内</code>,age为非唯一索引，使用临检索模式的行级锁，则不管事务A执行那个语句，事务B的插入语句总会阻塞。</p>
<p><strong>总结：</strong></p>
<ul>
<li><strong>InnoDB 中的行锁的实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁。</strong></li>
<li><strong>记录锁</strong>存在于包括主键索引在内的唯一索引中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于非唯一索引中，锁定开区间范围内的一段间隔，它是基于临键锁实现的。</li>
<li><strong>临键锁</strong>存在于非唯一索引中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的间隙锁，锁定一段左开右闭的索引区间。</li>
</ul>
<h4 id="意向锁">2.5 意向锁</h4>
<p>意向锁又分为<strong>意向共享锁（IS）</strong>和 <strong>意向排他锁（IX）</strong>。在介绍意向锁的意义之前，必须明白下面四点：</p>
<ul>
<li>意向共享锁（IS）和 意向排他锁（IX）都是<strong>表锁</strong>。</li>
<li><strong>意向锁是一种不与行级锁冲突的表级锁，这一点非常重要。它只会与非意向的表锁冲突</strong></li>
<li><strong>意向锁与意向锁之间永远是兼容的</strong></li>
<li>意向锁是<code>InnoDB</code>自动加的， 不需用户干预。当兵对表或对行加排他锁时，就会获得意向排他锁；加共享锁时，会获得意向共享锁。</li>
<li>意向锁是在<code>InnoDB</code>下存在的内部锁，对于<code>MyISAM</code>而言 没有意向锁之说。</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">兼容性</th>
<th style="text-align: center;">表IS</th>
<th style="text-align: center;">表IX</th>
<th style="text-align: center;">表s</th>
<th style="text-align: center;">表x</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>表IS</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>表IX</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>表S</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>表X</strong></td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
</tbody>
</table>
<p><strong>意向锁的存在目的是为了让InnoDB中的行锁和表锁能够更高效的共存</strong>。假设有下表，InnoDB，RR隔离级别 <code>id</code>是主键 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/ilock.png" width="500"></p>
<p>加入现在有事务<code>A</code>，进行了一条<code>SELECT * FROM users WHERE id = 6 FOR UPDATE;</code>但未提交，那么事务<code>A</code>会获得<code>id=6</code>的行级锁，且为记录排他锁，同时还有自动生成一个意向排他锁。</p>
<p>这时候有个事务<code>B</code>,进行操作<code>LOCK TABLES users READ;</code>会失败，因为对于要表锁来说，必须要保证：</p>
<ul>
<li>当前没有其他事务持有<code>users</code>表的排他锁。</li>
<li>当前没有其他事务持有<code>users</code>表中任意一行的排他锁 。</li>
</ul>
<p>但是现在<code>users</code>表的排他锁已经被事务<code>A</code>持有了，事务B的这个想获取表共享锁的操作会失败。</p>
<p>上面的例子是有意向锁的情况，试想一下没有意向锁和表锁情况会这样：事务B会去检查<code>user</code>表中的每一行查看是否有排他锁，如果有则无法执行，无则会执行。很明显这样的效率极低，但有意向锁后，只需检查意向表锁即可。</p>
<h3 id="事务">3. 事务</h3>
<p>事务就是由一批SQL语句组成，可以说它是一个独立的工作单元。<strong>事务处理可以用来维护数据的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行，事务处理是一种机制，利用事务处理可以保证成批的MySQL操作不会只执行一部分，如果全部执行那没问题，如果在执行过程中发生错误，它就会进行回退以恢复到数据库以前安全版本</strong>。MySQL中InnoDB支持事务，MyISAM不支持。</p>
<h4 id="事务的acid">3.1 事务的ACID</h4>
<p>一个运行良好的事务处理系统，必须具备四大特性：原子性(<code>atomicity</code>)、一致性(<code>consistency</code>)、隔离性(<code>isolation</code>)和持久性(<code>durability</code>)。实现了ACID的数据库相比于未实现的数据库，其通常需要更强的CPU处理能力，更大的内存和磁盘空间。因此要酌情堪虑是否选用事务型存储引擎。</p>
<ul>
<li><strong>原子性</strong>：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的操作要么全部提交成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>：数据库总是从一个一致性状态转移达到另一个一致性状态，一致性状态就是由事务原子性保障，一个事务提交了，那是ok的，一个事务未提交，那也是OK的。</li>
<li><strong>隔离性</strong>：通常来说，一个事务所做的修改在未提交以前，对其他事务是不可见的。事务间是互不干扰的。</li>
<li><strong>持久性</strong>：一旦事务提交了，其所做的修改会永久保存到数据库总中，即使系统崩溃，修改的数据也不会丢失，（持久性不能做到100%保证策略，如果数据库本身就能做到吃性，那么要备份又有什么用呢）</li>
</ul>
<h4 id="隔离级别">3.2 隔离级别</h4>
<p>在SQL标准中定义了四种隔离级别，<strong>每一种级别都规定了一个事务所做的修改，在哪些事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也低</strong></p>
<ul>
<li><p><strong>未提交读(<code>read uncommitted</code>)</strong>：在该隔离级别，事务中的修改，即使没有提交，对其他事务也都是可见的。<strong>事务可以读取未提交的数据，这也被称为脏读</strong>。这个级别会导致喝多问题，从性能上来说，该级别没有比其他级别好很多，一般不推荐使用。</p></li>
<li><strong>提交读(<code>read committed</code>)：在该级别，一个事务开始时只能看见已经提交的事务的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，因此也可称为</strong>不可重复读**。这个隔离级别时大多数数据库默认的隔离级别。</li>
<li><strong>可重复读(<code>repeatable read</code>)</strong>：在该级别，保证了同一个事务多次读取同样的记录的结果是一致的。可重复读是MySQ的默认隔离级别，解决了脏读的问题，但是对于幻读无法解决。<strong>所谓的幻读就是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围插入新的记录，当之前的事务再次读取该范围记录时，产生幻行。</strong>InooDB引擎使用多版本控制MVCC解决幻读问题。</li>
<li><p><strong>可串行化(<code>serializable1</code>)</strong>：该隔离级别时最高的隔离级别，它通过强制事务串行执行，避免了前面说的幻读问题。简单来说，就是在读取每一行数据都加锁，所有会导致大量的超时和锁争问题。</p></li>
</ul>
<h4 id="事务日志">3.3 事务日志</h4>
<p><strong>首先必须明白InnoDB存储引擎是以页为单位来管理存储空间的，真正访问页面之前，需要把在磁盘上的页缓存到内存中的缓存池之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘（checkpoint机制），通过缓存池来优化cpu和磁盘之间的鸿沟。通过将数据的修改记录到事务日志并持久化，内存中修改的数据在后台可以慢慢地刷回磁盘，不要修改一次就马上刷回磁盘。减少了与磁盘间的IO;同样事务日志的持久性保证了事务的一致性和持久性（由事务的<code>redo日志</code>和<code>undo日志</code>来保证。）</strong></p>
<ul>
<li><p><strong><code>REDO LOG</code>称为重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</strong><code>redo</code>日志的存在使得我们再对表进行修改时会把这些修改写进日志里，然后再写入磁盘，只有日志写入成功，才算事务的提交完成，<strong>这样即使数据库发生宕机未刷新到磁盘，也可以通过<code>redo</code>日志恢复。</strong></p></li>
<li><p><strong><code>UNDO LOG</code>称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性</strong>。有的DBA或许会认为<code>UNDO</code>是<code>REDO</code>的逆过程，其实不然。<code>undo log</code>是存储引擎(<code>innodb</code>)生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了<code>insert</code>语句操作，那么<code>undo log</code>就记录一条与之相反的delete操作，主要用于事务回滚（<code>undo log</code>记录的是每个修改操作的逆操作）和一致性非锁定定读（<code>undo log</code>回滚行记录到某种特定的版本,mvcc，多版本并发控制）。 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/log.png" width="600"></p></li>
</ul>
<p><a href="https://blog.csdn.net/zuodaoyong/article/details/123454426">MySQL事务日志详解</a></p>
<h3 id="多版本并发控制mvcc">4. 多版本并发控制MVCC</h3>
<p><strong>在MySQL你可以认为MVCC是行级锁的一种变种，为适应并提升并发性能，大多数情况下避免了加锁操作，因此开销更低，也解决了MySQL默认隔离级别可重复读下的幻读问题</strong>。MVCC旨在<code>repeatable read</code>和<code>read committed</code>下工作。</p>
<p><strong>MVCC的实现，是通过保存数据在某个时间点（说是时间点是未了更好理解，其实是事务的系统版本号）的快照来实现的。在InnoDB的MVCC中，通过在每行记录后面保存两个隐藏的列来实现，这两个列一个是保存了行的创建时间，一个保存了行的过期时间，当然存储的不是实际的时间值，而是系统版本号，系统版本号会根据没新开一个事务而自动递增</strong>。有了这两个列之后，对于<code>select\update\delete\insert</code>则必须遵循下面的规则：</p>
<ul>
<li><strong><code>select</code></strong>：对于select，InnoDB会根据一下规则来检索
<ul>
<li><ol type="a">
<li><strong>InnoDB只查找版本号早于当前事务版本号的数据行，这样确保了事务读取的行，要么在事务开始之前就已经存在，要么是当前事务自己插入或者修改的，绝不可能是该事务之后的事务进行修改的，这样解决了幻读的问题。</strong></li>
</ol></li>
<li><ol start="2" type="a">
<li><strong>行的删除版本要么未定义，要么就是大于当前事务的版本号，这就可以确保事务读取到的行，在该十五i开始前还未删除。如果之前就删除了那么删除版本号肯定有值而读取不了。</strong></li>
</ol></li>
</ul></li>
<li><p><strong><code>INSERT</code></strong>：InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p></li>
<li><p><strong><code>DELETE</code></strong>：InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p></li>
<li><p><strong><code>UPDATE</code></strong>：InnoDB为插入一行新记录，保存当前事务系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p></li>
</ul>
<p><strong><em>注意：MVCC并不能彻底解决并发带来的安全问题，它只是起到一个缓解并发冲突量的作用，如果两个事务有明显的次序要求，如事务A，B是希望A修改该行后再交由B修改，那么就必须人为事务A所在的行加锁，这样才能保证B是再A修改后才修改的</em></strong>，因此该用锁的时候还是要用，否则有MVCC就能解决这些的话，还要锁干嘛</p>
<h3 id="mysql的存储引擎">5. MySQL的存储引擎</h3>
<p>数据库存储引擎是极其重要的，这是因为：</p>
<ul>
<li>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。</li>
<li>不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL的核心就是存储引擎。</li>
<li>用户可以根据不同的需求为数据表选择不同的存储引擎(表类型)</li>
</ul>
<p>MySQL的存储引擎主要有InnoDB、MyISAM。</p>
<h4 id="innodb">5.1 InnoDB</h4>
<p>InnoDB是MySQL当中默认的事务型存储引擎，它被设计用来处理大量的短期事务，短期事务大部分情况下都是正常提交的，很少会回滚。<strong>InnoDB的数据存储在表空间<code>xxx.ibd</code>中，能将表的数据和索引放置在单独的文件中，其表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能，不过它的二级索引（非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的索引都会很大，消耗空间多</strong></p>
<p><strong>InnoDB的特点：</strong></p>
<ul>
<li><strong>采用MVCC多版本并发控制来支持高并发，并且实现了四个标准隔离级别，默认级别为可重复的，使用间隙锁和MVCC策略防止了幻读的出现。</strong></li>
<li>支持自动增长列`AUTO_INCREMENT·。自动增长列的值不能为空，且值必须唯一。MySQL中规定自增列必须为主键。</li>
<li>支持外键，保证数据的完整性和正确性。外键所在表为子表，外键所依赖的表为父表。父表中被子表外键关联的字段必须为主键</li>
<li><strong>支持行级锁，提高并发访问性能。</strong></li>
<li><strong>作为事务性存储，InnoDB通过一些机制和工具支持真正的热备份。</strong>（热备份是指在正常情况下,两余度同时工作,当某一余度出现故障时,系统可切除故障余度,启用单余度方式,降级工作.本系统采用热备份方式）</li>
</ul>
<h4 id="myisam">5.2 MyISAM</h4>
<p>MyISAM是MySQL早期的默认存储引擎。MyISAM将表存储在两个文件中：数据文件(<code>xxx.MYD</code>)和索引文件(<code>xxx.MYI</code>)。MyISAM不支持事务和行级锁，而且有一个致命的缺陷就是崩溃后无法安全恢复。</p>
<p><strong>MyISAM特点：</strong></p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>占用空间小，访问速度快 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/engine.png" width="700"></li>
</ul>
<h3 id="mysql的索引">6. MySQL的索引</h3>
<p>索引在MySQL中也叫<strong>键</strong>，是存储引擎用于快速找到记录的一种数据结构。因此索引对于数据库的性能非常关键，尤其是当表中的数据量越来越多时，索引对性能的影响愈发重要。总计索引的优点有三点：</p>
<ul>
<li>索引可以快速查询，大大减少了服务器查找时需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变成顺序I/O，如<code>order by</code>就是索引支持的</li>
</ul>
<p><strong>索引分类（逻辑角度）</strong>：</p>
<ul>
<li><strong>普通索引：</strong>是最基本的索引，主要其加快查询速度，可使用<code>key</code>或者<code>index</code>定义一个列的普通索引或联合普通索引。</li>
<li><strong>主键索引</strong>：即主键，一个表只能有一个主键，则也就只能有一个主键索引，不允许有重复值和<code>NULL</code>值。以<code>primary key</code>定义。</li>
<li><strong>唯一索引</strong>：不允许有重复值，但运行为<code>NULL</code>值，同时一个表可以有多个唯一索引。适用<code>unique key</code>或者<code>unique index</code>定义</li>
<li><strong>多列索引（复合索引）</strong>：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li>
</ul>
<p><strong><em>注意</em></strong>：<code>key</code>和<code>index</code>的区别是，<code>key</code>除了会定义一个相应的索引之外，还会形成一种约束，约束该列的规范，比如<code>primary key</code>约束表只能有一个主键列，且不能重复不能为NULL，而<code>index</code>只是生成这一的一个索引。</p>
<blockquote>
<p>索引分类 <strong>从物理存储角度:</strong> 聚簇索引和非聚簇索引 <strong>从数据结构角度:</strong> B+树索引、hash索引、FULLTEXT索引、R-Tree索引</p>
</blockquote>
<h4 id="索引基础">6.1 索引基础</h4>
<p>理解索引当然是看例子更合适： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">select first_name from sahilia.actor where actor_id=<span class="number">5</span>;</span><br></pre></td></tr></table></figure> 上面这个检索语句中，如果在<code>actor_id</code>列上设有索引，则MySQL将使用索引找到<code>actor_id=5</code>的行，即MySQL会在索引上按值查找，然后返回该值的数据行。</p>
<p>索引可以包含一个或多个列(创建键)。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效的使用索引的<strong>最左前缀原则</strong>。需要明确的是<strong>最左前缀原则</strong>是发生在复合索引上的，只有复合索引才会有所谓的左和右之分，在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配</p>
<p><strong>mysql 建立多列索引（联合索引）有最左前缀的原则，即最左优先，如：</strong></p>
<ul>
<li>如果有一个 2 列的索引<code>(col1, col2)</code>，则已经对<code>(col1)、(col1, col2)</code>上建立了索引；</li>
<li>如果有一个 3 列索引<code>(col1, col2, col3)</code>，则已经对<code>(col1)、(col1, col2)、(col1, col2, col3)</code>上建立了索引；</li>
</ul>
<p><strong>原理</strong>：</p>
<p>B+树的数据项是复合的数据结构，比如<code>(name,age,sex)</code>的时候，B+树是按照从左到右的顺序来建立索引树的，比如当<code>(张三,20,F)</code>这样的数据来检索的时候，B+树就优先比较name来确定下一步的搜索方向，如果name相同则再依次比较<code>age</code>和<code>sex</code>，最后得到检索到的数据；但当<code>（20，F）</code>这样的没有<code>name</code>的数据来的时候，B+树就不知道第一步应该检查哪个节点，因此此时就不会使用联合索引。</p>
<h4 id="索引类型">6.2 索引类型</h4>
<p>索引有很多种类型，可以为不同的场景提高供更好的性能。在MySQL中，索引是在存储引擎实现的，因此没有统一的索引标准。下面介绍MySQL中的支持的索引类型。</p>
<h5 id="btree索引">6.2.1 B+Tree索引</h5>
<p>InnoDB使用的时B+Tree索引。这意味着所有的值都是按顺序存储的，<strong>且数据域都存储在叶子节点处，非叶子节点只存储索引不能存储数据</strong>，这样对于查询性能来说很稳定，都是<code>h</code>。B+Tree索引适用于全键值、键值范围或键前缀查找：比如定义了普通联合索引<code>key(last_name,first_name,birthday)</code></p>
<ul>
<li><strong>全值匹配：</strong>指的是和索引中的所有列进行匹配，即<code>last_name,first_name,birthday</code>均匹配</li>
<li><strong>匹配最左前缀</strong>：查找时，可以只列举第一列<code>last_name</code>进行查找</li>
<li><strong>匹配列前缀</strong>：也可只匹配某一列的值的开头部分，如寻找姓以<code>J</code>开头的数据</li>
<li><strong>匹配范围</strong>：对姓名<code>last_name</code>也支持范围查找。</li>
</ul>
<p><strong><em>注意：说到B+Tree的叶子节点，必须区分MySQL中的聚簇索引和非聚簇索引（二级索引），在聚簇索引的叶子节点存储的是完整的行数据，而二级索引叶子节点存储的是数据<code>行指针</code>,这里的<code>行指针</code>的实质是叶子节点保存只是行的主键值，因此非聚簇索引必须还要在聚簇索引结构上进行查找，这也是为什么它被称为二级索引</em></strong></p>
<p>更详细的B+Tree见：<a href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构</a></p>
<h5 id="哈希索引">6.2.2 哈希索引</h5>
<p><strong>哈希索引是基于哈希表实现的，因此对于使用哈希索引其关键字的存储是无序的，不支持范围匹配查找，只有精确匹配锁索引所有列的查询才有效。</strong>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码解决其存储的位置，因此其查找一个值的复杂度为<code>O(1)</code>，比B+Tree更快。</p>
<p>在MySQL中，只有Memory引擎显式支持哈希索引，也是其默认的索引类型。</p>
<p><strong>优点：</strong></p>
<ul>
<li>访问内存的速度很快，同时因为是通过计算哈希值来确定关键字位置，访问哈希索引的数据也很快</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不会存储字段值，所有不能使用索引中的值来避免读行。</li>
<li>哈希索引数据是按照计算的哈希值排列的，因此也就是无序的，不支持范围查找。</li>
<li>哈希索引不想B+Tree索引那样支持部分列查找，因为索引的哈希值是所有列共同计算的结果。</li>
<li>哈希冲突多的时候，维护操作的代价比较高昂。</li>
</ul>
<h4 id="为什么b树更适合做索引">6.3 为什么B+树更适合做索引</h4>
<p><strong>我们先分析B+Tree与众不同的特点：</strong></p>
<ul>
<li>第一个就是B+树在B树的基础之上最重要的改进就是非叶子结点只存储关键字和下一层的索引，不存储Data域，只在叶子结点存储Data域；</li>
<li>第二点就是利用B+树的天然有序且在所有叶子结点增加一个链指针，是InnoDB中支持order by limit的原因所在。所有叶结点构成一个有序链表，因此当我们需要有序遍历所有关键字或者按范围查询时，直接从最小关键字的叶子结点开始遍历即可。</li>
</ul>
<h6 id="非叶子结点不存储data域的好处">6.3.1非叶子结点不存储Data域的好处</h6>
<ul>
<li><p><strong>每一个结点可以存放更多的关键字和下一层的索引。数据库是存储在磁盘上的，我们读取数据是从磁盘读取到内存中，我们在进行磁盘预读取时，是以块的单位进行数据读取，我们在检索B/B+树的结点时，每次以块为单位将一个结点读取到内存中，若一块磁盘包含了树结点以外的数据，就造成了浪费，因此我们需要使每一个结点的数据大小正好或者接近一块磁盘的大小</strong>。于是我们在构建B+/B树时，树的阶数其实就取决于一块磁盘中能容纳多少个关键字以及相关的索引和Data域。<strong>B+树的非叶子结点不存储Data域，因此它可以存储更多个关键字和下一层索引，因此B+树会比B树更宽胖</strong>。若我需要查找的关键字正好在叶子结点，B+树所进行的I/O次数更少,因为途中经过每一层，我们都需要进行一次I/O读取一个结点，B+树会更矮，途径的层数会更少。</p></li>
<li><p>使得B+树查询速度更稳定，B+树所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p></li>
</ul>
<h5 id="所有叶结点构成一个有序链表的好处">6.3.2所有叶结点构成一个有序链表的好处</h5>
<ul>
<li><p><strong>B+树便于区间查找（这点才是B+树作为索引的关键）</strong>，我们进行数据库查询大多为区间查询，B+树天然具备排序功能，B+树所有的叶子结点构成了一个有序链表，在查询大小区间的数据时候更方便，B+树查询，只需通过头结点往下找到第一个叶子结点，然后在叶子结点的链表上就行遍历即可完成区间查询，而B树的关键字大小相邻近的结点可能隔得很远，要想进行区间查询需要不停的进行中序遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li>
<li><p>B+树全结点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要进行中序遍历，这有利于数据库做全表扫描。</p></li>
</ul>
<p><strong>总结B+树优点(选择B+树作为索引的原因)</strong></p>
<ul>
<li>因为没有非叶子节点没有存储数据，因此单一非叶子结点能存储更多的关键字索引</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；</li>
<li>所有叶子节点形成有序链表，便于范围查询以及全结点遍历更快。</li>
</ul>
<h4 id="高性能的索引策略">6.4 高性能的索引策略</h4>
<p>正确的创建和使用索引是实现高性能查询的基础。创建索引是最忌讳的就是为每一个列都建上独立的索引或者按照错误的顺序创建联合索引，这样会大大降低性能。</p>
<blockquote>
<p>索引不是越多越好，会降低性能！！为什么会降低性能呢？ 且听我娓娓道来 数据库中建立一个索引，那么就得维护，当你在一张表建立了100个索引，你就得在每次插入、删除都得维护这100个索引，这性能能好吗？</p>
</blockquote>
<p>但对于中表，适当的建立数据库的表索引能够有效的提升性能，<strong>如何建立高性能的索引是本节的主题，主要有</strong>：</p>
<ul>
<li><strong>选择适当的列建立聚簇索引（适当的列是指频繁查询且唯一的字段，这样对于大多数查询来说都避免了回表查询）</strong></li>
<li><strong>对于字符类型索引，可以尝试建立前缀索引</strong></li>
<li><strong>对于建立联合索引（复合索引），必须把选择性高的列放在前面</strong></li>
<li><strong>建立覆盖索引来避免回表查询</strong></li>
<li>合理利用冗余索引（当我们向表中添加字段(B)，现有的联合索引<code>(A,C)</code>已经过于庞大，维护困难，我们可以考虑添加<code>(A,B)</code>索引)</li>
</ul>
<h5 id="前缀索引单列索引字符">6.4.1 前缀索引：单列索引（字符）</h5>
<p><strong>有时候需要索引很长的字符列，但这会让索引变得大且慢</strong>。 一个策略是<strong>可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率</strong>。但是<strong>也会降低索引的选择性，其选择性是指不重复的索引值<code>d</code>和数据表的记录总数<code>T</code>的比值</strong>，即<span class="math inline">\(d/T\)</span>。</p>
<p>如下面计算左前缀前几位时的选择性<code>left(city,7)</code>表示取<code>city</code>的前7位： <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/qian.png" width="700"></p>
<p>根据上面的描述，我们应该用<code>city(7)</code>创建前缀索引 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alter table sakila.<span class="function">city_demo add <span class="title">key</span> <span class="params">(city(<span class="number">7</span>))</span></span>;</span><br></pre></td></tr></table></figure> <strong>优缺点：</strong>值得一提的是，前缀索引是一种能使索引更小、更快的有效办法，但缺点使MySQL无法使用前缀索引做<code>order by</code>和<code>group by</code>，也无法使用前缀索引做覆盖扫描。</p>
<h5 id="选择合适的索引序列联合索引">6.4.2 选择合适的索引序列：联合索引</h5>
<p>对于B+Tree多列索引来说，按照其最左前缀匹配原则，正确的的顺序依赖于使用哪些列选择性高，同时还有考虑如何更好的满足排序和分组的需要，即满足<code>order by\group by\distinct</code>查询子句的查询需求。</p>
<p><strong>有一条经验法则：将选择性最高的列放在索引的最前面，选择性。</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">count</span><span class="params">(distinct staff_id)</span>/<span class="title">count</span><span class="params">(*)</span> as staff_id_selectivity,</span></span><br><span class="line"><span class="function">	-&gt; <span class="title">count</span><span class="params">(distinct customer_id)</span>/<span class="title">count</span><span class="params">(*)</span> as customer_id_selectivoty,</span></span><br><span class="line"><span class="function">	-&gt; <span class="title">count</span><span class="params">(*)</span></span></span><br><span class="line"><span class="function">	-&gt; from payment</span>;</span><br><span class="line">-------------------------------输出--------------------------------------------------*</span><br><span class="line">staff_id_seletivity:<span class="number">0.0001</span></span><br><span class="line">customer_id_selectibity:<span class="number">0.0373</span></span><br><span class="line"><span class="built_in">count</span>(*):<span class="number">16049</span></span><br></pre></td></tr></table></figure> 从上面可以看到选择性更高的是<code>customer_id</code>，因此将其放在索引第一列： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">alter table payment add <span class="title">key</span><span class="params">(customer_id,staff_id)</span></span>;</span><br></pre></td></tr></table></figure> 最后还要说一句尽管这条关于选择性和基数的经验法则对于一般情况适用，但是别忘了还要考虑<code>where</code>子句当中的排序、分组和范围查询，要对这些折中考虑。</p>
<h4 id="聚簇索引">6.5 聚簇索引</h4>
<p>首先要明白的是聚簇索引不是开始说到的属于<strong>普通索引、唯一索引和主键索引的分类</strong>，MySQL的索引分类只有这三种。<strong>聚簇索引并不是一个单独索引类型，而是一种数据的存储方式的专有名词</strong>。</p>
<p><strong>对于InnoDB来说，InnoDB就会选择一个唯一的非空索引作为聚簇索引，当没有符合的唯一非空索引，就会隐式的定义一个主键来作为聚簇索引</strong>，因此一般情况你也可以理解主键就是聚簇索引；但是，有些时候唯一索引也有可能是聚簇索引</p>
<h5 id="聚簇索引与非聚簇索引的区别">6.5.1 聚簇索引与非聚簇索引的区别</h5>
<p>在上面说到B+Tree的时候已经介绍到了聚簇索引和非聚簇索引之间的区别，这里在系统的总结一下。</p>
<ul>
<li><strong>首先就是一张表只有有一个聚簇索引，但可以有多个非聚簇索引</strong></li>
<li><strong>另外聚簇索引的叶子节点存储的是完整的行数据，而非聚簇索引的叶子节点存储的是其相应主键列的关键字值，因此使用非聚簇索引进行查询时，除了查询非聚簇索引得到主键关键字值外，还要利用该值进行回表查询聚簇索引，最终得到整个行数据</strong>，这也是非聚簇索引又叫二级索引的由来。</li>
</ul>
<p><img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/aindex.png" width="700"> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用主键索引(聚簇索引)查询</span></span><br><span class="line">select * from table where ID = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//使用非聚簇索引查询</span></span><br><span class="line">select * from table where k = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="聚簇索引的优缺点">6.5.2 聚簇索引的优缺点</h5>
<p>聚簇索引可能对性能有帮助，但也会导致严重的问题，下面分析其优缺点</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>聚簇索引的存在将相关数据都保存在一起，磁盘一次I/O就获得所有数据</strong>，如用户邮箱的管理，以ID为主键形成聚簇索引结构，则更加ID用户将其相关的数据都聚簇在叶子节点，可一下获得其所有数据。如果没有聚簇索引，则要获取该ID的所有信息要经过多次磁盘I/O</li>
<li><strong>数据访问速度更快，聚簇索引将索引和数据保存在同一个B+Tree上，因此聚簇索引比非聚簇索引的查询更快。</strong></li>
<li>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>插入速度严重依赖插入的顺序，其存储结构说明了按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式</strong>。如果不是按照逐渐顺序，会慢很大，而且最坏使用<code>optimize table</code>重新组织一下表。
<ul>
<li>实验表明按主键列的值顺序的插入记录要快于乱序插入：
<ul>
<li>这是因为乱序插入使得InnoDB不得不频繁的做页分裂操作，以便为新的行分配空间，而页分裂导致移动大量的数据。</li>
<li>要插入的目标页可能还没有刷到缓存，那么此时InnoDB就不得不先从磁盘读取目标页到内存中，这将增加磁盘与内存的IO次数，导致速度性能下降。</li>
</ul></li>
</ul></li>
<li><p>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</p></li>
<li><p>更新行或插入行被强制移动带新的行，如果是要插入满行的一页，则会导致<code>页分类</code>。存储引擎通过页分裂称两个页面以能够存储该行，一次页分裂操作，导致表占有更多的空间。</p></li>
<li><p>二级索引（非聚簇索引）访问需要两次索引查找，而不是一次</p></li>
<li><p>在行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描变慢。</p></li>
</ul>
<h4 id="覆盖索引">6.6 覆盖索引</h4>
<p>上面提到了二级索引想要查询行的所有列必须进行回表查询，有没有什么办法不用回表查询就能得到一些列的信息呢。这是要就用到了<strong>覆盖索引</strong>，<strong>如果一个二级索引的叶子节点就包含了所有要查询字段的值，就称为为覆盖索引</strong>。在<code>select</code>前使用<code>explain</code>表示优先使用覆盖索引</p>
<p>不是所有的索引类型都能成为覆盖索引，覆盖索引必须存储该索引所在行的值，而像哈希索引、空间索引这些都不能存储。因此MySQL只有B+Tree索引能使用覆盖索引。现在来讲解覆盖索引的实现要求：</p>
<ul>
<li>表有除一个主键索引，其他列建立相应的二级索引，这一才能在二级索引存储有其他列的值。对于主键很明显在二级索引的叶子节点上</li>
<li>在<code>select</code>上使用<code>explain</code>，优先使用覆盖索引</li>
</ul>
<p><strong>一个最简单的覆盖索引例子就是如下：</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">TEST_FU</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	ID INT NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span></span></span><br><span class="line"><span class="params"><span class="function">	NAME VARCHAR(<span class="number">8</span>) NOT <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	AGE DOUBLE NOT <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	PRIMARY KEY (ID),</span></span></span><br><span class="line"><span class="params"><span class="function">	INDEX (NAME)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span>ENGINE</span>=InnoDB;</span><br></pre></td></tr></table></figure> 上面的表含有三个字段，其中<code>ID</code>为主键，<code>NAME</code>为普通索引，那么<code>NAME</code>作为二级索引，其叶子节点存储的是主键的值，那么下述语句： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT ID,NAME FROM TEST_FU WHERE NAME=<span class="string">&#x27;trluper&#x27;</span>;</span><br></pre></td></tr></table></figure> &gt;上面这条语句由于只要<code>ID\NAME</code>，而在<code>NAME</code>中的叶子节点就是存储<code>ID</code>的值，此时就不必去聚簇索引进行回表查询了，只需一次就能查询到结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT ID,NAME,AGE FROM TEST_FU WHERE NAME=<span class="string">&#x27;trluper&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面这条语句由于只要<code>ID\NAME</code>，而在<code>NAME</code>中的叶子节点就是存储<code>ID</code>的值，但是<code>AGE</code>并不在二级索引中，此时就还是要求去聚簇索引进行回表查询了，那么查询就不会走覆盖索引了。</p>
</blockquote>
<p><a href="https://blog.csdn.net/lengyue1084/article/details/119352209">覆盖索引详解</a></p>
<h4 id="冗余索引">6.7 冗余索引</h4>
<p>同一信息的重复储存，叫做冗余,冗余索引通常发生在为表添加新索引的时候。如<code>key(name,city)</code>和<code>key(name)</code>这两个索引就是冗余索引，能够命中后者的查询肯定能够命中前者。</p>
<p>大多数情况下我们都不需要冗余索引，因为索引的维护需要一定的开销。但有时候却页不得不创建一个冗余索引，就比如新加了一个字段，同时现有的联合索引已经非常庞大，如果再将这字段加入这个联合索引就会使得该联合索引更加庞大，此时使用新建冗余索引更好。</p>
<h3 id="优化查询">7. 优化查询</h3>
<p><strong>查询优化、库表结构优化和索引优化</strong>在优化数据库中应该齐头并进，一个不落。上面已经介绍了索引的知识，在这里我们将着重介绍<strong>如何编写高效的SQL查询语句，在这个过程中也将设计高效的表结构和索引。</strong></p>
<p>查询的大致生命周期：<code>客户端--&gt;服务器（解析--&gt;生成执行计划--&gt;执行--&gt;返回结果）</code></p>
<h4 id="查询语句本身优化">7.1 查询语句本身优化</h4>
<p>查询性能低的最基本原因是访问的数据太多。大部分性能低下的的查询都可以通过减少访问的数据量方式进行优化。对于低效的查询，通过下面两个方法分析是很有效的：</p>
<ul>
<li><strong>确认应用程序是否在检索大量超过需要的数据(比如不要使用<code>select *</code>,它会检索出一行中的所有数据，但是实际中我们可能用不到所有数据)。这恶通常意味者访问太多的行，有时候也有可能是访问太多的列（<code>select *</code>)</strong></li>
<li>确认MySQL服务器层是否分析大量超过需要的数据行。</li>
</ul>
<p><strong>所有一般来说我们的查询语句应该遵循下面规范，能够达到优化目的：</strong></p>
<ul>
<li>** 对于不需要的记录，应当避免，合理增加一些限制，如<code>limit</code>**</li>
<li><strong>不要总是取出全部的列，即尽量不使用<code>select *</code>，因为这会带来额外的磁盘IO、CPU服务资源</strong></li>
</ul>
<h4 id="重构查询语句">7.2 重构查询语句</h4>
<p>MySQL数据库的连接和断开都很轻量级、在返回一个小查询结果非常高效。且现代通信网络非常快、在一通用的服务器上，每秒运行超10万的查询是能够的。</p>
<p><strong>因此对于查询语句也能够这样优化：将复杂的大的SQL语句切分成下查询语句，每个小查询功能完全一样，只完成一小部分，每次只返回一小部分的查询结果</strong>，达到”分而治之“的效果。</p>
<p>比如说每个月我们都有执行下面的语句： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DELETE FROM messgaes WHERE created&lt;<span class="built_in">DATA_SUB</span>(<span class="built_in">NOW</span>(),INTERVAL <span class="number">3</span> MONTH);</span><br></pre></td></tr></table></figure> 那么我们可以使用下面切分后的语句 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rows_affected=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	row_affected=<span class="built_in">do_query</span>(<span class="string">&quot;DELETE FROM messgaes WHERE created&lt;DATA_SUB(NOW(),INTERVAL 3 MONTH) LIMIT 10000&quot;</span>);</span><br><span class="line">&#125;where rows_affected&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="查询执行过程">7.3 查询执行过程</h4>
<p>我们要编写好的SQL语句，就必须知道MySQL是如何优化和执行查询的 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/sqlRun.png" width="700"> - 客户端发送一条查询给服务器 - 服务器先检查查询缓存，如果缓存命中，则立刻返回存储在缓存中的结果，否则进入下一阶段 - 服务器进行SQL解析，预处理、再由优化器生成对应的执行计划 - MySQL根据优化器生成的执行计划，再由存储引擎的API来执行查询 - 将结果返回给客户端</p>
<p>上面的每一步都是很复杂的，这里这是简述</p>
<h4 id="查询优化处理">7.4 查询优化处理</h4>
<h5 id="查询优化器">7.4.1 查询优化器</h5>
<p>通过语法解析后的SQL语句被认为是合法的，然后由优化器将其转化为执行计划，一条查询可以由很多种执行方式，<strong>优化器的作用就是找到其中最好的可执行计划</strong>。</p>
<p><strong>MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择成本最小的一个</strong>。我们可以通过查询当前会话的<code>LAST_QUERY_COST</code>的值来得到MySQL计算当前查询的成本 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from CUSTOMER;</span><br><span class="line">+----+--------+------------+---------+</span><br><span class="line">| ID | SALARY | HIREDATE   | NAME    |</span><br><span class="line">+----+--------+------------+---------+</span><br><span class="line">|  <span class="number">1</span> |  <span class="number">23000</span> | <span class="number">2025</span><span class="number">-06</span><span class="number">-06</span> | trluper |</span><br><span class="line">|  <span class="number">2</span> |   <span class="number">9000</span> | <span class="number">2025</span><span class="number">-04</span><span class="number">-26</span> | 小明    |</span><br><span class="line">|  <span class="number">5</span> |  <span class="number">21000</span> | <span class="number">2021</span><span class="number">-06</span><span class="number">-06</span> | 瑞凤    |</span><br><span class="line">|  <span class="number">8</span> |  <span class="number">19000</span> | <span class="number">2025</span><span class="number">-01</span><span class="number">-26</span> | 点点    |</span><br><span class="line">+----+--------+------------+---------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW STATUS LIKE &#x27;LAST_QUERY_COST&#x27;</span>;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Last_query_cost | <span class="number">0.649000</span> |</span><br><span class="line">+-----------------+----------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.09</span> sec)</span></span></span><br></pre></td></tr></table></figure> 这个结果表示MySQL的优化器任务大概需要0.649个数据页的随机查找才能完成上面的查询。这个数据是根据一系列的统计信息得来的。</p>
<p>有很多原因会导致MySQL优化器选择错误的执行计划：</p>
<ul>
<li>统计信息不准确。MySQL依赖引擎提高的统计信息来评估成本，但是有的存储引擎提高的信息偏差大。</li>
<li>执行计划种的估计成本不等同于实际执行的成本，所以即使统计信息准确，优化器给出的执行计划可能不是最优的。</li>
<li>MySQL的最优与你想的最优不一样。你希望执行用时尽可能少，但MySQL的最优只是基于模型选择最优的执行计划，有时候这并不是最快的执行计划。</li>
<li>MySQL不考虑其他并发执行的查询，这可能影响当前的查询速度</li>
</ul>
<p>MySQL使用优化策略有<strong>动态优化和静态优化</strong></p>
<ul>
<li>静态优化：直接对解析树进行分析，并完成优化，静态优化在第一次完成后一直有效。可以看作是一直<code>&quot;编译时优化&quot;</code>。比如对<code>where</code>条件转换为另一种等价形式。</li>
<li>动态优化：动态优化在每次执行时都要重新评估，有时候升值在查询的执行过程种也会重新优化。被认为时<code>运行时优化</code>.</li>
</ul>
<h4 id="优化特定类型的查询">7.5 优化特定类型的查询</h4>
<h5 id="优化关联查询">7.5.1 优化关联查询</h5>
<p>含有关联查询（有主外键对应）的查询语句是MySQL的主要讨论话题，这里需要注意以下的优化选择：</p>
<ul>
<li><strong>确保<code>ON</code>或者<code>USING</code>字句种的列有索引</strong>。同时在创建索引的时候就需要考虑关联顺序，当表<code>A</code>和表<code>C</code>使用列<code>c</code>关联时，如果优化器的关联顺序是<code>B、A</code>，那么就不需要在<code>B</code>表的对应列上建立索引。一般来说，只需要关联顺序的第二个表的相应列建立索引。</li>
<li><strong>确保任何的<code>group by</code>和<code>order by</code>中的表达式只涉及到一个表中的列，这样<code>MySQL</code>才能可能使用索引来优化这个过程</strong></li>
</ul>
<h5 id="子查询">7.5.2 子查询</h5>
<p>对于子查询，优化的建议是尽可能的使用关联查询替代。</p>
<blockquote>
<p>子查询：子查询是指嵌套select语句，可以一次完成很多逻辑上需要多个步骤才能完成的SQL操作。查询虽然很灵活，但是执行效率并不高。这是因为执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。 关联查询：通过<code>join</code>方式进行多表查询，连接查询不需要建立临时表，因此一般来说其速度比子查询快</p>
</blockquote>
<h3 id="常见题目">8 常见题目</h3>
<p>这里列举了一些最可能问的问题，面试可以加强印象。</p>
<h4 id="你一般怎么建索引的">8.1 你一般怎么建索引的？</h4>
<ul>
<li><strong>选择适当的列建立聚簇索引（适当的列是指频繁查询且唯一的字段，这样对于大多数查询来说都避免了回表查询）</strong></li>
<li><strong>对于字符类型索引，可以尝试建立前缀索引</strong></li>
<li><strong>对于建立联合索引（复合索引），必须把选择性高的列放在前面</strong></li>
<li><strong>建立覆盖索引来避免回表查询</strong></li>
</ul>
<p>当然，对索引的优化可以按照下面步骤来： - 去my.cnf里配置三个配置，输出<strong>慢查询日志</strong>，查询查询慢的SQL <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#打开慢查询日志</span><br><span class="line">slow_query_log=<span class="number">1</span></span><br><span class="line">#慢查询日志存储路径</span><br><span class="line">slow_query_log_file=/var/log/mysql/log-slow-queries.log</span><br><span class="line">#SQL执行时间大于<span class="number">3</span>秒，则记录日志</span><br><span class="line">long_query_time=<span class="number">3</span></span><br></pre></td></tr></table></figure> - 当我们看到慢SQL后，不是马上去建立索引，而是看能不能优化SQL。大多数情况下，业务SQL比较复杂，很难优化，因此建立索引要参照下面的规则： - (1)索引并非越多越好，大量的索引不仅占用磁盘空间，而且还会影响insert,delete,update等语句的性能 - (2)索引需要维护，因此避免对经常更新的表做更多的索引，并且索引中的列尽可能少；对经常用于查询的字段创建索引，避免添加不必要的索引 - (3)数据量少的表尽量不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果 - (4)在条件表达式中经常用到不同值较多的列上创建索引，在不同值很少的列上不要建立索引 - (5)在频繁进行排序或者分组的列上建立索引，如果排序的列有多个，可以在这些列上建立联合索引，联合索引中列顺序按照选择性排列。</p>
<h4 id="讲讲索引的分类你知道哪些">8.2 讲讲索引的分类？你知道哪些？</h4>
<ul>
<li><strong>从物理存储角度:</strong>
<ul>
<li>聚簇索引和非聚簇索引</li>
</ul></li>
<li><strong>从数据结构角度:</strong>
<ul>
<li>B+树索引、hash索引、</li>
</ul></li>
<li><strong>从逻辑角度:</strong>
<ul>
<li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li>
<li>普通索引或者单列索引</li>
<li>多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li>
<li>唯一索引或者非唯一索引</li>
</ul></li>
</ul>
<h4 id="如何避免回表查询什么是索引覆盖">8.3 如何避免回表查询?什么是索引覆盖?</h4>
<p>当能通过读取索引就可以得到想要的数据，那就不需要回表读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做索引覆盖。</p>
<h4 id="现在我有一个列里头的数据都是唯一的需要建一个索引选唯一索引还是普通索引">8.4 现在我有一个列，里头的数据都是唯一的，需要建一个索引，选唯一索引还是普通索引？</h4>
<p><strong>唯一索引</strong>。业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p>
<p>这里衍生另一个问题 #### 8.5 为什么唯一索引的插入速度比不上普通索引？为什么唯一索引的查找速度比普通索引快？ <strong>背景：</strong>MySQL数据库对数据的修改不会立马刷新在磁盘上，所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘，通过缓存池来优化cpu和磁盘之间的鸿沟。这么做的优点是能将多个插入合并到一个操作中，减小与磁盘的IO次数，提升数据库性能。</p>
<p>基于此，InnoDB 引入了 <code>Change Buffer</code>缓存，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。</p>
<p>唯一索引的插入速度比普通索引慢、查询快的原因就是:</p>
<ul>
<li>在更新时，普通索引将记录放在<code>change buffer</code>中即执行完毕；唯一索引为保证数据的唯一性，需要校验唯一性，必须将数据页读入内存确定没有冲突，然后才能继续操作,不能使用<code>change buffer</code>；</li>
<li>查询时： 未使用<code>limit 1</code>的情况，唯一索引匹配到一条数据后即返回；普通索引回继续匹配下一条数据，发现不匹配后才返回。从这里看，唯一索引比较普通索引少了一次匹配过程。</li>
</ul>
<p>这里又产生了另一个问题： #### 8.6 为什么唯一索引的更新不使用 <code>Change Buffer</code> 因为唯一索引为了保证唯一性，需要将数据页加载进内存才能判断是否违反唯一性约束。但是，既然数据页都加载到内存了，还不如直接更新内存中的数据页，没有必要再使用<code>Change Buffer</code>。</p>
<h4 id="mysql索引是什么结构的用红黑树可以么">8.7 mysql索引是什么结构的？用红黑树可以么？</h4>
<p>MySQL常用的数据结构是<code>B+ tree</code>。B+有两个重要的特点：</p>
<ul>
<li><strong>一是非叶子节点不存储数据，数据只在聚簇索引的叶子节点处存储（数据文件和索引文件聚合在一起）</strong>。这表面设计者可以在非叶子节点存储更多的索引，B+树层数小，更加宽胖，减少磁盘的IO，提升数据库的性能。</li>
<li><strong>二是B+树的叶子节点间使用了双向链表指针连接起来</strong>。这为MySQL的范围查找提供了更好的性能。 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/B+Tree.png" width="700"> AVL树和红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据数据存储的时候，显然不能将全部数据全部加载进内存，因此如果采用红黑树，就会造成频繁磁盘IO，效率低下。</li>
</ul>
<h5 id="那为啥不用b-tree而选择b-tree呢">8.7.1那为啥不用B Tree,而选择B+ tree呢？</h5>
<p>首先我们要看一下两者结构的区别 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/BTree.png" width="700"> <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/B+Tree.png" width="700"></p>
<p>可以看到： - <strong>B Tree的除了叶子节点外树内会存储数据，而B+树只在叶子节点存储数据。</strong>计算机从磁盘中读取数据是按块读取，每一个节点的数据大小正好或恰好接近一块磁盘大小。那么对于B+树来说，因为非叶子节点不存储数据，那么它们就可以存储更多的关键字和下一层索引，因此B+树会比B树更加宽胖，层数少，此时所进行的磁盘IO次数更少，效率更好。 - <strong>B Tree的除了叶子节没有双向链指针，而B+树叶子节点有链指针连接起来。</strong>B+树对范围查询更加友好、效率更高，它只需要遍历叶子节点就能够遍历整颗树，而B树则需要做局部的中序遍历才可以。 那你知道为啥Mongodb用B Tree当索引，而不用B+ Tree么</p>
<h5 id="那为啥mongodb用b-tree当索引而不用b-tree么">8.7.2 那为啥Mongodb用B Tree当索引，而不用B+ Tree么</h5>
<p>这样从两个数据库的区别来说了，Mongodb是非关系性数据库，他用类Json格式来保存数据，它的数据更多的是聚合过的数据，因此对于MongoDB的查询更多关注单个查询，单个查询要优于MySQL；</p>
<p>而MySQL是关系型数据库，数据的关联性是非常强的，表之间的关系更加强烈，更多的关注于范围查询，在叶子节点有链表指针连接，更有利于遍历查找。</p>
<p>就综合性能来看，MongoDB的单个查询比Mysql的平均查询速度要快。</p>
<h4 id="mysql某表建了多个单索引查询多个条件时如何走索引的">8.8 mysql某表建了多个单索引，查询多个条件时如何走索引的？</h4>
<p>Mysql在优化器中有一个优化器称为<code>Range</code>优化器，负责进行范围查询的优化！那么该优化器计算执行成本有两种方式<code>index dive</code>与<code>index statistics</code>。它们是MySQL优化器对开销代价的估算方法，前者统计速度慢但是能得到精准的值，后者统计速度快但是数据未必精准。</p>
<h4 id="mysql有哪几种log">8.9 mysql有哪几种log</h4>
<p>事务日志（重做日志<code>redo log</code>、回滚日志<code>undo log</code>）、二进制日志(binlog)、错误日志(errorlog)、慢查询日志(slow query log)、一般查询日志(general log)，中继日志(relay log)</p>
<ul>
<li>错误日志：记录出错信息，也记录一些警告信息或者正确的信息。</li>
<li>查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li>
<li><strong>慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</strong></li>
<li>二进制日志：记录对数据库执行更改的所有操作。</li>
<li>中继日志：中继日志也是二进制日志，用来给slave 库恢复</li>
<li><strong>事务日志：重做日志redo和回滚日志undo</strong></li>
</ul>
<h4 id="脏读不可重复读和幻读">8.10 脏读、不可重复读和幻读</h4>
<ul>
<li><p>脏读：脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并不一定最终存在的数据，这就是脏读。（未提交读会出现脏读） <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/dirtyRead.png" width="700"></p></li>
<li><p>不可重复读：不可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。就比如事务<code>A</code>多次读取同一数据，但事务<code>B</code> 在事务<code>A</code>多次读取的过程中，对数据作了更新并提交，导致事务<code>A</code>多次读取同一数据时，结果不一致。 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/notreaptread.png" width="700"></p></li>
<li><p><strong>幻读</strong>：所谓的幻读就是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围插入新的记录，当之前的事务再次读取该范围记录时，产生幻行。（即幻读是对于某个范围的插入而言）</p></li>
</ul>
<h5 id="不可重复读和幻读区别是什么">8.10.1 不可重复读和幻读区别是什么？</h5>
<p><strong>不可重复读的重点是修改，幻读的重点在于范围新增或者删除。</strong></p>
<ul>
<li>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。</li>
<li>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记 录就变为了5条，这样就导致了幻读。</li>
</ul>
<h4 id="dropdelete与truncate的区别">8.11 drop、delete与truncate的区别</h4>
<ul>
<li><code>Truncate</code>删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，<code>TRUNCATE</code>比<code>delete</code>更快，占用的空间更小。</li>
<li><code>delete</code>是DML语句,用来删除表的全部或者一部分行数据，可以作为事务中的语句，因此能够回滚，事务提交后才会生效，会触发这个表上所有的delete触发器。</li>
<li><code>Drop</code>命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。</li>
</ul>
<p>因此，在不再需要一张表的时候，用<code>Drop</code>；在想删除部分数据行时候，用<code>Delete</code>；在保留表而删除所有数据的时候用<code>Truncate</code>。</p>
<h4 id="sql优化方式">8.12 SQL优化方式</h4>
<ul>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 <code>where</code> 及 <code>order by</code> 涉及的列上建立索引。</p></li>
<li><strong>应尽量避免在 <code>where</code> 子句中对字段进行<code>null</code>值判断，否则将导致引擎放弃使用索引而进行全表扫描，</strong>如果索引是整形，那么可以在索引上设置默认值<code>0</code>，确保表中列没有 <code>null</code>值。(索引失效)</li>
<li><p><strong>应尽量避免在<code>where</code> 子句中使用<code>!=</code> 或<code>&lt;&gt;</code> 操作符，否则将引擎放弃使用索引而进行全表扫描。</strong>(索引失效)</p></li>
<li><p><strong>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。</strong>(索引失效)</p></li>
<li><code>in</code> 和 <code>not in</code> 也要慎用，否则会导致全表扫描。</li>
<li><p><code>like ‘%abc%’</code> 也会导致全表扫描。</p></li>
<li><p><strong>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</strong>(索引失效)</p></li>
<li><p><strong>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</strong>(索引失效)</p></li>
<li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</li>
<li><p>很多时候用 <code>exists</code> 代替 <code>in</code> 是一个好的选择。</p></li>
</ul>
<h4 id="索引在什么情况下会失效">8.13 索引在什么情况下会失效</h4>
<ul>
<li>1、在使用不等于<code>！=</code> 或者<code>&lt;&gt;</code> 这样的会失效。</li>
<li>2、在使用不包含<code>not in</code>、不存在<code>not exists</code>这样的会失效。</li>
<li>3、在使用空 <code>is null</code>、不为空 <code>is not null</code> 这样的会失效。</li>
<li>4、在使用小于 <code>&lt;</code>、大于 <code>&gt;</code>、<code>&lt;=</code>、 <code>&gt;=</code> 这些的时候，mysql优化器会根据索引比例、表的数据量大小等因素来决定走不走索引。</li>
<li>不满足最左匹配原则</li>
<li>索引列上即<code>where</code>子句中对字段进行表达式操作，会导致索引失效</li>
<li>索引列上即<code>where</code>子句中对字段进行函数操作，会导致索引失效</li>
<li>字段类型不匹配，会导致类型失效。如<code>code</code>字段是<code>varchar</code>类型，在<code>where</code>字句你使用<code>code=101</code>整型，就会导致索引失效</li>
<li>like左边包含<code>%</code>，会导致索引失效。这是因为索引的匹配规则是从左开始的。</li>
<li></li>
</ul>
<p><strong>如果写了一条<code>sql</code>，我怎么知道这条sql有没有走索引呢?</strong></p>
<p>使用<code>explain</code>解释器来查看，在sql语句前面加上explain就可以来查看。explain中有多列，其中重点看<code>type</code>字段，type中的数据类型从优到差依次为：</p>
<blockquote>
<p><code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt;ALL</code></p>
</blockquote>
<p>当我们写了一条<code>sql</code>语句发现他的<code>type</code>是<code>ALL</code>的时候我们就要考虑一下怎么优化一下了，因为<code>ALL</code>是最差的，我们就需要琢磨一下怎么优化，当然优化到<code>system</code>是最好的，但是一般不会优化到这种程度.</p>
<h4 id="mysql中为什么要有事务回滚机制">8.14 MySQL中为什么要有事务回滚机制？</h4>
<p>而在 MySQL 中，<strong>恢复机制是通过回滚日志<code>undo log</code>实现的</strong>，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。 当事务已经被提交之后，就无法再次回滚了。</p>
<p><strong>回滚日志作用：</strong></p>
<ul>
<li>1)能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息</li>
<li><ol start="2" type="1">
<li>在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。</li>
</ol></li>
</ul>
<h4 id="数据库引擎innodb与myisam的区别">8.15 数据库引擎InnoDB与MyISAM的区别</h4>
<p>InnoDB和MyISAM是MySQL数据库中常用的两种存储引擎，它们在功能和性能方面有一些区别。以下是InnoDB和MyISAM之间的主要区别：</p>
<ul>
<li><p><strong>事务支持</strong>：InnoDB是一个支持事务的存储引擎，它遵循ACID（原子性、一致性、隔离性和持久性）特性。这意味着您可以使用事务来执行复杂的操作，例如多个SQL语句的原子性执行、数据的回滚和提交。而MyISAM不支持事务，它以更简单的方式处理数据操作。</p></li>
<li><p><strong>并发性能：</strong>InnoDB对于高并发性能的支持较好。它使用行级锁定，这使得多个用户可以同时访问不同的行，提高了并发性。而MyISAM使用表级锁定，当一个用户对表执行写操作时，其他用户将无法对同一表进行写操作，这可能导致并发性能较差。</p></li>
<li><p><strong>数据完整性：</strong>InnoDB提供了更高的数据完整性保证。它支持外键约束，可以在数据库级别强制执行关联性，并确保引用的数据完整性。MyISAM不支持外键约束，这意味着您需要在应用层面来维护数据的完整性。</p></li>
<li><p><strong>崩溃恢复：</strong>InnoDB具有更好的崩溃恢复能力。它支持崩溃恢复和事务日志（redo log和undo log），可以在数据库崩溃后恢复数据。MyISAM在崩溃后需要进行表级别的修复，这可能需要更多时间。</p></li>
<li><p><strong>全文索引</strong>：MyISAM支持全文索引，可以进行高效的全文搜索。而InnoDB在MySQL 5.6版本之后才开始支持全文索引。</p></li>
<li><p><strong>空间占用</strong>：通常情况下，InnoDB的数据文件相对较大，因为它需要存储事务日志和其他附加数据。而MyISAM的数据文件相对较小，因为它不需要存储这些额外的数据。</p></li>
<li><strong>存储结构</strong>：
<ul>
<li>InnoDB使用聚簇索引（clustered index）来存储表数据，因此数据文件是和（主键）索引绑在一起的，即数据文件和索引文件在一块。聚簇索引决定了表中数据的物理存储顺序，它与表的主键相关联。如果表没有显式定义主键，则InnoDB会选择一个唯一的非空索引来作为聚簇索引。因此，在InnoDB中，数据行按照聚簇索引的顺序进行存储。</li>
<li>同时除了聚簇索引外，InnoDB还支持非聚簇索引（secondary index），也称为辅助索引。辅助索引存储了非主键列的索引数据，它的数据结构与B+树相似。 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/InnoDB.png" width="700"></li>
<li>MyISAM使用堆表（heap table）的存储方式，数据行在表中按照插入的顺序存储。因此，表数据在物理上没有特定的顺序，而是根据插入的时间顺序组织的，因此MyISAM的数据文件和索引文件独立存储。</li>
<li>MyISAM使用B+树来存储索引数据。每个索引都是一个独立的B+树结构，包含索引列和指向对应数据行的指针。 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/MyISAM.png" width="700"></li>
</ul></li>
</ul>
<p>综上所述，选择使用哪种存储引擎取决于您的具体需求。如果您需要支持事务、并发性能和数据完整性，并且对崩溃恢复有较高的要求，那么InnoDB是一个更好的选择。如果您对全文搜索有较高的需求，并且对空间占用和简单性要求较高，那么MyISAM可能更适合您的应用场景。请根据您的具体需求和考虑因素选择适合的存储引擎。</p>
<h4 id="你了解mysql的内部构造吗一般可以分为哪两个部分">8.16 你了解MySQL的内部构造吗？一般可以分为哪两个部分？</h4>
<p>可以分为服务层和存储引擎层两部分，其中：</p>
<ul>
<li>服务层：包括<strong>连接器、查询缓存、解析器、优化器、执行器</strong>等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
<ul>
<li>连接器：管理连接、权限验证；</li>
<li>查询缓存：命中缓存则直接返回结果；</li>
<li>解析器：对SQL进行词法分析、语法分析；（判断查询的SQL字段是否存在也是在这步）</li>
<li>优化器：执行计划生成、选择索引；</li>
<li>执行器：操作引擎、返回结果；</li>
</ul></li>
<li><strong>存储引擎层：</strong>负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。
<ul>
<li>存储引擎：存储数据、提供读写接口</li>
</ul></li>
</ul>
<h4 id="什么是主键什么是外键">8.15 什么是主键?什么是外键?</h4>
<p><strong>主键是表格里的(一个或多个)字段，只用来定义表格里的行</strong>;主键里的值总是唯一的。外键是一个用来建立两个表格之间关系的约束。这种关系一般都涉及一个表格里的主键字段与另外一个表格(尽管可能是同一个表格)里的一系列相连的字段。那么这些相连的字段就是外键。 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/mainkey.png" width="700"> 主键在本表中是唯一的、不可为空的，外键可以重复可以唯空；外键和另一张表的主键关联，不能创建对应表中不存在的外键。</p>
<h4 id="乐观锁和悲观锁">8.16 乐观锁和悲观锁</h4>
<ul>
<li><strong>乐观锁：</strong>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。它假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。一般都是通过版本号来识别</li>
<li><strong>悲观锁：</strong>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。它假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li>
</ul>
<blockquote>
<p>注意：读用乐观锁，写用悲观锁 共享锁（<code>Share Locks，S锁</code>）：一个线程给数据加上共享锁后，其他线程只能读取数据，不能修改。 排它锁（<code>eXclusive Locks，X锁</code>）：一个线程给数据加上排它锁后，其他线程不能读取也不能修改。 没有锁：InnoDB所有的普通select都是快照读，都不加锁。</p>
</blockquote>
<blockquote>
<p>手动加锁： <code>select * from table_name where  ... lock in share mode 会给事务加上共享锁；</code></p>
</blockquote>
<blockquote>
<p><code>select * from table_name where ... for update 会给事务加上排它锁。</code></p>
</blockquote>
<h4 id="mysql索引主要使用的两种数据结构是什么">8.17 MySQL索引主要使用的两种数据结构是什么？</h4>
<ul>
<li><p><strong>哈希索引，</strong>对于哈希索引来说，底层的数据结构肯定是哈希表，<strong>因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；</strong>其余大部分场景，建议选择<code>BTree索引</code></p></li>
<li><p><strong>BTree索引</strong>，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中，每次查询都是从树的入口root开始，依次遍历node，获取leaf。</p></li>
</ul>
<p>但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</p>
<h4 id="数据库为什么要进行分库和分表呢都放在一个库或者一张表中不可以吗">8.18 数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？</h4>
<p><strong>分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。</strong></p>
<p><strong>通过分表，可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用，此外，可以很大的缓解表锁的问题</strong>。 分表策略可以归纳为<strong>垂直拆分和水平拆分</strong></p>
<ul>
<li><p>水平分表：水平分表解决行数据量大问题。可使用取模分表就属于随机分表，而时间维度分表则属于连续分表。</p></li>
<li>垂直分表：垂直分表解决列数大问题。垂直分表策略
<ul>
<li>将不常用的字段单独拆分到另外一张扩展表.</li>
<li>将大文本的字段单独拆分到另外一张扩展表,</li>
<li>将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中</li>
</ul></li>
</ul>
<blockquote>
<p>对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。</p>
</blockquote>
<h4 id="mysql中有四种索引类型可以简单说说吗">8.19 MySQL中有四种索引类型，可以简单说说吗？</h4>
<ul>
<li><p><code>FULLTEXT</code> ：即为全文索引，目前只有MyISAM引擎支持。其可以在<code>CREATE TABLE ，ALTER TABLE ，CREATE INDEX</code>使用，不过目前只有<code>CHAR、VARCHAR ，TEXT</code>列上可以创建全文索引，需要注意的是MySQL5.6以后支持全文索引了，5.6之前是不支持的。</p></li>
<li><p><code>HASH</code> ：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</p></li>
<li><p><code>BTREE</code> ：<code>BTREE</code>索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</p></li>
<li><p><code>RTREE</code> ：<code>RTREE</code>在MySQL很少使用，仅支持<code>geometry</code>数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。 相对于BTREE，RTREE的优势在于范围查找。</p></li>
</ul>
<h4 id="视图的作用是什么可以更改吗">8.20 视图的作用是什么？可以更改吗？</h4>
<p>视图是虚拟的表，其不包含任何列或数据。其实视图可以看作已经定义好的SQL语句，只不过它贮存在数据库中，其数据都存放在定义视图查询所引用的真实表中。<strong>创建视图</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">create view 视图名称 as 查询语句</span><br></pre></td></tr></table></figure> 优点：</p>
<ul>
<li><strong>编写复杂的SQL并且重用：</strong>使用视图可以简化复杂的 sql 操作，隐藏具体的细节，且视图可以以表的形式使用。</li>
<li><strong>数据安全：MySQL将用户对数据的访问权限限制 在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有 隔离性 </strong>。视图相当于在用户和实际的数据表之间加了一层虚拟表</li>
<li></li>
</ul>
<blockquote>
<p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。</p>
</blockquote>
<p>缺点：</p>
<ul>
<li>视图不能被索引。</li>
<li>维护工作多：我们在实际数据表的基础上创建了视图，那么，如果实际数据表的结构变更了，我们就需要及时对 相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</li>
</ul>
<h4 id="什么时候需要建立数据库索引呢">8.21 什么时候需要建立数据库索引呢？</h4>
<ul>
<li>当我们对一个表中某字段访问频繁时，可以考虑建立索引</li>
<li>对于中大表，即数据量多的，可以考虑选择适当的字段建立索引</li>
</ul>
<p>在最频繁使用的、用以缩小查询范围的字段,需要排序的字段上建立索引。</p>
<p>不宜：</p>
<ul>
<li>1）对于查询中很少涉及的列或者重复值比较多的列</li>
<li>2）对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。</li>
</ul>
<h4 id="一道场景题假如你所在的公司选择mysql数据库作数据存储一天五万条以上的增量预计运维三年你有哪些优化手段">8.22 一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？</h4>
<ul>
<li>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</li>
<li>选择合适的表字段数据类型和存储引擎，适当的添加索引。</li>
<li>MySQL库主从读写分离。</li>
<li>找规律分表，减少单表中的数据量提高查询速度。</li>
<li>添加缓存机制，比如Memcached，Apc等。</li>
<li>不经常改动的页面，生成静态页面。</li>
<li>书写高效率的SQL。比如<code>SELECT * FROM TABEL</code> 改为 <code>SELECT field_1, field_2, field_3 FROM TABLE</code></li>
</ul>
<h4 id="数据库中的主键超键候选键外键是什么">8.22 数据库中的主键、超键、候选键、外键是什么？</h4>
<ul>
<li><p><strong>超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键</p></li>
<li><p><strong>候选键</strong>：不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！</p></li>
<li><p><strong>主键：</strong>用户选作元组标识的一个候选键为主键</p></li>
<li><p>** 外键：**如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键</p></li>
</ul>
<p><strong>举例</strong>：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">学号</th>
<th style="text-align: left;">姓名</th>
<th style="text-align: left;">性别</th>
<th style="text-align: left;">年龄</th>
<th style="text-align: left;">系别</th>
<th style="text-align: left;">专业</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">20020612</td>
<td style="text-align: left;">李辉</td>
<td style="text-align: left;">男</td>
<td style="text-align: left;">20</td>
<td style="text-align: left;">计算机</td>
<td style="text-align: left;">软件开发</td>
</tr>
<tr class="even">
<td style="text-align: left;">20060613</td>
<td style="text-align: left;">张明</td>
<td style="text-align: left;">男</td>
<td style="text-align: left;">18</td>
<td style="text-align: left;">计算机</td>
<td style="text-align: left;">软件开发</td>
</tr>
<tr class="odd">
<td style="text-align: left;">20060614</td>
<td style="text-align: left;">王小玉</td>
<td style="text-align: left;">女</td>
<td style="text-align: left;">19</td>
<td style="text-align: left;">物理</td>
<td style="text-align: left;">力学</td>
</tr>
<tr class="even">
<td style="text-align: left;">20060615</td>
<td style="text-align: left;">李淑华</td>
<td style="text-align: left;">女</td>
<td style="text-align: left;">17</td>
<td style="text-align: left;">生物</td>
<td style="text-align: left;">动物学</td>
</tr>
</tbody>
</table>
<ul>
<li>超键：于是我们从例子中可以发现 学号是标识学生实体的唯一标识。那么该元组的超键就为学号。除此之外我们还可以把它跟其他属性组合起来，比如：(学号，性别)，(学号，年龄)</li>
<li>候选键：根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际上，候选键是超键的子集，比如 （学号，年龄）是超键，但是它不是候选键。因为它还有了额外的属性。</li>
<li>主键：简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号就为主键。</li>
<li>外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成绩单表的外键，为学生表的主键。</li>
</ul>
<p><strong>主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。</strong></p>
<h4 id="数据库三大范式精讲">8.23 数据库三大范式精讲</h4>
<ul>
<li><p><strong>第一范式</strong>：所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，即实体中的某个属性不能有多个值或者不能有重复的属性。简而言之<strong>第一范式就是无重复的列。</strong> &gt;在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库</p></li>
<li><p><strong>第二范式</strong>：第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。 &gt;为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。 第二范式（2NF）要求实体的属性完全依赖于主关键字。满足第二范式前必须先满足第一范式</p></li>
<li><p><strong>第三范式</strong>：第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 &gt;例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p></li>
</ul>
<p>总结：</p>
<ul>
<li>1NF：原子性。 字段不可再分,否则就不是关系数据库;</li>
<li>2NF：唯一性 。一个表只说明一个事物；</li>
<li>3NF：每列都与主键有直接关系，不存在传递依赖。</li>
</ul>
<h4 id="你知道哪些数据库结构优化的手段">8.24 你知道哪些数据库结构优化的手段？</h4>
<ul>
<li><strong>范式优化：</strong> 比如消除冗余（节省空间。。）</li>
<li><strong>反范式优化：</strong>比如适当加冗余等（减少join）</li>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。</li>
<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>拆分表</strong>：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。</li>
</ul>
<h4 id="为什么mysql索引要使用b树而不是b树或者红黑树">8.25 为什么MySQL索引要使用B+树，而不是B树或者红黑树？</h4>
<p>我们在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。</p>
<p>为什么B类树可以进行优化呢？我们可以根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息，保证层数（树的高度）尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</p>
<h4 id="为什么mysql索引适用用b树而不用hash表和b树">8.26 为什么MySQL索引适用用B+树而不用hash表和B树？</h4>
<ul>
<li>利用Hash需要把数据全部<strong>加载到内存中</strong>，如果数据量大，是一件很<strong>消耗内存</strong>的事，而采用B+树，是基于<strong>按照节点分段加载，由此减少内存消耗。</strong></li>
<li>和业务场景有关，<strong>对于唯一查找（查找一个值），Hash确实更快</strong>，但数据库中经常查询多条数据，这时候由于B+数据的<strong>有序性</strong>，与叶子节点又有<strong>链表相连</strong>，他的查询效率会比Hash快的多。</li>
<li><strong>b+树的非叶子节点不保存数据</strong>，只保存子树的临界值（最大或者最小），所以同样大小的节点，<strong>b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。</strong></li>
</ul>
<h4 id="数据库如何保证一致性">8.27 数据库如何保证一致性？</h4>
<p>分为两个层面来说。</p>
<ul>
<li><strong>从数据库层面</strong>，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。</li>
<li><strong>从应用层面</strong>，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据</li>
</ul>
<h4 id="数据库如何保证原子性">8.28 数据库如何保证原子性？</h4>
<p>主要是利用 Innodb 的<code>undo log</code>。 <strong><code>undo log</code>名为回滚日志，是实现原子性的关键</strong>，当事务回滚时能够撤销所有已经成功执行的 SQL语句，他需要记录你要回滚的相应日志信息。 例如</p>
<ul>
<li>当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li>
<li>当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li>
<li>当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作</li>
</ul>
<p>undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子</p>
<h4 id="数据库如何保证持久性">8.29 数据库如何保证持久性？</h4>
<p>主要是利用Innodb的redo log。重写日志， 正如之前说的，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再写回到磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？ 简单啊，事务提交前直接把数据写入磁盘就行啊。 这么做有什么问题？</p>
<ul>
<li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</li>
<li>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li>
</ul>
<p>于是，决定采用<code>redo log</code>解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在<code>redo log</code>中记录这次操作。当事务提交的时候，会<code>将redo log</code>日志进行刷盘(<code>redo log</code>一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将<code>redo log中</code>的内容恢复到数据库中，再根据<code>undo log</code>和<code>binlog</code>内容决定回滚数据还是提交数据。</p>
<p><strong>采用redo log的好处？</strong></p>
<p>其实好处就是将redo log进行刷盘比对数据页刷盘效率高，具体表现如下：</p>
<ul>
<li><code>redo log</code>体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li>
<li><code>redo log</code>是一直往末尾进行追加，属于顺序</li>
<li>IO。效率显然比随机IO来的快</li>
</ul>
<h4 id="数据库高并发是我们经常会遇到的你有什么好的解决方案吗">8.30 数据库高并发是我们经常会遇到的，你有什么好的解决方案吗？</h4>
<ul>
<li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li>增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读。</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li>
<li>使用分布式架构，分散计算压力。</li>
</ul>
<p>参考文献： &gt;《高性能MySQL》 &gt;《 MySQL技术内幕：InnoDB存储引擎（第2版）》</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
