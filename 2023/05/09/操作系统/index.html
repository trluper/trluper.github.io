<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1 操作系统的基本概念  操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。 操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。 操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。 操作">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:description" content="1 操作系统的基本概念  操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。 操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。 操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。 操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/操作系统概念.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/systemcall.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/timeP.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/manyque.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/进程状态切换.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/first.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/good.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/big.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/near.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/VP.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/安全状态.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/资源分配图.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/多个资源的死锁检测.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/PTE.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/aimed.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/miss.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/manyLevel.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OPT.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FIFO.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LRU.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CLOCK.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pCLOCK.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/bigsmall.png">
<meta property="og:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/memoryList.png">
<meta property="article:published_time" content="2023-05-09T06:47:11.000Z">
<meta property="article:modified_time" content="2023-06-10T03:25:51.459Z">
<meta property="article:author" content="trluper">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/操作系统概念.png">

<link rel="canonical" href="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统 | Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-09 14:47:11" itemprop="dateCreated datePublished" datetime="2023-05-09T14:47:11+08:00">2023-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-10 11:25:51" itemprop="dateModified" datetime="2023-06-10T11:25:51+08:00">2023-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>36k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="操作系统的基本概念">1 操作系统的基本概念</h3>
<ol type="1">
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li>操作系统本质上是一个运行在计算机上的<strong>软件程序</strong> ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li>操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 </strong>内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<h4 id="操作系统的内核kernel">操作系统的内核（Kernel）</h4>
<p>维基百科对于内核的解释： &gt;<strong>内核</strong>（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I/O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 <strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</strong></p>
<blockquote>
<p>早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!</p>
</blockquote>
<p><strong>简单概括两点：</strong></p>
<ul>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li>
<li>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</li>
</ul>
<h4 id="中央处理器cpucentral-processing-unit">中央处理器（CPU，Central Processing Unit）</h4>
<p>关于 CPU 简单概括三点：</p>
<ul>
<li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑</strong>。</li>
<li>** CPU 主要包括两个部分：控制器+运算器。**</li>
<li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li>
</ul>
<h4 id="cpu-vs-kernel内核">CPU vs Kernel(内核)</h4>
<p>可以简单从下面两点来区别：</p>
<ul>
<li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li>
<li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/操作系统概念.png" width="500"></li>
</ul>
<h3 id="操作系统的基本特性">2 操作系统的基本特性</h3>
<p>操作系统的基本特性是<strong>并发性、共享性、虚拟性、异步性。</strong></p>
<h4 id="并发性">并发性</h4>
<p><strong>并行性和并发性(Concurrence)是既相似又有区别的两个概念，</strong>并行性是指两个或多个事件在同一时刻发生；而并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。（宏观并发微观串行）</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h4 id="共享性">共享性</h4>
<p>指系统中的资源可供内存中多个并发执行的进程(线程)共同使用，相应地，把这种资源共同使用称为资源共享，或称为资源复用。目前主要实现资源共享的方式有：</p>
<ul>
<li>互斥共享方式</li>
<li>同时访问方式</li>
</ul>
<h5 id="互斥共享方式">互斥共享方式</h5>
<p>当一个进程 A 要访问某资源时，必须先提出请求。如果此时该资源空闲，系统便可将之分配给请求进程 A 使用。此后若再有其它进程也要访问该资源时(只要 A 未用完)，则必须等待。仅当 A 进程访问完并释放该资源后，才允许另一进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源，例如打印机。</p>
<h5 id="同时访问方式">同时访问方式</h5>
<p>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p>
<h4 id="虚拟性">虚拟性</h4>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：<strong>时（时间）分复用技术和空（空间）分复用技术。</strong></p>
<p><strong>多个进程能在同一个处理器上并发执行使用了时分复用技术</strong>，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p>虚拟内存使用了<strong>空分复用技术</strong>，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<h4 id="异步性">异步性</h4>
<p>在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。进程是以人们不可预知的速度向前推进，此即进程的异步性。</p>
<h3 id="操作系统的基本功能">3 操作系统的基本功能</h3>
<p>操作系统的基本功能包括<strong>进程管理、内存管理、文件管理、设备管理。</strong></p>
<ul>
<li><strong>进程管理</strong>：进程控制、进程同步、进程通信、死锁处理、处理机调度等</li>
<li><strong>内存管理</strong>：内存分配、地址映射、内存保护与共享、虚拟内存等</li>
<li><strong>文件管理</strong>：文件存储空间的管理、目录管理、文件读写管理和保护等</li>
<li><strong>设备管理</strong>：完成用户I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备管理、设备处理、虚拟设备等。</li>
</ul>
<h3 id="什么是系统调用用户态和系统态是">4 什么是系统调用/用户态和系统态是？</h3>
<p>根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：</p>
<ul>
<li>** 用户态(user mode) **: 用户态运行的进程或程序可以直接读取用户程序的数据。</li>
<li><strong>系统态(kernel mode)</strong>:可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ul>
<p>我们运行的程序基本都是运行在用户态，如果要调用操作系统提供的系统态级别的子功能，那就需要系统调用了！</p>
<p>也就是说在运行的用户程序中，<strong>凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</strong></p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/systemcall.png" width="600"></li>
</ul>
<h4 id="为什么要有用户态与内核态">为什么要有用户态与内核态?</h4>
<p><strong>在 cpu 的所有指令中，有些指令是非常危险的，如果使用不当，将会造成系统崩溃等后果。为了避免这种情况发生，cpu 将指令划分为特权级(内核态)指令和非特权级(用户态)指令。</strong></p>
<p><strong>对于那些危险的指令只允许内核及其相关模块调用，对于那些不会造成危险的指令，就允许用户应用程序调用。</strong></p>
<ul>
<li>内核态(核心态,特权态): 内核态是操作系统内核运行的模式。 内核态控制计算机的硬件资源，如硬件设备，文件系统等等，并为上层应用程序提供执行环境。</li>
<li>用户态: 用户态是用户应用程序运行的状态。 应用程序必须依托于内核态运行,因此用户态的操作权限比内核态是要低的，如磁盘，文件等，访问操作都是受限的。</li>
<li>系统调用: 系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。</li>
</ul>
<h4 id="用户态切换到内核态的几种方式">用户态切换到内核态的几种方式</h4>
<ul>
<li><strong>系统调用:</strong> 系统调用是用户态主动要求切换到内核态的一种方式，用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</li>
<li><strong>异常:</strong> 当 cpu 在执行用户态的应用程序时，发生了某些不可知的异常。于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</li>
<li><strong>硬件设备的中断:</strong> 当硬件设备完成用户请求后，会向 cpu 发出相应的中断信号，这时 cpu 会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序，如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核台的转换。</li>
</ul>
<h3 id="计算机的局部性原理">5 计算机的局部性原理</h3>
<p>一个编写良好的计算机程序常常具有良好的<strong>局部性</strong>，即他们更加倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用或的数据项本身，这种特性，常常称为<strong>局部性原理</strong>。局部性由两种不同的形式：<strong>时间局部性和空间局部性</strong></p>
<ul>
<li><strong>时间局部性</strong>：被引用过一次的内存位置很有可能在不久的将来再次被多次引用。</li>
<li><strong>空间局部性</strong>：一个内存被引用过了，那么极有可能在不久的将来会引用器附近的内存位置。在高速缓存中的表现形式是以<strong>数据块</strong>的形式进行缓存，弥补未命中时的惩罚</li>
</ul>
<p>我们应该理解局部性原理，因为一般而言，一个良好局部性的程序比局部性差的程序运行得更快，这是由现代计算机系统得设计结构所决定得，在现代计算系统得各个层次之哦你给，都引入了局部性原理：</p>
<ul>
<li>在硬件层，计算机设计者通过引入称为<strong>高速缓存存储器</strong>这样小而快得快速存储器来保存最近引用得指令和数据项，从而提高对主存得访问速度。</li>
<li>在操作系统中，系统使用主存作为<strong>虚拟地址空间</strong>，来存储最近被引用得数据项，来避免因从磁盘取数据过慢而导致CPU资源的浪费</li>
<li>类似的，用主存来缓存磁盘文件中最近被使用的磁盘块。</li>
<li>局部性原理在应用程序中也有应用，入<code>Web</code>浏览器将最近引用的文档放在本地磁盘上，利用的就是时间局部性。</li>
</ul>
<span id="more"></span>
<h3 id="磁盘调度算法">6 磁盘调度算法</h3>
<p>读写一个传统磁盘块的时间的影响因素有：</p>
<ul>
<li><strong>旋转时间</strong>（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li><strong>寻道时间</strong>（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li><strong>实际的数据传输时间</strong></li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h4 id="先来先服务">先来先服务</h4>
<p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h4 id="最短寻道时间优先">最短寻道时间优先</h4>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p><strong>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</strong></p>
<h4 id="电梯扫描算法">电梯扫描算法</h4>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<h3 id="进程线程和协程的区别和联系">7 进程、线程和协程的区别和联系</h3>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>比较点</th>
<th><strong>进程</strong></th>
<th><strong>线程</strong></th>
<th><strong>协程</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>定义</td>
<td>资源分配和拥有的基本单位</td>
<td>程序执行的基本单位</td>
<td>用户态的轻量级线程，线程内部调度的基本单位</td>
</tr>
<tr class="even">
<td>切换情况</td>
<td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td>
<td>保存和设置程序计数器、少量寄存器和栈的内容</td>
<td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td>
</tr>
<tr class="odd">
<td>切换者</td>
<td>操作系统</td>
<td>操作系统</td>
<td>用户</td>
</tr>
<tr class="even">
<td>切换过程</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态(没有陷入内核)</td>
</tr>
<tr class="odd">
<td>调用栈</td>
<td>内核栈</td>
<td>内核栈</td>
<td>用户栈</td>
</tr>
<tr class="even">
<td>拥有资源</td>
<td>CPU资源、内存资源、文件资源和句柄等</td>
<td>程序计数器、寄存器、栈和状态字</td>
<td>拥有自己的寄存器上下文和栈</td>
</tr>
<tr class="odd">
<td>并发性</td>
<td>不同进程之间切换实现并发，各自占有CPU实现并行</td>
<td>一个进程内部的多个线程并发执行</td>
<td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td>
</tr>
<tr class="even">
<td>系统开销</td>
<td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td>
<td>切换时只需保存和设置少量寄存器内容，因此开销很小</td>
<td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td>
</tr>
<tr class="odd">
<td>通信方面</td>
<td>进程间通信需要借助操作系统</td>
<td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td>
<td>共享内存、消息队列</td>
</tr>
</tbody>
</table>
<p>1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p>
<p>2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位</p>
<h4 id="线程和进程的区别">线程和进程的区别？</h4>
<ul>
<li><strong>进程</strong>：程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。程序是静态的，进程是动态的。是CPU分配资源的最小单位</li>
<li><strong>线程：</strong>线程（thread）是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。线程是CPU调度的最小单位</li>
</ul>
<p><strong>关系：</strong></p>
<ul>
<li>一个进程可有多个线程</li>
<li>进程间很难共享数据，线程很容易实现数据共享</li>
<li>进程比线程消耗更多的计算机资源</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉</li>
</ul>
<p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源，所以我们也说，进程是CPU分配资源的最小单位。</p>
<p>线程存在与进程当中(进程可以认为是线程的容器)，是操作系统调度执行的最小单位。说通俗点，线程就是干活的，轻量级进程。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。（是为避免进程fork()产生写时拷贝的不必要时间和内存支出）</p>
<ul>
<li><p>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</p></li>
<li><p>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</p></li>
<li><p>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</p></li>
<li><p>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构</p></li>
</ul>
<h4 id="协程">协程</h4>
<p><strong>协程本质上是一种用户态的轻量级线程，协程的调度完全由用户控制。</strong></p>
<p>传统意思上来说，线程分为<strong>内核态线程</strong>和<strong>用户态线程</strong>，<strong>用户态线程需要绑定内核态线程</strong>，CPU并不能感知用户态线程的存在，它只知道它在运行1个线程，这个线程实际是内核态线程。用户态线程实际有个名字就叫协程（co-routine），为了容易区分，使用协程指用户态线程，使用线程指内核态线程。</p>
<p>协程跟线程是有区别的，线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p>
<p>协程和线程有3种映射关系：</p>
<ul>
<li><code>N:1</code>，N个协程绑定1个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上，一是某个程序用不了硬件的多核加速能力，二是一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li>
<li><code>1:1</code>，1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，但有一个缺点是协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</li>
<li><code>M:N</code>，M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</li>
</ul>
<p><strong>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</strong></p>
<ul>
<li><strong>协程是属于线程的</strong>。协程程序是在线程里面跑的，因此协程又称微线程和纤程等</li>
<li>** 协程没有线程的上下文切换消耗**。协程的调度切换是用户(程序员)手动切换的，因此更加灵活,因此又叫用户空间线程.</li>
<li><strong>原子操作性</strong>。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁</li>
<li><p><strong>协程的优点：</strong></p></li>
<li>跨平台,跨体系架构</li>
<li>无需线程上下文切换的开销</li>
<li>无需原子操作锁定及同步的开销</li>
<li>方便切换控制流，简化编程模型</li>
<li><p>高并发+高扩展性+低成本：一个 CPU 支持上万的协程都不是问题。所以很适合用于高并发处理。</p></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无法利用多核资源：协程的本质是个单线程，它不能同时将单个 CPU 的多个核用上，协程需要和进程配合才能运行在多 CPU 上。当然我们日常所编写的绝大部分应用都没有这个必要，除非是 cpu 密集型应用。</li>
<li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序：这一点和事件驱动一样，可以使用异步IO操作来解决</li>
</ul>
<h3 id="一个进程可以创建多少线程和什么有关">8 一个进程可以创建多少线程，和什么有关？</h3>
<p>这个要分不同系统去看：</p>
<ul>
<li>如果是32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。</li>
<li>如果是64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。</li>
</ul>
<p>顺便多说一句，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响，无用线程要及时销毁</p>
<h3 id="外中断和异常有什么区别">9 外中断和异常有什么区别？</h3>
<ul>
<li><p>外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p></li>
<li><p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p></li>
</ul>
<h3 id="进程线程模型你知道多少">10 进程线程模型你知道多少？</h3>
<p>对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单</p>
<h4 id="多线程">多线程</h4>
<p>我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量<code>int i = 10</code>，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。</p>
<p>我们必须知道，<strong>做一次简单的<code>i = i + 1</code>在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，</strong>而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p>
<p>但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。</p>
<p>比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p>
<p>对于线程，我认为弄清以下两点非常重要：</p>
<ul>
<li><p>线程之间有无先后访问顺序（线程依赖关系）</p></li>
<li><p>多个线程共享访问同一变量（同步互斥问题）</p></li>
</ul>
<p>另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的<code>tid</code>，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。</p>
<p>而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p>
<p>线程相关接口不少，主要需要了解各个参数意义和返回值意义。</p>
<p><strong>1.线程创建和结束</strong></p>
<ul>
<li>背景知识：</li>
</ul>
<p>在一个文件内的多个函数通常都是按照<code>main</code>函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在<code>main</code>函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照<code>main</code>函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。</p>
<ul>
<li><p>相关接口：</p>
<ul>
<li><p>创建线程：<code>int pthread_create(pthread_t *tidp,const pthread_attr_t *attr, void *(start_rtn)(void),void *arg)</code>;创建一个新线程，<code>pthread和start_routine</code>不可或缺，分别用于标识线程和执行体入口，其他可以填<code>NULL</code>。</p>
<ul>
<li><p><code>pthread</code>：用来返回线程的tid，<code>*pthread</code>值即为tid，类型<code>pthread_t == unsigned long int</code>。</p></li>
<li><p><code>attr</code>：指向线程属性结构体的指针，用于改变所创线程的属性，填<code>NULL</code>使用默认值。</p></li>
<li><p><code>start_routine</code>：线程执行函数的首地址，传入函数指针。</p></li>
<li><p><code>arg：</code>通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。</p></li>
</ul></li>
<li><p>获得线程ID：<code>pthread_t pthread_self();</code>.。调用时，会打印线程<code>ID</code>。</p></li>
</ul></li>
<li>等待线程结束：<code>int pthread_join(pthread_t tid, void** retval);</code>主线程调用，等待子线程退出并回收其资源，类似于进程中<code>wait/waitpid</code>回收僵尸进程，调用<code>pthread_join</code>的线程会被阻塞。
<ul>
<li><p><code>tid</code>：创建线程时通过指针得到<code>tid</code>值。</p></li>
<li><p><code>retval</code>：指向返回值的指针。</p></li>
</ul></li>
<li><p>结束线程：<code>pthread_exit(void *retval);</code>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过<code>pthread_join</code>获得。</p>
<ul>
<li><code>retval：</code>同上。</li>
</ul></li>
<li><p>分离线程：<code>int pthread_detach(pthread_t tid);</code>主线程、子线程均可调用。主线程中<code>pthread_detach(tid)</code>，子线程中<code>pthread_detach(pthread_self())</code>，调用后和主线程分离，子线程结束时自己立即回收资源。</p>
<ul>
<li>tid：同上。</li>
</ul></li>
</ul>
<p><strong>2.线程属性值修改</strong></p>
<ul>
<li><p>背景知识：线程属性对象类型为<code>pthread_attr_t</code>，结构体定义如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> detachstate;    <span class="comment">// 线程分离的状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy;    <span class="comment">// 线程调度策略</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> schedparam;    <span class="comment">// 线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched;    <span class="comment">// 线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope;    <span class="comment">// 线程的作用域</span></span><br><span class="line">    <span class="comment">// 以下为线程栈的设置</span></span><br><span class="line">    <span class="type">size_t</span> guardsize;    <span class="comment">// 线程栈末尾警戒缓冲大小</span></span><br><span class="line">    <span class="type">int</span> stackaddr_set;    <span class="comment">// 线程的栈设置</span></span><br><span class="line">    <span class="type">void</span> *    stackaddr;    <span class="comment">// 线程栈的位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize;    <span class="comment">// 线程栈大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>相关接口：对上述结构体中各参数大多有：<code>pthread_attr_get()</code>和<code>pthread_attr_set()</code>系统调用函数来设置和获取。这里不一一罗列。</p></li>
</ul>
<h4 id="多进程">多进程</h4>
<p>每一个进程是资源分配的基本单位。</p>
<p><strong>进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。</strong></p>
<p><strong>实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。</strong></p>
<p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过<strong>写时复制机制</strong>将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。</p>
<p>如果子进程想要运行自己的代码段，还可以通过调用<code>execv()</code>函数重新加载新的代码段，之后就和父进程独立开了。</p>
<p>我们在shell中执行程序就是通过shell进程先<code>fork()</code>一个子进程再通过<code>execv()</code>重新加载新的代码段的过程。</p>
<p><strong>1.进程创建与结束</strong></p>
<ul>
<li><p>背景知识：进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：<code>0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程</code>。所以我们在命令行中通过 <code>./program</code>执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。</p></li>
<li>相关接口：
<ul>
<li>创建进程：<code>pid_t fork(void);</code>
<ul>
<li>返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid == 0</li>
</ul></li>
<li>结束进程：<code>void exit(int status);</code>
<ul>
<li><code>status</code>是退出状态，保存在全局变量中S?，通常0表示正常退出。</li>
</ul></li>
<li><p>获得PID：<code>pid_t getpid(void);</code>返回调用者pid。</p></li>
<li><p>获得父进程PID：<code>pid_t getppid(void)</code>;返回父进程pid。</p></li>
</ul></li>
<li><p>其他补充：</p>
<ul>
<li>正常退出方式：<code>exit()、_exit()、return（在main中）</code>。</li>
<li><p><code>exit()</code>和<code>_exit()</code>区别：<code>exit()</code>是对<code>__exit()</code>的封装，都会终止进程并做相关收尾工作，最主要的区别是<code>_exit()</code>函数关闭全部描述符和清理函数后不会刷新流，但是<code>exit()</code>会在调用<code>_exit()</code>函数前刷新数据流。</p></li>
<li><p><code>return</code>和<code>exit()</code>区别：<code>exit()</code>是函数，但有参数，执行完之后控制权交给系统。<code>return</code>若是在调用函数中，执行完之后控制权交给调用进程，若是在<code>main</code>函数中，控制权交给系统。</p></li>
<li><p>异常退出方式：<code>abort()</code>、终止信号。</p></li>
</ul></li>
</ul>
<p><strong>2.Linux进程控制</strong></p>
<ul>
<li><p><strong>进程地址空间（地址空间）</strong> 虚拟存储器为每个进程提供了独占系统地址空间的假象。</p>
<p>尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。</p>
<p>有一些&quot;敏感&quot;的地址需要注意下，对于32位进程来说，代码段从<code>0x08048000</code>开始。从<code>0xC0000000</code>开始到<code>0xFFFFFFFF</code>是内核地址空间，通常情况下代码运行在用户态（使用<code>0x00000000 ~ 0xC00000000</code>的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。</p>
<p>也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。</p></li>
<li><p><strong>进程控制块（处理机）进程</strong>：的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。</p></li>
<li><p><strong>上下文切换</strong> 内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。</p>
<p>进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。</p>
<p>一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p></li>
</ul>
<h3 id="进程调度算法你了解多少">11 进程调度算法你了解多少？</h3>
<h4 id="先来先服务-first-come-first-serverdfcfs">先来先服务 first-come first-serverd（FCFS）</h4>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p><strong>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</strong></p>
<h4 id="短作业优先-shortest-job-firstsjf">短作业优先 shortest job first（SJF）</h4>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度</p>
<h4 id="最短剩余时间优先-shortest-remaining-time-nextsrtn">最短剩余时间优先 shortest remaining time next（SRTN）</h4>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p>
<p>如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h4 id="时间片轮转">时间片轮转</h4>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。</p>
<p>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/timeP.png" width="500"></li>
</ul>
<h4 id="优先级调度">优先级调度</h4>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h4 id="多级反馈队列">多级反馈队列</h4>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 <code>1,2,4,8,..。</code>进程在第一个队列没执行完，就会被移到下一个队列。</p>
<p>这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/manyque.png" width="600"></p>
<h3 id="进程状态的切换">12 进程状态的切换</h3>
<p><strong>进程的三种基本状态</strong></p>
<ul>
<li><strong>就绪状态</strong>：当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li>
<li><strong>执行状态</strong>：进程已获得 CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</li>
<li><strong>阻塞状态</strong>：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。致使进程阻塞的典型事件有：请求 I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而把处于阻塞状态的进程排成多个队列。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/进程状态切换.png" width="600"></li>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h3 id="linux下进程间通信方式">13 Linux下进程间通信方式？</h3>
<ul>
<li><p><strong>管道：</strong></p>
<ul>
<li><p><strong>无名管道（内存文件）</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</p></li>
<li><p><strong>有名管道（FIFO文件，借助文件系统）</strong>：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</p></li>
</ul></li>
<li><p><strong>共享内存：</strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</p></li>
<li><p><strong>消息队列：</strong>消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li>
<li><p><strong>套接字</strong>：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</p></li>
<li><p><strong>信号：</strong>用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</p></li>
<li><p><strong>信号量：</strong>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问</p></li>
</ul>
<h3 id="linux下同步机制">14 Linux下同步机制？</h3>
<ul>
<li><p><code>POSIX</code>信号量：可用于进程同步，也可用于线程同步。</p></li>
<li><p><code>POSIX</code>互斥锁 + 条件变量：只能用于线程同步</p></li>
</ul>
<h3 id="如果系统中具有快表tlb后那么地址的转换过程变成什么样了">15 如果系统中具有快表(<code>tlb</code>)后，那么地址的转换过程变成什么样了？</h3>
<p>块表其实与缓存存储结构的功能是一样的，只不过<code>TLB</code>缓存的是<strong>页表条目信息</strong>。在没有<code>tlb</code>时，当CPU产生一个虚拟地址，送到<strong>内存管理单元</strong>后，为能够进行地址转换，必须先向主存内的页表请求对应的<strong>页表条目</strong>，在主存中找到页表条目后返回给MMU处理，之后MMU通过<strong>虚拟地址</strong>和相应的<strong>页表条目</strong>生成物理地址，用该物理地址再次去内存取相应的数据，可见在没有<code>tlb</code>的时候，地址转换过程中要两次访问主存，一次是为了获得页表信息来生成物理地址，另一次是通过生成的物理地址来获得数据</p>
<p>有了<code>tlb</code>缓存后，得益于计算机的局部性设计，将会大大减少从主存中获取页表信息的几率，这样</p>
<blockquote>
<p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p>
</blockquote>
<blockquote>
<p>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
</blockquote>
<blockquote>
<p>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</p>
</blockquote>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，–般来说快表的命中率可以达到90%以上。</p>
<p>例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问- -次快表耗时1us， 访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?<code>(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us</code>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是<code>(1+100) * 0.9+ (100+100) *0.1=110.9 us</code> 若未采用快表机制，则访问一个逻辑地址需要<code>100+100 = 200us</code> 显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>
<h3 id="动态分区分配算法有哪几种可以分别说说吗">16 动态分区分配算法有哪几种？可以分别说说吗？</h3>
<h4 id="首次适应算法">1 首次适应算法</h4>
<p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p>
<p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/first.png" width="700"></p>
<h4 id="最佳适应算法">2 最佳适应算法</h4>
<p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p>
<p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/good.png" width="700"></p>
<h4 id="最坏适应算法">3 最坏适应算法</h4>
<p>又称最大适应算法(<code>Largest Fit</code>)</p>
<p>算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/big.png" width="700"></p>
<h4 id="邻近适应算法">4 邻近适应算法</h4>
<p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>
<p>如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/near.png" width="700"></p>
<h4 id="总结">5 总结</h4>
<p>首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p>
<p>最佳导致大量碎片，最坏导致没有大的空间。</p>
<p>进过实验，首次适应比最佳适应要好，他们都比最坏好。</p>
<table style="width:96%;">
<colgroup>
<col style="width: 5%">
<col style="width: 19%">
<col style="width: 19%">
<col style="width: 22%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>算法</th>
<th>算法思想</th>
<th>分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>首次适应</td>
<td>从头到尾找适合的分区</td>
<td><strong>空闲分区以地址递增次序排列 </strong></td>
<td>综合看性能最好。<strong>算法开销小</strong>，回收分区后一般不需要对空闲分区队列重新排序</td>
<td></td>
</tr>
<tr class="even">
<td>最佳适应</td>
<td>优先使用更小的分区，以保留更多大分区</td>
<td>空闲分区以容量递增次序排列</td>
<td>会有更多的大分区被保留下来，更能满足大进程需求</td>
<td>会产生很多太小的、难以利用的碎片;<strong>算法开销大</strong>，回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr class="odd">
<td>最坏适应</td>
<td>优先使用更大的分区，以防止产生太小的不可用的碎片</td>
<td>空闲分区以容量递减次序排列</td>
<td>可以减少难以利用的小碎片</td>
<td>大分区容易被用完，不利于大进程<strong>;算法开销大</strong>(原因同上)</td>
</tr>
<tr class="even">
<td>邻近适应</td>
<td>由首次适应演变而来，每次从上次查找结束位置开始查找</td>
<td>空闲分区以地址递增次序排列(可排列成循环链表)</td>
<td>不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong>(原因同首次适应算法)</td>
<td>会使高地址的大分区也被用完</td>
</tr>
</tbody>
</table>
<h3 id="外部碎片和内部碎片">17 外部碎片和内部碎片</h3>
<p>造成堆利用率低的主要原因是一种称为内存碎片的现象，当虽然有未使用的内存但不能用来满足分配请求时，就会发送这种现象。有两种形式的碎片：<strong>内部碎片和外部碎片</strong></p>
<ul>
<li><p><strong>内部碎片：</strong>内部碎片是在一个已分配块比有实际需要的有效载荷大时发生的。比如计算机的内存对齐机制，虽然实际需要1字节存储，但分配器会分配<code>4</code>或者<code>8</code>字节的块来存储。因此，内部碎片是由计算机本身所造成的，我们只能通过改变变量顺序使得内部碎片尽可能小。<strong>外部碎片的量化也是极为简单，就是已分配快大小和有效载荷之间的差的和</strong></p></li>
<li><p><strong>外部碎片</strong>：外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以满足这个请求块。</p></li>
</ul>
<h3 id="虚拟技术你了解吗">18 虚拟技术你了解吗</h3>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：<strong>时（时间）分复用技术和空（空间）分复用技术。</strong></p>
<p><strong>多进程与多线程</strong>：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p><strong>虚拟内存使用了空分复用技术</strong>，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中</p>
<h3 id="一个cc程序从开始编译到生成可执行文件的完整过程你能说出来多少">19 一个C/C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？</h3>
<p>四个过程：</p>
<ul>
<li><p>（1）<strong>预编译 </strong>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<ul>
<li><p>1、删除所有的#define，展开所有的宏定义。</p></li>
<li><p>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p></li>
<li><p>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。</p></li>
<li><p>4、删除所有的注释，“//”和“/**/”。</p></li>
<li><p>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。</p></li>
<li><p>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</p></li>
</ul></li>
<li><p>（2）<strong>编译</strong> 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<ul>
<li><p>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p></li>
<li><p>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p></li>
<li><p>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p></li>
<li><p>4、优化：源代码级别的一个优化过程。</p></li>
<li><p>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p></li>
<li><p>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p></li>
</ul></li>
<li><p>（3）<strong>汇编</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。</p>
<p>经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。</p></li>
<li><p>（4）链接</p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<ul>
<li>1、<strong>静态链接：</strong> 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li>
</ul>
<p><strong>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</strong></p>
<ul>
<li>2、<strong>动态链接：</strong> 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</li>
</ul>
<p><strong>共享库：</strong>就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失</p></li>
</ul>
<h3 id="操作系统在对内存进行管理的时候需要做些什么">20 操作系统在对内存进行管理的时候需要做些什么?</h3>
<ul>
<li>操作系统负责内存空间的分配与回收。（虚拟内存的堆）</li>
<li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。（虚拟内存）</li>
<li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。（虚拟内存）</li>
<li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰（虚拟内存）</li>
</ul>
<h3 id="进程间通信有哪几种方式">21 进程间通信有哪几种方式</h3>
<p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>细节</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>管道(pipe)</strong></td>
<td>允许一个进程和另一个与它有共同祖先的进程之间进行通信</td>
</tr>
<tr class="even">
<td><strong>命名管道(FIFO)</strong></td>
<td>类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令<code>mkfifo</code>或系统调用<code>mkfifo</code>来创建</td>
</tr>
<tr class="odd">
<td><strong>消息队列(MQ)</strong></td>
<td>消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。<strong>消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点</strong>；</td>
</tr>
<tr class="even">
<td><strong>信号量(semaphore)</strong></td>
<td>信号量主要作为进程间以及同进程不同线程之间的同步手段；</td>
</tr>
<tr class="odd">
<td><strong>共享内存(shared memory)</strong></td>
<td>它使得多个进程可以访问同一块内存空间，<strong>是最快的可用IPC形式。</strong>这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥</td>
</tr>
<tr class="even">
<td><strong>信号(signal)</strong></td>
<td>信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身</td>
</tr>
<tr class="odd">
<td><strong>内存映射(mapped memory)</strong></td>
<td>内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它</td>
</tr>
<tr class="even">
<td><strong>Socket</strong></td>
<td>它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信</td>
</tr>
</tbody>
</table>
<p>进程间通信主要包括管<strong>道、系统IPC（包括消息队列、信号量、信号、共享内存等）</strong>、以及套接字<code>socket</code>。</p>
<p><strong>1.管道</strong>：</p>
<p>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p>
<p><strong>1.1 普通管道PIPE：</strong></p>
<ul>
<li><p>1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p></li>
<li><p>2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p></li>
<li><p>3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p></li>
</ul>
<p><strong>1.2 命名管道FIFO</strong>：</p>
<ul>
<li><p>1)FIFO可以在无关的进程之间交换数据</p></li>
<li><p>2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中，严格遵守先进先出原则。</p></li>
</ul>
<ol start="2" type="1">
<li>系统IPC：</li>
</ol>
<p><strong>2.1 消息队列</strong></p>
<p><strong>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</strong></p>
<p><strong>特点</strong>：</p>
<ul>
<li><p>1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p></li>
<li><p>2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p></li>
<li><p>3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p></li>
</ul>
<p><strong>2.2 信号量<code>semaphore</code></strong></p>
<p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<p>特点：</p>
<ul>
<li><p>1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</p></li>
<li><p>2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</p></li>
<li><p>3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p></li>
<li><p>4)支持信号量组。</p></li>
</ul>
<p><strong>2.3 信号<code>signal</code></strong></p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p><strong>2.4 共享内存（Shared Memory）</strong></p>
<p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p>
<p>特点：</p>
<ul>
<li><p>1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p></li>
<li><p>2)因为多个进程可以同时操作，所以需要进行同步</p></li>
<li><p>3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p></li>
</ul>
<p><strong>3.套接字SOCKET</strong>：</p>
<p>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</p>
<h3 id="虚拟内存是什么作用">22 虚拟内存是什么、作用</h3>
<p>在概念上，<strong>虚拟内存是指存放在磁盘上的N字节大小的内存区域，</strong>每个字节都要相应的虚拟地址，作为寻址索引。<strong>和存储结构的缓存一样，磁盘的数据也被分割成块，在这类为做区别称之为虚拟页，每个虚拟页大小由计算机系统决定为<span class="math inline">\(P=2^p\)</span></strong>，与之对应的是物理页，其大小也应该为<code>P</code>。<strong>可以理解它是一种映射，由虚拟内存映射到真实物理内存上，这样在有限的内存上可以运行更多的程序。</strong></p>
<p>在任何时刻，我们都不能实际真实一股脑的为进程分配全部的存储空间，因此虚拟页面分为三个不相交的子集：</p>
<ul>
<li><strong>未分配的：</strong>VM系统还没有分配的页，此时未分配的块没有任何数据和它们管理，因此此时不会占有任何磁盘空间</li>
<li><strong>缓存的</strong>：当前缓存的虚拟页在占有磁盘中的空间，当然由于缓存到内存。内存当中也会占有一定内存空间</li>
<li><strong>维缓存的</strong>：在磁盘中占用空间，但并未缓存在内存中，当然不占用内存(此时当CPU要寻址该页当中一个数据时，由于未缓存在内存中，就会造成<strong>缺页异常</strong>。) <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/VP.png" width="700"></li>
</ul>
<h4 id="作用">作用</h4>
<ul>
<li>虚拟内存是作为缓存的工具，如<code>L1\L2\L3</code>作为主存的缓存，那么虚拟内存是作为主存与磁盘之间缓存的工具</li>
<li><p>虚拟内存的目的是为了让物理内存扩充成为更大的逻辑内存，从而让程序获得更多的可用内存。</p></li>
<li><p>更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。</p></li>
<li><p><strong>简化了链接，</strong>独立的地址空间允许每个进程的内存映像使用相同的格式，且都是相同的虚拟起始地址,只要保证虚拟内存地址得顺序就可以，而不用管代码和数据实际存放在物理内存的何处。</p></li>
<li><p>当程序引用到不在物理内存中的页时，产生缺页中断，将缺失的部分装入物理内存并重新执行失败的指令。可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p></li>
<li><p>提供了内存保护功能，每个进程的必须在自己的存储空间运行，虚拟内存起到了这个作用，虽然在逻辑地址上它们运行是在同一位置上，但通过地址转换成物理地址后，每个进程都有自己的真实物理地址。</p></li>
</ul>
<p>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<h3 id="几种典型的锁">23 几种典型的锁</h3>
<h4 id="读写锁">读写锁</h4>
<ul>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ul>
<h4 id="互斥锁">互斥锁</h4>
<p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
<p>互斥锁属于sleep-waiting类型的锁，互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，<strong>而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换</strong>。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>
<h4 id="条件变量">条件变量</h4>
<p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</p>
<h4 id="自旋锁">自旋锁</h4>
<p>自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。</p>
<p>虽然它的效率比互斥锁高，但是它也有些不足之处：</p>
<ul>
<li><p>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</p></li>
<li><p>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</p></li>
<li><p>自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</p></li>
</ul>
<h3 id="死锁产生的必要条件">24 死锁产生的必要条件</h3>
<ul>
<li><strong>互斥条件：</strong>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。</li>
<li><strong>请求和保持条件：</strong>指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li><strong>不可抢占条件：</strong>指进程已获得的资源，在未使用完之前，不能被剥夺抢占，只能在使用完时由自己释放。</li>
<li><strong>循环等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合<code>&#123;P0，P1，P2，…，Pn&#125;</code>中的<code>P0</code>正在等待一个<code>P1</code>占用的资源；<code>P1</code>正在等待 <code>P2</code>占用的资源，……，<code>Pn</code>正在等待已被P0占用的资源。</li>
</ul>
<h3 id="处理死锁的基本方法">处理死锁的基本方法</h3>
<p><strong>主要有以下五种方法：</strong></p>
<ul>
<li><strong>鸵鸟策略</strong></li>
<li><strong>预防死锁</strong>：该方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而可能会导致系统资源利用率和系统吞吐量降低。</li>
<li><strong>避免死锁</strong>：是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。这种方法只需事先施加较弱的限制条件，便可获得较高的资源利用率及系统吞吐量，但实现难度较高。</li>
<li><strong>检测死锁</strong>：是允许系统在运行过程中发生死锁，但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源； 然后，采取适当措施，从系统中将已发生的死锁清除掉。</li>
<li>** 解除死锁**：与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤消或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</li>
</ul>
<h4 id="鸵鸟策略">鸵鸟策略</h4>
<p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p><strong>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</strong></p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h4 id="预防死锁">预防死锁</h4>
<p>预防死锁的方法是使四个必要条件中的第<code>2、3、4</code>个条件之一不能成立，来避免发生死锁。至于必要<code>条件 1</code>，因为它是由设备的固有特性所决定的，不仅不能改变，还应加以保证。</p>
<h5 id="摒弃请求和保持条件">摒弃“请求和保持”条件</h5>
<p>在采用这种方法时，<strong>系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。</strong></p>
<ul>
<li>优点：简单、易于实现且很安全</li>
<li>缺点：资源严重浪费，恶化了系统资源的利用率；造成使进程延迟运行</li>
</ul>
<h5 id="摒弃不可抢占条件">摒弃不可抢占条件</h5>
<p>在采用这种方法时系统规定，进程是逐个地提出对资源的要求的。<strong>当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请</strong>。这意味着某一进程已经占有的资源，在运行过程中会被暂时地释放掉，也可认为是被剥夺了，从而摒弃了“不剥夺”条件。</p>
<ul>
<li><strong>缺点</strong>：实现起来比较复杂且要付出很大的代价。一个资源在使用一 段时间后，它的被迫释放可能会造成前段工作的失效，即使是采取了某些防范措施，也还会使进程前后两次运行的信息不连续。此外，这种策略还可能因为反复地申请和释放资源，致使进程的执行被无限地推迟，这不仅延长了进程的周转时间，而且也增加了系统开销，降低了系统吞吐量。</li>
</ul>
<h5 id="摒弃环路等待条件">摒弃“环路等待”条件</h5>
<p><strong>这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。</strong></p>
<ul>
<li><strong>缺点</strong>：是为系统中各类资源所分配(确定)的序号必须相对稳定，这就限制了新类型设备的增加；作业(进程)使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费；这种按规定次序申请的方法，必然会限制用户简单、自主地编程。</li>
</ul>
<h4 id="避免死锁">避免死锁</h4>
<p><strong>所谓安全状态，是指系统能按某种进程顺序<code>(P1，P2，…，Pn)</code>(称<code>〈P1，P2，…，Pn〉</code>序列为安全序列)，来为每个进程<code>Pi</code>分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</strong></p>
<p>并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便有可能进而进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。<strong>因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态。</strong> <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/安全状态.png" width="700"> 图 a 的第二列 <code>Has</code>表示已拥有的资源数，第三列<code>Max</code>表示总共需要的资源数，<code>Free</code> 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时<code>Free</code> 变为 5（图 c）；接着以同样的方式运行 <code>C</code>和<code>A</code>，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<blockquote>
<p>预防死锁和避免死锁这两种方法实质上都是通过施加某些限制条件，来预防发生死锁。两者的主要差别在于：为预防死锁所施加的限制条件较严格，这往往会影响进程的并发执行；而为避免死锁所施加的限制条件则较宽松，这给进程的运行提供了较宽松的环境，有利于进程的并发执行。</p>
</blockquote>
<h5 id="利用银行家算法避免死锁">利用银行家算法避免死锁</h5>
<p><strong>基本思想：</strong></p>
<ul>
<li>在每个新进程进入系统时，他必须声明在运行过程中，可能需要的每种资源类型的最大单元数目（数目不超过系统拥有的资源总量）。</li>
<li><strong>当进程请求一组资源时，系统必须首先在确定是否有足够的资源分配给该进程。</strong></li>
<li>若有，<strong>在进一步计算将这些资源分配给进程后，是否会使系统处于不安全状态。如果处于安全状态，才将资源分配给他；否则，让进程等待。</strong></li>
</ul>
<p><strong>银行家算法中的数据结构</strong>:</p>
<ul>
<li><strong>可利用资源向量<code>Available</code>：</strong>是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 <code>Available[j]=K</code>，则表示系统中现有<code>Rj</code>类资源<code>K</code>个。</li>
<li><strong>最大需求矩阵Max：</strong>是一个 <code>n×m</code>的矩阵，它定义了系统中 <code>n</code>个进程中的每一个进程对<code>m</code>类资源的最大需求。如果<code>Max[i,j]</code>=K，则表示进程<code>i</code>需要<code>Rj</code>类资源的最大数目为<code>K</code>。</li>
<li><strong>分配矩阵<code>Allocation</code>：</strong>是一个 <code>n×m</code>的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果<code>Allocation[i,j]=K</code>，则表示进程<code>i</code>当前已分得Rj类资源的数目为<code>K</code>。</li>
<li><strong>需求矩阵<code>Need</code>：</strong>是一个<code>n×m</code>的矩阵，用以表示每一个进程尚需的各类资源数。如果<code>Need[i,j]=K</code>，则表示进程<code>i</code>还需要<code>Rj</code>类资源<code>K</code> 个，方能完成其任务。</li>
</ul>
<blockquote>
<p><code>Need[i, j]=Max[i, j]-Allocation[i, j]</code></p>
</blockquote>
<p><strong>银行家算法</strong>:</p>
<p>设<code>Request i</code>是进程<code>Pi</code>的请求向量，如果<code>Request i[j]=K</code>，表示进程<code>Pi</code>需要<code>K</code> 个 <code>R j</code>类型的资源。当<code>Pi</code>发出资源请求后，系统按下述步骤进行检查：</p>
<ol type="1">
<li>如果<code>Request i[j]≤Need[i,j]</code>，便转向步骤<code>(2)</code>；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</li>
<li>如果<code>Requesti[j]≤Available[j]</code>，便转向步骤<code>(3)</code>；否则，表示尚无足够资源，Pi须等待。</li>
<li>系统试探着把资源分配给进程 <code>P i</code>，并修改下面数据结构中的数值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available[j]= Available[j]-Request i[j];</span><br><span class="line">Allocation[i,j] = Allocation[i,j]+Request i[j];</span><br><span class="line">Need[i,j] = Need[i,j]-Request i[j];</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>系统执行<strong>安全性算法</strong>，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程 Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程<code>Pi</code>等待。</li>
</ul>
<p><strong>安全性算法</strong>: 系统所执行的安全性算法可描述如下：</p>
<ol type="1">
<li>设置两个向量：
<ul>
<li>工作向量<code>work：</code>它表示系统可提供给进程继续运行所需的各类资源数目，它含有<code>m</code>个元素，在执行安全算法开始时，<code>Work=Available</code>。</li>
<li><code>Finish</code>：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做<code>Finish[i]=false；</code>当有足够资源分配给进程时，再令<code>Finish[i]=true。</code></li>
</ul></li>
<li>从进程集合中找到一个能满足下述条件的进程：
<ul>
<li><code>Finish[i]=false;</code></li>
<li><code>Need[i,j]≤Work[j];</code>若找到，执行步骤3，否则，执行步骤4。</li>
</ul></li>
<li>当进程<code>Pi</code>获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Work[j] = Work[j]+Allocation[i,j];</span><br><span class="line">Finish[i] = <span class="literal">true</span>;</span><br><span class="line">go to step <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li>如果所有进程的<code>Finish[i]=true</code>都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</li>
</ol>
<blockquote>
<p>缺点：每一次分配都要执行安全性算法，得到所有的Finish都是true，效率会有一定牺牲，但牺牲&lt;效益</p>
</blockquote>
<h4 id="检测死锁">检测死锁</h4>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/资源分配图.png" width="700"> 上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p><strong>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</strong></p>
<h5 id="每种类型多个资源的死锁检测">每种类型多个资源的死锁检测</h5>
<p><img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/多个资源的死锁检测.png" width="700"> 上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol type="1">
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<blockquote>
<p>就是拓扑排序思想</p>
</blockquote>
<h4 id="死锁解除">死锁解除</h4>
<p>当发现有进程死锁时，便应立即把它们从死锁状态中解脱出来。常采用解除死锁的两种方法是：</p>
<ul>
<li><strong>剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。</strong></li>
<li><strong>撤消进程。最简单的撤消进程的方法是使全部死锁进程都夭折掉；稍微温和一点的方法是按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为止。</strong></li>
</ul>
<h3 id="内存的覆盖是什么有什么特点">25 内存的覆盖是什么？有什么特点？</h3>
<p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</p>
<p>覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。</p>
<h3 id="内存交换是什么有什么特点">26 内存交换是什么？有什么特点？</h3>
<ul>
<li><p><strong>交换(对换)技术的设计思想：</strong>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p></li>
<li>换入：把准备好竞争CPU运行的程序从辅存移到内存。</li>
<li><p>换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。</p></li>
</ul>
<h3 id="操作系统的页表寻址">27 操作系统的页表寻址</h3>
<p>虚拟内存系统必须以某种方法来判断一个虚拟页是否在主存DRAM上，如果在，还必须确定在DRAM的哪个位置。若不命中，触发<strong>缺页异常</strong>，还必须知道它在磁盘的哪个位置，同时还必须用页调度算法在物理内存中牺牲一个页进行替换。</p>
<p>上述的功能由软硬件共同结合作用，包括操作系统软件、MMU和重要的数据结构——页表。页表上是虚拟地址和物理页的关系，它常驻在主存上。每次地址翻译硬件将一个虚拟地址转为物理地址时，都会读取页表。页表的结构如下，页表就是页表条目PTE数组。简而言之，页表是为了配合计算机的虚拟内存而设计出来的数据结构。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/PTE.png" width="500"></p>
<p><strong>页表寻址命中过程</strong>：</p>
<ul>
<li>当CPU为了获取内存当中位于某个页面内某个位置的数据，它会产生一个虚拟地址<code>VA</code>，把它送给MMU</li>
<li>第二步：MMU用<code>VA</code>去高速缓存/主存获得<code>PTE</code>页表条目</li>
<li>第三步：高速缓存/主存向MMU返回一个PTE</li>
<li>第四步：MMU利用PTE和VA构造物理地址，并把它传送给主存</li>
<li>第五步：高数缓存/主存返回所请求的的数据给处理器</li>
</ul>
<p><img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/aimed.png" width="700"> 其中的物理地址构造如图所示，虚拟地址的后<code>p</code>位作为该页偏移地址，<code>PTE</code>内存储相应的物理页号，因此将它们拼接就可以得到真正的物理地址。</p>
<h3 id="页表未命中缺页会发生什么">28 页表未命中，缺页会发生什么？</h3>
<p>此时若CPU要使用<code>VP3</code>该页中某块的某个数据，由于主存并没有缓存该物理页，因此页表的<code>PTE</code>有效位为<code>0</code>，就会触发缺页异常，执行缺页处理程序，进行页面调度替换后再返回原来执行的指令<span class="math inline">\(I_{cur}\)</span>重新执行该虚拟的地址上的数据请求。<strong>在缺页异常处理程序，该程序会选择一个牺牲页作为替换<code>VP3</code>,假如选择了<code>VP4</code>作为替换页，若<code>VP4</code>修改了，那么内核执行写回操作，将他复制回磁盘。</strong></p>
<ul>
<li><strong>步骤：</strong>
<ul>
<li>第一步和第三步：与上述一样</li>
<li>第四步：PTE的有效位是零，所以MMU回触发缺页异常，传递给CPU中的控制到操作系统内核中的缺页异常处理程序。</li>
<li>第五步：缺页异常处理程序确定物理内存的牺牲页，如果这个页面已经被修改，则把它换出到磁盘</li>
<li>第六步：缺页异常处理程序调入新的页面，并且更新页表对应的<code>PTE</code></li>
<li>第七步：缺页异常处理程序返回到原来的进程，再次执行导致缺页的指令。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/miss.png" width="700"></li>
</ul></li>
</ul>
<h3 id="页表也会占用内存计算机是怎么设计">29 页表也会占用内存，计算机是怎么设计。</h3>
<p>上面讨论的都是单级页表的情况，对于单级页表，无论是否分配，我们都要维护PTE,试想一下<code>32位</code>系统，页面大小是<code>4KB</code>和一个<code>4</code>字节的PTE，那么在内存中总需要用<span class="math inline">\(4GB/4KB*4byte=4MB\)</span>的页表，对于64位来说更加复杂。内存是计算机很稀缺的资源，我们当然不希望内存因为存储页表而耗费太多的内存，<strong>虚拟内存并不是所有都会分配使用，因此多级页表利用这个特性解决这个问题的。</strong></p>
<p>多级页表中，第一级页表正常分配<code>1024</code>个PTE，但其中许多<code>PTE</code>都是未分配的即<code>null</code>，那么二级页表就不会去生成它们的二级页表，这样就大大节约了空间。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/manyLevel.png" width="700"> 上图中只占用了内存<span class="math inline">\(1024*4Byte*4=16KB\)</span></p>
<h3 id="页面置换算法">30 页面置换算法</h3>
<h4 id="最佳置换法opt">1 最佳置换法(OPT)</h4>
<p><strong>最佳置换算法(OPT，Optimal) :</strong>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OPT.png" width="700"> 最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的</p>
<h4 id="先进先出置换算法fifo">2 先进先出置换算法(FIFO)</h4>
<p>先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FIFO.png" width="700"> - <strong>Belady异常：</strong>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</p>
<blockquote>
<p>只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p>
</blockquote>
<blockquote>
<p>FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p>
</blockquote>
<h4 id="最近最久未使用置换算法lru">3最近最久未使用置换算法(LRU)</h4>
<ul>
<li>最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面</li>
<li>实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。 <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LRU.png" width="700"> LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。</li>
</ul>
<h4 id="时钟置换算法clock">4 时钟置换算法(CLOCK)</h4>
<p>最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p>
<p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。</p>
<p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)</p>
<ul>
<li><strong>简单的CLOCK算法实现方法:</strong>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第1轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描) <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CLOCK.png" width="700"></li>
</ul>
<h4 id="改进型的时钟置换算法">5 改进型的时钟置换算法</h4>
<p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p>
<p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。<code>修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。</code></p>
<p>为方便讨论，用<code>(访问位，修改位)</code>的形式表示各页面状态。如<code>(1, 1)</code>表示一个页面近期被访问过，且被修改过。</p>
<p>改进型的Clock算法需要综合考虑某一内存页面的访问位和修改位来判断是否置换该页面。在实际编写算法过程中，同样可以用一个等长的整型数组来标识每个内存块的修改状态。访问位A和修改位M可以组成一下四种类型的页面。</p>
<p><strong>算法规则：</strong>将所有可能被置换的页面排成一个循环队列</p>
<ul>
<li><p><strong>第一轮：</strong>从当前位置开始扫描到第一个<code>(A =0, M = 0)</code>的页用于替换。表示该页面最近既未被访问，又未被修改，是最佳淘汰页（第一优先级）</p></li>
<li><p><strong>第二轮：</strong>若第一轮扫描失败，则重新扫描，查找第一个<code>(A =0, M = 1)</code>的帧用于替换。本轮扫描会将访问位置<code>0</code>。本轮目的是寻找表示该页面最近未被访问，但被修改的页面，并不是很好的淘汰页。（第二）</p></li>
<li><p><strong>第三轮：</strong>若第二轮扫描失败，则重新扫描，查找第一个<code>(A =0, M = 0)</code>的帧用于替换。本轮扫描不修改任何标志位。表示该页面最近被访问，但未修改。（第三优先级）</p></li>
<li><p><strong>第四轮：</strong>若第三轮扫描失败，则重新扫描，查找第一个<code>(0, 1)</code>的帧用于替换。表示最近被访问，且已被修改的页面（最坏情况） <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pCLOCK.png" width="700"></p></li>
</ul>
<h4 id="总结-1">6 总结</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">算法规则</th>
<th style="text-align: left;">优缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>OPT</code></td>
<td style="text-align: left;">优先淘汰最长时间内不会被访问的页面</td>
<td style="text-align: left;">缺页率最小，性能最好;但无法实现</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FIFO</code></td>
<td style="text-align: left;">优先淘汰最先进入内存的页面</td>
<td style="text-align: left;">实现简单;但性能很差，可能出现Belady异常</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>LRU</code></td>
<td style="text-align: left;">优先淘汰最近最久没访问的页面</td>
<td style="text-align: left;">性能很好;但需要硬件支持，算法开销大</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>CLOCK (NRU)</code></td>
<td style="text-align: left;">最多两轮</td>
<td style="text-align: left;">实现简单，算法开销小;但未考虑页面是否被修改过。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>改进型CLOCK (改进型NRU)</code></td>
<td style="text-align: left;">若用(访问位，修改位)的形式表述，最多四轮</td>
<td style="text-align: left;">算法开销较小，性能也不错</td>
</tr>
</tbody>
</table>
<h3 id="linux中异常和中断的区别">31 Linux中异常和中断的区别</h3>
<h4 id="中断">中断</h4>
<p>大家都知道，当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。下面这张图显示了中断处理的流程：</p>
<h4 id="异常">异常</h4>
<p>CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。所以，大家也需要记住的是，异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常，下面这张图显示了异常处理的流程：</p>
<ul>
<li>相同点
<ul>
<li><p>最后都是由CPU发送给内核，由内核去处理</p></li>
<li><p>处理程序的流程设计上是相似的</p></li>
</ul></li>
<li>不同点
<ul>
<li>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的</li>
<li>内核需要根据是异常还是中断调用不同的处理程序</li>
<li>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</li>
<li>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</li>
</ul></li>
</ul>
<h3 id="上下文切换是什么">32 上下文切换是什么</h3>
<p>上下文切换（Context Switch）是操作系统中的一种机制，用于在多任务环境下，从一个任务（进程或线程）切换到另一个任务时保存和恢复任务的执行环境和状态。</p>
<p>在多任务操作系统中，同时存在多个任务需要并发执行。<strong>每个任务都有自己的执行上下文，包括寄存器状态、程序计数器（PC）值、栈指针、打开的文件、内存映射等</strong>。当操作系统需要切换当前正在执行的任务到另一个任务时，就需要进行上下文切换。</p>
<p><strong>上下文切换的过程包括以下步骤：</strong></p>
<ul>
<li><p>保存当前任务的上下文：操作系统会保存当前任务的寄存器状态、PC值、堆栈指针等信息，并将其保存在任务的上下文数据结构中，以便在之后能够正确地恢复任务的执行状态。</p></li>
<li><p>恢复目标任务的上下文：操作系统会从目标任务的上下文数据结构中读取保存的上下文信息，并将寄存器状态、PC值、堆栈指针等恢复到目标任务的执行状态。</p></li>
<li><p>切换执行：一旦目标任务的上下文恢复完毕，操作系统会将控制权切换到目标任务，开始执行目标任务的代码。</p></li>
</ul>
<p><strong>上下文切换的目的是实现任务的并发执行和共享CPU资源。通过在任务之间进行快速而有效的上下文切换，操作系统可以在有限的处理器资源下，实现多任务的轮转调度或优先级调度，以满足不同任务的执行需求。</strong></p>
<p>上下文切换的开销是一个重要的考量因素。切换过程中，<strong>需要保存和恢复大量的寄存器状态和其他执行环境，还可能涉及内存管理和页表切换等操作，这会带来一定的开销</strong>。因此，在设计操作系统调度算法时需要综合考虑上下文切换的成本和任务切换的频率，以实现高效的任务调度和系统性能。</p>
<h3 id="中断上下文和异常上下文">33 中断上下文和异常上下文</h3>
<p><strong>中断上下文（Interrupt Context）</strong>和<strong>异常上下文（Exception Context）</strong>是指在处理中断和异常时所处的执行环境和状态。</p>
<ul>
<li><p>中断上下文是指在处理硬件中断时保存的处理器状态和相关信息。当硬件设备触发中断时，处理器会立即中断当前执行的程序，保存当前的上下文信息，包括寄存器状态、程序计数器（PC）值、栈指针等。然后，处理器会切换到中断处理程序，执行相应的中断处理逻辑。中断上下文通常是由硬件和操作系统共同管理的，以确保在中断处理程序执行期间，中断不会干扰到正在运行的程序或任务。</p></li>
<li><p>异常上下文是指在处理异常时保存的处理器状态和相关信息。当程序执行过程中发生异常（如除零错误、非法内存访问等），处理器会立即中断当前执行的程序，保存当前的上下文信息，包括寄存器状态、程序计数器（PC）值、栈指针等。然后，处理器会将控制转移到异常处理程序，根据异常类型执行相应的处理逻辑。异常上下文通常是由操作系统提供的异常处理机制管理的，以确保在异常处理程序执行期间能够正确处理异常情况，并继续执行程序或采取适当的措施。</p></li>
</ul>
<p><strong>区别在于触发机制和处理方式：</strong></p>
<ul>
<li>中断是由外部设备或信号触发，可以是硬件中断或软件中断。中断上下文用于处理设备的输入输出操作或请求系统服务。</li>
<li>异常是由程序执行过程中的错误或特殊情况触发，可以是硬件异常或软件异常。异常上下文用于处理程序执行过程中的错误或异常情况</li>
</ul>
<h3 id="内核抢占和非内核抢占">34 内核抢占和非内核抢占</h3>
<p>内核抢占（Kernel Preemption）和非内核抢占（Non-Kernel Preemption）是操作系统中的两种不同的调度机制。</p>
<ul>
<li><p>内核抢占指的是当一个进程或线程正在执行内核态（kernel mode）代码时，如果有更高优先级的任务需要执行，操作系统会强制暂停当前内核态的执行，切换到更高优先级的任务执行。这种机制允许操作系统及时响应紧急的任务或事件，保证系统的可靠性和实时性。内核抢占通常需要硬件支持，例如通过定时器中断或外部中断信号来触发内核抢占。</p></li>
<li><p>非内核抢占是指当一个进程或线程正在执行用户态（user mode）代码时，如果有更高优先级的任务需要执行，操作系统会暂停当前用户态的执行，切换到更高优先级的任务。非内核抢占是由操作系统自身实现的，通常基于时间片轮转或优先级调度等算法来决定任务的切换时机。非内核抢占可以提高系统的响应性能，<strong>但也可能导致一些问题，如上下文切换开销过大、竞争条件等。</strong></p></li>
</ul>
<p>总的来说，内核抢占和非内核抢占都是为了实现多任务调度和提高系统的性能和可靠性。内核抢占在内核态代码执行期间也能被中断，而非内核抢占只在用户态代码执行期间进行切换。</p>
<h3 id="守护进程孤儿进程和僵尸进程">35 守护进程、孤儿进程和僵尸进程</h3>
<h4 id="守护进程">守护进程</h4>
<p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等</p>
<h4 id="孤儿进程">孤儿进程</h4>
<p>如果父进程先退出，子进程还没退出，那么子进程此时就成为孤儿进程，孤儿进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作</p>
<h4 id="僵尸进程">僵尸进程</h4>
<p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为<strong>僵尸进程。</strong></p>
<p>设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用<code>wait</code>或<code>waitpid</code>时就可以得到这些信息。</p>
<p>因此对于僵尸进程，父进程必须进行回收，否则会消耗系统资源，比如进程ID</p>
<h3 id="如何避免僵尸进程">36 如何避免僵尸进程?</h3>
<ul>
<li><p>通过<code>signal(SIGCHLD, SIG_IGN)</code>通知内核对子进程的结束不关心，由内核回收,此时子进程是由<code>init()</code>进程管理和回收。</p></li>
<li><p>父进程调用<code>wait/waitpid</code>等函数等待子进程结束，如果尚无子进程退出<code>wait</code>会导致父进程阻塞。<code>waitpid</code>可以通过传递<code>WNOHANG</code>使父进程不阻塞立即返回。</p></li>
<li><p>如果父进程很忙不要阻塞，可以用<code>signal</code>注册信号处理函数，在信号处理函数调用<code>wait/waitpid</code>等待子进程退出。</p></li>
<li><p>通过两次调用<code>fork</code>。父进程首先调用<code>fork</code>创建一个子进程然后<code>waitpid</code>等待子进程退出，子进程再<code>fork</code>一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由<code>init</code>进程接管，孙进程结束后，<code>init会</code>等待回收。</p></li>
</ul>
<h3 id="计算机大小端">37 计算机大小端</h3>
<p>对于跨域多字节的程序对象，必须有两个规则：</p>
<ul>
<li>这个对象的地址是什么：在几乎所有的机器上，多字节对象都被存储为连续的字节序列，<strong>对象的地址为所使用字节中最小的地址。</strong></li>
<li>这个对象在内存中是如何排列这些字节的：排列ijie有两个通用的规则，一个是大端(网络字节序)，一个是小端(主机序);<strong>大端字节序在内存中按从最高有效位到最低有效位存储；而小端字节序在内存中按照从最低有效位到最高有效位存储</strong>
<ul>
<li>现有一个int型变量，位于初始地址为<code>0x100</code>，它的十六进制值为<code>0x01234567</code>，则大小端存储如下： <img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/bigsmall.png" width="700"></li>
</ul></li>
</ul>
<p>如何区分计算机是大端存储还是小端存储： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>* byte_pointer;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start,size_tlen)</span></span>&#123;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%2.x &quot;</span>,start[i]);	<span class="comment">//%2.x表示整数必须用两个16进制输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">0x123456</span>;</span><br><span class="line"><span class="built_in">show_bytes</span>((byte_pointer)&amp;a,<span class="built_in">seziof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure> 输出 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">56</span> <span class="number">34</span> <span class="number">12</span> <span class="number">00</span></span><br></pre></td></tr></table></figure> 观察输出可知本计算机使用小端法存储数据</p>
<h3 id="线程回收方式">38 线程回收方式</h3>
<ul>
<li><code>pthread_join</code>阻塞方式回收：主线程调用，等待子线程退出并回收其资源，类似于进程中<code>wait/waitpid</code>回收僵尸进程，调用的线程会被阻塞。</li>
<li><code>pthread_detach</code>非阻塞形式回收：主线程、子线程均可调用。主线程中<code>pthread_detach(tid)</code>，子线程中<code>pthread_detach(pthread_self())</code>，调用后和主线程分离，子线程结束时自己立即回收资源。</li>
</ul>
<h3 id="linux环境下的内存分布">39 Linux环境下的内存分布</h3>
<p><img src="/2023/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/memoryList.png" width="700"> 过这张图你可以看到，用户空间内存，从低到高分别是 7 种不同的内存段：</p>
<ul>
<li>代码段<code>.txt</code>：程序文件段，包括二进制可执行代码；</li>
<li>已初始化数据段<code>.data</code>：又细分为只读数据段和读写数据段，存储全局变量、静态变量；</li>
<li>未初始化数据段<code>.bss</code>：它存储所有被初始化为0或者未初始化的静态变量，这些为初始化的变量在程序启动时被自动初始化为0。</li>
<li>堆段：包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段：包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</li>
<li>栈段：包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<h3 id="在linuxwindows平台下栈空间的大小">40 在Linux/windows平台下栈空间的大小</h3>
<ul>
<li>Linux环境下有操作系统决定，一般是<code>8MB，8192KB</code>，通过<code>ulimit -a</code>命令查看,通过<code>ulimit -s</code>修改 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">trluper@DESKTOP<span class="number">-67</span>ADUGH:~$ ulimit -a</span><br><span class="line">real-time non-<span class="function">blocking <span class="title">time</span>  <span class="params">(microseconds, -R)</span> unlimited</span></span><br><span class="line"><span class="function">core file <span class="title">size</span>              <span class="params">(blocks, -c)</span> 0</span></span><br><span class="line"><span class="function">data seg <span class="title">size</span>               <span class="params">(kbytes, -d)</span> unlimited</span></span><br><span class="line"><span class="function">scheduling <span class="title">priority</span>                 <span class="params">(-e)</span> 0</span></span><br><span class="line"><span class="function">file <span class="title">size</span>                   <span class="params">(blocks, -f)</span> unlimited</span></span><br><span class="line"><span class="function">pending <span class="title">signals</span>                     <span class="params">(-i)</span> 15393</span></span><br><span class="line"><span class="function">max locked <span class="title">memory</span>           <span class="params">(kbytes, -l)</span> 64</span></span><br><span class="line"><span class="function">max memory <span class="title">size</span>             <span class="params">(kbytes, -m)</span> unlimited</span></span><br><span class="line"><span class="function">open <span class="title">files</span>                          <span class="params">(-n)</span> 1024</span></span><br><span class="line"><span class="function">pipe <span class="title">size</span>                <span class="params">(<span class="number">512</span> bytes, -p)</span> 8</span></span><br><span class="line"><span class="function">POSIX message <span class="title">queues</span>         <span class="params">(bytes, -q)</span> 819200</span></span><br><span class="line"><span class="function">real-time <span class="title">priority</span>                  <span class="params">(-r)</span> 0</span></span><br><span class="line"><span class="function">stack <span class="title">size</span>                  <span class="params">(kbytes, -s)</span> 8192</span></span><br><span class="line"><span class="function">cpu <span class="title">time</span>                   <span class="params">(seconds, -t)</span> unlimited</span></span><br><span class="line"><span class="function">max user <span class="title">processes</span>                  <span class="params">(-u)</span> 15393</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">memory</span>              <span class="params">(kbytes, -v)</span> unlimited</span></span><br><span class="line"><span class="function">file <span class="title">locks</span>                          <span class="params">(-x)</span> unlimited</span></span><br></pre></td></tr></table></figure></li>
<li>Windows环境下由编译器决定，VC++6.0一般是1M</li>
</ul>
<h3 id="程序从堆中动态分配内存时虚拟内存上怎么操作的">41 程序从堆中动态分配内存时，虚拟内存上怎么操作的</h3>
<p><strong>页表：</strong>是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系</p>
<p>在进行动态内存分配时，例如<code>malloc()</code>函数或者其他高级语言中的<code>new</code>关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目<code>（PTE）</code>，使该<code>PTE</code>指向硬盘上这个新创建的虚拟页），通过<code>PTE</code>建立虚拟页和物理页的映射关系。</p>
<h3 id="抖动你知道是什么吗它也叫颠簸现象">42 抖动你知道是什么吗？它也叫颠簸现象</h3>
<p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的实际内存物理块不够)</p>
<p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率 为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程工作集” 的概念</p>
<h3 id="什么是进程工作集">43 什么是进程工作集</h3>
<h3 id="从堆和栈上建立对象哪个快">44 从堆和栈上建立对象哪个快？</h3>
<p>栈比较快，从两方面来考虑：</p>
<ul>
<li><p><strong>分配和释放，</strong>堆在分配和释放时都要调用函数（malloc,free)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看malloc和free的源代码，函数做了很多额外的工作，而栈却不需要这些。</p></li>
<li><p><strong>访问时间</strong>，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次，栈常驻内存中。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的</p></li>
</ul>
<h3 id="常见的内存错误">45 常见的内存错误</h3>
<ul>
<li><p>内存分配未成功，却使用了它。</p>
<p>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为<code>NULL</code>。如果指针p是函数的参数，那么在函数的入口处用<code>assert(p!=NULL)</code>进行检查。如果是用<code>malloc</code>或<code>new</code>来申请内存，应该用<code>if(p==NULL)</code> 或<code>if(p!=NULL)</code>进行防错处理。</p></li>
<li><p>内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</p></li>
<li><p>内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</p></li>
<li><p>忘记了释放内存，造成内存泄露。</p>
<p>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中<code>malloc</code>与<code>free</code>的使用次数一定要相同，否则肯定有错误（<code>new/delete</code>同理）。</p></li>
<li><p>释放了内存却继续使用它。常见于以下有三种情况：</p>
<ul>
<li><p>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</p></li>
<li><p>函数的<code>return</code>语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</p></li>
<li><p>使用<code>free</code>或<code>delete</code>释放了内存后，没有将指针设置为<code>NULL</code>。导致产生“野指针”。</p></li>
</ul></li>
</ul>
<h3 id="内存交换中被换出的进程保存在哪里">46 内存交换中，被换出的进程保存在哪里？</h3>
<p><strong>保存在磁盘中，也就是外存中</strong>。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。</p>
<h3 id="五种io模型">47 五种IO模型</h3>
<h3 id="fork操作原理">48 fork操作原理</h3>
<h3 id="linux常用命令">49 Linux常用命令</h3>
<p>见<a target="_blank" rel="noopener" href="https://trluper.cn/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">Linux常用命令</a></p>
<h3 id="生成者-消费者模型">50 生成者-消费者模型</h3>
<h3 id="经典同步问题">51 经典同步问题</h3>
<h4 id="读者写者问题">读者—写者问题</h4>
<h4 id="哲学家进餐问题">哲学家进餐问题</h4>
<p>文章参考来源 &gt;<a target="_blank" rel="noopener" href="https://github.com/forthespada/InterviewGuide/tree/main">InterviewGuide</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="trluper 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="trluper 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/05/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/" rel="prev" title="深入理解计算机系统-链接">
      <i class="fa fa-chevron-left"></i> 深入理解计算机系统-链接
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" rel="next" title="深入理解计算机系统-异常控制流">
      深入理解计算机系统-异常控制流 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">1 操作系统的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8kernel"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统的内核（Kernel）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8cpucentral-processing-unit"><span class="nav-number">1.2.</span> <span class="nav-text">中央处理器（CPU，Central Processing Unit）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpu-vs-kernel%E5%86%85%E6%A0%B8"><span class="nav-number">1.3.</span> <span class="nav-text">CPU vs Kernel(内核)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">2 操作系统的基本特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%80%A7"><span class="nav-number">2.1.</span> <span class="nav-text">并发性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">共享性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">互斥共享方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">同时访问方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%80%A7"><span class="nav-number">2.3.</span> <span class="nav-text">虚拟性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%80%A7"><span class="nav-number">2.4.</span> <span class="nav-text">异步性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="nav-number">3.</span> <span class="nav-text">3 操作系统的基本功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%81%E6%98%AF"><span class="nav-number">4.</span> <span class="nav-text">4 什么是系统调用&#x2F;用户态和系统态是？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">4.1.</span> <span class="nav-text">为什么要有用户态与内核态?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%88%87%E6%8D%A2%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">用户态切换到内核态的几种方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">5 计算机的局部性原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">6 磁盘调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.1.</span> <span class="nav-text">先来先服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="nav-number">6.2.</span> <span class="nav-text">最短寻道时间优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B5%E6%A2%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">电梯扫描算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">7.</span> <span class="nav-text">7 进程、线程和协程的区别和联系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.1.</span> <span class="nav-text">线程和进程的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">协程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3"><span class="nav-number">8.</span> <span class="nav-text">8 一个进程可以创建多少线程，和什么有关？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">9 外中断和异常有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91"><span class="nav-number">10.</span> <span class="nav-text">10 进程线程模型你知道多少？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">10.1.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">10.2.</span> <span class="nav-text">多进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91"><span class="nav-number">11.</span> <span class="nav-text">11 进程调度算法你了解多少？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-first-come-first-serverdfcfs"><span class="nav-number">11.1.</span> <span class="nav-text">先来先服务 first-come first-serverd（FCFS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-shortest-job-firstsjf"><span class="nav-number">11.2.</span> <span class="nav-text">短作业优先 shortest job first（SJF）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-shortest-remaining-time-nextsrtn"><span class="nav-number">11.3.</span> <span class="nav-text">最短剩余时间优先 shortest remaining time next（SRTN）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC"><span class="nav-number">11.4.</span> <span class="nav-text">时间片轮转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">11.5.</span> <span class="nav-text">优先级调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="nav-number">11.6.</span> <span class="nav-text">多级反馈队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="nav-number">12.</span> <span class="nav-text">12 进程状态的切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">13.</span> <span class="nav-text">13 Linux下进程间通信方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E4%B8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">14.</span> <span class="nav-text">14 Linux下同步机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8tlb%E5%90%8E%E9%82%A3%E4%B9%88%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E4%BA%86"><span class="nav-number">15.</span> <span class="nav-text">15 如果系统中具有快表(tlb)后，那么地址的转换过程变成什么样了？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%8F%AF%E4%BB%A5%E5%88%86%E5%88%AB%E8%AF%B4%E8%AF%B4%E5%90%97"><span class="nav-number">16.</span> <span class="nav-text">16 动态分区分配算法有哪几种？可以分别说说吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-number">16.1.</span> <span class="nav-text">1 首次适应算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-number">16.2.</span> <span class="nav-text">2 最佳适应算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-number">16.3.</span> <span class="nav-text">3 最坏适应算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-number">16.4.</span> <span class="nav-text">4 邻近适应算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">16.5.</span> <span class="nav-text">5 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E5%92%8C%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87"><span class="nav-number">17.</span> <span class="nav-text">17 外部碎片和内部碎片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">18.</span> <span class="nav-text">18 虚拟技术你了解吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AAcc%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E5%88%B0%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E4%BD%A0%E8%83%BD%E8%AF%B4%E5%87%BA%E6%9D%A5%E5%A4%9A%E5%B0%91"><span class="nav-number">19.</span> <span class="nav-text">19 一个C&#x2F;C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%AF%B9%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="nav-number">20.</span> <span class="nav-text">20 操作系统在对内存进行管理的时候需要做些什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">21.</span> <span class="nav-text">21 进程间通信有哪几种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">22.</span> <span class="nav-text">22 虚拟内存是什么、作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">22.1.</span> <span class="nav-text">作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81"><span class="nav-number">23.</span> <span class="nav-text">23 几种典型的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">23.1.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">23.2.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">23.3.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">23.4.</span> <span class="nav-text">自旋锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">24.</span> <span class="nav-text">24 死锁产生的必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-number">25.</span> <span class="nav-text">处理死锁的基本方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%B8%B5%E9%B8%9F%E7%AD%96%E7%95%A5"><span class="nav-number">25.1.</span> <span class="nav-text">鸵鸟策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="nav-number">25.2.</span> <span class="nav-text">预防死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%91%92%E5%BC%83%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BF%9D%E6%8C%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">25.2.1.</span> <span class="nav-text">摒弃“请求和保持”条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%91%92%E5%BC%83%E4%B8%8D%E5%8F%AF%E6%8A%A2%E5%8D%A0%E6%9D%A1%E4%BB%B6"><span class="nav-number">25.2.2.</span> <span class="nav-text">摒弃不可抢占条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%91%92%E5%BC%83%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-number">25.2.3.</span> <span class="nav-text">摒弃“环路等待”条件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">25.3.</span> <span class="nav-text">避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">25.3.1.</span> <span class="nav-text">利用银行家算法避免死锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="nav-number">25.4.</span> <span class="nav-text">检测死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">25.4.1.</span> <span class="nav-text">每种类型多个资源的死锁检测</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4"><span class="nav-number">25.5.</span> <span class="nav-text">死锁解除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E8%A6%86%E7%9B%96%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">26.</span> <span class="nav-text">25 内存的覆盖是什么？有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">27.</span> <span class="nav-text">26 内存交换是什么？有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%A1%B5%E8%A1%A8%E5%AF%BB%E5%9D%80"><span class="nav-number">28.</span> <span class="nav-text">27 操作系统的页表寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E6%9C%AA%E5%91%BD%E4%B8%AD%E7%BC%BA%E9%A1%B5%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">29.</span> <span class="nav-text">28 页表未命中，缺页会发生什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E4%B9%9F%E4%BC%9A%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="nav-number">30.</span> <span class="nav-text">29 页表也会占用内存，计算机是怎么设计。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">31.</span> <span class="nav-text">30 页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E6%B3%95opt"><span class="nav-number">31.1.</span> <span class="nav-text">1 最佳置换法(OPT)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95fifo"><span class="nav-number">31.2.</span> <span class="nav-text">2 先进先出置换算法(FIFO)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95lru"><span class="nav-number">31.3.</span> <span class="nav-text">3最近最久未使用置换算法(LRU)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95clock"><span class="nav-number">31.4.</span> <span class="nav-text">4 时钟置换算法(CLOCK)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">31.5.</span> <span class="nav-text">5 改进型的时钟置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">31.6.</span> <span class="nav-text">6 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">32.</span> <span class="nav-text">31 Linux中异常和中断的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">32.1.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">32.2.</span> <span class="nav-text">异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">33.</span> <span class="nav-text">32 上下文切换是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%BC%82%E5%B8%B8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">34.</span> <span class="nav-text">33 中断上下文和异常上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0%E5%92%8C%E9%9D%9E%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0"><span class="nav-number">35.</span> <span class="nav-text">34 内核抢占和非内核抢占</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">36.</span> <span class="nav-text">35 守护进程、孤儿进程和僵尸进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">36.1.</span> <span class="nav-text">守护进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">36.2.</span> <span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">36.3.</span> <span class="nav-text">僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">37.</span> <span class="nav-text">36 如何避免僵尸进程?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A4%A7%E5%B0%8F%E7%AB%AF"><span class="nav-number">38.</span> <span class="nav-text">37 计算机大小端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">39.</span> <span class="nav-text">38 线程回收方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="nav-number">40.</span> <span class="nav-text">39 Linux环境下的内存分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8linuxwindows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">41.</span> <span class="nav-text">40 在Linux&#x2F;windows平台下栈空间的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%A0%86%E4%B8%AD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%97%B6%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8A%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84"><span class="nav-number">42.</span> <span class="nav-text">41 程序从堆中动态分配内存时，虚拟内存上怎么操作的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%96%E5%8A%A8%E4%BD%A0%E7%9F%A5%E9%81%93%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%E5%AE%83%E4%B9%9F%E5%8F%AB%E9%A2%A0%E7%B0%B8%E7%8E%B0%E8%B1%A1"><span class="nav-number">43.</span> <span class="nav-text">42 抖动你知道是什么吗？它也叫颠簸现象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="nav-number">44.</span> <span class="nav-text">43 什么是进程工作集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%8A%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1%E5%93%AA%E4%B8%AA%E5%BF%AB"><span class="nav-number">45.</span> <span class="nav-text">44 从堆和栈上建立对象哪个快？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF"><span class="nav-number">46.</span> <span class="nav-text">45 常见的内存错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E4%B8%AD%E8%A2%AB%E6%8D%A2%E5%87%BA%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">47.</span> <span class="nav-text">46 内存交换中，被换出的进程保存在哪里？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E7%A7%8Dio%E6%A8%A1%E5%9E%8B"><span class="nav-number">48.</span> <span class="nav-text">47 五种IO模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">49.</span> <span class="nav-text">48 fork操作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">50.</span> <span class="nav-text">49 Linux常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">51.</span> <span class="nav-text">50 生成者-消费者模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">52.</span> <span class="nav-text">51 经典同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">52.1.</span> <span class="nav-text">读者—写者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">52.2.</span> <span class="nav-text">哲学家进餐问题</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:48</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
      <script type="text/javascript">
      function renderGitalk(){
        var gitalk = new Gitalk({
            owner: '',
            repo: '',
            clientID: '123fe329fdbb06b0f1d1',
            clientSecret: '40add829107b6e69f43274d3545ae71c988de8eb',
            admin: '',
            
            });
        gitalk.render('gitalk-container');
      }
      renderGitalk();
      </script>
    
 


<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>