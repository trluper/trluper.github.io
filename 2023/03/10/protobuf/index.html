<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1 Protobuf 概述 Protocol Buffer (简称Protobuf) 是Google出品的性能优异、跨语言、跨平台的序列化库。在网络通信和通用数据交换等应用场景中经常使用的技术是 JSON或 XML，在微服务架构中通常使用另外一个数据交换的协议的工具ProtoBuf。 ProtoBuf也是我们做微服务开发，进行Go进阶实战中，必知必会的知道点。 ProtoBuf全称：prot">
<meta property="og:type" content="article">
<meta property="og:title" content="protobuf">
<meta property="og:url" content="https://example.com/2023/03/10/protobuf/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:description" content="1 Protobuf 概述 Protocol Buffer (简称Protobuf) 是Google出品的性能优异、跨语言、跨平台的序列化库。在网络通信和通用数据交换等应用场景中经常使用的技术是 JSON或 XML，在微服务架构中通常使用另外一个数据交换的协议的工具ProtoBuf。 ProtoBuf也是我们做微服务开发，进行Go进阶实战中，必知必会的知道点。 ProtoBuf全称：prot">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://example.com/2023/03/10/protobuf/protobuf的特点.png">
<meta property="og:image" content="https://example.com/2023/03/10/protobuf/protobuf的存储方式.png">
<meta property="og:image" content="https://example.com/2023/03/10/protobuf/wireType.png">
<meta property="og:image" content="https://example.com/2023/03/10/protobuf/varint.png">
<meta property="og:image" content="https://example.com/2023/03/10/protobuf/varint解码方式.png">
<meta property="og:image" content="https://example.com/2023/03/10/protobuf/string类型的value.png">
<meta property="og:image" content="https://example.com/2023/03/10/protobuf/string类型的value存储方式.png">
<meta property="og:image" content="https://example.com/2023/03/10/protobuf/嵌套message.png">
<meta property="og:image" content="https://example.com/2023/03/10/protobuf/不带packed的repeated存储方式.png">
<meta property="og:image" content="https://example.com/2023/03/10/protobuf/带packed的repeated存储方式.png">
<meta property="article:published_time" content="2023-03-10T03:29:03.000Z">
<meta property="article:modified_time" content="2023-09-22T03:04:16.843Z">
<meta property="article:author" content="trluper">
<meta property="article:tag" content="protobuf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://example.com/2023/03/10/protobuf/protobuf的特点.png">

<link rel="canonical" href="https://example.com/2023/03/10/protobuf/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>protobuf | Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/03/10/protobuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          protobuf
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-10 11:29:03" itemprop="dateCreated datePublished" datetime="2023-03-10T11:29:03+08:00">2023-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-22 11:04:16" itemprop="dateModified" datetime="2023-09-22T11:04:16+08:00">2023-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/protobuf/" itemprop="url" rel="index"><span itemprop="name">protobuf</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="protobuf-概述">1 Protobuf 概述</h2>
<p>Protocol Buffer (简称Protobuf) 是Google出品的性能优异、跨语言、跨平台的序列化库。在网络通信和通用数据交换等应用场景中经常使用的技术是 <code>JSON</code>或 <code>XML</code>，在微服务架构中通常使用另外一个数据交换的协议的工具<strong>ProtoBuf</strong>。</p>
<p>ProtoBuf也是我们做微服务开发，进行Go进阶实战中，必知必会的知道点。</p>
<p><strong>ProtoBuf全称：</strong>protocol buffers，直译过来是：“协议缓冲区”，是一种与语言无关、与平台无关的可扩展机制，用于序列化结构化数据。</p>
<ul>
<li><strong>和<code>json\xml</code>最大的区别是：json，ProtoBuf是二进制格式。</strong></li>
<li><strong><code>ProtoBuf</code>相比于<code>json\XML</code>，更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。</strong></li>
<li><strong>我们只需要定义一次数据结构，就可以使用ProtoBuf生成源代码，轻松搞定在各种数据流和各种语言中写入、读取结构化数据。</strong></li>
</ul>
<span id="more"></span>
<p><strong>官方的发布日志中列举了 proto3 的改变：</strong></p>
<ul>
<li>移除了原始值字段的出现逻辑。</li>
<li>移除了required字段</li>
<li>移除了缺省值</li>
<li>移除了unknown字段 （3.5中又加上了）</li>
<li>移除了扩展，使用Any代替</li>
<li>修复了未知的枚举值的语义</li>
<li>添加了map类型</li>
<li>添加了一些标准类似，比如time、动态数据的呈现</li>
<li>可以使用 JSON 编码代替二进制 proto 编码</li>
</ul>
<blockquote>
<p>2001年初，Protobuf 首先在 Google 内部创建， 我们把它称之为 proto1，一直以来在 Google 的内部使用，其中也不断的演化，根据使用者的需求也添加很多新的功能，一些内部库依赖它。几乎每个 Google 的开发者都会使用到它。</p>
<p>Google 开始开源它的内部项目时，因为依赖的关系，所以他们决定首先把 Protobuf 开源出去。 proto1 在演化的过程中有些混乱，所以Protobuf 的开发者重写了 Protobuf 的实现，保留了 proto1 的大部分设计，以及 proto1 的很多的想法。但是开源的 proto2 不依赖任何的 Google 的库，代码也相当的清晰。2008年7月7日，Protobuf 开始公布出来。</p>
<p>Protobuf 公布出来也得到了大家的广泛的关注， 逐步地也得到了大家的认可，很多项目也采用 Protobuf 进行消息的通讯，还有基于 Protobuf 的微服务框架 GRPC。在使用的过程中，大家也提出了很多的意见和建议，Protobuf 也在演化，于 2016 年推出了 Proto3。 Proto3 简化了 proto2 的开发，提高了开发的效能，但是也带来了版本不兼容的问题。</p>
</blockquote>
<h2 id="protobuf环境配置">2 protobuf环境配置</h2>
<p>我们以ubuntu为例进行protobuf的环境安装。值得一提的是，目前机构培训和学习一般使用较旧的版本如<code>v2.5.0</code>版本。目前最新版本用<code>CMake</code>安装</p>
<h3 id="最新版本">最新版本</h3>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf" class="uri">https://github.com/protocolbuffers/protobuf</a></p>
<p>利用CMake安装：执行下面命令： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:protocolbuffers/protobuf.git</span><br><span class="line">#下载完成后，执行下述命令</span><br><span class="line">cmake . -Dprotobuf_BUILD_TESTS=OFF</span><br><span class="line">cmake --build . --parallel <span class="number">10</span></span><br><span class="line">#测试</span><br><span class="line">ctest --verbose</span><br><span class="line">#安装至user目录下</span><br><span class="line">sudo cmake --install .</span><br><span class="line"></span><br><span class="line">#用makefile测试安装也可</span><br><span class="line">make VERBOSE=<span class="number">1</span> test</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<p>出现错误1： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at cmake/gtest.cmake:<span class="number">7</span> (message):</span><br><span class="line">  Cannot find third_party/googletest directory that<span class="number">&#x27;</span>s needed to build tests.</span><br><span class="line">  If you use git, make sure you have cloned submodules:</span><br><span class="line"></span><br><span class="line">    git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line">  If instead you want to skip tests, run cmake with:</span><br><span class="line"></span><br><span class="line">    cmake -Dprotobuf_BUILD_TESTS=OFF</span><br><span class="line"></span><br><span class="line">Call <span class="built_in">Stack</span> (most recent call first):</span><br><span class="line">  CMakeLists.txt:<span class="number">291</span> (include)</span><br></pre></td></tr></table></figure> 解决方法，将<code>cmake .</code>更改为<code>cmake .  -Dprotobuf_BUILD_TESTS=OFF</code></p>
<p>出现错误2： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at third_party/utf8_range/CMakeLists.txt:<span class="number">31</span> (add_subdirectory):</span><br><span class="line">  The source directory</span><br><span class="line"></span><br><span class="line">    /home/project/protobuf/sourcecode/protobuf/third_party/abseil-cpp</span><br><span class="line"></span><br><span class="line">  does <span class="keyword">not</span> contain a CMakeLists.txt file.</span><br></pre></td></tr></table></figure> 解决方法：在third_party进行<code>git clone https://github.com/abseil/abseil-cpp.git</code></p>
<p>因为protobuf依赖第三方库abseil，我们cloe以后，要对其进行编译安装： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd absil-cpp</span><br><span class="line">makdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DABSL_BUILD_TESTING=ON -DABSL_USE_GOOGLETEST_HEAD=ON -DCMAKE_CXX_STANDARD=<span class="number">14</span> ..</span><br><span class="line">cmake --build . --target all</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<h3 id="版本安装">2.5.0版本安装</h3>
<p>下载v2.5.0版本的protobuf后，执行下述命令 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#安装必要的库</span><br><span class="line">apt-get install autoconf automake libtool curl make g++ unzip </span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<h2 id="安装go">3 安装go</h2>
<ul>
<li><strong>步骤1：先安装golang</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install golang-go</span><br></pre></td></tr></table></figure></li>
<li><p><strong>步骤2：</strong>将go的path添加进<code>~/.bashrc</code>，并进行<code>source ~/.bashrc</code>。可用<code>go env</code>查看go的路径 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> GOROOT=/opt/go</span><br><span class="line"><span class="keyword">export</span> GOPATH=~/GOPATH</span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$GOROOT/bin:$GOPATH</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>步骤3</strong>：安装<code>protoc-gen-go</code>:Protobuf 核心的工具集是 C++ 语言开发的，官方的 protoc 编译器中并不支持 Go 语言，需要安装一个插件才能生成 Go 代码。用如下命令安装： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure> 此命令会将 <code>protoc-gen-go</code> 可执行文件安装在<code>$GOROOT/bin</code>目录下,因此需要将其添加进PATH（步骤2）。当编译器调用时传递了--go_out 命令行标志时 <code>protoc</code> 就会使用该插件。<code>--go_out</code> 告诉编译器把 Go 源代码写到哪里。编译器会为每个 <code>.proto</code>文件生成一个单独的源代码文件。</p></li>
</ul>
<blockquote>
<p>如果出现<code>go: google.golang.org/protobuf/cmd/protoc-gen-go@latest: module google.golang.org/protobuf/cmd/protoc-gen-go: Get &quot;https://proxy.golang.org/google.golang.org/protobuf/cmd/protoc-gen-go/@v/list&quot;: dial tcp 172.217.160.81:443: i/o timeout</code>错误 可尝试设置Go代理重新安装 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https:<span class="comment">//goproxy.io,direct</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="protobuf是什么作用">4 protobuf是什么？作用？</h2>
<p><strong>Protocol Buffers（简称 Protobuf）是一种轻便高效的能够序列化结构数据的协议工具</strong>，可以用于结构化数据串的序列化。适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p>
<p>和<code>json\xml</code>最大的区别是json，ProtoBuf是经过编码压缩的二进制格式。 因此<code>ProtoBuf</code>相比于<code>json\XML</code>，其体积更小（3 ~ 10倍）、速度更快（20 ~ 100倍）、也更为简单。** <img src="/2023/03/10/protobuf/protobuf的特点.png" width="700"></p>
<h3 id="protocol-buffer-的序列化-和反序列化简单速度快的原因">Protocol Buffer 的序列化 和反序列化简单、速度快的原因</h3>
<ul>
<li>使用二进制的形式，比json用文本形式更接近计算机处理语言</li>
<li>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）。</li>
<li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成。</li>
</ul>
<h3 id="protocol-buffer-的数据压缩效果好即序列化后的数据量体积小的原因是">Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是</h3>
<ul>
<li><ol type="a">
<li>采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li>
</ol></li>
<li><ol start="2" type="a">
<li>采用 <code>T - L - V</code>的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li>
</ol></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/633656133">如果面试提到Protobuf，面试官问其原理怎么办？</a></p>
<h3 id="protobuf-2和3的区别">Protobuf 2和3的区别</h3>
<ol type="1">
<li>protoful文件的第一行需要指定您正在使用proto3语法：如果不这样做，protocol buffer编译器将假定使用的是proto2。这必须是文件的第一个非空、非注释行。</li>
<li>proto3取消了proto2的required，而proto3的singular就是proto2的optional。</li>
<li>proto3 repeated标量数值类型默认packed，而proto2默认不开启。</li>
<li>proto3增加了Kotlin，Ruby，Objective-C，C#，Dart的支持。</li>
<li>proto2可以选填default，而proto3只能使用系统默认的。（序列化后如果是默认值是不会占用空间的，对于proto2来说处理就很麻烦了）</li>
<li>proto3必须有一个零值，以便我们可以使用 0 作为数字默认值。零值需要是第一个元素，以便与proto2语义兼容，其中第一个枚举值始终是默认值。proto2则没有这项要求。</li>
<li>proto3在3.5版本之前会丢弃未知字段。但在 3.5 版本中，重新引入了未知字段的保留以匹配 proto2 行为。在 3.5 及更高版本中，未知字段在解析过程中保留并包含在序列化输出中。</li>
<li>proto3移除了proto2的扩展，新增了Any（仍在开发中）和JSON映射。</li>
</ol>
<h3 id="protobuf中每个字段后的序号作用">Protobuf中每个字段后的序号作用？</h3>
<p><strong>每个字段有唯一编号，在二进制流中标识该字段，可以看后面protobuf 编解码原理去了解字段的作用。</strong></p>
<blockquote>
<ul>
<li>消息被使用了，字段就不能改了，改了会造成数据错乱（常见坑)，服务器和客户端很多bug，是proto buffer 文件更改，未使用更改后的协议导致。</li>
<li>1 到 15 范围内的字段编号需要一个字节进行编码，编码结果将同时包含编号和类型</li>
<li>16 到 2047 范围内的字段编号占用两个字节。因此，非常频繁出现的 message 元素保留字段编号 1 到 15。</li>
<li>字段最小数字为1，最大字段数为2^29 - 1。（原因在编码原理那章讲解过，字段数字会作为key，key最后三位是类型）</li>
<li>19000 through 19999 (FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber这些数字不能用，这些是保留字段，如果使用会编译器会报错</li>
</ul>
</blockquote>
<h3 id="protobuf和json对比">protobuf和json对比</h3>
<p>可以从优缺点来对比protobuf和json，相较于json，protobuf具有优点：</p>
<ul>
<li>在性能上，其使用编码进行二进制数据流形式传输，压缩性好，能够一定程度上减小流量，从而节省网络带宽和省电。其序列化和烦序列化的速度要比json快2-100倍，传输的速度也更加快。</li>
<li>在便捷性上，使用较为简单，能够依靠protoc自动生成序列化和反序列化的目标代码；</li>
<li>维护成本低，只需要维护指定的<code>.protoc</code>文件即可，加密性较好，只有通过<code>proto</code>文件才能了解数据结构</li>
<li>兼容性较好，跨平台，能够支持各种主流语言。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>自解释性差：只有通过<code>proto</code>文件才能了解数据结构，这一点源于它的加密性好，才导致自解释性差。</li>
</ul>
<blockquote>
<p>一般来说，客户端与服务器用的是json，而服务器与服务器之间用protobuf，该策略的原因上面对比已经分析出来了：后端服务之间的RPC调用可能会传输大量数据，如果全部用纯文本的形式来表示数据那么不管是网络带宽还是性能可能都会差强人意，protobuf更适合。而客户端更多与人相关，使用对人较友好的json语句更为稳妥。</p>
</blockquote>
<h2 id="protobuf的序列化和反序列化原理">5 protobuf的序列化和反序列化原理</h2>
<p>protobuf之所以序列化和反序列化快，体积小，在于其采用了独特的编码，采用<code>T - L - V</code>的数据存储方式，减少了分隔符的使用，使得数据存储得紧凑。</p>
<p>在protobuf，其使用<strong>标识 - 长度 - 字段值</strong> 表示每个字段，所有字段拼接成一个 字节流，从而 实现 编码存储 的功能 <img src="/2023/03/10/protobuf/protobuf的存储方式.png" width="700"></p>
<ul>
<li>Tag: field_number &lt;&lt; 3 | wire type <img src="/2023/03/10/protobuf/wireType.png" width="700"></li>
<li>length:可选字段,目前只有类型2需要，例如字符串，length会存储字符串长度。</li>
<li>value：不同类型的value值会有不同的编码方式。下面对每种类型进行逐一讲解。</li>
</ul>
<h3 id="wiretype0时的编码方式">5.1 wireType=0时的编码方式</h3>
<p>采用了两种编码方式：<strong><code>Varint &amp; Zigzag</code></strong></p>
<h4 id="varint">varint</h4>
<ul>
<li><strong>Varint编码方式</strong>:一种变长的编码方式。将数据按7个bit为一组进行分组， 每分组前加1bit标示是否有下一组数据。依靠这种编码技术能够省去不必要的存储空间。 <img src="/2023/03/10/protobuf/varint.png" width="700"></li>
</ul>
<blockquote>
<p>这样就可以用更少的字节表示数字，达到压缩的目的。</p>
</blockquote>
<blockquote>
<ul>
<li>采用 Varint编码，对于很小的 int32 类型 数字，则可以用 1个字节来表示</li>
<li>虽然大的数字会需要 5 个 字节 来表示，但大多数情况下，消息都不会有很大的数字，所以采用 Varint方法总是可以用更少的字节数来表示数字</li>
</ul>
</blockquote>
<ul>
<li><strong>Varint解码方式</strong> <img src="/2023/03/10/protobuf/varint解码方式.png" width="700"></li>
</ul>
<h4 id="zigzag">Zigzag</h4>
<p>Varint 编码方式的不足是如果采用 Varint编码方式 表示一个<strong>负数</strong>，那么一定需要 5 个 byte。<strong>因为最高位bit是1</strong>。例如int32类型 -1: <code>100000000    00000000   00000000 00000001</code>，使用varint编码<code>ceil(4*8/7) =  5</code></p>
<p><strong>protobuf会先采用 Zigzag 编码，再采用 Varint编码</strong>，Zigzag的原理是<strong>使用 无符号数 来表示 有符号数字；</strong></p>
<ul>
<li>Zigzag 编码 是补充 Varint编码在 表示负数 的不足，从而更好的帮助 Protocol Buffer进行数据的压缩</li>
<li>所以，<strong>如果提前预知字段值是可能取负数的时候，记得采用sint32 / sint64 数据类型</strong></li>
</ul>
<h3 id="wiretype2时的编码方式">5.2 wireType=2时的编码方式</h3>
<p>wireType=2时的编码方式，采用<code>T-L-V</code>的格式存储。这里，我们主要讲解常用的讲解三种数据类型的Value：</p>
<ul>
<li>String类型</li>
<li>嵌套消息类型（Message）</li>
<li>通过packed修饰的 repeat 字段（即packed repeated fields）</li>
</ul>
<h4 id="string类型">String类型</h4>
<p>字段值（即V） 采用UTF-8编码 <img src="/2023/03/10/protobuf/string类型的value.png" width="700"> <img src="/2023/03/10/protobuf/string类型的value存储方式.png" width="700"></p>
<h4 id="嵌套消息类型message">嵌套消息类型（Message）</h4>
<p>即字面意思<strong>内部消息编码的T - L -V组成外部消息的v</strong> <img src="/2023/03/10/protobuf/嵌套message.png" width="700"></p>
<h4 id="通过packed修饰的-repeat-字段">通过packed修饰的 repeat 字段</h4>
<p>repeated 修饰的字段有两种表达方式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">message Test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 表达方式1：不带packed=true</span></span><br><span class="line">    repeated int32 Car = <span class="number">4</span> ;</span><br><span class="line">    <span class="comment">// 表达方式2：带packed=true,proto 2.1 开始可使用</span></span><br><span class="line">    repeated int32 Car = <span class="number">4</span> [packed=<span class="literal">true</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在代码中给`repeated int32 Car`附上3个字段值：3、270、86942</span></span><br><span class="line">Test.setCar（<span class="number">3</span>）；</span><br><span class="line">Test.setCar（<span class="number">270</span>）；</span><br><span class="line">Test.setCar（<span class="number">86942</span>）；</span><br></pre></td></tr></table></figure> <img src="/2023/03/10/protobuf/不带packed的repeated存储方式.png" width="700"></p>
<ul>
<li><p><strong>问题：</strong>对于同一个 repeated字段、多个字段值来说，他们的Tag都是相同的，会导致Tag的冗余，即相同的Tag存储多次；</p></li>
<li><p>解决方案：采用带packed=true 的 repeated 字段存储方式，即将相同的 Tag 只存储一次、记一个长度Length字段 ：Tag - Length - Value -Value -Value。 <img src="/2023/03/10/protobuf/带packed的repeated存储方式.png" width="700"></p></li>
</ul>
<p>通过采用带<code>packed=true</code> 的 <code>repeated</code> 字段存储方式，从而更好地压缩序列化后的数据长度。</p>
<blockquote>
<p><strong>特别注意</strong> packed修饰只用于基本类型的repeated字段 用在其他字段，编译 .proto 文件时会报错</p>
</blockquote>
<h3 id="总结">总结</h3>
<ul>
<li>protobuf编码/解码 方式简单，只需要简单的数学运算、位移等，序列化 &amp; 反序列化速度很快</li>
<li>protobuf采用了独特的编码方式，如Varint、Zigzag编码方式等等，采用T - L - V 的数据存储方式，数据存储得紧凑，数据压缩效果好</li>
</ul>
<p><strong>使用建议</strong> 根据上面的序列化原理分析，有以下使用建议：</p>
<ul>
<li><p>建议1：字段标识号（Field_Number）尽量只使用 1-15，且不要跳动使用 因为Tag里的Field_Number是需要占字节空间的。如果Field_Number&gt;16时，Field_Number的编码就会占用2个字节，那么Tag在编码时也就会占用更多的字节；如果将字段标识号定义为连续递增的数值，将获得更好的编码和解码性能</p></li>
<li><p>建议2：若需要使用的字段值出现负数，请使用 sint32 / sint64，不要使用int32 / int64 因为采用sint32 / sint64数据类型表示负数时，会先采用Zigzag编码再采用Varint编码，从而更加有效压缩数据</p></li>
<li><p>建议3：对于repeated字段，尽量增加packed=true修饰 因为加了packed=true修饰repeated字段采用连续数据存储方式，即T - L - V - V -V方式</p></li>
</ul>
<h2 id="protobuf语法">6 protobuf语法</h2>
<h3 id="定义一个消息类型">定义一个消息类型</h3>
<p>假设现在要定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的 .proto 文件了： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">package Request;</span><br><span class="line">option go_package=<span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query = <span class="number">1</span>;</span><br><span class="line">    int32 page_number = <span class="number">2</span>;</span><br><span class="line">    int32 result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - syntax：是必须写的，而且要定义在第一行；目前proto3是主流，不写默认使用proto2 - package：定义我们proto文件的包名 - option go_package：定义生成的pb.go的包名，我们通常在proto文件中定义。如果不在proto文件中定义，也可以在使用protoc生成代码时指定pb.go文件的包名 - message：非常重要，用于定义消息结构体，不用着急，下文会重点讲解</p>
<h3 id="分配标识号">分配标识号</h3>
<p>可以看到消息定义的每个字段都有一个唯一的数字标识符。<strong>这个标识符用于在消息的二进制格式中标识字段, 一旦消息类型被使用后不可以再修改。</strong></p>
<p>注意标识符的值在 <strong>1 和 15 之间时，编码只需一个字节</strong>。标识符 在16 到 2047 之间将占用两个字节<strong>。因此应该将从 1 到 15 的标识符分派给最频繁出现的消息元素</strong>。记得保留一些空间给未来可能添加的频繁出现的元素。</p>
<p>最小的标识号可以从 1 开始，最大到 <span class="math inline">\(2^{29} - 1\)</span>（536,870,911）,另外<code>19000 到 19999(FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber)</code>不能使用，Protobuf协议实现中对这些进行了预留。</p>
<h3 id="指定字段规则">指定字段规则</h3>
<p>消息字段有以下两种属性：</p>
<ul>
<li><strong><code>singular</code></strong>：一个格式良好的消息应该有 0 个或者 1 个这种字段（但是不能超过 1 个）。（没有使用 repeated 默认属于这种属性）</li>
<li><strong><code>repeated</code>(数组形式）</strong>：在一个格式良好的消息中，这种字段可以重复任意多次（包括 0 次）。重复的值的顺序会被保留。（<strong>在 go 里面会被转化为数组</strong>）</li>
</ul>
<p>在 proto3 中，<code>repeated</code> 的标量域默认情况下会使用<code>packed</code> 编码(见上编码原理)</p>
<h3 id="定义多个消息类型">定义多个消息类型</h3>
<p>在一个 .proto 文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与 SearchResponse消息类型对应的回复消息格式的话，可以将它添加到相同的 .proto 文件中，如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  string query = <span class="number">1</span>;</span><br><span class="line">  int32 page_number = <span class="number">2</span>;</span><br><span class="line">  int32 result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchResponse &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="添加注释">添加注释</h3>
<p>向 .proto 文件添加注释，可以使用 C/C++/Java 风格的双斜杠（//） 语法格式，如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  string query = <span class="number">1</span>;</span><br><span class="line">  int32 page_number = <span class="number">2</span>;  <span class="comment">// Which page number do we want?</span></span><br><span class="line">  int32 result_per_page = <span class="number">3</span>;  <span class="comment">// Number of results to return per page.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="保留标识符reserved">保留标识符（Reserved）</h3>
<p>当更新消息类型，需要彻底删除或者注释掉一个字段时，以后的用户在更新这个类型的时候可以重用这些标识号。如果他们后来使用同一个文件的旧版本加载，会导致严重的问题，包括数据损坏、隐私错误等等。现在有一种确保不会发生这种情况的方法就是为字段 tag（reserved name 可能会 JSON 序列化的问题）指定 reserved 标识符，protocol buffer 的编译器会警告未来尝试使用这些域标识符的用户。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>;</span><br><span class="line">  reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong><em>注：不要在同一行 reserved 声明中同时声明名字和标签数字。</em></strong></p>
<h3 id="从-.proto-生成的文件">从 .proto 生成的文件</h3>
<p>当用 protocol buffer 编译器来运行 .proto 文件时,即<code>protoc **.proto --*_out=&quot;.&quot;</code>，编译器将选择的编程语言，生成相应的代码，这些代码可以操作在 .proto 文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>
<ul>
<li>对 C++ 来说，编译器会为每个 .proto 文件生成一个 .h 文件和一个 .cc 文件，.proto 文件中的每一个消息有一个对应的类。</li>
<li>对 Java 来说，编译器为每一个消息类型生成了一个 .java 文件，以及一个特殊的 Builder 类（该类是用来创建消息类接口的）。</li>
<li>对 Python 来说，有点不太一样——Python 编译器为 .proto 文件中的每个消息类型生成一个含有静态描述符的模块，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的 Python 数据访问类。</li>
<li>对 Go 来说，编译器会位每个消息类型生成了一个 .pd.go 文件。</li>
<li>对于 Ruby 来说，编译器会为每个消息类型生成了一个 .rb 文件。</li>
<li>对 javaNano 来说，编译器输出类似于 java 但是没有 Builder 类</li>
<li>对于 Objective-C 来说，编译器会为每个消息类型生成了一个 pbobjc.h 文件和 pbobjcm 文件，.proto 文件中的每一个消息有一个对应的类。</li>
<li>对于 C# 来说，编译器会为每个消息类型生成了一个 .cs 文件，.proto 文件中的每一个消息有一个对应的类。</li>
</ul>
<h2 id="protobuf的字段类型与编程语言的对应">7 protobuf的字段类型与编程语言的对应</h2>
<p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>
<table style="width:83%;">
<colgroup>
<col style="width: 5%">
<col style="width: 33%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 9%">
<col style="width: 5%">
<col style="width: 6%">
</colgroup>
<thead>
<tr class="header">
<th>.proto</th>
<th>使用技巧</th>
<th>C++</th>
<th>Java</th>
<th>Python</th>
<th>Go</th>
<th>Ruby</th>
<th>C#</th>
<th>PHP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>float64</td>
<td>Float</td>
<td>double</td>
<td>float</td>
</tr>
<tr class="even">
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>Float</td>
<td>float</td>
<td>float</td>
</tr>
<tr class="odd">
<td>int32</td>
<td>使用变长编码，对于负值的效率很低，如果值有可能有负值，使用sint32替代</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr class="even">
<td>int64</td>
<td>使用变长编码，对于负值的效率很低，如果值有可能有负值，使用sint64替代</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string</td>
</tr>
<tr class="odd">
<td>uint32</td>
<td>使用变长编码</td>
<td>uint32</td>
<td>int</td>
<td>int/long</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>uint</td>
<td>integer</td>
</tr>
<tr class="even">
<td>uint64</td>
<td>使用变长编码</td>
<td>uint64</td>
<td>long</td>
<td>int/long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer/string</td>
</tr>
<tr class="odd">
<td>sint32</td>
<td>使用变长编码，这些编码在负值时比int32高效的多</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr class="even">
<td>sint64</td>
<td>使用变长编码，有符号的整型值。编码时比通常的int64高效。</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string</td>
</tr>
<tr class="odd">
<td>fixed32</td>
<td>总是4个字节，如果数值总是比228大的话，这个类型会比uint32高效。</td>
<td>uint32</td>
<td>int</td>
<td>int</td>
<td>uint32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>uint</td>
<td>integer</td>
</tr>
<tr class="even">
<td>fixed64</td>
<td>总是8个字节，如果数值总是比256大的话，这个类型会比uint64高效。</td>
<td>uint64</td>
<td>long</td>
<td>int/long</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer/string</td>
</tr>
<tr class="odd">
<td>sfixed32</td>
<td>总是4个字节</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum 或者 Bignum（根据需要）</td>
<td>int</td>
<td>integer</td>
</tr>
<tr class="even">
<td>sfixed64</td>
<td>总是8个字节</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string</td>
</tr>
<tr class="odd">
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>bool</td>
<td>TrueClass/FalseClass</td>
<td>bool</td>
<td>boolean</td>
</tr>
<tr class="even">
<td>string</td>
<td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td>
<td>string</td>
<td>String</td>
<td></td>
<td>str/unicode</td>
<td>string</td>
<td>String (UTF-8)</td>
<td>string</td>
</tr>
<tr class="odd">
<td>bytes</td>
<td>可能包含任意顺序的字节数据。</td>
<td>string</td>
<td>ByteString</td>
<td>str</td>
<td>[]byte</td>
<td>String (ASCII-8BIT)</td>
<td>ByteString</td>
<td>string</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>在 java 中，无符号 32 位和 64 位整型被表示成他们的整型对应形式，最高位被储存在标志位中。</li>
<li>对于所有的情况，设定值会执行类型检查以确保此值是有效。</li>
<li>64 位或者无符号 32 位整型在解码时被表示成为 long，但是在设置时可以使用int型值设定，在所有的情况下，值必须符合其设置其类型的要求。</li>
<li>python中 string 被表示成在解码时表示成 unicode。但是一个 ASCII string 可以被表示成 str 类型。</li>
<li>Integer 在 64 位的机器上使用，string 在 32 位机器上使用</li>
</ol>
<h2 id="默认值">8 默认值</h2>
<p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的简单元素，被解析的对象所对应的字段被设置为默认值，对于不同类型指定如下：</p>
<ul>
<li>对于string，默认是一个空 string</li>
<li>对于bytes，默认是一个空的 bytes</li>
<li>对于 bool，默认是 false</li>
<li>对于数值类型，默认是 0</li>
<li>对于枚举，默认是第一个定义的枚举值，必须为 0;</li>
<li>对于消息类型（message），如果没有被设置，确切的消息是根据语言确定的。</li>
</ul>
<p>对于可重复的字段，默认值是空（通常情况下是对应语言中空数组）。</p>
<blockquote>
<p>对于简单字段，一旦消息被解析，就无法判断这个字段时有设置值但是恰巧是默认值，还是根本没有被设置（例如 boolean 值是否被设置为 false）。另外，如果一个简单消息字段被设置为默认值，这个值不会被序列化传输。</p>
</blockquote>
<h2 id="更新一个消息类型">9 更新一个消息类型</h2>
<p>如果一个已有的消息格式已无法满足新的需求。<strong>例如，要在消息中添加一个额外的字段，但是同时旧版本写的代码仍然可用。不用担心，更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可：</strong></p>
<ul>
<li><p><strong>不要更改任何已有的字段的数值标识。</strong></p></li>
<li><p>如果增加新的字段，使用旧格式的字段仍然可以被新产生的代码所解析。应该记住这些元素的默认值，这样新代码就可以以适当的方式和旧代码生成的数据交互。<strong>相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉</strong>。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和 proto2 中的行为是不同的，在 proto2 中未定义的域依然会随着消息被序列化）</p></li>
<li><p><strong>非 required 的字段可以移除，只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的 .proto 文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</strong></p></li>
<li><p>int32, uint32, int64, uint64, 和 bool 是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在 C++ 中对它进行了强制类型转换一样（例如，如果把一个 64 位数字当作 int32 来读取，那么它就会被截断为 32 位的数字）。</p></li>
<li><p>sint32 和 sint64 是互相兼容的，但是它们与其他整数类型不兼容。</p></li>
<li><p>string 和 bytes 是兼容的（只要 bytes 是有效的 UTF-8 编码）。</p></li>
<li><p>嵌套消息与 bytes 是兼容的（只要 bytes 包含该消息的一个编码过的版本）。</p></li>
<li><p>fixed32 与 sfixed32 是兼容的，fixed64 与 sfixed64 是兼容的。</p></li>
<li><p>枚举类型与 int32，uint32，int64 和 uint64 相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的 proto3 枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int 类型的字段总会被保留。</p></li>
</ul>
<h2 id="字段类型">10 字段类型</h2>
<p>处理上面提到的一些基础类型以外，protobuf还支持一些其他结构类型。</p>
<h3 id="枚举">枚举</h3>
<p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个 SearchRequest 消息添加一个 corpus 字段，而 corpus 的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS 或 VIDEO 中的一个。 这时通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。</p>
<p>在下面的例子中，在消息格式中添加了一个叫做SexType 的枚举类型——它含有所有可能的值 ——以及一个类型为 SexType 的字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;<span class="comment">//指定版本信息，非注释的第一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SexType</span> <span class="comment">//枚举消息类型，使用enum关键词定义,一个性别类型的枚举类型</span></span><br><span class="line">&#123;</span><br><span class="line">    UNKONW = <span class="number">0</span>; <span class="comment">//proto3版本中，首成员必须为0，成员不应有相同的值</span></span><br><span class="line">    MALE = <span class="number">1</span>;  <span class="comment">//1男</span></span><br><span class="line">    FEMALE = <span class="number">2</span>; <span class="comment">//2女  0未知</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个用户消息</span></span><br><span class="line">message UserInfo</span><br><span class="line">&#123;</span><br><span class="line">    string name = <span class="number">1</span>; <span class="comment">// 姓名字段</span></span><br><span class="line">    SexType sex = <span class="number">2</span>; <span class="comment">// 性别字段，使用SexType枚举类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SexType 枚举的第一个常量映射为 0：每个枚举类型必须将其第一个类型映射为0，这是因为：</p>
<ul>
<li>必须有一个 0 值，可以用这个 0 值作为默认值。</li>
<li>这个零值必须为第一个元素，为了兼容 proto2 语义，枚举类的第一个值总是默认值。</li>
</ul>
<p><strong>可以通过将相同值赋值给不同的枚举常量来定义别名. 为此需要设置<code>allow_alias</code>选项为true</strong>, 否则当发现别名时protocol编译器会生成错误消息。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumAllowingAlias</span> &#123;</span><br><span class="line">  option allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 此时 RUNNING 是 STATRTED 的别名</span></span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumNotAllowingAlias</span> &#123;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 枚举常量必须在 32 位整型值的范围内。因为 enum 值是使用可变编码方式的，对负数不够高效，因此不推荐在 enum 中使用负数。</p>
<p>如上例所示，可以外部声明枚举类型，然后message内定义一个枚举类型；当然，<strong>也可以在message中声明枚举类型然后定义。</strong></p>
<p>当对一个使用了枚举的 .proto 文件运行 protocol buffer 编译器的时候，生成的代码中将有一个对应的 enum（对Java或C++来说）</p>
<blockquote>
<p>Go不直接支持枚举的，并没有<code>enum</code>关键字</p>
</blockquote>
<h3 id="自定义类型">自定义类型</h3>
<p>可以将其他消息类型用作自定义的字段类型。例如，假设在每一个 <code>SearchResponse</code> 消息中包含 <code>Result</code> 消息，此时可以在相同的 <code>.proto</code>文件中定义一个<code>Result</code> 消息类型，然后在<code>SearchResponse</code> 消息中指定一个 <code>Result</code>类型的字段，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">essage SearchResponse &#123;</span><br><span class="line">  repeated Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Result &#123;</span><br><span class="line">  string url = <span class="number">1</span>;</span><br><span class="line">  string title = <span class="number">2</span>;</span><br><span class="line">  repeated string snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="导入其他文件中的类型">导入其他文件中的类型</h4>
<p>如果是希望导入其他 .proto 文件中的类型定义，可以在文件中添加一个导入声明： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在this.proto导入other_protos.proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;myproject/other_protos.proto&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>这种导入方式存在一个问题：</strong><code>this.proto</code>只能通过<strong><code>包名.消息或类型名称</code></strong>访问<code>other_protos.proto</code>中定义的消息或类型。无法访问在<code>other_protos.proto</code>内<code>import</code>的其他<code>proto</code>文件里定义的消息或类型，即：只能访问直接import的proto文件里的类型或消息；</p></li>
<li><p><strong>解决方法</strong>：通过<code>import public</code>可解决。即如果在<code>other_protos.proto</code>内使用<code>import public</code>关键字导入其他<code>proto</code>文件，那么在导入<code>other_protos.proto</code>的<code>proto</code>文件中可以访问其他<code>proto</code>文件。这种方式就想是将<code>proto</code>文件移到<code>other_protos.proto</code>一样</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new.proto文件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old.proto文件</span></span><br><span class="line"><span class="comment">// 通过import public导入new.proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">public</span> <span class="string">&quot;new.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;other.proto&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端 proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;old.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 现在你可以使用new.protoc和old.protoc两种包的proto定义了。</span></span><br></pre></td></tr></table></figure>
<p>通过在编译器命令行参数中使用 -I/--proto_pathprotocal 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常只要指定 proto_path 标志为工程根目录，并且指定好导入的正确名称就好。</p>
<h4 id="使用-proto2-的消息类型">使用 proto2 的消息类型</h4>
<p>导入 proto2 的消息类型并在 proto3 消息中使用是可以的，反之也如此。但是，proto2 的枚举不能在 proto3 语法中使用</p>
<h3 id="any">Any</h3>
<p>Protobuf中的Any类型可以理解为泛型类型，它可以存储任何消息类型的字段（int, char等类型必须先封装成消息类型）。Any类型字段也可以用<code>Repeated</code> 修饰。为了使用Any类型，你需要导入import google/protobuf/any.proto。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">  string message = <span class="number">1</span>;</span><br><span class="line">  repeated google.protobuf.Any details = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于给定的消息类型的默认类型 URL 是 type.googleapis.com/packagename.messagename。</p>
<p>不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装 Any 值。例如在 java 中，Any类型会有特殊的 pack() 和 unpack() 访问器，在C++中会有 <code>PackFrom()</code> 和 <code>UnpackTo()</code> 方法。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Storing an arbitrary message type in Any.</span></span><br><span class="line">NetworkErrorDetails details = ...;</span><br><span class="line">ErrorStatus status;</span><br><span class="line">status.<span class="built_in">add_details</span>()-&gt;<span class="built_in">PackFrom</span>(details);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reading an arbitrary message from Any.</span></span><br><span class="line">ErrorStatus status = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> Any&amp; detail : status.<span class="built_in">details</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (detail.<span class="built_in">Is</span>&lt;NetworkErrorDetails&gt;()) &#123;</span><br><span class="line">    NetworkErrorDetails network_error;</span><br><span class="line">    detail.<span class="built_in">UnpackTo</span>(&amp;network_error);</span><br><span class="line">    ... processing network_error ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 目前，用于Any类型的动态库仍在开发之中</p>
<h3 id="oneof">Oneof</h3>
<p><strong>如果消息中有很多可选字段，并且同时至多一个字段会被设置， 可以通过使用 Oneof 特性来强化这个行为并节省内存。</strong></p>
<p>Oneof 字段就像可选字段， 除了它们会共享内存，并且同一时间最多一个字段会被设置。 设置其中一个字段会清除其它字段。 可以使用 <code>case()</code> 或者 <code>WhichOneof()</code> 方法检查哪个 <code>oneof</code> 字段被设置，这取决于使用什么编程语言。</p>
<p>因为 <code>proto3</code>没有办法区分正常的值是否是设置了还是取得缺省值(比如 int64 类型字段，如果它的值是 0，无法判断数据是否包含这个字段，因为 0 既可能是数据中设置的值，也可能是这个字段的零值)，所以可以通过 <code>Oneof</code> 取得这个功能，因为 <code>Oneof</code> 有判断字段是否设置的功能。</p>
<h4 id="使用-oneof">使用 Oneof</h4>
<p>为了在 . proto 定义 Oneof 字段， 需要在名字前面加上 <code>oneof</code> 关键字, 比如下面例子的 <code>test_oneof:</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message SampleMessage &#123;</span><br><span class="line">  oneof test_oneof &#123;</span><br><span class="line">    string name = <span class="number">4</span>;</span><br><span class="line">    SubMessage sub_message = <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后再将<code>oneof</code> 字段定义到<code>test_oneof</code> 中。<strong>可以增加任意类型的字段，但是不能使用<code>repeated</code>关键字。 </strong> 在产生的代码中, oneof 字段拥有同样的 <code>getters</code>和<code>setters</code>， 就像正常的可选字段一样，也有一个特殊的方法来检查到底哪个字段被设置。</p>
<h4 id="oneof-特性">Oneof 特性</h4>
<ul>
<li>设置 oneof 会自动清除其它 oneof 字段的值。所以设置多次后，只有最后一次设置的字段有值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">CHECK</span>(message.<span class="built_in">has_name</span>());</span><br><span class="line">message.<span class="built_in">mutable_sub_message</span>();   <span class="comment">// Will clear name field.</span></span><br><span class="line"><span class="built_in">CHECK</span>(!message.<span class="built_in">has_name</span>());</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">- 如果解析器遇到同一个 oneof 中有多个成员，只有看到的最后一个成员会被解析成消息。</span><br><span class="line">- oneof 不支持 repeated.</span><br><span class="line">- 反射 API 对 oneof 字段有效.</span><br><span class="line">- 如果使用 C++，需确保代码不会导致内存泄漏。下面的代码会崩溃， 因为 sub_message 已经通过 <span class="built_in">set_name</span>() 删除了</span><br><span class="line">```cpp</span><br><span class="line">SampleMessage message;</span><br><span class="line">SubMessage* sub_message = message.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);      <span class="comment">// Will delete sub_message</span></span><br><span class="line">sub_message-&gt;set_...            <span class="comment">// Crashes here</span></span><br></pre></td></tr></table></figure></li>
<li>在 C++ 中，如果使用 Swap() 来交换两个带有 oneof 的消息，每个消息将会有另一个消息的 oneof，例如在下面的例子中，msg1 会拥有sub_message 并且 msg2 会有 name。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage msg1;</span><br><span class="line">msg1.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">SampleMessage msg2;</span><br><span class="line">msg2.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">msg1.<span class="built_in">swap</span>(&amp;msg2);</span><br><span class="line"><span class="built_in">CHECK</span>(msg1.<span class="built_in">has_sub_message</span>());</span><br><span class="line"><span class="built_in">CHECK</span>(msg2.<span class="built_in">has_name</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="向后兼容性问题">向后兼容性问题</h4>
<p>当增加或者删除 oneof 字段时一定要小心。如果检查 oneof 的值返回 None/NOT_SET，它意味着 oneof 字段没有被赋值或者在一个不同的版本中赋值了。 没有办法知道是哪种情况，因为没有办法判断一个未知字段是否是 oneof 的成员。</p>
<h4 id="tag-重用问题">Tag 重用问题</h4>
<p>将字段移入或移除oneof：在消息被序列号或者解析后，可能会失去一些信息（有些字段也许会被清除） 删除一个字段或者加入一个字段：在消息被序列号或者解析后，这也许会清除现在设置的 oneof 字段 分离或者融合oneof：和移动普通字段一样有类似问题。</p>
<h3 id="map">Map</h3>
<p>如果希望创建一个关联映射，protocol buffer 提供了一种快捷的语法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure> - 其中 key_type 可以是任意 Integer 或者 string 类型（所以，除了 floating 和 bytes 的任意简单类型都是可以的）。</p>
<ul>
<li>value_type 可以是任意类型。</li>
</ul>
<p>例如，如果希望创建一个 project 的映射，每个 Projecct 使用一个 string 作为 key，可以像下面这样定义： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, Project&gt; projects = <span class="number">3</span>;</span><br></pre></td></tr></table></figure> - Map 的字段不可以是 repeated。 - 序列化后的顺序和 map 迭代器的顺序是不确定的，所以不要期望以固定顺序处理 Map。 - 当为 .proto 文件产生生成文本格式的时候，map 会按照 key 的顺序排序，数值化的 key 会按照数值排序。 - 从序列化中解析或者融合时，如果有重复的 key 则后一个 key 不会被使用，当从文本格式中解析 map 时，如果存在重复的 key，则可能会导致解析失败。 - 如果为映射字段提供键但没有值，则序列化字段时的行为取决于语言。在 C ++，Java 和 Python 中，该类型的默认值已序列化，而在其他语言中，则没有序列化。</p>
<h4 id="向后兼容性问题-1">向后兼容性问题</h4>
<p>map语法序列化后等同于如下内容，因此即使是不支持 map 语法的protocol buffer 实现也是可以处理数据的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message MapFieldEntry &#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeated MapFieldEntry map_field = N  </span><br></pre></td></tr></table></figure></p>
<h3 id="定义服务service">定义服务(Service)</h3>
<p>如果想要将消息类型用在 RPC (远程方法调用)系统中，可以在 .proto 文件中定义一个 RPC 服务接口，protocol buffer 编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个 RPC 服务并具有一个方法，该方法能够接收 SearchRequest 并返回一个 SearchResponse，此时可以在 .proto 文件中进行如下定义： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service SearchService &#123;</span><br><span class="line">  <span class="function">rpc <span class="title">Search</span> <span class="params">(SearchRequest)</span> <span class="title">returns</span> <span class="params">(SearchResponse)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 最直观的使用 protocol buffer 的 RPC 系统是 Go 的 RPC 框架 gRPC，一个由谷歌开发的语言和平台中的开源的 PRC 系统，gRPC 在使用 protocl buffer 时非常有效，如果使用特殊的 protocol buffer 插件可以直接从 .proto 文件中产生相关的RPC代码。</p>
<p>如果不想使用 gRPC，也可以使用 protocol buffer 用于自己的 RPC 实现。</p>
<h2 id="实例">11 实例</h2>
<p>文章参考来源：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangdanyangtc/article/details/126480389">protobuf序列化和反序列化原理</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/633656133">如果面试提到Protobuf，面试官问其原理怎么办？</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7164261080678531108">IM通讯协议专题学习(一)：Protobuf从入门到精通，一篇就够！</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7144948875613339685">【Go微服务】一文带你玩转ProtoBuf</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaoming.net.cn/2020/11/27/Protobuf%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/#%E5%9C%A8-Go-%E4%B8%AD%E4%BD%BF%E7%94%A8-protobuf">Protobuf</a></p>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="trluper 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="trluper 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/protobuf/" rel="tag"># protobuf</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/07/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="prev" title="lambda表达式">
      <i class="fa fa-chevron-left"></i> lambda表达式
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/10/Msys2/" rel="next" title="Msys2">
      Msys2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#protobuf-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1 Protobuf 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protobuf%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">2.</span> <span class="nav-text">2 protobuf环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC"><span class="nav-number">2.1.</span> <span class="nav-text">最新版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85"><span class="nav-number">2.2.</span> <span class="nav-text">2.5.0版本安装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85go"><span class="nav-number">3.</span> <span class="nav-text">3 安装go</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protobuf%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">4 protobuf是什么？作用？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#protocol-buffer-%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96-%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E9%80%9F%E5%BA%A6%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">4.1.</span> <span class="nav-text">Protocol Buffer 的序列化 和反序列化简单、速度快的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protocol-buffer-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E6%95%88%E6%9E%9C%E5%A5%BD%E5%8D%B3%E5%BA%8F%E5%88%97%E5%8C%96%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F%E4%BD%93%E7%A7%AF%E5%B0%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF"><span class="nav-number">4.2.</span> <span class="nav-text">Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protobuf-2%E5%92%8C3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.</span> <span class="nav-text">Protobuf 2和3的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protobuf%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AE%B5%E5%90%8E%E7%9A%84%E5%BA%8F%E5%8F%B7%E4%BD%9C%E7%94%A8"><span class="nav-number">4.4.</span> <span class="nav-text">Protobuf中每个字段后的序号作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protobuf%E5%92%8Cjson%E5%AF%B9%E6%AF%94"><span class="nav-number">4.5.</span> <span class="nav-text">protobuf和json对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protobuf%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">5 protobuf的序列化和反序列化原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wiretype0%E6%97%B6%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 wireType&#x3D;0时的编码方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#varint"><span class="nav-number">5.1.1.</span> <span class="nav-text">varint</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zigzag"><span class="nav-number">5.1.2.</span> <span class="nav-text">Zigzag</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wiretype2%E6%97%B6%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 wireType&#x3D;2时的编码方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.1.</span> <span class="nav-text">String类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8Bmessage"><span class="nav-number">5.2.2.</span> <span class="nav-text">嵌套消息类型（Message）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87packed%E4%BF%AE%E9%A5%B0%E7%9A%84-repeat-%E5%AD%97%E6%AE%B5"><span class="nav-number">5.2.3.</span> <span class="nav-text">通过packed修饰的 repeat 字段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protobuf%E8%AF%AD%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">6 protobuf语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.1.</span> <span class="nav-text">定义一个消息类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%A0%87%E8%AF%86%E5%8F%B7"><span class="nav-number">6.2.</span> <span class="nav-text">分配标识号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E8%A7%84%E5%88%99"><span class="nav-number">6.3.</span> <span class="nav-text">指定字段规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.4.</span> <span class="nav-text">定义多个消息类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A"><span class="nav-number">6.5.</span> <span class="nav-text">添加注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E7%95%99%E6%A0%87%E8%AF%86%E7%AC%A6reserved"><span class="nav-number">6.6.</span> <span class="nav-text">保留标识符（Reserved）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E-.proto-%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.7.</span> <span class="nav-text">从 .proto 生成的文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protobuf%E7%9A%84%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AF%B9%E5%BA%94"><span class="nav-number">7.</span> <span class="nav-text">7 protobuf的字段类型与编程语言的对应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">8.</span> <span class="nav-text">8 默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.</span> <span class="nav-text">9 更新一个消息类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">10 字段类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">10.1.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.2.</span> <span class="nav-text">自定义类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.2.1.</span> <span class="nav-text">导入其他文件中的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-proto2-%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.2.2.</span> <span class="nav-text">使用 proto2 的消息类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#any"><span class="nav-number">10.3.</span> <span class="nav-text">Any</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#oneof"><span class="nav-number">10.4.</span> <span class="nav-text">Oneof</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-oneof"><span class="nav-number">10.4.1.</span> <span class="nav-text">使用 Oneof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#oneof-%E7%89%B9%E6%80%A7"><span class="nav-number">10.4.2.</span> <span class="nav-text">Oneof 特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">10.4.3.</span> <span class="nav-text">向后兼容性问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tag-%E9%87%8D%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-number">10.4.4.</span> <span class="nav-text">Tag 重用问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">10.5.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98-1"><span class="nav-number">10.5.1.</span> <span class="nav-text">向后兼容性问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1service"><span class="nav-number">10.6.</span> <span class="nav-text">定义服务(Service)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">11.</span> <span class="nav-text">11 实例</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:03</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
      <script type="text/javascript">
      function renderGitalk(){
        var gitalk = new Gitalk({
            owner: '',
            repo: '',
            clientID: '123fe329fdbb06b0f1d1',
            clientSecret: '40add829107b6e69f43274d3545ae71c988de8eb',
            admin: '',
            
            });
        gitalk.render('gitalk-container');
      }
      renderGitalk();
      </script>
    
 


<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>