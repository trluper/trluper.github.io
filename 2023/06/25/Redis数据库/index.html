<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. Redis数据类型 Redis提供了String,Hash,List,Set,Zset五种数据类型。 String String数据结构是最简单的key-value类型，value不仅可以是String,也可以是数字，包括整数，浮点数和二进制数。 string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis数据库">
<meta property="og:url" content="https://example.com/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:description" content="1. Redis数据类型 Redis提供了String,Hash,List,Set,Zset五种数据类型。 String String数据结构是最简单的key-value类型，value不仅可以是String,也可以是数字，包括整数，浮点数和二进制数。 string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://example.com/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis事件处理器.png">
<meta property="og:image" content="https://example.com/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis一次通行过程.png">
<meta property="article:published_time" content="2023-06-25T08:16:51.000Z">
<meta property="article:modified_time" content="2023-06-26T07:01:36.131Z">
<meta property="article:author" content="trluper">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://example.com/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis事件处理器.png">

<link rel="canonical" href="https://example.com/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis数据库 | Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis数据库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-25 16:16:51" itemprop="dateCreated datePublished" datetime="2023-06-25T16:16:51+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 15:01:36" itemprop="dateModified" datetime="2023-06-26T15:01:36+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="redis数据类型">1. Redis数据类型</h2>
<p>Redis提供了<code>String,Hash,List,Set,Zset</code>五种数据类型。</p>
<h3 id="string">String</h3>
<p><code>String</code>数据结构是最简单的<code>key-value</code>类型，<code>value</code>不仅可以是<code>String</code>,也可以是数字，包括整数，浮点数和二进制数。</p>
<p><code>string</code> 数据结构是简单的 <code>key-value</code> 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串（simple dynamic string，SDS）</strong>。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<p>主要的应用有：缓存，计数（比如用户的访问次数、热点文章的点赞转发数量等等），共享session和限速。</p>
<p>内部编码主要有：</p>
<ul>
<li><strong><code>int</code></strong>:8个字节的长整型</li>
<li><strong><code>embstr</code></strong>:小于等于39个字节的字符串</li>
<li><strong><code>raw</code></strong>:大于39个字节的字符串</li>
</ul>
<p>各个指令的时间复杂度</p>
<ul>
<li><strong><code>SET</code></strong>：为一个 key 设置 value，可以配合 EX/PX 参数指定 key 的有效期，通过 NX/XX 参数针对 key 是否存在的情况进行区别操作，时间复杂度 O(1)</li>
<li><strong><code>GET</code></strong>：获取某个 key 对应的 value，时间复杂度 O(1)</li>
<li><strong><code>GETSET</code></strong>：为一个 key 设置 value，并返回该 key 的原 value，时间复杂度 O(1)</li>
<li><strong><code>MSET</code></strong>：为多个 key 设置 value，时间复杂度 O(N)</li>
<li><strong><code>MSETNX</code></strong>：同 MSET，如果指定的 key 中有任意一个已存在，则不进行任何操作，时间复杂度 O(N)</li>
<li><strong><code>MGET</code></strong>：获取多个 key 对应的 value，时间复杂度 O(N)</li>
<li><strong><code>INCR</code></strong>：将 key 对应的 value 值自增1，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li>
<li><strong><code>INCRBY</code></strong>：将 key 对应的 value 值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的 String 数据起作用。时间复杂度 O(1)</li>
<li><strong><code>DECR/DECRBY</code></strong>：同 INCR/INCRBY，自增改为自减。</li>
</ul>
<h3 id="hash">Hash</h3>
<p><code>Hash</code>是一个<code>string</code>类型的<code>field</code>和<code>value</code>的映射表，hash特别适合用于存储对象，后续操作的时候，可以直接仅仅修改这个对象某个字段的值。比如可以用hash数据结构来存储用户信息，商品信息等。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key = JavaUser</span><br><span class="line">value = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="string">&quot;location&quot;</span>: <span class="string">&quot;GuangDong,Jieyang&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要应用有：将关系型数据库每一行数据存储为一个哈希键</p>
<p><strong>内部编码主要：</strong></p>
<ul>
<li><code>ziplist(压缩列表)</code>：当哈希类型元素个数小于<code>hash-max-ziplist-entries</code>配置（默认512个字节），同时所有值小于<code>hash-max-ziplist-value</code>配置（默认64个字节）时，使用<code>ziplist</code>作为内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀</li>
<li><code>hashtable(哈希表)</code>：当哈希类型无法满足ziplist的条件时，使用hashtable作为内部实现，因为此时ziplist读写效率会下降，而hashtable读写时间复杂度为O(1)</li>
</ul>
<h4 id="各个指令的时间复杂度">各个指令的时间复杂度</h4>
<p>与 Hash 相关的常用命令：</p>
<ul>
<li><strong>HSET</strong>：将 key 对应的 Hash 中的 field 设置为 value。如果该 Hash 不存在，会自动创建一个。时间复杂度 O(1)</li>
<li>***：返回指定 Hash 中 field 字段的值，时间复杂度 O(1)</li>
<li>HMSET/HMGET：同 HSET 和 HGET，可以批量操作同一个 key 下的多个 field，时间复杂度：O(N)，N为一次操作的 field 数量</li>
<li>HSETNX：同 HSET，但如 field 已经存在，HSETNX 不会进行任何操作，时间复杂度 O(1)</li>
<li>HEXISTS：判断指定Hash中 field 是否存在，存在返回1，不存在返回0，时间复杂度 O(1)</li>
<li>HDEL：删除指定 Hash 中的 field（1个或多个），时间复杂度：O(N)，N 为操作的 field 数量</li>
<li>HINCRBY：同 INCRBY 命令，对指定 Hash 中的一个 field 进行 INCRBY，时间复杂度 O(1)</li>
</ul>
<p><strong>应谨慎使用的Hash相关命令：</strong></p>
<ul>
<li>HGETALL：返回指定 Hash 中所有的 field-value 对。返回结果为数组，数组中 field 和 value 交替出现。时间复杂度 O(N)</li>
<li>HKEYS/HVALS：返回指定 Hash 中所有的 field/value，时间复杂度 O(N)</li>
<li>上述三个命令都会对 Hash 进行完整遍历，Hash中的 field 数量与命令的耗时线性相关，对于尺寸不可预知的 Hash，应严格避免使用上面三个命令，而改为使用 HSCAN 命令进行游标式的遍历</li>
</ul>
<h3 id="list">List</h3>
<p><code>list</code>就是链表，Redis中list的应用场景非常多，也是Redis最重要的数据结构之一</p>
<p><strong><code>list</code>的实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</strong></p>
<p>另外可以通过<code>lrange</code>，就是从某个元素开始读取多少个元素，可以基于<code>list</code>实现分页查询，基于 redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
<p>主要的应用有：<strong>栈、队列，消息队列（抢购），文章列表等</strong></p>
<p><strong>内部编码有：</strong></p>
<ul>
<li><strong><code>ziplist(压缩列表)</code>：</strong>当哈希类型元素个数小于<code>list-max-ziplist-entries</code>配置（默认512），同时所有值小于<code>list-max-ziplist-value</code>配置（默认64）时，使用<code>ziplist作</code>为内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀</li>
<li><strong><code>linkedlist</code>(链表)</strong>：当列表类型无法满足<code>ziplist</code>条件时，使用链表作为内部实现</li>
</ul>
<h4 id="各个指令的时间复杂度-1">各个指令的时间复杂度</h4>
<ul>
<li><strong><code>LPUSH</code></strong>：向指定<code>List</code>的左侧（即头部）插入 1 个或多个元素，返回插入后的<code>List</code> 长度。时间复杂度<code>O(N)</code>，<code>N</code>为插入元素的数量</li>
<li><strong><code>RPUSH</code>：</strong>同 <code>LPUSH</code>，向指定<code>List</code>的右侧（即尾部）插入 1 或多个元素</li>
<li><strong><code>LPOP</code>：</strong>从指定<code>List</code>的左侧（即头部）移除一个元素并返回，时间复杂度 O(1)</li>
<li><strong><code>RPOP</code>：</strong>同 <code>LPOP</code>，从指定 <code>List</code> 的右侧（即尾部）移除 1 个元素并返回</li>
<li><strong><code>LPUSHX/RPUSHX</code></strong>：与 <code>LPUSH/RPUSH</code> 类似，区别在于，<code>LPUSHX/RPUSHX</code> 操作的 <code>key</code> 如果不存在，则不会进行任何操作</li>
<li><strong><code>LLEN</code></strong>：返回指定<code>List</code>的长度，时间复杂度 O(1)</li>
<li><strong><code>LRANGE</code></strong>：返回指定 <code>List</code> 中指定范围的元素（双端包含，即 <code>LRANGE key 0 10</code>会返回 <code>11</code> 个元素），时间复杂度 O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的 <code>List</code> 元素会导致延迟，同时对长度不可预知的<code>List</code>，避免使用 <code>LRANGE key 0 -1</code>这样的完整遍历操作。</li>
</ul>
<p>应谨慎使用的List相关命令：</p>
<ul>
<li><strong><code>LINDEX</code></strong>：返回指定<code>List</code>指定 <code>index</code> 上的元素，如果<code>index</code> 越界，返回<code>nil</code>。<code>index</code>数值是回环的，即 <code>-1</code>代表 <code>List</code> 最后一个位置，<code>-2</code>代表<code>List</code>倒数第二个位置。时间复杂度 O(N)</li>
<li><strong><code>LSET</code></strong>：将指定 <code>List</code>指定 <code>index</code> 上的元素设置为 <code>value</code>，如果 <code>index</code> 越界则返回错误，时间复杂度 <code>O(N)</code>，如果操作的是头/尾部的元素，则时间复杂度为<code>O(1)</code></li>
<li><strong><code>LINSERT</code></strong>：向指定 <code>List</code> 中指定元素之前/之后插入一个新元素，并返回操作后的 <code>List</code> 长度。如果指定的元素不存在，返回<code>-1</code>。如果指定<code>key</code> 不存在，不会进行任何操作，时间复杂度 <code>O(N)</code></li>
</ul>
<p><strong>由于<code>Redis</code> 的 List 是链表结构的，上述的三个命令的算法效率较低，需要对 <code>List</code>进行遍历，命令的耗时无法预估，在<code>List</code>长度大的情况下耗时会明显增加，应谨慎使用。</strong></p>
<h3 id="set">Set</h3>
<p>集合（set）可以保存多个字符串元素，但是不允许有重复元素，并且集合中的元素是无序的，一个集合最多可以存储2^32-1个元素，集合可以进行内部的增删改查和多个集合取交集，并集，差集。</p>
<p>主要的应用有：<strong>标签，生成随机数（抽奖），社交需求（共同好友，粉丝等等）</strong></p>
<p><strong>内部编码主要有：</strong></p>
<ul>
<li>** intset(整数集合)**：当集合中的元素都是整数而且元素个数小于set-max-intset-entries配置（默认512个）时，使用该编码减少内存的使用</li>
<li><strong>hashtable(哈希表)</strong>：其它条件下使用哈希表作为内部实现</li>
</ul>
<h4 id="各个指令的时间复杂度-2">各个指令的时间复杂度</h4>
<ul>
<li><strong>SADD</strong>：向指定 Set 中添加 1 个或多个 member，如果指定 Set 不存在，会自动创建一个。时间复杂度 O(N)，N 为添加的 member 个数</li>
<li><strong>SREM</strong>：从指定 Set 中移除 1 个或多个 member，时间复杂度 O(N)，N 为移除的 member 个数</li>
<li><strong>SRANDMEMBER</strong>：从指定 Set 中随机返回 1 个或多个 member，时间复杂度 O(N)，N 为返回的 member 个数</li>
<li><strong>SPOP：</strong>从指定 Set 中随机移除并返回 count 个 member，时间复杂度 O(N)，N 为移除的 member 个数</li>
<li><strong>SCARD</strong>：返回指定 Set 中的 member 个数，时间复杂度 O(1)</li>
<li><strong>SISMEMBER</strong>：判断指定的 value 是否存在于指定 Set 中，时间复杂度 O(1)</li>
<li><strong>SMOVE</strong>：将指定 member 从一个 Set 移至另一个 Set</li>
</ul>
<p>慎用的Set相关命令：</p>
<ul>
<li><strong>SMEMBERS</strong>：返回指定 Hash 中所有的 member，时间复杂度 O(N)</li>
<li><strong>SUNION/SUNIONSTORE：</strong>计算多个 Set 的并集并返回/存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
<li><strong>SINTER/SINTERSTORE</strong>：计算多个 Set 的交集并返回/存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
<li><strong>SDIFF/SDIFFSTORE：</strong>计算 1 个 Set 与 1 或多个 Set 的差集并返回/存储至另一个 Set 中，时间复杂度 O(N)，N 为参与计算的所有集合的总 member 数</li>
</ul>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的 Set 尺寸不可知的情况下，应严格避免使用。可以考虑通过 SSCAN 命令遍历获取相关 Set 的全部 member，如果需要做并集/交集/差集计算，可以在客户端进行，或在不服务实时查询请求的 Slave 上进行</p>
<h3 id="zset">ZSet</h3>
<p>有序集合（zset）保留集合元素不能重复的特性，但是有序集合中的元素可以排序，它为每一个元素设定一个score作为排序的依据</p>
<p>应用：<strong>排行榜系统，用户点赞。需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</strong></p>
<p><strong>内部编码实现：</strong></p>
<ul>
<li><strong>ziplist(压缩列表)</strong>：当哈希类型元素个数小于zset-max-ziplist-entries配置（默认128个），同时所有值小于zset-max-ziplist-value配置（默认64）时，使用ziplist作为内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，在节省内存方面更加优秀。</li>
<li><strong>skiplist(跳表)：</strong>当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降</li>
</ul>
<h4 id="各个指令的时间复杂度-3">各个指令的时间复杂度</h4>
<ul>
<li><strong>ZADD</strong>：向指定 Sorted Set 中添加 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为添加的 member 数量，N 为 Sorted Set 中的 member 数量</li>
<li><strong>ZREM</strong>：从指定 Sorted Set 中删除 1 个或多个 member，时间复杂度 O(Mlog(N))，M 为删除的 member 数量，N 为 Sorted Set 中的 member 数量</li>
<li><strong>ZCOUNT</strong>：返回指定 Sorted Set 中指定 score 范围内的 member 数量，时间复杂度：O(log(N))</li>
<li><strong>ZCARD</strong>：返回指定 Sorted Set 中的 member 数量，时间复杂度 O(1)</li>
<li><strong>ZSCORE</strong>：返回指定 Sorted Set 中指定 member 的 score，时间复杂度 O(1)</li>
<li><strong>ZRANK/ZREVRANK</strong>：返回指定 member 在 Sorted Set 中的排名，ZRANK 返回按升序排序的排名，ZREVRANK 则返回按降序排序的排名。时间复杂度 O(log(N))</li>
<li><strong>ZINCRBY</strong>：同 INCRBY，对指定 Sorted Set 中的指定 member 的 score 进行自增，时间复杂度 O(log(N))</li>
</ul>
<p><strong>慎用的Sorted Set相关命令：</strong></p>
<ul>
<li><strong>ZRANGE/ZREVRANGE：</strong>返回指定 Sorted Set 中指定排名范围内的所有 member，ZRANGE 为按 score 升序排序，ZREVRANGE 为按 score 降序排序，时间复杂度 O(log(N)+M)，M为本次返回的 member 数</li>
<li><strong>ZRANGEBYSCORE/ZREVRANGEBYSCORE</strong>：返回指定 Sorted Set 中指定 score 范围内的所有 member，返回结果以升序/降序排序，min 和 max 可以指定为 -inf和+ inf，代表返回所有的 member。时间复杂度 O(log(N)+M)</li>
<li><strong>ZREMRANGEBYRANK/ZREMRANGEBYSCORE</strong>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有 member。时间复杂度 O(log(N)+M)</li>
</ul>
<p>上述几个命令，应尽量避免传递<code>[0 -1]</code>或<code>[-inf +inf]</code>这样的参数，来对 Sorted Set 做一次性的完整遍历，特别是在 Sorted Set 的尺寸不可预知的情况下。可以通过 ZSCAN 命令来进行游标式的遍历，或通过 LIMIT 参数来限制返回 member 的数量（适用于 ZRANGEBYSCORE 和 ZREVRANGEBYSCORE 命令），以实现游标式的遍历。</p>
<h2 id="为什么要用redis为什么要用缓存">2. 为什么要用redis/为什么要用缓存</h2>
<p>主要从“高性能”和“高并发”这两个点来看待这个问题</p>
<p><strong>高性能：</strong></p>
<p>Redis中的数据是存储在内存中的，所以读写速度非常快。假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变之后，同步改变缓存中相应的数据即可。</p>
<p><strong>高并发：</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库</p>
<h2 id="redis的数据怎么存储在内存中内存这么有限怎么存储的">3. Redis的数据怎么存储在内存中（内存这么有限，怎么存储的）</h2>
<h2 id="为什么使用redis而不直接在程序中使用map做缓存">4. 为什么使用redis而不直接在程序中使用map做缓存？</h2>
<p>缓存分为本地缓存和分布式缓存，使用语言自带得map实现的是本地缓存，最主要得特点是轻量以及快速，生命周期随着该实例的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。</p>
<h2 id="redis的线程模型">5. redis的线程模型</h2>
<p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型 </strong>。redis内部使用文件事件处理器file event handler,这个文件事件处理器是单线程的，所以redis才叫做单线程的模型。</p>
<p>它采用IO多路复用机制同时监听多个socket，它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。根据socket上的事件来选择对应的事件处理器进行处理。</p>
<p>这样的好处非常明显： I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：</p>
<ul>
<li>文件事件;</li>
<li>时间事件。</li>
</ul>
<p>时间事件不需要多花时间了解，我们接触最多的还是 文件事件（客户端进行读取写入等操作，涉及一系列网络通信）。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件的： &gt;Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event &gt;handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<blockquote>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
</blockquote>
<blockquote>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</strong></p>
</blockquote>
<p>文件事件处理器的结构包含4各部分：</p>
<ul>
<li>多个socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器，命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路服用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。 <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis事件处理器.png" width="700"></p>
<p>客户端与redis的一次通信过程如下： <img src="/2023/06/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/redis一次通行过程.png" width="800"></p>
<p>客户端<code>socket01</code>向<code>redis</code>的<code>server socket</code>请求建立连接，此时<code>server socket</code>会产生一个<code>AE_READBLE</code>事件，IO多路复用程序监听到<code>server socket</code>产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的<code>socket01</code>,并将该<code>socket01</code>的<code>AE_READBLE</code>事件与命令请求处理器相关联。</p>
<p>假设此时客户端发送了一个<code>set key value</code>请求，此时<code>redis</code>的<code>socket01</code>会产生<code>AE_READABLE</code>事件，IO多路复用程序将事件压入队列，此时事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取<code>socket01</code>中的<code>key value</code>并在自己内存中完成<code>key value</code>的设置。操作完成后，它会将<code>socket01</code>的<code>AE_WRITABLE</code>事件与命令回复处理器相关联。</p>
<p>如果此时客户端准备好接收返回结果了，那么redis中的<code>socket01</code>会产生一个<code>AE_WRITABLE</code>事件，同样压入队列中，事件分派器找到相关联的的命令回复处理器，由命令回复处理器对<code>socket01</code>输入本次操作的一个结果，比如ok，之后解除<code>socket01</code>的<code>AE_WRITABLE</code>事件与命令回复处理器的关联。</p>
<p>这就完成了一次通信。</p>
<h2 id="redis-使用单线程的原因">6. Redis 使用单线程的原因</h2>
<p>Redis 从一开始就选择使用单线程模型处理来自客户端的绝大多数网络请求，这种考虑其实是多方面的，其中最重要的几个原因如下：</p>
<ul>
<li>使用单线程模型能带来更好的可维护性，方便开发和调试；</li>
<li>使用单线程模型也能并发的处理客户端的请求；</li>
<li><strong>Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；</strong></li>
</ul>
<p>上述三个原因中的最后一个是最终使用单线程模型的决定性因素，其他的两个原因都是使用单线程模型额外带来的好处，在这里按顺序介绍上述的几个原因。</p>
<h3 id="可维护性">可维护性</h3>
<p>可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。</p>
<p>如果计算机中的两个进程（线程同理）同时尝试修改一个共享内存的内容，在没有并发控制的情况下，最终的结果依赖于两个进程的执行顺序和时机，如果发生了并发访问冲突，最后的结果就会是不正确的。</p>
<p>引入了多线程，就必须要同时引入并发控制来保证在多个线程同时访问数据时程序行为的正确性，这就需要工程师额外维护并发控制的相关代码，例如，会需要在可能被并发读写的变量上增加互斥锁。</p>
<p>在访问这些变量或者内存之前也需要先对获取互斥锁，一旦忘记获取锁或者忘记释放锁就可能会导致各种诡异的问题，管理相关的并发控制机制也需要付出额外的研发成本和负担。</p>
<h3 id="并发处理">并发处理</h3>
<p><strong>使用单线程模型也并不意味着程序不能并发的处理任务，Redis 虽然使用单线程模型处理用户的请求，但是它却使用 I/O 多路复用机制并发处理来自客户端的多个连接，同时等待多个连接发送的请求。</strong></p>
<p>在 I/O 多路复用模型中，最重要的函数调用就是 select 以及类似函数，该方法的能够同时监控多个文件描述符（也就是客户端的连接）的可读可写情况，当其中的某些文件描述符可读或者可写时，select 方法就会返回可读以及可写的文件描述符个数。</p>
<p>使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要额外创建和维护进程和线程来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。</p>
<h3 id="性能瓶颈">性能瓶颈</h3>
<p>这个就是 Redis 选择单线程模型的决定性原因 —— 多线程技术能够帮助我们充分利用 CPU 的计算资源来并发的执行不同的任务，但是 CPU 资源往往都不是 Redis 服务器的性能瓶颈。哪怕在一个普通的 Linux 服务器上启动 Redis 服务，它也能在 1s 的时间内处理 1,000,000 个用户请求。</p>
<p>如果这种吞吐量不能满足我们的需求，更推荐的做法是使用分片的方式将不同的请求交给不同的 Redis 服务器来处理，而不是在同一个 Redis 服务中引入大量的多线程操作。</p>
<p>简单总结一下，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。</p>
<p>多线程虽然会更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的开销，其中包括：</p>
<ul>
<li>保存线程 1 的执行上下文；</li>
<li>加载线程 2 的执行上下文；</li>
</ul>
<p>频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。</p>
<p>##7. Redis 多线程 ### Redis 4.0 虽然说 <code>Redis</code> 是单线程模型，但是， 实际上，<code>Redis</code> 在 4.0 之后的版本中就已经加入了对多线程的支持。</p>
<p>不过，<strong><code>Redis 4.0</code> 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</strong></p>
<p>Redis 在最新的几个版本中加入了一些可以被其他线程异步处理的删除操作，例如 <code>UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC</code>等非阻塞的删除操作。为什么会需要这些删除操作，而它们为什么需要通过多线程的方式异步处理？</p>
<h4 id="删除操作多线程的原因">删除操作多线程的原因</h4>
<p>可以在 Redis 在中使用 <code>DEL</code> 命令来删除一个键对应的值，如果待删除的键值对占用了较小的内存空间，那么哪怕是同步地删除这些键值对也不会消耗太多的时间。</p>
<p>但<strong>是对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的 PCT99 和可用性。</strong></p>
<p><strong>然而释放内存空间的工作其实可以由后台线程异步进行处理，这也就是 UNLINK 命令的实现原理，它只会将键从元数据中删除，真正的删除操作会在后台异步执行。</strong></p>
<blockquote>
<p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p>
</blockquote>
<h3 id="redis6.0-之后引入了多线程">Redis6.0 之后引入了多线程</h3>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="trluper 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="trluper 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/10/Redis/" rel="prev" title="Redis">
      <i class="fa fa-chevron-left"></i> Redis
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">1. Redis数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">1.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash"><span class="nav-number">1.2.</span> <span class="nav-text">Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E6%8C%87%E4%BB%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.2.1.</span> <span class="nav-text">各个指令的时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">1.3.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E6%8C%87%E4%BB%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">各个指令的时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">1.4.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E6%8C%87%E4%BB%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">各个指令的时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zset"><span class="nav-number">1.5.</span> <span class="nav-text">ZSet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E6%8C%87%E4%BB%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="nav-number">1.5.1.</span> <span class="nav-text">各个指令的时间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98"><span class="nav-number">2.</span> <span class="nav-text">2. 为什么要用redis&#x2F;为什么要用缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E7%9A%84%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%86%85%E5%AD%98%E8%BF%99%E4%B9%88%E6%9C%89%E9%99%90%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="nav-number">3.</span> <span class="nav-text">3. Redis的数据怎么存储在内存中（内存这么有限，怎么存储的）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8redis%E8%80%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8map%E5%81%9A%E7%BC%93%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text">4. 为什么使用redis而不直接在程序中使用map做缓存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">5. redis的线程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">6.</span> <span class="nav-text">6. Redis 使用单线程的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="nav-number">6.1.</span> <span class="nav-text">可维护性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86"><span class="nav-number">6.2.</span> <span class="nav-text">并发处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"><span class="nav-number">6.3.</span> <span class="nav-text">性能瓶颈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">6.3.1.</span> <span class="nav-text">删除操作多线程的原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis6.0-%E4%B9%8B%E5%90%8E%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.4.</span> <span class="nav-text">Redis6.0 之后引入了多线程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">968k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:40</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
      <script type="text/javascript">
      function renderGitalk(){
        var gitalk = new Gitalk({
            owner: '',
            repo: '',
            clientID: '123fe329fdbb06b0f1d1',
            clientSecret: '40add829107b6e69f43274d3545ae71c988de8eb',
            admin: '',
            
            });
        gitalk.render('gitalk-container');
      }
      renderGitalk();
      </script>
    
 


<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>