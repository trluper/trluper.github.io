<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Trluper">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="trluper">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">python面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 18:24:44" itemprop="dateCreated datePublished" datetime="2022-06-30T18:24:44+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-15 10:10:48" itemprop="dateModified" datetime="2022-09-15T10:10:48+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">python面向对象</span></a>
                </span>
            </span>

          
            <span id="/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-meta-item leancloud_visitors" data-flag-title="python面向对象" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="面向对象">1. 面向对象</h4>
<h5 id="类对象提供的默认行为">1.1 类对象提供的默认行为</h5>
<p>在python的面向对象模型种，要分清<strong>类对象</strong>和<strong>实例对象</strong>。类对象就是<code>class</code>定义了一个类只会，该类提供些行为就是类对象.而实例对象就是该类的实例。每次调用类，就会生成一个实例。 类对象提供的默认行为：</p>
<ul>
<li><code>class</code>语句创建类对象并将其赋值给变量名。就像<code>def</code>一样，class语句也是可执行语句，执行时会产生类对象，并赋值变量名</li>
<li>class语句的赋值语句会创建类属性，像模块文件一样，class语句内的顶层的赋值语句（不在<code>def</code>内）会成为类对象的属性。</li>
<li>类属性提供对象的状态（变量）和行为（函数）</li>
<li>类仍然时模块内的属性。当<code>class</code>执行时，只是赋值语句而已，赋值了一个类对象</li>
</ul>
<h5 id="实例对象是具体对象">1.2 实例对象是具体对象</h5>
<p>每当调用类对象时，就会生成示例对象：</p>
<ul>
<li>调用类对象会创建新的实例对象</li>
<li>每个示例对象有类的属性并且有自己的命名空间</li>
<li><strong><em>在方法内对self属性做赋值会产生每个实例自己的属性</em></strong>：在类函数内，第一个参数总是接受方法调用的隐形主体，通常用<code>self</code>会引用正处理的实例对象（相当于C/C++的<code>this指针</code>)。对<code>self</code>的属性做赋值运算，会创建或修改实例内的数据，而不是类的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">firstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.data=value;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data);</span><br><span class="line">    data=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">s=firstClass();</span><br><span class="line">s.printdata();	<span class="comment">#0</span></span><br><span class="line">s.setdata(<span class="number">10</span>);</span><br><span class="line">s.printdata();	<span class="comment">#10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>self</code>会自动引用正在处理的示例对象，所以赋值语句会把值村储到实例的命名空间。因为<strong>类对象</strong>会产生多个实例，函数必须经过<code>self</code>参数才能识别获取正在处理的实例（就看出时c/c++中隐藏的<code>this指针</code>就行了)</p>
<h5 id="继承">1.3 继承</h5>
<p>面向对象的一大特性就是继承，以下时python中继承的核心观点：</p>
<ul>
<li>父类列在类开头的括号处</li>
<li>子类从父类中继承了函数和属性</li>
<li>实例会继承所有可读取类的属性：每个实例会从创建它的类中获取变量名，此外还有该类的父类</li>
<li>每个<code>object.attribute</code>都会开启新的独立搜索：python会对每个属性取出表达式进行对类树的独立搜索，包括self</li>
<li>一般来说逻辑的修改都是通过继承的子类修改，而不是直接修改父类</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">secondClass</span>(<span class="title class_ inherited__">firstClass</span>):</span><br><span class="line">	data=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这是第二个类&quot;</span>，sefl.data);</span><br><span class="line"></span><br><span class="line">a=secondClass();</span><br><span class="line">a.setdata(<span class="number">20</span>)</span><br><span class="line">a.printdata();		<span class="comment">#这是第二个类 20</span></span><br></pre></td></tr></table></figure>
<p>子类对属性的搜索会从下往上，即从子类到父类，直到所找属性名首次出现为止。上面的<code>printdata</code>函数覆盖了父类的<code>printdata</code>函数，这中覆盖叫做<code>重载</code>。</p>
<h5 id="类的运算符重载初识">1.4 类的运算符重载初识</h5>
<p><strong>运算符重载</strong>就是让类写成的对象可以截获并响应内置类型上的运算，如加法、切片和打印等等，在这里我们只是片面性的列举了一些重载以做了解，更加具体的将在后面介绍。运算符重载的主要注意点：</p>
<ul>
<li>运算符重载的命名方式为<code>__x__</code></li>
<li>当实例出现内置运算时，这类方法会自动调用。比如实例有<code>__add__</code>方法，当对象出现<code>+</code>表达式时，该方法就会调用</li>
<li>类可覆盖多数内置类型运算</li>
<li>运算符重载让类变得更趋像python的对象模型</li>
</ul>
<p><strong><em>注意</em></strong>：我们必须关心一个方法，那就是<code>__init__</code>方法，也称为<strong>构造函数</strong>,它用于初始化对象的状态的，<strong><em><code>__init__</code>和<code>self</code>是我们理解python面向对象特性的关键</em></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdClass</span>(<span class="title class_ inherited__">secondClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.data=value;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> ThirdClass(self.data+other);</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[ThirdClass:%s]&#x27;</span>% self.data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是ThirdClass&quot;</span>,self.data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=ThirdClass(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">a.printdata();</span><br><span class="line">a=a+<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">a.printdata();</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是ThirdClass abc</span><br><span class="line">这是ThirdClass abc123</span><br><span class="line">[ThirdClass:abc123]</span><br></pre></td></tr></table></figure> 从上面可以知道几点：</p>
<ol type="1">
<li><code>ThirdClass</code>调用传入一个参数，这是传给<code>__init__</code>构造函数的参数，即在在构建实例时自动调用<code>__init__</code>构造函数来初始化属性</li>
<li>有<code>__add__</code>函数后，即<code>+</code>运算符重载，<code>ThirdClass</code>的实例对象就可出现在<code>+</code>处，对与<code>+</code>，它把左侧的对象传给<code>self</code>，右侧的给<code>other</code>。执行完后，<strong>对于<code>__add__</code>来说要返回一个新的对象实例</strong></li>
<li>重载了<code>__str__</code>方法后，可以直接调用<code>print</code>打印对象</li>
</ol>
<h5 id="以实例介绍类的细节">1.5 以实例介绍类的细节</h5>
<h6 id="person和manager">1.5.1 person和manager</h6>
<p>在本节，将会两个类<code>person</code>和<code>manager</code>来介绍类实现的一些细节。顺带一提oython的%字符串格式为<code>&quot;%s,%d&quot; %(&quot;2222&quot;,10)</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,job=<span class="literal">None</span>,pay=<span class="number">0</span></span>):</span><br><span class="line">		self.name=name;</span><br><span class="line">		self.job=jon;</span><br><span class="line">		self.pay=pay;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span>  self.name.split()[-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self,percent</span>):</span><br><span class="line">		self.pay=<span class="built_in">int</span>(self.pay*(<span class="number">1</span>+percent))</span><br><span class="line">	<span class="comment">#print重载</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;[Person:%s,%s]&#x27;</span> % (self.name,self.pay)</span><br><span class="line"><span class="comment">#manager类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">	<span class="comment">#定制自己的构造函数，使用父类（超类）的构造函数构造</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,pay</span>):</span><br><span class="line">		self.person=Person.__init__(self,name,<span class="string">&#x27;mgr&#x27;</span>,pay);</span><br><span class="line">	<span class="comment">#重载函数，内部仍然使用超类的函数</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self,percent,bonus=<span class="number">1.0</span></span>):</span><br><span class="line">		person.giveRaise(self,percent+bonus);</span><br><span class="line">	<span class="comment">#改进点：</span></span><br><span class="line">	<span class="comment">#1. 使用内置的`Instance.__class__.__name__`,避免重复修改前部分的名称</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span><span class="string">&#x27;[%s:%s,%s]&#x27;</span> % (self.__class__.__name__,self.name,self.pay)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="对象持久化">1.5.2 对象持久化</h6>
<p>在上面我们创建的不是真正的数据库记录，如果关闭python，实例也将消失，因为它们是内存中的临时对象，这时可以使用python中<code>对象持久化</code>的功能，让对象在退出程序时依然存在。<strong>对象持久化</strong>通过3个标准库模块实现：</p>
<ul>
<li><code>pickle</code>:任意python对象和字节串之间的转化</li>
<li><code>dbm</code>：实现一个可通过键访问的文件系统，以存储字符串</li>
<li><code>shelve</code>:使用上面两个模块按照键把python对象存储到一个文件</li>
</ul>
<p>即<code>shelve</code>通过使用<code>pickle</code>将对象转为字符串，然后存储到一个<code>dbm</code>文件中键值对下，<code>shelve</code>通过键获取<code>pinkle</code>化的字符串，并用<code>pickle</code>在内存中重新创建最初对象。<code>shelve</code>就像字典一样，但是<code>shelve</code>一开始必须打开，并且在修改后关闭它 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">a=Person(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">b=Manager(<span class="string">&quot;小路&quot;</span>，<span class="number">1000</span>)</span><br><span class="line">db=shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">object</span> <span class="keyword">in</span>(a,b)</span><br><span class="line">	db[objecct.name]=<span class="built_in">object</span></span><br><span class="line">db.close();</span><br></pre></td></tr></table></figure> 此时，当前目录下会生成一个或多个名为<code>persondb</code>的文件</p>
<h5 id="抽象类">1.6 抽象类</h5>
<p>抽象类只是实现给继承者的一些接口，继承者类将接口实现什么功能完全由继承类决定，因此抽象接口类不能产生实例,只要类中有一个抽象方法，我们就不能创建该类的实例对象。在python3中，在<code>class</code>的头部使用一个关键字参数，以及特殊的<strong><span class="citation" data-cites="装饰器">@装饰器</span></strong>语法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCmeta,abstractmethod</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>(metaclass=ABCmeta):</span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">method_1</span>(<span class="params">self,*args</span>):</span><br><span class="line">		<span class="keyword">pass</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="命名空间">1.7 命名空间</h5>
<p>我们知道点号和无点号的变量名，会用不同方式进行访问，还有一些作用域是用于对对象命名空间做初始而设定的（如模块和类），总结如下：</p>
<ul>
<li>无点号运算的变量民与作用域相对应（如普通的全局和局部赋值）</li>
<li>点号的属性名<code>object.x</code>使用的是对象的命名空间</li>
<li>有些作用域会对对象的命名空间初始化（模块和类）</li>
</ul>
<h5 id="运算符重载详解">1.8 运算符重载详解</h5>
<p>运算符重载是意味着给自定义类增加操作，在类方法中拦截内置操作，当类的实例出现内置操作时，python自动调用你的方法。以下时常见的运算符重载方法：</p>
<table>
<thead>
<tr class="header">
<th>运算符重载函数名</th>
<th>重载功能</th>
<th>调用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__init__</code></td>
<td>构造函数</td>
<td>实例创建时自动调用</td>
</tr>
<tr class="even">
<td><code>__del__</code></td>
<td>析构函数</td>
<td>实例对象回收时自动调用</td>
</tr>
<tr class="odd">
<td><code>__add__</code></td>
<td>运算符<code>+</code></td>
<td>如果没有<code>__iadd__</code>，<code>X+Y,X+=Y</code>时会调用</td>
</tr>
<tr class="even">
<td><code>__sub__</code></td>
<td>运算符<code>-</code></td>
<td><code>X-Y,X-=Y</code>调用</td>
</tr>
<tr class="odd">
<td><code>__repr__,__str__</code></td>
<td>打印，转换</td>
<td><code>print(x),repr(x),str(x)</code></td>
</tr>
<tr class="even">
<td><code>__call__</code></td>
<td>函数调用</td>
<td><code>X(*args,**dargs)</code></td>
</tr>
<tr class="odd">
<td><code>__getattr__</code></td>
<td>点号运算</td>
<td><code>X.undefined</code></td>
</tr>
<tr class="even">
<td><code>__setattr__</code></td>
<td>属性赋值语句</td>
<td><code>X.attribute=value</code></td>
</tr>
<tr class="odd">
<td><code>__delattr__</code></td>
<td>属性删除</td>
<td><code>del X.attribute</code></td>
</tr>
<tr class="even">
<td><code>__getattribute__</code></td>
<td>属性获取</td>
<td><code>X.attribute</code></td>
</tr>
<tr class="odd">
<td><code>__getitem__</code></td>
<td>索引运算</td>
<td><code>x[key],x[i:j]</code></td>
</tr>
<tr class="even">
<td><code>__setitem__</code></td>
<td>索引赋值语句</td>
<td><code>x[key]=value,x[i:j]=sequance</code></td>
</tr>
<tr class="odd">
<td><code>__delitem__</code></td>
<td>索引和分片删除</td>
<td><code>del x[key],del x[i:j]</code></td>
</tr>
<tr class="even">
<td><code>__iter__</code>,<code>__next___</code></td>
<td>迭代环境</td>
<td><code>i=iter(x),next(i)</code></td>
</tr>
<tr class="odd">
<td><code>__len__</code></td>
<td>长度</td>
<td>如果没有<code>__bool__</code>，直接<code>len(x)</code></td>
</tr>
<tr class="even">
<td><code>__bool__</code></td>
<td>布尔测试</td>
<td><code>bool(x)</code></td>
</tr>
<tr class="odd">
<td><code>__lt__</code>,<code>__gt__</code></td>
<td>比较</td>
<td>从左到右以此为<code>&lt;,&gt;</code></td>
</tr>
<tr class="even">
<td><code>__le__</code>,<code>__ge__</code></td>
<td>比较</td>
<td><code>&lt;=,&gt;=</code></td>
</tr>
<tr class="odd">
<td><code>__eq__</code>,<code>__ne__</code></td>
<td>比较</td>
<td><code>==,!=</code></td>
</tr>
<tr class="even">
<td><code>__contains__</code></td>
<td>成员关系测试</td>
<td><code>item in X</code></td>
</tr>
</tbody>
</table>
<p>由上面可知，运算符的重载前后都有两个下划线标识，以区分其他变量名函数。</p>
<h6 id="索引和分片__getitem__">1.8.1 索引和分片<code>__getitem__</code></h6>
<p>如果类中定义或者继承了该运算符，则对于实例的索引运算，会自动调用<code>__getitem__</code>,会把实例传递给第一个参数，方括号内的值则传递给后面的一个参数，<code>__setitem__</code>则加了一个值value参数。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">operatorOverload</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		self.L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,index</span>):</span><br><span class="line">		<span class="keyword">return</span> self.L[index];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,index,value</span>):</span><br><span class="line">		self.L[index]=value;</span><br><span class="line">x=operatorOverload();</span><br><span class="line"><span class="comment">#索引操作</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">2</span>]);	<span class="comment">#9</span></span><br><span class="line"><span class="built_in">print</span>(x.L);		<span class="comment">#[1,2,3,4]</span></span><br><span class="line"><span class="comment">#分片操作</span></span><br><span class="line"><span class="built_in">print</span>(x[::<span class="number">2</span>])	<span class="comment">#[1,3]</span></span><br><span class="line"><span class="comment">#赋值</span></span><br><span class="line">x[::<span class="number">2</span>]=[<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="built_in">print</span>(x[:])</span><br></pre></td></tr></table></figure></p>
<h6 id="索引迭代__iter__">1.8.2 索引迭代<code>__iter__</code></h6>
<p><code>__getitem__</code>有一个买一送一的情况，该重载不仅仅支持上面所讲的<strong>索引和分片功能</strong>,同时支持了<code>for</code>循环的迭代，<strong>当类中未定义<code>__iter__</code>时，即<code>for</code>循环每次循环时都会调用类的<code>__getitem__</code></strong>。其实不仅仅指<code>for</code>循环会调用，其他的迭代环境，如<code>in成员测试，列表解析,内置函数map，列表和元组赋值运算以及类型构造方法</code>也会自动调用该方法，只有类中没有<code>__iter__</code>. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> x:	<span class="comment">#调用了__getitem__</span></span><br><span class="line">	<span class="built_in">print</span>(item,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h6 id="迭代器对象">1.8.3 迭代器对象</h6>
<p>尽管上面说的<code>__getitem__</code>支持迭代，但是它只是一直附加方法，真正的迭代还是要习惯用<code>__iter__</code>来获取迭代器，调用<code>__next__</code>访问，直到碰见异常<code>StopIteration</code>。python环境中所有迭代环境都是先尝试<code>__iter__</code>方法，然后再试<code>__getitem__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IterTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> self.start==self.end:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration;</span><br><span class="line">		self.start+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> self.start**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">m=IterTest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">q=<span class="built_in">iter</span>(m);</span><br><span class="line"><span class="built_in">print</span>(q);		<span class="comment">#&lt;__main__.IterTest object at 0x00000168A41CDFF0&gt;</span></span><br><span class="line"><span class="comment">#print(next(q))	#1</span></span><br><span class="line">L=<span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">	L.append(x);</span><br><span class="line"><span class="built_in">print</span>(L);		<span class="comment">#[1, 4, 9, 16, 25]，当print(next(q))未注释，输出为[4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<p>上面可以看到，迭代器对象就是实例<code>self</code>，这是因为<code>__next__</code>使类方法。且上面定义的迭代器使像<strong>生成器函数和表达式、<code>map</code>和<code>zip</code>内置函数</strong>一样的单迭代对象，要达到多个迭代器的效果，<code>__iter__</code>只需替迭代器定义新的状态对象，而不是返回<code>self</code>，带来的消耗是要创建多个迭代对象: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NextTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> self.start==self.end:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration;</span><br><span class="line">		self.start+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> self.start**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IterTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> NextTest(self.start,self.end);</span><br><span class="line"></span><br><span class="line">m=IterTest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">q=<span class="built_in">iter</span>(m);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(q));		<span class="comment">#1</span></span><br><span class="line">L=<span class="built_in">list</span>();</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">	L.append(x);</span><br><span class="line"><span class="built_in">print</span>(L);			<span class="comment">#[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure></p>
<h6 id="成员关系">1.8.4 成员关系</h6>
<p>再迭代领域，类通常把<code>in</code>成员关系运算符实现为一个迭代，使用<code>__iter__</code>或着<code>__getitem__</code>。要支持更加特定的成员关系，类可能要编写一个<code>__contains__</code>方法，出现是，方法优先级是<code>contains&gt;iter&gt;getitem</code>。<code>__contains__</code>方法应该把成员关系定义为对一个<strong>映射</strong>应用键，用于序列的搜索 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContainsTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.data=value;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self,x</span>):</span><br><span class="line">		<span class="keyword">return</span> x <span class="keyword">in</span> self.data;</span><br><span class="line"></span><br><span class="line">m=ContainsTest([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Contains:&quot;</span>,<span class="number">3</span> <span class="keyword">in</span> m,end=<span class="string">&#x27; &#x27;</span>);		<span class="comment">#Contains: True</span></span><br></pre></td></tr></table></figure></p>
<h6 id="属性引用">1.8.5 属性引用</h6>
<p><code>__getattr__</code>方法是拦截属性点号运算，当通过对未定义（不存在）属性名称和实例进行点号运算时，就会用属性名称作为字符串调用这个方法，如果可以通过继承找到属性就不会调用这个方法。因此，<code>__getattr__</code>可以作为钩子通过这种方式响应属性请求： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">empty</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">___getattr__</span>(<span class="params">self,attrname</span>):</span><br><span class="line">		<span class="keyword">if</span> attrname=<span class="string">&quot;age&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> AttributeError,attrname</span><br><span class="line"></span><br><span class="line">x=empty();</span><br><span class="line">x.age		<span class="comment">#40</span></span><br><span class="line">x.name		<span class="comment">#AttributeError:name</span></span><br></pre></td></tr></table></figure> <code>__setattr__</code>会拦截所有属性的赋值语句,因此如果定义了这个方法要小心。除此之外，因为它对任何赋值语句都会拦截，即使是在<code>__setattr__</code>内也不例外，为防止无限递归，要使用该方法，必须通过<strong>属性字典</strong>做索引来赋值任何实例属性<code>self.__dict__[attr]=value;</code>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self,attrname,value</span>):</span><br><span class="line">		<span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">			self.__dict__[attr]=value;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">raise</span> AttriubteError, attrname+<span class="string">&#x27;nor allowed&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="call表达式">1.8.6 call表达式</h6>
<p>当调用实例时，使用<code>__call__</code>。如果定义该方法，python1就会为实例应用函数调用表达式运行<code>__call__</code>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,*args,**agrv</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;called:&#x27;</span>,args,argv);</span><br><span class="line">c=Test();</span><br><span class="line">c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,x=<span class="number">4</span>,y=<span class="number">5</span>);	<span class="comment">#called:(1,2,3)&#123;&#x27;x&#x27;=4,&#x27;y&#x27;=5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="布尔测试">1.8.7 布尔测试</h6>
<p>python首先尝试<code>__bool__</code>来直接获取一个<code>bool</code>值，如果没有该方法，就尝试<code>__len__</code>，根据对象的长度确定一个真值。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.data=value;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span>(self.data!=<span class="literal">None</span>):</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span>;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(self.data);</span><br><span class="line">x=Truth(<span class="string">&quot;12314&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;bool yes!&#x27;</span>);	<span class="comment">#bool yes!</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(x):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;len yes!&#x27;</span>);	<span class="comment">#len yes!</span></span><br></pre></td></tr></table></figure></p>
<h6 id="迭代环境__next__和__iter__">1.8.8 迭代环境<code>__next__</code>和<code>__iter__</code></h6>
<p>python对于创建得类允许自定义迭代环境，如果用户需要定义迭代环境，必须 - 实现<code>__iter__</code>和<code>__next__</code>函数， - 同时在<code>__next__</code>函数中指定迭代退出环境,一般为产生一个异常<code>raise</code> - 在迭代中<code>__next__</code>中实现迭代对象，返回该对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __iter__(self):</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">def __next__(self):</span><br><span class="line">    <span class="keyword">if</span> self.Next is None:</span><br><span class="line">        raise StopIteration</span><br><span class="line">    self.currentNode=self.Next</span><br><span class="line">    self.Next=self.Next.next</span><br><span class="line">    <span class="keyword">return</span> self.currentNode</span><br></pre></td></tr></table></figure>
<h6 id="section">1.8.9</h6>
<h5 id="类的设计">1.9 类的设计</h5>
<p>无论是哪门语言，对于OOP，其重要的三个面向对象特性：继承、多态、封装。在python，这三个特性作用也是一样：</p>
<ul>
<li>继承：提高代码的复用性</li>
<li>多态：提高程序的可扩展性和可维护性</li>
<li>封装：方法和运算符实现行为，数据隐藏是一种惯例，以此提高程序安全性</li>
</ul>
<h6 id="封装">1.9.1 封装</h6>
<p>封装提高程序的安全性。将数据（属性）和行为（方法）包装到类对象中，在方法内部对属性进行操作，在类对象的外部调用方法，这样无需关心方法内部的具体实现细节，从而隔离了复杂度；在python中没有专门的修饰符用于属性的私有，如果该属性不希望在类对象外部被访问，前边使用两个<code>_</code>修饰 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.__age=age  <span class="comment">#年龄不希望在类的外部被使用，所以加了两个__</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.__age)</span><br><span class="line">stu1=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">stu1.show()</span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br><span class="line"><span class="comment">#print(stu1.__age)   #这句话会报错，因为__age不希望在类外面使用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;如果想在类之外使用，可以用_类名__实例属性来用&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(stu1._Student__age)</span><br></pre></td></tr></table></figure></p>
<h6 id="继承-1">1.9.2 继承</h6>
<p>在python中，如果一个类没有继承任何类，则默认继承object。python支持多继承，<strong>定义子类时，必须在其构造函数中调用父类的构造函数</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,stu_num</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.stu_num=stu_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,teachofyear</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.teachofyear=teachofyear</span><br><span class="line"></span><br><span class="line">stu=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>,<span class="number">1001</span>)</span><br><span class="line">teach=Teacher(<span class="string">&#x27;李四&#x27;</span>,<span class="number">40</span>,<span class="number">20</span>)</span><br><span class="line">stu.info()</span><br><span class="line">teach.info()</span><br></pre></td></tr></table></figure> 如上，如果子类对继承父类中的某个属性或方法不满意，可以在子类中对其（方法体）进行重新编写.<strong>子类重写后的方法中可以通过<code>super().xxx()</code>调用父类中被重写的方法</strong>。</p>
<p>另外一点，在python中object类是所有类的父类，因此所有类都有object类的属性和方法。有内置函数dir()可以查看指定对象所有属性。object还有有一个<code>__str__()</code>方法，用于返回一个对于“对象的描述”，对应于内置函数<code>str()</code>经常用于<code>print()</code>方法，帮我们查看对象的信息，所以我们经常会对<code>__str__()</code>进行重写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我的名字是&#123;0&#125;,今年&#123;1&#125;岁&#x27;</span>.<span class="built_in">format</span>(self.name,self.age)</span><br><span class="line">stu=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(stu))</span><br><span class="line"><span class="built_in">print</span>(stu)  <span class="comment">#默认会调用__str__()这样的方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(stu))</span><br></pre></td></tr></table></figure>
<h6 id="多态">1.9.3 多态</h6>
<p>多态就是“具有多种形态”,它指的是：即便不知道一个变量所引用的对象到底是 什么类型，仍然可以通过这个变量调用方法，在运行过程中根据变量所引用对象的类型， 动态决定调用哪个对象中的方法。实现多态必须有的三个条件：</p>
<ul>
<li>继承</li>
<li>方法重写</li>
<li>父类引用指向子类对象 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动物会吃&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;狗吃骨头&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猫吃鱼&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;人吃五谷杂粮&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.eat()</span><br><span class="line">fun(Cat())</span><br><span class="line">fun(Dog())</span><br><span class="line">fun(Animal())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;——————————&#x27;</span>)</span><br><span class="line">fun(Person())</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="类的浅拷贝和深拷贝">1.9.4 类的浅拷贝和深拷贝</h6>
<ul>
<li><strong>变量的赋值操作</strong>：只是形成两个变量，实际上还是指向同一个对象</li>
<li><strong>浅拷贝</strong>：python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，源对象与拷贝对象会引用同一个子对象</li>
<li><strong>深拷贝</strong>：使用copy模块的<code>deepcopy</code>函数，递归拷贝对象中包含的子对象，源对象和拷贝 对象所有的子对象也不相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Disk</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,cpu,disk</span>):</span><br><span class="line">        self.cpu=cpu</span><br><span class="line">        self.disk=disk</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.变量的赋值</span></span><br><span class="line">cpu1=CPU()</span><br><span class="line">cpu2=cpu1</span><br><span class="line"><span class="built_in">print</span>(cpu1)</span><br><span class="line"><span class="built_in">print</span>(cpu2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.类的浅深拷贝</span></span><br><span class="line">disk=Disk() <span class="comment">#创建一个硬盘类的对象</span></span><br><span class="line"><span class="built_in">print</span>(disk)</span><br><span class="line">computer=Computer(cpu1,disk)    <span class="comment">#创建一个计算机类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#浅拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">computer2=copy.copy(computer)</span><br><span class="line"><span class="built_in">print</span>(computer,computer.cpu,computer.disk)</span><br><span class="line"><span class="built_in">print</span>(computer2,computer2.cpu,computer2.disk)</span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝</span></span><br><span class="line">computer3=copy.deepcopy(computer)</span><br><span class="line"><span class="built_in">print</span>(computer,computer.cpu,computer.disk)</span><br><span class="line"><span class="built_in">print</span>(computer3,computer3.cpu,computer3.disk)</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//赋值就是简单的变量引用同一个对象</span><br><span class="line">&lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt;</span><br><span class="line">&lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#浅拷贝，对象包含的的子对象内容不拷贝，都引用同一个内容</span></span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615ED70</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615F820</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝，子对象也拷贝了</span></span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615ED70</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615DD50</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615D450</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615D3F0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="设计模式之委托模式">1.9.5 设计模式之委托模式</h6>
<p>所谓的<strong>委托</strong>，<strong>通常就是指控制对象内嵌其他对象，而把运算请求传给这些内嵌对象处理，控制器对象只负责管理工作</strong>。在python中，委托通常用<code>__getattr__</code>钩子方法实现，因为这个方法会拦截对不存在属性的读取，因此代理类可以使用<code>__getattr__</code>把任意读取操作转给被包装对象。 简而言之：通过一个类来调用另一个类里的方法来处理请求，即这两个类对象参与处理同一个请求对象，只不过一个是<strong>委托者</strong>，一个是<strong>处理者</strong>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,<span class="built_in">object</span></span>):</span><br><span class="line">		self.wrapped=<span class="built_in">object</span>;	<span class="comment">#内嵌对象</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self,attrname</span>):</span><br><span class="line">		<span class="keyword">if</span> attrname==<span class="string">&#x27;append&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped,attrname);</span><br><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">x=wrapper(L);</span><br><span class="line">x.append(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">print</span>(L)			<span class="comment">#[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure> 上述代码中，因为<code>x.append(4)</code>未在<code>wrapper</code>内定义，触发<code>__getattr__</code>函数,<code>getattr(x,y)</code>函数的作用就是点操作，即<code>x.y</code>。</p>
<h6 id="绑定和无绑定方法">1.9.6 绑定和无绑定方法</h6>
<ul>
<li>实例的绑定方法：即有<code>self</code>，且在类中没有被任何装饰器修饰的方法就是绑定到对象的方法，这类方法专门为对象定制。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    country = <span class="string">&quot;China&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">str</span>(self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;Kitty&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p.__dict__)</span><br><span class="line">p.speak()   <span class="comment">#通过对象调用 Kitty, 18</span></span><br><span class="line">Person.speak(p)   <span class="comment">#通过类调用Kitty, 18</span></span><br></pre></td></tr></table></figure>
<p>通过对象调用绑定到对象的方法，会有一个自动传值的过程，即自动将当前对象传递给方法的第一个参数（<code>self</code>，一般都叫<code>self</code>，也可以写成别的名称）；若是使用类调用，则第一个参数需要手动传值。</p>
<ul>
<li>类的绑定方法:类中使用<code>@classmethod</code>修饰的方法就是绑定到类的方法。这类方法专门为类定制。通过类名调用绑定到类的方法时，会将类本身当做参数传给类方法的第一个参数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operate_database</span>():</span><br><span class="line">    host = <span class="string">&#x27;192.168.0.5&#x27;</span></span><br><span class="line">    port = <span class="string">&#x27;3306&#x27;</span></span><br><span class="line">    user = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">cls</span>):  <span class="comment"># 约定俗成第一个参数名为cls，也可以定义为其他参数名</span></span><br><span class="line">        <span class="built_in">print</span>(cls)</span><br><span class="line">        <span class="built_in">print</span>(cls.host + <span class="string">&#x27;:&#x27;</span> + cls.port + <span class="string">&#x27; &#x27;</span> + cls.user + <span class="string">&#x27;/&#x27;</span> + cls.password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Operate_database.connect();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Operate_database&#x27;</span>&gt;</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span>:<span class="number">3306</span> abc/<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>非绑定方法:在类内部使用 <span class="citation" data-cites="staticmethod">@staticmethod</span> 修饰的方法即为非绑定方法，这类方法和普通定义的函数没有区别，不与类或对象绑定，谁都可以调用(实例和类都可以)，且没有自动传值的效果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operate_database</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port, user, password</span>):</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_passwrod</span>(<span class="params">salt, password</span>):</span><br><span class="line">        m = hashlib.md5(salt.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 加盐处理</span></span><br><span class="line">        m.update(password.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">hash_password = Operate_database.get_passwrod(<span class="string">&#x27;lala&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)  <span class="comment"># 通过类来调用</span></span><br><span class="line"><span class="built_in">print</span>(hash_password)</span><br><span class="line"></span><br><span class="line">p = Operate_database(<span class="string">&#x27;192.168.0.5&#x27;</span>, <span class="string">&#x27;3306&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line">hash_password = p.get_passwrod(p.user, p.password)  <span class="comment"># 也可以通过对象调用</span></span><br><span class="line"><span class="built_in">print</span>(hash_password)</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f7a1cc409ed6f51058c2b4a94a7e1956</span><br><span class="line">0659c7992e268962384eb17fafe88364</span><br></pre></td></tr></table></figure></p>
<h5 id="棱形继承">1.10 棱形继承</h5>
<p>在多层继承和多继承同时使用的情况下，就会出现复杂的继承关系，即重重复继乘，常说的<strong>菱形继承</strong> <img src="/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/lengxing.png" width="300"> 在这种结构中，在调用顺序上就出现了疑惑，调用顺序究竟是以下哪一种顺序呢,如果是深度，那么A会重复调用，造成不必要的消耗</p>
<ul>
<li><code>D-&gt;B-&gt;A-&gt;C-&gt;A（深度优先）</code></li>
<li><code>D-&gt;B-&gt;C-&gt;A（广度优先）</code></li>
</ul>
<p>上面问题的根源都跟MRO有关,MRO(Method Resolution Order)也叫方法解析顺序，主要用于在多重继承时判断调的属性来自于哪个类，其使用了一种叫做C3的算法，其基本思想时在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则去寻找需要的属性和方法。 <strong>要避免顶层父类某个方法被多次调用，此时就需要super()来发挥作用了,super本质上是一个类，内部记录着MRO信息，由于C3算法确保同一个类只会被搜寻一次，这样就避免了顶层父类中的方法被多次执行了</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意，这段代码是个特例，在D的注释处明显调用了B/C的构造函数，所有会执行两次A的构造函数，要使其不执行两次，则需要使用super().xxx()。这种方法很常用，应该熟记</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init A...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end A...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init B...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(B, self).__init__()</span><br><span class="line">		<span class="comment"># A.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end B...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init C...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(C, self).__init__()</span><br><span class="line">		<span class="comment"># A.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end C...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init D...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(D, self).__init__()</span><br><span class="line">		<span class="comment">#B.__init__(self)</span></span><br><span class="line">        <span class="comment">#C.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end D...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    D()</span><br></pre></td></tr></table></figure> 输出：采用广度优先搜索 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init D...</span><br><span class="line">init B...</span><br><span class="line">init C...</span><br><span class="line">init A...</span><br><span class="line">end A...</span><br><span class="line">end C...</span><br><span class="line">end B...</span><br><span class="line">end D...</span><br><span class="line"></span><br></pre></td></tr></table></figure> 值得一提的是Python类分为两种，一种叫经典类，一种叫新式类。都支持多继承，但继承方式不同：</p>
<ul>
<li><strong>新式类</strong>：从object继承来的类。（如:class A(object)），采用广度优先搜索的方式继承（即先水平搜索，再向上搜索）。</li>
<li><strong>经典类</strong>：不从object继承来的类。（如：class A()），采用深度优先搜索的方式继承（即先深入继承树的左侧，再返回，再找右侧）。</li>
</ul>
<p><strong><em>注意：Python2.x中类的是有经典类和新式类两种。Python3.x中都是新式类（类都默认继承object）。因此对于多重继承，顺序很重要，他会根据继承类在首行位置，从左到右搜索</em></strong> 实例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    attr=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    attr=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B,C):</span><br><span class="line">    <span class="keyword">pass</span>;</span><br><span class="line"></span><br><span class="line">M=D();</span><br><span class="line"><span class="built_in">print</span>(M.attr)		<span class="comment">#2</span></span><br></pre></td></tr></table></figure> 上面的代码输出为2，先解释一下：因为B、C都继承自A，D继承自B，那么在python3.x版本以上，采用了广度优先，顺序是<code>D-&gt;B-&gt;C-&gt;A</code>,在C时遇到了属性<code>attr=2</code>，停止搜索返回，输出为2</p>
<h6 id="super详解">1.10.1 super详解</h6>
<p>上面已经提到了，在python3.x版本上，都使用新式类，python避免重复调用是采用<strong>MRO(Method Resolution Order)机制也叫方法解析顺序，主要用于在多重继承时判断调的属性来自于哪个类，其使用了一种叫做C3的算法，其基本思想时在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则去寻找需要的属性和方法。</strong></p>
<p><code>super</code>本质上是一个类，但super() 和父类没有实质性的关联：</p>
<ul>
<li><code>super()</code>函数需要两个参数，第一个是类名，第二个是一般都为<code>self</code>但也会有<code>cls</code>情况，但在python3.x中使用<code>super().xxxx()</code>等同于<code>super(classname,self).xxxx()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;B&quot;</span>)</span></span><br><span class="line"><span class="function">        super().__init__()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class C(A):</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;C&quot;</span>)</span></span><br><span class="line"><span class="function">        super(C, self).__init__()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class D(B,C):</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;D&quot;</span>,D.__mro__)</span></span><br><span class="line"><span class="function">        super(D, self).__init__()</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">#输出</span></span><br><span class="line"><span class="function">D (&lt;class <span class="string">&#x27;ListNode.D&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.B&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.C&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.A&#x27;</span>&gt;, &lt;class <span class="string">&#x27;object&#x27;</span>&gt;)</span></span><br><span class="line"><span class="function">B</span></span><br><span class="line"><span class="function">C</span></span><br><span class="line"><span class="function">A</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p><code>super</code>工作原理：如果在类D中调用<code>super()</code>会传入D类，那就会在它<code>__mro__</code>上一级开始查找，它的上一级是B，就会调用B的函数，依次类推下去。如下更改D类的<code>super()</code>输出改变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;D&quot;</span>,D.__mro__)</span></span><br><span class="line"><span class="function">        super(C, self).__init__()</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">#输出：</span></span><br><span class="line"><span class="function">D (&lt;class <span class="string">&#x27;ListNode.D&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.B&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.C&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.A&#x27;</span>&gt;, &lt;class <span class="string">&#x27;object&#x27;</span>&gt;)</span></span><br><span class="line"><span class="function">A</span></span><br></pre></td></tr></table></figure>
<p>因为上一级是<code>__mro__</code>中C的上一级是A，就好执行A的<code>__init__()</code>函数</p>
<h5 id="slots可选">1.11 slots（可选）</h5>
<p>python类有一个双刃剑就是：即使我们没有在类内部创建属性，也可以在实例对象中通过<code>.</code>给实例对象创建一个属于实例的属性，这样听起来非常bug，不像java和c++这样有很好的封装性: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a=A();</span><br><span class="line">a.p=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">print</span>(a.p) <span class="comment">#20</span></span><br></pre></td></tr></table></figure> 之前提到过<code>__getattr__</code>能够对未在类内创建的属性提供操作。这里介绍python提供的<code>slots</code>来支持这一功能。 这个特殊属性一般是在类的顶层内将变量名称（字符串形式）按顺序赋值给变量<code>__slots__</code>，<strong>该属性规定：只有<code>__slots__</code>列表内的这些变量名可赋值为实例属性</strong>。它也要遵循python的规则，实例属性名必须在引用前赋值 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>:</span><br><span class="line">	__slots__=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=limiter();</span><br><span class="line"><span class="comment">#print(x.age)		#AttributeError,未赋值就引用</span></span><br><span class="line">x.age=<span class="number">40</span></span><br><span class="line"><span class="built_in">print</span>(x.age)		<span class="comment">#40</span></span><br><span class="line">x.jk=<span class="number">2</span>;				<span class="comment">#不允许，变量名不在__slots__</span></span><br></pre></td></tr></table></figure> 但是注意，类中有<code>__slots__</code>会没有<code>__dict__</code>属性，事实上，<code>__slots__</code>就是以<code>__dict__</code>的代价来起到这样一个功能的： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>:</span><br><span class="line">	__slots__=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>,<span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=limiter();</span><br><span class="line">x.jk=<span class="number">2</span>;				<span class="comment">#运行成功</span></span><br></pre></td></tr></table></figure> 没有<code>__dict__</code>，我们就不能在类的函数内随便起变量名，因此对于<code>__slots__</code>看情况使用</p>
<h5 id="装饰器">1.12. 装饰器</h5>
<p>装饰器一般有函数装饰器和类装饰器。装饰器即指通过对函数的包装来修改其他函数的功能的函数。我们知道在python中可以嵌套定义函数，<strong>但是我们外部无法直接访问嵌套内部函数，好在可以将一个函数名赋值给一个变量，其实函数名就是一个变量，只不过指向函数对象，也可通过返回函数变量名</strong>，然后通过变量名去调用<code>变量名()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">hi</span><span class="params">(name=<span class="string">&quot;yasoob&quot;</span>)</span>:</span></span><br><span class="line"><span class="function">    def greet():</span></span><br><span class="line"><span class="function">        return <span class="string">&quot;now you are in the greet() function&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    def welcome():</span></span><br><span class="line"><span class="function">        return <span class="string">&quot;now you are in the welcome() function&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    if name =</span>= <span class="string">&quot;yasoob&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> greet</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"> </span><br><span class="line">a = <span class="built_in">hi</span>()		#返回great</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">a</span>())				#调用<span class="built_in">a</span>()==<span class="built_in">great</span>()</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">&lt;function greet at <span class="number">0x7f2143c01500</span>&gt;</span><br><span class="line">now you are in the <span class="built_in">greet</span>() function</span><br></pre></td></tr></table></figure></p>
<p>既然我们能够将函数作为变量，那么变量当然可以作为参数，当我们将函数变量作为参数传递给另外一个函数时，就会产生装饰器的知识，实际上装饰器就是做这种事： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    def wrapTheFunction():</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">        a_func()</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    return wrapTheFunction</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">def a_function_requiring_decoration():</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration()</span></span><br><span class="line"><span class="function">#outputs: <span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration =</span> <span class="built_in">a_new_decorator</span>(a_function_requiring_decoration)</span><br><span class="line"><span class="meta">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">a_function_requiring_decoration</span>()</span><br><span class="line"><span class="meta">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line">#        I am the function which needs some decoration to remove my foul smell</span><br><span class="line">#        <span class="function">I am doing some boring work after executing <span class="title">a_func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="函数装饰器">1.12.1 函数装饰器</h6>
<p>上面讲解了函数装饰器的原理，提供了一种方式声明函数的特定运算模式，其原理是将函数包裹到另一个函数，在另一个函数的逻辑内实现。<strong>现在为简化其实现，使用<code>@</code>代替这些代码，所以函数装饰器在def语句前一行，由<code>@符号、后面跟着所谓的元函数</code></strong>组成。元函数就是管理另一函数（或其他可调用对象）的函数,如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">a_new_decorator</span></span><br><span class="line"><span class="function">def <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span></span><br><span class="line"><span class="function">          <span class="string">&quot;remove my foul smell&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration()</span></span><br><span class="line"><span class="function">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="function">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="function">#         I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure> 上面的<code>@a_new_decorator</code>等价于<code>a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration</code></p>
<p><strong>python内置的装饰器：</strong></p>
<ul>
<li><code>@classmethod</code>：修饰类内的方法是绑定到类的方法，该方法专门为类提供，会将类本身当作参数传给类方法的第一个参数，不需要使用对象调用当然你可以使用对象调用。</li>
<li><code>@staticmethod</code>：在类内部使用该装饰器修饰方法，这类方法不与类或对象绑定，属于静态方法，谁都可以调用，且没有自动传值功能。</li>
<li><code>@wraps(函数变量名)</code>；在上面举例的函数装饰器<code>@a_new_decorator</code>中会改变函数的<code>__name__</code>为<code>wrapTheFunction</code>，正常应该为<code>a_function_requiring_decoration</code>。这时候就需要使用<code>@wraps()</code>装饰器 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: wrapTheFunction</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="comment">#使用@wraps()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_new_decorator</span>(<span class="params">a_func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">a_func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapTheFunction</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requiring_decoration</span>():</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"><span class="comment">#输出正常</span></span><br><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: a_function_requiring_decoration</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="类装饰器">1.12.2 类装饰器</h6>
<p>类装饰器类似于函数装饰器（后续补充）</p>
<h4 id="链表实现">2. 链表实现</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value,<span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.value=value</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;节点已删除&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,Size=<span class="number">0</span>,pHead=<span class="literal">None</span></span>):</span><br><span class="line">        self.pHead=pHead</span><br><span class="line">        self.Next=pHead</span><br><span class="line">        self.Size=Size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已注销&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.Next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.currentNode=self.Next</span><br><span class="line">        self.Next=self.Next.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> self.currentNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Crease</span>(<span class="params">self</span>):</span><br><span class="line">        self.Size+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DeCrease</span>(<span class="params">self</span>):</span><br><span class="line">        self.Size-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node=ListNode(value)</span><br><span class="line">        <span class="comment">#判断是否为空链表</span></span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.pHead=node</span><br><span class="line">            <span class="keyword">return</span> self.pHead;</span><br><span class="line">        <span class="comment">#找到最后一个节点</span></span><br><span class="line">        current_Node=self.pHead;</span><br><span class="line">        preNode=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current_Node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode=current_Node</span><br><span class="line">            current_Node=current_Node.<span class="built_in">next</span></span><br><span class="line">        preNode.<span class="built_in">next</span>=node</span><br><span class="line">        self.Crease()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">erase</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            preNode=<span class="literal">None</span></span><br><span class="line">            current_node=self.pHead;</span><br><span class="line">            <span class="keyword">while</span> current_node!=<span class="literal">None</span> <span class="keyword">and</span> current_node.value != value:</span><br><span class="line">                preNode=current_node</span><br><span class="line">                current_node=current_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> preNode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">             self.pHead=self.pHead.<span class="built_in">next</span></span><br><span class="line">             self.DeCrease()</span><br><span class="line">             <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">elif</span> current_node.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode.<span class="built_in">next</span>=current_node.<span class="built_in">next</span></span><br><span class="line">            self.DeCrease()</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">return</span> self.pHead</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,value</span>):</span><br><span class="line">        Next=self.pHead</span><br><span class="line">        <span class="keyword">while</span> Next.value <span class="keyword">is</span> <span class="keyword">not</span> value:</span><br><span class="line">            Next=Next.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> Next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        current_node=self.pHead</span><br><span class="line">        preNode=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current_node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode=current_node</span><br><span class="line">            current_node=current_node.<span class="built_in">next</span></span><br><span class="line">        preNode.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        self.DeCrease()</span><br><span class="line">        <span class="keyword">return</span> current_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        retNode=self.pHead</span><br><span class="line">        self.pHead=self.pHead.<span class="built_in">next</span></span><br><span class="line">        self.DeCrease()</span><br><span class="line">        <span class="keyword">return</span> retNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_front</span>(<span class="params">self,value</span>):</span><br><span class="line">        node = ListNode(value)</span><br><span class="line">        self.Next=self.pHead</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.pHead=node</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        node.<span class="built_in">next</span>=self.pHead</span><br><span class="line">        self.pHead=node</span><br><span class="line">        self.Crease()</span><br><span class="line">        self.Next=self.pHead</span><br><span class="line">        <span class="keyword">return</span> self.pHead</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">python基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-24 09:07:58" itemprop="dateCreated datePublished" datetime="2022-06-24T09:07:58+08:00">2022-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-15 15:31:16" itemprop="dateModified" datetime="2022-10-15T15:31:16+08:00">2022-10-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          
            <span id="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-meta-item leancloud_visitors" data-flag-title="python基础知识" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="python的运行过程">1. python的运行过程</h4>
<p><img src="https://img-blog.csdnimg.cn/9f0f1b3db22d4c1e8a5bdd455e7702a7.jpeg#pic_center"></p>
<h5 id="字节码编译">1.1 字节码编译</h5>
<pre><code>当程序运行时,Python内部会将源代码(.py文件中的程序)编译成所谓的字节码的形式,就是将每一行源代码语句从上到下翻译过来,翻译成一组字节码的指令.这些字节码可以提高执行速度;比起源代码语句,字节码要执行快的多。
它会将字节码保存为一个以pyc为扩展名的文件，Python这样保存字节码是一种作为启动速度的优化.下一次运行程序时,如果你还停留在上一次修改记录的话,就会直接跳过编译直接加载.pyc文件.</code></pre>
<h5 id="pvm虚拟机">1.2 PVM虚拟机</h5>
<p>py程序编译成字节码后，字节码文件会发送给PVM，也就是python虚拟机进行出来。PVM是python运行的引擎，从根本上讲，它才算是python解释器。python虚拟机就是去模拟可执行程序在x86机器上的运行</p>
<h4 id="python的内置对象">2. python的内置对象</h4>
<p>python中没有类型声明，运行的表达式的语法决定了创建和使用对象的类型，正如以下表达式就是这些类型起源的地方。Python有五个标准的数据类型：</p>
<ul>
<li><code>Numbers</code>（数字）</li>
<li><code>String</code>（字符串）</li>
<li><code>List</code>（列表）</li>
<li><code>Tuple</code>（元组）</li>
<li><code>Dictionary</code>（字典）</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">column</th>
<th style="text-align: center;">column</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数字</td>
<td style="text-align: center;"><code>1234，3.14159，3+4j</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">字符串</td>
<td style="text-align: center;"><code>'spaw',&quot;guidos&quot;,&quot;python&quot;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">列表</td>
<td style="text-align: center;"><code>[1,[2,'there'],4]</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">字典</td>
<td style="text-align: center;"><code>&#123;'food':'spam','taste':'yum'&#125;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">元组</td>
<td style="text-align: center;"><code>(1,'spam',4,'u')</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">文件</td>
<td style="text-align: center;"><code>my=open('eggs','r')</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">集合</td>
<td style="text-align: center;"><code>set('abs'),&#123;'a','b','s'&#125;</code></td>
</tr>
</tbody>
</table>
<p>可迭代对象：字符串、列表、字典、元组、集合、文件对象 一些操作： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//数字整型</span><br><span class="line">s=<span class="number">546</span>;</span><br><span class="line">s=s*<span class="number">4</span>;</span><br><span class="line">//字符串</span><br><span class="line">s=<span class="string">&#x27;spam&#x27;</span>;</span><br><span class="line">k=<span class="built_in">len</span>(s); 	<span class="comment">#k=4</span></span><br><span class="line">s=s+<span class="string">&#x27;xyz&#x27;</span>;  <span class="comment">#s=&#x27;spamxyz&#x27;</span></span><br><span class="line">//序列操作</span><br><span class="line">s=<span class="string">&#x27;spam&#x27;</span>;</span><br><span class="line">q=s[<span class="number">0</span>];</span><br><span class="line">m=s[-<span class="number">1</span>];	<span class="comment">#字符串长度-1，即s[4-1]</span></span><br><span class="line">t=s[<span class="number">0</span>:<span class="number">3</span>]	<span class="comment">#从下标0开始，输出三个字符，即t=&#x27;spa&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>重要性质：</strong></p>
<p><strong>python的对象内存不可变性：</strong>在上面所写的例子中没有通过任何操作对原始字符串即spam变动，字符串在python中具有不可变性，在创建后就不可改变，但比总可以通过建立一个新的字符串并以同一个名字对其进行赋值（如<code>s=s+'xyz'</code>)，因为python在运行过程中会清理旧对象（动态类型）。<strong>一旦改变便意味是产生了新的对象</strong></p>
<h4 id="数字类型">3. 数字类型</h4>
<h5 id="一些内置的数学函数">3.1 一些内置的数学函数</h5>
<table>
<thead>
<tr class="header">
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>abs()</code></td>
<td>取绝对值</td>
</tr>
<tr class="even">
<td><code>pow()</code></td>
<td>计算任意N次方值</td>
</tr>
<tr class="odd">
<td><code>min()\max()</code></td>
<td>取最小值</td>
</tr>
<tr class="even">
<td><code>divmod()</code></td>
<td>同时取商和余数</td>
</tr>
<tr class="odd">
<td><code>sum()</code></td>
<td>求和</td>
</tr>
<tr class="even">
<td><code>round()</code></td>
<td>四舍五入</td>
</tr>
<tr class="odd">
<td><code>hex()</code></td>
<td>十进制转为十六进制</td>
</tr>
</tbody>
</table>
<h5 id="表达式操作符">3.2 表达式操作符</h5>
<p>与C/C++有些不同： <img src="https://img-blog.csdnimg.cn/57b3415f38e34a2a96c5b56f1dd1bffa.jpeg#pic_center"></p>
<h4 id="字符串">4. 字符串</h4>
<h5 id="raw字符串抑制转义">4.1 raw字符串抑制转义</h5>
<p>转义序列用来处理嵌入在自符串中的特殊字节编码很合适，但有些场合我们希望不要发生转义，如文件路径中<code>myfile=open('C:\new\test.txt','w')。</code>本意想打开这个文件，但是因为转义字符<code>\n</code>的存在。如果字母<code>r</code>出现在字符串第一个引号钱，意味着关闭转义：<code>myfile=open(R'C:\new\test.txt','w')'</code></p>
<h5 id="常见操作">4.2 常见操作</h5>
<p>对于python的字符串，无论是<code>&quot;&quot;</code>还是<code>''</code>都一样,支持串与串的相加，支持串与数的相乘，但不允许串与数的相加。同时支持负偏移和分片操作： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;trluper&quot;</span>;	<span class="comment">#合法</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;	<span class="comment">#合法</span></span><br><span class="line">c=<span class="built_in">str</span>[-<span class="number">1</span>];		<span class="comment">#str[len(str)-1]=str[6]</span></span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>+<span class="string">&#x27;github&#x27;</span>;</span><br><span class="line"><span class="built_in">str</span>*=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">str</span>+=<span class="number">4</span>;			<span class="comment">#error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r</span><br><span class="line">trlupergithub</span><br><span class="line">trlupergithubtrlupergithubtrlupergithubtrlupergithub</span><br></pre></td></tr></table></figure></p>
<p><strong>分片：</strong><code>Str[i:j]</code>i表示从下标为i的开始，小标j结束（不包括j）(i未输入时默认为0，j未说明默认为到最后一个元素)。即<code>str[1:-1]</code>,表示从r开始到e结束（<code>len(str)-1=6</code>），<strong>分片会产生新对象。</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br><span class="line">s=<span class="built_in">str</span>[<span class="number">1</span>:-<span class="number">1</span>];</span><br><span class="line"><span class="built_in">print</span>(s);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlupe</span><br></pre></td></tr></table></figure></p>
<p><strong>扩展分片：</strong>分片表达式有可选的第三个索引，用作步进<code>str[i:j:k]</code>，未声明时k默认为1，表示隔几个元素取 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br><span class="line">s=<span class="built_in">str</span>[<span class="number">1</span>:-<span class="number">1</span>:<span class="number">2</span>];</span><br><span class="line"><span class="built_in">print</span>(s);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rue</span><br></pre></td></tr></table></figure></p>
<h5 id="数据类型转换">4.3 数据类型转换</h5>
<p>上面讲到字符串和数字之间无法相加，会发生错误，为解决这方面问题，python提供了字符串和数字间的转换函数：</p>
<table>
<thead>
<tr class="header">
<th>函数名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>int(string s)</code></td>
<td>将字符串转换为数字</td>
</tr>
<tr class="even">
<td><code>str(int i)</code></td>
<td>将数字转换为字符串</td>
</tr>
<tr class="odd">
<td><code>float(string s</code>)</td>
<td>将字符串转换为浮点数</td>
</tr>
<tr class="even">
<td><code>repr(object)</code></td>
<td>将对象转换为字符串并返回一个字符串对象</td>
</tr>
<tr class="odd">
<td><code>ord(char c)</code></td>
<td>将单个字符转为ascii码</td>
</tr>
<tr class="even">
<td><code>chr(int i)</code></td>
<td>将数字转换为对于的ascii码</td>
</tr>
<tr class="odd">
<td><code>tuple(s)</code></td>
<td>将序列 s 转换为一个元组</td>
</tr>
<tr class="even">
<td><code>list(s)</code></td>
<td>将序列 s 转换为一个列表</td>
</tr>
<tr class="odd">
<td><code>set(s)</code></td>
<td>转换为可变集合</td>
</tr>
<tr class="even">
<td><code>dict(d)</code></td>
<td>创建一个字典。d 必须是一个序列 (key,value)元组。</td>
</tr>
</tbody>
</table>
<h5 id="修改查询字符串">4.4 修改/查询字符串</h5>
<p>对于不可变性质，如果我们要改变原有字符串的一些值，则需要利用合并、分片这样的工具来重新建立并赋值一个新字符串或者<code>replace</code>，若有必要（程序的方便和易读），需要将结果重新赋值给原变量名。查找可以使用<code>find()</code>函数或者判断<code>“Trl&quot; in str</code>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;Trluper!&#x27;</span>;</span><br><span class="line"><span class="built_in">str</span>[<span class="number">0</span>]=<span class="string">&#x27;t&#x27;</span>;	<span class="comment">#error</span></span><br><span class="line">//分片合并</span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>[:<span class="number">3</span>]+<span class="string">&quot;user&quot;</span>+<span class="built_in">str</span>[-<span class="number">1</span>];</span><br><span class="line">//replace</span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>.replace(<span class="string">&quot;uper&quot;</span>,<span class="string">&quot;user&quot;</span>);</span><br><span class="line">//查找</span><br><span class="line"><span class="built_in">str</span>.find(<span class="string">&quot;trl&quot;</span>);	<span class="comment">#找到返回第一个下标，未找到则返回-1</span></span><br><span class="line">“trl” <span class="keyword">in</span> <span class="built_in">str</span>;		<span class="comment">#return True or false</span></span><br></pre></td></tr></table></figure></p>
<h5 id="字符串格式化">4.5 字符串格式化</h5>
<p>字符串格式化提供了一种组合字符串处理任务的处理思想。在python中有两种形式的<strong>字符串格式化表达式</strong>：</p>
<ol type="1">
<li>基于C的<code>printf模型</code>:在%左侧放置字符串，字符串中带有一个或多个嵌入目标(即<code>%d、%s、%c</code>这些)，<code>%</code>右侧放置一个元组或字典 。</li>
<li>python的字符串的<code>format函数</code>：通过花括号的位置或者关键字指出替换目标</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于元组的字符串格式化：</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;my name is %s,and I am %d years old&quot;</span> %(<span class="string">&quot;trluper&quot;</span>,<span class="number">24</span>);</span><br><span class="line"><span class="comment">#基于字典</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;my name is %(name)s,and I am %(age)d years old&quot;</span> % &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>&#125;;</span><br><span class="line"><span class="comment">#format函数</span></span><br><span class="line">template=<span class="string">&quot;my name is &#123;0&#125;,and i am &#123;age&#125; years old&quot;</span> ;</span><br><span class="line"><span class="built_in">str</span>=template.<span class="built_in">format</span>(<span class="string">&quot;trluper&quot;</span>,age=<span class="number">24</span>);</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> I am <span class="number">24</span> years old</span><br><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> I am <span class="number">24</span> years old</span><br><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> i am <span class="number">24</span> years old</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串的函数接口">5. 字符串的函数接口</h4>
<h5 id="字符串查询">5.1 字符串查询</h5>
<p>建议使用<code>find</code>，因为如果没有找到匹配的字符串，<code>index</code>方法会报异常。</p>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>find(str, beg=0, end=len(string))</code></td>
<td>查找子串<code>str</code>第一次出现的位置，如果找到则返回相应的索引，否则返回-1</td>
</tr>
<tr class="even">
<td><code>rfind(str, beg=0,end=len(string))</code></td>
<td>类似于<code>find()</code>函数，不过是从右边开始查找</td>
</tr>
<tr class="odd">
<td><code>index(str, beg=0, end=len(string))</code></td>
<td>类似于<code>find</code>，只不过如果没找到会报异常。</td>
</tr>
<tr class="even">
<td><code>rindex(str, beg=0 end=len(string))</code></td>
<td>类似于<code>rfind</code>，如果没有匹配的字符串会报异常</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;my name is qlee，what your name?&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2))<span class="comment">#全部查找</span></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2,<span class="number">5</span>))<span class="comment">#从第5个元素开始查找</span></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2,<span class="number">35</span>))<span class="comment"># 从第35个元素开始查找，超过元素索引或者没找到，不会报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="字符串大小写转换操作upperlowerswapcasecapitalize和title">5.2 字符串大小写转换操作（upper、lower、swapcase、capitalize和title）</h5>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>upper</code></td>
<td>将字符串中所有元素都转为大写</td>
</tr>
<tr class="even">
<td><code>lower</code></td>
<td>将字符串中所有元素都转为小写</td>
</tr>
<tr class="odd">
<td><code>swapcase</code></td>
<td>交换大小写。大写转为小写，小写转为大写</td>
</tr>
<tr class="even">
<td><code>capitalize</code></td>
<td>第一个大写，其余小写</td>
</tr>
<tr class="odd">
<td><code>title</code></td>
<td>每个单词的第一次字符大写，其余均为小写</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="string">&quot;my name is Qlee&quot;</span></span><br><span class="line"><span class="built_in">print</span>(txt.upper())</span><br><span class="line"><span class="built_in">print</span>(txt.lower())</span><br><span class="line"><span class="built_in">print</span>(txt.swapcase())</span><br><span class="line"><span class="built_in">print</span>(txt.capitalize())</span><br><span class="line"><span class="built_in">print</span>(txt.title())</span><br></pre></td></tr></table></figure>
<h5 id="字符串对齐centerjust和zfill">5.3 字符串对齐（center，just和zfill）</h5>
<p><img src="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png" width="700"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.center(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.ljust(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.rjust(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.zfill(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*********hello world!*********</span><br><span class="line">hello world!******************</span><br><span class="line">******************hello world!</span><br><span class="line">000000000000000000hello world!</span><br></pre></td></tr></table></figure>
<h5 id="分割字符串splitsplitlines和partition">5.4 分割字符串(split、splitlines和partition)</h5>
<p><img src="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png" width="700"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;my name is qlee, what is your name&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split())       <span class="comment"># 以空格为分隔符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split(<span class="string">&#x27;i&#x27;</span>,<span class="number">1</span>))   <span class="comment"># 以 i 为分隔符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split(<span class="string">&#x27;b&#x27;</span>))     <span class="comment"># 以b为分隔符,没找到不会报错</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.partition(<span class="string">&quot;name&quot;</span>))<span class="comment">#找到第一个name，分割为三部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.rpartition(<span class="string">&quot;name&quot;</span>))<span class="comment">#反向找到第一个name，分割为三部分</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;&quot;&quot;my name is qlee</span></span><br><span class="line"><span class="string">      what is your name&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.splitlines())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;qlee,&#x27;</span>, <span class="string">&#x27;what&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;your&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;my name &#x27;</span>, <span class="string">&#x27;s qlee, what is your name&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;my name is qlee, what is your name&#x27;</span>]</span><br><span class="line">(<span class="string">&#x27;my &#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27; is qlee, what is your name&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;my name is qlee, what is your &#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;my name is qlee&#x27;</span>, <span class="string">&#x27;      what is your name&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="合并与替换joinreplace">5.5 合并与替换(join，replace)</h5>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>join(seq)</code></td>
<td>以指定字符串作为分隔符，将 <code>seq</code> 中所有的元素(的字符串表示)合并为一个新的字符串</td>
</tr>
<tr class="even">
<td><code>replace(old,new [,max])</code></td>
<td>把 将字符串中的 <code>old</code> 替换成 <code>new</code>,如果 <code>max</code>指定，则替换不超过<code>max</code>次</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------join-----------&quot;</span>)</span><br><span class="line">seq1 = (<span class="string">&quot;h&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>) <span class="comment">#元组</span></span><br><span class="line">seq2 = [<span class="string">&quot;h&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>] <span class="comment">#列表</span></span><br><span class="line">seq3 = <span class="string">&quot;hello&quot;</span> <span class="comment">#字符串</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;&quot;</span>.join(seq1)) <span class="comment">#无分隔符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot; &quot;</span>.join(seq1))<span class="comment">#空格</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;,&quot;</span>.join(seq1))<span class="comment">#&quot;,&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------replace-----------&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;my name is qlee&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.replace(<span class="string">&quot;qlee&quot;</span>, <span class="string">&quot;lq&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------join-----------</span><br><span class="line">hello</span><br><span class="line">h e l l o</span><br><span class="line">h,e,l,l,o</span><br><span class="line">----------replace-----------</span><br><span class="line">my name <span class="keyword">is</span> lq</span><br></pre></td></tr></table></figure></p>
<h5 id="字符串的比较maxmin等">5.6 字符串的比较(&lt;,&gt;,max,min等)</h5>
<p>字符串的比较操作：</p>
<ul>
<li>运算符：<code>&gt; , &gt;=, &lt;, &lt;=, ==, !=</code></li>
<li>比较规则：从第一个以此往下比较。</li>
<li>比较原理：比较的是<code>oridinal value</code>(原始值，即ascii码值)</li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>max(str)</code></td>
<td>返回字符串<code>str</code>中最大的字母</td>
</tr>
<tr class="even">
<td><code>min(str)</code></td>
<td>返回字符串<code>str</code>中最小的字母</td>
</tr>
<tr class="odd">
<td><code>ord</code></td>
<td>将指定字符转换为原始值</td>
</tr>
<tr class="even">
<td><code>chr</code></td>
<td>将原始值转换为对应的字符</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;mynameisqlee&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;max(str): &quot;</span>, <span class="built_in">max</span>(<span class="built_in">str</span>),<span class="string">&quot;min(str): &quot;</span>, <span class="built_in">min</span>(<span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> &lt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;c&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">98</span>))</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="built_in">str</span>):  y <span class="built_in">min</span>(<span class="built_in">str</span>):  a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure></p>
<h5 id="判断字符串isidentifierisspaceisalphaisdecimalisnumeric和isalnum等">5.7 判断字符串(isidentifier、isspace、isalpha、isdecimal、isnumeric和isalnum等)</h5>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>isidentifier</code></td>
<td>判断字符串是不是合法标识符(字符、数字、下划线)</td>
</tr>
<tr class="even">
<td><code>isspace</code></td>
<td>判断字符是否只有空白字符(回车、换行和水平制表符)</td>
</tr>
<tr class="odd">
<td><code>isalpha</code></td>
<td>判断字符串是否全部由字母组成</td>
</tr>
<tr class="even">
<td><code>isdecimal</code></td>
<td>判断字符是否全部由十进制的数字组成，不包括中文、罗马字符</td>
</tr>
<tr class="odd">
<td><code>isdigit</code></td>
<td>判断字符串只包含数字，不包括中文数字</td>
</tr>
<tr class="even">
<td><code>isnumeric</code></td>
<td>判断字符串是否全部由数字组成，中文数字也算</td>
</tr>
<tr class="odd">
<td><code>isalnum</code></td>
<td>判断字符串是否由字母和数字组成</td>
</tr>
<tr class="even">
<td><code>islower</code></td>
<td>判断字符串中的字符是否全部为小写，字符串至少有一个字符</td>
</tr>
<tr class="odd">
<td><code>isupper</code></td>
<td>判断字符串中的字符是否全部为大写，字符串至少有一个字符</td>
</tr>
<tr class="even">
<td><code>istitle</code></td>
<td>判断字符串是否标题话，见<code>titile</code></td>
</tr>
<tr class="odd">
<td><code>isascii</code></td>
<td>如果字符串为空或字符串中的所有字符都是 ASCII，则返回 <code>True</code>，否则返回<code>False</code>。</td>
</tr>
<tr class="even">
<td><code>isprintable</code></td>
<td>如果所有字符都是可打印的，则<code>isprintable()</code>方法返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&amp;&quot;</span>.isidentifier())<span class="comment">#False,&amp;为非法标识符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   t&quot;</span>.isspace())<span class="comment">#False,&quot;t&quot;为非空</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aldflafd你好&quot;</span>.isalpha())<span class="comment">#ture,中文也可以</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isdecimal())<span class="comment">#False,中文不属于十进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isnumeric())<span class="comment">#True,中文、罗马字符的数字也算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123abc&quot;</span>.isalnum())<span class="comment">#True,只能字母和数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isdigit())<span class="comment">#False，不能包括中文</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.islower())<span class="comment"># False,不能为空字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;TLUHBH&quot;</span>.isupper())<span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My Name Is Qlee&quot;</span>.istitle())<span class="comment">#True,只有第一个字符为大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是中国人&quot;</span>.isascii())<span class="comment">#False，中文不属于ascii</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello!\nAre you ?&quot;</span>.isprintable()) <span class="comment">#False,\n不可打印</span></span><br></pre></td></tr></table></figure>
<h4 id="模式匹配">6. 模式匹配</h4>
<p>字符串对象的方法能够支持基于模式的文本出处理，文本的模式匹配是一个高级工具，需要导入一个re模块，这个模块包含了搜索、分割和替换等调用。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re;</span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;Hello  se es ra df world&quot;</span>;</span><br><span class="line">match=re.match(<span class="string">&#x27;Hello[\t]*(.*)world&#x27;</span>,<span class="built_in">str</span>);</span><br><span class="line">gr=match.group(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(gr);</span><br></pre></td></tr></table></figure> 上面这个例子是在以Hello未开始，后面接这几个或零个制表符或空格的，接着将任意字符保存至组中，后以world结尾的str， 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">se es ra df</span><br></pre></td></tr></table></figure></p>
<h4 id="列表list">7. 列表(list)</h4>
<p>python的列表对象是一个任意类型对象的位置相关的有序集合，没有固定大小，不像C++数组那样，它没有固定类型的约束，同时python的核心数据类型一个优秀特性就是能支持任意类型的嵌套。<strong>同字符串不同，列表是可变对象，支持在原处修改</strong>，总结性质如下：</p>
<ul>
<li>列表是保持从左到右的序列，列表内存储的元素没有类型限制，也支持任意嵌套</li>
<li>列表可以像字符串一样索引、分片和合并</li>
<li>与字符串不同的是，列表是可变的，支持在原处修改。同时列表的长度可以改变</li>
<li>在python解释器内部，列表就是C数组，而不是链结构</li>
<li>存储的是对象引用，而不是拷贝，因此从这来看很像C/C++的指针数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#包含了整型、字符串、浮点数</span></span><br><span class="line">L=[<span class="number">123</span>,<span class="string">&quot;spam&quot;</span>,<span class="number">1.23</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">#一些接口</span></span><br><span class="line">append(<span class="built_in">object</span>, /)	<span class="comment">#将任意object在列表尾部插入</span></span><br><span class="line">pop();				<span class="comment">#移除给定偏移项</span></span><br><span class="line">insert();			<span class="comment">#插入元素</span></span><br><span class="line">remove（）;			<span class="comment">#按照值移除</span></span><br><span class="line">sort();				<span class="comment">#安照默认的升序排序</span></span><br><span class="line">reverse();			<span class="comment">#翻转</span></span><br><span class="line"><span class="keyword">del</span> L[i]			<span class="comment">#删除指定位置元素</span></span><br></pre></td></tr></table></figure>
<h4 id="列表解析">8. 列表解析</h4>
<p>处理序列和列表的方法中，python还包括了一个更高级的的操作，称为列表解析表达式.<strong>列表解析最常应用迭代协议的环境之一</strong>，列表解析把任意一个表达式应用于一个迭代对象中的元素。它可提供一种处理矩阵这样的数据结构。假如现在要从矩阵中提取第二列，使用列表解析可以很简单提取出来：<code>row[1]for row in AOI_world</code>,这种表达式有许多玩法，如<code>row[1]for row in AOI_world if row[1]%2==0</code></p>
<ul>
<li>列表解析编写代码比for循环更精简</li>
<li>执行速度更快</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AOI_world=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]];</span><br><span class="line">col2=[row[<span class="number">1</span>]<span class="keyword">for</span> row <span class="keyword">in</span> AOI_world];</span><br><span class="line"><span class="built_in">print</span>(col2);</span><br><span class="line"></span><br><span class="line"><span class="comment">#更爽的用法,rstrip函数去除右边的空白，使用if滤除开头不为p的字符串</span></span><br><span class="line">lines=[line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">if</span> line[<span class="number">0</span>]==<span class="string">&#x27;p&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure> 当然其他相关函数内容如<code>map</code>，<code>filter</code>还未介绍，但列表解析这里可以涉及一些。列表解析说白了，就是把任意一个表达式应用于一个可迭代对象中的元素，并将结束收集到一个新列表中。列表解析能够成为比<code>filter,map</code>更有用的函数工具： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用map</span></span><br><span class="line">res=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>,<span class="string">&#x27;trluper&#x27;</span>));</span><br><span class="line"><span class="comment">#用列表解析</span></span><br><span class="line">res=[<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;trluper&#x27;</span>];</span><br><span class="line"><span class="comment">#使用if的列表解析能有与filter一样的过滤功能</span></span><br><span class="line">res=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"><span class="comment">#嵌套for循环</span></span><br><span class="line">res=[x+y <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]];</span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：列表解析会产生一个新列表对象。</p>
<h4 id="字典dictionary">9. 字典(Dictionary)</h4>
<p>字典是一种映射，是一个键值对集合，通过键值获取相应的值，字典具有可变性，可以随需求增大或减小，像列表那样。字典页可以嵌套，性质总结：</p>
<ul>
<li>字典其实就是散列表也叫哈希表，通过键对生成哈希码而找到值，通过键值对映射类型</li>
<li>与列表不同，字典是无序，保存在字典中的项没有特定的顺序，因此不支持序列操作，如下标访问，是通过键值访问，键值是不可重复的</li>
<li>与列表一样，可变长，存储的元素可为任意类型，支持任意嵌套，可以在原处修改；存储的是对象引用，而不是拷贝 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keyValue_test=&#123;<span class="string">&#x27;food&#x27;</span>:<span class="string">&#x27;fish&#x27;</span>,<span class="string">&#x27;quantity&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;price&#x27;</span>:<span class="number">50</span>&#125;;</span><br><span class="line">fod_name=keyValue_test[<span class="string">&#x27;food&#x27;</span>];</span><br></pre></td></tr></table></figure> <strong>字典常用函数：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;fish&quot;</span> <span class="keyword">in</span> keyValue;		<span class="comment">#键存在判断</span></span><br><span class="line">D.keys();				<span class="comment">#返回所有键,可迭代对象</span></span><br><span class="line">D.values();				<span class="comment">#返回所有值,可迭代对象</span></span><br><span class="line">D.items();				<span class="comment">#键+值,可迭代对象</span></span><br><span class="line">D.copy();				<span class="comment">#拷贝</span></span><br><span class="line">D.get(key,\);			<span class="comment">#返回key对应的值，相当于D[key]</span></span><br><span class="line">D.update(D1);			<span class="comment">#合并字典</span></span><br><span class="line">D.pop(key);				<span class="comment">#删除键值对</span></span><br><span class="line"><span class="built_in">len</span>(D);					<span class="comment">#长度</span></span><br><span class="line"><span class="keyword">del</span> D[key];</span><br><span class="line"><span class="built_in">list</span>(D.keys())			<span class="comment">#生成键序列</span></span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>clear()</code></td>
<td>删除字典内所有元素</td>
</tr>
<tr class="even">
<td><code>copy()</code></td>
<td>返回一个字典的浅复制</td>
</tr>
<tr class="odd">
<td><code>fromkeys(seq[, val])</code></td>
<td>创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td>
</tr>
<tr class="even">
<td><code>get(key, default=None)</code></td>
<td>返回指定键的值，如果值不在字典中返回default值</td>
</tr>
<tr class="odd">
<td><code>has_key(key)</code></td>
<td>如果键在字典dict里返回true，否则返回false</td>
</tr>
<tr class="even">
<td><code>items()</code></td>
<td>以列表返回可遍历的(键, 值) 元组数组</td>
</tr>
<tr class="odd">
<td><code>keys()</code></td>
<td>以列表返回一个字典所有的键</td>
</tr>
<tr class="even">
<td><code>setdefault(key, default=None)</code></td>
<td>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr class="odd">
<td><code>update(dict2)</code></td>
<td>把字典dict2的键/值对更新到dict里</td>
</tr>
<tr class="even">
<td><code>values()</code></td>
<td>以列表返回字典中的所有值</td>
</tr>
<tr class="odd">
<td><code>pop(key[,default])</code></td>
<td>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td>
</tr>
<tr class="even">
<td><code>popitem()</code></td>
<td>返回并删除字典中的最后一对键和值。</td>
</tr>
</tbody>
</table>
<h5 id="键的排序">9.1 键的排序</h5>
<ul>
<li><p>因为字典不是序列，不包含任何可靠的从左到右的顺序排序方法，当我们需要强调某种顺序时，一个常用方法就是通过字典的keys方法收集一个键的列表，使用列表的<code>sort</code>方法进行排序： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_list=<span class="built_in">list</span>(d.keys());</span><br><span class="line"><span class="built_in">print</span>(key_list);</span><br><span class="line">key_list.sort();</span><br><span class="line"><span class="built_in">print</span>(key_list);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;quantity&#x27;</span>, <span class="string">&#x27;buyer&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;buyer&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;quantity&#x27;</span>]</span><br></pre></td></tr></table></figure></p></li>
<li><p>第二种方法是通过使用最新的<code>sorted</code>内置函数可以一步完成，<code>sorted</code>调用后会返回排序后的新列表对象 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="built_in">sorted</span>(d);</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(key,<span class="string">&quot;==&gt;&quot;</span>,d[key]);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buyer ==&gt; TOM</span><br><span class="line">food ==&gt; fish</span><br><span class="line">price ==&gt; <span class="number">50</span></span><br><span class="line">quantity ==&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="set集合">10. set集合</h4>
<p>set集合是无序的，它既不是映射也不是序列，可以说它是存储无值的键，而且键值唯一不可变</p>
<p>创建集合对象： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python2.6版</span></span><br><span class="line">x=<span class="built_in">set</span>(<span class="string">&#x27;abcde&#x27;</span>);</span><br><span class="line">y=<span class="built_in">set</span>(<span class="string">&#x27;bdxyz&#x27;</span>);</span><br><span class="line"></span><br><span class="line">z=x&amp;y</span><br><span class="line"><span class="built_in">print</span>(z);</span><br><span class="line"></span><br><span class="line">i=x.intersection(y);</span><br><span class="line"><span class="built_in">print</span>(i);</span><br><span class="line">x.add(<span class="string">&#x27;trluper&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line">x.update(<span class="built_in">set</span>([<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;y&#x27;</span>]));</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line">x.remove(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.0</span></span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="元组tuple">11. 元组(tuple)</h4>
<p>元组对象是一个不可改变的列表，他有列表的有序性，但没有列表的可变性，和字符串类似。它们编写在圆括号<code>()</code>而不是<code>[]</code>和<code>&#123;&#125;</code>内,<strong><code>()</code></strong>时可选的，不是必须，。它们支持任意类型和任意嵌套。元组提供了不可变这一项约束是使用它的原因，否则使用列表。性质总结：</p>
<ul>
<li>元组是位置有序的对象集合，因此支持下标访问，支持分片。</li>
<li>与字符串一样，元组是不可比变的，不能在原处进行修改。因此元组也就是长度不可变的，在不生产一个新对象下不能增长或缩短</li>
<li>元组内的元素可为任意类型且为引用，而不是拷贝，支持任意嵌套</li>
<li>元组不支持任何方法调用，但是支持字符串和列表的一般序列操作：合并、倍乘、分块</li>
</ul>
<p>一般操作： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T=(elements);   <span class="comment">#创建元组</span></span><br><span class="line">T=i,j,k,l		<span class="comment">#省略()创建元组</span></span><br><span class="line">T[j];			<span class="comment">#访问</span></span><br><span class="line">T[i:j];			<span class="comment">#分块</span></span><br><span class="line"><span class="built_in">len</span>(T);			<span class="comment">#长度</span></span><br><span class="line">T1+T2;			<span class="comment">#合并</span></span><br><span class="line">T*<span class="number">3</span>;			<span class="comment">#内容倍乘</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> T:		<span class="comment">#迭代</span></span><br><span class="line">“trlupe<span class="string">r&quot; in T;	#元组内是否有该元素</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></p>
<p>在python3.0以上，有元组的专有调用方法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index(element);		<span class="comment">#查询元素下标</span></span><br><span class="line">count(element);		<span class="comment">#统计元素出现过几次</span></span><br></pre></td></tr></table></figure></p>
<h4 id="文件">12. 文件</h4>
<p>文件对象提供了python编程对外部文件操作的接口，要创建一个文件对象，就必须调用内置的<code>open</code>函数打开问文件： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_object=<span class="built_in">open</span>(<span class="string">&quot;*.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure> 除了<code>open</code>这个函数，python还有额外的类文件工具：管道、FIFO、套接字、通过键访问文件、对象吃久、基于描述符的文件、关系数据库等.</p>
<p><strong>文件常用函数接口：</strong></p>
<p><img src="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/file.jpg" width="600"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_name=<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">lines=file_name.readlines();	<span class="comment">#读取整个文件到列表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><em>注意：</em></strong>在写入时，我们必须将对象转换成字符串，同样在读出时，我们也必须用转换工具将文本文件中的字符串转换乘python对象</p>
<h4 id="python的动态类型">13. python的动态类型</h4>
<h5 id="动态类型是什么">13.1 动态类型是什么</h5>
<p>python的动态类型是为什么在python不必声明变量的存在和类型的缘由。<strong>python使用动态类型和他提供的多态性来提供python语言的简洁灵活的基础。在python中我们是不会声明所使用对象的确切类型的。所谓的python动态类型，就是在程序运行的过程中自动决定对象的类型。</strong></p>
<ul>
<li>与C/C++明显不同的是，在python中，变量只是一个名字，它永远不会有任何类型约束，变量是通用的，在python中类型的概念只存在于对象中。</li>
<li>变量在赋值的时候才创建，即没有声明，当变量出现在表达式中，它会被当前引用的对象所替代，无论该对象是什么类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">就如a=<span class="number">3</span>这个简单的赋值语句，python分步：</span><br><span class="line">	<span class="number">1.</span>创建一个对象代表<span class="number">3</span>，</span><br><span class="line">　　<span class="number">2.</span>如果程序中没有变量a，则创建他。</span><br><span class="line">　　<span class="number">3.</span>将变量与对象<span class="number">3</span>连接起来。</span><br></pre></td></tr></table></figure>
<ul>
<li>变量和对象保存在内存中的不同部分，变量只是对对象的引用，这样来说变量更像是C/C++中的<code>void*</code>指针
<ul>
<li><ol type="1">
<li>变量是系统表的元素，他指向对象存放的地址空间</li>
</ol></li>
<li><ol start="2" type="1">
<li>对象是分配的一块内存，地址可被连接，有足够大空间代表对象的值，每个对象都有两个标准头部信息:一是类型标识符（标识对象类型），二是引用计数器（垃圾回收）。</li>
</ol>
<ul>
<li>2.1 <strong>类型标识符</strong>：对象知道自己的类型，一旦与变量连接，程序执行中也就知道变量是引用了哪种类型的对象。</li>
<li>2.2 <strong>引用计数</strong>：每当对象被引用到一个变量是，其引用计数会+1，反之则-1，当引用计数为0是，该对象的内存空间被自动回收，这种性质很想C++的智能指针<code>shared_ptr</code>，意味着我们在使用过程中不需要考虑对象内存释放的问题.</li>
<li>2.3 引用的过程自动完成变量指向对象地址的过程，即从变量到对象的指针</li>
</ul></li>
</ul></li>
</ul>
<h5 id="共享引用">13.2. 共享引用</h5>
<ul>
<li><p>之前我们就提到过，在python中对象是不可变性的，一旦发生改变便意味这新对象的产生。共享引用也是如此： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span>; <span class="comment">#a指向对象，对象值为3，对象引用为1</span></span><br><span class="line">b=a; <span class="comment">#b也指向该对象，对象引用为2</span></span><br><span class="line">b=b+<span class="number">2</span>; <span class="comment">#产生新对象5，引用计数为1，a所引用的对象仍为3，引用计数为1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>但有一些对象和操作也确实会在原处修改对象，如列表、字典以及一些通过<code>class</code>语句定义的对象，对列表的一个位置进行赋值会改变这个列表对象，而不是生成一个新列表（想想也是，如果每次都有生成一个新列表，那么对于数量极大的列表来说，其消耗的时间是极大的）,如果不想这样，使用<code>copy</code>函数进行拷贝成一个新对象，指向内容相同但内存不同 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同上面一样创建了新对象42，没有影响原对象</span></span><br><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">L1=L2;</span><br><span class="line">L2=<span class="number">42</span>;</span><br><span class="line"><span class="comment">#原处修改,L1和L2均变为[42,2,3]</span></span><br><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">L1=L2;</span><br><span class="line">L1[<span class="number">0</span>]=<span class="number">42</span>;</span><br><span class="line"><span class="comment">#copy函数防止原处修改，</span></span><br><span class="line"><span class="keyword">import</span> copy;</span><br><span class="line">L2=copy.copy(L1);</span><br></pre></td></tr></table></figure></p></li>
<li><p>共享引用和相等：<code>==操作符</code>，测试两个引用对象值是否相同；<code>is操作符</code>,检查对象的同一性，是否内存地址一样</p></li>
</ul>
<h5 id="引用和拷贝">13.3.引用和拷贝</h5>
<p>到这里，应该知道了引用和拷贝的区别：</p>
<ul>
<li>引用是指变量名指向对象，多个引用都是指向同意内存地址</li>
<li>而拷贝是对原对象的一份拷贝，会在PVM中开辟一份自己的内存地址存储</li>
</ul>
<p>在python中赋值操作总是存储对象的引用，而不是拷贝。如果有些时候我们不希望因多个对象的引用中的改变而造成影响（如上面所举列表例子），那么就应该用拷贝：</p>
<ul>
<li>没有限制条件的分片语句会产生一份拷贝</li>
<li><code>copy</code>方法产生一份拷贝</li>
<li>一些内置函数，如<code>list(L)</code>产生一份拷贝</li>
</ul>
<h4 id="python语句">14. python语句</h4>
<h5 id="与cc完全不同点">14.1 与C/C++完全不同点</h5>
<ul>
<li>python中所有的嵌套语句的首行以<code>:</code>结尾</li>
<li>python中不像C/C++,可省略嵌套语句的<code>()</code>，如<code>if x&gt;y:</code>,如果单条if，则必须加<code>()</code></li>
<li>每个语句最后的<code>;</code>不是必须的，可省略，但是当一行有多条语句用<code>;</code></li>
<li>缩进的结束就是代码块的结束，python没有用<code>&#123;&#125;</code>来标识代码块，而是看缩进</li>
</ul>
<h5 id="赋值和打印">14.2 赋值和打印</h5>
<h6 id="赋值">14.2.1 赋值</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;trluper&quot;</span></span><br><span class="line"><span class="built_in">str</span>,s=<span class="string">&quot;trl&quot;</span>,<span class="string">&quot;uper&quot;</span></span><br><span class="line">a,b,c,d=<span class="string">&#x27;trlu&quot;	#a=&#x27;</span>t<span class="string">&#x27;,b=&#x27;</span><span class="string">r&#x27;,c=&#x27;</span>l<span class="string">&#x27;,d=&#x27;</span><span class="string">u&#x27;</span></span><br><span class="line"><span class="string">a,*b=&quot;trluper&quot; #a=&#x27;</span>t<span class="string">&#x27; b=[&#x27;</span><span class="string">r&#x27;,&#x27;</span>l<span class="string">&#x27;,&#x27;</span><span class="string">u&#x27;,&#x27;</span>p<span class="string">&#x27;,&#x27;</span>e<span class="string">&#x27;,&#x27;</span><span class="string">r&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>在上面的表达式可以看到，<code>*b</code>并不是C/C++中的指针，而是告诉赋值表达式变量<code>b</code>匹配剩下的内容成列表</p>
<h6 id="打印">14.2.2 打印</h6>
<p>python中<code>print</code>的语法:<code>print([object,...][,sep=' '][,end='\n'][,file=sys.stdout]);</code>在表示中，方括号的的项是可选的，且这些参数跟在要打印的对象后面，以<code>name=value</code>形式出现。</p>
<ul>
<li><code>object</code>指要打印的对象</li>
<li><code>sep</code>表示没打印一个对象，都有输出一个空格。(没有显式传递，则默认` `)</li>
<li><code>end</code>表示在打印末尾输出换行符（没有传递就默认<code>\n</code>）</li>
<li><code>file</code>表示要将这些对象输出给文件、标准流还是其他文件对象。(没有显示说明，则默认<code>sys.stdout</code>)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log=<span class="built_in">open</span>(<span class="string">r&#x27;D:\Python_WorkSpace\test.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;唱&quot;</span>,<span class="string">&quot;跳&quot;</span>,<span class="string">&quot;rap&quot;</span>,<span class="string">&quot;篮球&quot;</span>,sep=<span class="string">&#x27;*&#x27;</span>,end=<span class="string">&#x27;\n&#x27;</span>,file=log);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="python的布尔值">14.3 python的布尔值</h5>
<p>对于python的<code>bool</code>类型来说，其<code>true</code>和<code>false</code>的判断：</p>
<table>
<thead>
<tr class="header">
<th>情况</th>
<th>True/False</th>
<th>情况</th>
<th>True/False</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>none</code></td>
<td><code>F</code></td>
<td>空<code>map&#123;&#125;</code></td>
<td><code>F</code></td>
</tr>
<tr class="even">
<td>数值<code>0</code></td>
<td><code>F</code></td>
<td><code>False</code></td>
<td><code>F</code></td>
</tr>
<tr class="odd">
<td>空序列</td>
<td><code>F</code></td>
<td>对象为空</td>
<td><code>F</code></td>
</tr>
</tbody>
</table>
<h5 id="判断循环语句">14.4 判断循环语句</h5>
<h6 id="ifelifelse">14.4.1 if/elif/else</h6>
<p>python中没有C/C++中的<code>switch case</code>语句块，要做判断选择只有用<code>if</code>语句,在python中没有<code>&#123;&#125;</code>作为语句块边界标识，只能靠左侧的缩进来判断语句属于哪一部分:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a==b <span class="keyword">and</span> c==d <span class="keyword">and</span> d==e):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;相等&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> c==d <span class="keyword">and</span> d==e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;cde相等&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;不相等“)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#三目运算</span></span><br><span class="line"><span class="string">A=Y if X else Z;	#X为真时A=Y,false时为A=Z</span></span><br></pre></td></tr></table></figure>
<h6 id="while语句">14.4.2 while语句</h6>
<p><code>while</code>语句书写格式时：首行以及测试表达式，内部有一行或多行缩进语句主题执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">0</span>;b=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> a&lt;b:</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">    a+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;a不小于b&quot;</span>)</span><br></pre></td></tr></table></figure>
<h6 id="for语句">14.4.3 for语句</h6>
<p><code>for</code>循环不同与c/c++，在python中，它通常是用作序列迭代器，可以遍历任何有序的序列对象内的元素，可用于字符串、列表、元组、其他内置可迭代对象； <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;target&gt; <span class="keyword">in</span> &lt;<span class="built_in">object</span>&gt;:</span><br><span class="line">	&lt;Options&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	&lt;Options&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 当运行<code>for</code>循环时,PVM会将序列对象中的元素赋值給<code>target</code>,然后在循环主题中对其进行操作。<code>for</code>循环的循环变量<code>target</code>可以是任何赋值目标(反正执行完一次后就会重新赋值，引用)。因此<code>for</code>对序列的任意嵌套都能解包。</p>
<h5 id="其他循环">14.5 其他循环</h5>
<h6 id="range函数跳遍历">14.5.1 range函数跳遍历</h6>
<p><code>range函数</code>常用在<code>for循环</code>中用来产生索引，但也可以用在任何需要整数列表的地方。<code>range</code>是一个跌代器，会根据需要产生元素： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">5</span>);	<span class="comment">#生成0，1，2，3，4</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>,<span class="number">5</span>);	<span class="comment">#生成2，3，4</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>); <span class="comment">#生成0，2，4，6，8</span></span><br><span class="line"><span class="comment">#应用,遍历X跳一个输出,其实就是相当与while循环，条件+2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(X),<span class="number">2</span>):</span><br><span class="line">	<span class="built_in">print</span>(X[i],end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure> 根据上面的解释可知：</p>
<ul>
<li>传一个参数时，会产生从0算起的整数，不包括参数值</li>
<li>传两个参数时，第一个为起始值，第二个为最大不包括值</li>
<li>传三个参数时，第三个为步进值</li>
</ul>
<h6 id="并行遍历zip和map">14.5.2 并行遍历zip和map</h6>
<p><strong><code>zip</code>函数</strong>：传而对于<code>zip()</code>，原型是<code>zip(*list)</code>，<code>list</code>是一个列表，<code>zip(*list)</code>返回的是一个元组串，如果要转为元组列表，必须使用<code>list()</code>函数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">L2=[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">L3=<span class="built_in">zip</span>(L1,L2);	<span class="comment">#L3=(1,5),(2,6),(3,7),(4,8)</span></span><br><span class="line">L4=<span class="built_in">list</span>(<span class="built_in">zip</span>(L1,L2)) <span class="comment">#L4=[(1,5),(2,6),(3,7),(4,8)]</span></span><br><span class="line"><span class="comment">#并行遍历</span></span><br><span class="line"><span class="keyword">for</span> (x,y) <span class="keyword">in</span> L3:</span><br><span class="line">	<span class="built_in">print</span>(x,y,<span class="string">&quot;x+y=&quot;</span>,x+y);</span><br><span class="line">a2,b2=<span class="built_in">zip</span>(*<span class="built_in">zip</span>(L1,L2))  <span class="comment">#a2=(1,2,3,4) b2=(5,6,7,8)</span></span><br></pre></td></tr></table></figure> 事实上，<code>zip()</code>可以接受任何类型的序列（就是任何可迭代对象）。</p>
<p><strong><code>map函数</code>:</strong> 对于map()它的原型是<code>map(function,sequence)</code>，就是对序列sequence中每个元素都执行函数function操作.比如之前的<code>a,b,c = map(int,raw_input().split())</code>，意思就是说把输入的<code>a，b，c</code>转化为整数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="built_in">ord</span>,<span class="string">&#x27;spam&#x27;</span>);	<span class="comment">#ord为ascii转换为数字，结果为115，112，97，109</span></span><br></pre></td></tr></table></figure></p>
<h6 id="filter和reduce">14.5.3 filter和reduce</h6>
<p><code>filter</code>和<code>reduce</code>都会返回可迭代对象。在python3.0,需要用<code>list</code>调用来显示其所有结果。<code>filter</code>的作用是基于某一函数的过滤器。<code>reduce</code>是没对元素都应用函数得到最后结果 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>((<span class="keyword">lambda</span> x:x&gt;<span class="number">0</span>),<span class="built_in">range</span>(-<span class="number">5</span>,<span class="number">5</span>)));	<span class="comment">#[1,2,3,4]</span></span><br><span class="line">reduce((<span class="keyword">lambda</span> x,y:x+y),[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);			<span class="comment">#10</span></span><br></pre></td></tr></table></figure></p>
<h4 id="迭代器和解析">15. 迭代器和解析</h4>
<p>在上面提到的for循环和while循环能够处理重复性任务，但是序列迭代在程序中非常常见，因此python提供了额外工具来使得这项工作变得简单高效。</p>
<h5 id="文件迭代器">15.1. 文件迭代器</h5>
<h6 id="next__">15.1.1 <code>__next()__</code></h6>
<p>在文件类中，有一个方法<code>__next__()</code>,该方法每次调用时，就会返回文件的下一行，到达文件末尾时，会抛出StopIteration异常，而不是空字符串。像这样的接口就是python中所说的<strong><em>迭代协议</em></strong>.事实上，任何这类对象都认为时可迭代的，因为它们也能以<code>for循环</code>或其他迭代工具遍历，<strong><em>因为所有迭代工具内部工作原理都是调用<code>__next__()</code>，并且捕捉StopIteration异常来确定何时离开</em></strong></p>
<p><strong><em>迭代协议：Python 迭代协议由<code>__iter__</code>方法与<code>__next__</code>方法构成，若对象具有<code>__iter__</code>方法，称该对象为“可迭代对象（iterable object）”。若对象具有<code>__next__</code>方法，称该对象为“迭代器（iterator）”。<code>__iter__</code>方法必须返回一个迭代器对象，<code>__next__</code>方法不断的返回下一元素，或者抛出StopIteration。<code>__next__</code>方法是 Python 迭代协议的核心.<code>__iter__</code>方法是迭代协议的辅助——将可迭代对象转换成迭代器</em></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		s=file.__next__();</span><br><span class="line">	<span class="keyword">except</span> StopIteration:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="built_in">print</span>(s,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="用for循环推荐">15.1.2 用for循环(推荐)</h6>
<p>读取文本文件的最佳方式就是根本不要去读，其代替的方法就是让for循环每轮自动调用<code>__next__()</code>从而前进到下一行： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>):</span><br><span class="line">	<span class="built_in">print</span>(line,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure> 不建议使用<code>readlines</code>函数，因为<code>readlines</code>时一次性把文件加载到内存，且运行速度不如<code>for循环</code>.</p>
<h6 id="手动迭代">15.1.3 手动迭代</h6>
<p>为了支持手动迭代，python提供了一内置函数<code>next()</code>，他会自动调用一个对象的<code>__next__()</code>函数。即调用<code>next(X)</code>等价于<code>X.__next__()</code>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s=<span class="built_in">next</span>(file);</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(s,end=<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure> 另一方面，再深一点看，当for循环开始时，通过iter内置函数获得一个迭代器，返回的迭代器对象含有需要的next或<code>__next__()</code>方法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it=<span class="built_in">iter</span>(file);	//获取迭代器</span><br><span class="line"><span class="built_in">print</span>(file <span class="keyword">is</span> it);</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s= it.__next__();</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(s,end=<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="字典迭代">15.2. 字典迭代</h5>
<h6 id="获取键值列表再由遍历列表遍历字典">15.2.1 获取键值列表，再由遍历列表遍历字典</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D.keys():</span><br><span class="line">	<span class="built_in">print</span>(key,D[key]);</span><br></pre></td></tr></table></figure>
<h6 id="有字典的迭代器遍历">15.2.2 有字典的迭代器遍历</h6>
<p>字典有一个迭代器，在<strong><em>迭代的环境下（即for循环/while循环）</em></strong>会自动一次返回一个键，这样我们就不必生成键值序列来遍历： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it=<span class="built_in">iter</span>(D);	<span class="comment">#获得字典的迭代器</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">		<span class="comment">#s=it.__next__();</span></span><br><span class="line">        l=<span class="built_in">next</span>(it);</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(l,D[l]);</span><br><span class="line"></span><br></pre></td></tr></table></figure> 因此可简写for循环：（推荐） <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D:</span><br><span class="line">    <span class="built_in">print</span>(key,D[key]);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="其他迭代环境">15.3 其他迭代环境</h5>
<p>上面介绍的迭代环境是在<strong>for循环</strong>看的以及之前讲到过的<strong>列表解析</strong>也有迭代协议。其实，<strong><code>in成员测试</code>、<code>map</code>内置函数以及像<code>sorted</code>（调用后会返回排序后的列表对象）和<code>zip</code>调用这样的内置函数也使用了迭代协议</strong>。<strong><em>当应用于文件时，文件对象的迭代器都自动扫描：</em></strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>.upper,<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>))); <span class="comment">#[&quot;ADC&quot;,&quot;DADA&quot;,&quot;SSDA&quot;]</span></span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>));				<span class="comment">#[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<h4 id="函数">16. 函数</h4>
<p>作为一位C/C++、java程序员，需要了解python函数体系下的函数相关语句和表达式,因为它们有很大的不同点:</p>
<ul>
<li><code>def</code>是可执行代码，python的函数由<code>def</code>语句编写，<strong>函数只有当<code>def</code>运行后才存在，这就意味着不能在函数未运行时就去调用</strong>。</li>
<li><code>def</code>创建了一个对象并将其赋值给某一个变量，即函数名只是函数对象的引用。</li>
<li><code>lambda</code>创建一个对象但将其作为结果返回。使用<code>lambada</code>表达式创建函数，运行将函数定义内联到语法上一条<code>def</code>语句不能工作的地方。</li>
<li><code>yield</code>向调用者发回结果对象，<strong>但会记住它离开的地方</strong></li>
<li><code>global</code>声明了一个模块的变量并被赋值。默认情况下所有在一个函数总被赋值的对象，仅在函数作用域中有效。如要使得它在整个模块中都可使用，函数需要<code>global</code>语句声明</li>
<li><code>nonlocal</code>声明了将要赋值的一个封闭函数变量</li>
</ul>
<h5 id="def">16.1 def</h5>
<p><code>def</code>语句将创建一个函数对象并将其赋值给一个变量名，格式如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(arg1,arg2,arg3,...):</span><br><span class="line">	functions-body;</span><br><span class="line"></span><br></pre></td></tr></table></figure> python中所有语句都是实时运行的，没有像独立编译时间这样的流程。<strong><em>python函数在程序运行之前并不需要全部定义，因为<code>def</code>在运行时评估，而<code>def</code>里面的函数体调用时才评估（与C/C++不同) </em></strong>。一个<code>def</code>语句可以出现在任何地方，比如<code>if</code>,<code>while</code>甚至是<code>def</code>嵌套也是合法的： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> test:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_func</span>():</span><br><span class="line">		....</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_func1</span>():</span><br><span class="line">		....</span><br><span class="line"></span><br><span class="line"><span class="comment">#嵌套</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">	x=<span class="number">99</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">		<span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">			<span class="built_in">print</span>(x);</span><br><span class="line">		f3();	<span class="comment">#调用</span></span><br><span class="line">	f2();		<span class="comment">#调用</span></span><br><span class="line"></span><br><span class="line">f1();</span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：当我<code>def</code>嵌套时，必须在上一层函数调用嵌套函数</p>
<h5 id="python中的多态">16.2 python中的多态</h5>
<p>对于python中函数的作用，会根据传入参数的不同而有些许不同： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">times</span>(<span class="params">x,y</span>):</span><br><span class="line">	<span class="keyword">return</span> x*y;</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">times(<span class="number">2</span>,<span class="number">4</span>);	<span class="comment">#return 8</span></span><br><span class="line">times(<span class="string">&quot;tr&quot;</span>,<span class="number">4</span>);	<span class="comment">#return trtrtrtr</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 可以看到<code>times</code>实现的功能的意义完全依赖于参数<code>x</code>和<code>y</code>的类型，<strong><em>这种依赖类型的行为称为多态</em></strong>。可以说python的动态类型是实现python多态的前提条件。在python这种多头机制下，<strong>编写函数接口更多是为对象编写，而不是特定为一个类型</strong>，这样可以达到函数的复用，提升代码简易和高效性。</p>
<h5 id="作用域">16.3 作用域</h5>
<p>在代码编写过程中，变量可以在三个不同地方辅助，其对应的作用域：</p>
<ul>
<li>变量在一个<code>def</code>赋值，其作用域只在该函数有效</li>
<li>变量在<code>def</code>之外赋值，从赋值地方开始到文件结尾都有效</li>
<li>变量在嵌套<code>def</code>内，只在内层<code>def</code>内有效</li>
</ul>
<h6 id="作用域法则">16.3.1 作用域法则</h6>
<ol type="1">
<li>全局作用域的作用范围仅限单个文件。要是有其他模块的变量名，必须导入模块</li>
<li>导入模块的作用域是全局的</li>
<li>每次函数调用都创建一个新的本地作用域</li>
<li>在函数赋值的变量名除非声明为<code>global</code>或者<code>nonlocal</code>变量，否则默认为本地变量。<code>global</code>将位于函数内的变量变为全局（位于模块文件内部的顶部），<code>nonlocal</code>将嵌套函数内的变量声明为非本地</li>
<li>python执行过程变量搜索路径：<code>本地作用域--&gt;上一层结构def或lambda的本地作用域--&gt;全局作用域--&gt;内置作用域</code></li>
</ol>
<h6 id="global">16.3.2 global</h6>
<p><code>global</code>不是一个类型或者大小的声明，而是<strong><em>命名空间的声明</em></strong>，它告诉编译器python函数打算生成一个或多个全局变量名 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用法1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_func</span>(<span class="params">x,y</span>):</span><br><span class="line">	<span class="keyword">global</span> z;</span><br><span class="line">	z=x+y;</span><br><span class="line">func(<span class="number">2</span>,<span class="number">4</span>)；</span><br><span class="line"><span class="built_in">print</span>(z);	<span class="comment">#输出6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用法2，告诉函数x不是本地的，而是全局的（主要用法：将在函数内修改的全局变量保存）</span></span><br><span class="line">x=<span class="number">22</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">   <span class="keyword">global</span> x;</span><br><span class="line">   x=<span class="number">99</span></span><br><span class="line">f1();</span><br><span class="line"><span class="built_in">print</span>(x);	<span class="comment">#输出99</span></span><br></pre></td></tr></table></figure></p>
<h6 id="nonlocal">16.3.3 nonlocal</h6>
<p>与<code>global</code>一样，<code>nonlocal</code>也是将变量在嵌套作用中的修改保存下来。与<code>global</code>不同之处在于：<code>global</code>是对<code>def</code>之外的全局变量作用，而<code>nonlocal</code>更严格，是对嵌套的的变量，这样达到能够使内层嵌套对变量的修改能够保存。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_func1</span>(<span class="params">a,<span class="built_in">str</span></span>):</span><br><span class="line">	x=a;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">		<span class="keyword">nonlocal</span> x</span><br><span class="line">		x+=<span class="number">20</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">str</span>,x);	<span class="comment">#这是一个nonlocal测试 21</span></span><br><span class="line">	_f(<span class="built_in">str</span>);</span><br><span class="line">	<span class="built_in">print</span>(x);			<span class="comment">#21</span></span><br><span class="line"></span><br><span class="line">_func1(<span class="number">1</span>,<span class="string">&quot;这是一个nonlocal测试&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="参数">17. 参数</h4>
<h5 id="引用传递">17.1 引用传递</h5>
<p>要努力区别python的传参机制和C++引用参数，对于python来说：</p>
<ul>
<li><strong>不可变参数通过“值”传递，虽然像整数、字符串这些是通过对象的引用进行传递的，但是它们的不可变性导致我们不可能在原处改变，一旦执行给变量赋新值，意味这新对象产生，变量只是新对象的一份引用。</strong>（这样来看它的效果其实就是C++中的按值传递，即发生了一份拷贝）</li>
<li><strong>可变对象时通过“指针”进行传递的。虽然列表、字典这样的对象实际上也是通过引用来传递，但效果却和不可变参数完全不同，因为它们支持原处修改，因此函数内发生的改变能够保存。</strong>（这就像C++中传递数组很像）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">2</span>;</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x</span>):</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">isinstance</span>(x,<span class="built_in">list</span>):</span><br><span class="line">		x[<span class="number">0</span>]=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">	<span class="keyword">elif</span> <span class="built_in">isinstance</span>(x,numbers.Number):</span><br><span class="line">		x=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">test(a);</span><br><span class="line"><span class="built_in">print</span>(a);	<span class="comment">#2</span></span><br><span class="line">test(b);</span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#[20,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>python通过引用来传参，意味着我们不需要进行多余的拷贝操作，能够节约内存和运行时间，同时也就支持可传递很大对象。如果我们要抑制因传入可变参数而带来的修改，可以在传入时拷贝一份作为参数<code>test(copy(b));</code></p>
<h5 id="返回值">17.2 返回值</h5>
<p><code>return</code>语句能够返回任意种类对象，所有也能够返回多个值（指的是封装进元组或列表这样的集合里）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">	x=<span class="number">2</span>;</span><br><span class="line">	y=[<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">return</span> x,y;</span><br><span class="line"></span><br><span class="line">l=func();	<span class="comment">#(2,[3,4])</span></span><br></pre></td></tr></table></figure> 上面的函数返回了元组(2,[3,4])。（因为元组的<code>()</code>不是必须的）</p>
<h5 id="参数匹配模型">17.3 参数匹配模型</h5>
<p>这些匹配模型的底层传参机制仍有是引用赋值：</p>
<ul>
<li>位置参数：默认模式，通过从左到右参数匹配(位置：调用者)</li>
<li>关键字参数；设置传参默认值，<code>name=value</code>形式，意思是当我们执行从左到右匹配，发现某参数没有传入，则调用时使用默认值(位置：被调函数)</li>
<li>关键字参数：<code>name=value</code>还可以指定我们调用时参数传递给哪一个参数变量，破环了默认模式，即不必遵循从左到右匹配，而是按名字匹配,如<code>print(&quot;trluper&quot;,sep=' ',end=' ',file=sys,stdout);</code>（位置：调用者）</li>
<li>可变参数列表，在函数的参数中有<code>*</code>号，意味着该函数支持可变参数列表，即支持传递任意个参数。单个<code>*</code>指对元组，<code>**</code>是对字典,<strong>即指在调用的时候我们传递给函数的参数会被打包参数位置信息的元组序列或者字典对象</strong>，对函数来说它会解包</li>
</ul>
<p>示例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位置参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,c</span>):</span><br><span class="line">	<span class="built_in">print</span>(a,b,c);</span><br><span class="line"><span class="comment">#关键字参数name=value形式调用</span></span><br><span class="line">f(a=<span class="number">2</span>,c=<span class="number">3</span>,b=<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#关键字参数,设置默认值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name=<span class="string">&#x27;Bob&#x27;</span>,age=<span class="string">&#x27;&#x27;</span>,jov=<span class="string">&#x27;engineer&#x27;</span></span>):</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line"><span class="comment">#*</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">*args</span>):</span><br><span class="line">	<span class="built_in">print</span>(args);</span><br><span class="line"><span class="comment">#调用时打包成元组</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)		<span class="comment">#(1,2,3,4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#**只对关键字参数有效，将关键字参数打包成字典</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">**args</span>):</span><br><span class="line">	<span class="built_in">print</span>(args);</span><br><span class="line">f(a=<span class="number">1</span>,b=<span class="number">2</span>);		<span class="comment">#&#123;&#x27;a&#x27;=1,&#x27;b&#x27;=2&#125;</span></span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：如要函数要混用这些模式，则顺序必须是<code>位置参数-&gt;关键字参数-&gt;*-&gt;**</code></p>
<h4 id="函数的高级话题">18. 函数的高级话题</h4>
<p>学习了函数，我们就必须要了解如何使函数聚合性更强，解耦合性能更好，设计函数的功能性。</p>
<h5 id="递归函数">18.1 递归函数</h5>
<p>较循环结构而言，对任意深度的嵌套，循环较难处理，而递归能够容易处理该类嵌套： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#能够处理任意嵌套</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L:<span class="string">&quot;可以是列表也可是元组&quot;</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">		<span class="keyword">if</span>  <span class="built_in">isinstance</span>(x,<span class="built_in">list</span>):</span><br><span class="line">			tot+=sumtree(x);</span><br><span class="line">		<span class="keyword">elif</span>  <span class="built_in">isinstance</span>(x,<span class="type">Tuple</span>):</span><br><span class="line">			tot+=sumtree(x);</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			tot+=x;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sumtree([<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],(<span class="number">3</span>,<span class="number">4</span>),<span class="number">5</span>,[<span class="number">7</span>,<span class="number">8</span>,[<span class="number">2</span>,<span class="number">3</span>]]])); <span class="comment">#38</span></span><br></pre></td></tr></table></figure></p>
<h5 id="属性存储和注解">18.2 属性存储和注解</h5>
<p>由于python函数是对象，函数对象可以赋值给其他的变量名、传递给其他函数、嵌入到数据结构、从一个函数返回给另一个函数等等。</p>
<h6 id="属性">18.2.1 属性</h6>
<p>函数除了调用以外，我们还可以检查它的<strong>属性</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sumtree.__name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(sumtree));</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sumtree</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__call__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__closure__&#x27;</span>, <span class="string">&#x27;__code__&#x27;</span>, <span class="string">&#x27;__defaults__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__get__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__globals__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__kwdefaults__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<h6 id="注解">18.2.2 注解</h6>
<p>python3.0以后，可以给函数对象附加注解信息---就是与函数的参数和结果相关的任意用户定义的数据。注解有它专有的语法，但它自身不做任何事情，注解是可选的，并且出现的时候只是直接附加在函数对象的<code>__annotations__</code>属性以供其他用户使用。语法：</p>
<ul>
<li>函数注解编写在def行</li>
<li>对于参数，它们出现在紧随参数名冒号的后面</li>
<li>对于返回值，它们编写于参数列表之后的<code>-&gt;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L:<span class="string">&quot;可以是列表也可是元组&quot;</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sumtree.__annotations__);	<span class="comment">#&#123;&#x27;L&#x27;: &#x27;可以是列表也可是元组&#x27;, &#x27;return&#x27;: &lt;class &#x27;int&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="lambda表达式">18.3. lambda表达式</h5>
<p>除了<code>def</code>之外，python提供了另一种函数对象的表达式，叫<code>lambada</code>也称匿名函数。这个表达式创建了一个之后能够调用的函数，但是它返回一个函数而不是将这个函数赋值给一个变量名，这也是为啥lambda叫匿名函数。</p>
<h6 id="lambda表达式格式">18.3.1 lambda表达式格式</h6>
<p>关键字lambda后面接参数列表，<code>:</code>后面为函数体 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arg1,rag2,...:</span><br><span class="line">	function_body;</span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong></p>
<ul>
<li>lambda是一个表达式，而不是语句。因为是一个表达式，所有它能出现在<code>def</code>不能出现的地方，如列表中、或者函数参数中等。同时它会返回一个新函数对象，我们可以选择性的将对象赋值给一个变量，方便操作。</li>
<li>lambda的主体是一个单个的表达式，而不是一个代码块。因为lambda是为编写简单函数而设计的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_test</span>(<span class="params">L,cmp=<span class="keyword">lambda</span> x,y:x&gt;y</span>):</span><br><span class="line">	a=L[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> e <span class="keyword">in</span> L[<span class="number">1</span>:]:</span><br><span class="line">		<span class="keyword">if</span> cmp(a,e):</span><br><span class="line">			a=e;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">min_test([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>])		<span class="comment">#0</span></span><br></pre></td></tr></table></figure>
<h4 id="深入理解迭代和解析">19深入理解迭代和解析</h4>
<h5 id="重访迭代器生成器">19.1 重访迭代器：生成器</h5>
<p>python对延迟提供了更多的支持，有两种方法尽可能延迟结果创建：</p>
<ul>
<li><strong>生成器函数</strong>：编写为常规的<code>def</code>，但是使用<code>yield</code>一次返回一个结果，在每个结果之间挂起和继续它们的状态</li>
<li><strong>生成器表达式</strong>：类似于列表解析，但是它们的返回是按需产生结果对象，而不是像列表解析一样构建一新列表</li>
</ul>
<p>由于二者都不会创建列表，因此节省了内存空间，并且允许计算时间分散到各个结果请求。</p>
<h6 id="生成器函数">19.1.1 生成器函数</h6>
<p><strong>一个送回一个值并随后从退出的地方继续的函数就叫生成器函数</strong>。<strong><em>生成器函数</em></strong>与常规函数的不同点主要在于：</p>
<ul>
<li>生成器函数自动在生成值的时刻挂起，在挂起时要保存函数的状态。</li>
<li>生成器函数代码不同是生成器<code>yield</code>一个值，而不是<code>return</code>，从该角度来看，允许生成器函数随时间产生一系列值</li>
</ul>
<p><strong>1 迭代协议</strong></p>
<p>要理解生成器，必须了解<strong>迭代协议</strong>。可迭代的对象定义了一个<code>__next__</code>方法，要么返回迭代中的下一项，要么抛出<code>StopIteration</code>异常终止迭代。一个对象的迭代器用<code>iter</code>内置函数接受。如果支持该协议，则<code>for</code>循环和其他迭代语句，使用这种迭代协议来遍历一个序列或者生成器；若不支持，迭代返回去重复序列。</p>
<p><strong>2 生成器：</strong></p>
<p>生成器函数要支持该协议，就必须得包含一条<code>yiled</code>语句，该语句被编译为生成器，一旦调用这条语句就会返回一个迭代对象，该对象支持用一个<code>__next__()</code>函数来继续执行该生成器函数接口。要终止生成器函数，可以在生成器函数末尾有一条<code>return</code>语句，终止生成，也可以引发一个<code>StopIteration</code>异常终止。<strong><em>简而言之，编写了包含<code>yiled</code>的函数称为生成器函数，<code>yield</code>语句为生成器，自动的支持迭代协议</em></strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">L</span>):</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">		<span class="keyword">yield</span> i**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]));		<span class="comment">#&lt;generator object func at 0x000001FB7F4AB450&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]):	<span class="comment">#1，4，9，16</span></span><br><span class="line">	<span class="built_in">print</span>(i);</span><br></pre></td></tr></table></figure> 从上面程序可以看到，调用一个生成器函数会返回一个生成器对象，它支持迭代协议，即生成器对象有一个<code>__next__()</code>方法，它可以开始这个函数，或者从它上一次<code>yield</code>值后的地方恢复，并且得到一系列的值，到最后一个时，产生<code>StopIteration</code>异常。</p>
<p><strong>3 扩展生成器函数协议send和next</strong></p>
<p>生成器函数协议增加了一个<code>send()</code>函数，<code>send()</code>函数生成一系列结果的下一个元素，这一点像<code>__next__()</code>,但是它提供了一种调用者与生成器之间的通信。当使用这一额外协议时，值可以通过调用<code>G.send(value)</code>发生给一个生成器 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g=func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="literal">None</span>));</span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<h6 id="生成器表达式">19.1.2 生成器表达式</h6>
<p>生成器表达式其实跟列表解析相似，区别就是列表解析是在<code>[]</code>内，而生成器表达式是在<code>()</code>内： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列表解析</span></span><br><span class="line">[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]; <span class="comment">#[0,1,4,9]</span></span><br><span class="line"><span class="comment">#生成器表达式</span></span><br><span class="line">G=(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))	<span class="comment">#generator</span></span><br><span class="line">G.__next__();</span><br><span class="line"><span class="comment">#for循环自动迭代</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span>(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)):</span><br><span class="line">	<span class="built_in">print</span>(num);</span><br></pre></td></tr></table></figure> 从上面可知道，生成器表达式很不同，不是在内存种构建结果，而是返回一个生成器对象，这个对象将会支持迭代协议并在任意迭代语境的操作。</p>
<p><strong>1 生成器是单迭代对象</strong></p>
<p>无论是生成器函数还是生成器表达式，都只支持一次活跃迭代，即不能在不同位置的有自己的迭代器： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">G=(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">iter_1=<span class="built_in">iter</span>(G);</span><br><span class="line">iter_1.__next__();		<span class="comment">#0</span></span><br><span class="line">iter_2=<span class="built_in">iter</span>(G);</span><br><span class="line">iter_2.__next_();		<span class="comment">#1</span></span><br></pre></td></tr></table></figure> 如上，两个迭代器总是在同一位置，即只能有一个活跃的迭代器</p>
<p><strong>2. 编写自己的map和zip</strong></p>
<p><strong>mymap</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mymap</span>(<span class="params">func,*seqs</span>):</span><br><span class="line">	<span class="keyword">return</span> [func(*args) <span class="keyword">for</span> args <span class="keyword">in</span> <span class="built_in">zip</span>(*seqs)]</span><br><span class="line"><span class="built_in">print</span>(mymap(<span class="built_in">pow</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)));</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">16</span>, <span class="number">243</span>, <span class="number">4096</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>myzip</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myzip</span>(<span class="params">func,*seqs</span>):</span><br><span class="line">	seqs=[<span class="built_in">list</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> seqs];</span><br><span class="line">	res=[];</span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">all</span>(seqs):</span><br><span class="line">		res.append(<span class="built_in">tuple</span>(s.pop(<span class="number">0</span>)<span class="keyword">for</span> s <span class="keyword">in</span> seqs));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="解析语法概况">19.2. 解析语法概况</h5>
<p>除了列表解析以外，python3.0还增加了集合解析和字典解析： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列表解析</span></span><br><span class="line">[f(x) <span class="keyword">for</span> x <span class="keyword">in</span> S]</span><br><span class="line"><span class="comment">#集合解析</span></span><br><span class="line">&#123;f(x) <span class="keyword">for</span> x <span class="keyword">in</span> S&#125;</span><br><span class="line"><span class="comment">#字典解析</span></span><br><span class="line">&#123;key:val <span class="keyword">for</span> (key,val) <span class="keyword">in</span> <span class="built_in">zip</span>(keys,vals)&#125;</span><br><span class="line"><span class="comment">#生成器表达式</span></span><br><span class="line">(x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br></pre></td></tr></table></figure></p>
<h4 id="模块">20. 模块</h4>
<p>模块是将程序代码和数据封装起来以方便重用，其实模块就相当于是一个命名空间。模块由两个语句和一个终于的内置函数进行处理：</p>
<ul>
<li><code>import</code>:让用户导入一个模块</li>
<li><code>from</code>:允许用户从以模块文件获取特定变量名</li>
<li><code>imp.reload</code>:在不终止python程序下，提供重新载入模块文件代码的方法.</li>
</ul>
<h5 id="import工作机制">20.1 import工作机制</h5>
<p>乍一看，我们都会认为python的<code>import</code>很像C/C++的<code>#include&lt;&gt;</code>，但是并不是完全一样，首先一点就是在导入时模块就已经运行了，即一旦<code>import a</code>模块，<code>a</code>模块里面的代码就会执行，如果<code>a</code>模块内有<code>print</code>语句的话就会输出。而<code>C</code>会在预处理阶段将头文件展开，同内部代码一样，执行<code>预处理编译--&gt;汇编--&gt;链接</code>过程</p>
<p><strong>import的三个过程：</strong></p>
<p><strong>1. 找到模块文件</strong></p>
<p>在执行钱必须找到模块文件所在的位置，导入是简单的<code>import a</code>，没有路径，也没有加后缀<code>.py</code>,因为python使用<strong>==标准模块搜索路径==</strong></p>
<p><strong>2. 编译成字节码（如果需要）</strong></p>
<p>python会检查模块文件的时间戳，当发现字节码即后缀为<code>.pyc</code>的文件比源代码<code>.py</code>旧，就会重新编译成<code>.pyc</code>文件，覆盖原字节码文件，反之，则不。若在搜索时只有<code>.pyc</code>文件，没有<code>.py</code>文件，直接加载<code>.pyc</code>文件。通过这些算法方式来提高程序启动速度。（<strong><em>注意</em></strong>：只有被导入的文件才会有<code>.pyc</code>文件） <strong><em>注意</em></strong>：因此多次在一个顶层模块导入模块，导入操作只会执行一次，因为已经生成了最新的<code>.pyc</code>文件</p>
<p><strong>3. 执行模块代码来创建其所定义的对象</strong></p>
<p>最后一步执行，不多说</p>
<h5 id="标准模块搜索路径">20.2.标准模块搜索路径</h5>
<p>大多数情况下，可以说依赖导入模块的搜索路径的自动特性，完全不要要配置路径。要配置你自己的路径，必须了解模块搜索路径的四个组件：</p>
<ul>
<li>程序主目录</li>
<li>pythonPATH(如果已经设置)</li>
<li>标准链接库目录</li>
<li>任何.pth文件内容</li>
</ul>
<p>这四个组件组合起来就变成了<code>sys.path</code>。第一个和第三个是自动定义，以及固定了，第二和第四个就可以用来扩展路径，从而包含你自己的外部源代码。</p>
<h5 id="import和from">20.3 import和from</h5>
<p>格式： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line"><span class="keyword">from</span> simple <span class="keyword">import</span> x,y</span><br><span class="line">x=<span class="number">42</span>;</span><br></pre></td></tr></table></figure> 在交互的模式下对<code>x</code>赋值运输,只会修改作用域内的变量x，而不是这个文件内的x，以from复制而来的变量名和其来源的文件之间没有联系，如果要修改，应该用<code>import</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line">simple.x=<span class="number">42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="命名空间">20.4 命名空间</h5>
<p>在模块的文件顶层（也就是不在函数或类的主体内）每一个赋值的变量名都会变成该模块的属性。我么们可以在模块外以<code>simple.x</code>对其属性进行引用。</p>
<h6 id="模块加载和作用域">20.4.1 模块加载和作用域</h6>
<ul>
<li><strong>模块语句会在首次导入时执行</strong>：模块第一次导入无论在什么地方，<strong>都会建立空的模块对象，并逐一执行模块文件内的语句</strong></li>
<li>顶层的赋值语句创建模块属性（如def,=)</li>
<li>模块的命名空间能够通过属性<code>__dict__</code>或<code>dir(simple)</code>获得</li>
<li>模块是一个独立的作用域（本地变量就是全局变量）：模板自己成立一个作用域，但是它的变量可看作全局变量，文件内都可使用</li>
</ul>
<h6 id="进行导入操作的文件的与被导入的文件的关系">20.4.2 进行导入操作的文件的与被导入的文件的关系</h6>
<p>导入操作不会赋予被导入文件种的代码对上层代码的可见度：即被导入文件无法看见进行导入操作的文件内的变量名 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#modeA.py</span></span><br><span class="line">x=<span class="number">88</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">	gloabal x;</span><br><span class="line">	x=<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#modeB.py</span></span><br><span class="line"><span class="keyword">import</span> modeA</span><br><span class="line">x=<span class="number">11</span>;</span><br><span class="line">modeA.f()</span><br><span class="line"><span class="built_in">print</span>(x,modeA.x);	<span class="comment">#11 99</span></span><br></pre></td></tr></table></figure> 总结来说：</p>
<ul>
<li>函数绝对无法看见其他函数内的变量名，除非它们是嵌套的</li>
<li>模块程序代码绝对无法看见其他模块的变量名，除非明确进行了变量导入</li>
</ul>
<h6 id="模块重载">20.4.3 模块重载</h6>
<p>我们之前提到，模块导入只会执行一次，要强制模块代码重新载入并执行，得要调用<code>reload</code>内置函数： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line">reload(simple);		<span class="comment">#重载模块</span></span><br></pre></td></tr></table></figure> 重载模块有几个<strong><em>注意点：</em></strong></p>
<ul>
<li><code>reload</code>会在模块当前命名空间内执行模块文件的新代码</li>
<li>重载会影响所有使用import读取的模块属性</li>
<li>重载只会以后对以后使用from的造成影响</li>
</ul>
<h4 id="内置函数">21 内置函数</h4>
<p>python内部内置了丰富的函数供开发者调用，下面进行简单的介绍。</p>
<h5 id="数学函数">21.1 数学函数</h5>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>abs(x)</code></td>
<td>返回数字的绝对值，如<code>abs(-10)</code>返回 10</td>
</tr>
<tr class="even">
<td><code>ceil(x)</code></td>
<td>返回数字的上入整数，如<code>math.ceil(4.1)</code> 返回 5</td>
</tr>
<tr class="odd">
<td><code>cmp(x, y)</code></td>
<td>如果 <code>x &lt; y</code> 返回 -1, 如果 <code>x == y</code> 返回 0, 如果 <code>x &gt; y</code> 返回 1</td>
</tr>
<tr class="even">
<td><code>exp(x)</code></td>
<td>返回e的x次幂(ex),如<code>math.exp(1)</code> 返回2.718281828459045</td>
</tr>
<tr class="odd">
<td><code>fabs(x)</code></td>
<td>返回数字的绝对值，如<code>math.fabs(-10)</code> 返回10.0</td>
</tr>
<tr class="even">
<td><code>floor(x)</code></td>
<td>返回数字的下舍整数，如<code>math.floor(4.9)</code>返回 4</td>
</tr>
<tr class="odd">
<td><code>log(x)</code></td>
<td>如<code>math.log(math.e)</code>返回1.0,<code>math.log(100,10)</code>返回2.0</td>
</tr>
<tr class="even">
<td><code>log10(x)</code></td>
<td>返回以10为基数的x的对数，如<code>math.log10(100)</code>返回 2.0</td>
</tr>
<tr class="odd">
<td><code>max(x1, x2,...)</code></td>
<td>返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr class="even">
<td><code>min(x1, x2,...)</code></td>
<td>返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr class="odd">
<td><code>modf(x)</code></td>
<td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr class="even">
<td><code>pow(x, y)</code></td>
<td>x**y 运算后的值。</td>
</tr>
<tr class="odd">
<td><code>round(x [,n])</code></td>
<td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td>
</tr>
<tr class="even">
<td><code>sqrt(x)</code></td>
<td>返回数字x的平方根</td>
</tr>
</tbody>
</table>
<h5 id="内置函数-1">21.2 内置函数</h5>
<p>这里列举一些简单内置函数列表，不做例子解释：</p>
<table style="width:11%;">
<colgroup>
<col style="width: 5%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>abs()</code></td>
<td><code>abs()</code>函数返回数字的绝对值</td>
</tr>
<tr class="even">
<td><code>all()</code></td>
<td><code>all()</code>函数用于判断给定的可迭代参数<code>iterable</code>中的所有元素是否都为<code>TRUE</code>，如果是返回 <code>True</code>，否则返回<code>False</code>.元素除了<code>0、空、None、False</code>外都算 True</td>
</tr>
<tr class="odd">
<td><code>any()</code></td>
<td><code>any()</code>函数用于判断给定的可迭代参数<code>iterable</code>是否全部为<code>False</code>，则返回<code>False</code>，如果有一个为<code>True</code>，则返回<code>True</code>。元素除了是<code>0、空、FALSE 外都算 TRUE</code>。</td>
</tr>
<tr class="even">
<td><code>bin()</code></td>
<td><code>bin()</code>返回一个整数 <code>int</code> 或者长整数 <code>long int</code> 的二进制表示</td>
</tr>
<tr class="odd">
<td><code>bool()</code></td>
<td><code>bool()</code> 函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。</td>
</tr>
<tr class="even">
<td><code>bytearray()</code></td>
<td><code>bytearray()</code>方法返回一个新字节数组。这个数组里的元素是可变的，并且每个元素的值范围</td>
</tr>
<tr class="odd">
<td><code>callable()</code></td>
<td>函数用于检查一个对象是否是可调用的。如果返回<code>True</code>，<code>object</code>仍然可能调用失败；但如果返回<code>False</code>，调用对象<code>object</code>绝对不会成功。</td>
</tr>
<tr class="even">
<td><code>chr()</code></td>
<td><code>chr()</code>用一个范围在 <code>range（256）</code>内的（就是0～255）整数作参数，返回一个对应的字符</td>
</tr>
<tr class="odd">
<td><code>classmethod修饰符</code></td>
<td><code>classmethod</code> 修饰符对应的函数不需要实例化，不需要 <code>self</code> 参数，但第一个参数需要是表示自身类的 <code>cls</code> 参数，可以来调用类的属性，类的方法，实例化对象等。</td>
</tr>
<tr class="even">
<td><code>cmp()</code></td>
<td>cmp(x,y) 函数用于比较2个对象，如果 <code>x &lt; y</code> 返回 -1, 如果<code>x == y</code>返回 0, 如果 <code>x &gt; y</code>返回 1</td>
</tr>
<tr class="odd">
<td><code>delattr()</code></td>
<td>删除属性,<code>delattr(x, 'foobar')</code> 相等于 <code>del x.foobar</code></td>
</tr>
<tr class="even">
<td><code>dir()</code></td>
<td><code>dir()</code>函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表</td>
</tr>
<tr class="odd">
<td><code>divmod()</code></td>
<td>把除数和余数运算结果结合起来，返回一个包含商和余数的元组<code>(a / b, a % b)</code></td>
</tr>
<tr class="even">
<td><code>execfile()</code></td>
<td>函数可以用来执行一个文件</td>
</tr>
<tr class="odd">
<td><code>file()</code></td>
<td><code>file()</code>函数用于创建一个 file 对象，它有一个别名叫<code>open()</code>，更形象一些，它们是内置函数。参数是以字符串的形式传递的</td>
</tr>
<tr class="even">
<td><code>float()</code></td>
<td><code>float()</code>函数用于将整数和字符串转换成浮点数。</td>
</tr>
<tr class="odd">
<td><code>frozenset()</code></td>
<td>返回一个冻结的集合，冻结后集合不能再添加或删除任何元素，即不可变</td>
</tr>
<tr class="even">
<td><code>getattr()</code></td>
<td>返回一个对象的属性值</td>
</tr>
<tr class="odd">
<td><code>globals()</code></td>
<td><code>globals()</code>函数会以字典类型返回当前位置的全部全局变量</td>
</tr>
<tr class="even">
<td><code>hasattr()</code></td>
<td><code>hasattr()</code>函数用于判断对象是否包含对应的属性</td>
</tr>
<tr class="odd">
<td><code>hash()</code></td>
<td><code>hash()</code>用于获取取一个对象（字符串或者数值等）的哈希值</td>
</tr>
<tr class="even">
<td><code>help()</code></td>
<td><code>help()</code> 函数用于查看函数或模块用途的详细说明</td>
</tr>
<tr class="odd">
<td><code>hex()</code></td>
<td><code>hex()</code> 函数用于将10进制整数转换成16进制，以字符串形式表示</td>
</tr>
<tr class="even">
<td><code>id()</code></td>
<td><code>id()</code>函数返回对象的唯一标识符，标识符是一个整数</td>
</tr>
<tr class="odd">
<td><code>input()</code></td>
<td>标准输入流，接受一个标准输入数据，返回为 string 类型</td>
</tr>
<tr class="even">
<td><code>int()</code></td>
<td>将一个字符串或数字转换为整型</td>
</tr>
<tr class="odd">
<td><code>iter()</code></td>
<td><code>iter()</code>函数用来生成迭代器</td>
</tr>
<tr class="even">
<td><code>len</code></td>
<td><code>len()</code>方法返回对象（字符、列表、元组等）长度或项目个数</td>
</tr>
<tr class="odd">
<td><code>locals()</code></td>
<td><code>locals()</code>函数会以字典类型返回当前位置的全部局部变量</td>
</tr>
<tr class="even">
<td><code>next()</code></td>
<td><code>next()</code>返回迭代器的下一个项目,该函数于<code>iter()</code>配套使用</td>
</tr>
<tr class="odd">
<td><code>open()</code></td>
<td><code>open()</code>函数用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 <code>OSError</code></td>
</tr>
<tr class="even">
<td><code>ord()</code></td>
<td>该函数是<code>chr()</code>函数（对于 8 位的 ASCII 字符串）的配对函数，它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。</td>
</tr>
<tr class="odd">
<td><code>pow(x,y)</code></td>
<td>指数计算，返回<span class="math display">\[$x^y\]</span>$</td>
</tr>
<tr class="even">
<td><code>round()</code></td>
<td>返回浮点数 x 的四舍五入值，准确的说保留值将保留到离上一位更近的一端（四舍六入）</td>
</tr>
<tr class="odd">
<td><code>sorted()</code></td>
<td>对所有可迭代的对象进行排序操作</td>
</tr>
<tr class="even">
<td><code>str()</code></td>
<td>返回一个对象的<code>string</code>格式,将对象转化为适于人阅读的形式</td>
</tr>
</tbody>
</table>
<h6 id="compile函数">21.2.1 compile()函数</h6>
<p>compile() 函数将一个字符串编译为字节代码，格式如下: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compile</span>(source, filename, mode[, flags[, dont_inherit]])</span><br></pre></td></tr></table></figure> - <code>source</code>：字符串或者AST（Abstract Syntax Trees）对象。。 - <code>filename</code>：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。 - <code>mode</code> ：指定编译代码的种类。可以指定为 exec, eval, single。 - <code>flags</code> ：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。。 - <code>flags和dont_inherit</code>是用来控制编译源码时的标志</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">str</span> = <span class="string">&quot;for i in range(0,10): print(i)&quot;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">compile</span>(<span class="built_in">str</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;exec&#x27;</span>)   <span class="comment"># 编译为字节代码对象 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;code <span class="built_in">object</span> &lt;module&gt; at <span class="number">0x10141e0b0</span>, file <span class="string">&quot;&quot;</span>, line <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">exec</span>(c)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h6 id="complex函数">21.2.2 complex()函数</h6>
<p><code>complex()</code>函数用于创建一个值为<code>real + imag * j</code>的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span>(<span class="number">1</span>)    <span class="comment"># 数字，结果为(1 + 0j)</span></span><br><span class="line"><span class="built_in">complex</span>(<span class="string">&quot;1&quot;</span>)  <span class="comment"># 当做字符串处理，结果为(1 + 0j)</span></span><br></pre></td></tr></table></figure></p>
<h6 id="dict函数">21.2.3 dict()函数</h6>
<p>dict() 函数用于创建一个字典。有四种接口来创建字典 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>()                        # 创建空字典</span><br><span class="line"><span class="built_in">dict</span>(a=<span class="string">&#x27;a&#x27;</span>, b=<span class="string">&#x27;b&#x27;</span>, t=<span class="string">&#x27;t&#x27;</span>)     # 传入关键字</span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))   # 映射函数方式来构造字典</span><br><span class="line"><span class="built_in">dict</span>([(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])    # 可迭代对象方式来构造字典</span><br></pre></td></tr></table></figure></p>
<h6 id="enumerate函数">21.2.4 enumerate()函数</h6>
<p><code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#形式</span></span><br><span class="line"><span class="built_in">enumerate</span>(sequence, [start=<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line">seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons))   <span class="comment">#[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>))       <span class="comment"># 小标从 1 开始[(1, &#x27;Spring&#x27;), (2, &#x27;Summer&#x27;), (3, &#x27;Fall&#x27;), (4, &#x27;Winter&#x27;)]</span></span><br></pre></td></tr></table></figure></p>
<h6 id="eval函数">21.2.5 eval()函数</h6>
<p><code>eval()</code>函数用来执行一个字符串表达式，并返回表达式的值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line"><span class="built_in">eval</span>( <span class="string">&#x27;3 * x&#x27;</span> )		#<span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<h6 id="filter函数">21.2.6 filter()函数</h6>
<p><code>filter()</code>函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。<strong>接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 <code>True</code> 或 <code>False</code>，最后将返回 <code>True</code> 的元素放到新列表中。</strong></p>
<blockquote>
<p>注意: Python2.7 返回列表，Python3.x 返回迭代器对象，具体内容可以查看：Python3 filter() 函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">    return n % <span class="number">2</span> =</span>= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">newlist = <span class="built_in">filter</span>(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(newlist) #[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h6 id="format-格式化函数">21.2.7 format 格式化函数</h6>
<p>Python2.6 开始，新增了一种格式化字符串的函数<code>str.format()</code>，它增强了字符串格式化的功能。基本语法是通过<code>&#123;&#125;</code>和<code>:</code>来代替以前的 <code>%</code>。<code>format</code> 函数可以接受不限个参数，位置可以不按顺序 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.format(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    # 不设置指定位置，按默认顺序</span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.format(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  # 设置指定位置</span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.format(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  # 设置指定位置</span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h6 id="isinstance函数">21.2.8 isinstance()函数</h6>
<p><code>isinstance()</code>判断一个对象是否是一个已知的类型，类似<code>type()</code>。<code>isinstance()</code> 与 <code>type()</code> 区别：</p>
<ul>
<li><code>type()</code>不会认为子类是一种父类类型，不考虑继承关系。</li>
<li><code>isinstance()</code>会认为子类是一种父类类型，考虑继承关系。</li>
<li>因此如果要判断两个类型是否相同推荐使用 <code>isinstance()</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#语法</span><br><span class="line"><span class="built_in">isinstance</span>(object, classinfo)</span><br><span class="line">#举例</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">isinstance</span> (a,<span class="type">int</span>)			#True</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="issubclass函数">21.2.9 issubclass()函数</h6>
<p>方法用于判断参数 <code>class</code> 是否是类型参数 <code>classinfo</code> 的子类: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">issubclass</span>(<span class="keyword">class</span>, classinfo)</span><br></pre></td></tr></table></figure></p>
<h6 id="list函数">21.2.10 list()函数</h6>
<p><code>list()</code>方法用于将元组或字符串转换为列表。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aTuple = (<span class="number">123</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>)</span><br><span class="line">list1 = <span class="built_in">list</span>(aTuple)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line">list2=<span class="built_in">list</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure> <em>注：元组与列表是非常类似的，区别在于元组的元素值不能修改，元组是放在括号中，列表是放于方括号中。</em></p>
<h6 id="range函数">21.2.11 range()函数</h6>
<p>Python3 <code>range()</code>函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。 Python3 <code>list()</code>函数是对象迭代器，可以把<code>range()</code>返回的可迭代对象转为一个列表，返回的变量类型为列表。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式</span></span><br><span class="line"><span class="built_in">range</span>(stop)</span><br><span class="line"><span class="built_in">range</span>(start, stop[, step])</span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">	<span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<h6 id="reversed函数">21.2.12 reversed()函数</h6>
<p>reversed 函数返回一个反转的迭代器。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 字符串</span><br><span class="line">seqString = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqString)))</span><br><span class="line"> </span><br><span class="line"># 元组</span><br><span class="line">seqTuple = (<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqTuple)))</span><br><span class="line"> </span><br><span class="line"><span class="meta"># range</span></span><br><span class="line">seqRange = <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqRange)))</span><br><span class="line"> </span><br><span class="line"># 列表</span><br><span class="line">seqList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqList)))</span><br></pre></td></tr></table></figure> 结果： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;R&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;R&#x27;</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h6 id="set函数">21.2.13 set()函数</h6>
<p><code>set()</code>函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">set</span>(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">y = <span class="built_in">set</span>(<span class="string">&#x27;google&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="built_in">set</span>([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]), <span class="built_in">set</span>([<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;l&#x27;</span>]))   <span class="comment"># 重复的被删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x &amp; y         <span class="comment"># 交集</span></span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;o&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x | y         <span class="comment"># 并集</span></span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x - y         <span class="comment"># 差集</span></span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="sorted函数">21.2.14 sorted()函数</h6>
<p><code>sorted()</code>函数对所有可迭代的对象进行排序操作 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式</span></span><br><span class="line"><span class="built_in">sorted</span>(iterable, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">example_list = [<span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">sorted</span>(example_list, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>sort 与 sorted 区别：</strong></p>
<ul>
<li><code>sort</code>是应用在 <code>list</code> 上的方法，<code>sorted</code> 可以对所有可迭代的对象进行排序操作。</li>
<li><code>list</code> 的 <code>sort</code> 方法返回的是对已经存在的列表进行操作，而内建函数<code>sorted</code>方法返回的是一个新的 <code>list</code>，而不是在原来的基础上进行的操作。</li>
</ul>
<h6 id="hash函数">21.2.15 hash()函数</h6>
<p>hash() 用于获取取一个对象（字符串或者数值等）的哈希值。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(<span class="string">&#x27;test&#x27;</span>)            <span class="comment"># 字符串</span></span><br><span class="line"><span class="comment">#哈希值</span></span><br><span class="line"><span class="number">2314058222102390712</span></span><br></pre></td></tr></table></figure></p>
<h6 id="vars函数">21.2.16 vars()函数</h6>
<p><code>vars()</code>函数返回对象<code>object</code>的属性和属性值的字典对象。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#格式</span><br><span class="line"><span class="built_in">vars</span>([object])</span><br><span class="line">#举例</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runoob</span>:</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>(Runoob))</span><br><span class="line">#输出：</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>: None&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="命令行参数add_argument用法解析">22. 命令行参数add_argument()用法解析</h4>
<h5 id="argparse介绍">22.1 argparse介绍</h5>
<p><code>argparse</code>模块是 Python 内置的一个用于命令项选项与参数解析的模块，argparse 模块可以让人轻松编写用户友好的命令行接口。通过在程序中定义好我们需要的参数，然后 argparse 将会从 sys.argv 解析出这些参数。argparse 模块还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。</p>
<p>三个步骤：</p>
<ul>
<li>1、创建一个解析器——创建 ArgumentParser() 对象</li>
<li>2、添加参数——调用 add_argument() 方法添加参数</li>
<li>3、解析参数——使用 parse_args() 解析添加的参数</li>
</ul>
<h5 id="创建一个解析器创建-argumentparser-对象">22.2 创建一个解析器——创建 ArgumentParser() 对象</h5>
<p>使用 argparse 的第一步是创建一个 ArgumentParser 对象： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure> ArgumentParser 对象包含将命令行解析成 Python 数据类型所需的全部信息。</p>
<ul>
<li><code>description</code>:大多数对 ArgumentParser 构造方法的调用都会使用 description= 关键字参数。这个参数简要描述这个程度做什么以及怎么做。在帮助消息中，这个描述会显示在命令行用法字符串和各种参数的帮助消息之间。</li>
</ul>
<h5 id="添加参数调用-add_argument-方法添加参数">22.3 添加参数——调用 add_argument() 方法添加参数</h5>
<p>给一个 ArgumentParser 添加程序参数信息是通过调用 add_argument() 方法完成的。通常，这些调用指定 ArgumentParser 如何获取命令行字符串并将其转换为对象。这些信息在 parse_args() 调用时被存储和使用。例如 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--sparse&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;GAT with sparse version or not.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">72</span>, <span class="built_in">help</span>=<span class="string">&#x27;Random seed.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10000</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of epochs to train.&#x27;</span>)</span><br></pre></td></tr></table></figure> add_argument() 方法定义如何解析命令行参数: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.add_argument(name <span class="keyword">or</span> flags...[, action][, nargs][, const][, default][, <span class="built_in">type</span>][, choices][, required][, <span class="built_in">help</span>][, metavar][, dest])</span><br></pre></td></tr></table></figure></p>
<p>每个参数解释如下: - <code>name or flags</code>: 选项字符串的名字或者列表，例如 foo 或者 -f, --foo。 - <code>action</code> : 命令行遇到参数时的动作，默认值是 store。 - <code>store_const</code>:表示赋值为const； - <code>append</code>:将遇到的值存储成列表，也就是如果参数重复则会保存多个值; - <code>append_const</code>:将参数规范中定义的一个值保存到一个列表； - <code>count</code>：存储遇到的次数；此外，也可以继承 argparse.Action 自定义参数解析； - <code>nargs</code>: 应该读取的命令行参数个数，可以是具体的数字，或者是?号，当不指定值时对于 Positional argument 使用 default，对于 Optional argument 使用 const；或者是 * 号，表示 0 或多个参数；或者是 + 号表示 1 或多个参数。 - <code>const</code>: action 和 nargs 所需要的常量值。 - <code>default</code> : 不指定参数时的默认值。 - <code>type</code>: 命令行参数应该被转换成的类型。 - <code>choices</code> : 参数可允许的值的一个容器。 - <code>required</code>: 可选参数是否可以省略 (仅针对可选参数)。 - <code>help</code> : 参数的帮助信息，当指定为 argparse.SUPPRESS 时表示不显示该参数的帮助信息. - <code>metavar</code>:在 usage 说明中的参数名称，对于必选参数默认就是参数名称，对于可选参数默认是全大写的参数名称. - <code>dest</code>: 解析后的参数名称，默认情况下，对于可选参数选取最长的名称，中划线转换为下划线.</p>
<h5 id="解析参数使用-parse_args-解析添加的参数">22.4 解析参数——使用 parse_args() 解析添加的参数</h5>
<p>rgumentParser 通过 parse_args() 方法解析参数。它将检查命令行，把每个参数转换为适当的类型然后调用相应的操作。在大多数情况下，这意味着一个简单的 Namespace 对象将从命令行解析出的属性构建： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">args = parser.parse_args()</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 22.5 实例</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"> </span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">parser.add_argument(<span class="string">&#x27;--sparse&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;GAT with sparse version or not.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">72</span>, <span class="built_in">help</span>=<span class="string">&#x27;Random seed.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10000</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of epochs to train.&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">args = parser.parse_args()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(args.sparse)</span><br><span class="line"><span class="built_in">print</span>(args.seed)</span><br><span class="line"><span class="built_in">print</span>(args.epochs)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">（面试）C++基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-19 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-19T00:00:00+08:00">2022-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-01 13:50:29" itemprop="dateModified" datetime="2022-12-01T13:50:29+08:00">2022-12-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span id="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-meta-item leancloud_visitors" data-flag-title="（面试）C++基础知识" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="c知识面试版">1. C++知识面试版</h3>
<h4 id="编译过程">1.1 编译过程</h4>
<p><img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/compile.png" width="600"> 如上所示，<strong>一个c源文件会先经过预处理，将头文件展开、宏替换和去注释；然后经过编译器生成汇编文件，再有汇编器生成二进制文件，最后再经过链接器将函数库中相应的代码组合到目标文件</strong></p>
<h4 id="静态链接和动态链接">1.2 静态链接和动态链接</h4>
<h5 id="静态链接">1.2.1 静态链接：</h5>
<p>由链接器在链接时将库的内容加入到可执行程序中。</p>
<ul>
<li><strong>优点：对运行环境的依赖性较小，具有较好的兼容性</strong></li>
<li><strong>缺点：生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间；库函数有了更新，必须重新编译应用程序</strong></li>
</ul>
<h5 id="动态链接">1.2.2 动态链接</h5>
<p>连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。</p>
<ul>
<li><strong>优点：在需要的时候才会调入对应的资源函数；简化程序的升级；有着较小的程序体积；实现进程之间的资源共享（避免重复拷贝）</strong></li>
<li><strong>缺点：依赖动态库，不能独立运行；动态库依赖版本问题严重</strong></li>
</ul>
<p>注：前面我们编写的应用程序大量用到了标准库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入<code>-static</code>参数。</p>
<h4 id="c函数调用过程">1.3 C++函数调用过程</h4>
<p><strong>函数调用栈的基本知识</strong>：</p>
<ul>
<li>每个线程都有一个自己的函数调用栈</li>
<li>栈也是程序申请的一段内存，随着栈的使用而增长。而一般编译的时候也可以指定编译选项设置栈最大值。如果递归调用层数太深，会导致栈溢出。</li>
<li>在<strong>系统中程序执行的时候 栈都是从高地址往低地址增长的&lt;函数参数压栈，一般从右向左压栈</strong>（比如<code>__cdecl</code>函数调用约定）</li>
<li><code>EIP</code>寄存器存储当前执行指令的内存位置</li>
<li><code>EBP</code>寄存器表明当前栈帧的栈底</li>
<li><code>ESP</code>寄存器表明当前栈帧的栈顶</li>
</ul>
<p><strong>调用函数过程</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以此为例</span></span><br><span class="line"><span class="built_in">intFunAdd</span>(intiPara1, intiPara2) &#123;</span><br><span class="line">    intiAdd = <span class="number">7</span>; </span><br><span class="line">    intiResult = iPara1 + iPara2 + iAdd; </span><br><span class="line">    returniResult; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> main&#123;</span><br><span class="line">    intiVal1 = <span class="number">5</span>; intiVal2 = <span class="number">6</span>; </span><br><span class="line">    intiRes = <span class="built_in">FunAdd</span>(iVal1, iVal2); </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;iRes: %dn&quot;</span>, iRes); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将函数参数压入<code>push</code>栈中（从右到左），在跳入<code>call</code>该函数体执行前，会再压入一个数据，改数据是一个地址，是函数执行完后要返回的地址，也是我们程序中函数调用的下一条语句，即“保护现场”。</li>
<li><code>push ebp</code>，进入函数后，压入一个旧<code>ebp</code>，该<code>ebp</code>是上一个函数的<code>ebp</code>。这样子就能通过<code>ebp-4</code>、<code>ebp-8</code>来获取参数。</li>
<li><code>mov ebp, esp</code>，将此时的栈顶地址作为该函数的栈基址，确定被调函数的栈底</li>
<li>执行函数将被调函数内的一些局部变量压栈。</li>
<li>执行最后一步后，如果有返回值，将返回值存入<code>EAX</code>寄存器。</li>
<li><code>mov esp,ebp</code>将<code>ebp</code>赋给<code>esp</code>，此时<code>esp</code>指向栈底，后执行<code>pop</code>恢复原先的<code>main</code>函数栈帧</li>
<li>此时<code>esp</code>指向了第一步保存的下一条执行语句的地址，获取后回到main函数，此时<code>intFunAdd</code>函数执行完毕</li>
<li><code>add esp,8</code>，将压入的两个参数去除，后将<code>eax</code>寄存器的返回值赋给相应变量</li>
</ul>
<p><img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/funcCall.png" width="600"></p>
<h4 id="内联函数与普通函数的区别">1.4 内联函数与普通函数的区别</h4>
<ul>
<li>相当于把内联函数里面的内容写在调用内联函数的地方；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数</li>
</ul>
<h4 id="内存中的字节对齐">1.5 内存中的字节对齐</h4>
<h4 id="c的内存模型">1.6 C++的内存模型</h4>
<ul>
<li><strong>C++分区：堆、栈、自由存储区、全局/静态存储区、常量存储区</strong></li>
<li><strong>c/c++内存模型生命周期</strong>：自由存储区、动态区、静态区</li>
</ul>
<p><strong><em>以下注意点：</em></strong></p>
<pre><code>(a)函数体中定义的变量通常是在栈上；
(b)用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上；
(c)在所有函数体外定义的是全局量；
(d)加了static修饰符后不管在哪里都存放在全局区（静态区）；
(e)在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用；
(f)在函数体内定义的static表示只在该函数体内有效；
(g)另外，函数中的&quot;adgfdf&quot;这样的字符串存放在常量区</code></pre>
<p><img src="/2022/06/19/(%E9%9D%A2%E8%AF%95)C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++程序内存图.png" width="500"></p>
<h4 id="static关键字的作用">1.7 static关键字的作用</h4>
<h5 id="全局静态变量编译时初始化存储在bssdata">1.7.1 全局静态变量（编译时初始化，存储在bss/data)</h5>
<p>在全局变量前加上关键字<code>static</code>，全局变量就定义成一个全局静态变量。<strong>存储在静态存储区（未初始化<code>bss</code>或已初始化数据段<code>data</code>），在整个程序运行期间一直存在。</strong></p>
<ul>
<li><strong>初始化：只能初始化一次。未经初始化的静态变量会被自动初始化为0</strong></li>
<li><strong>作用域</strong>：全局静态变量在声明他的文件之外是不可见的，准确地说是他的作用域从定义之处开始，到文件结尾。</li>
</ul>
<h5 id="局部静态变量">1.7.2 局部静态变量</h5>
<p>在局部变量之前加上关键字<code>static</code>，局部变量就成为一个局部静态变量。<strong>内存中的位置在静态存储区</strong></p>
<ul>
<li><strong>初始化</strong>：只能初始化一次。未经初始化的静态变量会被自动初始化为0。</li>
<li><strong>作用域</strong>：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束，但并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</li>
</ul>
<h5 id="静态函数">1.7.3 静态函数</h5>
<p><strong>在函数返回类型前加<code>static</code>，函数就定义为静态函数。函数的定义和声明在默认情况下都是<code>extern</code>的，但静态函数默认声明仅在当前文件当中可见，不能被其他文件所用</strong>。函数的实现使用<code>static</code>修饰，那么这个函数只可在本<code>cpp</code>内使用，不会同其他<code>cpp</code>中的同名函数引起冲突，起到一个函数隐藏的作用；</p>
<ul>
<li><strong>warning：</strong>不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</li>
</ul>
<h5 id="类的静态成员">1.7.4 类的静态成员</h5>
<p>在类中，<strong>静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则</strong>，即保证了安全性。因此，<strong>静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</strong></p>
<h5 id="类的静态函数">1.7.5 类的静态函数</h5>
<p><strong>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</strong></p>
<p><strong>在静态成员函数中没有<code>this</code>指针，因此无法被<code>const</code>修饰</strong>。实现中不能直接引用类中声明明的非静态成员，但可以引用类中声明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，要通过对象来引用。调用静态成员函数可通过<code>object.staticfunc()</code>也可以通过<code>class::staticfunc()</code>调用</p>
<h4 id="const关键字">1.8 const关键字</h4>
<h4 id="一些seziof大小">1.9一些seziof大小</h4>
<p><strong>虚函数表4字节，4字节对齐！比如</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(A);/大小是<span class="number">8</span>，<span class="number">4</span>+<span class="number">1</span>+（对齐）<span class="number">3</span>=<span class="number">8</span></span><br><span class="line"><span class="comment">//static变量虽然属于类，但并不在类内开辟空间</span></span><br></pre></td></tr></table></figure></p>
<h4 id="section">1.10</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">550k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:20</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'TXhU0V217D2k9wXcjdYcmYLt-gzGzoHsz',
      appKey     : '7vt5hNdJIFoHxQb92AoWuR3E',
      placeholder: "骚言骚语",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
