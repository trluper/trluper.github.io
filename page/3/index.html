<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Trluper">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="trluper">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-07 21:34:12" itemprop="dateCreated datePublished" datetime="2022-08-07T21:34:12+08:00">2022-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 09:47:06" itemprop="dateModified" datetime="2022-08-22T09:47:06+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="get请求和post请求的区别">1. get请求和post请求的区别</h4>
<p><strong>在实际应用中，get和post请求的区别主要有以下几个：</strong></p>
<ul>
<li><strong><code>get</code>请求用于从服务器上获得资源，而<code>post</code>请求用于向服务器提交数据</strong></li>
<li><code>get</code>将表单中的数据按照<code>key=value</code>的形式，添加到<code>action</code>指定的<code>URL</code>后面，并且两者之间使用<code>?</code>连接，各个变量之间使用&amp;连接；post是将表单的数据放在HTTP协议的请求头或者消息体中，传递到action所指向的URL</li>
<li><strong><code>get</code>传输的数据要受到URL长度的限制（最大长度是2048个字符）；而<code>post</code>可以传输大量数据，上传文件通常使用post</strong></li>
<li><strong>使用<code>get</code>时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用<code>get</code>，对于敏感数据应使用<code>post</code></strong></li>
<li><code>get</code>使用<code>MIME</code>类型<code>application/x-www-form-urlencoded</code>的URL编码（也叫百分号编码）文本格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是<code>%20</code></li>
<li><strong><code>get</code>请求参数会被完整保留在浏览器历史记录里，而<code>post</code>中的参数不会被保留。</strong></li>
</ul>
<p><strong>但是在本质上，get和post请求没有区别：</strong></p>
<p><code>get</code>和<code>post</code>是HTTP协议中的两种发送请求的方法，而HTTP是基于<code>TCP/IP</code>的关于数据如何在万维网中如何通信的协议。因此，<code>get</code>和<code>post</code>的底层也是<code>TCP/IP</code>,也就是说，<code>get</code>和<code>post</code>都是TCP链接。</p>
<p><strong>此外，get和post还有一个重要的区别：</strong></p>
<p><code>get</code>产生一个<code>TCP</code>数据包；<code>POST</code>产生两个TCP数据包。对于<code>get</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应200（返回数据）；而对于<code>post</code>，浏览器先发送<code>header</code>，服务器响应<code>100 continue</code>，浏览器再发送<code>data</code>，服务器响应<code>200 ok</code>（返回数据）。</p>
<h4 id="tcp和udp的区别">2. TCP和UDP的区别</h4>
<ul>
<li><strong>连接性：</strong>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。UDP无连接。</li>
<li><strong>服务对象</strong>：TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；UDP支持一对一，一对多，多对一，多对多的交互通信。</li>
<li><strong>可靠性</strong>：TCP是有保证数据安全可靠的措施，可靠交付：无差错，不丢失，不重复，按序到达。UDP是尽最大努力交付，不保证可靠交付。</li>
<li><strong>拥塞控制和流量控制</strong>：TCP有拥塞控制和流量控制保证数据传输的安全性。UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li>
<li><strong>报文长度</strong>：TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li>
<li><strong>首部开销</strong>：TCP首部开销大，首部20个字节。UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</li>
<li><strong>TCP和UDP适用场景</strong>：从特点上我们已经知道，TCP是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</li>
</ul>
<p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP.png" width="600"></p>
<h4 id="tcp三次握手">3. TCP三次握手</h4>
<ul>
<li>只有<code>SYN</code>位置1表示连接请求。</li>
<li>只有<code>ACK</code>置1表示<code>ACK</code>报文段，携带数据时会消耗序号<code>seq</code>，不携带则不消耗</li>
<li><code>ACK</code>和<code>SYN</code>都置1，不能携带数据，但消耗1个序号<code>seq</code> <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/threeAndFour.png" width="600"></li>
</ul>
<h5 id="三次握手">3.1 三次握手</h5>
<ul>
<li>1、Client将标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，并将该数据包发送给Server，Client进入<code>SYN_SENT</code>状态，等待Server确认。</li>
<li>2、Server收到数据包后由标志位<code>SYN=1</code>知道Client请求建立连接，Server将标志位<code>SYN</code>和<code>ACK</code>都置为1，<code>ack=J+1</code>，随机产生一个值<code>seq=K</code>，并将该数据包发送给Client以确认连接请求，Server进入<code>SYN_RCVD</code>状态。</li>
<li>3、Client收到确认后，检查<code>ack</code>是否为J+1，ACK若为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给Server，Server检查<code>ack</code>是否为K+1，<code>ACK</code>为1，如果正确则连接建立成功，Client和Server进入<code>ESTABLISHED</code>状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<h5 id="三次握手的原因">3.2 三次握手的原因</h5>
<ul>
<li>①建立连接，</li>
<li>②第三次要回ACK的原因：如果没有第三次回ACK，会导致已经失效的连接请求报文突然又传输到服务器端，又建立客户端与服务器的连接，但客户端又不发送数据，此时导致的服务器资源浪费。 所谓已经失效的连接请求是指客户端发出的连接请求滞留在网络中，超时后但又被服务器接收到。</li>
</ul>
<h5 id="思考connect为什么会阻塞即第三次ack丢失下客户端怎么办">3.3 思考：connect为什么会阻塞（即第三次ACK丢失下客户端怎么办）</h5>
<p><strong>server端：</strong></p>
<blockquote>
<p>第三次的ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。 而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为&gt;5.如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。</p>
</blockquote>
<p><strong>client端</strong>：</p>
<blockquote>
<p>在linux c 中，client 一般是通过<code>connect()</code>函数来连接服务器的，而<code>connect()</code>是在TCP的三次握手的第二次握手完成后就成功返回值。也就是说client在接收到 SYN+ACK包，它的TCP连接状态就为established （已连接），表示该连接已经建立。 那么如果第三次握手中的ACK包丢失的情况下，Client 向<code>server</code>端发送数据，Server端将以<code>reset</code>包响应，方能感知到Server的错误。</p>
</blockquote>
<h4 id="tcp四次挥手">4. TCP四次挥手</h4>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个<code>FIN</code>来终止这一方向的连接，收到一个<code>FIN</code> 只是意味着这一方向上没有数据流动了，即不会再发送到数据了，但是在这个TCP连接上仍然能够收数据，直到另一方也发送了<code>FIN</code>。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<h5 id="四次挥手过程">4.1 四次挥手过程</h5>
<ul>
<li>1.数据传输结束后，客户端的应用进程发出连接释放<code>FIN</code>报文段，并停止发送数据，客户端进入<code>FIN_WAIT_1</code>状态，此时客户端依然可以接收服务器发送来的数据。</li>
<li>2.服务器接收到<code>FIN</code>后，发送一个<code>ACK</code>给客户端，确认序号为收到的序号<code>+1</code>，服务器进入<code>CLOSE_WAIT</code>状态。客户端收到后进入<code>FIN_WAIT_2</code>状态。</li>
<li>3.当服务器没有数据要发送时，服务器也发送一个<code>FIN</code>报文，此时服务器进入<code>LAST_ACK</code>状态，等待客户端的确认</li>
<li>4.客户端收到服务器的<code>FIN</code>报文后，给服务器发送一个<code>ACK</code>报文，确认序列号为收到的序号<code>+1</code>。此时客户端进入<code>TIME_WAIT</code>状态，等待<code>2MSL</code>（MSL：报文段最大生存时间），然后关闭连接。</li>
</ul>
<p>应用层可以使用系统调用函数read函数==0来判断对端是否关闭连接。</p>
<h5 id="为什么要等待2msl才关闭链接">4.2 为什么要等待2MSL才关闭链接</h5>
<ul>
<li>①为保证客户端发送的最后一个ACK报文段能够到达服务器。若第4次挥手的报文段丢失了，服务器就会超时重传第3次挥手的报文段。</li>
<li>②经过2MSL时间，可以使本次连接持续时间内所以产生的报文段(主要针对滞留在网络中的）都失效，这样就可避免已失效的本次链接请求影响下一次链接请求。</li>
</ul>
<h5 id="为什么要4次挥手">4.3 为什么要4次挥手</h5>
<p>因为主动关闭的一方是已经确定没有数据要发送了，而被动关闭的一方还未<code>FIN</code>报文，先回一个<code>ACK</code>确认报文，其在<code>FIN</code>发生前可能还要发送数据，只有等待数据发生完，才能回一个<code>FIN</code>报文，主动关闭方再回一个<code>ACK</code>确认,才能达到双向关闭，</p>
<h4 id="tcp机的状态转移">5. TCP机的状态转移</h4>
<p><img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/statusSwitch.png" width="600"> [^上半部分为3次握手，下半部分为4次挥手，实线表示主动，虚线为被动，细线为特殊情况]</p>
<p><strong>状态解释：</strong></p>
<ul>
<li><code>CLOSED</code>：表示初始状态。</li>
<li><code>LISTEN</code>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li>
<li><code>SYN_SENT</code>：这个状态与<code>SYN_RCVD</code>遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。<code>SYN_SENT</code>状态表示客户端已发送SYN报文。</li>
<li><code>SYN_RCVD</code>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</li>
<li><p><code>ESTABLISHED</code>：表示连接已经建立。</p></li>
<li><strong><code>FIN_WAIT_1</code>: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文</strong>。区别是：
<ul>
<li><code>FIN_WAIT_1</code>状态是当socket在<code>ESTABLISHED</code>状态时，想主动关闭连接，向对方发送了<code>FIN</code>报文，此时该socket进入到FIN_WAIT_1状态。</li>
<li><code>FIN_WAIT_2</code>状态是当对方回应<code>ACK</code>后，该socket进入到<code>FIN_WAIT_2</code>状态，正常情况下，对方应马上回应<code>ACK</code>报文，所以<code>FIN_WAIT_1</code>状态一般较难见到，而<code>FIN_WAIT_2</code>状态可用netstat看到。</li>
</ul></li>
<li><p><code>FIN_WAIT_2</code>：<strong>主动关闭链接的一方，发出<code>FIN</code>收到<code>ACK</code>以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发，既socket上还有数据流动。</strong></p></li>
<li><p><code>TIME_WAIT</code>: <strong>表示收到了对方的<code>FIN</code>报文，并发送出了<code>ACK</code>报文，等2MSL后即可回到CLOSED可用状态。如果<code>FIN_WAIT_1</code>状态下，收到对方同时带<code>FIN</code>标志和<code>ACK</code>标志的报文时，可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code>状态。</strong></p></li>
<li><p><code>CLOSING</code>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p></li>
<li><code>CLOSE_WAIT</code>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。（服务器）</li>
<li><p><code>LAST_ACK</code>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。（服务器）</p></li>
</ul>
<h4 id="tcp的拥塞控制对整个网络">6. TCP的拥塞控制：对整个网络</h4>
<p>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。<strong>流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口<code>cwnd</code>。</strong></p>
<ul>
<li><p><strong>慢开始</strong>：最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免<code>cwnd</code>增长过大。</p></li>
<li><p><strong>拥塞避免</strong>：每经过一个往返时间<code>RTT</code>，<code>cwnd</code>只增长1。在慢开始和拥塞避免的过程中，一旦发现网络拥塞（超时），就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）</p></li>
<li><p><strong>快重传</strong>：接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。</p></li>
<li><p><strong>快恢复</strong>：当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），并将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/controlOfcrowd.png" width="600"></p></li>
</ul>
<h4 id="tcp的可靠性保证">7. TCP的可靠性保证</h4>
<p>TCP主要提供了<strong>检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制</strong>等方法实现了可靠性传输。</p>
<ul>
<li><p><strong>检验和</strong>：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部</p></li>
<li><p>最大长度：在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</p></li>
<li><p><strong>滑动窗口：</strong>我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。这就提出了一个滑动窗口的概念:不必等等确认，发送端直接发送数据，在连续收到三个重复确认应答时，重新发生要求的序列号包 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/resend.png" width="600"></p></li>
</ul>
<h4 id="tcp的滑动窗口">8. TCP的滑动窗口</h4>
<p>端对端的流量控制,也解决包乱序问题（数据包格式有SequenceNumber，是数据包的序号seq,ACK——用于确认收到，用来解决不丢包的问题)。每一次读取数据之后,回ack报文,报文中会携带当前缓冲区大小,用来告知对方发送的数据不能超过我接收的缓冲区大小。</p>
<h4 id="tcp黏包问题">9. TCP黏包问题</h4>
<p><strong>原因：</strong> TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p>
<p><strong>解决：</strong></p>
<ul>
<li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li>
<li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li>
<li>在数据包之间设置边界，如添加特殊符号 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 ，则会误判为消息的边界。</li>
</ul>
<h4 id="简述域名解析过程本机如何干预域名解析">10. 简述域名解析过程，本机如何干预域名解析</h4>
<ul>
<li><p>1）在浏览器中输入<code>www.qq.com</code>域名，操作系统会先检查自己本地的<code>hosts</code>文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p></li>
<li><p>2）如果<code>hosts</code>里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p></li>
<li><p>3）如果<code>hosts</code>与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p></li>
<li><p>4）如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p></li>
<li><p>5）如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名<code>.com</code>是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责<code>.com</code>域的这台服务器。这台负责<code>.com</code>域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址<code>qq.com</code>给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找<code>qq.com</code>域服务器，重复上面的动作，进行查询，直至找到<code>www.qq.com</code>主机。</p></li>
<li><p>6）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></li>
</ul>
<p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>
<h4 id="section">10.</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/" class="post-title-link" itemprop="url">高性能MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-04 21:34:03" itemprop="dateCreated datePublished" datetime="2022-08-04T21:34:03+08:00">2022-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-07 21:12:18" itemprop="dateModified" datetime="2022-08-07T21:12:18+08:00">2022-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="mysql的架构">1. MySQL的架构</h4>
<p>MySQL最重要最与众不同的就是它的存储引擎架构，这种架构设计将查询处理(<code>QUERY PROCESSING</code>)及其他系统任务和数据存储/提取相分离。在这里主要介绍MySQL的服务器架构、各种存储引擎之间的区别。</p>
<h5 id="逻辑架构">1.1 逻辑架构</h5>
<p>MySQL各组件协同工作的示意图如下：</p>
<ul>
<li>最上层的客户端不是MySQL独有的，像许多C/S结构都具有。</li>
<li>第二层架构是大多数MySQL的核心服务功能所在的一层，如查询解析、分析、优化、缓存和所有的内置函数，所有跨存储引擎的功能也在这一层实现：存储过程、视图、触发器等。</li>
<li>第三层包含了存储引擎，存储引擎负责MySQL中数据的存储和提取 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/Fram.png" width="400"></li>
</ul>
<h6 id="连接管理与安全性">1.1.1 连接管理与安全性</h6>
<p>每个客户端连接到MySQL服务器进程有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU时间片中执行语句。服务器会负责缓存管理线程，因此不需要为每一个新建的连接创建或者销毁线程。</p>
<p>当有来自于客户端的连接请求时，服务器会对连接信息进行认证，认证基于用户名、密码和主机信息进行。</p>
<h6 id="优化与执行">1.1.2 优化与执行</h6>
<p><strong>进行解析的过程：</strong></p>
<ul>
<li>MySQL会解析查询，并创建内部数据结构（解析树），<strong>然后对其进行各种优化：包括重写查询、决定表的读取顺序以及选择合适的索引等。</strong></li>
<li>用户可以通过特殊的关键字提示优化器来影响它的优化决策过程，也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器时如何进行优化决策的。</li>
<li>优化器不关心表使用哪种存储引擎，但存储引擎对优化查询是有影响的，因为优化器会请求存储引擎提供容量或某个具体操作的开销。</li>
</ul>
<p><strong>当然不要忘了还有查询缓存：</strong></p>
<p>对于select语句，在解析查询之前，服务器会先检查查询缓存，如果能在查询缓存中找到对应查询，服务器就不必执行解析器、优化和执行的整个过程，直接返回查询缓存中的结果集即可。</p>
<h5 id="并发控制">1.2 并发控制</h5>
<p>在MySQL当中是在两个面讨论的并发控制：服务器层和存储引擎层。在并发场景下，如果不对并发进行控制，则会导致数据的损坏无效，一般来说我们都是用锁<code>lock</code>来对其进行控制。在MySQL中的锁有共享锁(<code>shared lock</code>)、排他锁(<code>exclusive lock</code>)，也叫读锁(<code>read lock</code>)和写锁(<code>write lock</code>)</p>
<h4 id="锁">2. 锁</h4>
<p>锁这个知识点比较繁杂，下图是对锁的各个概念范围进行分类： <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/Lockrecord.png" width="700"></p>
<h5 id="锁类型兼容性">2.1 锁类型（兼容性）</h5>
<p>对于读取内容来说一般不会发生什么问题，因为本线程没有对数据进行修改，<strong>但是试想一下你正在对读的使用，另一个人正在对数据进行写入，这时候问题就来了，你读的数据会是确定呢吗?答案肯定是不确定的</strong>，因此对于读操作也要注意。而写操作就更不用说了，每一次的写入都会改变数据，必定加入排斥锁。在MySQL中读锁即为共享锁，写锁即为排斥锁。</p>
<ul>
<li><p><strong>共享锁（读锁）</strong>：读锁是共享的，或者说是不阻塞的，多个线程可以在同一时刻可以同时读取同一个资源而互不干扰，但是当有一个线程试图写时，是不被允许的，即读锁不阻塞其他的读操作，但是阻塞写操作。</p></li>
<li><p><strong>排斥锁（写锁）</strong>：写锁是排他的，一个写锁会阻塞其他的写锁和读锁。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享锁</span></span><br><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line"><span class="comment">//排他锁（X)</span></span><br><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></table></figure>
<h5 id="锁的粒度">2.2 锁的粒度</h5>
<p><strong>为提供共享资源并发性就是让锁的对象更具有选择性，即尽量只锁定需要修改的部分数据，而不是所有的资源，任何时候，在给定资源锁的粒度越小精度越高，则系统的并发程度越高。但是我们不能无限制的只加最小粒度的锁，因为锁也需要消耗资源的，如锁的各种操作、包括获得锁、检查锁是否解除、释放锁都会增加系统开销</strong>，因此对锁选择策略是在锁的开销和数据安全性之间寻找平衡折中。</p>
<h6 id="表级锁">2.2.1 表级锁</h6>
<p>表级锁是对整个表加锁的一种操作。MyISAM和InnoDB引擎都支持表级锁，</p>
<ul>
<li><strong>优点：</strong>是MySQL中锁定粒度最大的一种锁，实现简单，资源消耗也比较少，加锁快，只对一个表操作不会出现死锁。</li>
<li><strong>缺点</strong>：其锁定粒度最大，触发锁冲突的概率最高，并发度最低。</li>
</ul>
<p>表锁的语法是<code>lock tables … read/write</code>。可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。<code>lock tables</code>语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#为表t1上读锁，t2上写锁</span><br><span class="line">lock tables t1 read,t2 wirte;</span><br><span class="line">#释放锁</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line">mysql&gt; lock tables employee read;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; insert into employee <span class="title">values</span><span class="params">(<span class="string">&#x27;crf&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="number">15000</span>,now(),<span class="number">300</span>)</span></span>;</span><br><span class="line">ERROR <span class="number">1099</span> (HY000): Table <span class="string">&#x27;employee&#x27;</span> was locked with a READ lock <span class="keyword">and</span> can<span class="number">&#x27;</span>t be updated</span><br></pre></td></tr></table></figure></p>
<h6 id="行级锁">2.2.2 行级锁</h6>
<p>行级锁是MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁，在MySQL中MyISAM不支持行锁，InnoDB支持。<strong>记住行级锁只能对是有索引字段进行加锁从而锁住改行。</strong></p>
<ul>
<li><strong>优点：</strong>行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，</li>
<li><strong>缺点：</strong>因为粒度小，因此加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将退化使用的是表锁</strong>。</p>
<p><strong>其他注意事项：</strong></p>
<ul>
<li><p>在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁。</p></li>
<li><p>如果MySQL的行锁是针对范围索引加的锁，不是针对记录加的锁，所以即使是访问不同行的记录，如果使用了相同的索引键，也是会出现锁冲突的，这是因为间隙锁的原因（接下来会讲）</p></li>
<li><p>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</p></li>
<li><p>即便在条件中使用了索引字段，但具体是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p></li>
</ul>
<p><strong>隐式默认加锁</strong>：</p>
<ul>
<li>InnoDB自动加意向锁。</li>
<li>对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，<code>InnoDB</code>会自动给涉及数据集加排他锁<code>（X)</code>；</li>
<li>对于普通<code>SELECT</code>语句，InnoDB不会加任何锁；</li>
</ul>
<p><strong>显示加锁</strong>：</p>
<ul>
<li><strong>共享锁（S）</strong>：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code></li>
<li><strong>排他锁（X)</strong> ：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code></li>
</ul>
<p><strong><em>注意</em></strong>：正如上面所说的，行锁是根据索引上的索引项加锁实现的，即上面的对于的列必须有加索引才能是为行级锁，否则为表级锁，如下开两个客户端连接MySQL,因为不是索引，所以为表锁 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#客户端<span class="number">1</span>：不是索引，粒度为表锁，类型为排他锁</span><br><span class="line">mysql&gt; select id,<span class="function">job_name from employee_job where id <span class="title">in</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span> <span class="keyword">for</span> update</span>;</span><br><span class="line">+----+--------------+</span><br><span class="line">| id | job_name     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">2</span>  | 老板         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">#客户端2：</span></span><br><span class="line"><span class="function">mysql&gt; select id,job_name from employee_job where id <span class="title">in</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">ERROR <span class="number">1100</span> (HY000): Table <span class="string">&#x27;employee_job&#x27;</span> was <span class="keyword">not</span> locked with LOCK TABLES</span><br></pre></td></tr></table></figure></p>
<h6 id="页级锁">2.2.3 页级锁</h6>
<p>页级锁的粒度介于行级锁和表级锁中间的一种锁。它比表级锁速度快，比表级锁的冲突多，比行级锁的冲突少，但速度慢。因此页级是一种折中锁，一次锁定相邻的一组记录。BDB 支持页级锁。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p>
<p><strong><em>注意：行级锁不一定比表级锁要好，锁的粒度越细，代价越高，相比表级锁在表的头部直接加锁，行级锁还要扫描找到对应的行对其上锁，这样的代价其实是比较高的，所以表锁和行锁各有所长。</em></strong></p>
<h6 id="全局锁">2.2.4 全局锁</h6>
<p>MySQL提供了一个加全局读锁的方法，命令是<code>Flush tables with read lock</code>,当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#对所有数据库实例加读锁</span><br><span class="line">Flush tables with read lock</span><br><span class="line">#对所有数据库实例加写锁</span><br><span class="line">Flush tables with write lock</span><br></pre></td></tr></table></figure></p>
<h5 id="死锁">2.3 死锁</h5>
<p>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，</p>
<h6 id="引起死锁的原因">2.3.1 引起死锁的原因</h6>
<ul>
<li>①竞争不可抢占资源引起死锁（不可抢占是指没有使用完的资源，不能被抢占）</li>
<li>②竞争可消耗资源引起死锁</li>
<li>③线程推进顺序不当引起死锁</li>
</ul>
<p>情况1：有线程<code>p1</code>，<code>p2</code>，都需要资源<code>A</code>，<code>B</code>，本来可以<code>p1运行A</code> --&gt; <code>p1运行B</code> --&gt; <code>p2运行A</code> --&gt; <code>p2运行B</code>，但是顺序换了，<code>p1</code>运行<code>A</code>时<code>p2</code>运行<code>B</code>，容易发生第一种死锁。互相抢占资源对放持有的资源。</p>
<p>情况2：有<code>p1，p2，p3</code>三个线程，<code>p1</code>向<code>p2</code>发送消息并接受<code>p3</code>发送的消息，<code>p2</code>向<code>p3</code>发送消息并接受<code>p1</code>的消息，<code>p3</code>向<code>p1</code>发送消息并接受<code>p2</code>的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成死锁。</p>
<h6 id="产生死锁的必要条件">2.3.2 产生死锁的必要条件</h6>
<ul>
<li><p><strong>互斥条件</strong>：某资源只能被一个进程使用，其他进程请求该资源时，只能等待，直到资源使用完毕后释放资源。</p></li>
<li><p><strong>请求和保持条件</strong>：程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。</p></li>
<li><p><strong>不可抢占条件</strong>：进程已获得的资源没有使用完，不能被抢占。</p></li>
<li><p><strong>循环等待条件</strong>：必然存在一个循环链。</p></li>
</ul>
<h6 id="解决死锁的方式">2.3.3 解决死锁的方式</h6>
<p>在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在</p>
<ul>
<li><strong>预防死锁：</strong>在设计时，对锁的使用进行预防，以确保业务不会发生死锁，通过破坏死锁产生的后三个必要条件：即破坏请求持、不可抢占、循环等待条件之一来预防死锁。
<ul>
<li><strong>破坏请求和保持条件</strong>：所有线程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生。</li>
<li><strong>破坏不可抢占条件</strong>：当一个已经保持了某种不可抢占资源的线程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请</li>
<li><strong>破坏循环等待条件</strong>：对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</li>
</ul></li>
<li><p><strong>解除死锁：</strong>产生死锁时，能够从死锁中解脱处理，比如一种策略超时退出。在MySQL中这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置，默认为<code>50s</code>.</p></li>
<li><p><strong>检查死锁：</strong>在MySQL种有这样的机制，线程发现死锁后，会主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。可将参数<code>innodb_deadlock_detect</code>设置为<code>on</code>，表示开启这个逻辑。但是它有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，消耗大。</p></li>
<li><p><strong>一种特殊情况：</strong>在<code>REPEATABLE-READ</code>隔离级别下，如果两个线程同时对相同条件记录用<code>SELECT…FOR UPDATE</code>加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成<code>READ COMMITTED</code>，就可避免问题。</p></li>
</ul>
<h5 id="三种行级锁模式原理">2.4 三种行级锁模式（原理）</h5>
<h6 id="记录锁">2.4.1 记录锁</h6>
<p><strong>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，粒度是行级锁，类型是排他锁</strong>。一般记录锁出现在<code>select、update</code>语句，比如下面这句，它会在<code>id=1</code>的记录上加上记录锁，以阻止其他事务插入，更新，删除和更新<code>id=1</code>这一行。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id 列必须为主键列或唯一索引列</span></span><br><span class="line">SELECT * FROM test WHERE id=<span class="number">1</span> FOR UPDATE;</span><br><span class="line">UPDATE SET age = <span class="number">50</span> WHERE id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure> <strong>记录锁的条件：</strong></p>
<ul>
<li><code>id</code> 列必须为唯一索引列或主键列(主键索引)，否则上述语句加的锁就会变成临键锁(有关临键锁下面会讲)。</li>
<li>同时查询语句的条件子句必须为精准匹配即为<code>=</code>，不能为<code>&gt;、&lt;、like</code>等，否则也会退化成间隙锁或者临键锁</li>
</ul>
<p><strong><em>注意：如果要锁的列没有索引，进行全表记录加锁（行级锁的性质）</em></strong></p>
<h6 id="间隙锁">2.4.2 间隙锁</h6>
<p><strong>间隙锁<code>Gap Lock</code>是指在InnoDB存储引擎中锁可以加在不存在的空闲空间的一种锁</strong>。它能在两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。<strong>间隙锁是一种行级锁，是 InnoDB在 RR(可重复读) 隔离级别下为了解决幻读问题时引入的锁机制。</strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</p>
<p><strong>产生间隙锁的条件：</strong></p>
<ul>
<li>使用普通索引锁定，或者使用多列唯一索引，或者使用唯一索引锁定多行记录。</li>
<li>条件子句不为精确匹配，为范围</li>
</ul>
<p><strong>可能光说不好理解，看例子：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建test表，id为主键索引</span></span><br><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` <span class="built_in">int</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="built_in">varchar</span>(<span class="number">8</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">INSERT INTO `test` <span class="built_in">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;小罗&#x27;</span>),(<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;小黄&#x27;</span>),(<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>),(<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>);</span><br></pre></td></tr></table></figure> 上面的插入语句完成后，<code>test</code>表中存在的隐藏间隙如下： <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/gaplock.png" width="600"> 即有范围：<code>(-∞, 1]、(1, 5]、(5, 7]、(7, 11]、(11, +∞]</code>，那么当我使用下面语句的时候就会触发间隙锁 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM `test` WHERE `id` BETWEEN <span class="number">5</span> AND <span class="number">7</span> FOR UPDATE;</span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;小张1&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">9</span>, <span class="string">&#x27;大东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">11</span>, <span class="string">&#x27;李西&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务8插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">12</span>, <span class="string">&#x27;张三&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure> 从上面我们可以看到，<code>(5, 7]、(7, 11]</code>这两个区间被事务1锁住，在此期间的其他事务的插入操作失败，而其它区间，都可以正常插入数据。所以我们可以得出结论：当我们给 <code>(5, 7]</code>这个区间加锁的时候，会锁住 <code>(5, 7]、(7, 11]</code>这两个区间。</p>
<p><strong>间隙锁的缺点</strong>:</p>
<ul>
<li>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。虽然解决了幻读，但在某些场景下这可能会对性能造成很大的危害</li>
<li>当Query无法利用索引的时候， Innodb会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；</li>
</ul>
<p><strong>间隙锁的作用：</strong></p>
<ul>
<li>解决可重复读隔离级别下的幻读</li>
<li>为了数据恢复和复制的需要。</li>
</ul>
<p><strong><em>注意：可重复读级别下才会有间隙锁！还有如果对不存的记录操作即使使用<code>=</code>也会产生间隙锁，如<code>select id,name from test where id=3 for update;</code>,id=3是不存在的记录</em></strong></p>
<h6 id="临键锁next-key-locks">2.4.3 临键锁（Next-Key Locks）</h6>
<p><strong><code>Next-key locks</code>是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。</strong></p>
<p>也可以理解为一种特殊的间隙锁，因此临建锁肯定也可以解决幻读的问题。 <strong>每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据</strong>。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，<strong>而临键锁只与非唯一索引列有关，在唯一索引列（包括主键索引）上不存在临键锁。</strong>即临键锁是对非唯一索引而言的。</p>
<p>假设有如下表：InnoDB，RR隔离级别，<code>id</code>主键, <code>age</code>普通索引 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/nextkeylocks.png" width="600"> 则有<code>age</code>范围:<code>(-∞, 10],(10, 24],(24, 32],(32, 45],(45, +∞]</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/事务A执行下述语句</span><br><span class="line">-- 根据非唯一索引列 UPDATE 某条记录 </span><br><span class="line">UPDATE table SET name = Vladimir WHERE age = <span class="number">24</span>; </span><br><span class="line">-- 或根据非唯一索引列 锁住某条记录 </span><br><span class="line">SELECT * FROM table WHERE age = <span class="number">24</span> FOR UPDATE;</span><br><span class="line"><span class="comment">//事务B执行下述语句</span></span><br><span class="line"><span class="function">INSERT INTO table <span class="title">VALUES</span><span class="params">(<span class="number">100</span>, <span class="number">26</span>, <span class="string">&#x27;tianqi&#x27;</span>)</span></span>; </span><br></pre></td></tr></table></figure> 上面因为<code>age=26</code>恰好在<code>(24,32]范围内</code>,age为非唯一索引，使用临检索模式的行级锁，则不管事务A执行那个语句，事务B的插入语句总会阻塞。</p>
<p><strong>总结：</strong></p>
<ul>
<li><strong>InnoDB 中的行锁的实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁。</strong></li>
<li><strong>记录锁</strong>存在于包括主键索引在内的唯一索引中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于非唯一索引中，锁定开区间范围内的一段间隔，它是基于临键锁实现的。</li>
<li><strong>临键锁</strong>存在于非唯一索引中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的间隙锁，锁定一段左开右闭的索引区间。</li>
</ul>
<h5 id="意向锁">2.5 意向锁</h5>
<p>意向锁又分为<strong>意向共享锁（IS）</strong>和 <strong>意向排他锁（IX）</strong>。在介绍意向锁的意义之前，必须明白下面四点：</p>
<ul>
<li>意向共享锁（IS）和 意向排他锁（IX）都是<strong>表锁</strong>。</li>
<li><strong>意向锁是一种不与行级锁冲突的表级锁，这一点非常重要。它只会与非意向的表锁冲突</strong></li>
<li><strong>意向锁与意向锁之间永远是兼容的</strong></li>
<li>意向锁是<code>InnoDB</code>自动加的， 不需用户干预。当兵对表或对行加排他锁时，就会获得意向排他锁；加共享锁时，会获得意向共享锁。</li>
<li>意向锁是在<code>InnoDB</code>下存在的内部锁，对于<code>MyISAM</code>而言 没有意向锁之说。</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">兼容性</th>
<th style="text-align: center;">表IS</th>
<th style="text-align: center;">表IX</th>
<th style="text-align: center;">表s</th>
<th style="text-align: center;">表x</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>表IS</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>表IX</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>表S</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>表X</strong></td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
</tbody>
</table>
<p><strong>意向锁的存在目的是为了让InnoDB中的行锁和表锁能够更高效的共存</strong>。假设有下表，InnoDB，RR隔离级别 <code>id</code>是主键 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/ilock.png" width="500"></p>
<p>加入现在有事务<code>A</code>，进行了一条<code>SELECT * FROM users WHERE id = 6 FOR UPDATE;</code>但未提交，那么事务<code>A</code>会获得<code>id=6</code>的行级锁，且为记录排他锁，同时还有自动生成一个意向排他锁。</p>
<p>这时候有个事务<code>B</code>,进行操作<code>LOCK TABLES users READ;</code>会失败，因为对于要表锁来说，必须要保证：</p>
<ul>
<li>当前没有其他事务持有<code>users</code>表的排他锁。</li>
<li>当前没有其他事务持有<code>users</code>表中任意一行的排他锁 。</li>
</ul>
<p>但是现在<code>users</code>表的排他锁已经被事务<code>A</code>持有了，事务B的这个想获取表共享锁的操作会失败。</p>
<p>上面的例子是有意向锁的情况，试想一下没有意向锁和表锁情况会这样：事务B会去检查<code>user</code>表中的每一行查看是否有排他锁，如果有则无法执行，无则会执行。很明显这样的效率极低，但有意向锁后，只需检查意向表锁即可。</p>
<h4 id="事务">3. 事务</h4>
<p>事务就是由一批SQL语句组成，可以说它是一个独立的工作单元。<strong>事务处理可以用来维护数据的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行，事务处理是一种机制，利用事务处理可以保证成批的MySQL操作不会只执行一部分，如果全部执行那没问题，如果在执行过程中发生错误，它就会进行回退以恢复到数据库以前安全版本</strong>。MySQL中InnoDB支持事务，MyISAM不支持。</p>
<h5 id="事务的acid">3.1 事务的ACID</h5>
<p>一个运行良好的事务处理系统，必须具备四大特性：原子性(<code>atomicity</code>)、一致性(<code>consistency</code>)、隔离性(<code>isolation</code>)和持久性(<code>durability</code>)。实现了ACID的数据库相比于未实现的数据库，其通常需要更强的CPU处理能力，更大的内存和磁盘空间。因此要酌情堪虑是否选用事务型存储引擎。</p>
<ul>
<li><strong>原子性</strong>：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的操作要么全部提交成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>：数据库总是从一个一致性状态转移达到另一个一致性状态，一致性状态就是由事务原子性保障，一个事务提交了，那是ok的，一个事务未提交，那也是OK的。</li>
<li><strong>隔离性</strong>：通常来说，一个事务所做的修改在未提交以前，对其他事务是不可见的。事务间是互不干扰的。</li>
<li><strong>持久性</strong>：一旦事务提交了，其所做的修改会永久保存到数据库总中，即使系统崩溃，修改的数据也不会丢失，（持久性不能做到100%保证策略，如果数据库本身就能做到吃性，那么要备份又有什么用呢）</li>
</ul>
<h5 id="隔离级别">3.2 隔离级别</h5>
<p>在SQL标准中定义了四种隔离级别，<strong>每一种级别都规定了一个事务所做的修改，在哪些事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也低</strong></p>
<ul>
<li><p><strong>未提交读(<code>read uncommitted</code>)</strong>：在该隔离级别，事务中的修改，即使没有提交，对其他事务也都是可见的。<strong>事务可以读取未提交的数据，这也被称为脏读</strong>。这个级别会导致喝多问题，从性能上来说，该级别没有比其他级别好很多，一般不推荐使用。</p></li>
<li><strong>提交读(<code>read committed</code>)：在该级别，一个事务开始时只能看见已经提交的事务的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，因此也可称为</strong>不可重复的**。这个隔离级别时大多数数据库默认的隔离级别。</li>
<li><strong>可重复读(<code>repeatable read</code>)</strong>：在该级别，保证了同一个事务多次读取同样的记录的结果是一致的。可重复读是MySQ的默认隔离级别，解决了脏读的问题，但是对于幻读无法解决。<strong>所谓的幻读就是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围插入新的记录，当之前的事务再次读取该范围记录时，产生幻行。</strong>InooDB引擎使用多版本控制MVCC解决幻读问题。</li>
<li><p><strong>可串行化(<code>serializable1</code>)</strong>：该隔离级别时最高的隔离级别，它通过强制事务串行执行，避免了前面说的幻读问题。简单来说，就是在读取每一行数据都加锁，所有会导致大量的超时和锁争问题。</p></li>
</ul>
<h5 id="事务日志">3.3 事务日志</h5>
<p>首先必须明白InnoDB存储引擎是以页为单位来管理存储空间的，真正访问页面之前，需要把在磁盘上的页缓存到内存中的缓存池之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘（checkpoint机制），通过缓存池来优化cpu和磁盘之间的鸿沟。事务的原子性、一致性和持久性由事务的<code>redo日志</code>和<code>undo日志</code>来保证。</p>
<ul>
<li><p><strong><code>REDO LOG</code>称为重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</strong><code>redo</code>日志的存在使得我们再对表进行修改时会把这些修改写进日志里，然后再写入磁盘，只有日志写入成功，才算事务的提交完成，<strong>这样即使数据库发生宕机未刷新到磁盘，也可以通过<code>redo</code>日志恢复。</strong></p></li>
<li><p><strong><code>UNDO LOG</code>称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性</strong>。有的DBA或许会认为<code>UNDO</code>是<code>REDO</code>的逆过程，其实不然。<code>undo log</code>是存储引擎(<code>innodb</code>)生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了<code>insert</code>语句操作，那么<code>undo log</code>就记录一条与之相反的delete操作，主要用于事务回滚（<code>undo log</code>记录的是每个修改操作的逆操作）和一致性非锁定定读（<code>undo log</code>回滚行记录到某种特定的版本,mvcc，多版本并发控制）。 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/log.png" width="600"></p></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zuodaoyong/article/details/123454426">MySQL事务日志详解</a></p>
<h4 id="多版本并发控制mvcc">4. 多版本并发控制MVCC</h4>
<p><strong>在MySQL你可以认为MVCC是行级锁的一种变种，为适应并提升并发性能，大多数情况下避免了加锁操作，因此开销更低，也解决了MySQL默认隔离级别可重复读下的幻读问题</strong>。MVCC旨在<code>repeatable read</code>和<code>read committed</code>下工作。</p>
<p><strong>MVCC的实现，是通过保存数据在某个时间点（说是时间点是未了更好理解，其实是事务的系统版本号）的快照来实现的。在InnoDB的MVCC中，通过在每行记录后面保存两个隐藏的列来实现，这两个列一个是保存了行的创建时间，一个保存了行的过期时间，当然存储的不是实际的时间值，而是系统版本号，系统版本号会根据没新开一个事务而自动递增</strong>。有了这两个列之后，对于<code>select\update\delete\insert</code>则必须遵循下面的规则：</p>
<ul>
<li><strong><code>select</code></strong>：对于select，InnoDB会根据一下规则来检索
<ul>
<li><ol type="a">
<li><strong>InnoDB只查找版本号早于当前事务版本号的数据行，这样确保了事务读取的行，要么在事务开始之前就已经存在，要么是当前事务自己插入或者修改的，绝不可能是该事务之后的事务进行修改的，这样解决了幻读的问题。</strong></li>
</ol></li>
<li><ol start="2" type="a">
<li><strong>行的删除版本要么未定义，要么就是大于当前事务的版本号，这就可以确保事务读取到的行，在该十五i开始前还未删除。如果之前就删除了那么删除版本号肯定有值而读取不了。</strong></li>
</ol></li>
</ul></li>
<li><p><strong><code>INSERT</code></strong>：InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p></li>
<li><p><strong><code>DELETE</code></strong>：InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p></li>
<li><p><strong><code>UPDATE</code></strong>：InnoDB为插入一行新记录，保存当前事务系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p></li>
</ul>
<p><strong><em>注意：MVCC并不能彻底解决并发带来的安全问题，它只是起到一个缓解并发冲突量的作用，如果两个事务有明显的次序要求，如事务A，B是希望A修改该行后再交由B修改，那么就必须人为事务A所在的行加锁，这样才能保证B是再A修改后才修改的</em></strong>，因此该用锁的时候还是要用，否则有MVCC就能解决这些的话，还要锁干嘛</p>
<h4 id="mysql的存储引擎">5. MySQL的存储引擎</h4>
<p>数据库存储引擎是极其重要的，这是因为：</p>
<ul>
<li>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。</li>
<li>不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL的核心就是存储引擎。</li>
<li>用户可以根据不同的需求为数据表选择不同的存储引擎(表类型)</li>
</ul>
<p>MySQL的存储引擎主要有InnoDB、MyISAM。</p>
<h5 id="innodb">5.1 InnoDB</h5>
<p>InnoDB是MySQL当中默认的事务型存储引擎，它被设计用来处理大量的短期事务，短期事务大部分情况下都是正常提交的，很少会回滚。<strong>InnoDB的数据存储在表空间<code>xxx.ibd</code>中，能将表的数据和索引放置在单独的文件中，其表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能，不过它的二级索引（非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的索引都会很大，消耗空间多</strong></p>
<p><strong>InnoDB的特点：</strong></p>
<ul>
<li><strong>采用MVCC多版本并发控制来支持高并发，并且实现了四个标准隔离级别，默认级别为可重复的，使用间隙锁和MVCC策略防止了幻读的出现。</strong></li>
<li>支持自动增长列`AUTO_INCREMENT·。自动增长列的值不能为空，且值必须唯一。MySQL中规定自增列必须为主键。</li>
<li>支持外键，保证数据的完整性和正确性。外键所在表为子表，外键所依赖的表为父表。父表中被子表外键关联的字段必须为主键</li>
<li><strong>支持行级锁，提高并发访问性能。</strong></li>
<li><strong>作为事务性存储，InnoDB通过一些机制和工具支持真正的热备份。</strong>（热备份是指在正常情况下,两余度同时工作,当某一余度出现故障时,系统可切除故障余度,启用单余度方式,降级工作.本系统采用热备份方式）</li>
</ul>
<h5 id="myisam">5.2 MyISAM</h5>
<p>MyISAM是MySQL早期的默认存储引擎。MyISAM将表存储在两个文件中：数据文件(<code>xxx.MYD</code>)和索引文件(<code>xxx.MYI</code>)。MyISAM不支持事务和行级锁，而且有一个致命的缺陷就是崩溃后无法安全恢复。</p>
<p><strong>MyISAM特点：</strong></p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>占用空间小，访问速度快 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/engine.png" width="700"></li>
</ul>
<h4 id="mysql的索引">6. MySQL的索引</h4>
<p>索引在MySQL中也叫<strong>键</strong>，是存储引擎用于快速找到记录的一种数据结构。因此索引对于数据库的性能非常关键，尤其是当表中的数据量越来越多时，索引对性能的影响愈发重要。总计索引的优点有三点：</p>
<ul>
<li>索引可以快速查询，大大减少了服务器查找时需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变成顺序I/O，如<code>order by</code>就是索引支持的</li>
</ul>
<p><strong>索引分类</strong>：</p>
<ul>
<li><strong>普通索引：</strong>是最基本的索引，主要其加快查询速度，可使用<code>key</code>或者<code>index</code>定义一个列的普通索引或联合普通索引。</li>
<li><strong>主键索引</strong>：即主键，一个表只能有一个主键，则也就只能有一个主键索引，不允许有重复值和<code>NULL</code>值。以<code>primary key</code>定义。</li>
<li><strong>唯一索引</strong>：不允许有重复值，但运行为<code>NULL</code>值，同时一个表可以有多个唯一索引。适用<code>unique key</code>或者<code>unique index</code>定义</li>
</ul>
<p><strong><em>注意</em></strong>：<code>key</code>和<code>index</code>的区别是，<code>key</code>除了会定义一个相应的索引之外，还会形成一种约束，约束该列的规范，比如<code>primary key</code>约束表只能有一个主键列，且不能重复不能为NULL，而<code>index</code>只是生成这一的一个索引。</p>
<h5 id="索引基础">6.1 索引基础</h5>
<p>理解索引当然是看例子更合适： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name from sahilia.actor where actor_id=<span class="number">5</span>;</span><br></pre></td></tr></table></figure> 上面这个检索语句中，如果在<code>actor_id</code>列上设有索引，则MySQL将使用索引找到<code>actor_id=5</code>的行，即MySQL会在索引上按值查找，然后返回该值的数据行。</p>
<p>索引可以包含一个或多个列(创建键)。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效的使用索引的<strong>最左前缀原则</strong>。需要明确的是<strong>最左前缀原则</strong>是发生在复合索引上的，只有复合索引才会有所谓的左和右之分，在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配</p>
<p><strong>mysql 建立多列索引（联合索引）有最左前缀的原则，即最左优先，如：</strong></p>
<ul>
<li>如果有一个 2 列的索引<code>(col1, col2)</code>，则已经对<code>(col1)、(col1, col2)</code>上建立了索引；</li>
<li>如果有一个 3 列索引<code>(col1, col2, col3)</code>，则已经对<code>(col1)、(col1, col2)、(col1, col2, col3)</code>上建立了索引；</li>
</ul>
<p><strong>原理</strong>：</p>
<p>B+树的数据项是复合的数据结构，比如<code>(name,age,sex)</code>的时候，B+树是按照从左到右的顺序来建立索引树的，比如当<code>(张三,20,F)</code>这样的数据来检索的时候，B+树就优先比较name来确定下一步的搜索方向，如果name相同则再依次比较<code>age</code>和<code>sex</code>，最后得到检索到的数据；但当<code>（20，F）</code>这样的没有<code>name</code>的数据来的时候，B+树就不知道第一步应该检查哪个节点，因此此时就不会使用联合索引。</p>
<h5 id="索引类型">6.2 索引类型</h5>
<p>索引有很多种类型，可以为不同的场景提高供更好的性能。在MySQL中，索引是在存储引擎实现的，因此没有统一的索引标准。下面介绍MySQL中的支持的索引类型。</p>
<h6 id="btree索引">6.2.1 B+Tree索引</h6>
<p>InnoDB使用的时B+Tree索引。这意味着所有的值都是按顺序存储的，<strong>且数据域都存储在叶子节点处，非叶子节点只存储索引不能存储数据</strong>，这样对于查询性能来说很稳定，都是<code>h</code>。B+Tree索引适用于全键值、键值范围或键前缀查找：比如定义了普通联合索引<code>key(last_name,first_name,birthday)</code></p>
<ul>
<li><strong>全值匹配：</strong>指的是和索引中的所有列进行匹配，即<code>last_name,first_name,birthday</code>均匹配</li>
<li><strong>匹配最左前缀</strong>：查找时，可以只列举第一列<code>last_name</code>进行查找</li>
<li><strong>匹配列前缀</strong>：也可只匹配某一列的值的开头部分，如寻找姓以<code>J</code>开头的数据</li>
<li><strong>匹配范围</strong>：对姓名<code>last_name</code>也支持范围查找。</li>
</ul>
<p><strong><em>注意：说到B+Tree的叶子节点，必须区分MySQL中的聚簇索引和非聚簇索引（二级索引），在聚簇索引的叶子节点存储的是完整的行数据，而二级索引叶子节点存储的是数据<code>行指针</code>,这里的<code>行指针</code>的实质是叶子节点保存只是行的主键值，因此非聚簇索引必须还要在聚簇索引结构上进行查找，这也是为什么它被称为二级索引</em></strong></p>
<p>更详细的B+Tree见：<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构</a></p>
<h6 id="哈希索引">6.2.2 哈希索引</h6>
<p><strong>哈希索引是基于哈希表实现的，因此对于使用哈希索引其关键字的存储是无序的，不支持范围匹配查找，只有精确匹配锁索引所有列的查询才有效。</strong>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码解决其存储的位置，因此其查找一个值的复杂度为<code>O(1)</code>，比B+Tree更快。</p>
<p>在MySQL中，只有Memory引擎显式支持哈希索引，也是其默认的索引类型。</p>
<p><strong>优点：</strong></p>
<ul>
<li>访问内存的速度很快，同时因为是通过计算哈希值来确定关键字位置，访问哈希索引的数据也很快</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不会存储字段值，所有不能使用索引中的值来避免读行。</li>
<li>哈希索引数据是按照计算的哈希值排列的，因此也就是无序的，不支持范围查找。</li>
<li>哈希索引不想B+Tree索引那样支持部分列查找，因为索引的哈希值是所有列共同计算的结果。</li>
<li>哈希冲突多的时候，维护操作的代价比较高昂。</li>
</ul>
<h5 id="为什么b树更适合做索引">6.3 为什么B+树更适合做索引</h5>
<p><strong>我们先分析B+Tree与众不同的特点：</strong></p>
<ul>
<li>第一个就是B+树在B树的基础之上最重要的改进就是非叶子结点只存储关键字和下一层的索引，不存储Data域，只在叶子结点存储Data域；</li>
<li>第二点就是所有叶子结点增加一个链指针，使所有叶结点构成一个有序链表，因此当我们需要有序遍历所有关键字时，直接从最小关键字的叶子结点开始遍历即可。</li>
</ul>
<h6 id="非叶子结点不存储data域的好处">6.3.1非叶子结点不存储Data域的好处</h6>
<ul>
<li><p><strong>每一个结点可以存放更多的关键字和下一层的索引。数据库是存储在磁盘上的，我们读取数据是从磁盘读取到内存中，我们在进行磁盘预读取时，是以块的单位进行数据读取，我们在检索B/B+树的结点时，每次以块为单位将一个结点读取到内存中，若一块磁盘包含了树结点以外的数据，就造成了浪费，因此我们需要使每一个结点的数据大小正好或者接近一块磁盘的大小</strong>。于是我们在构建B+/B树时，树的阶数其实就取决于一块磁盘中能容纳多少个关键字以及相关的索引和Data域。<strong>B+树的非叶子结点不存储Data域，因此它可以存储更多个关键字和下一层索引，因此B+树会比B树更宽胖</strong>。若我需要查找的关键字正好在叶子结点，B+树所进行的I/O次数更少,因为途中经过每一层，我们都需要进行一次I/O读取一个结点，B+树会更矮，途径的层数会更少。</p></li>
<li><p>使得B+树查询速度更稳定，B+树所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p></li>
</ul>
<h6 id="所有叶结点构成一个有序链表的好处">6.3.2所有叶结点构成一个有序链表的好处</h6>
<ul>
<li><p><strong>B+树便于区间查找（这点才是B+树作为索引的关键）</strong>，我们进行数据库查询大多为区间查询，B+树天然具备排序功能，B+树所有的叶子结点构成了一个有序链表，在查询大小区间的数据时候更方便，B+树查询，只需通过头结点往下找到第一个叶子结点，然后在叶子结点的链表上就行遍历即可完成区间查询，而B树的关键字大小相邻近的结点可能隔得很远，要想进行区间查询需要不停的进行中序遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li>
<li><p>B+树全结点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要进行中序遍历，这有利于数据库做全表扫描。</p></li>
</ul>
<p><strong>总结B+树优点(选择B+树作为索引的原因)</strong></p>
<ul>
<li>因为没有非叶子节点没有存储数据，因此单一非叶子结点能存储更多的关键字索引</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；</li>
<li>所有叶子节点形成有序链表，便于范围查询以及全结点遍历更快。</li>
</ul>
<h5 id="高性能的索引策略">6.4 高性能的索引策略</h5>
<p>正确的创建和使用索引是实现高性能查询的基础。创建索引是最忌讳的就是为每一个列都建上独立的索引或者按照错误的顺序创建联合索引，这样会大大降低性能。</p>
<h6 id="选择合适的索引序列">6.4.1 选择合适的索引序列</h6>
<p>对于B+Tree多列索引来说，按照其最左前缀匹配原则，正确的的顺序依赖于使用哪些列选择性高，同时还有考虑如何更好的满足排序和分组的需要，即满足<code>order by\group by\distinct</code>查询子句的查询需求。</p>
<p><strong>有一条经验法则：将选择性最高的列放在索引的最前面。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">count</span><span class="params">(distinct staff_id)</span>/<span class="title">count</span><span class="params">(*)</span> as staff_id_selectivity,</span></span><br><span class="line"><span class="function">	-&gt; <span class="title">count</span><span class="params">(distinct customer_id)</span>/<span class="title">count</span><span class="params">(*)</span> as customer_id_selectivoty,</span></span><br><span class="line"><span class="function">	-&gt; <span class="title">count</span><span class="params">(*)</span></span></span><br><span class="line"><span class="function">	-&gt; from payment</span>;</span><br><span class="line">-------------------------------输出--------------------------------------------------*</span><br><span class="line">staff_id_seletivity:<span class="number">0.0001</span></span><br><span class="line">customer_id_selectibity:<span class="number">0.0373</span></span><br><span class="line"><span class="built_in">count</span>(*):<span class="number">16049</span></span><br></pre></td></tr></table></figure> 从上面可以看到选择性更高的是<code>customer_id</code>，因此将其放在索引第一列： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table payment add <span class="title">key</span><span class="params">(customer_id,staff_id)</span></span>;</span><br></pre></td></tr></table></figure> 最后还要说一句尽管这条关于选择性和基数的经验法则对于一般情况适用，但是别忘了还要考虑<code>where</code>子句当中的排序、分组和范围查询，要对这些折中考虑。</p>
<h5 id="聚簇索引">6.5 聚簇索引</h5>
<p>首先要明白的是聚簇索引不是开始说到的属于<strong>普通索引、唯一索引和主键索引的分类</strong>，MySQL的索引分类只有这三种。<strong>聚簇索引并不是一个单独索引类型，而是一种数据的存储方式的专有名词</strong>。</p>
<p><strong>对于InnoDB来说，InnoDB就会选择一个唯一的非空索引作为聚簇索引，当没有符合的唯一非空索引，就会隐式的定义一个主键来作为聚簇索引</strong>，因此一般情况你也可以理解主键就是聚簇索引；但是，有些时候唯一索引也有可能是聚簇索引</p>
<h6 id="聚簇索引与非聚簇索引的区别">6.5.1 聚簇索引与非聚簇索引的区别</h6>
<p>在上面说到B+Tree的时候已经介绍到了聚簇索引和非聚簇索引之间的区别，这里在系统的总结一下。</p>
<ul>
<li><strong>首先就是一张表只有有一个聚簇索引，但可以有多个非聚簇索引</strong></li>
<li><strong>另外聚簇索引的叶子节点存储的是完整的行数据，而非聚簇索引的叶子节点存储的是其相应主键列的关键字值，因此使用非聚簇索引进行查询时，除了查询非聚簇索引得到主键关键字值外，还要利用该值进行回表查询聚簇索引，最终得到整个行数据</strong>，这也是非聚簇索引又叫二级索引的由来。</li>
</ul>
<p><img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/aindex.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用主键索引(聚簇索引)查询</span></span><br><span class="line">select * from table where ID = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//使用非聚簇索引查询</span></span><br><span class="line">select * from table where k = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="聚簇索引的优缺点">6.5.2 聚簇索引的优缺点</h6>
<p>聚簇索引可能对性能有帮助，但也会导致严重的问题，下面分析其优缺点</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>聚簇索引的存在将相关数据都保存在一起，磁盘一次I/O就获得所有数据</strong>，如用户邮箱的管理，以ID为主键形成聚簇索引结构，则更加ID用户将其相关的数据都聚簇在叶子节点，可一下获得其所有数据。如果没有聚簇索引，则要获取该ID的所有信息要经过多次磁盘I/O</li>
<li><strong>数据访问速度更快，聚簇索引将索引和数据保存在同一个B+Tree上，因此聚簇索引比非聚簇索引的查询更快。</strong></li>
<li>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p><strong>插入速度严重依赖插入的顺序，其存储结构说明了按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式</strong>。如果不是按照逐渐顺序，会慢很大，而且最坏使用<code>optimize table</code>重新组织一下表。</p></li>
<li><p>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</p></li>
<li><p>更新行或插入行被强制移动带新的行，如果是要插入满行的一页，则会导致<code>页分类</code>。存储引擎通过页分裂称两个页面以能够存储该行，一次页分裂操作，导致表占有更多的空间。</p></li>
</ul>
<h5 id="覆盖索引">6.6 覆盖索引</h5>
<p>上面提到了二级索引想要查询行的所有列必须进行回表查询，有没有什么办法不用回表查询就能得到一些列的信息呢。这是要就用到了<strong>覆盖索引</strong>，<strong>如果一个索引包含了所有要查询字段的值，就称为为覆盖索引</strong>。在<code>select</code>前使用<code>explain</code>表示优先使用覆盖索引</p>
<p>不是所有的索引类型都能成为覆盖索引，覆盖索引必须存储该索引所在行的值，而像哈希索引、空间索引这些都不能存储。因此MySQL只有B+Tree索引能使用覆盖索引。现在来讲解覆盖索引的实现要求：</p>
<ul>
<li>表有除一个主键索引，其他列建立相应的零和索引，这一才能在二级索引存储有其他列的值。对于主键很明显在二级索引的叶子节点上</li>
<li>在<code>select</code>上使用<code>explain</code>，优先使用覆盖索引</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lengyue1084/article/details/119352209">覆盖索引详解</a></p>
<h5 id="冗余索引">6.7 冗余索引</h5>
<p>同一信息的重复储存，叫做冗余,冗余索引通常发生在为表添加新索引的时候。如<code>key(name,city)</code>和<code>key(name)</code>这两个索引就是冗余索引，能够命中后者的查询肯定能够命中前者。</p>
<p>大多数情况下我们都不需要冗余索引，因为索引的维护需要一定的开销。但有时候却页不得不创建一个冗余索引，就比如新加了一个字段，同时现有的联合索引已经非常庞大，如果再将这字段加入这个联合索引就会使得该联合索引更加庞大，此时使用新建冗余索引更好。</p>
<h4 id="优化查询">7. 优化查询</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 21:59:16" itemprop="dateCreated datePublished" datetime="2022-07-30T21:59:16+08:00">2022-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-05 22:38:42" itemprop="dateModified" datetime="2022-08-05T22:38:42+08:00">2022-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/30/MySQL/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/30/MySQL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="了解sql">1. 了解SQL</h4>
<h5 id="数据库基础">1.1 数据库基础</h5>
<p>数据库是一个以某种有组织的方式存储的数据集合。<code>MySQL</code>数据库中只有一个用户，名为<code>root</code>，但是它可以有多个数据库，如下是与<code>Oracle</code>数据库的不同之处： <img src="/2022/07/30/MySQL/different.png" width="700"></p>
<h6 id="表的概念">1.1.1 表的概念</h6>
<p>在数据库中，<strong>表是一种结构化的文件，用来存储某种特定类型的数据</strong>。数据库中的表都有一个唯一名字来标识自己，称为<strong>表名</strong>。同时表具有一些特性，这些特性定义了数据在表中如何存储，可以存储什么样的数据，数据如何分解、各部分信息如何让命名等等。</p>
<p>描述表的这组信息就是所谓的<strong>模式</strong>，模式即指关于数据库和表的布局以及特性的信息。</p>
<h6 id="列和数据类型">1.1.2 列和数据类型</h6>
<p><strong>表由列组成，列就是表中的一个字段</strong>。列中存储着表的某部分信息，数据库中的列都有相应的类型，数据类型定义了列中可以存储的数据种类。</p>
<h6 id="行">1.1.3 行</h6>
<p><strong>虽然表由列组成，但存储过程中，表中的数据是按行存储的</strong>。每次保存的记录都存储在自己所在的行中，你也可以理解为行就是表中的一个记录。</p>
<h6 id="主键">1.1.4 主键</h6>
<p><strong>表中的每一行都应该有唯一标识自己的一列，这样搜索起来才不容易出错，保证数据的完整性</strong>，就如一个顾客列表可以使用顾客编号来作为主键,如果使用顾客姓名来搜索，万一有相同姓名的顾客搜索就容易混淆。<strong>因此对于每创建一个表来说都应该至少设置一列为主键</strong>，作为主键的列必须满足：</p>
<ul>
<li>任意两行都不具有相同的主键值</li>
<li>每一行都必须具有一个主键值（主键列不允许为NULL值）</li>
</ul>
<p>主键虽然通常定义在表的一列上，但是也可以使用多个列作为主键</p>
<h6 id="外键">1.1.5 外键</h6>
<p><strong>外键就是某个表中被定义为外键的一列，它包含另一个表的主键值</strong>，定义两个表之间的关系，一个表中可以有多个外键。其作用主要有：</p>
<ul>
<li>不用重复存储另一个表中有的数据到本表，只需通过外键建立连续即可，节省了时间和空间</li>
<li>同时在删除中必须先删除外键才能删除主键，因此能保证数据的完整性</li>
</ul>
<h4 id="mysql的安装和修改">2. MySQL的安装和修改</h4>
<p>在ubuntu中可以使用<code>sudo apt install mysql-server</code>进行安装MySQL数据库。以下是对数据库的的初始化必做事项 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#进入本地数据库shell界面</span><br><span class="line">mysql -u root -p</span><br><span class="line">#进入其他主机的数据库shell</span><br><span class="line">mysql -h 192.168.18.251 -u root -p</span><br><span class="line">#修改密码</span><br><span class="line">mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<h5 id="启动和关闭mysql服务器">2.1 启动和关闭MySQL服务器</h5>
<p>MySQLS数据库分为客户端和服务器，<code>mysql-server</code>与<code>mysql-client</code>是DBMS的两个面向不同操作对象的工具。<code>server</code>是DBMS面向物理层次，包含存储数据的一系列机制、处理方法的集成；<code>client</code>是DBMS面向用户，提供一系列工具为用户所用，这些工具包括通常写的<code>sql</code>在内都要通过<code>server</code>的编译才能操作物理数据。即在连接服务器时要先开启<code>mysql-server</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种启动mysql服务器方法</span></span><br><span class="line">service mysql start</span><br><span class="line">systemctl statrt mysql</span><br><span class="line">systemctl restart mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看状态</span></span><br><span class="line">systemctl status mysql.service</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭服务器</span></span><br><span class="line">systectl stop mysql</span><br><span class="line">service mysql stop</span><br></pre></td></tr></table></figure>
<p><strong>注意数据库shell界面</strong>，<code>shell</code>界面是<code>mysql-client</code>提供了一种人与<code>mysql</code>直接交互的命令窗口，同Linux的<code>bashShell</code>是一样的。</p>
<h5 id="其他对数据库的操作">2.2 其他对数据库的操作</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#展示目前数据库目录</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.05 sec)</span><br><span class="line"></span><br><span class="line">#创建数据库:创建一个使用utf-8字符集，并带校对规则的mydb3数据库。会对存入的数据进行检查。</span><br><span class="line">mysql&gt; create database mydb3 character set utf8 collate utf8_general_ci;</span><br><span class="line">Query OK, 1 row affected, 2 warnings (0.03 sec)</span><br><span class="line"></span><br><span class="line">#修改数据库</span><br><span class="line">mysql&gt; alter database test character set utf8;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.05 sec)</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mydb3              |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">#选择test数据库</span><br><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">#删除数据库</span><br><span class="line">mysql&gt; drop database mydb3;</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="表的创建修改和删除">2.3 表的创建、修改和删除</h5>
<p>本节主要简单介绍对表的操作关键字和相应的数据库数据类型，让读者对表创建有一个总体的认识。能够简单创建表，提升性能的表创建方法后续才会介绍到。在创建表之前，必须选择对哪一个数据库操作 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure></p>
<h6 id="mysql的数据类型">2.3.1 MySQL的数据类型</h6>
<p>数据类型是定义该列可以存储的数据以及该数据实际怎样存储的法则</p>
<p><strong>1. 串数据类型</strong> <img src="/2022/07/30/MySQL/string.png" width="700"></p>
<p><strong>2. 数值数据类型</strong> <img src="/2022/07/30/MySQL/digit.png" width="700"></p>
<p><strong>3. 日期和时间数据类型</strong> <img src="/2022/07/30/MySQL/date.png" width="700"></p>
<p><strong>4. 二进制数据类型</strong>：可以存储任何数据，如图像、多媒体、字处理文档等 <img src="/2022/07/30/MySQL/binary.png" width="700"></p>
<ul>
<li><code>bit</code>：1位，可以指定位数，如：<code>bit(3)</code></li>
<li><code>int</code>：2字节可以指定最大位数，如<code>int&lt;4&gt;</code>,最大为4位的整数</li>
<li><code>float</code>：2个字节,可以指定最大的位数和最大的小数位数，如：<code>float&lt;5,2&gt;</code> 最大为一个5位的数，小数位最多2位</li>
<li><code>double</code>：4个字节,可以指定最大的位数和最大的小数位数，如：<code>float&lt;6,4&gt;</code>最大为一个6位的数，小数位最多4位</li>
<li><code>char</code>：必须指定字符数,如<code>char(5)</code>,为不可变字符　即使存储的内容为'ab',也是用5个字符的空间存储这个数据</li>
<li><code>varchar</code>：必须指定字符数,如varchar(5) 为可变字符　如果存储的内容为'ab',占用2个字符的空间；如果为'abc',则占用3个字符的空间</li>
<li><code>text</code>: 大文本(大字符串)</li>
<li><code>blob</code>：二进制大数据,如图片，音频文件，视频文件</li>
<li><code>date</code>: 日期　如：'1921-01-02'</li>
<li><code>datetime</code>: 日期+时间　如：'1921-01-02 12:23:43'</li>
<li><code>timeStamp</code>: 时间戳，自动赋值为当前日期时间</li>
</ul>
<h6 id="创建表">2.3.2 创建表</h6>
<p>创建表使用<code>create table</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#创建CUSTOMER表，以ID作为主键，同时指示除SALARY外其他都不能为NULL</span><br><span class="line">mysql&gt; CREATE TABLE IF NOT EXISTS CUSTOMER(</span><br><span class="line">    -&gt; NAME VARCHAR(20) NOT NULL, </span><br><span class="line">    -&gt; ID VARCHAR(30) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; SALARY DOUBLE NULL,</span><br><span class="line">    -&gt; HIREDATE DATE NOT NULL,</span><br><span class="line">    -&gt; PRIMARY KEY (ID)</span><br><span class="line">    -&gt; )ENGINE=InnoDB;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure> <strong>这里有几个关键字需要介绍</strong>：</p>
<ul>
<li><p><code>NULL</code>和<code>NOT NULL</code>:这两个关键字指示我们在插入记录对于该列来说，如果是<code>NOT NULL</code>,则插入记录时该列必须要有数据，否则会报错，而<code>NULL</code>修饰的列可以允许插入的记录在该列为空。</p></li>
<li><p><code>AUTO_INCREMENT</code>:在上述的表中<code>ID</code>是标识顾客的唯一编号，它们可以任意但是必须唯一，如果认为指定那么很难维护，<code>AUTO_INCREMENT</code>则是告诉MySQL本列每增加一行时自动增量，即每次执行一个<code>insert</code>,对该列增量。</p></li>
<li><p><code>PRIMARY KEY()</code>:指示使用哪一个或哪几个字段作为主键</p></li>
<li><p><code>ENGINE=InnoDB</code>:指示使用的引擎类型为<code>InnoDB</code> ，关于引擎类型后续会讲到</p></li>
</ul>
<h6 id="更新表">2.3.3 更新表</h6>
<p>有时候我们创建了表，但是对于表的字段列需要添加或者删除操作，这时候就用到了<strong>表更新</strong>这个概念，更新表使用<code>alter table CUSTOMER add/drop ID VARCHAR(40) NOT NULL</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#添加列</span><br><span class="line">mysql&gt; alter table CUSTOMER add marriage VARCHAR(5) NULL;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">#删除列</span><br><span class="line">mysql&gt; alter table CUSTOMER DROP MARRIAGE;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">#修改列</span><br><span class="line">alter table employee modify column height float;</span><br><span class="line">#修改表的字符集:</span><br><span class="line">alter table employee character set gbk;</span><br></pre></td></tr></table></figure></p>
<h6 id="删除表">2.3.4 删除表</h6>
<p>删除数据库中的表使用<code>drop table</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE CUSTOMER;</span><br></pre></td></tr></table></figure></p>
<h6 id="重命名表">2.3.5 重命名表</h6>
<p>如果相对表的名字重命名则可使用<code>rename</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; rename table CUSTOMER TO customer;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; show tables</span>;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| customer       |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="显示表结构">2.3.6 显示表结构</h6>
<p>如果想对表的结构字段名、类型等了解，可通过<code>describe</code>来显示表结构： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; describe customer;</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| NAME     | <span class="built_in">varchar</span>(<span class="number">20</span>) | NO   |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">| ID       | <span class="built_in">varchar</span>(<span class="number">30</span>) | NO   | PRI | <span class="literal">NULL</span>    |       |</span><br><span class="line">| SALARY   | <span class="type">double</span>      | YES  |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">| HIREDATE | date        | NO   |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.02</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="sql常用语句">3. SQL常用语句</h4>
<p>对于数据库来说，对数据库的操作离不开最重要的语句，而SQL语句就是对数据库操作的主流语言，可以说数据库和结构化查询语言<code>SQL</code>几乎是同义词，谈到<code>SQL</code>就当相于是在说数据库了。在数据库的操作中最常用的就是<strong>查询<code>select</code>,插入<code>insert into</code>，修改<code>update</code>和删除<code>delete</code>。</strong>也就是增删改差</p>
<h5 id="select语句">3.1 select语句</h5>
<p><code>select</code>是数据库中最常用的语句，它能从一个表或多个表中检索数据，使用<code>select</code>至少给出两个信息：一是要检索什么，从什么地方检索：<code>select what from where;</code>。<strong>你可以看作调用<code>select</code>会生成一个临时表作为结果集输出。</strong></p>
<p>如下是最简单的两句查询语句： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//产看该表所有数据</span><br><span class="line">select * from employee;</span><br><span class="line">//查看特定数据</span><br><span class="line">select name 姓名,birthday 出生日期 from employee where sal=15500;</span><br></pre></td></tr></table></figure> 上面的两条语句中：<strong>第一条既没有过滤也没有对查询结果排序</strong>，通常来说都不会使用如下低效的查询语句；<strong>第二句虽然增加了过滤条件<code>sal=15500</code>,也使用文字显示代替<code>name</code>和<code>birthday</code>作为输出界面，但是也没有对结果排序</strong></p>
<h6 id="distinct关键字">3.1.1 distinct关键字</h6>
<p>如果一个表中的一列不是主键有多个相同的值，但是我们又想查询结果只显示不同的值，这个使用就要使用到<code>distinct</code>关键字 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤表中重复数据。</span></span><br><span class="line">select DISTINCT english from student;</span><br><span class="line">select DISTINCT english,name from student;</span><br></pre></td></tr></table></figure></p>
<h6 id="limit关键字">3.1.2 limit关键字</h6>
<p>如果我们对检索的结果不要求其返回太多话，或者是限定其应该返回几行，这个时候就应该使用<code>limit</code>关键字:</p>
<ul>
<li><code>limit</code>后带一个数字的表示最多返回多少行</li>
<li><code>limit</code>后面带两个数字的表示从检索结果的的几行开始和返回的最多行数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer limit <span class="number">5</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">mysql&gt; select * from customer limit <span class="number">5</span>,<span class="number">5</span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br></pre></td></tr></table></figure>
<h6 id="order-by关键字">3.1.3 order by关键字</h6>
<p>一般来说，如果<code>select</code>语句没有对数据进行排序，则默认使用的数据在底层表中出现的顺序而显示，它可能是数据最初添加到表的顺序，但是一旦你进行过更新和删除，这个顺序就会受到MySQL重用回收存储空间的影响。因此应该采用关键字<code>order by</code>对检索结构进行排序。</p>
<ul>
<li>当<code>order by</code>后面只有一个字段名是，按该字段排序</li>
<li>当<code>order by</code>后面跟着多个字段名排序，首先是按照第一个字段排序，然后看排序后是否有相同的第一个字段值的记录，如果有，则对有相同第一个字段值的记录进行第二个字段排序。</li>
<li>默认情况下，使用的是升序排序，如果相要使用降序排序，则应该在后面添加<code>desc</code>,如<code>...order by name DESC;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name 姓名 from customer order by name;</span><br><span class="line">+---------+</span><br><span class="line">| 姓名    |</span><br><span class="line">+---------+</span><br><span class="line">| jack    |</span><br><span class="line">| lili    |</span><br><span class="line">| tom     |</span><br><span class="line">| trl     |</span><br><span class="line">| trluper |</span><br><span class="line">| 小明    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<h6 id="where关键字">3.1.4 where关键字</h6>
<p>在上面首次介绍<code>select</code>时，我们已经使用了<code>where</code>关键字，<code>where</code>关键字时对检索记录的一个筛选，只有符合<code>where</code>后面的条件才会输出这些记录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#普通条件显示</span><br><span class="line">mysql&gt; select * from customer where salary&gt;=<span class="number">15000</span> order by salary desc;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#非空显示</span></span><br><span class="line"><span class="function">mysql&gt; select * from customer where salary is <span class="keyword">not</span> null</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<p>在这里我们还需要介绍能够与<code>where</code>组合的更高级的过滤语句关键字<code>and、or</code>。上面使用<code>where</code>都是单一条件,如果要求要符合多个条件的使用怎么办？那当然是使用<code>and\or</code>来解决</p>
<ul>
<li><code>and</code>：同c++中的<code>&amp;&amp;</code>起一样的作用，优先级高于<code>or</code></li>
<li><code>or</code>：同c++中的<code>||</code>起一样的作用</li>
</ul>
<h6 id="in关键字">3.1.5 IN关键字</h6>
<p><code>IN</code>操作符用来指定条件的范围，范围中的每个条件都可以进行匹配，它的功能与<code>or</code>很相像，使用<code>IN</code>是因为：</p>
<ul>
<li>在使用长的合法选项清单是，<code>IN</code>操作符更加直观清楚，语句也不如<code>or</code>那样长冗余。</li>
<li>在使用<code>IN</code>时，计算的次序更容易管理</li>
<li><code>IN</code>操作一般比<code>or</code>操作符清单执行的更快</li>
<li><code>IN</code>操作符最多的优点是可以包含其他<code>select</code>语句，更加动态的建立<code>where</code>子句。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select * from customer where salary <span class="title">in</span><span class="params">(<span class="number">12000</span>,<span class="number">15000</span>,<span class="number">25000</span>)</span></span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<h6 id="not关键字">3.1.6 NOT关键字</h6>
<p><code>NOT</code>关键字有且只有一个功能，那就是否定它之后的紧跟的条件，NOT肯对<code>and、or</code>没什么用，但是对于<code>IN</code>来说却是绝配。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select * from customer where salary <span class="keyword">not</span> <span class="title">in</span><span class="params">(<span class="number">12000</span>,<span class="number">15000</span>,<span class="number">25000</span>)</span></span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| tom  | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="like和通配符">3.1.7 LIKE和通配符</h6>
<p><strong>通配符</strong>指的是用来匹配一部分的特殊字符；<strong>搜索模式</strong>则是指在搜索语句中使用字面值、通配符或两者组合成的搜索条件。<strong>使用通配符是必须在前面使用<code>LIKE</code>关键字，该关键字告诉MySQL后面跟着的搜索模式是使用通配符匹配而不是直接使用字面值匹配</strong></p>
<ul>
<li><code>%</code>通配符：该通配符是最常使用的，它可以表示任意字符出现任意次数，如<code>trl%</code>表示以<code>trl</code>开头的任意名称</li>
<li><code>_</code>通配符：同<code>%</code>是一样的作用，但是只匹配单个任意字符，即只匹配一次。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer where name like <span class="string">&#x27;trl%&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p>虽然通配符很有用，但是代价是很大的，它的搜索一般比前面的其他搜索所花时间更多，一般来说使用通配要遵循以下技巧：</p>
<ul>
<li>尽量不使用，如果有其他操作符能够达到相同效果，则应该使用这些操作符</li>
<li>假如一定要使用，则不要把通配符放在搜索模式的开始处，因为这样的搜索极慢</li>
</ul>
<h6 id="select支持算术运算">3.1.8 select支持算术运算</h6>
<p>对于MySQL中的数字类型，运行使用<code>* + - /</code>运算。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select salary,add_salary,salary+add_salary as finalSalary from custommer order by id;</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line">| salary | add_salary | finalSalary |</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line">|  <span class="number">12000</span> |        <span class="number">300</span> |       <span class="number">12300</span> |</span><br><span class="line">|  <span class="number">12500</span> |        <span class="number">300</span> |       <span class="number">12800</span> |</span><br><span class="line">|  <span class="number">15000</span> |        <span class="number">300</span> |       <span class="number">15300</span> |</span><br><span class="line">|  <span class="number">15000</span> |        <span class="number">300</span> |       <span class="number">15300</span> |</span><br><span class="line">|  <span class="number">25000</span> |        <span class="number">300</span> |       <span class="number">25300</span> |</span><br><span class="line">|  <span class="number">16000</span> |        <span class="number">300</span> |       <span class="number">16300</span> |</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="正则表达式进行搜索">3.2 正则表达式进行搜索</h5>
<p>前面介绍的过滤使用匹配、比较和通配符进行操作寻找符合的数据，对于一些基本情况来说足够了，但是随着过滤条件的增加，<code>where</code>子句本身的复杂性也在增加，这时候就应当使用正则表达式匹配。<strong>使用正则表达式必须在正则表达式（文本）前面使用<code>regexp</code>关键字，同·<code>like</code>一样告诉MySQL后面使用正则表达式进行匹配</strong>。</p>
<p>注意在正则表达式中，对于有特殊意义的符号，如果你不希望他被翻译成则表示里的特殊符号，应该加<code>\\</code>进行转义，如<code>. | []</code>这些通过<code>\\. \\| \\[\\]</code>经过转义后才能被认为是字符串的一部分。</p>
<h6 id="section">3.2.1 |</h6>
<p>在正则表达式中<code>|</code>上面的<code>or</code>是起到一样的作用 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer where name regexp <span class="string">&#x27;trl|tom&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<h6 id="section-1">3.2.2 []</h6>
<p><code>[]</code>的作用是匹配方括号内的字符之一，如<code>[123]</code>是指匹配1或2或3，同样为省略书写也可以写出<code>[1-3]</code>是同样的表示。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer where name regexp <span class="string">&#x27;[a-z]rl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<h6 id="section-2">3.2.3</h6>
<p><code>.</code>也是正则表达式中一个特殊字符，它表示匹配任意一个字符。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;.rl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------|</span><br></pre></td></tr></table></figure></p>
<h6 id="匹配字符类">3.2.4 匹配字符类</h6>
<p>MySQL中存在一些已经定义的字符集，这样就不用你自己手动去阻止这些字符集 <img src="/2022/07/30/MySQL/charSet.png" width="700"></p>
<h6 id="匹配多个字符">3.2.5 匹配多个字符</h6>
<p>至今为止，上面介绍的都是匹配单个字符的情况，是否有匹配多个字符的正则表达式特殊字符呢，当然是有的。 <img src="/2022/07/30/MySQL/muchChar.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;trl*&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意这里的重复元字符是指能够匹配当前元字符的前一个字符的多个重复值，如<code>trl*</code>,匹配<code>trl\trll\trll\trlll...\..</code>等</p>
<h6 id="定位符">3.2.6 定位符</h6>
<p>到目前为止，上面的匹配规则都是匹配一个串中任意一个为止的文本，为了能够指定匹配的为止，给出了定位符： <img src="/2022/07/30/MySQL/locate.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;^trl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select *from customer where name regexp &#x27;^trl$&#x27;</span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure> 一般来说，其他的正则表达式字符都应当与定位符结合使用</p>
<h5 id="insert语句">3.3 insert语句</h5>
<p>插入数据使用<code>insert into</code>，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入完整数据</span></span><br><span class="line"><span class="function">insert into employee <span class="title">values</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="number">15000</span>,<span class="string">&#x27;1998-05-09&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;2021-1-9&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//与select结合使用</span></span><br><span class="line"><span class="function">insert into  <span class="title">employee</span><span class="params">(id,name,salary,birthday,rank,hiredate)</span> select id,name,salary,birthday,rank,hiredate from employee_1 where name</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="update语句">3.4 update语句</h5>
<p>修改更新数据使用<code>update</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update customer set salary=salary+<span class="number">500</span>;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: <span class="number">6</span>  Changed: <span class="number">6</span>  Warnings: <span class="number">0</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="delete语句">3.5 delete语句</h5>
<p><code>delete</code>用来删除记录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除所有数据</span></span><br><span class="line"><span class="keyword">delete</span> from employee;</span><br><span class="line"><span class="comment">//删除指定数据</span></span><br><span class="line"><span class="keyword">delete</span> form employee where name=<span class="string">&#x27;jack&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用truncate删除表中记录。无条件 效率高</span></span><br><span class="line">truncate table employee;</span><br></pre></td></tr></table></figure></p>
<h4 id="函数">4. 函数</h4>
<p>有时候，我们对于搜索到的列的一些东西需要得到总和、平均和拼接，总之，我们不希望查找后的结果仍然是以底层表所存储的那样呈现上来,<strong>而是希望在<code>select</code>运行阶段经过处理后得到我们想要的结果，这时候就用到了想要的MySQL函数。</strong>大多数SQL支持以下函数：</p>
<ul>
<li>用于处理文本串的文本函数，如删除或填充、大小写转换等。</li>
<li>用于数值数据进行算术的操作，如绝对值、求和等</li>
<li>用于处理日期和时间值并从时间值提取特定成分</li>
<li>返回DBMS正使用的特殊信息的系统函数，如返回登录信息、检查版本细节等</li>
</ul>
<h5 id="拼接字段">4.1 拼接字段</h5>
<p>假如我们想在<code>select</code>中让输出的结果的一个字段即显示<code>name</code>又显示<code>salary</code>,而不是分开两个字段显示，这样就用到了<code>concat()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">concat</span><span class="params">(name,<span class="string">&#x27;:&#x27;</span>,salary,<span class="string">&#x27; &#x27;</span>,hiredate)</span> as &#x27;name:salary hiredate<span class="string">&#x27;&#x27; from customer order by id;</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">| name:salary hiredate     |</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">| jack:12000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| tom:12500 2022-08-03     |</span></span></span><br><span class="line"><span class="string"><span class="function">| lili:15000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| 小明:15000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| trluper:25000 2022-08-03 |</span></span></span><br><span class="line"><span class="string"><span class="function">| trl:16000 2022-08-03     |</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">6 rows in set (0.00 sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：</em></strong>在MySQL中拼接两个字段只能使用<code>concat()</code>函数，而在其他的数据库中则运行使用<code>+</code>直接拼接。</p>
<h5 id="文本处理函数">4.2 文本处理函数</h5>
<p><img src="/2022/07/30/MySQL/stringFunc.png" width="700"></p>
<h5 id="日期和时间处理函数">4.3 日期和时间处理函数</h5>
<p><img src="/2022/07/30/MySQL/dateFunc.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">now</span><span class="params">()</span>,<span class="title">year</span><span class="params">(now())</span> as 年,<span class="title">month</span><span class="params">(now() )</span>as 月,<span class="title">date</span><span class="params">(now())</span> as 日</span>; </span><br><span class="line">+---------------------+------+------+------------+</span><br><span class="line">| <span class="built_in">now</span>()               | 年   | 月   | 日         |</span><br><span class="line">+---------------------+------+------+------------+</span><br><span class="line">| <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">25</span> | <span class="number">2022</span> |    <span class="number">8</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------------------+------+------+------------+</span><br></pre></td></tr></table></figure></p>
<h5 id="数值处理函数">4.4 数值处理函数</h5>
<p><img src="/2022/07/30/MySQL/numberFunc.png" width="700"></p>
<h5 id="汇总函数">4.5 汇总函数</h5>
<p>有时候我们需要对表中的数据进行汇总，而不是把它们实际检索出来，这时候就需要这样的函数，因此MySQL专门设立了<strong>汇总函数</strong> <img src="/2022/07/30/MySQL/finalFunc.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#统计一个班级共有多少学生？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student</span>;</span><br><span class="line">#统计数学成绩大于<span class="number">90</span>的学生有多少个？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student where math&gt;90</span>;</span><br><span class="line">#统计总分大于<span class="number">250</span>的人数有多少？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student where math+chinese+english&gt;250</span>;</span><br><span class="line">#统计一个班级数学总成绩？</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span> from student</span>;</span><br><span class="line">#统计一个班级语文、英语、数学各科的总成绩</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span>, <span class="title">sum</span><span class="params">(chinese)</span>, <span class="title">sum</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#统计一个班级语文、英语、数学的成绩总和</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math+chinese+english)</span>from student</span>;</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span>+<span class="title">sum</span><span class="params">(chinese)</span>+<span class="title">sum</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#求一个班级数学平均分？</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math)</span> from student</span>;</span><br><span class="line">#求一个班级总分平均分</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math+chinese+english)</span>from student</span>;</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math)</span>+<span class="title">avg</span><span class="params">(chinese)</span>+<span class="title">avg</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#求班级最高分和最低分</span><br><span class="line"><span class="function">select <span class="title">max</span><span class="params">(math+chinese+english)</span>,<span class="title">min</span><span class="params">(math+chinese+english)</span> from student</span>;</span><br></pre></td></tr></table></figure>
<h4 id="其他查询操作">4. 其他查询操作</h4>
<p>在这里将会介绍分组查询、子查询和组合查询等查询手段，进一步掌握查询检索方法。</p>
<h5 id="分组查询">4.1 分组查询</h5>
<p>分组查询得关键字为<code>group by</code>，使用该关键字能够使得检索后得结果按照你想要得情况进行分组,<strong>下述得<code>group by</code>句子指示是按<code>salary</code>排序并分组</strong>,这样一来我们就不用一一调用<code>select salary count(*) where salary=各个数值;</code>语句，只需要以<code>group by</code>就能执行全部，同时还有附有<code>order by</code>进行排序，如下所示： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#这句sql语句相当于<span class="function">select salary <span class="title">count</span><span class="params">(*)</span> where salary</span>=各个数值 order by salary;</span><br><span class="line">mysql&gt; select salary,<span class="built_in">count</span>(*) from customer group by salary;</span><br><span class="line">+--------+----------+</span><br><span class="line">| salary | <span class="built_in">count</span>(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|  <span class="number">12500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">13000</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">15500</span> |        <span class="number">2</span> |</span><br><span class="line">|  <span class="number">25500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">16500</span> |        <span class="number">1</span> |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="number">5</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>group by</code>分组数据，还允许对分组进行过滤，但在这里使用得不是<code>where</code>，而应该使用<code>having</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select salary,<span class="built_in">count</span>(*) from customer group by salary having salary&gt;=<span class="number">13000</span>;</span><br><span class="line">+--------+----------+</span><br><span class="line">| salary | <span class="built_in">count</span>(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|  <span class="number">13000</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">15500</span> |        <span class="number">2</span> |</span><br><span class="line">|  <span class="number">25500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">16500</span> |        <span class="number">1</span> |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="子查询">4.2 子查询</h5>
<p>迄今为止，我们上面学的得<code>select</code>查询语句都是单语句得简单查询，即都是从单个数据表中检索数据得单条语句。还有一种嵌套在其他查询中查询，内部的查询语句称为<strong>子查询</strong>。有子查询的语句从内向外处理</p>
<p><strong>使用子查询是因为在实际的应用中我们总不可能用一张表来存储全部的数据，而是让每一个表存储特定的内容，这样一来，我们就极有可能会用到一个表中的数据作为另一个表的字段名称或者条件来进行查询</strong>，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为条件</span></span><br><span class="line"><span class="function">select cust_id from order_num <span class="title">in</span><span class="params">(select order_num from orderitems where prod_id=<span class="string">&#x27;TNT2&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为计算字段</span></span><br><span class="line">select cust_name,cust_state,</span><br><span class="line">(select <span class="built_in">count</span>(*) from orders where order.cust_id=customer.cust_id) as orders from customer order by cust_name;</span><br></pre></td></tr></table></figure></p>
<h5 id="组合查询">4.3 组合查询</h5>
<p><strong>组合查询是将多个<code>select</code>语句的组合成一个结果集返回，这些组合查询通常称为并<code>union</code>或复合查询</strong>。使用组合查询的情况有以下两点：</p>
<ul>
<li>在多个查询中从不同表返回类似结构的数据要形成一个结果集</li>
<li>对单个表执行多个查询，要按单个查询结果集返回</li>
</ul>
<p>这时就可使用<code>union</code>操作符来组合数条SQL查询语句，<strong>使用时只需要在各条<code>select</code>语句之间加上<code>union</code>关键字即可，返回的结果集中会自动的去重</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary from employee where name=<span class="string">&#x27;trluper&#x27;</span></span><br><span class="line">   -&gt; <span class="keyword">union</span> select name,salary froom employee where name=<span class="string">&#x27;trl&#x27;</span>;</span><br><span class="line">+---------+--------+</span><br><span class="line">| name    | salary |</span><br><span class="line">+---------+--------+</span><br><span class="line">| trluper |  <span class="number">25500</span> |</span><br><span class="line">| trl     |  <span class="number">16500</span> |</span><br><span class="line">+---------+--------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>使用<code>union</code>时的规则:</strong></p>
<ul>
<li><code>union</code>必须由两条或以上的<code>select</code>语句上才能使用</li>
<li><code>union</code>的每个查询必须包含相同的列、表达式或聚集函数（不要求相同次序列出），输出会以第一个<code>select</code>语句的列名称为准</li>
<li>列数据必须兼容：类型不必完全相同，但是DBMS可以隐式转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select salary from employee where name=<span class="string">&#x27;trluper&#x27;</span>  <span class="keyword">union</span> select job_name from employyee_job where id=<span class="number">5</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| salary    |</span><br><span class="line">+-----------+</span><br><span class="line">| <span class="number">25500</span>     |</span><br><span class="line">| c++开发   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select name,salary from employee where name</span>=<span class="string">&#x27;trluper&#x27;</span>  <span class="keyword">union</span> <span class="title class_">select</span> salary,name frmom employee where name=<span class="string">&#x27;trl&#x27;</span>;</span><br><span class="line">+---------+--------+</span><br><span class="line">| name    | salary |</span><br><span class="line">+---------+--------+</span><br><span class="line">| trluper | <span class="number">25500</span>  |</span><br><span class="line">| <span class="number">16500</span>   | trl    |</span><br><span class="line">+---------+--------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="连结表多表查询">5. 连结表（多表查询）</h4>
<p><strong>我们知道将数据分不同种类存储到不同的表能够更有效率，也更方便管理，单是我们不可能在检索的时候对单个表单个表的检索，我们希望能够将不同表但相同对象的数据放置在一起，这和时候就用到了连结表。</strong>SQL最强大的功能就是能在数据检索查询的执行中连结<code>join</code>表，连结表不存在于数据库的存储中，它是在<code>select</code>运行过程依据条件创建而成。一般来说使用连结表最好是定义<strong>主键和外键</strong>，通过主外键将两者两者连结在一起。</p>
<p>下面的例子中employee的<code>ID</code>为主键，<code>employee_job</code>的外键为<code>ID</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee,employee_job where employee.id=employee_jjob.id order by salary desc;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面使用<code>where</code>子句来建立连结，但是对于连结表这一知识点来说，最好是使用它的特定规则来实现连结比较好即使用<code>join</code>关键字。如下介绍当中的：笛卡儿积、内连结、外连结。</p>
<h5 id="笛卡儿积交叉连接">5.1 笛卡儿积（交叉连接）</h5>
<p>笛卡尔集是指两个集合<code>A</code>和<code>B</code>的乘积,如下 <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如，有 A 和 B 两个集合，它们的值如下：</span><br><span class="line">A = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">B = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">集合 A×B 和 B×A 的结果集分别表示为：</span><br><span class="line">A×B=&#123;<span class="comment">(1,3)</span>, <span class="comment">(1,4)</span>, <span class="comment">(1,5)</span>, <span class="comment">(2,3)</span>, <span class="comment">(2,4)</span>, <span class="comment">(2,5)</span> &#125;;</span><br><span class="line">B×A=&#123;<span class="comment">(3,1)</span>, <span class="comment">(3,2)</span>, <span class="comment">(4,1)</span>, <span class="comment">(4,2)</span>, <span class="comment">(5,1)</span>, <span class="comment">(5,2)</span> &#125;;</span><br></pre></td></tr></table></figure> 我们发现笛卡儿积不遵从弄个交换律即<code>A*B≠B*A</code>。多表查询遵循的算法就是以上提到的笛卡尔积，表与表之间的连接可以看成是在做乘法运算。<strong>在实际应用中，应避免使用笛卡尔积，因为笛卡尔积中容易存在大量的不合理数据，简单来说就是容易导致查询结果重复、混乱。</strong>笛卡儿积使用<code>cross join</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee cross join employee_job order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 老大         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 开发         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 技术服务     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 产品经理     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | c++开发      |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| lili    |  <span class="number">15500</span> | c++开发      |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 产品经理     |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 老大         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 销售         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | c++开发      |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 销售         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 老大         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 开发         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | c++开发      |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 开发         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 销售         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 技术服务     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 产品经理     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 开发         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 技术服务     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 产品经理     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 销售         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 产品经理     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 老大         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 销售         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">36</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="内连接">5.2 内连接</h5>
<p><strong>基于两个表直接的主键和外键相等的查询称为内部链接</strong>。只返回满足<code>on</code>后连接条件的数据（两边都有的才显示）。（对应oracle等值连接。） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee a inner join employee_job b on a.id=b.id order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br></pre></td></tr></table></figure></p>
<h5 id="外连接">5.3 外连接</h5>
<p>外连结有左外连结和右外连结，外连接与内连接的不同在于外连接对于另一个表会显示全部记录，不管符不符合后边<code>on</code>的条件，另一个表只显示符合条件的数据。</p>
<h6 id="左外连结">5.3.1 左外连结</h6>
<p><code>left join</code>是<code>left outer join</code>的简写，它的全称是左外连接，是外连接中的一种。外连接，左表<code>a</code>的记录将会全部表示出来，而右表<code>b</code>只会显示符合搜索条件的记录。右表记录不足的地方均为<code>NULL</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee a left join employee_job b on a.id=b.idorder by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| Adson   |  <span class="number">19000</span> | <span class="literal">NULL</span>         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">7</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="右外连接">5.3.2 右外连接</h6>
<p>效果同左外是相反的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ysql&gt; select name,salary,job_name from employee a right join employee_job b on a.id=b.id order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="视图">6. 视图</h4>
<p>视图是虚拟的比表，与包含数据的表不同，视图只包含使用时动态检索数据的查询<strong>。即视图是将一个查询语句包装成一个有名字的虚拟表，我们可以通过该虚拟表来使用这个查询语句</strong>。因此对于视图来说具有以下优点：</p>
<ul>
<li>重用SQL语句</li>
<li>简化了复杂的SQL操作，在编写查询后，我们可以很方便重用它，而不用知道它的细节</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据，可以给用户授予表的特定部分的权限而不是整个表的访问权限</li>
<li>更改数据格式和表示。视图可以返回与底层表不同的数据格式和表示。</li>
<li>节省空间，有了视图，不用在去创建一个同视图一样的表，在有需要的使用视图生成一个临时表即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create view employee_view as select name,salary,hiredate from employee,employee_job where employee.id=employee_job.id;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; show tables</span>;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| employee       |</span><br><span class="line">| employee_job   |</span><br><span class="line">| employee_view  |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">3</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select * from employee_view</span>;</span><br><span class="line">+---------+--------+------------+</span><br><span class="line">| name    | salary | hiredate   |</span><br><span class="line">+---------+--------+------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     |  <span class="number">13000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    |  <span class="number">15500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper |  <span class="number">25500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     |  <span class="number">16500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+--------+------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p><strong><em>注意</em></strong>：通常来说，视图是支持更新的，即可以对视图使用和表一样的<code>insert\update\delete</code>操作，因为视图只是一个包装<code>select</code>语句的虚拟表，因此更新一个视图会更新其相关的底层表，对视图的更新就是对底层表的更新。<strong>但是并不是所有的视图都支持更新，如果视图不能正确的确定被更新的基数据所在就不能更新。</strong></p>
<h4 id="存储过程">7. 存储过程</h4>
<p>视图能够很好的重复利用SQL语句，但是只能存储<code>select</code>语句，存储过程能够解决这个问题，<strong>存储过程（PROCEDURE）是事先经过编译并存储在数据库中的一段SQL语句的集合。调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是很有好处的。</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li>简化操作，存储过程通过把处理语句封装在容易使用的单元中。</li>
<li>简化对变动的管理，如果有表名、列名的变动时，只需要改动存储过程内的代码即可。</li>
<li>提高性能，使用存储过程比使用单独的SQL语句要快。</li>
<li>安全性大，因此使用的是存储过程内的SQL语句，数据库管理员是可以向访问数据库中存储过程的应用程序授予适当的权限，而不是向基础数据库表提供任何权限。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果使用大量的存储过程，那么使用这些存储过程的每个连接的内存使用量将大大增加</li>
<li>对于复杂的业务逻辑的存储过程的设计较为困难</li>
<li>开发和维护存储过程都不容易。</li>
<li>对数据库依赖程度较高，移值性差。</li>
</ul>
<h5 id="建立和调用存储过程">7.1 建立和调用存储过程</h5>
<p>存储过程就类似于c++中的函数，需要先定义，使用时需要调用。存储过程可以定义参数，参数分为<code>IN、OUT、INOUT</code>类型三种类型。调用存储过程使用<code>call</code></p>
<ul>
<li><code>IN</code>类型的参数表示接受调用者传入的数据；</li>
<li><code>OUT</code>类型的参数表示向调用者返回数据；</li>
<li><code>INOUT</code>类型的参数即可以接受调用者传入的参数，也可以向调用者返回数据。</li>
<li><code>declare</code>指示在存储过程中定义的变量，可使用<code>set</code>设置值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 创建存储过程</span><br><span class="line"><span class="function">CREATE PROCEDURE <span class="title">demo2</span><span class="params">(IN s_sex CHAR(<span class="number">1</span>),OUT s_count INT)</span></span></span><br><span class="line"><span class="function">	-- 存储过程体</span></span><br><span class="line"><span class="function">	BEGIN</span></span><br><span class="line"><span class="function">		-- 把SQL中查询的结果通过INTO赋给变量</span></span><br><span class="line"><span class="function">		SELECT <span class="title">COUNT</span><span class="params">(*)</span> INTO s_count FROM student WHERE sex</span>= s_sex;</span><br><span class="line">		declare id <span class="type">int</span>;</span><br><span class="line">		set id=<span class="number">15</span>;</span><br><span class="line">	END;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程</span><br><span class="line"><span class="function">call <span class="title">demo2</span><span class="params">(<span class="string">&#x27;男&#x27;</span>,nums)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的<code>SELECT COUNT(*) INTO s_count FROM student WHERE sex= s_sex;</code>语句将统计到的数目存储到<code>s_count</code>以返回给调用着，因为调用后他这是将结果返回给了<code>s_count</code>并没有输出结果集，可通过<code>select</code>输出 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s_count;</span><br></pre></td></tr></table></figure></p>
<h5 id="删除和检查存储过程">7.2 删除和检查存储过程</h5>
<p>可以通过<code>show create procedure</code>查看存储过程的详细信息，通过<code>drop procedure</code>删除存储过程 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show create procedure demo2;</span><br><span class="line">drop procedure demo2;</span><br></pre></td></tr></table></figure></p>
<h4 id="触发器">8. 触发器</h4>
<p>触发器的作用是让某一条语句在某事件发生时会自动执行。创建触发器时必须给出四条信息：</p>
<ul>
<li>唯一的触发器名称</li>
<li>触发器的关联表</li>
<li>触发器应该响应的活动，如<code>select、insert、update、delete</code>等</li>
<li>触发器何时执行<code>befor\after</code></li>
</ul>
<p>创建触发器使用<code>create trigger</code>,如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create trigger newproduct after insert on products <span class="keyword">for</span> each row select NEW.product_id;</span><br></pre></td></tr></table></figure> 上面这条触发器名称为<code>newproduct</code>,触发时机为在<code>products</code>表对每个插入行后会执行<code>select NEW.product.id</code>。这里<code>NEW</code>时关键字指定该插入行</p>
<h4 id="事务处理">9. 事务处理</h4>
<p>MySQL支持多种数据库引擎，最常见的是<code>MyISAM</code>和<code>InnoDB</code>。前者不支持事务处理，后者支持。<strong>事务处理可以用来维护数据的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行，事务处理是一种机制，利用事务处理可以保证成批的MySQL操作不会只执行一部分，如果全部执行那没问题，如果在执行过程中发生错误，它就会进行回退以恢复到数据库以前安全版本</strong>。</p>
<p>上面的这种事务处理机制保证了数据的完整性和安全性。事务处理需要知道的几个关键词如下：</p>
<ul>
<li>事务<code>transaction</code>：指一组SQL语句</li>
<li>回退<code>rollback</code>：指撤销指定SQL语句的过程</li>
<li>提交<code>commit</code>：指将未存储的SQL语句写入数据库表</li>
<li>保留的<code>savepoint</code>：指事务处理设置的临时占位符，你可以对它发布回退</li>
</ul>
<h5 id="事务的特性">9.1 事务的特性</h5>
<h6 id="事务的四大特性acid">9.1.1 事务的四大特性acid</h6>
<ul>
<li><strong>原子性</strong>：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的操作要么全部提交成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>：数据库总是从一个一致性状态转移达到另一个一致性状态，一致性状态就是由事务原子性保障，一个事务提交了，那是ok的，一个事务未提交，那也是OK的。</li>
<li><strong>隔离性</strong>：通常来说，一个事务所做的修改在未提交以前，对其他事务是不可见的。事务间是互不干扰的。</li>
<li><strong>持久性</strong>：一旦事务提交了，其所做的修改会永久保存到数据库总中，即使系统崩溃，修改的数据也不会丢失，（持久性不能做到100%保证策略，如果数据库本身就能做到吃性，那么要备份又有什么用呢）</li>
</ul>
<h6 id="事务的隔离级别">9.1.2 事务的隔离级别</h6>
<p><strong>事务的并发问题：</strong></p>
<ul>
<li>脏读 : 能读取到另一个未提交的数据（最可怕）</li>
<li>不可重复读: 对同一记录的两次读取不一致, 因为另一事务对该记录做了修改</li>
<li>幻读(虚读): 对同一记录的两次查询不一致, 因为另一事务插入了一条记录</li>
</ul>
<p><strong>四大隔离级别:</strong></p>
<ul>
<li><p><strong>未提交读(<code>read uncommitted</code>)</strong>：在该隔离级别，事务中的修改，即使没有提交，对其他事务也都是可见的。<strong>事务可以读取未提交的数据，这也被称为脏读</strong>。这个级别会导致喝多问题，从性能上来说，该级别没有比其他级别好很多，一般不推荐使用。</p></li>
<li><strong>提交读(<code>read committed</code>)：在该级别，一个事务开始时只能看见已经提交的事务的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，因此也可称为</strong>不可重复的**。这个隔离级别时大多数数据库默认的隔离级别。</li>
<li><strong>可重复读(<code>repeatable read</code>)</strong>：在该级别，保证了同一个事务多次读取同样的记录的结果是一致的。可重复读是MySQ的默认隔离级别，解决了脏读的问题，但是对于幻读无法解决。<strong>所谓的幻读就是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围插入新的记录，当之前的事务再次读取该范围记录时，产生幻行。</strong>InooDB引擎使用多版本控制MVCC解决幻读问题。</li>
<li><p><strong>可串行化(<code>serializable1</code>)</strong>：该隔离级别时最高的隔离级别，它通过强制事务串行执行，避免了前面说的幻读问题。简单来说，就是在读取每一行数据都加锁，所有会导致大量的超时和锁争问题。</p></li>
</ul>
<h5 id="rollback">9.2 rollback</h5>
<p>MySQL的<code>rollback</code>命令用来指示回退到事务开始之前的版本，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from employee_job;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#开启事务机制</span></span><br><span class="line"><span class="function">mysql&gt; start transaction</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; <span class="keyword">delete</span> from employee_job</span>;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; select * from employee_job</span>;</span><br><span class="line"><span class="function">Empty <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#回退</span></span><br><span class="line"><span class="function">mysql&gt; roolback</span>;</span><br><span class="line">mysql&gt; select * from employee_job;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br></pre></td></tr></table></figure></p>
<h5 id="commit">9.3 commit</h5>
<p>在Mysql中，如果不是在事务处理快，则提交的更改是默认自动立刻写入表中的。但是在事务处理块中，提交不会隐含执行，必须你显示的调用<code>commit</code>它才会提交到表中。但是如果在<code>start transaction</code>~<code>commit</code>当中的SQL语句出现错误时，则全部不会提交，回退事务开始前的版本 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from employee_job;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#开始事务</span></span><br><span class="line"><span class="function">mysql&gt; start transaction</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; insert into employee_job <span class="title">values</span><span class="params">(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;老板&#x27;</span>)</span></span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#提交</span></span><br><span class="line"><span class="function">mysql&gt; commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select* from employee_job</span>;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br><span class="line">| <span class="number">2</span>  | 老板         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">7</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></p>
<h5 id="使用保留点">9.4 使用保留点</h5>
<p>为了避免一次性对事务处理块进行全部的回退或者提交，使用<code>savepoint</code>来设置保留的，已达到能支持部分回退或者提交的功能。如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">...</span><br><span class="line">savepoint point1;</span><br><span class="line">...</span><br><span class="line">savepoint point2;</span><br><span class="line">...</span><br><span class="line">rollback to point1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure> 上面的程序会回退到<code>point1</code>，因此提交的MySQL批次只有<code>point1</code>前的，后面的无法提交。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">算法题解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 21:30:13" itemprop="dateCreated datePublished" datetime="2022-07-30T21:30:13+08:00">2022-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-10 14:36:56" itemprop="dateModified" datetime="2023-02-10T14:36:56+08:00">2023-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="动态规划类">1. 动态规划类</h4>
<h5 id="打家劫舍">1.1 打家劫舍</h5>
<p><strong>问题：</strong>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]：表示第i家房屋结尾的最多能偷窃到的最高数额</span></span><br><span class="line">        <span class="comment">//初始条件：dp[0]=nums[0]、dp[1]=nums[1]</span></span><br><span class="line">        <span class="comment">//因为对邻接房屋偷窃，则dp[i]=max(dp[x])+nums[i]，0≤x&lt;i-1</span></span><br><span class="line">        <span class="comment">//这样的算法复杂度为O(N*N)，可以通过两个变量，使得算法降为O(N)</span></span><br><span class="line">        <span class="comment">//变量maxOdd表示奇次序的最大值，maxEven表示偶次序的最大值</span></span><br><span class="line">		<span class="comment">//奇偶次序的作用是：</span></span><br><span class="line">		<span class="comment">//当我们的下标为偶数时，只能与之前奇次序最大值相加，之后更新偶次序数（这是因为此时奇偶关系对</span></span><br><span class="line">		<span class="comment">//于下一个数已失效）；同理下标为奇数也是一样</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="comment">//初始条件</span></span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//maxOdd初始为dp[1]，maxEven初始为dp[0]</span></span><br><span class="line">        <span class="type">int</span> maxOdd=dp[<span class="number">1</span>],maxEven=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==i%<span class="number">2</span>)      <span class="comment">//为偶下标</span></span><br><span class="line">            &#123;</span><br><span class="line">               dp[i]=nums[i]+maxEven;</span><br><span class="line">                <span class="comment">//更新奇偶的最大值</span></span><br><span class="line">                <span class="keyword">if</span>(maxOdd&lt;maxEven)</span><br><span class="line">                    maxOdd=maxEven;</span><br><span class="line">                maxEven=<span class="built_in">Max</span>(maxEven,maxOdd,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>            <span class="comment">//奇下标</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=nums[i]+maxOdd;</span><br><span class="line">                <span class="keyword">if</span>(maxOdd&gt;maxEven)</span><br><span class="line">                    maxEven=maxOdd;</span><br><span class="line">                maxOdd=<span class="built_in">Max</span>(maxEven,maxOdd,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMaxValue</span>(dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="最长回文子串">1.2 最长回文子串</h5>
<p><strong>问题：</strong>给你一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]:表示s[i]是否等于s[j],相等且回文则置为true，否则为false</span></span><br><span class="line">    <span class="comment">//初始条件：dp[i][i]=true;</span></span><br><span class="line">    <span class="comment">//状态转移方程：</span></span><br><span class="line">	<span class="comment">//①若i和j是相邻的即i+1=j且s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//②若不相邻，则判断内侧是否为true，若dp[i+1][j-1]=true&amp;&amp;s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//通过增加两变量记录当前回文串的最长长度Maxlen,初始为1,以及记录回文串的下标开始index_min，初始为最后一个元素</span></span><br><span class="line">    <span class="comment">//算法的时间复杂度为O(n*n)</span></span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>||len==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(len,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> Maxlen=<span class="number">1</span>,index_min=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])<span class="comment">//如果两元素相等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i+<span class="number">1</span>)<span class="comment">//如果相邻</span></span><br><span class="line">                    dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//不相邻，判断两元素内部是否为回文串</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;Maxlen&lt;j-i+<span class="number">1</span>)<span class="comment">//更新Maxlen和index_min</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Maxlen=j-i+<span class="number">1</span>;</span><br><span class="line">                    index_min=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ret=s.<span class="built_in">substr</span>(index_min,Maxlen);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="最长回文子序列">1.3 最长回文子序列</h5>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*动态规划：dp[i][j]，其中0=&lt;i&lt;=j&lt;=n,dp[i][j]表示序列s在i~j范围内的最长回文子序列长度。</span></span><br><span class="line"><span class="comment">                    对于回文序列的问题，我们必须注意循环的顺序，首先i从大到小，j从小到大且满足j&gt;=i，直                  到得到dp[0][n-1]</span></span><br><span class="line"><span class="comment">            初始条件：①当i=j时，dp[i][j]=1</span></span><br><span class="line"><span class="comment">                     ②当i&gt;j时，dp[i][j]=0</span></span><br><span class="line"><span class="comment">            状态转移方程：①当s[i]=s[j且相邻即i+1=j,dp[i][j]=dp[i][j-1]+1</span></span><br><span class="line"><span class="comment">                         ②当s[i]=s[j]且不相邻,dp[i][j]=dp[i+1][j-1]+2</span></span><br><span class="line"><span class="comment">                         ③当s[i]!=s[j]且相邻，dp[i][j]=1</span></span><br><span class="line"><span class="comment">                         ④当s[i]!=s[j]，此时s[i]和s[j]不能同时作为回文子序列的首尾，则有</span></span><br><span class="line"><span class="comment">                         dp[i][j]=max(dp[i][j-1],dp[i+1][j])</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxLen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>==j)</span><br><span class="line">                        dp[i][j]=dp[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>==j)</span><br><span class="line">                        dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;maxLen)</span><br><span class="line">                    maxLen=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="树类">2. 树类</h4>
<h4 id="链表类">3. 链表类</h4>
<h5 id="两数相加">3.1 两数相加</h5>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head=l1;</span><br><span class="line">        <span class="type">int</span> jingwei=<span class="number">0</span>;</span><br><span class="line">        ListNode* prio;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val=l1-&gt;val+l2-&gt;val+jingwei;</span><br><span class="line">            prio=l1;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1&amp;&amp;!l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val+=jingwei;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1&amp;&amp;l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prio=l1;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                    l1-&gt;val+=jingwei;</span><br><span class="line">                    jingwei=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            prio-&gt;next=l2;</span><br><span class="line">            l1=l2;</span><br><span class="line">            l1-&gt;val+=jingwei;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1&amp;&amp;l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prio=l1;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                    l1-&gt;val+=jingwei;</span><br><span class="line">                    jingwei=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jingwei)</span><br><span class="line">            &#123;</span><br><span class="line">                prio-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(jingwei,<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="删除链表倒数第n个节点">3.2 删除链表倒数第N个节点</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        ListNode* tmp=head;</span><br><span class="line">        <span class="keyword">while</span>(tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=head;</span><br><span class="line">		<span class="comment">//删除头节点单独考虑</span></span><br><span class="line">        <span class="keyword">if</span>(len-n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> tmp-&gt;next;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len-n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next=tmp-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="合并k个有序链表">3.3 合并K个有序链表</h5>
<p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用分治的思想，分别两两合并</span></span><br><span class="line">        <span class="comment">//使用递归实现：</span></span><br><span class="line">        <span class="comment">//递归退出条件为：一是传入的只有一个链表另一个为NUL，二是传入的均为NULL，直接返回</span></span><br><span class="line">        <span class="comment">//程序结构：mergeKList为主调用，不做其他功能，merge递归入口，当达到底层是使用mergeTwoList   </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>()<span class="number">-1</span>);     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoList</span><span class="params">(ListNode* a,ListNode* b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==a||<span class="literal">NULL</span>==b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>==a?b:a;</span><br><span class="line">        ListNode* head=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;val&gt;b-&gt;val)&#123;</span><br><span class="line">            head=b;</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head=a;</span><br><span class="line">            a=a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tempNode=head;</span><br><span class="line">        <span class="keyword">while</span>(a&amp;&amp;b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;val&gt;b-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                tempNode-&gt;next=b;</span><br><span class="line">                b=b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tempNode-&gt;next=a;</span><br><span class="line">                a=a-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tempNode=tempNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a)</span><br><span class="line">            tempNode-&gt;next=a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempNode-&gt;next=b;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=(r+l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(r==l)</span><br><span class="line">            <span class="keyword">return</span> lists[r];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r&lt;l)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">mergeTwoList</span>(<span class="built_in">merge</span>(lists,l,m),<span class="built_in">merge</span>(lists,m+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="两两交换链表中的节点">3.4 两两交换链表中的节点</h5>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用双指针，前一指针比后一指针快一步，然后交换指向即可</span></span><br><span class="line">        <span class="comment">//为方便，在链表头部添加一节点pHead</span></span><br><span class="line">        ListNode* front=<span class="literal">NULL</span>,*back=<span class="literal">NULL</span>,*pHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        pHead-&gt;next=head;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        back=head;</span><br><span class="line">        front=head-&gt;next;</span><br><span class="line">        ListNode* ret=pHead;</span><br><span class="line">        <span class="keyword">while</span>(front!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            back-&gt;next=front-&gt;next;</span><br><span class="line">            front-&gt;next=back;</span><br><span class="line">            pHead-&gt;next=front;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            pHead=back;</span><br><span class="line">            <span class="keyword">if</span>(back-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                back=back-&gt;next;</span><br><span class="line">                front=back-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                front=<span class="literal">NULL</span>;</span><br><span class="line">                back=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ##### 3.5 K个一组翻转链表 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针：前一个指针front比后一个指针快K-1</span></span><br><span class="line">        <span class="comment">//为方便，增加辅助头指针pHead</span></span><br><span class="line">        ListNode* front=<span class="literal">NULL</span>,*back=<span class="literal">NULL</span>,*pHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(),*ret=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        pHead-&gt;next=head;</span><br><span class="line">        front=back=head;</span><br><span class="line">        ret=pHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k&amp;&amp;front!=<span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">            front=front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(front!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;   <span class="comment">//记录下一组节点</span></span><br><span class="line">            ListNode* tmp_back=front-&gt;next;</span><br><span class="line">            ListNode* tmp_front=tmp_back;</span><br><span class="line">            <span class="comment">//pHead记录</span></span><br><span class="line">            pHead-&gt;next=front;</span><br><span class="line">            pHead=back;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">                <span class="comment">//记录下一个翻转节点</span></span><br><span class="line">                ListNode* tmp=back-&gt;next;</span><br><span class="line">                <span class="comment">//翻转</span></span><br><span class="line">                back-&gt;next=front-&gt;next;</span><br><span class="line">                front-&gt;next=back;</span><br><span class="line">                <span class="comment">//更新</span></span><br><span class="line">                back=tmp;</span><br><span class="line">                <span class="comment">//下一组更新</span></span><br><span class="line">                <span class="keyword">if</span>(tmp_front)</span><br><span class="line">                    tmp_front=tmp_front-&gt;next;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            back=tmp_back;</span><br><span class="line">            front=tmp_front;         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="字符串类">4. 字符串类</h4>
<h5 id="n字形变换">4.1 N字形变换</h5>
<p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。如输入字符串为 <code>PAYPALISHIRING</code> 行数为 4 时，排列如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;PAYPALISHIRING&quot;</span>, numRows = <span class="number">4</span></span><br><span class="line">输出：<span class="string">&quot;PINALSIGYAHRPI&quot;</span></span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于numRows有这样的一个规律：</span></span><br><span class="line"><span class="comment">//按规定第一列取s的前numRows个字符，即i=0.....numRows</span></span><br><span class="line"><span class="comment">//对于i行后面的列每隔(numRows-1)*2+i取一个，直到(numrow-1)*2*j&gt;s.size()为止,j&gt;=1</span></span><br><span class="line"><span class="comment">//同时对于第i行，在取s[(numRow-1)*2*j+i]时，</span></span><br><span class="line"><span class="comment">//前面应该还有当(numRows-1)*2*j+i-2i!=(numRows-1)*2*(j-1)+i时添加一个字符为s[(numsRow-1)*2*j+i-2i]</span></span><br><span class="line"><span class="comment">//或者只需排除第一行和最后一行即可</span></span><br><span class="line"><span class="comment">//时间复杂度为O(N)，空间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="built_in">convert</span>(string s, <span class="type">int</span> numRows) &#123;</span><br><span class="line">        string ret=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numRows&amp;&amp;i&lt;s.<span class="built_in">size</span>();i++)  <span class="comment">//第i行存储</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret+=s[i];</span><br><span class="line">            <span class="type">int</span> gapDistance=(numRows<span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;gapDistance*j-i&lt;s.<span class="built_in">size</span>();j++)<span class="comment">//寻找下一个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows<span class="number">-1</span>)             <span class="comment">//判断是不是第一行或者最后一行,不是则进入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret+=s[gapDistance*j-i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(gapDistance*j+i&lt;s.<span class="built_in">size</span>())</span><br><span class="line">                    ret+=s[gapDistance*j+i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> #### 5. 双指针类 ##### 5.1 无重复字符的最长子串 <strong>问题：</strong>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<blockquote>
<p>示例： 输入: s = &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用滑动窗口的思路，即双指针的应用，左指针first表示以该元素为起始点</span></span><br><span class="line">   <span class="comment">//右指针last表示[first,last)是以s[first]开头最长无重复子串，以first为起始</span></span><br><span class="line">   <span class="comment">//不断向右移动右指针，直到遇到重复的为止</span></span><br><span class="line">   <span class="comment">//用unordered_set记录来判断是否有重复元素</span></span><br><span class="line">   <span class="comment">//虽然是双循环，但是内部右指针不重置，移动次数为常数，因此时间复杂度为O(N)</span></span><br><span class="line">   <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">0</span>==len||<span class="number">1</span>==len)</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    <span class="type">int</span> last=<span class="number">0</span>,maxLen=<span class="number">1</span>;</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; hSet;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;len;first++)  <span class="comment">//左指针向前</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不是第一次进入循环，说明当前元素s[last]与hSet存在重复，不断去除前一个</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>!=first)</span><br><span class="line">            hSet.<span class="built_in">erase</span>(s[first<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//不断右移右指针，直到遇到重复的</span></span><br><span class="line">        <span class="keyword">while</span>(last&lt;len&amp;&amp;!hSet.<span class="built_in">count</span>(s[last]))</span><br><span class="line">        &#123;</span><br><span class="line">            hSet.<span class="built_in">insert</span>(s[last]);</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen=<span class="built_in">max</span>(maxLen,last-first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="盛最多水的容器">5.2 盛最多水的容器</h5>
<p><strong>问题</strong>：给定一个长度为<code>n</code>的整数数组<code>height</code>。有<code>n</code>条垂线，第<code>i</code>条线的两个端点是<code>(i, 0)</code>和<code>(i, height[i])</code>。找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//双指针，一头指向头，一个指向尾</span></span><br><span class="line">    <span class="comment">//原理不用多说，看代码即可知</span></span><br><span class="line">    <span class="comment">//复杂度O(N)</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> maxCap=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="built_in">Min</span>(height[left],height[right])*(right-left);</span><br><span class="line">        <span class="keyword">if</span>(maxCap&lt;tmp)</span><br><span class="line">            maxCap=tmp;</span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="三数之和">5.3 三数之和</h5>
<p><strong>算法思路：</strong></p>
<ul>
<li>1、特判，对于数组长度<code>n</code>，如果数组为<code>null</code>或者数组长度小于<code>3</code>，返回<code>[]</code></li>
<li>2、对数组进行排序。</li>
<li>3、遍历排序后数组：
<ul>
<li>若<code>nums[i]&gt;0</code>：因为已经排序好，所以后面不可能有三个数加和等于0，直接返回结果。</li>
<li>对于重复元素：跳过，避免出现重复解</li>
<li>令左指针<code>L=i+1</code>，右指针<code>R=n-1</code>，当 <code>L&lt;R</code>时，执行循环：
<ul>
<li>当<code>nums[i]+nums[L]+nums[R]==0</code>，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解</li>
<li>若和大于0，说明<code>nums[R]</code>太大，<code>R</code>左移</li>
<li>若和小于0，说明<code>nums[L]</code>太小，<code>L</code>右移</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line"><span class="comment">/*方法一：转化为两数之和</span></span><br><span class="line"><span class="comment">*先将nums的元素拷贝一份到unordered_set处</span></span><br><span class="line"><span class="comment">*再将将nums内的数据两两求和存储回到tmp</span></span><br><span class="line"><span class="comment">*通过在set寻找是否有符合tmp的数据求得其解</span></span><br><span class="line"><span class="comment">*时间复杂度为O(N*N),空间复杂度为O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*方法二：双指针和排序</span></span><br><span class="line"><span class="comment">*先对数组nums进行升序排序，</span></span><br><span class="line"><span class="comment">*后依次从负值取一个元素作为第一个选取的值</span></span><br><span class="line"><span class="comment">*之后定义左右指针，从左指向右前进一位选取一个元素，这里选取了两个元素执行求和得target</span></span><br><span class="line"><span class="comment">*右指针向左移动若干个位置，寻找元素与target和为0得元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line"><span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; nums[i] &lt;= <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    left = i + <span class="number">1</span>;</span><br><span class="line">    right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[left]);</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="comment">//判断下一个值是否重复，是则跳过</span></span><br><span class="line">            <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                left++;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;len<span class="number">-1</span>&amp;&amp;nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">        i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最接近的三数之和">5.4 最接近的三数之和</h5>
<p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *使用三数之和的方法：</span></span><br><span class="line"><span class="comment">    *1、先对数组进行排序</span></span><br><span class="line"><span class="comment">    *2、之后想三数之和一样遍历排序后的数组：</span></span><br><span class="line"><span class="comment">    *时间复杂度为O(N*N)，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> ret=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> right=len<span class="number">-1</span>,left=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较ret是否要更新</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(target-(nums[i]+nums[left]+nums[right]))</span><br><span class="line">                    &lt;<span class="built_in">abs</span>(target-ret))</span><br><span class="line">                    ret=nums[i]+nums[left]+nums[right];</span><br><span class="line">            <span class="comment">//双指针应该向哪边移动</span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[i]+nums[left]+nums[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[i]+nums[left]+nums[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="四数之和">5.5 四数之和</h5>
<p>给你一个由 n 个整数组成的数组<code>nums</code>，和一个目标值<code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组<code>[nums[a], nums[b], nums[c], nums[d]]</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//解决方法同三数求和一样，使用排序+双指针方法</span></span><br><span class="line">        <span class="comment">//只不过此时多加了一层循环，则时间复杂度为O(N^3),</span></span><br><span class="line">        <span class="type">long</span> Target=target;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>;i++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>&amp;&amp;Target&lt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=i+<span class="number">3</span>;j--)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="type">int</span> left=i+<span class="number">1</span>,right=j<span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="type">long</span> result=(<span class="type">long</span>)nums[i]+(<span class="type">long</span>)nums[j]+</span><br><span class="line">					 			(<span class="type">long</span>)nums[left]+(<span class="type">long</span>)nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(Target&lt;result)</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(Target&gt;result)</span><br><span class="line">                        left++;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        ret.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(right&gt;left&amp;&amp;nums[right]==nums[right<span class="number">-1</span>])</span><br><span class="line">                            right--;</span><br><span class="line">                        <span class="keyword">while</span>(right&gt;left&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])</span><br><span class="line">                            left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//跳过重复</span></span><br><span class="line">                 <span class="keyword">while</span>(j&gt;=i+<span class="number">3</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])</span><br><span class="line">                    j--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//跳过重复</span></span><br><span class="line">             <span class="keyword">while</span>(i&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>&amp;&amp;nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="深度优先搜索类">6. 深度优先搜索类</h4>
<h4 id="广度优先搜索类">7. 广度优先搜索类</h4>
<h4 id="数学">8. 数学</h4>
<h4 id="矩阵">9. 矩阵</h4>
<h4 id="图类">10. 图类</h4>
<h4 id="模拟">11. 模拟</h4>
<h5 id="字符串转整数">11.1 字符串转整数</h5>
<p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：</p>
<ul>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</li>
<li>返回整数作为最终结果。</li>
</ul>
<p><strong><em>注意：</em></strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 ' ' 。</li>
<li>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//易错点：</span></span><br><span class="line"><span class="comment">//        1、题目要求对于前面没遇到数字前，若为非空格非&#x27;-+&#x27;，则为非法输入，直接退出</span></span><br><span class="line"> <span class="comment">//       2、&#x27;-&#x27;或&#x27;+&#x27;号后只能是数字，不能为其他，否则直接退出循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> isFu=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> isfirst=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> Nodigital=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">long</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(isfirst&amp;&amp;Nodigital&amp;&amp;s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(isfirst&amp;&amp;Nodigital&amp;&amp;(<span class="string">&#x27;-&#x27;</span>==s[i]||<span class="string">&#x27;+&#x27;</span>==s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&#x27;-&#x27;</span>==s[i])</span><br><span class="line">                    isFu=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    isFu=<span class="literal">false</span>;</span><br><span class="line">                isfirst=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(isFu)</span><br><span class="line">                    <span class="keyword">if</span>(INT_MIN&gt;result*<span class="number">10</span>-tmp)&#123;</span><br><span class="line">                        result=INT_MIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        result=result*<span class="number">10</span>-tmp;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(INT_MAX&lt;result*<span class="number">10</span>+tmp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        result=INT_MAX;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        result=result*<span class="number">10</span>+tmp;</span><br><span class="line">                Nodigital=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/all/">leetcode</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" class="post-title-link" itemprop="url">动态规划算法思想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-29 13:56:14" itemprop="dateCreated datePublished" datetime="2022-07-29T13:56:14+08:00">2022-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-15 13:49:29" itemprop="dateModified" datetime="2022-12-15T13:49:29+08:00">2022-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="动态规划">1. 动态规划</h4>
<p>我们遇到的问题中，有很大一部分可以用动态规划<code>Dynamic Programming</code>来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解题</p>
<h5 id="动态规划的原理">1.1 动态规划的原理</h5>
<p><strong>动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度</strong>， 因此它比回溯法、暴力法等要快许多。动态规划要求我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。由于单纯使用语言来描述动态规划晦涩难懂，因此采用例子来说明：</p>
<p><strong>问题1：假设有1元、3元和5元的硬币，如何用最少的的硬币凑够11元？</strong></p>
<p>学过贪心算法知道，加如使用贪心算法，每次拿面额最高的银币来逼近这个11是一个方法，但它不能保证一定是最少数量的。因此这里介绍动态规划来解答。正如上面所说，动态规划就是将问题小化，以上一次的子问题的最优解推出下一个的最优解：</p>
<ul>
<li>因此我们可想当面额为<code>i</code>时，最少的硬币数量是多少，我们使用<code>dp[i]</code>表示凑够<code>i</code>元时最少的硬币数量。</li>
<li>豪无疑问，当<code>i=0</code>时<code>dp[0]=0</code>，因为题目给出了1元、3元和5元的面额，我们需要对这些进行处理，因此能够得到其他的初始条件，<code>i=1</code>时<code>dp[i]=1</code>,i=3时<code>dp[3]=1</code>,i=5时<code>dp[5]=</code>。</li>
<li>完成了初始化条件后，我们可以继续推其他面额的情况，由提供的三种面额，可以知道当<code>i=2</code>时<code>dp[2]=2</code>，但<code>i=3</code>时，组成它的有两种选择，一种时三个1元硬币，另一种是直接选择3元，有<code>min(dp[3].dp[2]+1)</code>知道<code>dp[3]=1</code>是最优解，同样<code>dp[4]</code>，它可以有<code>4=1+3</code>或者<code>4=3+1</code>，两者的的数量是一致的，只不过是次序的不同，再到<code>dp[5]</code>可以检查<code>min(dp[4]+1,dp[2]+1,dp[5])</code>取最小</li>
<li>由上面的分析，我们可以很容易的分析到这样一个状态转移方程： <span class="math display">\[
dp[i]=
\begin{cases}
min(dp[i-1]+1,dp[i-3]+1,dp[i-5]+1),i&gt;5\\
1,i=1,3,5\\
2,i=2,4
\end{cases}
\]</span></li>
</ul>
<p>这样问题就迎刃而解，得如下代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 有面值1，3，5的硬币，试求组成39元时用到最少的硬币数量</span></span><br><span class="line"><span class="comment">* 首先定义dp[i]表示i元时用到得最少银币数</span></span><br><span class="line"><span class="comment">* 由题得初始化条件dp[0]=0,dp[1]=1,dp[3]=1,dp[5]=5</span></span><br><span class="line"><span class="comment">* 当i&gt;5时，会有状态转移方程dp[i]=min(dp[i-1].dp[i-3],do[i-5])+1;</span></span><br><span class="line"><span class="comment">*当i&lt;=5时，这个范围含的2，4未初始化，</span></span><br><span class="line"><span class="comment">*可以增加以判断条件当i-1&gt;=0,i-3&gt;=0,i-5&gt;0来决定，是否要在状态转移方程添加对应项</span></span><br><span class="line"><span class="comment">* 这里由于能够自己推段2，4的最小数量，直接当作初始化，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCoin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">40</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">5</span>] = <span class="number">1</span>;	</span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	dp[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] = <span class="built_in">Min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">3</span>], dp[i - <span class="number">5</span>]) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">39</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的案例可以知道，解决动态规划的策略最重要的三步是：</p>
<ul>
<li><strong>确定<code>dp</code>数组的含义</strong></li>
<li>确定可从题意得出的临界值</li>
<li><strong>确定状态转移方程</strong></li>
</ul>
<p>有了状态和状态转移方程，问题基本上也就解决了，接下来的问题只是如何写迭代代码而已。</p>
<h5 id="初级问题">1.2 初级问题</h5>
<p>上面的硬币问题只能说是很简单的动态规划问题，我们可以在来看看更复杂一点的。</p>
<p><strong>问题：</strong>一个序列有N个数：A[1],A[2],…,A[N]，求出最长连续非降子序列的长度</p>
<p>同样对于这个问题也能使用动态规划来解决，定义一个<code>dp[i]</code>表示包括当前下标<code>i</code>的非降子序列的长度，那么就有这样的条件：</p>
<ul>
<li>初始条件中，我们肯定可以知道<code>i=0</code>时<code>d[i]=1</code>。</li>
<li>状态转移方程则有<code>d=1+(s[i]&gt;=s[i-1]?d[i-1]:0)</code>，这个状态转移方程指示，我们只需将当前的访问的元素与上一个元素进行对比，如果是<code>&gt;=</code>，则与之前一样是一个非降子序列，反之则不是，重新计数非降子序列长度</li>
<li>最后只需要遍历一次<code>d[i]</code>就能得到最长非降子序列的长度，起始和结束位置也能递推</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">maxLength</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len)</span></span>;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] =<span class="number">1</span>+( s[i] &gt;= s[i - <span class="number">1</span>] ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getmaxValue</span>(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的问题可以进一步升级，不要求连续，如下：</p>
<p><strong>问题：</strong>一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度</p>
<p>虽然这个问题不要求连续，我们同样能够使用一维<code>dp[i]</code>尝试解决，同样要找出初始条件和状态转移方程。<strong>我们可以让<code>dp[i]</code>是表示在以<code>A[i]</code>结尾的即下标<code>0~i</code>的子序列的最长非降长度</strong>，那么就有如下策略：</p>
<ul>
<li>初始条件<code>dp[0]=1</code></li>
<li>状态转移方程有两种情况，一是必须在前面找到所有的个x,使得<code>A[i]&gt;=A[x]</code>，更新<code>dp[x]=dp[x]+1</code>,然后执行取最大值,如果没有找到则直接赋值为<code>dp[i]=1</code>。即</li>
</ul>
<p><span class="math display">\[
dp[i]=
\begin{cases}
max(dp[x]+1)     当之前序列存在A[i]&gt;=A[x]时，\\
1，           之前的序列不存在A[x]&lt;=A[i]时
\end{cases}
\]</span></p>
<ul>
<li>最后遍历一遍<code>dp</code>数组，取最大值，</li>
<li>该算法因为当<code>A[i]&lt;A[i-1]</code>时，需要从后往前遍历dp数组。外部循环为<code>n</code>，内部平均循环为<code>n/2</code>，因此时间复杂度为<code>O(N*N)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSonLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(len);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(i)</span></span>;</span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cap[i] &gt; cap[j]) &#123;</span><br><span class="line">                    tmp[index]=dp[j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> max=<span class="built_in">getmaxValue</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (max==<span class="number">0</span>)</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=max+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getmaxValue</span>(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的算法分时间复杂度达到了<code>O(N*N)</code>,是否有办法使复杂度降到<code>O(NlogN)</code>？我们可以看到上面的程序之所以变为<code>O(N*N)</code>，是因为每次对<code>A[i]</code>都要遍历之前的<code>A[x]</code>，我们是否可以通过增加一个数组来存储形成的最长非降子序列，然后进行二分查找呢，经过二分查找使得复杂度变为<code>O(NlogN)</code>:</p>
<p><strong>要这样做我们必须重新定义<code>dp[i]</code>数组的意义，<code>dp[i]</code>它表示长度为<code>i+1</code>的递增子序列中，最大的序列尾数；再定义一个<code>maxL</code>变量，指示当前最长递增子序列的长度，对数组<code>dp</code>二分查找，判断<code>cap[x]</code>要插入的位置</strong></p>
<ul>
<li>若<code>cap[x]&gt;dp[maxL]</code>,表示当前该值比递增子序列的尾数都大，将<code>cap[x]</code>添加到<code>dp</code>尾部，<code>maxL++</code></li>
<li>若<code>dp[i-1]&lt;cap[x]&lt;dp[i]</code>，更新相应<code>dp[i]</code>即可</li>
</ul>
<p>显然这种方法以及不算动态规划了，是一种特殊解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; storage)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">	<span class="type">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> lo = <span class="number">0</span>, hi = maxL;</span><br><span class="line">		<span class="comment">//二分查找</span></span><br><span class="line">		<span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (dp[mid] &lt; num)</span><br><span class="line">				lo = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				hi = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[lo] = num;</span><br><span class="line">		<span class="keyword">if</span> (lo == maxL)</span><br><span class="line">		&#123;</span><br><span class="line">			maxL++;</span><br><span class="line">			<span class="keyword">if</span>(storage[<span class="number">0</span>].size&lt;maxL)</span><br><span class="line">				storage.<span class="built_in">clear</span>();</span><br><span class="line">			storage.<span class="built_in">push_back</span>(dp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>附加：如果要你返回所有最长递增子序列或者返回最长递增子序列的个数该如何解决？</em></strong> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/solution/zui-chang-di-zeng-zi-xu-lie-de-ge-shu-by-w12f/">leetcode第673题.最长递增序列的个数</a></p>
<h5 id="中级">1.3 中级</h5>
<p>上面举的例子都是对一维<code>dp</code>来解决，接下来介绍如何解决二维<code>dp</code>的问题。</p>
<p>**问题：平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果**</p>
<p>当然了，使用动态规划<code>dp</code>就要找初始条件喝状态转移方程</p>
<ul>
<li>定义二维数组<code>dp[N][M]</code>，<code>d[i][j]</code>表示从<code>A[0][0]</code>到<code>A[i][j]</code>能收集到的最多苹果数量</li>
<li>因为只能向下喝右移动，则有状态转移方程<code>d[i][j]=max(d[i-1][j],d[i][j-1])+A[i][j]</code>，其中<code>i&gt;0,j&gt;0</code></li>
<li>为了方便实现状态转移方程，我们可以人增加隔离带，即<code>A[0][j]=0、A[i][0]=0</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxApple</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cap.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> row = cap[<span class="number">0</span>].<span class="built_in">size</span>(),</span><br><span class="line">		col = cap.<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(col+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(row+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= col; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= row; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> Max = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			dp[i][j] = Max + cap[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[col][row];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述算法复杂度为<code>O(N*M)</code></p>
<h4 id="参考文章动态规划从新手到专家">参考文章：<a target="_blank" rel="noopener" href="https://hawstein.com/2013/03/26/dp-novice-to-advanced/">动态规划：从新手到专家</a></h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-28 13:30:57" itemprop="dateCreated datePublished" datetime="2022-07-28T13:30:57+08:00">2022-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-15 13:42:00" itemprop="dateModified" datetime="2022-12-15T13:42:00+08:00">2022-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="算法总览">1. 算法总览</h4>
<p>常见的排序算法有<strong>插入排序、选择排序、希尔排序、堆排序、冒泡排序、快速排序、归并排序和基数排序</strong>。常见排序算法可以分为两大类：</p>
<ul>
<li><strong>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破<code>O(nlogn)</code>，因此称为非线性时间比较类排序</strong>。</li>
<li><strong>线性时间非比较类排序：</strong>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。排序算法的时间复杂度如下： <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort.png" width="700"></li>
</ul>
<p><strong>算法的稳定性：</strong>稳定性就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。</p>
<ul>
<li><strong>稳定排序算法</strong>：冒泡排序、插入排序、归并排序、计数排序、桶排序与基数排序</li>
<li><strong>不稳定排序算法</strong>：希尔排序、选择排序、堆排序与快速排序</li>
</ul>
<p><strong>内部排序和外部排序：</strong>内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。上面所列举的都是内部排序。像多路归并可以采用外部排序</p>
<h5 id="插入排序">1.1 插入排序</h5>
<ul>
<li><strong>基本思想：</strong>每次将当前元素插入到左侧（有序区）已经排序的数组中，使得插入之后的左侧数组依然有序。
<ul>
<li>查找出元素要插入的位置：要插的元素与之前排好的子序比较</li>
<li>将要插入位置的元素及后面的元素后移一个位置</li>
<li>将元素插入</li>
</ul></li>
<li><p><strong>复杂度</strong>：插入排序一共需要两重循环，第一重循环确定需要加入有序序列的新元素，一共n-1轮，第二重循环确定新元素在原来有序序列中的位置，平均需要<code>n/4</code>轮可以确定位<code>O(n²)</code>,空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性：</strong>每次比较时遇到第一个小于等于新元素的元素，就将新元素插入到该元素的后面，即可不破坏相等元素的相对顺序，做到算法稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len== <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = cap[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; cap[j] &gt; tmp; j--)</span><br><span class="line">            cap[j + <span class="number">1</span>] = cap[j];</span><br><span class="line">        cap[j + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="希尔排序">1.2 希尔排序</h5>
<p>通过上面对插入排序程序的编写知道，插入排序适用于基本有序和数据量不大的排序表，<strong>希尔排序</strong>是基于这两点改进而来的。</p>
<ul>
<li><p><strong>基本思想</strong>：先将待排序表分割成若干形如 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">L</span>[i,i+d,i+<span class="number">2</span>d……,i+kd]</span><br></pre></td></tr></table></figure> 既把步长相隔增量d的记录组成一个子表，对各个子表分别进行直接插入排序。当整个表的元素已呈<strong>“基本有序”</strong>时，再次对全体记录进行一次直接插入排序。一般来说，步长取<code>d=n/2</code>，之后都已<code>1/2</code>递减。</p>
<ul>
<li>1.取一步长<code>d1&lt;n</code>，把表中全部记录分发d组</li>
<li>2.所有距离为<code>d1</code>的倍数的记录放到一组。</li>
<li>3.在各组内进行直接插入排序</li>
<li>4.取第二个步长<code>d2&lt;d1</code>，重复上述过程，直到<code>d=1</code>。</li>
<li>5.<code>d=1</code>时，再进行一次直接插入排序</li>
</ul></li>
<li><p><strong>复杂度：</strong>希尔排序的时间复杂度会随着<code>d</code>选取策略的不同而发生变化，但是通常保持在<span class="math inline">\(O(n^{1.3})~O(n^{1.5})\)</span>;希尔排序依旧属于原地排序，不需要额外的空间，所以空间复杂度与插入排序一样为<code>O(1)</code></p></li>
<li><p><strong>稳定性：</strong>虽然插入排序是稳定的排序算法，但是希尔排序因为将序列进行了拆分再进行插入排序，如此不同组中的相等元素相对位置不能保证不变，所以相等元素的相对位置会发生改变，故时不稳定排序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/shellSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = len / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;len ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = cap[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; cap[j] &gt; tmp; j -= d)</span><br><span class="line">                cap[j + d] = cap[j];</span><br><span class="line">            cap[j + d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="选择排序">1.3 选择排序</h5>
<p>选择排序<code>Selection-sort</code>是一种简单直观的排序算法。它的</p>
<ul>
<li><p><strong>基本思想：</strong>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始（末尾）位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></li>
<li><p><strong>复杂度：</strong>选择排序一共需要比较<code>n-1</code>轮（每轮找到最小的元素进行交换），第<code>m</code>轮比较<code>n-m</code>次，所以比较的总次数为：$ _{i=0}^{n-1}n-i <span class="math inline">\(，即为\)</span>O(N^2)<span class="math inline">\(。选择排序不需要额外的空间，故其空间复杂度为\)</span>O(1)$</p></li>
<li><p><strong>稳定性：</strong>由于选择出的元素可能会进行跨越式的交换，所以会破坏原本的顺序，所以不稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即使终止的选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size = cap.<span class="built_in">size</span>(); !sorted &amp;&amp; size &gt; <span class="number">1</span>; size--)</span><br><span class="line">    &#123;		<span class="comment">//每一轮size-1,最大的放在后面   </span></span><br><span class="line">        <span class="type">int</span> indexOfMax = <span class="number">0</span>;</span><br><span class="line">        sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap[indexOfMax] &lt; cap[i])		<span class="comment">//找出最大的值</span></span><br><span class="line">                indexOfMax = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sorted = <span class="literal">false</span>;	<span class="comment">//无序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Swap</span>(cap[indexOfMax], cap[size - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="冒泡排序">1.4 冒泡排序</h5>
<ul>
<li><p><strong>基本思想：</strong>从后往前（从前往后），两两比较相邻元素的值。若为逆序A[i]&lt;A[i-1]，则交换他们。每一轮将最大的放到后面（即每一次减少一次内循环）</p></li>
<li><p><strong>复杂度：</strong>冒泡排序一共需要比较<code>n-1</code>轮，第<code>m</code>轮比较<code>n-m</code>次，所以其比较总次数应为：<span class="math inline">\(\displaystyle\sum_{i=0}^{n-1}n-i\)</span>，故冒泡排序的时间复杂度为<code>O(n²)</code>。冒泡排序比较和交换的过程中不消耗额外的内存，故冒泡排序的空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性</strong>：比较时如果两个元素相等则不交换，即可做到使算法稳定 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序时及时终止的冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(T&amp; cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cap.<span class="built_in">size</span>(); sorted &amp;&amp; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        sorted = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (cap[j] &gt; cap[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(cap[j], cap[j + <span class="number">1</span>]);</span><br><span class="line">                sorted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速排序">1.5 快速排序**</h5>
<ul>
<li><strong>基本思想</strong>：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。
<ul>
<li>1.选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</li>
<li>2.分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</li>
<li>3.递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</li>
</ul></li>
<li><p><strong>复杂度</strong>：<strong>快速排序的性能受到基准选择策略的影响</strong>，理论上如果每次选择基准都选择分区的第一个元素，那么这个序列越有序则时间复杂度越趋近于<code>O(n²)</code>，这是因为每次基准都是分区最大或最小的元素，那么左区间将会没有元素，而右区间将会有除了基准外的全部元素，这样就跟普通的插入排序没有区别了，<strong>因此对于快排会有优化措施</strong>。<strong>快速排序的最坏运行情况是<code>O(n²)</code>，比如说顺序数列的快排。但它的平摊期望时间是<code>O(nlogn)</code>，且<code>O(nlogn)</code> 记号中隐含的常数因子很小</strong>，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。<strong>快速排序可以实现原地排序，不需要消耗额外的内存，所以快速排序的空间复杂度为<code>O(1)</code>。</strong></p></li>
<li><p><strong>稳定性</strong>：快速排序不能保证相等元素的相对顺序不发生改变，所以不稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写自己的quickSort,没有优化，遇到最坏情况的时间复杂度会变成O(N*N)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--;</span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="快排优化">1.5.1 快排优化</h6>
<p>对于快排，其性能受到基准选择策略的影响，当出现下面两种情况时为最坏情况：</p>
<ul>
<li>在分解时每次选取的基准点为最小元素</li>
<li>在分解时每次选取的基准点为最大元素</li>
</ul>
<p>为了避免快排出现上述所说的最坏情况，选择哪一个元素作为基准点是关键，<strong>在快排过程中采用三点取中间值的优化方案。三数取中<code>median-of-three</code>指的是在挑选基准元素时，不是简单的选择数组中的第一个元素或最后一个，而是选取某三个元素，常选头、尾和中央三个元素，并且适用三个元素之中的中位数作为基准元素进行划分</strong>。这样即使在最坏的情况下将时间复杂度推进到<code>O(NlogN)</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后的快排代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">medianOfThree</span>(a, first, (first + last) / <span class="number">2</span>, last);</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--; </span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cap[first] &lt; cap[mid])</span><br><span class="line">        <span class="keyword">if</span> (cap[first] &gt;= cap[last])	<span class="comment">//last=&lt;first&lt;mid</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&lt;mid&lt;last</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[mid];</span><br><span class="line">            cap[mid] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">// first&lt;last&lt;=mid</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[last];</span><br><span class="line">            cap[last] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[first] &lt; cap[last])	<span class="comment">//last&gt;first&gt;=mid</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&gt;=mid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[last];</span><br><span class="line">        cap[last] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[mid];</span><br><span class="line">        cap[mid] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.png" width="600"> 上图对优化后和优化前的快排进行了测试，很明显三数取中后对与升序和降序数组的时间得到了大大的改善，避免了最坏情况，逼近<code>O(NlogN)</code>,<strong>但是对于重复数组的优化还不能得到很好的改善，因此可以在三数取中的快排中加入以下的策略：</strong></p>
<ul>
<li><p>优化一：当待排序序列的长度分割到一定大小后，使用插入排序，这是因为对于很小部分大致有序的数组，快排不如插排效率。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</p></li>
<li><p>优化二：当待排序序列的长度分割到一定大小后如100个，使用计数排序，这样能够很明显的提升大量重复值情况下的效率</p></li>
</ul>
<h5 id="堆排序">1.6 堆排序*</h5>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个完全二叉树的结构，并同时满足堆的的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p>
<p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
<ul>
<li><strong>基本思想</strong>：
<ul>
<li><p><strong>插入：</strong>因为<strong>堆是完全二叉树，所以当加入一个元素形时，必须维持该堆仍为完全二叉树</strong>，即该新节点位置由此定下了肯定为叶子结点。接着元素插入要依据原来是大根堆还是小根堆（即不能破环该堆的性质）。把插入的元素，沿着从新节点到根节点的路径<code>i/2</code>，执行一趟冒泡操作，将新元素与其夫节点的元素比较交换，直到后者大于前者（大根堆为例）。</p></li>
<li><p><strong>删除：在大根堆中删除一个元素，其实就是删除根节点的元素</strong>。此时就需要重新组织，以便保持性质不变 。其策略是，从删除的位置开始为一个树,向下找，找到该树的最后一个叶子节点，删除该节点但保存元素到临时量；然后比较节点的左右孩子，将大的放到该根节点；这时因为大孩子的被放到根节点而成为了空(没有元素），以此类推，直到最后一个叶子我们与之前中间量保存的元素比较，完成删除排序，</p></li>
<li><p><strong>初始化：</strong>当堆刚开始时就要有n个元素，我们就要构建非空堆，我们需要在堆中执行n次插入操作。先将元素按层次插入，取位置在i=n/2的元素，如果以这个元素为根的子树是大根堆则不做操作，如果不是大根堆则从该节点开始的树进行检测替换，依次检查i-1,i-2……1</p></li>
</ul></li>
<li><p><strong>复杂度</strong>：堆排序的时间复杂度是标准的<code>O(nlogn)</code>。用数组实现堆的功能，故空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性</strong>：堆排序并不是进行线性的比较，而是根据堆的结构进行比较，所以在交换时会破坏相等元素原本的相对顺序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/heapSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆插入</span></span><br><span class="line"><span class="comment">该方法通过查询当前堆的大小和元素比较定位插入点，进行大根堆完全二叉树形式插入即`/2`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T&amp; heap,<span class="type">const</span> T&amp; theElement)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> currentNode=++heapsize;</span><br><span class="line">	<span class="comment">//通过比较寻找插入点，比插入值小的元素下沉</span></span><br><span class="line">	<span class="keyword">while</span>(currentNode!=<span class="number">1</span>&amp;&amp;heap[currentNode/<span class="number">2</span>]&lt;theElement)</span><br><span class="line">	&#123;</span><br><span class="line">		heap[currentNode]=heap[currentNode/<span class="number">2</span>];</span><br><span class="line">		currentNode/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入新值</span></span><br><span class="line">	heap[currenNode]=theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆删除</span></span><br><span class="line"><span class="function">templaet&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; heap)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(heapsize==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	heap[<span class="number">1</span>].~<span class="built_in">T</span>();		<span class="comment">//销毁根节点元素</span></span><br><span class="line">	T lastElement=heap[heapsize];	<span class="comment">//最后一个元素保存到临时变量</span></span><br><span class="line">	heap[heapsize--].~<span class="built_in">T</span>();			<span class="comment">//销毁最后一个元素</span></span><br><span class="line">	<span class="type">int</span> currentNode=<span class="number">1</span>,child=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;heapsize)</span><br><span class="line">	&#123;	<span class="comment">//元素进行上升</span></span><br><span class="line">		<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="comment">//判断lastElement是否可以放在heap[child]上</span></span><br><span class="line">		<span class="keyword">if</span>(lastElement&gt;=heap[child])	<span class="comment">//可以就直接退出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		heap[currentNode]=heap[child];</span><br><span class="line">		currentNode=child;</span><br><span class="line">		child*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currentNode]=lastElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(T&amp; Heap,std::<span class="type">size_t</span> _heapsize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	heapsize=_heapsize;</span><br><span class="line">	<span class="comment">//从下往上进行堆化，即从heapsize/2开始，直到root=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> root=heapsize/<span class="number">2</span>;root&gt;=<span class="number">1</span>;root--)</span><br><span class="line">	&#123;</span><br><span class="line">		T rootElement=heap[root];</span><br><span class="line">		<span class="type">int</span> child=<span class="number">2</span>*root;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;=heapsize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span>(rootElement&gt;=heap[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			heap[child/<span class="number">2</span>]=heap[child];</span><br><span class="line">			child*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[child/<span class="number">2</span>]=rootElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你也可以不用写堆排序，直接使用STL当中的<code>push_heap、pop_heap、make_heap</code>进行插入、删除和初始化一个堆。</p>
<h5 id="基数排序">1.7 基数排序*</h5>
<p>基数排序是一种<strong>非比较型整数排序算法</strong>，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<ul>
<li><strong>基本思想</strong>：基数排序排序主要通过将数字分解进行排序，如三位数的925，基数排序可通过十进制分解，将925分解成9、2、5三个数，然后依次以个位、十位、百位进行排序。<strong>在这个过程中，因为数字只有0~9,所有仅仅需要10个桶就，然后调用三次箱子排序即可</strong>：
<ul>
<li>1.将无序集合中的所有元素根据个位的大小分别分配到0-9十个桶中；</li>
<li>2.从个位为0的桶开始依据每个元素的十位将元素分配到0-9十个桶中；</li>
<li>3.每次依据的位数增加一位（百位，千位，万位），直到集合中最大的数的位数为止；</li>
<li>4.最后一次分配完成后从第0个桶开始依次取出元素，直到所有的元素被取出来，这个取出的顺序可以保证元素是从小到大的；</li>
</ul></li>
<li><p><strong>复杂度</strong>：每一次散列需要对每个元素进行分配，即n次操作，最多进行最大的数的位数轮散列分配，即k轮，所以时间复杂度为<code>O(n*k)</code>。基数排序需要<code>n+m</code>个额外空间，其中<code>n</code>为待排序集合大小，<code>m</code>为10（无负数元素）或<code>20</code>（有负数元素）</p></li>
<li><p><strong>稳定性</strong>：基数排序不会破坏相等元素的相对顺序，所以是稳定的 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/radixSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(T&amp; cap,<span class="type">int</span> place)</span> </span>&#123;	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,num=<span class="number">1</span>; i &lt; place; i++,num*=<span class="number">10</span>) &#123;<span class="comment">//num指示对哪一位进行基数排序</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">tempVec</span>(<span class="number">10</span>);<span class="comment">//二维数组，内部vector的大小看数据量 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cap.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = cap[i] / num % <span class="number">10</span>;</span><br><span class="line">            tempVec[index].<span class="built_in">push_back</span>(cap[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cap.<span class="built_in">clear</span>();		<span class="comment">//清除里面的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)		<span class="comment">//放回vec</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = tempVec[i].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (it != tempVec[i].<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cap.<span class="built_in">push_back</span>(*it);</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="归并排序">1.8 归并排序**</h5>
<ul>
<li><strong>基本思想</strong>：归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法<code>Divide and Conquer</code>的一个非常典型的应用。<strong>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序</strong>。若将两个有序表合并成一个有序表，称为二路归并。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：一是自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；二是自下而上的迭代；
<ul>
<li>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>4.重复步骤 3 直到某一指针达到序列尾；</li>
<li>5.将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul></li>
<li><p><strong>复杂度</strong>：很明显归并排序需要<code>logn</code>轮合并，每轮合并需要<code>n-1~n/2</code>次比较，所以时间复杂度为<code>O(nlogn)</code>.归并排序比较占用内存，但却是一种效率高且稳定的算法，其需要临时空间存储归并后的数据，因此空间复杂度为<code>O(N)</code></p></li>
<li><p><strong>稳定性</strong>：归并排序的合并操作并不会影响相同元素的相对顺序，故稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//使用迭代实现二路归并排序</span></span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(len);       <span class="comment">//合并空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)</span><br><span class="line">    &#123;   <span class="comment">//logn趟合并</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//合并相邻两子序列</span></span><br><span class="line">            <span class="type">int</span> next = j + i;</span><br><span class="line">            <span class="type">int</span> k = j;</span><br><span class="line">            <span class="keyword">while</span>(k &lt;(j+i) &amp;&amp; k&lt;len &amp;&amp; next &lt; len &amp;&amp; next &lt; (j+<span class="number">2</span>*i) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cap[k] &lt;= cap[next])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[index] = cap[k];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[index] = cap[next];</span><br><span class="line">                    next++;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k&lt;len &amp;&amp;k &lt; j + i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[index] = cap[k];</span><br><span class="line">                index++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (next &lt; len &amp;&amp; next &lt; j + <span class="number">2</span> * i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[index] = cap[next];</span><br><span class="line">                index++;</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            j = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), cap.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计数排序">1.9 计数排序</h5>
<ul>
<li><p><strong>基本思想：</strong>计数排序的核心在于<strong>将输入的数据值转化为键存储在额外开辟的数组空间中</strong>。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<strong>确定范围的整数</strong>。当输入的元素是<code>n</code>个0到k之间的整数时，它的运行时间是<code>Θ(n + k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。<strong><em>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量内存，因此堆数据范围很大的不适用，该排序算法最号应用于数据范围不大重复值多的情况</em></strong>。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>遍历数组<code>cap</code>，对值<code>i</code>作为cap的下标存入<code>+1</code>,即<code>C[i]++</code>;</li>
<li>对所有的重复值计数累加</li>
<li>从前往后遍历数组C，将对应的下标index作为值存人<code>cap</code>，并在<code>C[index]-1</code></li>
</ul></li>
<li><p><strong>复杂度</strong>：计数排序的时间复杂度与待排序元素的范围相关，其时间复杂度为<code>O(n+k)</code>,其中<code>n</code>为元素数量，<code>k</code>为元素的范围（即最大的元素与最小的元素的差加1）。计数排序需要额外开辟k个桶的空间，所以空间复杂度为<code>(k)</code>。</p></li>
<li><p><strong>稳定性</strong>：计数排序是一个非基于比较的线性时间排序算法,所以看出是一种稳定排序 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/countingSortgif.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxValue = <span class="built_in">getMaxValue</span>(cap)+<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(maxValue)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : cap)</span><br><span class="line">        tmp[i]++;</span><br><span class="line">    <span class="type">int</span> _index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxValue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (tmp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cap[_index] = i;</span><br><span class="line">            tmp[i]--;</span><br><span class="line">            _index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="桶排序">1.10 桶排序*</h5>
<ul>
<li><strong>基本思想</strong>：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：<strong>一是在额外空间充足的情况下，尽量增大桶的数量；二是使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</strong>。同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。
<ul>
<li>1.开辟m大小的空间，生成m个桶，每个桶对应一个范围；</li>
<li>2.将待排序的所有元素依次按照范围散列到对应的桶里；</li>
<li>3.对所有的桶内的元素以桶为单位排序；</li>
<li>4.从第一个桶开始依次将排好序的元素取出；</li>
</ul></li>
<li><p><strong>复杂度</strong>：对于待排序序列大小为<code>N</code>，共分为<code>M</code>个桶，<code>N</code>次循环，将每个元素装入对应的桶中。<code>M</code>次循环，对每个桶中的数据进行排序（平均每个桶有<code>N/M</code>个元素）。一般使用较为快速的排序算法，时间复杂度为 O(N/MlogN/M)，整个桶排序的时间复杂度为：<code>O(N)+O(M∗(N/M∗log(N/M))) = O(N)+O(N∗(log(N/M)) = O(N)+O(C）= O(N∗(log(N/M)+1))</code>；桶排序需要额外的m个桶的空间和n个元素的空间，故空间复杂度为<code>O(m+n)</code>。</p></li>
<li><p><strong>稳定性</strong>：桶排序的稳定性取决于桶内排序使用的算法，所以我们通常认为桶排序是稳定排序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bucketSort.png" width="400"></p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/18/Makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/18/Makefile/" class="post-title-link" itemprop="url">Makefile</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-18 12:06:19" itemprop="dateCreated datePublished" datetime="2022-07-18T12:06:19+08:00">2022-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-23 13:20:49" itemprop="dateModified" datetime="2022-07-23T13:20:49+08:00">2022-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Makefile/" itemprop="url" rel="index"><span itemprop="name">Makefile</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/18/Makefile/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/18/Makefile/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="make">1. make</h4>
<h5 id="make是什么">1.1 make是什么</h5>
<p>make是一个命令，是管理文件的自动编译管理器，这里的自动是指能根据文件时间戳自动发现更新过的文件而减少编译的工作量，同时通过读取makefile的文件的内容来进行预期的编译工作，make将只编译有改动的文件，而不用完全编译。</p>
<h5 id="工作原理">1.2工作原理</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app:main.o hello.o</span><br><span class="line">        gcc -o app main.o hello.o</span><br><span class="line">main.o:main.c hello.h</span><br><span class="line">        gcc -c main.c</span><br><span class="line">hello.o:hello.c hello.h</span><br><span class="line">        gcc -c hello.c</span><br><span class="line">clean:</span><br><span class="line">        rm app main.o hello.o</span><br></pre></td></tr></table></figure>
<ul>
<li><code>make</code>在当前目录寻找<code>Makefile</code>或<code>makefile</code>文件。</li>
<li>如果找到，它会找文件中的第一个目标文件<code>target</code>，如上例它找到<code>app</code>这个目标文件，把这个文件作为最终的目标文件。如果<code>app</code>文件不存在,或是<code>app</code>所依赖的后面的<code>.o</code>文件的文件修改时间要比<code>app</code>这个文件新，那么<code>make</code>命令就会执行后面所定义的命令来生成<code>app</code>这个文件。</li>
<li><strong>如果<code>app</code>所依赖的<code>.o</code>文件也不存在，那么<code>make</code>命令会在当前文件中寻找目标为<code>.o</code>文件的依赖关系。如果找到，则再根据那一个规则生成<code>.o</code>文件，根据<code>.o</code>文件依赖的<code>.c</code>文件和<code>.h</code>文件，执行规则生成<code>.o</code>文件。</strong></li>
<li><strong>然后make再用<code>.o</code>文件生成执行文件<code>app</code></strong></li>
</ul>
<p><strong>总而远之，<code>make</code>会依据依赖关系一层一层地去找文件的依赖关系,直到最终编译出第一个目标文件</strong>。在找寻的过程中,如果出现错误,如最后被依赖的文件找不到,那么 make 就会直接退出并报错。</p>
<p>但是像<code>clean</code>这种没有被第一个目标文件直接或间接关联,那么它后面所定义的命令将不会被自动执行。不过，可以显式指定<code>make</code>执行<code>clean</code>，即<code>make　clean</code>。<strong>同时只要修改了与第一个目标文件存在直接或间接依赖关系的文件，都会发生重新编译和重新链接</strong></p>
<h5 id="make命令">1.3 make命令</h5>
<p>make是一个命令工具，它解释Makefile 中的指令（应该说是规则） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make [ -f file ][ options ][ targets ]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>-f file</code>:<code>make</code>默认在工作目录中寻找名为<code>GNUmakefile、makefile、Makefile</code>的文件作为<code>makefile</code>输入文件,但有时可能命名不是这些,则<code>-f</code>可以指定以上名字以外的文件作为makefile输入文件</p></li>
<li><code>options</code>
<ul>
<li><code>v：</code>显示make工具的版本信息</li>
<li><code>w：</code>在处理<code>makefile</code>之前和之后显示工作路径</li>
<li><code>C dir：</code>读取<code>makefile</code>之前改变工作路径至dir目录</li>
<li><code>n：</code>只打印要执行的命令但不执行</li>
<li><code>s：</code>执行但不显示执行的命令</li>
</ul></li>
<li><p><code>targets</code>:使用<code>make</code>命令时没有指定目标，则<code>make</code>工具默认会实现<code>makefile</code>文件内的第一个目标，如果指定了<code>make</code>工具要实现的目标则该目标为最终目标（目标可以是一个或多个）</p></li>
</ul>
<h4 id="makefile">2. Makefile</h4>
<p><code>Makefile</code>是一个脚本文件，其内部编写一些符和<code>make</code>工具解析的语法规则来进行执行一些命令。</p>
<h5 id="makefile是什么">2.1 Makefile是什么</h5>
<p><code>makefile</code>定义了一系列的规则来指定，<strong>哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译</strong>，甚至于进行更复杂的功能操作，因为<code>makefile</code>就像一个<code>Shell</code>脚本一样，其中也可以执行操作系统的命令。<code>Makefile</code>带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。<code>makefile</code>文件由<code>make</code>命令工具来执行。</p>
<p><strong>make主要解决两个问题：</strong></p>
<ul>
<li><strong>1) 大量代码的关系维护</strong>:大项目中源代码比较多，手工维护、编译时间长而且编译命令复杂，难以记忆及维护,把代码维护命令及编译命令写在<code>makefile</code>文件中，然后再用<code>make</code>工具解析此文件自动执行相应命令，可实现代码的合理编译</li>
<li><strong>2) 减少重复编译时间</strong>，在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有的目标文件，节省编译时间。</li>
</ul>
<p><code>Makefile</code>文件命名规则<code>makefile</code>和<code>Makefile</code>都可以，推荐使用<code>Makefile</code>,即<code>vim Makefile</code>。学号<code>Makefile</code>只需要学习他的<strong>一条规则，三个变量，两个函数</strong>就能上手了。</p>
<h5 id="一条规则">2.2 一条规则</h5>
<p><strong>一条规则</strong>即指完成单此任务所包含的要素，Makefile的一条规则三要素如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一条规则</span></span><br><span class="line">target... : prerequisites ...</span><br><span class="line">     command</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>target</code>:<strong>通常是要产生的文件名称，目标可以是可执行文件或其它obj文件，也可是一个标签</strong></li>
<li><code>prerequisites</code>：依赖文件，用来输入从而产生目标的文件，一个目标通常有几个依赖文件（也可以没有）。<code>prerequisites</code>中如果有一个以上的文件比<code>target</code>文件要新的话，<code>command</code>所定义的命令就会被执行。</li>
<li><code>command</code>：make执行的动作，一个规则可以含几个命令（可以没有）。有多个命令时，每个命令占一行。</li>
</ul>
<p><code>make</code>工具从上往下找寻<code>target</code>，<strong>根据<code>target</code>后对应的依赖关系，先去查找依赖项的文件,为索所有的目标文件创建依赖关系链</strong>。若依赖项不存在，则会报错： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make div.o</span><br><span class="line">make: *** No rule to make target <span class="string">&#x27;div.cpp&#x27;</span>, needed by <span class="string">&#x27;div.o&#x27;</span>.  Stop.</span><br></pre></td></tr></table></figure> 若存在，在检查依赖关系时，同时会检查目标与源文件的时间戳，当源文件时间戳更新时，make会更新依赖它的链路上所有文件，即调用command部分。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Makefile件</span></span><br><span class="line">sum.o:sum.cpp</span><br><span class="line">        g++ -c  sum.cpp -o sum.o</span><br><span class="line">main.o:main.cpp</span><br><span class="line">        g++ -c main.cpp -o main.o</span><br><span class="line">main:main.o sum.o</span><br><span class="line">        g++ main.o sum.o -o main</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make sum.o main.o main</span><br><span class="line">make: <span class="string">&#x27;sum.o&#x27;</span> is up to date.</span><br><span class="line">g++ -c main.cpp -o main.o</span><br><span class="line">g++ main.o sum.o -o main</span><br></pre></td></tr></table></figure></p>
<h5 id="变量">2.3 变量</h5>
<p>在<code>Makefile</code>中使用变量有点类似于C语言中的宏定义，使用该变量相当于内容替换，使用变量可以使<code>Makefile</code>易于维护,修改内容变得简单变量定义及使用。<strong>在<code>Makefile</code>中由自定义变量和自动变量</strong>。</p>
<h6 id="等号">2.3.1 等号</h6>
<p>在学习变量前需要熟悉Makefile中的等号，等号有4种<code>=，:=，?=，+=</code>。</p>
<ul>
<li><code>?=</code>表示，如果左边的变量没有被赋值，那么将等号右边的值赋给左边的变量。如果赋过值，则保持原来的值不变。</li>
<li><code>+=</code>表示将等号右边的值追加到左边变量中，但是中间会有一个空格。</li>
<li><code>=</code>与<code>:=</code>是比较不好区分的两个等号，可以将”=“理解为&quot;址传递&quot;或引用，”:=“理解为&quot;值传递”。</li>
</ul>
<p>在<code>Makefile</code>中是不允许将变量自己的值赋给自己的，也不允许出现循环引用。</p>
<h6 id="变量名的规则">2.3.2 变量名的规则</h6>
<p><strong><code>makefile</code>的变量名的起名规则：</strong></p>
<ul>
<li><code>makefile</code>变量名可以以数字开头</li>
<li>变量是大小写敏感的</li>
<li>变量一般都在<code>makefile</code>的头部定义</li>
<li>变量几乎可在<code>makefile</code>的任何地方使用</li>
</ul>
<h6 id="自定义变量">2.3.3 自定义变量</h6>
<ul>
<li>1）定义变量方法：<code>变量名=变量值</code>,<code>变量名？=变量值</code>,<code>变量名+=变量值</code>,<code>变量名:=变量值</code></li>
<li><ol start="2" type="1">
<li>使用变量名：<code>$(变量名)</code>或<code>$&#123;变量名&#125;</code></li>
</ol></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objs=add.o sum.o div.o mul.o</span><br><span class="line">target=main</span><br><span class="line">$(target):$(bgjs)</span><br><span class="line">		gcc &amp;(objs) -o $(target)</span><br></pre></td></tr></table></figure>
<h6 id="三个重要自动变量">2.3.4 三个重要自动变量</h6>
<p><code>Makefile</code>的自动变量有以下几个:</p>
<p><img src="/2022/07/18/Makefile/auto.png" width="700"></p>
<p><strong>其中重要常用的三个是：</strong></p>
<ul>
<li><code>$@:</code> 表示规则中的目标</li>
<li><code>$&lt;:</code>表示规则中依赖性的第一个</li>
<li><code>$^:</code> 表示规则中的所有依赖性, 组成一个列表, 以空格隔开,如果这个列表中有重复的项则消除重复项。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">objs=add.o sum.o div.o mul.o</span><br><span class="line">target=main</span><br><span class="line">sum.o:sum.cpp</span><br><span class="line">        g++ -c  $^ -o $@</span><br><span class="line">main.o:main.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br><span class="line">$(target):$(bgjs)</span><br><span class="line">		g++ &amp;(objs) -o $(target)</span><br><span class="line">clean:</span><br><span class="line">		rm -rf $(objs) $(target)</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：自动变量只能在规则的命令中中使用</em></strong></p>
<h5 id="模式规则">2.4 模式规则</h5>
<p>如果想要进一步的偷懒，那就必须提到<strong>模式规则</strong>，模式规则用来匹配当前目录下的符合模式匹配的所有文件。模式规则类似于普通规则，<strong>只是在模式规则中，目标名中需要包含有模式字符<code>%</code>，包含有模式字符<code>%</code>的目标被用来匹配一个文件名，<code>%</code>可以匹配任何非空字符串</strong>。看到上面你觉得很绕，让我们看实例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#%表示可以匹配当前目录下的所有以.cpp为后缀的源文件，</span><br><span class="line">#并且对应生成相应名称的.o文件（注意是使用$&lt;才能生成对应.o文件</span><br><span class="line">%.o:%.cpp</span><br><span class="line">		g++ -c $&lt; -o $@</span><br></pre></td></tr></table></figure> 单独上面的这个<code>makefile</code>不能成功执行，会出现<code>No targets.Stop</code>错误 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接make，不成功</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make</span><br><span class="line">make: *** No targets.  Stop.</span><br><span class="line"><span class="comment">//传入目标，成功</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make main.o</span><br><span class="line">g++ -c main.cpp -o main.o</span><br></pre></td></tr></table></figure> 这是很正常的，因为<code>%</code>是模式匹配规则，你如果没传入目标它就无法执行<code>make</code>的工作机制。下面来讲解对<code>%</code>的解决办法</p>
<h5 id="函数">2.5 函数</h5>
<p><code>makefile</code>中的函数有很多，在这里给大家介绍两个最常用的:</p>
<ul>
<li><p><code>wildcard</code>查找指定目录下的指定类型的文件 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src = $(wildcard *.c) <span class="comment">//找到当前目录下所有后缀为.c的文件,赋值给src</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>patsubst</code>匹配替换 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = $(patsubst %.c,%.o, $(src)) <span class="comment">//把src变量里所有后缀为.c的文件替换成.o，然后赋值给obj</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong><em>注意</em></strong>：<code>patsubst</code>不是把src里的文件的后缀改为.o，是在<code>makefile.o</code>文件内部将生成的<code>.o</code>文件替换掉<code>src</code>内的<code>.cpp</code>文件，因此在<code>make</code>的时候一定是要先生成<code>.o</code>文件（这里从两者<code>*</code>和<code>%</code>就能看出)，从两者的特性能够得到以下的解决： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all:$(patsubst %.cpp,%.o,$(wildcard *.cpp))</span><br><span class="line">%.o:%.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br></pre></td></tr></table></figure> 原理：all目标获得了目录内的<code>*.cpp</code>文件，使用<code>patsubst</code>要求将<code>*.cpp</code>替换为<code>*.o</code>,但是目录中还没有<code>*.o</code>文件，则会依据make工作原理进行到下一个目标，刚好这个目标是生成<code>.o</code>文件的，则执行。</p>
<h5 id="简单示例">2.6 简单示例</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.cpp)</span><br><span class="line">objs=$(patsubst %.cpp,%.o,$(src))</span><br><span class="line">target=main</span><br><span class="line">$(target):$(objs)</span><br><span class="line">        g++ $(objs) -o $(target)</span><br><span class="line">%.o:%.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">#PHONY伪目标，不去判断目标文件是否存在或者更新，无条件执行</span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">        rm -rf $(objs) $(target)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#执行make</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make</span><br><span class="line">g++ -c main.cpp -o main.o</span><br><span class="line">g++ -c sum.cpp -o sum.o</span><br><span class="line">g++ main.o sum.o -o main</span><br><span class="line">#执行makeclean</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">Linux操作系统基本命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-15 17:26:07" itemprop="dateCreated datePublished" datetime="2022-07-15T17:26:07+08:00">2022-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-16 20:37:26" itemprop="dateModified" datetime="2022-12-16T20:37:26+08:00">2022-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="shell">1. shell</h4>
<p><code>shell</code>是<code>Linux</code>系统中运行的一种特殊程序。在用户和内核之间之间充当“翻译官”，用户登陆<code>Linux</code>系统时，自动加载一个<code>Shell</code>程序，<code>Bash</code>是<code>Linux</code>系统中默认使用的<code>Shell</code>程序。</p>
<ul>
<li>内核：用于调用计算机硬件资源</li>
<li>shell：将用户指令转换成计算机语言让内核去调用计算机硬件资源 <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell.png" width="500"></li>
</ul>
<h4 id="bash解析器常用快捷键teminal">2. Bash解析器常用快捷键(Teminal)</h4>
<p><code>bash</code>是一个文件，linux系统中万物皆文件，<code>bash</code>文件位于<code>/bin/bash</code>，<code>bash</code>使用的快捷键：</p>
<ul>
<li><code>Tab</code>键:补齐命令，补齐路径，显示当前目录下的所有目录</li>
<li>使用快捷键<code>Ctrl + L</code> 清除终端上的显示(类似于DOS的cls清屏功能)，也可用<code>clear</code>指令</li>
<li><code>ctlr+c</code>的作用是中断终端的操作。</li>
<li>遍历输入的历史命令：从当前位置向上遍历<code>ctrl + p</code>或<code>↑</code>；从当前位置向下遍历<code>ctrl + n（↓）</code></li>
<li>光标相关操作</li>
<li>光标左移： <code>ctrl + b （←）</code></li>
<li>坐标右移： <code>ctrl + f （→）</code></li>
<li>移动到头部：<code>ctrl + a（Home）</code></li>
<li>移动到尾部：<code>ctlr + e（End）</code></li>
<li>字符删除</li>
<li>删除光标前边的字符：ctrl + h（Backspace）</li>
<li>删除光标后边的字符：ctrl + d</li>
<li>删除光标前所有内容：ctrl + u</li>
<li>删除光标后所有内容：ctrl + k</li>
</ul>
<h4 id="系统目录">3. 系统目录</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oot@trluper-<span class="keyword">virtual</span>-machine:/home/trluper<span class="meta"># cd /</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/<span class="meta"># ls</span></span><br><span class="line">bin    dev   lib    libx32      mnt   root  snap      sys  var</span><br><span class="line">boot   etc   lib32  lost+found  opt   run   srv       tmp</span><br><span class="line">cdrom  home  lib64  media       proc  sbin  swapfile  usr</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/</code>：根目录，一般根目录下只存放目录，<strong>在<code>Linux</code>下有且只有一个根目录</strong>。所有的东西都是从这里开始。当你在终端里输入<code>/home</code>，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</li>
<li><code>/bin</code>: <strong>这一目录中存放了供超级用户和一般用户都可以使用的命令，常用的命令<code>ls、tar、mv、cat</code>等</strong></li>
<li><code>/usr/bin</code>: <strong>安装的外部的命令，<code>usr</code>表示的是<code>unix software source</code>，不是user。</strong></li>
<li><code>/boot</code>：放置<code>linux</code>系统启动时用到的一些文件，如<code>Linux</code>的内核文件<code>/boot/vmlinuz</code>，系统引导管理器<code>/boot/grub</code>。</li>
<li><code>/dev</code>：存放<code>linux</code>系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，</li>
<li><code>/etc</code>：<strong>系统配置文件存放的目录，不建议在此目录下存放可执行文件</strong>，重要的配置文件有 <code>/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</code></li>
<li><code>/home</code>：<strong>系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，<code>~edu</code>表示用户<code>edu</code>的家目录。</strong></li>
<li><code>/lib</code>：<strong>内核级别</strong>,系统使用的函数库的目录，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/lib</code>: <strong>系统级别</strong>，目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录</li>
<li><code>/usr/local/lib</code>：<strong>用户级别</strong>，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/include</code>：<strong>C程序语言编译使用的头文件。<code>linux</code>下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数</strong></li>
<li><code>/lost+fount</code>：系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li><code>/mnt、/media</code>:光盘默认挂载点，通常光盘挂载<code>/mnt/cdrom</code>下，也不一定，可以选择任意位置进行挂载。</li>
<li><code>/opt</code>：给主机额外安装软件所摆放的目录。</li>
<li><code>/proc</code>：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 <code>/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*</code> 等。</li>
<li><code>/root</code>：系统管理员root的家目录。</li>
<li><code>/sbin、/usr/sbin、/usr/local/sbin</code>：<strong>放置系统管理员使用的可执行命令</strong>，如<code>fdisk、shutdown、mount</code>等。<strong>与<code>/bin</code>不同的是，这几个目录是给系统管理员root使用的命令，</strong>一般用户只能&quot;查看&quot;而不能设置和使用。</li>
<li><code>/tmp</code>：<strong>一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</strong></li>
<li><code>/srv</code>：服务启动之后需要访问的数据目录，如<code>www</code>服务需要访问的网页数据存放在<code>/srv/www</code>内。</li>
<li><code>/usr</code>：<strong>应用程序存放目录，<code>/usr/bin</code>存放应用程序，<code>/usr/share</code>存放共享数据，<code>/usr/lib</code>存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。<code>/usr/local</code>:存放软件升级包。<code>/usr/share/doc:</code>系统说明文件存放目录。<code>/usr/share/man:</code>程序说明文件存放目录。</strong></li>
<li><code>/var</code>：放置系统执行过程中经常变化的文件，如随时更改的日志文件 <code>/var/log，/var/log/message</code>所有的登录文件存放目录，<code>/var/spool/mail</code>邮件存放的目录，<code>/var/run</code>程序或服务启动后，其PID存放在该目录</li>
</ul>
<h4 id="linux的文件">4. Linux的文件</h4>
<p>在Linux世界里，一切皆文件。在Linux中，文件可分为以下几种：<strong>普通文件（普通文件、可执行文件、压缩文件）、目录文件、设备文件、链接文件和套接字</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linuxFile.png" width="400"></p>
<p><strong>文件符号标识：</strong></p>
<ul>
<li>普通文件:<code>-</code></li>
<li>目录：<code>d</code></li>
<li>字符设备：<code>c</code></li>
<li>管道：<code>p</code></li>
<li>符号链接：<code>l</code></li>
<li>套接字：<code>s</code></li>
<li>符号连结：<code>l</code></li>
<li>一般文件:<code>f</code></li>
</ul>
<h4 id="linux常用命令">5. Linux常用命令</h4>
<p>Linux的命令分为内建命令和外部命令。<code>shell</code>内建命令是指<code>bash</code>工具中集成的命令，一般有一些都会有一个与之同名的系统函数。外部命令是安装外部软件所带的命令。</p>
<h5 id="内建命令和外部命令的区别">5.1 内建命令和外部命令的区别</h5>
<ul>
<li><p><strong>内部命令</strong>：实际上是<code>shell</code>程序的一部分，其中包含的是一些比较简单的<code>linux</code>系统命令，这些命令由<code>shell</code>程序识别并在<code>shell</code>程序内部完成运行，通常在<code>linux</code>系统加载运行<code>shell</code>时就被加载并驻留在系统内存中。内部命令是写在bashy源码里面的，<strong>其执行速度比外部命令快，因为解析内部命令shell不需要创建子进程</strong>。<code>exit，history，cd，echo</code>等就是内建命令 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help 内建命令</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>外部命令</strong>：<strong>外部命令是<code>linux</code>系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存</strong>。通常外部命令的实体并不包含在<code>shell</code>中，但是其命令执行过程是由<code>shell</code>程序控制的。<code>shell</code>程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。外部命令是在<code>bash</code>之外额外安装的，通常放在<code>/bin，/sbin，/usr/bin，/usr/sbin，/usr/local/sbin</code>等等。可通过<code>echo $PATH</code>命令查看外部命令的存储路径 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是外部命令一个--help选项，不是help指令</span></span><br><span class="line">外部命令 --help</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>type</code>命令可以分辨内部命令与外部命令</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用的三个参数：-t对应-type，-a对应-all，-p对应-path，</span></span><br><span class="line">type [-a | -t | -p] name</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">type [-all | -type | -path] name</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="内建命令使用">5.2 内建命令使用</h5>
<p>所有内建命令如下：加星号的为常用项</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
<th style="text-align: center;">重要程度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>：</code></td>
<td>扩展参数列表，执行重定向操作</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>.</code></td>
<td>读取并执行指定文件中的命令（在当前shell环境中）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>alias</code></td>
<td>为指定命令定义一个别名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>bg</code></td>
<td>将作业以后台模式运行</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>bind</code></td>
<td>将键盘序列绑定到一个<code>readline</code>函数或宏</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>break</code></td>
<td>退出<code>for、while、selec</code>t或<code>until</code>循环</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>builtin</code></td>
<td>执行指定的<code>shell</code>内建命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>caller</code></td>
<td>返回活动子函数调用的上下文</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>cd</code></td>
<td>将当前目录切换为指定目录</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>command</code></td>
<td>执行指定的命令，无需进行通常的shell查找</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>compgen</code></td>
<td>为指定单词生成可能的补全匹配</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>complete</code></td>
<td>显示指定的单词是如何补全的</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>compopt</code></td>
<td>修改指定单词的补全选项</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>continue</code></td>
<td>继续执行<code>for、while、select或until</code>循环的下一次迭代</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>declare</code></td>
<td>声明一个变量或者变量类型</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>dirs</code></td>
<td>显示当前存储目录的列表</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>disown</code></td>
<td>从进程作业表中删除指定的作业</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>echo</code></td>
<td>将指定字符串输出到<code>STDOUT</code></td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>enable</code></td>
<td>启用或禁止指定的内建<code>shell</code>命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>eval</code></td>
<td>将指定的参数拼接成一个命令，然后执行该命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>exec</code></td>
<td>用指定命令替换<code>shell</code>进程</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>exit</code></td>
<td>强制<code>shell</code>以指定的退出状态码退出</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>export</code></td>
<td>设置子<code>shell</code>进程可用的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>fc</code></td>
<td>从历史记录中选择命令列表</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>fg</code></td>
<td>将作业以前台模式运行</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>getopts</code></td>
<td>分析指定的位置参数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>hash</code></td>
<td>查找并记住指定命令的全路径名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>help</code></td>
<td>显示帮助文件</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>history</code></td>
<td>显示命令历史记录</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>jobs</code></td>
<td>列出活动作业</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>kill</code></td>
<td>向指定的进程ID发送一个系统信号</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>let</code></td>
<td>计算一个数学表达式中的每个参数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>local</code></td>
<td>在函数中创建一个作用域受限的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>logout</code></td>
<td>退出登录<code>shell</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>mapfile</code></td>
<td>从<code>STDIN</code>读取数据行，并将其加入索引数组</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>popd</code></td>
<td>从目录栈中删除记录</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>printf</code></td>
<td>使用格式化字符串显示文本</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>pushd</code></td>
<td>向目录栈添加一个目录</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>pwd</code></td>
<td>显示当前工作目录的路径名</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>read</code></td>
<td>从<code>STDIN</code>读取一行数据并将其赋值给一个变量</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>readarray</code></td>
<td>从<code>STDIN</code>读取数据行并将其放入索引数组</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>readonly</code></td>
<td>从<code>STDIN</code>读取一行数据并将其赋值给一个不可修改的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>return</code></td>
<td>强制函数以某个值退出，这个值可以被调用脚本提取</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>set</code></td>
<td>设置并显示环境变量的值和shell属性</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>shift</code></td>
<td>将位置参数依次向下降一个位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>shopt</code></td>
<td>打开/关闭控制<code>shell</code>可选行为的变量值</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>source</code></td>
<td>读取并执行指定文件中的命令（在当前<code>shell</code>环境中）</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>suspend</code></td>
<td>暂停<code>shell</code>的执行，直到收到一个<code>SIGCONT</code>信号</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>test</code></td>
<td>基于指定条件返回退出状态码0或1</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>times</code></td>
<td>显示累计的用户和系统时间</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>trap</code></td>
<td>如果收到了指定的系统信号，执行指定的命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>type</code></td>
<td>显示指定的单词如果作为命令将会如何被解释</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>typeset</code></td>
<td>声明一个变量或变量类型</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>ulimit</code></td>
<td>为系统用户设置指定的资源的上限</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>umask</code></td>
<td>为新建的文件和目录设置默认权限</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>unalias</code></td>
<td>删除指定的别名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>unset</code></td>
<td>删除指定的环境变量或<code>shell</code>属性</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>wait</code></td>
<td>等待指定的进程完成，并返回退出状态码</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h6 id="cd命令">5.2.1 cd命令</h6>
<p><code>cd</code>命令是改变当前工作目录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ../	返回上一级目录</span><br><span class="line">cd /  进入根目录</span><br><span class="line">cd ~	进入用户主目录</span><br><span class="line">如：</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ cd ~</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ pwd</span><br><span class="line">/home/trluper</span><br></pre></td></tr></table></figure></p>
<h6 id="dirs命令">5.2.2 dirs命令</h6>
<p><code>dirs</code>命令用于显示<code>Shell</code>目录中的堆栈记录。不加选项时显示当前的Shell命令堆栈中的所有目录，显示时左边为最新加入的目录。</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>删除目录堆栈中的所有记录</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>以完整格式显示堆栈中的目录。显示用户宿主目录时，列出完整路径，而不是“~”</td>
</tr>
<tr class="odd">
<td><code>-n</code></td>
<td>显示右起第n个目录（n从0计数）</td>
</tr>
<tr class="even">
<td><code>+n</code></td>
<td>显示左起第n个目录 （n从0计数）</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td>以每行一个记录的方式列出堆栈中多有记录</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>以每行一个记录的方式列出堆栈中所有记录，并在每行加上序号（从0开始编号）</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ dirs -v</span><br><span class="line"> <span class="number">0</span>  ~/Documents</span><br></pre></td></tr></table></figure>
<h6 id="echo命令">5.2.3 echo命令</h6>
<p><code>echo</code>命令用于将输入的字符串送往标准输出，默认输出的字符间以空白字符隔开，并在最后加上换行号。常与重定向命令<code>&gt;</code>结合使用。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo [OPTION]... [STRING]...</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>参数选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-n</code></td>
<td>不输出行尾的换行符，不自动换行</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>允许对下面列出的加反斜线转义的字符进行解释</td>
</tr>
<tr class="odd">
<td><code>-E</code></td>
<td>默认选项，禁止对在STRINGs中的那些序列进行解释</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ echo -e <span class="string">&quot;这是echo&quot;</span></span><br><span class="line">这是echo</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ echo -e <span class="string">&quot;这是echo&quot;</span> &gt;test.txt</span><br></pre></td></tr></table></figure>
<h6 id="help命令">5.2.4 help命令</h6>
<p>help命令用于显示<code>shell</code>内部命令的帮助信息。<code>help</code>命令只能显示<code>shell</code>内部的命令帮助信息。而对于外部命令的帮助信息只能使用<code>man</code>或者<code>info</code>或者以外部命令的<code>--help</code>选项查看。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ help cd</span><br><span class="line">cd: cd [-L|[-P [-e]] [-@]] [dir]</span><br><span class="line">    Change the shell working directory.</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<h6 id="history命令">5.2.5 history命令</h6>
<p><code>Bash</code>有完善的历史命令，这对于简化管理操作、排查系统错误都有重要的作用，而且使用简单方便，建议大家多使用历史命令。系统保存的历史命令可以使用<code>history</code>命令查询。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history [选项] [历史命令保存文件]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>c</code></td>
<td>清空历史命令</td>
</tr>
<tr class="even">
<td><code>w</code></td>
<td>把缓存中的历史命令写入历史命令保存文件中。如果不手工指定历史命令保存文件，则放入默认历史命令保存文件<code>~/.bash_history</code>中</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ history</span><br><span class="line">    <span class="number">1</span>  ping baidu.com</span><br><span class="line">    <span class="number">2</span>  ifconfig</span><br><span class="line">    <span class="number">3</span>  sudo apt install net-tools</span><br><span class="line">    <span class="number">4</span>  ifconfig </span><br><span class="line">    <span class="number">5</span>  ping baidu.com</span><br><span class="line">    <span class="number">6</span>  sudu apt update</span><br><span class="line">    <span class="number">7</span>  sudo apt update</span><br><span class="line">    <span class="number">8</span>  ifconfig</span><br><span class="line">    <span class="number">9</span>  ssh</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h6 id="kill命令">5.2.6 kill命令</h6>
<p><code>kill</code>命令用于删除执行中的程序或工作。<code>kill</code>可将指定的信息送至程序。预设的信息为<code>SIGTERM(15)</code>，可将指定程序终止。若仍无法终止该程序，可使用<code>SIGKILL(9)</code>信息尝试强制删除程序。程序或工作的编号可利用 <code>ps</code>指令或<code>jobs</code>指令查看。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [信号] PID</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>信号编号</th>
<th>信号名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><code>EXIT</code></td>
<td>程序退出时收到该信息。</td>
</tr>
<tr class="even">
<td>1</td>
<td><code>HUP</code></td>
<td>挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。</td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>INT</code></td>
<td>表示结束进程，但并不是强制性的，常用的<code>Ctrl+C</code>组合键发出就是一个 <code>kill -2</code> 的信号。</td>
</tr>
<tr class="even">
<td>3</td>
<td><code>QUIT</code></td>
<td>退出。</td>
</tr>
<tr class="odd">
<td>9</td>
<td><code>KILL</code></td>
<td>杀死进程，即强制结束进程。</td>
</tr>
<tr class="even">
<td>11</td>
<td><code>SEGV</code></td>
<td>段错误。</td>
</tr>
<tr class="odd">
<td>15</td>
<td><code>TERM</code></td>
<td>正常结束进程，是<code>kill</code>命令的默认信号。</td>
</tr>
</tbody>
</table>
<h6 id="pwd命令">5.2.7 pwd命令</h6>
<p>命令用于显示工作目录。执行<code>pwd</code>指令可立刻得知您目前所在的工作目录的绝对路径名称。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ pwd</span><br><span class="line">/home/trluper/Documents</span><br></pre></td></tr></table></figure></p>
<h6 id="ulimit命令">5.2.8 ulimit命令</h6>
<p><code>ulimit</code>用来限制每个用户可使用的资源，如CPU、内存、句柄等。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]	设置limit</span><br><span class="line">ulimit [-SHabcdefiklmnpqrstuvxPT]			查询</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>S</code></td>
<td>表示软限制,超出设定的值会告警</td>
</tr>
<tr class="even">
<td><code>H</code></td>
<td>表示硬限制，超出设定的值会报错</td>
</tr>
<tr class="odd">
<td><code>a</code></td>
<td>列出系统所有资源限制的值</td>
</tr>
<tr class="even">
<td><code>d</code></td>
<td>每个进程数据段的最大值</td>
</tr>
<tr class="odd">
<td><code>f</code></td>
<td>当前<code>shell</code>可创建的最大文件容量</td>
</tr>
<tr class="even">
<td><code>l</code></td>
<td>可以锁定的物理内存的最大值</td>
</tr>
<tr class="odd">
<td><code>m</code></td>
<td>可以使用的常驻内存的最大值</td>
</tr>
<tr class="even">
<td><code>n</code></td>
<td>每个进程可以同时打开的最大文件句柄数</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>管道的最大值</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>堆栈的最大值</td>
</tr>
<tr class="odd">
<td><code>t</code></td>
<td>每个进程可以使用CPU的最大时间</td>
</tr>
<tr class="even">
<td><code>u</code></td>
<td>每个用户运行的最大进程并发数</td>
</tr>
<tr class="odd">
<td><code>v</code></td>
<td>当前<code>shell</code>可使用的最大虚拟内存</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -n</span><br><span class="line"><span class="number">1024</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -v</span><br><span class="line">unlimited</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -p</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h6 id="source命令和.命令">5.2.9 source命令和.命令</h6>
<p>.sh后缀的文件为Linux的脚本文件，里面可以写入许多执行命令语句。然后我们可以通过使用<code>source</code>命令或者<code>.</code>在当前shell环境来执行该脚本文件中的所有语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source test.sh</span><br><span class="line">或</span><br><span class="line">. test.sh</span><br></pre></td></tr></table></figure>
<p><strong>来看一下四个执行的区别：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.sh文件：</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;step 1 sleeping&quot;</span></span><br><span class="line">sleep <span class="number">200</span></span><br><span class="line">echo <span class="string">&quot;step 2 sleeping&quot;</span></span><br><span class="line">sleep <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行：</span></span><br><span class="line">./test.sh	<span class="comment">//当前shell下正常执行，这种执行方式需要test.sh的执行权限，开启两个进程一个是test.sh,一个是sleep</span></span><br><span class="line">sh test.sh	<span class="comment">//开启新的shell执行，不用执行权限，有读取权限即可，开两个新进程：一个bash，一个sleep</span></span><br><span class="line">. test.sh	<span class="comment">//当前shell下执行，只需要读取权限即可，开启一个新进程sleep</span></span><br><span class="line">source test.sh	<span class="comment">//同第三个一样</span></span><br></pre></td></tr></table></figure></p>
<h6 id="umask命令">5.3.10 umask命令</h6>
<p><code>umask</code>命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由umask设置的掩码决定。用户每次注册进入系统时，<code>umask</code>命令都被执行， 并自动设置掩码<code>mode</code>来限制新文件的权限。用户可以通过再次执行<code>umask</code>命令来改变默认值，新的权限将会把旧的覆盖掉。<strong>注意umask命令是指定哪些权限将在新文件的默认权限中被删除</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> umask [-p] [-S] [mode]</span><br><span class="line"> -p        以八进制数字表示掩码</span><br><span class="line"> -S        以符号格式表示掩码</span><br><span class="line"></span><br><span class="line">ugo：u表示当前用户权限，g为组用户权限，o为其他用户权限</span><br><span class="line">rwx：r为读权限(<span class="number">4</span>)，w为写权限(<span class="number">2</span>)，x为执行权限(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们通过<code>umask</code>查询其默认的删除权限代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前目录的umask掩码</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ umask</span><br><span class="line"><span class="number">0002</span></span><br></pre></td></tr></table></figure>
<p>因为umask的掩码表示被删除的权限，则目录拥有的权限为<code>777-002=765</code>，则以后建立的目录的权限为<code>u=rwx,g=r-x,o=r-x</code>。如果想要改变默认，则设置<code>umask</code>,那么以后新建的目录或文件会按这个来删除权限</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ umask -p <span class="number">555</span>		<span class="comment">//以后新建的目录和文件删除所有用户的读和执行权限</span></span><br></pre></td></tr></table></figure>
<h5 id="外部命令">5.3 外部命令</h5>
<h6 id="sudo命令">5.3.1 sudo命令</h6>
<p><code>sudo</code>命令以系统管理者的身份执行指令，也就是说，经由<code>sudo</code>所执行的外部指令就好像是<code>root</code>亲自执行。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo --help</span><br><span class="line">sudo - execute a command as another user</span><br></pre></td></tr></table></figure></p>
<p><code>usage: sudo -h | -K | -k | -V</code></p>
<ul>
<li><code>V</code> 显示版本编号</li>
<li><code>h</code> 会显示版本编号及指令的使用方式说明</li>
<li><code>l</code> 显示出自己（执行<code>sudo</code>的使用者）的权限</li>
<li><code>k</code> 将会强迫使用者在下一次执行<code>sudo</code>时问密码（不论有没有超过 N 分钟）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo cd /</span><br><span class="line">sudo: cd: command <span class="keyword">not</span> found</span><br><span class="line"><span class="comment">//注意，shell是一个命令解析器，sudo cd是错误的，因为cd是shell内置的，不是系统里面的，</span></span><br><span class="line"><span class="comment">//要进入root用户，先获取root权限 然后进入/root</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo -sH</span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/home/trluper<span class="meta"># cd /root</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~# </span><br></pre></td></tr></table></figure>
<h6 id="su命令">5.3.2 su命令</h6>
<p><code>su</code>（英文全拼：<code>switch user</code>）命令用于变更为其他使用者的身份，除<code>root</code>外，需要键入该使用者的密码。使用权限：所有使用者。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~<span class="meta"># su trluper	<span class="comment">//切回用户身份</span></span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:/root$ sudo su	<span class="comment">//切回root</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> trluper: </span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~# </span><br></pre></td></tr></table></figure></p>
<h6 id="ls命令">5.3.3 ls命令</h6>
<p>是英文单词<code>list</code>的简写，其功能为列出目录的内容，是用户最常用的命令之一，它类似于<code>DOS</code>下的<code>dir</code>命令。</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-a</code></td>
<td>显示所有文件及目录<code>.</code>开头的隐藏文件也会列出)</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>将文件以相反次序显示(原定依英文字母次序)</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>将文件依建立时间之先后次序列出</td>
</tr>
<tr class="odd">
<td><code>-A</code></td>
<td>同 -a ，但不列出 <code>.</code> (目前目录) 及<code>..</code>(父目录)</td>
</tr>
<tr class="even">
<td><code>-F</code></td>
<td>在列出的文件名称后加一符号；例如可执行档则加 <code>*</code>, 目录则加 <code>/</code></td>
</tr>
<tr class="odd">
<td><code>-R</code></td>
<td>若目录下有文件，则以下之文件亦皆依序列出</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ ls -l</span><br><span class="line">total <span class="number">40</span></span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Desktop</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Documents</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Downloads</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Music</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Pictures</span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">13</span> <span class="number">23</span>:<span class="number">46</span> projects</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Public</span><br><span class="line">drwx------ <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> snap</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Templates</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Videos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="man命令">5.3.4 man命令</h6>
<p>man命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息：<code>man [选项] 命令名</code> linux中各个分页的意义：</p>
<table>
<thead>
<tr class="header">
<th>分页</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>Standard commands</code>（标准命令）</td>
</tr>
<tr class="even">
<td><code>2</code></td>
<td><code>System calls</code>系统调用，如<code>open,write</code></td>
</tr>
<tr class="odd">
<td><code>3</code></td>
<td><code>Library functions</code>库函数，如<code>printf,fopen</code></td>
</tr>
<tr class="even">
<td><code>4</code></td>
<td><code>Special devices</code>（设备文件的说明，/dev下各种设备）</td>
</tr>
<tr class="odd">
<td><code>5</code></td>
<td><code>File formats</code>（文件格式，如passwd）</td>
</tr>
<tr class="even">
<td><code>6</code></td>
<td><code>Games and toys</code>（游戏和娱乐）</td>
</tr>
<tr class="odd">
<td><code>7</code></td>
<td><code>Miscellaneous</code>（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</td>
</tr>
<tr class="even">
<td><code>8</code></td>
<td><code>Administrative Commands</code>（管理员命令，如ifconfig）</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ man <span class="number">3</span> open</span><br><span class="line">NAME</span><br><span class="line">       open, openat — open file</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ...)</span></span>;</span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h6 id="makdir命令">5.3.5 makdir命令</h6>
<p>mkdir（英文全拼：<code>make directory</code>）命令用于创建目录。需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。参数<code>-p</code>可递归创建目录。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ cd ./Documents/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ mkdir -p a/b</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ mkdir mydir&#123;<span class="number">1.</span><span class="number">.3</span>&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a  mydir1  mydir2  mydir3</span><br></pre></td></tr></table></figure></p>
<h6 id="rmdir命令">5.3.6 rmdir命令</h6>
<p>rmdir删除指定的目录，一个目录被删除之前必须是空的，'-p'递归删除目录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a  mydir1  mydir2  mydir3</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ rmdir -p a/b/c</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ rmdir mydir&#123;<span class="number">1.</span><span class="number">.3</span>&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br></pre></td></tr></table></figure></p>
<h6 id="touch命令">5.3.7 touch命令</h6>
<p><strong><code>touch</code>命令用于修改文件或者目录的时间属性，包括访问时间和修改时间，若文件不存在，系统会建立一个新的文件。</strong>即：</p>
<ul>
<li>1）如果文件不存在, 创建新文件(只能是普通文件，不能是文件夹)</li>
<li>2）如果文件存在, 更新文件时间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ touch test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ ls</span><br><span class="line">test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ touch test&#123;<span class="number">1.</span><span class="number">.3</span>&#125;.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ ls</span><br><span class="line">test  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure>
<h6 id="cp命令">5.3.8 cp命令</h6>
<p><code>cp</code>命令的功能是将给出的文件或目录复制到另一个文件或目录中，即：</p>
<ul>
<li>可以将一个或多个文件复制到另一个文件夹中</li>
<li>可以将目录即目录下的文件和子目录复制到另一个目录</li>
<li>可以将一个文件复制给另一个文件</li>
</ul>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a</code></td>
<td>此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合</td>
</tr>
<tr class="even">
<td><code>d</code></td>
<td>复制时保留链接。这里所说的链接相当于<code>Windows</code>系统中的快捷方式。</td>
</tr>
<tr class="odd">
<td><code>f</code></td>
<td>覆盖已经存在的目标文件而不给出提示</td>
</tr>
<tr class="even">
<td><code>i</code></td>
<td>与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答<code>y</code>时目标文件将被覆盖</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td>
</tr>
<tr class="even">
<td><code>r</code></td>
<td>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</td>
</tr>
<tr class="odd">
<td><code>l</code></td>
<td>不复制文件，只是生成硬链接文件，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>不复制文件，创建文件的软链接，软链接就相当于windows的快捷键（即路径名）</td>
</tr>
<tr class="odd">
<td><code>u</code></td>
<td>当存在相同的文件时，只有源文件比目标文件新时，才会将源文件复制给目标文件</td>
</tr>
</tbody>
</table>
<p><strong>1.复制一个文件到另外一个文件夹</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 源文件 目标文件（夹）:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp test1.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">test1.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 复制多个文件到另外一个文件夹</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 源文件<span class="number">1</span> 源文件<span class="number">2</span> 目标文件夹 或cp 文件* 目标文件夹</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -u *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 复制目录到另一个目录</strong></p>
<p>只需要记住复制文件夹一定要加<code>-r</code>参数，否则会出现<code>cp: omitting directory</code>错误。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">未加-r出错:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$  cp /home/trluper/Documents/mydir_1 /home/trluper/Documents/mydir_2</span><br><span class="line">cp: -r <span class="keyword">not</span> specified; omitting directory <span class="string">&#x27;/home/trluper/Documents/mydir_1&#x27;</span></span><br><span class="line"></span><br><span class="line">加-r:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -r /home/trluper/Documents/mydir_1 /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">mydir_1  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cd mydir_1/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2/mydir_1$ ls</span><br><span class="line">mysondir  test  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 复制文件到另一个文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制内容到文件</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cp test.cpp test2.cp</span><br></pre></td></tr></table></figure>
<p><strong>5. -u的重要性</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test.cpp</span><br><span class="line"></span><br><span class="line">使用-u，没有更新，因为文件没有更新变动：</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -u *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test.cpp</span><br><span class="line"></span><br><span class="line">未使用-u，直接更新:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test.cpp </span><br></pre></td></tr></table></figure>
<h6 id="rm命令">5.3.9 rm命令</h6>
<p>可通过<code>rm</code>删除文件或目录。使用<code>rm</code>命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在<code>rm</code>后使用<code>-i</code>参数以逐个确认要删除的文件。</p>
<h6 id="mv命令">5.3.10 mv命令</h6>
<p>用户可以使用<code>mv</code>命令来<strong>移动文件或目录</strong>，<strong>也可以给文件或目录重命名</strong>。<code>mv</code>与<code>cp</code>时不同的，<code>mv</code>是移动，<code>cp</code>是复制一个。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [OPTION]... [-T] SOURCE DEST</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--backup</code></td>
<td>若需覆盖文件，则覆盖前先行备份</td>
</tr>
<tr class="even">
<td><code>-b</code></td>
<td>当文件存在时，覆盖前，为其创建一个备份</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录</td>
</tr>
<tr class="even">
<td><code>-i</code></td>
<td>交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入<code>y</code>，表示将覆盖目标文件</td>
</tr>
<tr class="odd">
<td><code>-S</code></td>
<td>为备份文件指定后缀，而不使用默认的后缀</td>
</tr>
<tr class="even">
<td><code>-u</code></td>
<td>当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ mv ../mydir_1 .</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">mydir_1  test  test.cpp</span><br><span class="line"><span class="comment">//对文件重命名</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ ls</span><br><span class="line">alogrithm.h  sum.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ mv alogrithm.h Alogrithm.h</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ ls</span><br><span class="line">Alogrithm.h  sum.cpp</span><br></pre></td></tr></table></figure>
<h6 id="cat命令">5.3.11 cat命令</h6>
<p>cat：将文件内容一次性输出到终端。缺点是终端显示的内容有限，如果文件太长无法全部显示</p>
<ul>
<li><code>-n</code>:对输出的所有行编号</li>
<li><code>-b</code>:输出内容并且给非空行编号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cat -n test.cpp </span><br><span class="line">     <span class="number">1</span>	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">     <span class="number">2</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">     <span class="number">3</span>	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="number">4</span>	    cout&lt;&lt;<span class="string">&quot;这里是test1.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line">     <span class="number">5</span>	&#125;</span><br></pre></td></tr></table></figure>
<h6 id="less命令">5.3.12 less命令</h6>
<p>less命令将文件内容分页显示到终端，可以自由上下浏览</p>
<h6 id="head命令">5.3.13 head命令</h6>
<p>head命令从文件头部开始查看前n行的内容。如果没有指定行数，默认显示前10行内容。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head –n [行数] 文件名</span><br><span class="line">head -n <span class="number">30</span> /etc/passwd</span><br></pre></td></tr></table></figure></p>
<h6 id="find命令">5.3.14 find命令</h6>
<p><code>find</code>命令功能非常强大也很复杂，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure> <code>option</code>多达二十多种，这里列举两个：</p>
<ul>
<li>按文件名查询，使用<code>-name</code>,如<code>find . -name &quot;test.cpp&quot;</code></li>
<li>按文件类型查找，使用<code>-type</code>,如<code>find . -type f</code></li>
</ul>
<p>举例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将当前目录及其子目录下所有最近 20 天内更新过的文件列出</span></span><br><span class="line">find . -ctime  <span class="number">20</span></span><br><span class="line"><span class="comment">//查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：</span></span><br><span class="line">find /var/log -type f -mtime +<span class="number">7</span> -ok rm &#123;&#125; \;</span><br><span class="line"><span class="comment">//找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</span></span><br><span class="line">find . -type f -perm <span class="number">644</span> -exec ls -l &#123;&#125; \;</span><br><span class="line"><span class="comment">//查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：</span></span><br><span class="line">find / -type f -size <span class="number">0</span> -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>
<h6 id="grep命令">5.3.15 grep命令</h6>
<p>很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用<code>grep</code>命令。<code>grep</code>命令是一个强大的文本搜索工具，它能使用<strong>正则表达式</strong>搜索文本，并把匹配的行打印出来.<strong>其中<code>pattern</code>为模式，它要么是字符串，要么是正则表达式，总而言之是我们检索的指定信息</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] pattern filename</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-i</code></td>
<td>不区分大小写</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>只输出匹配行的计数</td>
</tr>
<tr class="odd">
<td><code>-l</code></td>
<td>查询多文件时只输出包含匹配字符的文件名</td>
</tr>
<tr class="even">
<td><code>-n</code></td>
<td>显示匹配行及行号</td>
</tr>
<tr class="odd">
<td><code>-s</code></td>
<td>不显示不存在或无匹配文本的错误信息</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示不包含匹配文本的所有行，即反向查找</td>
</tr>
<tr class="odd">
<td><code>-o</code></td>
<td>只显示匹配字符串的部分</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>实现多个选项的匹配，逻辑<code>or</code>关系</td>
</tr>
<tr class="odd">
<td><code>-E</code></td>
<td>使用扩展正则表达式，而不是基本正则表达式，在使用<code>-E</code>选项时，相当于使用<code>egrep</code></td>
</tr>
</tbody>
</table>
<p><strong>正则表达式：</strong></p>
<ul>
<li><code>^</code>：此时匹配正则表达以“某字符串”开头的行</li>
<li><code>$</code>：匹配正则表达式的以“某字符串”结尾的行</li>
<li><code>[xyz]</code>：匹配方括号中的任意一个字符</li>
<li><code>[^xyz]</code>：匹配除方括号中字符外的所有字符</li>
<li><code>*</code>：匹配<code>*</code>前面的字符，匹配0个或无数个</li>
<li><code>[ - ]</code>: 范围匹配，如<code>[A-C]</code>，即<code>A、B、C</code>都符合要求</li>
</ul>
<p><strong>1. 查找以指定字字符串开头的行</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in ^[a,q,r,f] hell.txt</span><br><span class="line"><span class="number">2</span>:QQWEWQE</span><br><span class="line"><span class="number">5</span>:FDSST</span><br><span class="line"><span class="number">7</span>:AFASRAY</span><br><span class="line"><span class="number">12</span>:ASDSAEE</span><br><span class="line"><span class="number">13</span>:FAFSDG</span><br><span class="line"><span class="number">17</span>:FBB</span><br><span class="line"><span class="number">24</span>:R</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 查找以指定字结符串尾的行</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in [a,q,r,f]$ hell.txt</span><br><span class="line"><span class="number">1</span>:dasdfDSFSDA</span><br><span class="line"><span class="number">4</span>:KKJHFR</span><br><span class="line"><span class="number">14</span>:DAGSA</span><br><span class="line"><span class="number">24</span>:R</span><br><span class="line"><span class="number">26</span>:CZXCGA</span><br></pre></td></tr></table></figure>
<p><strong>3.在文本中搜素只有一个字符的行，且为字母或数字</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in ^[[:alnum:]]$ hell.txt</span><br><span class="line"><span class="number">20</span>:Z</span><br><span class="line"><span class="number">21</span>:D</span><br><span class="line"><span class="number">22</span>:E</span><br><span class="line"><span class="number">23</span>:W</span><br><span class="line"><span class="number">24</span>:R</span><br><span class="line"><span class="number">25</span>:T</span><br></pre></td></tr></table></figure>
<p><strong>4.匹配<code>*</code>前面的字符，匹配0个或无数个</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in <span class="string">&quot;FDSS&quot;</span>* hell.txt </span><br><span class="line"><span class="number">1</span>:dasdfDSFSDA</span><br><span class="line"><span class="number">5</span>:FDSST</span><br></pre></td></tr></table></figure>
<h6 id="命令">5.3.16 |命令</h6>
<p>管道<code>|</code>一个命令的输出可以通过管道做为另一个命令的输入。即它只能处理经由前面一个指令传出的正确输出信息，对错误信息信息没有直接处理能力。然后，传递给下一个命令，作为标准的输入. 最常用的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|gerp <span class="string">&quot;进程名&quot;</span></span><br><span class="line">ps -aux|grep <span class="string">&quot;进程名&quot;</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -ef|grep bash</span><br><span class="line">trluper     <span class="number">2755</span>    <span class="number">2754</span>  <span class="number">0</span> <span class="number">16</span>:<span class="number">03</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span> -bash</span><br><span class="line">trluper     <span class="number">4549</span>    <span class="number">4548</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">29</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> -bash</span><br><span class="line">trluper     <span class="number">4716</span>    <span class="number">4549</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">49</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> bash</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -aux|grep bash</span><br><span class="line">trluper     <span class="number">2755</span>  <span class="number">0.0</span>  <span class="number">0.2</span>  <span class="number">19972</span>  <span class="number">5956</span> pts/<span class="number">1</span>    Ss+  <span class="number">16</span>:<span class="number">03</span>   <span class="number">0</span>:<span class="number">02</span> -bash</span><br><span class="line">trluper     <span class="number">4549</span>  <span class="number">0.0</span>  <span class="number">0.2</span>  <span class="number">19864</span>  <span class="number">5956</span> pts/<span class="number">0</span>    Ss   <span class="number">20</span>:<span class="number">29</span>   <span class="number">0</span>:<span class="number">00</span> -bash</span><br><span class="line">trluper     <span class="number">4718</span>  <span class="number">0.0</span>  <span class="number">0.1</span>  <span class="number">17864</span>  <span class="number">2584</span> pts/<span class="number">0</span>    S+   <span class="number">20</span>:<span class="number">49</span>   <span class="number">0</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> bas</span><br></pre></td></tr></table></figure></p>
<h6 id="ps命令">5.3.17 ps命令</h6>
<p><code>ps</code>（英文全拼：<code>process status</code>）命令用于显示当前进程的状态，类似于<code>windows</code>的任务管理器 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [options]</span><br></pre></td></tr></table></figure> <code>ps</code>的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a</code></td>
<td>显示现行终端机下的所有程序，包括其他用户的程序</td>
</tr>
<tr class="even">
<td><code>-a</code></td>
<td>显示所有终端机下执行的程序，除了阶段作业领导者之外</td>
</tr>
<tr class="odd">
<td><code>-A</code></td>
<td>显示所有程序</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>此选项的效果和指定”A”选项相同</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>显示UID,PPIP,C与STIME栏位</td>
</tr>
<tr class="even">
<td><code>-u</code></td>
<td>此选项的效果和指定”-U”选项相同</td>
</tr>
<tr class="odd">
<td><code>u</code></td>
<td>以用户为主的格式来显示程序状况</td>
</tr>
<tr class="even">
<td><code>-U</code></td>
<td>列出属于该用户的程序的状况，也可使用用户名称来指定</td>
</tr>
<tr class="odd">
<td><code>U</code></td>
<td>列出属于该用户的程序的状况</td>
</tr>
<tr class="even">
<td><code>x</code></td>
<td>显示所有程序，不以终端机来区分</td>
</tr>
</tbody>
</table>
<p><strong>1. <code>-aux</code>输出格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           <span class="number">1</span>  <span class="number">0.0</span>  <span class="number">0.4</span> <span class="number">166516</span> <span class="number">11808</span> ?        Ss   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">06</span> /sbin/init <span class="keyword">auto</span> noprom</span><br><span class="line">root           <span class="number">2</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [kthreadd]</span><br><span class="line">root           <span class="number">3</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [rcu_gp]</span><br><span class="line">root           <span class="number">4</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [rcu_par_gp]</span><br><span class="line">root           <span class="number">5</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [netns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>USER</code>: 行程拥有者</li>
<li><code>PID: pid</code></li>
<li><code>%CPU</code>: 占用的 <code>CPU</code> 使用率</li>
<li><code>%MEM</code>: 占用的记忆体使用率</li>
<li><code>VSZ</code>: 占用的虚拟记忆体大小</li>
<li><code>RSS</code>: 占用的记忆体大小</li>
<li><code>TTY</code>: 终端的次要装置号码 (minor device number of tty)</li>
<li><code>STAT:</code> 该行程的状态:</li>
<li><code>D:</code> 无法中断的休眠状态 (通常 IO 的进程)</li>
<li><code>R:</code> 正在执行中</li>
<li><code>S:</code> 睡眠状态，可被唤醒</li>
<li><code>T:</code> 暂停执行</li>
<li><code>Z:</code> 僵尸进程</li>
<li><code>W:</code> 没有足够的记忆体分页可分配</li>
<li><code>s：</code>进程是会话首进程</li>
<li><code>&lt;:</code> 高优先序的行程</li>
<li><code>N:</code> 低优先序的行程</li>
<li><code>X：</code>死掉的进程</li>
<li><code>START:</code> 行程开始时间</li>
<li><code>TIME:</code> 执行的时间</li>
<li><code>COMMAND：</code>所执行的指令</li>
</ul>
<p><strong>2. <code>-ef</code>输出格式</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -ef</span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           <span class="number">1</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">06</span> /sbin/init <span class="keyword">auto</span> noprompt splash</span><br><span class="line">root           <span class="number">2</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [kthreadd]</span><br><span class="line">root           <span class="number">3</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [rcu_gp]</span><br><span class="line">root           <span class="number">4</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [rcu_par_gp]</span><br><span class="line">root           <span class="number">5</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [netns]</span><br></pre></td></tr></table></figure></p>
<h6 id="tar命令">5.3.18 tar命令</h6>
<p><code>tar</code>是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解压以恢复数据。<code>tar</code>这个命令并没有压缩的功能，它只是一个打包的命令，<strong>但是在<code>tar</code>命令中增加一个选项<code>-z</code>可以调用<code>gzip</code>实现了一个压缩的功能，实行一个先打包后压缩的过程</strong>。当然你可以调用其他的压缩命令来压缩。<code>tar</code>要指定扩展名 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只打包</span></span><br><span class="line">tar -cvf test.tar ./</span><br><span class="line"><span class="comment">//压缩当前文件内的所有内容打成和压缩成test.tar.gz包</span></span><br><span class="line">tar -zcvf test.tar.gz ./</span><br><span class="line"><span class="comment">//解压缩和解包</span></span><br><span class="line">tar -zxvf test.tar.gz</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>创建一个新归档</td>
</tr>
<tr class="even">
<td><code>-x</code></td>
<td>从归档中解出文件</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>使用归档文件，一定为最后一个参数</td>
</tr>
<tr class="even">
<td><code>-z</code></td>
<td>通过 gzip 过滤归档</td>
</tr>
<tr class="odd">
<td><code>-t</code></td>
<td>查看内容</td>
</tr>
<tr class="even">
<td><code>-r</code></td>
<td>向压缩归档文件末尾追加文件</td>
</tr>
<tr class="odd">
<td><code>-u</code></td>
<td>更新原压缩包中的文件</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示所有过程</td>
</tr>
</tbody>
</table>
<p><strong>-f 是必须的，切记，这个参数是最后一个参数，后面只能接档案名。</strong></p>
<p><strong><em>linux中的压缩后缀：</em></strong></p>
<ul>
<li><code>*.gz</code>：由<code>gzip</code>压缩，参数为<code>-z</code></li>
<li><code>*.bz2</code>:由<code>bzip2</code>压缩，参数为<code>-j</code></li>
<li><code>*.Z</code>:由<code>compress</code>压缩，参数为<code>-Z</code></li>
<li><code>*.rar:</code>由<code>rar</code>压缩，linux需下载<code>rar</code></li>
<li><code>*.zip</code>：由<code>zip</code>压缩，linux需下载<code>zip</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -zcvf mytar.tar.gz ./</span><br><span class="line">./</span><br><span class="line">./mymdir_2</span><br><span class="line">./mytar.tar.gz</span><br><span class="line">./mydir_2/</span><br><span class="line">./mydir_2/test.cpp</span><br><span class="line">./mydir_2/hell.txt</span><br><span class="line">./mydir_2/mydir_1/</span><br><span class="line">./mydir_2/mydir_1/test.cpp</span><br><span class="line">./mydir_2/mydir_1/test1.cpp</span><br><span class="line">./mydir_2/mydir_1/sondir/</span><br><span class="line">./mydir_2/mydir_1/mysondir/</span><br><span class="line">./mydir_2/mydir_1/test3.cpp</span><br><span class="line">./mydir_2/mydir_1/test</span><br><span class="line">./mydir_2/mydir_1/test2.cpp</span><br><span class="line">./mydir_2/test</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar.tar.gz</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -tvf mytar.tar.gz </span><br><span class="line">drwxr-xr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">31</span> ./</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">12</span> ./mymdir_2</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">31</span> ./mytar.tar.gz</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">39</span> ./mydir_2/</span><br><span class="line">-rw-rw-r-- trluper/trluper  <span class="number">93</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/test.cpp</span><br><span class="line">-rw-rw-r-- trluper/trluper <span class="number">161</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">39</span> ./mydir_2/hell.txt</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">03</span> ./mydir_2/mydir_1/</span><br><span class="line">hrw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/mydir_1/test.cpp link to ./mydir_2/test.cpp</span><br><span class="line">-rw-rw-r-- trluper/trluper  <span class="number">93</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/mydir_1/test1.cpp</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">03</span> ./mydir_2/mydir_1/sondir/</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">49</span> ./mydir_2/mydir_1/mysondir/</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">04</span> ./mydir_2/mydir_1/test3.cpp</span><br><span class="line">-rwxrwxr-x trluper/trluper <span class="number">23528</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">01</span> ./mydir_2/mydir_1/test</span><br><span class="line">-rw-rw-r-- trluper/trluper     <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">04</span> ./mydir_2/mydir_1/test2.cpp</span><br><span class="line">hrwxrwxr-x trluper/trluper     <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">01</span> ./mydir_2/test link to ./mydir_2/mydir_1/test</span><br></pre></td></tr></table></figure>
<h6 id="gzip命令">5.3.19 gzip命令</h6>
<p>其实上面的<code>tar</code>加<code>-z</code>参数就已经完成了<code>gzip</code>命令的工作了。<code>tar</code>与<code>gzip</code>命令结合使用实现文件打包、压缩。<code>gzip</code>要指定扩展名</p>
<ul>
<li><code>-d</code>:解压</li>
<li><code>-r</code>:压缩所有子目录</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -cvf mytar1.tar mydir_2</span><br><span class="line">mydir_2/</span><br><span class="line">mydir_2/test.cpp</span><br><span class="line">mydir_2/hell.txt</span><br><span class="line">mydir_2/mydir_1/</span><br><span class="line">mydir_2/mydir_1/test.cpp</span><br><span class="line">mydir_2/mydir_1/test1.cpp</span><br><span class="line">mydir_2/mydir_1/sondir/</span><br><span class="line">mydir_2/mydir_1/mysondir/</span><br><span class="line">mydir_2/mydir_1/test3.cpp</span><br><span class="line">mydir_2/mydir_1/test</span><br><span class="line">mydir_2/mydir_1/test2.cpp</span><br><span class="line">mydir_2/test</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar  mytar.tar.gz</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ gzip -r mytar1.tar</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar.gz  mytar.tar.gz</span><br></pre></td></tr></table></figure>
<h6 id="zip和unzip命令">5.3.20 zip和unzip命令</h6>
<p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">压缩文件：zip -r 目标文件(没有扩展名) 源文件</span><br><span class="line">解压文件：unzip -d 解压后目录文件 压缩文件</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ zip -r myzip mydir_2</span><br><span class="line">  adding: mydir_2/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/test.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/hell.<span class="built_in">txt</span> (deflated <span class="number">20</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test1.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/sondir/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/mysondir/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test3.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/<span class="built_in">test</span> (deflated <span class="number">79</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test2.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/<span class="built_in">test</span> (deflated <span class="number">79</span>%)</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar.gz  mytar.tar.gz  myzip.zip</span><br></pre></td></tr></table></figure></p>
<h6 id="chmod命令">5.3.21 chmod命令</h6>
<p><code>chmod</code>（英文全拼：change mode）命令是控制用户对文件的权限的命令。Linux/Unix 的文件调用权限分为三级 : 文件所有者<code>Owner</code>、用户组<code>Group</code>、其它用户<code>ther Users</code>。<strong>在内建命令中我们通过设置<code>umask</code>命令来指定新建的文件的权限，但是对于已经存在的文件的权限我们要怎么去修改呢，只能使用<code>chmod</code>命令来修改</strong> <code>chmod</code> 修改文件权限有两种使用格式<strong>字母法与数字法</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字母</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ chmod o+w mydir_2/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxrwx <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ chmod <span class="number">775</span> mydir_2/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="命令-1">5.3.22 &gt;命令</h6>
<p><code>&gt;</code>命令是重定向命令。我们在bash上运行命令，其默认输出为当前的bash终端。当我们想要看查询的东西时（如ls命令），把原来输出到终端的，可以重定向到一个文件。命令后接 <code>&gt;文件名</code>，<code>&gt;</code>会覆盖，<code>&gt;&gt;</code>不覆盖原来内容 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l &gt;text.txt</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  text.txt</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ cat text.txt </span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">17</span> <span class="number">11</span>:<span class="number">04</span> text.txt</span><br></pre></td></tr></table></figure></p>
<h6 id="ln命令">5.3.23 ln命令</h6>
<p><code>ln</code>命令是linux系统中一个非常重要命令，英文全称是“link”，即链接的意思，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 一种是<code>hard link</code>，又称为硬链接；另一种是<code>symbolic link</code>，又称为符号链接。<strong>通俗一点理解，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间。符号链接可以理解为类似windows一样的快捷方式</strong>。 符号链接 ：</p>
<ul>
<li>1.符号链接以路径的形式存在，类似于Windows操作系统中的快捷方式。</li>
<li>2.符号链接可以跨文件系统 ，硬链接不可以。</li>
<li>3.符号链接可以对一个不存在的文件名进行链接，硬链接不可以。</li>
<li>4.符号链接可以对目录进行链接，硬链接不可以。</li>
</ul>
<p><strong>硬链接：</strong></p>
<ul>
<li>1.硬链接以文件副本的形式存在，但不占用实际空间。</li>
<li>2.硬链接不允许给目录创建硬链接。</li>
<li>3.硬链接只有在同一个文件系统中才能创建。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [参数] [源文件或目录] [目标文件或目录]</span><br></pre></td></tr></table></figure>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>为每个已存在的目标文件创建备份文件</td>
</tr>
<tr class="even">
<td><code>-d</code></td>
<td>此选项允许“root”用户建立目录的硬链接</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>强制创建链接，即使目标文件已经存在</td>
</tr>
<tr class="even">
<td><code>-n</code></td>
<td>把指向目录的符号链接视为一个普通文件</td>
</tr>
<tr class="odd">
<td><code>-i</code></td>
<td>交互模式，若目标文件已经存在，则提示用户确认进行覆盖</td>
</tr>
<tr class="even">
<td><code>-s</code></td>
<td>对源文件建立符号链接，而非硬链接</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>详细信息模式，输出指令的详细执行过程</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//软连接</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ln -s /home/trluper/Documents/mydir_2 ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls</span><br><span class="line">ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cd ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file/ln_file1$ ls</span><br><span class="line">hell.txt  mydir_1  test  test.cpp</span><br><span class="line"><span class="comment">//软连接就是路径</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> trluper trluper <span class="number">31</span>  <span class="number">7</span>月 <span class="number">17</span> <span class="number">11</span>:<span class="number">15</span> ln_file1 -&gt; /home/trluper/Documents/mydir_2</span><br><span class="line"><span class="comment">//硬链接</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ln /home/trluper/Documents/mydir_2/test.cpp lntest</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls</span><br><span class="line">ln_file1  lntest</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cat lntest </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;这里时test1.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="file命令">5.3.24 file命令</h6>
<p>file命令用于辨识文件类型。通过<code>file</code>指令，我们得以辨识该文件的类型。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>列出辨识结果时，不显示文件名称。</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>详细显示指令执行过程，便于排错或分析程序执行的情形。</td>
</tr>
<tr class="odd">
<td><code>-f&lt;名称文件&gt;</code></td>
<td>指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</td>
</tr>
<tr class="even">
<td><code>-L</code></td>
<td>直接显示符号连接所指向的文件的类别。</td>
</tr>
<tr class="odd">
<td><code>-m&lt;魔法数字文件&gt;</code></td>
<td>　指定魔法数字文件。</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示版本信息。</td>
</tr>
<tr class="odd">
<td><code>-z</code></td>
<td>尝试去解读压缩文件的内容。</td>
</tr>
<tr class="even">
<td><code>[文件或目录...]</code></td>
<td>要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ file lntest1 </span><br><span class="line">lntest1: C++ source, Unicode text, UTF<span class="number">-8</span> text</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ file ln_file1</span><br><span class="line">ln_file1: symbolic link to /home/trluper/Documents/mydir_2</span><br></pre></td></tr></table></figure>
<h6 id="chgrp命令">5.3.25 chgrp命令</h6>
<p><strong><code>chgrp</code>命令用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组</strong>。其中，组名可以是用户组的<code>id</code>，也可以是用户组的组名。文件名可以是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户(root)，则不能改变该文件的组。<strong>同时必须在<code>/etc/group</code>有该组名。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项] 组名 文件...</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>效果类似<code>-v</code>参数，但仅会显示更改的部分</td>
</tr>
<tr class="even">
<td><code>-f</code></td>
<td>不显示错误信息</td>
</tr>
<tr class="odd">
<td><code>-h</code></td>
<td>只对符号连接的文件作修改，而不是该其他任何相关文件</td>
</tr>
<tr class="even">
<td><code>-R</code></td>
<td>递归处理，将指令目录下的所有文件及子目录一并处理</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>显示指令执行过程；</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cat /etc/group</span><br><span class="line">root:x:<span class="number">0</span>:</span><br><span class="line">daemon:x:<span class="number">1</span>:</span><br><span class="line">bin:x:<span class="number">2</span>:</span><br><span class="line">sys:x:<span class="number">3</span>:</span><br><span class="line">adm:x:<span class="number">4</span>:syslog,trluper</span><br><span class="line">tty:x:<span class="number">5</span>:</span><br><span class="line">disk:x:<span class="number">6</span>:</span><br><span class="line">lp:x:<span class="number">7</span>:</span><br><span class="line">mail:x:<span class="number">8</span>:</span><br><span class="line">news:x:<span class="number">9</span>:</span><br><span class="line">uucp:x:<span class="number">10</span>:</span><br><span class="line">man:x:<span class="number">12</span>:</span><br><span class="line">...</span><br><span class="line"><span class="comment">//将rumenz目录由root组改为www群组</span></span><br><span class="line">chgrp -R www rumenz</span><br></pre></td></tr></table></figure>
<h6 id="top命令">5.3.26 top命令</h6>
<p><code>top</code>命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [参数]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>批处理</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>显示完整的治命令</td>
</tr>
<tr class="odd">
<td><code>-I</code></td>
<td>忽略失效过程</td>
</tr>
<tr class="even">
<td><code>-s</code></td>
<td>保密模式</td>
</tr>
<tr class="odd">
<td><code>-S</code></td>
<td>累积模式</td>
</tr>
<tr class="even">
<td><code>-i&lt;时间&gt;</code></td>
<td>设置间隔时间</td>
</tr>
<tr class="odd">
<td><code>-u&lt;用户名&gt;</code></td>
<td>指定用户名</td>
</tr>
<tr class="even">
<td><code>-p&lt;进程号&gt;</code></td>
<td>指定进程</td>
</tr>
<tr class="odd">
<td><code>-n&lt;次数&gt;</code></td>
<td>循环显示的次数</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ top -p2567</span><br><span class="line">top - <span class="number">12</span>:<span class="number">55</span>:<span class="number">36</span> up  <span class="number">2</span>:<span class="number">23</span>,  <span class="number">2</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line">Tasks:   <span class="number">0</span> total,   <span class="number">0</span> running,   <span class="number">0</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%<span class="built_in">Cpu</span>(s):  <span class="number">0.0</span> us,  <span class="number">0.0</span> sy,  <span class="number">0.0</span> ni, <span class="number">99.9</span> id,  <span class="number">0.1</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">MiB Mem :   <span class="number">2408.3</span> total,    <span class="number">493.1</span> free,    <span class="number">655.0</span> used,   <span class="number">1260.2</span> buff/cache</span><br><span class="line">MiB Swap:   <span class="number">2048.0</span> total,   <span class="number">2048.0</span> free,      <span class="number">0.0</span> used.   <span class="number">1570.8</span> avail Mem </span><br></pre></td></tr></table></figure>
<h6 id="ar命令">5.3.27 ar命令</h6>
<p><code>ar</code>命令用于<strong>建立或修改备存文件，或是从备存文件中抽取文件。可集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar [参数]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-d</code></td>
<td>删除备存文件中的成员文件</td>
</tr>
<tr class="even">
<td><code>-m</code></td>
<td>变更成员文件在备存文件中的次序</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td>显示备存文件中的成员文件内容</td>
</tr>
<tr class="even">
<td><code>-q</code></td>
<td>将文件附加在备存文件末端</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>将文件插入备存文件中</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>显示备存文件中所包含的文件</td>
</tr>
<tr class="odd">
<td><code>-x</code></td>
<td>自备存文件中取出成员文件</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>创建</td>
</tr>
<tr class="odd">
<td><code>-s</code></td>
<td>建立索引</td>
</tr>
</tbody>
</table>
<h6 id="nm命令">5.3.28 nm命令</h6>
<p><code>nm</code>是<code>names</code>的缩写，<strong><code>nm</code>命令主要是用来列出某些文件中的符号（说白了就是一些函数和全局变量等）</strong>。 一般来说，搞linux开发的人，才会用到<code>nm</code>命令，非开发的人，应该用不到. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm [参数]</span><br></pre></td></tr></table></figure></p>
<h4 id="vim编辑器">6. vim编辑器</h4>
<p><code>vi (Visual interface)</code>编辑器是<code>Linux</code>系统中最常用的文本编辑器，<code>vi</code>工作在字符模式下，不需要图形界面，非常适合远程及嵌入式工作，是效率很高的文本编辑器。<code>vim</code>是<code>vi</code>的升级版，它不仅兼容<code>vi</code>的所有指令，而且还有一些新的特性，例如<code>vim</code>可以撤消无限次、支持关键词自动完成、可以用不同的颜色来高亮你的代码。<code>vim</code>普遍被推崇为类<code>vi</code>编辑器中最好的一个。</p>
<h5 id="vim的三种模式">6.1 vim的三种模式</h5>
<p>vi有三种基本工作模式: <strong>命令模式、文本输入模式(编辑模式)、末行模式</strong></p>
<ul>
<li><p><strong>命令模式：</strong> <strong>任何时候,不管用户处于何种模式,只要按一下<code>ESC</code>键,即可使<code>vi</code>进入命令模式</strong>。我们在<code>shell</code>环境(提示符为<code>$</code>)下输入启动<code>vim</code>命令，进入编辑器时，也是处于该模式下。在命令模式下，用户可以输入各种合法的<code>vi</code>命令，用于管理自己的文档。<strong>此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的<code>vi</code>命令，则<code>vi</code>在接受用户命令之后完成相应的动作</strong>。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是<code>vi</code>的合法命令，<code>vi</code>会响铃报警。</p></li>
<li><p>文本输入模式： 在命令模式下输入插入命令<code>i（I）、附加命令a（A） 、打开命令o（O）、替换命s（S）</code>都可以进入文本输入模式，此时vi窗口的最后一行会显示“插入”,可进行文本编辑.</p></li>
<li><p>末行模式： 末行模式下，用户可以对文件进行一些附加处理。尽管命令模式下的命令可以完成很多功能，但要执行一些如字符串查找、替换、显示行号等操作还是必须要进入末行模式的。<strong>在命令模式下，输入冒号<code>:</code>即可进入末行模式。此时vi窗口的状态行会显示出冒号，等待用户输入命令。用户输入完成后，按回车执行，之后<code>vi</code>编辑器又自动返回到命令模式下</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vi-vim.gif"></p></li>
</ul>
<h5 id="命令模式下的命令操作">6.2 命令模式下的命令操作</h5>
<h6 id="切换到编辑模式">6.2.1 切换到编辑模式</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vimbianji.png"></p>
<h6 id="光标移动">6.2.2 光标移动</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mousemove.png"></p>
<h6 id="删除">6.2.3 删除</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/delete.png"> <strong>常用：<code>D</code>、<code>dG</code>、<code>nx</code>(n为数字)、<code>ndd</code></strong></p>
<h6 id="查找">6.2.4 查找</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/find.png"></p>
<h6 id="可视模式">6.2.5 可视模式</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/copydelete.png"></p>
<h6 id="粘贴和复制">6.2.6 粘贴和复制</h6>
<ul>
<li><code>p</code>:粘贴在光标后面</li>
<li><code>P</code>:粘贴在光标前面</li>
<li><code>y</code>:拷贝行</li>
<li><code>Y</code>:拷贝行</li>
</ul>
<h5 id="末行模式下的命令操作">6.3 末行模式下的命令操作</h5>
<h6 id="保存退出">6.3.1 保存退出</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/saveexit.png"></p>
<h6 id="替换">6.3.2 替换</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/tihuan.png"> 可以从上图总结：<code>s(</code>代表本行，<code>g</code>为所有(global)都替换，<code>%</code>指本文件所有行，<code>c</code>每次替换都要求确认</p>
<h6 id="分屏">6.3.3 分屏</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fenping.png"></p>
<h6 id="其他用法扩展">6.3.4 其他用法扩展</h6>
<p><img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/others.png"></p>
<h5 id="vim的配置文件所在">6.4 vim的配置文件所在</h5>
<p>局部配置文件（推荐）：<code>~/.vimrc</code> 全局配置文件:<code>/etc/vim/vimrc</code></p>
<h4 id="gcc和gcc编译器">7. GCC和gcc++编译器</h4>
<h5 id="gcc和-gcc是两个不同的东西">7.1 gcc和 GCC是两个不同的东西</h5>
<ul>
<li><code>GCC:GNU Compiler Collection</code>(GUN 编译器集合)，它可以编译<code>C、C++、JAV、Fortran、Pascal、Object-C、Ada</code>等语言。</li>
<li>因此<code>gcc</code>是<code>GCC</code>中的<code>GUN C Compiler</code>（C 编译器）；<code>g++</code>是<code>GCC</code>中的<code>GUN C++ Compiler</code>（<code>C++</code>编译器）。二者都可以编译<code>c</code>或<code>cpp</code>文件。只不过用<code>gcc</code>编译<code>c++</code>需要手动添加链接库</li>
<li><strong>在编译阶段，<code>g++</code>会调用<code>gcc</code>，对于<code>c++</code>代码，两者是等价的，但是因为<code>gcc</code>命令不能自动和<code>C++</code>程序使用的库联接，所以通常使用用<code>g++</code>来编译以求自动完成链接。所以对于<code>C</code>语言程序的编译，我们应该使用<code>gcc</code> 指令，而编译<code>C++</code>程序则推荐使用<code>g++</code>指令</strong></li>
</ul>
<h5 id="gccg的四个步骤">7.2 gcc/g++的四个步骤</h5>
<p><code>gcc、g++</code>编译器从拿到一个c源文件到生成一个可执行程序，中间一共经历了<strong>四个步骤：</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/compile.png"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">第一步: 进行预处理</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -E <span class="number">1</span>hello.c -o <span class="number">1</span>hello.i</span><br><span class="line">第二步: 生成汇编文件</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -S <span class="number">1</span>hello.i -o <span class="number">1</span>hello.s</span><br><span class="line">第三步: 生成目标代码</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -c <span class="number">1</span>hello.s -o <span class="number">1</span>hello.o</span><br><span class="line">第四步: 生成可以执行文件</span><br><span class="line"><span class="comment">//这条指令是完成链接这个过程的，它通过链接器ld将运行程序的目标文件和库文件链接在一起，</span></span><br><span class="line"><span class="comment">//生成最后的可执行文件</span></span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc <span class="number">1</span>hello.o -o <span class="number">1</span>hello</span><br><span class="line">第五步: 执行 </span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc​$ ./<span class="number">1</span>hello</span><br><span class="line">hello itcast</span><br><span class="line"></span><br><span class="line">也可直接将源文件生成一个可以执行文件</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc <span class="number">1</span>hello.c -o <span class="number">1</span>hello</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc​$ ./<span class="number">1</span>hello</span><br><span class="line">hello itcast</span><br></pre></td></tr></table></figure></p>
<p><strong>常用选项</strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/gcc.png"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello  -I /home/hello/include -L /home/hello/lib -lworld</span><br><span class="line">上面这句表示在编译hello.c时：</span><br><span class="line"></span><br><span class="line">-I /home/hello/include表示将/home/hello/include目录作为第一个寻找头文件的目录，</span><br><span class="line">寻找的顺序是：/home/hello/include--&gt;/usr/include--&gt;/usr/local/include </span><br><span class="line"></span><br><span class="line">-L /home/hello/lib表示将/home/hello/lib目录作为第一个寻找库文件的目录，</span><br><span class="line">寻找的顺序是：/home/hello/lib--&gt;/lib--&gt;/usr/lib--&gt;/usr/local/lib</span><br><span class="line"></span><br><span class="line">-lworld表示在上面的lib的路径中寻找libworld.so动态库文件或libworld.a静态库文件</span><br></pre></td></tr></table></figure></p>
<p><strong><em>附加</em></strong>：</p>
<ul>
<li><p><code>-I</code>针对头文件，未指明路径时，使用<code>#include&lt;&gt;</code>,<code>gcc/g++</code>默认目录<code>/usr/include</code>，如果使用<code>#include&lt;my.h&gt;</code>则找不到<code>my.h</code>文件，因此要通过<code>-I dir</code>参数来指定包含的头文件<code>my.h</code>的位置： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gcc hell.c -o hell -I /<span class="built_in">root</span>              (假设文件my.h存放在/root下)</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>-L</code>与<code>-I</code> 功能类似，只不过<code>-L</code>时对库文件使用，能够在指定库文件搜索路径。如果一个程序用到了目录<code>/root/lib</code>下的一个动态库<code>libsunq.so</code>，因为<code>-L dir</code>指定的是路径而没有指定文件，则需要用到 <code>-llibname</code>参数，它可以指定<code>gcc</code>去寻找<code>libsunq.so</code>或者<code>libsunq.a</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gcc hello.c -o hell -L /root/lib -lsunq</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="静态链接和动态链接">7.3 静态链接和动态链接</h5>
<h6 id="静态链接">7.3.1静态链接</h6>
<p><strong>静态链接是指由链接器在链接时将库的内容直接加入到可执行程序中。</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>对运行环境的依赖性较小，具有较好的兼容性</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间</li>
<li>库函数有了更新，必须重新编译应用程序</li>
</ul></li>
</ul>
<h6 id="动态链接">7.3.2 动态链接</h6>
<p><strong>动态链接是指连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>在需要的时候才会调入对应的资源函数</li>
<li>简化程序的升级；有着较小的程序体积</li>
<li>实现进程之间的资源共享（避免重复拷贝）</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>依赖动态库，不能独立运行</li>
<li>动态库依赖版本问题严重</li>
</ul></li>
</ul>
<p>注：前面我们编写的应用程序大量用到了标准库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入<code>-static</code>参数。</p>
<h6 id="静态库的制作">7.3.3 静态库的制作</h6>
<p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。 按照习惯,一般以<code>.a</code>做为文件后缀名。静态库的命名一般分为三个部分：</p>
<ul>
<li>前缀：<code>lib</code></li>
<li>库名称：自己定义即可</li>
<li>后缀：<code>.a</code></li>
</ul>
<p><strong>所以最终的静态库的名字应该为：<code>libxxx.a</code></strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/staticlinked.png" width="600"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：将c源文件生成对应的.o文件</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib$ gcc -c add.c -o add.o</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c sub.c -o sub.o </span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c mul.c -o mul.o </span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c div.c -o div.o</span><br><span class="line">步骤<span class="number">2</span>：使用打包工具ar将准备好的.o文件打包为.a文件 libtest.a</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib$ ar -rcs libAlogrithm.a add.o sub.o mul.o div.o</span><br></pre></td></tr></table></figure> <strong>在使用ar工具是时候需要添加参数：<code>-rcs</code></strong></p>
<ul>
<li><code>r</code>更新</li>
<li><code>c</code>创建</li>
<li><code>s</code>建立索引</li>
</ul>
<h6 id="静态库的使用">7.3.4 静态库的使用</h6>
<p>静态库制作完成之后，<strong>需要将<code>.a</code>文件和头文件一起发布给用户</strong>。假设测试文件为<code>main.c</code>，静态库文件为<code>libAlogrithm.a</code>，头文件为<code>Alogrithm.h</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ cat main.cpp </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Alogrithm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>,b=<span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ g++ -<span class="type">static</span> main.cpp -I ../staticLib/ -L ../staticLib/ -lAlogrithm -o test</span><br></pre></td></tr></table></figure></p>
<h6 id="动图库的制作">7.3.5 动图库的制作</h6>
<p>共享库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题和更新问题。 按照习惯,一般以“.so”做为文件后缀名。共享库的命名一般分为三个部分：</p>
<ul>
<li>前缀：<code>lib</code></li>
<li>库名称：自己定义即可</li>
<li>后缀：<code>.so</code></li>
</ul>
<p><strong>所以最终的动态库的名字应该为：<code>libxxx.so</code></strong> <img src="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/dynamiclib.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">步骤一：生成目标文件，此时要加编译选项：-fPIC（fpic）</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -fPIC -c add.c</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ gcc -fPIC -c sub.c </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -fPIC -c mul.c </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ gcc -fPIC -c div.c</span><br><span class="line">参数：-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</span><br><span class="line">步骤二：生成共享库，此时要加链接器选项: -shared（指定生成动态链接库）</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -shared add.o sub.o mul.o div.o -o libtest.so</span><br><span class="line"></span><br><span class="line">步骤三: 通过nm命令查看对应的函数</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ nm libtest.so | grep add </span><br><span class="line"><span class="number">00000000000006b</span>0 T add </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ nm libtest.so | grep sub </span><br><span class="line"><span class="number">00000000000006</span>c4 T sub</span><br></pre></td></tr></table></figure>
<h6 id="使用动态库">7.3.6 使用动态库</h6>
<p>静态库制作完后，需要在测试文件所在的目录创建<code>libxxx.so</code>的链接接，否则就会出现下面这个错误： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libtiger.so: cannot open shared object file: No such file <span class="keyword">or</span> direct</span><br></pre></td></tr></table></figure> 可以通过<code>ldd</code>命令查看哪些动态链接库没有找到： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ ldd test1</span><br><span class="line">	linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007ffc0d5fe000</span>)</span><br><span class="line">	libAlogrithm.so =&gt; <span class="keyword">not</span> found</span><br><span class="line">	libstdc++.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span> (<span class="number">0x00007fbd2317f000</span>)</span><br><span class="line">	libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007fbd22f57000</span>)</span><br><span class="line">	libm.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libm.so<span class="number">.6</span> (<span class="number">0x00007fbd22e70000</span>)</span><br><span class="line">	/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fbd233c1000</span>)</span><br><span class="line">	libgcc_s.so<span class="number">.1</span> =&gt; /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007fbd22e50000</span>)</span><br></pre></td></tr></table></figure> <strong>这是因为程序运行时没有找到动态链接库造成的。程序编译时链接动态库和运行时使用动态链接库的概念是不同的，在运行时，程序链接的动态链接库需要在系统目录下才行</strong>。方法：</p>
<ul>
<li><strong>方法一是可在系统目录创建软链接，链接文件。</strong>这是因为用·<code>-L</code>指定动态库文件路径只能保证编译通过，是否能执行还是得看<code>/lib/</code>或<code>/usr/lib</code>下面有没有该库文件（只要没有删除，永久有效）</li>
<li>方法二当然你要可以修改<code>LD_LIBRARY_PATH</code>指定的动态库搜索路径(当前shell有效)</li>
<li>方法三是配置文件<code>/etc/ld.so.conf</code>中指定的动态库搜索路径(永久有效)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deng@itcast:~/test/<span class="number">6</span>share_test$ sudo ln -s /home/trluper/Documents/staticLib/libtest.so /lib/share_test/libtest.so</span><br></pre></td></tr></table></figure>
<p>然后同静态链接一样，引用动态库去编译：（要保证能找到头文件，因此使用<code>-I</code>) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -<span class="type">static</span> main.cpp -I ../staticLib/ -lAlogrithm -o test</span><br></pre></td></tr></table></figure></p>
<h5 id="gdb调试">7.4 gdb调试</h5>
<p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具。GDB主要帮忙你完成下面四个方面的功能：</p>
<ul>
<li>启动程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>动态的改变你程序的执行环境。</li>
</ul>
<h6 id="gdb的工作步骤">7.4.1 gdb的工作步骤</h6>
<p><strong>1. 准备工作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用gcc/g++将其编译为可执行文件，同时使用-g表示该程序可调试：</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ g++ -g main.cpp sum.cpp -o main</span><br></pre></td></tr></table></figure>
<p><strong>2. 启动gdb</strong></p>
<p>输入<code>gdb -q + 可执行文件</code>，启动gdb进行调试。<code>-q</code>参数可以屏蔽一些gdb版本等相关信息，使得页面看起来干净些（我用了）。至此gdb启动完毕： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ gdb -q main</span><br><span class="line">Reading symbols from main...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p><strong>3. 查看代码（可选）</strong></p>
<p>输入<code>list（l）</code>即可查看程序源码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line"><span class="number">1</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Alogrithm.h&quot;</span></span></span><br><span class="line"><span class="number">2</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">3</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="number">4</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">5	</span>&#123;</span><br><span class="line"><span class="number">6</span>		<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="number">7</span>		cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line"><span class="number">8</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span>	&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 设置参数（可选）</strong></p>
<p><code>set args</code>可指定运行时参数（如：<code>set args 10 20 30 40 50</code>）。<code>show args</code>命令可以查看设置好的运行参数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args <span class="number">20</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">(gdb) b <span class="number">2</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b5</span>: file main.cpp, line <span class="number">6.</span></span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/trluper/Documents/staticLib/main <span class="number">20</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;20 30 50&quot;</span>.</span><br></pre></td></tr></table></figure></p>
<p><strong>5.设置断点（可选）</strong></p>
<p>输入<code>break（b）+数字</code> 可以对程序进行断点操作（数字就是设置断点的代码行数） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b <span class="number">2</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b5</span>: file main.cpp, line <span class="number">6.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>6. 启动程序</strong></p>
<p>输入<code>run（r)</code>开始运行程序，直到遇到“断点”或者“结束” <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/trluper/Documents/staticLib/main </span><br><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">6</span></span><br><span class="line"><span class="number">6</span>		<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>7.单步执行程序（可选）</strong></p>
<ul>
<li><code>next</code>单步执行程序，但是遇到函数时会直接跳过函数，不进入函数</li>
<li><code>step</code>单步执行程序，但遇到函数会进入函数</li>
<li><code>continue</code>继续执行程序，直到遇到断点或结束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;20 30 50&quot;</span>.</span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">7</span>		cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">(gdb) <span class="function">s</span></span><br><span class="line"><span class="function"><span class="title">sum</span> <span class="params">(a=<span class="number">10</span>, b=<span class="number">20</span>)</span> at sum.cpp:<span class="number">4</span></span></span><br><span class="line"><span class="function"><span class="number">4</span>		return a+b;</span></span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">5</span>	&#125;</span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="built_in">main</span> () at main.cpp:<span class="number">8</span></span><br><span class="line"><span class="number">8</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>8. 查看变量值（可选）</strong></p>
<p><code>print + 变量</code>查看变量值；<code>whatis + 变量</code>查看变量数据类型。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print a</span><br><span class="line">$<span class="number">1</span> = <span class="number">10</span></span><br><span class="line">(gdb) whatis a</span><br><span class="line">type = <span class="type">int</span></span><br></pre></td></tr></table></figure></p>
<p><strong>9. 退出</strong></p>
<p>输入<code>q</code>即可退出gdb <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) q</span><br><span class="line">A debugging session is active.</span><br><span class="line">	Inferior <span class="number">1</span> [process <span class="number">3102</span>] will be killed.</span><br><span class="line">Quit anyway? (y <span class="keyword">or</span> n) y</span><br></pre></td></tr></table></figure></p>
<h6 id="其他命令">7.4.2 其他命令</h6>
<p><strong>1. 断点</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>delete + n</code></td>
<td>删除第<code>n</code>个断点</td>
</tr>
<tr class="even">
<td><code>disable + n</code></td>
<td>暂停第<code>n</code>个断点</td>
</tr>
<tr class="odd">
<td><code>enable + n</code></td>
<td>开启第<code>n</code>个断点</td>
</tr>
<tr class="even">
<td><code>clear + n</code></td>
<td>清除第<code>n</code>行的断点</td>
</tr>
<tr class="odd">
<td><code>info b</code></td>
<td>显示当前程序的断点设置情况</td>
</tr>
<tr class="even">
<td><code>delete breakpoints</code></td>
<td>清除所有断点</td>
</tr>
</tbody>
</table>
<p><strong>2. 运行信息</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>where/bt</code></td>
<td>当前运行的堆栈列表</td>
</tr>
<tr class="even">
<td><code>bt backtrace</code></td>
<td>显示当前调用堆栈</td>
</tr>
<tr class="odd">
<td><code>up/down</code></td>
<td>改变堆栈显示的深度</td>
</tr>
<tr class="even">
<td><code>info program</code></td>
<td>查看程序是否在运行，以及进程号被暂停的原因</td>
</tr>
</tbody>
</table>
<p><strong>3. 运行命令</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>until</code></td>
<td>如果你厌倦了在一个循环内单步跟踪，它可以运行程序直到退出循环体</td>
</tr>
<tr class="even">
<td><code>until + 行号</code></td>
<td>运行至某行</td>
</tr>
<tr class="odd">
<td><code>finish</code></td>
<td>运行程序，直到当前函数返回完成，并且打印函数返回时的堆栈地址和返回值及参数值等信息</td>
</tr>
<tr class="even">
<td><code>call + 行数 + （参数）</code></td>
<td>调用程序中可见的函数，并传递参数</td>
</tr>
</tbody>
</table>
<h4 id="shell脚本">8. shell脚本</h4>
<p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。对于Linux 的 Shell 种类众多，常见的有：</p>
<ul>
<li><code>Bourne Shell（/usr/bin/sh或/bin/sh）</code></li>
<li><code>Bourne Again Shell（/bin/bash）</code></li>
<li><code>C Shell（/usr/bin/csh）</code></li>
<li><code>K Shell（/usr/bin/ksh）</code></li>
<li><code>Shell for Root（/sbin/sh）</code></li>
</ul>
<p>在一般情况下，人们并不区分<code>Bourne Shell</code>和<code>Bourne Again Shell</code>，所以，像<code>#!/bin/sh，</code>它同样也可以改为 <code>#!/bin/bash</code>。<code>#!</code>告诉系统其后路径所指定的程序即是解释此脚本文件的 <code>Shell</code> 程序。</p>
<h5 id="创建一个脚本文件">8.1 创建一个脚本文件</h5>
<p>使用<code>vi/vim</code>命令来创建文件)，新建一个文件<code>test.sh</code>，扩展名为<code>sh</code>（sh代表shell），扩展名并不影响脚本执行，见名知意就好。输入一些代码，第一行一般是这样: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;Hello World !&quot;</span></span><br></pre></td></tr></table></figure> <strong><code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种<code>Shell</code></strong>。echo 命令用于向窗口输出文本。</p>
<h5 id="运行脚本的方法">8.2 运行脚本的方法</h5>
<h6 id="作为可执行程序">8.2.1 作为可执行程序</h6>
<p>将上面的代码保存到<code>test.sh</code>，并<code>cd</code>到相应目录： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ./test.sh  <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">./test.sh  <span class="comment">#执行脚本</span></span><br></pre></td></tr></table></figure> 注意，一定要写成 <code>./test.sh</code>，而不是<code>test.sh</code>，运行其它二进制的程序也一样，直接写<code>test.sh</code>的话，<code>linux</code>系统会去<code>PATH</code>里寻找有没有叫<code>test.sh</code>的，而只有 <code>/bin, /sbin, /usr/bin，/usr/sbin</code>等在<code>PATH</code>里，你的当前目录通常不在<code>PATH</code>里，所以写成<code>test.sh</code>是会找不到命令的，要用 <code>./test.sh</code> 告诉系统说，就在当前目录找。</p>
<h6 id="作为解释器参数">8.2.2 作为解释器参数</h6>
<p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure> 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<h5 id="变量">8.3 变量</h5>
<p>变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： - 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 - 中间不能有空格，可以使用下划线 _。 - 不能使用标点符号。 - 不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<p>定义变量时，变量名不加美元符号<code>$</code>，但PHP语言中变量需要。使用变量名是需要加<code>$</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">&quot;runoob.com&quot;</span></span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br><span class="line">echo <span class="string">&quot;My name is &amp;&#123;your_name&#125;teacher&quot;</span></span><br><span class="line">your_name=<span class="string">&quot;xiaoming&quot;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>变量名外面的<code>&#123;&#125;</code>是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，</li>
<li>一般推荐使用<code>&#123;&#125;</code>,比如上面的第三节，如果不加<code>&#123;&#125;</code>，则会认为your_nameteacher为一个变量名，就出错了。</li>
<li>重新赋值是允许的，仍有不用加<code>$</code>,只有使用的时候加上<code>$</code></li>
</ul>
<h4 id="ssh">9. ssh</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" class="post-title-link" itemprop="url">ubuntu使用手册</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-13 16:44:21" itemprop="dateCreated datePublished" datetime="2022-07-13T16:44:21+08:00">2022-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:50:03" itemprop="dateModified" datetime="2022-10-30T21:50:03+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ubuntu/" itemprop="url" rel="index"><span itemprop="name">ubuntu</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ubuntu常用快捷键">1. Ubuntu常用快捷键</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、打开终端：Ctr+Alt+T</span><br><span class="line"><span class="number">2</span>、关闭终端：Ctrl + Shift + Q</span><br><span class="line"><span class="number">3</span>、复制：Ctrl + Shift + C</span><br><span class="line"><span class="number">4</span>、粘贴：Ctrl + Shift + V</span><br><span class="line"><span class="number">5</span>、跳转回主机操作:ctr+alt</span><br><span class="line"><span class="number">6</span>、跳回虚拟机：Ctr+G</span><br><span class="line"><span class="number">7</span>、新建终端窗口：Ctrl + Shift + N</span><br><span class="line"><span class="number">8</span>、运行命令：Alt + F2</span><br><span class="line"><span class="number">9</span>、全屏切换：F11</span><br></pre></td></tr></table></figure>
<h4 id="apt安装">2. apt安装</h4>
<p>对于Ubuntu安装各种软件包的命令格式使用<code>apt-get</code>或者<code>apt</code>。（centOS使用<code>yum</code>），这是在线安装。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线安装</span></span><br><span class="line">sudo apt-get update		<span class="comment">//更新软件包列表</span></span><br><span class="line">sudo apt-get install	<span class="comment">//安装软件</span></span><br><span class="line">sudo apt-get remove		<span class="comment">//删除软件</span></span><br><span class="line">sudo apt-get clean		<span class="comment">//清理安装包</span></span><br></pre></td></tr></table></figure> <strong><em>附：</em></strong>如果是从Ubuntu官网已经下载好了安装包，相应离线安装的话，因为从Ubuntu的文件为deb格式，所以</p>
<ul>
<li>软件安装<code>sudo dpkg -i xxx.deb</code></li>
<li>软件卸载<code>sudo dpkg -r 软件名</code></li>
</ul>
<h5 id="安装net-tools网络工具">2.1 安装net-tools网络工具</h5>
<p><code>net-tools</code>工具箱包括<code>arp, hostname, ifconfig, netstat, rarp, route, plipconfig, slattach, mii-tool and iptunnel and ipmaddr</code>等命令。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure></p>
<h5 id="安装ssh">2.2 安装ssh</h5>
<p><code>ssh</code>用于远程登录到<code>Linux</code>服务器来管理维护系统。<code>SSH</code>是专为远程登录会话和其他网络服务提供安全性的协议；使用<code>ssh</code>服务（指实现<code>SSH</code>协议的软件）可远程登录到服务器来管理维护系统，防止远程管理过程中的信息泄露问题。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装</span></span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"><span class="comment">//查看状态</span></span><br><span class="line">service ssh status</span><br><span class="line"><span class="comment">//查看端口</span></span><br><span class="line">netstat -anp |grep <span class="number">22</span> netstat -anp |grep sshlsof -i :<span class="number">22</span></span><br></pre></td></tr></table></figure></p>
<h5 id="aptitude">2.3 aptitude</h5>
<p><code>aptitude</code> 命令与 <code>apt-get</code> 命令一样，都是Debian Linux 及其衍生系统中功能极其强大的包管理工具。与<code>apt-get</code>不同的是，<code>aptitude</code>在处理依赖问题上更佳一些。举例来说，<code>aptitude</code> 在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。它通过文本操作菜单和命令两种方式管理软件包。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装</span></span><br><span class="line">sudo apt-get install aptitude</span><br><span class="line"><span class="comment">//命令</span></span><br><span class="line">aptitude upgrade		<span class="comment">//升级系统所有的软件包</span></span><br><span class="line">aptitude dist-upgrade	<span class="comment">//将系统升级到新的发行版</span></span><br><span class="line">aptitude safe-upgrade	<span class="comment">//安全升级系统的软件包</span></span><br><span class="line">aptitude install net-tools	<span class="comment">//安装软件包</span></span><br><span class="line">ptitude purge net-tools	<span class="comment">//彻底删除软件包</span></span><br><span class="line">aptitude search ssh	<span class="comment">//根据关键词搜索软件包</span></span><br><span class="line">aptitude show ssh	<span class="comment">//查看软件包的详细信息</span></span><br><span class="line">aptitude clean		<span class="comment">//删除缓存目录中的软件包安装文件</span></span><br></pre></td></tr></table></figure></p>
<h5 id="安装gccg">2.3 安装gcc/g++</h5>
<p><code>GCC</code>原名为 <code>GNU C</code> 语言编译器，因为它原本只能处理 C语言。GCC 快速演进，变得可处理 <code>C++、Fortran、Pascal、Objective-C、Java</code> 以及 <code>Ada</code> 等他语言。实际使用中：</p>
<ul>
<li>使用 <code>gcc</code> 指令编译 C 代码</li>
<li>使用 <code>g++</code>指令编译 C++ 代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo  apt-get insatll gcc</span><br><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure>
<h5 id="安装vim">2.4 安装vim</h5>
<p><code>vim</code>是从<code>VI</code>发展而来的一个文本编辑器，功能更强大。而<code>vim.tiny</code>是vim的精简版，所以，安装<code>vim</code>势在必行。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure></p>
<h5 id="安装cmake">2.5 安装Cmake</h5>
<p><code>Camke</code>是一个高级编译工具，当你用不同的语言或者编译器开发一个项目，各就各位code完之后要生成最终的输出（<code>dll</code>或执行文件），这时候就尴尬了，你要手动去MingGW或者GCC下配置成千上万的<code>.cpp .h .o .c</code>路劲和地址吗？这时候神器就出现了<code>CMake</code>，主要功能：</p>
<ul>
<li>配置和生成各大平台的工程（vs的vcxproj，Qt的Pro）</li>
<li>生成makefile文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure>
<h5 id="第三方线程库">2.6 第三方线程库</h5>
<p><code>pthread</code>是第三方线程库，安装如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install glibc-doc</span><br><span class="line"> sudo apt-get install manpages-posix manpages-posix-dev</span><br></pre></td></tr></table></figure></p>
<h5 id="mysql安装">2.7 MySQL安装</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server;</span><br></pre></td></tr></table></figure>
<h4 id="虚拟机网络问题">3. 虚拟机网络问题</h4>
<p>有时候我们的虚拟机会出现无法连接上网的情况，解决方法如下：</p>
<ul>
<li>检查宿主主机，能正常联网</li>
<li><p>linux的ifconfig显示，没有固定IP <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        inet6 ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0x10</span>&lt;host&gt;</span><br><span class="line">        loop  txqueuelen <span class="number">1000</span>  (Local Loopback)</span><br><span class="line">        RX packets <span class="number">2588</span>  bytes <span class="number">197004</span> (<span class="number">197.0</span> KB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">2588</span>  bytes <span class="number">197004</span> (<span class="number">197.0</span> KB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>将网络管理的缓存清除后重新开启即可 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo service network-manager stop</span><br><span class="line">sudo rm /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">sudo service network-manager start</span><br><span class="line">或</span><br><span class="line">sudo service NetworkManager stop</span><br><span class="line">sudo rm /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">sudo service NetworkManager start</span><br><span class="line">sudo vim /etc/NetworkManager/NetworkManager.conf #在这个文件中把第四行的<span class="literal">false</span>改成<span class="literal">true</span></span><br><span class="line">sudo service NetworkManager restart</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="wsl的ubuntu安装">4.WSL的ubuntu安装</h4>
<h4 id="wsl下的ubuntu的ssh服务器">5. wsl下的ubuntu的ssh服务器</h4>
<p><strong>如果你想用ssh连接远程window上的wsl，你是无法直接连接Linux的ssh的，必须通过走windows端口映射才行：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove openssh-server <span class="comment">#自带的有问题卸载</span></span><br><span class="line">sudo apt-get install openssh-server <span class="comment">#重新安装</span></span><br><span class="line">sudo vim /etc/ssh/sshd_config <span class="comment">#修改配置文件</span></span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 去掉前面的“#”</span></span><br><span class="line">Port <span class="number">2222</span> <span class="comment"># 端口号 默认22，因为与Window系统自带SSH冲突故改为2222</span></span><br><span class="line">AddressFamily <span class="built_in">any</span></span><br><span class="line">ListenAddress <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">ListenAddress ::</span><br><span class="line">PasswordAuthentication yes <span class="comment"># 是否允许使用密码登录 选“是”</span></span><br><span class="line"><span class="comment"># 其它配置没必要改变</span></span><br></pre></td></tr></table></figure> 生成成功后，我们在重启sshd，这样就可以了。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh --full-restart <span class="comment">#重启SSH服务</span></span><br></pre></td></tr></table></figure> <strong>端口映射：</strong>然后WLS2有一个问题，就是它相当于一个完整的虚拟机，所以IP地址与本机不一样，这就导致我们无法在别的设备上SSH连接</p>
<p>解决办法就是把WSL2虚拟机的IP映射到本机上(假设本机windows的ip为192.168.1.3) <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy <span class="built_in">set</span> v4tov4 listenport=<span class="number">12233</span> listenaddress=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> connectport=<span class="number">2222</span> connectaddress=<span class="number">172.18</span><span class="number">.69</span><span class="number">.154</span></span><br><span class="line"><span class="comment"># listenport win10监听的端口号</span></span><br><span class="line"><span class="comment"># listenaddress win10监听的外网地址，0.0.0.0指所有地址</span></span><br><span class="line"><span class="comment"># connectport 映射的linux的端口 也就是ssh的开启端口</span></span><br><span class="line"><span class="comment"># connectaddress linux的ip</span></span><br><span class="line"><span class="comment"># 可以理解为，所有发往win11:192.168.1.3的12233端口的tcp信息都会转发到172.18.69.154:2222</span></span><br></pre></td></tr></table></figure></p>
<p>测试：你可以在window上运行下面代码验证是否映射成功 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@本机IP -p 映射端口 <span class="comment"># 例如 ssh root@192.168.1.3 -p 12233 </span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用内透软件natapp">6. 使用内透软件natapp</h4>
<p>内网内透通过将我们的本机的ubuntu服务器与natapp的服务器连接，以支持另一台主机通过不同网段也能够通过走natapp的服务器连接该ubuntu服务器。即内网穿透。</p>
<p>在natapp中指定服务器地址即可，详细操作见<a target="_blank" rel="noopener" href="https://natapp.cn/tunnel/edit/16vldzyrj8">natapp官网</a> <img src="/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/natapp.png" width="700"> <strong><em>注：上面的ip地址和端口号中，如果你是连接wsl的那么就是window的ip地址和相应的端口映射号</em></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">STL源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-12 22:15:12" itemprop="dateCreated datePublished" datetime="2022-07-12T22:15:12+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-29 19:18:32" itemprop="dateModified" datetime="2022-10-29T19:18:32+08:00">2022-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STL/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>88k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:20</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="stl概述">1.STL概述</h4>
<h5 id="六大组件">1.1 六大组件</h5>
<ul>
<li>容器：各种数据结构,如<code>vector、list、deque、set、map</code>等,用来存放数据</li>
<li>算法：各种常用的算法（冒泡，排序）,如<code>sort、find、copy、for_each、search、erase</code></li>
<li>迭代器：扮演了容器与算法之间的胶合剂，是所谓的泛型指针</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理。注意一般都伴随着重新分配空间，那么原来的迭代器就会失效</li>
</ul>
<p>六大组件的交互关系是<code>Container</code>通过<code>Allocator</code>获得数据存储空间，<code>Alogrithm</code>通过<code>Iterator</code>存取<code>Container</code>的内容，<code>Functor</code>可以协助<code>Algorithm</code>完成不同的策略变化，<code>Adapter</code>可以修饰或套接<code>Functor</code>。本笔记将会以此对这六大组件进行介绍。</p>
<p>++说在前面：STL的实现版本由HP版本、PJ版本、RW版本、STLport版本和SGISTL版本等五个主要版本++</p>
<h4 id="空间配置器">2. 空间配置器</h4>
<p>在介绍STL的其他组件尤其是<code>container</code>组件之前，空间配置器是必须要先介绍的，因为容器内存空间的开辟需要由<code>allocator</code>去申请。allocator申请的空间是为构造原始的，<code>new</code>申请的空间是已构造的。在<code>gcc</code>中的容器使用了缺省的SGI版本的空间配置器：<code>class Alloc = alloc</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, **<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc**&gt;	<span class="comment">//默认使用了alloc</span></span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="comment">/*...实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="空间配置器的标准接口">2.1 空间配置器的标准接口</h5>
<p>allocator的必要接口（无论是哪个版本的STL）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员变量</span></span><br><span class="line">allocator::value_type;</span><br><span class="line">allocator::pointer;</span><br><span class="line">allocator::const_pointer;</span><br><span class="line">allocator::reference;</span><br><span class="line">allocator::const_reference;</span><br><span class="line">allocator::size_type;</span><br><span class="line">allocator::difference_type;</span><br><span class="line">allocator::rbind;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>();</span><br><span class="line">allocator::<span class="built_in">allocator</span>(<span class="type">const</span> allocator&amp;);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;allocator：：<span class="built_in">allocator</span>(<span class="type">const</span> allocator&lt;U&gt;&amp;);</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">allocator::~<span class="built_in">allocator</span>();</span><br><span class="line"><span class="comment">//返回某个对象的地址，等同于&amp;X</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::address</span><span class="params">(reference x)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//配置空间，n个足以存储U对象</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n,<span class="type">const</span> <span class="type">void</span>*=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//回收配置的空间,p为allocate返回的指针，n为allocate分配是指定的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::deallocate</span><span class="params">(pointer p,size_type n)</span></span>;</span><br><span class="line"><span class="comment">//对分配空间进行构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::construct</span><span class="params">(pointer,<span class="type">const</span> T&amp;x)</span></span>;</span><br><span class="line"><span class="comment">//对构造空间析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::destroy</span><span class="params">(pointer p)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="设计一个简单的空间配置器">2.1.1设计一个简单的空间配置器</h6>
<p>根据上述的接口，我们可以实现一个自己的、功能简单，接口不齐全的<code>allocator</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstddef&gt;</span>	<span class="comment">//ptrdiff_t,size_t类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myallocator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">inline</span> T* _allocate()（<span class="type">ptrdiff_t</span> size,T*)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//使用全局operator new ,相当于malloc</span></span><br><span class="line">		T* tmp=(T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size*<span class="built_in">sizeof</span>(T))));	<span class="comment">//调用全局重载运算符new</span></span><br><span class="line">		<span class="keyword">if</span>(tmp==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cerr&lt;&lt;<span class="string">&quot;out_of_memory&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _deallocate(T*buffer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//相当于free</span></span><br><span class="line">		::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _construct(T* p,<span class="type">const</span> U&amp; value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span>(p) <span class="built_in">U</span>(value);		<span class="comment">//placement new，相当于realloc，并进行构造</span></span><br><span class="line">	&#125;</span><br><span class="line">	/析构</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _destroy(T* ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">allocator</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> T  value_type;</span><br><span class="line">		<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> T* const_pointer;</span><br><span class="line">		<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">		<span class="comment">//内嵌体</span></span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rebind</span>&#123;</span><br><span class="line">			<span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//函数</span></span><br><span class="line">		<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n,<span class="type">const</span> <span class="type">void</span>* hint=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _allocate((difference_type)n,(pointer)hint);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">deallocte</span><span class="params">(pointer p,size_type n)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_deallocate(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_constrcut(p,value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_destroy(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	<span class="comment">//end of namespace myallocator</span></span><br></pre></td></tr></table></figure></p>
<h5 id="sgi空间配置器">2.2 SGI空间配置器</h5>
<p>SGI版本的空间配置器与众不同，其名称是<code>alloc</code>而不是<code>allocator</code>。<code>alloc</code>不接受任何参数，即如果你的程序要采用SGI版本的配置器，则不能使用标准写法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::allocator&lt;<span class="type">int</span>&gt;&gt; iv;</span><br></pre></td></tr></table></figure> 而应当使用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::alloc&gt; iv;</span><br></pre></td></tr></table></figure> 其实这个问题不会给我们带来困扰，在<code>GCC</code>中是使用缺省的空间配置器，我们可以不用显示的去指定，编译器默认采用SGI的这个版本。</p>
<p><strong><em>附</em></strong>：虽然SGI也提供了一个<code>aloocator</code>版本，但是不建议使用，因为效率不佳，因为它只是对<code>::operator new</code>和<code>::operator delete</code>做一个简单包装而已</p>
<h5 id="sgi的alloc">2.3 SGI的alloc</h5>
<p>我们知道<strong><code>new</code>算式包含两个步骤</strong>：一是调用<code>::operator new</code>配置内存；二是调用相应的构造函数构造对象内容。同样<strong><code>delete</code>算式也包含两个步骤</strong>：一是调用对象的析构函数析构；二是调用<code>::operator delete</code>释放内存</p>
<p>为了精密加工和效率的提升，STL的allocator把这两步操作区分开来，<strong>内存配置操作由<code>alloc::allocate()</code>负责，内存释放由<code>alloc::deallocate()</code>负责；而对象的构造和析构分别是由<code>::construct()</code>和<code>::destroy()</code>负责。</strong>STL的标准中规定配置器的定义位于<code>&lt;memory&gt;</code>中，对SGI版本来说<code>&lt;memory&gt;</code>内含有关键的两个文件，这两个文件实行上面的工作划分规则 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_alloc.h&gt;</span>		<span class="comment">//负责内存的配置和释放</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_construct.h&gt;</span>	<span class="comment">//负责构造和析构</span></span></span><br></pre></td></tr></table></figure> 在<code>&lt;stl_alloc.h&gt;</code>中定义了<strong>一、二级配置器</strong>，而在<code>&lt;stl_construct.h&gt;</code>定义了<code>construct()</code>和<code>destroy()</code>函数。</p>
<h5 id="alloc的stl_constuct">2.4 alloc的stl_constuct</h5>
<p>在<code>&lt;stl_construct.h&gt;</code>定义了多个重载的<code>construct()</code>和<code>destroy()</code>函数。这里介绍接受两个迭代器版本的<code>destroy()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator lasu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_destroy(first,last,<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个函数我们可以知道它会析构掉<code>[first,last)</code>范围内对象，<strong>如果是调用一些无关痛痒得析构函数，又万一这个范围很大的话效率会极低。因此<code>_destroy()</code>利用<code>value_type()</code>获得迭代器对象所指代得类型，在<code>_destroy</code>内部利用<code>_type_traits&lt;T&gt;</code>判断该类型得析构是否对内存空间无关痛痒，若是<code>_true_type</code>，则什么也不做就结束，若是<code>_false_type</code>则只能迭代去析构这个范围得对象。</strong></p>
<h5 id="空间配置stl_alloc">2.5 空间配置stl_alloc</h5>
<p>SGI内部是以<code>malloc()</code>和<code>free()</code>完成内存得配置与释放得。考虑到小型区块可能造成内存碎片得问题，SGI设计了双层配置器，<strong>第一级直接使用<code>molloc()</code>和<code>free()</code>,第二级则看情况采用不同策略分配：</strong></p>
<ul>
<li>当配置区块超过<code>128bytes</code>时，视为足够大，直接调用第一级得配置器</li>
<li>当配置区块小于<code>128bytes</code>时，视为小，便采用复杂的<code>memory pool</code>和自由链表管理配置</li>
</ul>
<p><strong>内存池<code>memory pool</code></strong>：内存池是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样，内存池允许在运行期以常数时间规划内存块，并且尽量避免了内存破碎的情况产生，使得内存分配的效率得到提升。</p>
<p><strong><em>注意：是只开放一级配置器还是同时开放二级，由<code>_USE_MALLOC</code>是否被定义而定，当被定义是，只开放第一级配置器，当未背定义时两级都开放。</em></strong></p>
<h6 id="一级配置器">2.5.1 一级配置器</h6>
<p>一级配置器是类名为<strong><code>template&lt;int inst&gt;class _malloc_alloc_template&#123;...&#125;</code></strong>的一个类，在<code>allocate()</code>内直接使用<code>malloc()</code>,在<code>deallocate()</code>直接使用<code>free()</code>。同时<strong>模拟<code>set_new_handler()</code>来处理内存不足的情况</strong>。奉上源码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_malloc_alloc_template</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//以下函数用来处理内存不足的情况</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span>*,<span class="type">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*_malloc_alloc_oom_handler)</span><span class="params">()</span></span>;	<span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//allocate分配</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">		<span class="type">void</span> *result=<span class="built_in">malloc</span>(n);		<span class="comment">//直接使用malloc分配</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==result)</span><br><span class="line">			result=<span class="built_in">oom_malloc</span>(n);	<span class="comment">//不断尝试</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//模拟set_new_hanlder，返回函数指针</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span><span class="params">(* set_malloc_hanlder(<span class="type">void</span>(*f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">void</span> (*old)=_malloc_alloc_oom_handler;</span><br><span class="line">		<span class="comment">//设置</span></span><br><span class="line">		_malloc_alloc_oom_handler=f;</span><br><span class="line">		<span class="keyword">return</span> (old);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数为纯虚函数，需要自己编写处理函数来不断尝试释放内存、申请内存</span></span><br><span class="line"><span class="built_in">void</span> (* _malloc_alloc_template&lt;inst&gt;::_malloc_alloc_oom_handler)()=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//malloc形式的不断尝试</span></span><br><span class="line"><span class="type">void</span> *_malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n)&#123;</span><br><span class="line">	<span class="built_in">void</span> (*my_malloc_hanlder)();	<span class="comment">//函数指针</span></span><br><span class="line">	<span class="type">void</span> *result;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;<span class="comment">//不断尝试释放，配置</span></span><br><span class="line">		my_malloc_hanlder=_malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==my_malloc_handler)</span><br><span class="line">			_ThROW_BAD_ALLOC;</span><br><span class="line">		(*my_malloc_handler)();<span class="comment">//调用释放</span></span><br><span class="line">		<span class="comment">//进行分配</span></span><br><span class="line">		result=<span class="built_in">malloc</span>(n);</span><br><span class="line">		<span class="comment">//分配成功直接返回</span></span><br><span class="line">		<span class="keyword">if</span>(result)</span><br><span class="line">			<span class="keyword">return</span>(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>查看上述的部分源代码可以知道</strong></p>
<ul>
<li>第一级空间分配器以<code>malloc()、free()、realloc()</code>等C函数执行内存配置，而不是采用<code>C++</code>的<code>::operator new</code>，<strong>因此无法使用C++的<code>new hanlder</code>机制，也就不能使用<code>set_new_hanlder()</code>,必须仿真一个类似该功能的<code>set_malloc_handler()</code></strong></li>
<li><code>allocate()</code>分配不成功后会改调用<code>oom_malloc()</code>不断尝试去释放分配，其中的<code>_malloc_alloc_oom_hanlder()</code>函数是要自己去编写指定的。如果你没有传入该函数，源码也未提供，默认为纯虚函数，则进入到<code>oom_hanlder()</code>判断后直接抛异常。</li>
</ul>
<h6 id="附加知识点new-handler机制">2.5.2 附加知识点：new handler机制</h6>
<p><code>new_handler</code>是一个void*类型的函数指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">　<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;	<span class="comment">//函数指针，只是起个名字new_handler=void*</span></span><br><span class="line"> <span class="comment">//new_handler是一个typedef后void*</span></span><br><span class="line">　<span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>new_handler</code>类型内的函数将在默认内存申请函数<code>operator new</code>和<code>operator new[]</code>申请内存失败时被调用;</li>
<li>默认情况下, 当内存不能够分配时, <code>new</code>操作将抛出一个<code>bad_alloc</code>的异常。 你可以改变这个默认操作, 通过<code>set_new_handler()</code>设置<code>new_handler</code>内的函数指针。当然 你可以使用<code>set_new_handler(0)</code>, 获得一个不抛出异常的<code>new</code>.</li>
</ul>
<p><strong>用户定义的my_handler应该可以做以下几件事之一:</strong></p>
<ul>
<li>释放内存, 产生更多可以用的内存</li>
<li>抛出bad_alloc异常(或bad_alloc派生类)</li>
<li>终止程序(比如调用abort或exit)</li>
</ul>
<h6 id="二级配置器">2.5.3 二级配置器</h6>
<p>二级配置器类名为<strong><code>template&lt;bool threads,int ints&gt;class _default_alloc_template&#123;...&#125;</code>：维护16个自由链表，负责16种小型区块内存池的次配置能力，内存池<code>memory pool</code>事先由<code>malloc</code>配置而得</strong>。为了方便管理，SGI的二级配置会主动将小额的内存需求上调至8的倍数，例如我们要求分配30bytes，那么二级配置器就会分配维护多个<code>32bytes</code>的内存块。第二级配置器多了许多机制，以避免太多的小额区块造成内存碎片，从而避免内存浪费和减轻配置负担，第二级配置的做法是：</p>
<ul>
<li>当配置区块超过<code>128bytes</code>时，视为足够大，直接调用第一级得配置器</li>
<li>当配置区块小于<code>128bytes</code>时，视为小，便采用复杂的<code>memory pool</code>管理配置，又称为次层配置。</li>
</ul>
<p><strong><code>memory pool</code>的想法是</strong>：预先配置一大块内存，一般来书为需求的2倍，并维护与之对应的自由链表<code>free list</code>。<strong>下次若有对应大小的内存需求，则直接从该链表拔出给它就行；如果客户端释还从该内存池种拔出的一部分内存，则由配置器回收到该内存池中</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free list的节点结构如下所示：节点使用union而不是struct，从而达到节省内存开销的目的。</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span>&#123;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;	<span class="comment">//未被使用时，由次指针维护</span></span><br><span class="line">	<span class="type">char</span> client_data[<span class="number">1</span>];	<span class="comment">//当内存被使用时，软件开发者使用这个，执行实际区块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>下面来介绍这种机制：</strong>从内存池中取空间给<code>free list</code>是<code>chunk_alloc()</code>函数得工作。</p>
<ul>
<li>如<code>chunk_alloc(32，20)</code>会根据<code>end_free-start_free</code>来判断内存池得水量是否充足，如果水量充足，则直接调出20个相应大小的内存区块给<code>free_list</code>；如果不充足则调用<code>malloc</code>分配至少40个<code>32bytes</code>的内存块，一个直接给客户端，19个给<code>free_list</code>维护，另外的给内存池</li>
<li>如果不够20个但至少能满足一个32bytes的内存块，也会拨出至少一个；</li>
<li>如果连一个区块都拨不出去，此时便会利用<code>malloc</code>从<code>heap</code>上配置内存，从内存中为内存池注入水源以应付需求，一般来说申请的内存是需求量的2倍。</li>
</ul>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/memorypool.png" width="700"></p>
<p>如上图：</p>
<ul>
<li><strong>假设程序一开始就调用<code>chunk_alloc(32,20)</code>,那么<code>malloc</code>就会配置40个<code>32bytes</code>的区块，其中第一个交出，另外19个交给<code>free_list[3]</code>维护，剩余20个交给内存池。</strong></li>
<li>接下来客户端再调用<code>chunk_alloc(64,20)</code>,此时很明显<code>free_list[7]</code>没有内存，必须向内存池请求支持，但内存池也只够10个64<code>bytes</code>的区块，那么就会交付这10，一个直接给客户端，另外9个由<code>free_list[7]</code>维护。此时内存池已经空了，</li>
<li>如果再调用<code>chunk_alloc(96,20)</code>,不仅<code>free_list[11]</code>没有内存，就连内存池也没有，那么就会调用<code>malloc</code>配置40+n个<code>96bytes</code>区块，其中第一个给客户端，19个给<code>free_list[11]</code>，另外的给内存池。</li>
<li>如果<code>malloc()</code>也无法分配内存，就会使用第一级配置，不断尝试去释放获取。</li>
</ul>
<h4 id="迭代器与traits编程技法">3. 迭代器与traits编程技法</h4>
<p><code>iterator</code>是指提供一种方法，使之能够依序巡防某个容器所含的各个元素，而又无需暴露该容器的内部表达式。STL通过泛型化将数据容器和算法分开，采用<code>iterator</code>将两者粘合起来，以<code>find</code>为例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(first!=last&amp;&amp;*first!=value)</span><br><span class="line">		++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 迭代器是一种行为类似指针的<strong>对象</strong>，而指针最常见的应用就是<strong>内容提取和成员访问</strong>，因此对于迭代器来说最重要的编程工作就是对<code>operator *、operator-&gt;、operator++</code>进行重载</p>
<h5 id="traits编程技法-stl源码的门钥">3.1 traits编程技法-STL源码的门钥</h5>
<h6 id="为什么要使用traits编程技法">3.1.1 为什么要使用traits编程技法</h6>
<p>迭代器一般都为模板，其所指对象的的型别，称为该迭代器的<code>value type</code>。模板函数虽然带有参数类型的推导，但却不是万能的：<strong>万一<code>value type</code>用于函数的反回值，毕竟template的参数推导机制只是适用于参数，无法推导返回值</strong>。<strong>我们可能可以在类内定义内嵌型别来解决，也可以使用<code>C++11</code>的的尾置返回类型</strong><code>remove_reference&lt;decltype(beg*)&gt;::type</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内嵌类型声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myiter</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;		<span class="comment">//内嵌型别声明</span></span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> I&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> I::value_type <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾置返回类型</span></span><br><span class="line"><span class="comment">//此例中我们通知编译器fcn2的返回类型与解引用beg的参数的结果类型相同</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(T beg,T end)</span>-&gt;<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上面这个程序看起来能够解决返回值问题，但是有一个问题就是我们<strong>不能为不是类类型的定义内嵌型别</strong>，比如<strong>指针</strong>就不行，但STL又必须接受原生指针作为一种迭代器。虽然采用模板的特例化可以解决问题，但是每有需要就要特例化一个模板就很麻烦，此时就得采用<code>traits</code>的偏特例化编程。(像<code>int*,double*</code>内置类型或者自动定义的类的指针就是原生指针)</p>
<h6 id="traits和偏特例化">3.1.2 traits和偏特例化</h6>
<p><code>traits</code>单词只是说明这个类能萃取到迭代器的特性，只是一个名字的作用，告诉编程人员注意对于这种类内部会对传入的参数进行取<code>value type</code>操作，说实在就是STL当中的规范协议。如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> itrator_traits&lt;I&gt;::<span class="built_in">value_type</span>(I iter)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果I内定义了自己的<code>value type</code>，那么就会在<code>iterator_traits</code>这种类内部有取<code>value type</code>操作。这里跟我们上面提到的内嵌型别说明是一样的。上面这个类只是起到中间转换的作用，这就<code>traits</code>的特定。</p>
<p>然后我们在去实现iterator_traits的一个特例化版本即传入指针形式的偏特化版本就能取得指针的类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的机制是当我们传入T*=int*时，因为int内有定义value_type那么就肯定能获得其类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 为啥还需要const版本，引用我们最终要获取时<code>I</code>的类型，而不是<code>const+类型</code>,试想当没有const版本，调用iterator_traits&lt;const int*&gt;会获取到<code>const int</code>而不是<code>int</code>。<strong>三个版本都是需要的，后面两个版本为解决原生指针无法获取类型而采用（应用偏特例化）</strong></p>
<p>总结：</p>
<ul>
<li>实现原生指针也能推导返回值类型就是要<code>traits</code>编程技法</li>
<li><code>traits</code>不是什么C++内部关键字，它只是对STL源码编写的一个规范</li>
<li><code>traits</code>编程技法主要应用于迭代器实现，迭代器就是行为像指针的类，保证我们在使用迭代器类的<code>operator*</code>后能返回迭代器所指的元素</li>
<li><code>traits</code>编程技法的实现原理就是对类模板的偏特例化（上面的二个篇特例化模板）</li>
</ul>
<h5 id="迭代器相应型别">3.2 迭代器相应型别</h5>
<p>更加迭代器使用<code>operator*</code>时所返回的类别，一般有<code>value type,difference type,pointer,reference,itrator category</code>这五种。因此我们在对<code>traits</code>类进行<code>typedef</code>时都应当指定，以便符号STL规范，即使自己编写的迭代器类也能与STL水乳交融。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::iterator_category	iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type 		    value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::difference_type 	difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer 			pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference 			reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="value_type">3.2.1 value_type</h6>
<p><code>value_type</code>就是迭代器所指对象的型别，任何一个打算与STL算法有完美搭配的class,都应当定义自己的<code>value_type</code>内嵌型别。</p>
<h6 id="difference_type">3.2.2 difference_type</h6>
<p><code>difference_type</code>用来表示两个迭代器的距离，因此也可以用来表示一个容器的最大容量。比如STL的<code>count</code>算法统计指定值出现次数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I*&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">count</span><span class="params">(I fist,I last,<span class="type">const</span> T&amp; value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I*&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;first!=last;++first)</span><br><span class="line">		<span class="keyword">if</span>(*first==value)</span><br><span class="line">			++n;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="reference">3.2.3 reference</h6>
<p><code>reference_type</code>即我们熟知的C++当中的左值引用，这个类型允许我们通过迭代器来对容器内的元素做出改变。</p>
<h6 id="pointer">3.2.4 pointer</h6>
<p><code>pointer</code>是指指针，传回一个指针表示我们也可以通过迭代器对容器内的元素做改变。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="iterator_category">3.2.5 iterator_category</h6>
<p>这个型别是迭代器的类型型名，必须指定迭代器的分类如下： <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/iterator.png" width="300"> 我们在设计算法的时候，必须针对上图的某种迭代器提供一明确定义，比如有一个算法明确使用<code>ForwardIterator</code>，那就应当明确传递这种迭代器，虽然传递<code>RandomAccessIterator</code>和<code>BidirectionalIterator</code>也可以,但效率并不是最佳。</p>
<h5 id="iterator源代码展示">3.3.iterator源代码展示</h5>
<p>下面的源代码选自SGI版本的STL<code>&lt;stl_iterator.h&gt;</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ITERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ITERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//五种迭代器，作为标记型别（tag types）,不需要任何成员</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iteratoe_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为避免写代码时挂一漏万，自行开发的迭代器最好继承自下面这个 std::iterator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Category</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>=<span class="type">ptrdiff_t</span>,</span><br><span class="line">		<span class="keyword">class</span> Pointer=T*,<span class="keyword">class</span> Reference=T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//五种迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> input_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                   value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance            difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                  pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                  reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                     value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance              difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                    pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                    reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;榨汁机&quot;traits</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer            pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference          reference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生指针（naive pointer）而设计的traits偏特性化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对Pointer-to-const而设计的traits偏特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T*                    pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T                     reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某迭代器iterator的类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">category</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器的value_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器的distance_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type*</span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//........................整组advance函数............................................</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数重载，使迭代器能在编译时期就确定调用哪个函数*/</span>  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为input_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_InputIter&amp; __i, _Distance __n, input_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (__n--) ++__i;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为bidirectional_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_BidirectionalIterator&amp; __i, _Distance __n,   </span><br><span class="line">                      bidirectional_iterator_tag) </span><br><span class="line">&#123;  </span><br><span class="line">  __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);  </span><br><span class="line">  <span class="keyword">if</span> (__n &gt;= <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">while</span> (__n--) ++__i;</span><br><span class="line">  <span class="keyword">else</span>  </span><br><span class="line">    <span class="keyword">while</span> (__n++) --__i;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为random_access_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_RandomAccessIterator&amp; __i, _Distance __n,   </span><br><span class="line">                      random_access_iterator_tag) </span><br><span class="line">&#123;  </span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);  </span><br><span class="line">  __i += __n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*决定调用哪个函数，这是一个对外接口*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(_InputIterator&amp; __i, _Distance __n)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_InputIterator, _InputIterator);</span><br><span class="line">  __advance(__i, __n, <span class="built_in">iterator_category</span>(__i));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//............................整组distance函数........................................</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function">	<span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __distance(first, last,</span><br><span class="line">			std::iterator_traits&lt;InputIterator&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">	_distance(InputIterator first,InpuetIterator，input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">    	++first;</span><br><span class="line">		++n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::difference_type </span><br><span class="line">        __distance(InputIterator first, InputIterator last, </span><br><span class="line">		std::random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的<code>advan</code>函数<strong><em>如果</em></strong>不加第三个参数，因为型别都未定，<strong>是实打实的<code>template</code>，不是重载函数，如下：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_II</span><span class="params">(InputIterator&amp; __i, _Distance __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectinalIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_BI</span><span class="params">(BidirectinalIterator&amp; __i, _Distance __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_RI</span><span class="params">(RandomAccessIterator&amp; __i, _Distance __n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们调用的时候，如果选错使用<code>advance_II</code>来进行<code>advance_RI</code>的工作内容，则原本的O(1)时间复杂度就变成了O(n)，<strong>因此在源码中通过增加五个结构体，来给这些函数增加第三个确定的参数形成重载机制，在编译时能够使用重载确定调用哪一个版本，容错率高</strong>。<code>distance</code>函数也是这样的思想。这是一个值得借鉴的模板编写方式！</p>
<h4 id="序列式容器">4. 序列式容器</h4>
<p>序列式容器当中的元素都可序，但未必一定有序，全看编程者的操作。C++语言本身带有<code>array</code>，STL提供<code>vector、list、deque、stack、queue、priority_queue</code>等序列容器。由于<code>stack\queue</code>只是将<code>deque</code>改头换面而成，技术上被归为配接器。</p>
<h5 id="vector">4.1 vector</h5>
<p>在<code>vector</code>中最关键的在于器对大小的控制以及重新配置时数据的移动效率。这些在后面会介绍到，这里我们先对<code>vector</code>的源码进行简单介绍： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T			value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;		<span class="comment">//这个说明了迭代器就是普通指针</span></span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> 		size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> 	difference_type;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//Simple_alloc时SGI STL的空间配置器，</span></span><br><span class="line">	<span class="comment">//虽然vector使用了缺省的配置器,但Simple_alloc更方便以元素大小为配置单元</span></span><br><span class="line">	<span class="keyword">typedef</span> Simple_alloc&lt;value_type,Alloc&gt;data_allocator;</span><br><span class="line">	iterator start;						<span class="comment">//表示目前使用空间的头</span></span><br><span class="line">	iterator finissh;					<span class="comment">//表示目前使用空间的尾</span></span><br><span class="line">	iterator end_of_storage;			<span class="comment">//表示目前可用空间的尾</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_aux</span><span class="params">(iterator position,<span class="type">const</span> T&amp;x)</span></span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...<span class="comment">//一些操作接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 因为<code>vector</code>维护的一个连续空间，所有不论元素型别为哪一种，普通指针都可以作为<code>vector</code>的迭代器而满足所有必要条件，因为像<code>operator*,-&gt;,++,--,+,-,+=,-+</code>这些操作，普通的指针天生就具备。也就是说普通指针就是<code>RandomAccessIterator</code>，支持随机存取。</p>
<h6 id="扩容机制">4.1.1 扩容机制</h6>
<p>在不同的STL版本中，vector的扩容策略不相同，msvc编译器每次是以1.5倍且向下取整的策略进行扩容，gcc编译器则是SGI版本，每次以2.0倍的策略进行扩容。下图时MSVC中的扩容机制 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MSVC</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">34</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(n);</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;size:&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot;  capacity:&quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">size:<span class="number">1</span>  capacity:<span class="number">1</span></span><br><span class="line">size:<span class="number">2</span>  capacity:<span class="number">2</span></span><br><span class="line">size:<span class="number">3</span>  capacity:<span class="number">3</span></span><br><span class="line">size:<span class="number">4</span>  capacity:<span class="number">4</span></span><br><span class="line">size:<span class="number">5</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">6</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">7</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">8</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">9</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">10</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">11</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">12</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">13</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">14</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">15</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">16</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">17</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">18</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">19</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">20</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">21</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">22</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">23</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">24</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">25</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">26</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">27</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">28</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">29</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">30</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">31</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">32</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">33</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">34</span>  capacity:<span class="number">42</span></span><br></pre></td></tr></table></figure></p>
<p>所谓的动态增加，并不是在原空间之后接续新空间，因为无法保证原空间之后尚有可供配置的空间，二是以原来的2倍或1.5倍另外配置一块较大空间，然后将内容拷贝过来，然后才在原内容之后构造新元素，并释放原空间。因此对<code>vector</code>的任何操作若会影响到空间重新配置，指向<code>vector</code>的所有迭代器就都失效了。</p>
<h5 id="list">4.2 list</h5>
<p>相较于<code>vector</code>的连续线性空间，list就比较复杂，它的好处就是每次插入或删除元素，才配置或释放一个元素空间。<strong><code>list</code>是一个双向链表，它不再能够像<code>vector</code>一样以</strong>普通指针<strong>作为迭代器，因为其节点不保证再空间中连续存在，<code>list</code>迭代器必须有能指向<code>list</code>的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。</strong></p>
<h6 id="list的迭代器">4.2.1 list的迭代器</h6>
<p><strong><code>list</code>的迭代器的要求:</strong></p>
<ul>
<li>迭代器必须具备前移、后移的能力，因此对<code>list</code>提供的是<code>BidirectinalIterator</code></li>
<li>与vector不同，不论是何时的插入操作和删除操作、接合操作都不会造成原因的<code>list</code>迭代器失效</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	link_type node; <span class="comment">//迭代器内部需要一个普通指针，指向list的节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//constructor</span></span><br><span class="line">	__list_iterator(link_type x):<span class="built_in">node</span>(x)&#123;&#125;</span><br><span class="line">	__list_iterator()&#123;&#125;</span><br><span class="line">	__list_iterator(<span class="type">const</span> iterator&amp; x):<span class="built_in">node</span>(x.node)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node==x.node;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node!=x.node;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以下对迭代器取值，取的是节点的数据值</span></span><br><span class="line">	reference <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对迭代器累加</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">		node=(link_type)((*node).next);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">		self tmp=*<span class="keyword">this</span>;</span><br><span class="line">		++*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对迭代器减1</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">		node=(link_type)((*node).prev);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">		self tmp=*<span class="keyword">this</span>;</span><br><span class="line">		--*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="list的数据结构">4.2.2 list的数据结构</h6>
<p><code>list</code>是一个<strong>双向环形链表</strong>，所有它只需要一个指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> _list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	link_type node;		<span class="comment">//只需一个指针</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="deque">4.3 deque</h5>
<p><strong><code>deque</code>是一种双向开口的连续线性空间，即指能在头尾两端都支持元素的插入和删除</strong> <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/deque.png" width="500"> <code>vector</code>虽然也能支持在头尾两端进行操作，但是效率奇差，无法接受，因为在头部的插入导致后面所有元素都要后移。而<code>deque</code>则不会：</p>
<ul>
<li><code>duque</code>允许时间复杂度<code>O(1)</code>对其头端进行元素的插入和移除，<code>vector</code>为<code>O(n)</code></li>
<li><code>deque</code>没有所谓的容量概念，因为它是动态地以连续空间组合而成，随时可以增加一段新的空间并链接起来，即不会发生如<code>vector</code>那样的空间重新配置机制</li>
<li>虽然<code>deque</code>也提供<code>RandomAccessIterator</code>，但它的迭代器并不是普通指针，其复杂度和<code>vector</code>不可同道里计，因此除非必要我们应该尽量选择<code>vector</code>而不是<code>deque</code>。</li>
<li>在对<code>deque</code>进行排序操作，为了最高效率，可将<code>deque</code>先完整复制到一个<code>vector</code>身上，将<code>vector</code>排序后再复制会<code>deque</code></li>
</ul>
<h6 id="deque的中控器">4.3.1 deque的中控器</h6>
<p><code>deque</code>是逻辑上是连续空间。<code>deque</code>系由一段一段的定量空间组成，一旦必要在<code>deque</code>的前端或尾增加空间，便配置一段定量连续空间，串接在整个<code>deque</code>的头端或尾端。因此对于<code>deque</code>容器来说必须维护其整体连续的假象，并提供随机存取接口，那么必须有中央控制器和复杂的迭代架构去实现。</p>
<p><strong><code>Deque</code>采取一块所谓的<code>map</code>(注意，不是STL的map容器)作为主控，这里所谓的<code>map</code>是一小块连续的内存空间，其中每一个元素(此处成为一个结点<code>node</code>)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是<code>deque</code>的存储空间的主体。</strong><code>SGI STL</code>允许我们指定缓冲区大小，默认使用<code>512bytes</code>(<code>map</code>其实就是二重指针<code>T**</code>) <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dequemap.png" width="500"></p>
<h6 id="deque的迭代器">4.3.2 deque的迭代器</h6>
<p>对于<code>deque</code>，维持其整体连续的假象，落在了迭代器的<code>operator++</code>和<code>operator--</code>两个重载运算符上。</p>
<ul>
<li>该迭代器必须能够指出分段连续空间在哪里</li>
<li>其次他必须能够判断自己是否已经处在其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃到下一个或上一个缓冲区。</li>
</ul>
<p>因此为了能够正确跳跃，<code>deque</code>必须随时掌握管控中心<code>map</code>。如下的实现方式可行: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>,<span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span>&#123; <span class="comment">//为继承 std::iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;,T*,Bufsize&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*,Bufsize&gt; const_iterator;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> __deque_buf_size(Bufsize,<span class="built_in">sizeof</span>(T));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未继承std::iterator,所以必须自行撰写下述五个必要的迭代器相应型别</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref renference; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持与容器的联结</span></span><br><span class="line">    T* cur; <span class="comment">//此迭代器所指之缓冲区中的现行(current)元素</span></span><br><span class="line">    T* first; <span class="comment">//此迭代器所指之缓冲区中的头</span></span><br><span class="line">    T* last; <span class="comment">//此迭代器所指之缓冲区中的尾(含备用空间)</span></span><br><span class="line">    map_pointer node; <span class="comment">//指向管控中心</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n,<span class="type">size_t</span> sz)&#123;</span><br><span class="line">        <span class="keyword">return</span> n!=<span class="number">0</span>? n:(sz&lt;<span class="number">512</span>? <span class="built_in">size_t</span>(<span class="number">512</span>/sz):<span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    n!=0,返回n，表示buffer_size由	用户自定义</span></span><br><span class="line"><span class="comment">    n=0,表示buffer_size使用默认值，那么：</span></span><br><span class="line"><span class="comment">        sz&lt;512,传回512/sz;</span></span><br><span class="line"><span class="comment">        sz&gt;=512,传回1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dequeiterator.png" width="700"> 如上图，假设我们产生一个元素类型未<code>int</code>,缓冲区为8的<code>deque</code>，经过增删操作后拥有20个元素。<strong><code>deque</code>类内的<code>start</code>和<code>finish</code>分别指向<code>deque</code>的第一个缓冲区和最后一个缓冲区，20/8=3，所以map拥有3个节点，且最后一个缓冲区还有插入元素的空间。</strong>三个指针<code>cur、first、last</code>分别如图所示，`cur·指向缓冲区的最后一个元素的下一个位置。</p>
<p>下面是deque几个重要操作： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span></span>&#123;</span><br><span class="line">	node=new_node;</span><br><span class="line">    first=*new_node;</span><br><span class="line">    last=first+<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">renference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> *cur;&#125;</span><br><span class="line"></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())*</span><br><span class="line">		(node-x.node<span class="number">-1</span>)+(cur-first)+(x.last-x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">    ++cur; <span class="comment">//切换下一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(cur==last)&#123; <span class="comment">//如果已达到所在缓冲区的尾端</span></span><br><span class="line">        <span class="built_in">set_node</span>(node+<span class="number">1</span>); <span class="comment">//利用set_node方法切换到下一个缓冲区</span></span><br><span class="line">        cur=first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>; <span class="comment">//调用operator++</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==first)&#123; <span class="comment">//如果达到缓冲区的头部</span></span><br><span class="line">        <span class="built_in">set_node</span>(node<span class="number">-1</span>); <span class="comment">//利用set_node方法切换到上一个缓冲区</span></span><br><span class="line">        cur=first;</span><br><span class="line">    &#125;</span><br><span class="line">    --cur;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>; <span class="comment">//调用operator--</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)&#123; <span class="comment">//实现随机存取、迭代器可以直接跳跃n个距离</span></span><br><span class="line">    difference_type offset=n+(cur-first);</span><br><span class="line">    <span class="keyword">if</span>(offset&gt;=<span class="number">0</span>&amp;&amp;offset&lt;<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) <span class="comment">//目标位置在统一缓冲区</span></span><br><span class="line">        cur+=n;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//目标位置不在统一缓冲区</span></span><br><span class="line">       		difference_type node_offset=offset&gt;<span class="number">0</span>?</span><br><span class="line">			offset/<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">				:-<span class="built_in">difference_type</span>((-offset<span class="number">-1</span>)/<span class="built_in">buffer_size</span>())<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">set_node</span>(node+node_offset); <span class="comment">//切换至正确的节点</span></span><br><span class="line">            cur=first+(offset-node_offset*<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()); <span class="comment">//切换至正确的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp+=n; <span class="comment">//调用operator+=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>+=-n;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp-=n; <span class="comment">//调用operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机存取第n个元素</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n)<span class="type">const</span> &#123;<span class="keyword">return</span> *(*<span class="keyword">this</span>+n);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> cur==x.cur;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> !(*<span class="keyword">this</span>==x);&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="built_in">return</span> (node==x.node)?(cur&lt;x.cur):(node&lt;x.node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="deque的数据结构">4.3.3 deque的数据结构</h6>
<p>deque除了维护<code>map</code>指针外，还必须维护<code>start、finish</code>两个迭代器，分别指向第一个缓冲区的第一个元素和最后一个缓冲区的额最后一个元素。此外，它当然也必须记住目前的map大小，因为一旦<code>map</code>所提供的节点不足，就必须重新配置更大的一块<code>map</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc,<span class="type">size_t</span> BufSiz=<span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;,T*,BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//元素的指针的指针</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start; <span class="comment">//表示第一个节点</span></span><br><span class="line">    iterator finish; <span class="comment">//表示最后一个节点</span></span><br><span class="line">    map_pointer map; <span class="comment">//指向map，map是块连续空间，其每个元素都是指针，指向一个节点</span></span><br><span class="line">    size_type map_size; <span class="comment">//map内有多个指针</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n)&#123;</span><br><span class="line">        <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">//调用operator[]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *start;&#125; <span class="comment">//调用operator*</span></span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        iterator temp=finish;</span><br><span class="line">        --temp; <span class="comment">//调用operator--</span></span><br><span class="line">        <span class="keyword">return</span> *temp; <span class="comment">//调用operator*</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> finish-start;&#125; <span class="comment">//调用operator-</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> finish==start;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="heap">4.5. heap</h5>
<p><code>heap</code>不属于STL的容器组件，但我们有必要认识它的实现思想，它是实现<code>priority queue</code>的助手。<code>priority queue</code>允许用户以任何次序将元素存入容器中，但是取出时一定时从优先权最高的元素开始取。而堆正有这样的特性，适合作为<code>priority queue</code>的底层机制。</p>
<p>对于heap的虽然讲解的时候用的是<strong>完全二叉树</strong>的形式来讲解，但只是为了更直观的表达而已，一般来说实现都是采用数组的形式来实现的，同时为了达到空间可增长，采用<code>vector+heap算法</code>来实现堆。</p>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/heapSort.gif" width="500"></p>
<h6 id="push_heap算法">4.5.1 push_heap算法</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意，此函式被调用时，新元素已置于底部容器的最尾端</span></span><br><span class="line">    __push_heap_aux(first, last, <span class="built_in">distance_type</span>(first),<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap_aux</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last, Distance*, T*)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>),<span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">    <span class="comment">// 以上系根据implicit representation heap的结构特性：新值必置于底部</span></span><br><span class="line">    <span class="comment">// 容器的最尾端，此即第一个洞号：(last-first)–1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 push_back()不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __push_heap(RandomAccessIterator first, Distance holeIndex,Distance topIndex, T value) </span><br><span class="line">&#123;</span><br><span class="line">    Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 找出父节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value) &#123;</span><br><span class="line">        <span class="comment">// 当尚未到达顶端，且父节点小于新值（于是不符合 heap 的次序特性）</span></span><br><span class="line">        <span class="comment">// 由于以㆖使用 operator&lt;，可知 STL heap 是一种 max-heap（大者为父）</span></span><br><span class="line">        *(first + holeIndex) = *(first + parent); <span class="comment">//令洞值为父值</span></span><br><span class="line">        holeIndex = parent; <span class="comment">// percolate up：调整洞号，向上提升至父节点</span></span><br><span class="line">        parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 新洞的父节点</span></span><br><span class="line">    &#125; <span class="comment">// 持续至顶端，或满足heap的次序特性为止</span></span><br><span class="line">    </span><br><span class="line">    *(first + holeIndex) = value; <span class="comment">//令洞值为新值，完成插入动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pop_heap算法">4.5.2 pop_heap算法</h6>
<p><strong><code>pop_heap</code>算法思路如下：</strong></p>
<ul>
<li>1.把根节点元素取出，把最后一个节点的元素取出</li>
<li>2.将原根节点元素放在vector的最后一个节点处</li>
<li>3.将原先的最后一个节点的元素放置到原根节点处作为新根节点</li>
<li>4.将新根节点逐个与子节点比较，直到其值比子节点都大时，结束算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __pop_heap_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap_aux(RandomAccessIterator first,RandomAccessIterator last, T*) </span><br><span class="line">&#123;</span><br><span class="line">    __pop_heap(first, last<span class="number">-1</span>, last<span class="number">-1</span>, <span class="built_in">T</span>(*(last<span class="number">-1</span>)),</span><br><span class="line">    <span class="built_in">distance_type</span>(first));</span><br><span class="line">    <span class="comment">// 以上，根据 implicit representation heap 的次序特性，pop操作的结果</span></span><br><span class="line">    <span class="comment">// 应为底部容器的第一个元素。因此，首先设定欲调整值为尾值，然后将首值调至</span></span><br><span class="line">    <span class="comment">// 尾节点（所以以上将迭代器 result设为 last-1）。然后重整 [first, last-1)，</span></span><br><span class="line">    <span class="comment">// 使之重新成一个合格的 heap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 pop_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap(RandomAccessIterator first,</span><br><span class="line">        RandomAccessIterator last,</span><br><span class="line">        RandomAccessIterator result,</span><br><span class="line">        T value, Distance*) </span><br><span class="line">&#123;</span><br><span class="line">    *result = *first; <span class="comment">// 设定尾值为首值，于是尾值即为欲求结果，</span></span><br><span class="line">                      <span class="comment">// 可由客端稍后再以底层容器之 pop_back() 取出尾值</span></span><br><span class="line"> </span><br><span class="line">    __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">    <span class="comment">// 以上欲重新调整 heap，洞号为 0（亦即树根处），欲调整值为 value（原尾值）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="sort_heap算法">4.5.3 sort_heap算法</h6>
<p>既然每次<code>pop_heap</code>可获得<code>heap</code>之中键值最大的元素，如果持续对整个<code>heap</code>做<code>pop_heap</code>动作，每次将操作范围从后向前缩减一个元素（因为pop_heap会把键值最大的元素放在底部容器的最尾端），当整个程序执行完毕，我们便有了一个递增序列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [first,last) 排列为一个heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 make_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first,RandomAccessIterator last, T*,Distance*) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//如果长度为0或1，不必重新排列</span></span><br><span class="line"> </span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    <span class="comment">// 找出第一个需要重排的子树头部，以parent标示出。由于任何叶节点都不需执行</span></span><br><span class="line">    <span class="comment">// perlocate down，所以有以下计算。parent命名不佳，名为holeIndex 更好</span></span><br><span class="line">    Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 重排以 parent 为首的子树。len是为了让__adjust_heap() 判断操作范围</span></span><br><span class="line">        __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 走完根节点，就结束。</span></span><br><span class="line">        parent--; <span class="comment">// （即将重排之子树的）头部向前一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="priority_queue">4.6 priority_queue</h5>
<p><code>priority_queue</code>是一个拥有权值观念的<code>queue</code>。其内部的元素不再像<code>queue</code>依照被存入的次序排列，而是按照元素的权值排列，权值最高者，排在最前面。缺省情况下<code>proority_queue</code>利用一个<code>max-heap</code>和<code>vector</code>为底部容器。<code>priority_queue</code>没有迭代器(<code>queue</code>和<code>stack</code>也没有) <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/priorityqueue.png" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;,</span><br><span class="line">    <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line">    Compare comp; <span class="comment">// 元素大小比较标准</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : c(), comp(x) &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以下用到的 make_heap(), push_heap(), pop_heap()都是泛型算法</span></span><br><span class="line">    <span class="comment">// 注意，任一个建构式都立刻于底层容器内产生一个 implicit representation heap</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; x)</span><br><span class="line">        : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(),comp); &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last)</span><br><span class="line">        : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        __STL_TRY &#123;</span><br><span class="line">            <span class="comment">// push_heap是泛型算法，先利用底层容器的 push_back() 将新元素推入末端，再重排heap</span></span><br><span class="line">            c.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); <span class="comment">//push_heap是泛型算法</span></span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        __STL_TRY &#123;</span><br><span class="line">            <span class="comment">//pop_heap 是泛型算法，从 heap 内取出一个元素。它并不是真正将元素</span></span><br><span class="line">            <span class="comment">//弹出，而是重排 heap，然后再以底层容器的 pop_back() 取得被弹出的元素</span></span><br><span class="line">            <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">            c.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="关联式容器">5. 关联式容器</h4>
<p>标准的STL关联式容器分为<code>set</code>集合和<code>map</code>映射表两大类。以及两大衍生体<code>multiset</code>和<code>multimap</code>。这些容器的底层机制均与<code>RB-tree</code>完成。红黑树是一个独立容器，但不对外界使用。同时<code>SGI STL</code>还提供了一个不在标准规则之外的管理容器<code>hash_table</code>，以及以<code>hash_table</code>为底层机制完成的<code>hash_set、hash_map、hash_multiset、hash_multimap</code>。</p>
<p>所谓关联式容器类似于关联式数据库：每笔数据都有一个键值和一个实值，当元素插入到关联式容器时会按照键值大小以某种规则将这个元素放置于合适的位置，因此对于关联式容器没有<code>push_back、push_front、pop_back、pop_front</code>这样的行为。</p>
<h5 id="rb-tree">5.1 RB-tree</h5>
<p>关于红黑树的的定义和一些平衡原理见<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构篇</a>，这里列举一些<code>SGI STL</code>的<code>RB-tree</code>源码。</p>
<h6 id="rb-tree结构体">5.1.1 RB-tree结构体</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">RB树的节点结构:</span><br><span class="line"><span class="comment">//由于红黑树的各种操作常需要上溯其父级节点，因此特别安排一个parent指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;     <span class="comment">// 红色为0</span></span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">  color_type color;     <span class="comment">// 节点颜色，红色或黑色</span></span><br><span class="line">  base_ptr parent;      <span class="comment">// 该指针指向其父节点</span></span><br><span class="line">  base_ptr left;        <span class="comment">// 指向左节点</span></span><br><span class="line">  base_ptr right;       <span class="comment">// 指向右节点</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	 <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left; <span class="comment">//一直向左走，找到最小值</span></span><br><span class="line">	 <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right; <span class="comment">//一直向右走，找到最大值</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node</span> : <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;   <span class="comment">//节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="rb-tree迭代器">5.1.2 RB-tree迭代器</h6>
<p><code>RB-tree</code>的迭代器属于双向迭代器，但不具备随机定位的能力，与<code>list</code>较为相似，比较特殊的是他具有前进和后退的操作。<code>RB-tree</code>迭代器的<code>operator++</code>是调用了基层迭代器的<code>increment()</code>函数，其<code>operator--</code>调用<code>decrement()</code>函数。 <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/rbtreeiterator.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基层迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_tree_base_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	base_ptr node; <span class="comment">//用来与容器之间产生一个连接的关系</span></span><br><span class="line">	<span class="comment">//实现operator++</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(node-&gt;right != <span class="number">0</span>)&#123;</span><br><span class="line">	        <span class="comment">//状况1：右子结点存在，则当前可以看成是根节点,则找出右子树的最左结点</span></span><br><span class="line">	        node = node-&gt;right;</span><br><span class="line">	        <span class="keyword">while</span>(node-&gt;left != <span class="number">0</span>)</span><br><span class="line">	            node = node-&gt;left;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">	        <span class="comment">//状况2：没有右子节点,找出父节点</span></span><br><span class="line">			<span class="comment">//如果现行节点本身是个右子节点，就一直上溯，直到不为右子节点为止</span></span><br><span class="line">	        base_ptr y = node-&gt;parent;</span><br><span class="line">	        <span class="keyword">while</span>(y-&gt;right == node)&#123;</span><br><span class="line">	            node = y;</span><br><span class="line">	            y = y-&gt;parent;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">if</span>(node-&gt;right != y)</span><br><span class="line">	            <span class="comment">//状况3：如果当前的node不是根节点，则y即为所求</span></span><br><span class="line">	            node = y;</span><br><span class="line">	        <span class="comment">//状况4：如果当前的node是根节点，则node为所求</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//实现--</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(node-&gt;color == rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)</span><br><span class="line">	        <span class="comment">//状况1：如果当前结点是header结点，那么其前驱应该是mostright结点，也就是其右子结点</span></span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//状况2：也就是当前是根节点，那么其前驱应该是左子树中最右结点</span></span><br><span class="line">                base_ptr y = node-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(y-&gt;right != <span class="number">0</span>)</span><br><span class="line">                    y = y-&gt;right;</span><br><span class="line">                node = y;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//状况3：如果当前不是根节点，也没有左子节点，那么当前处于右子树的最左结点，要去找根节点</span></span><br><span class="line">                base_ptr y = node-&gt;parent;</span><br><span class="line">                <span class="keyword">while</span>(y-&gt;left == node)</span><br><span class="line">				&#123;</span><br><span class="line">                    node = y;</span><br><span class="line">                    y = y-&gt;parent;</span><br><span class="line">                &#125;</span><br><span class="line">                node = y;</span><br><span class="line">                <span class="comment">//如果当前处于root结点，y则为header结点，那么当前必定只有root一个结点</span></span><br><span class="line">                <span class="comment">//则可以得到node = header，y = root</span></span><br><span class="line">                <span class="comment">//最终得到node = y，不需要特殊处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正规迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value,<span class="keyword">typename</span> Ref,<span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_tree_iterator</span>:<span class="keyword">public</span> rb_tree_base_iterator&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,Value&amp;,Value*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,<span class="type">const</span> Value&amp;,<span class="type">const</span> Vallue*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,Ref,Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>(link_type x)&#123;node = x&#125;;</span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>(<span class="type">const</span> iterator&amp; it)&#123;node = it.node&#125;;</span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">link_type</span>(node)-&gt;value_field;</span><br><span class="line">	&#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">	    <span class="built_in">increment</span>();</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    <span class="built_in">increment</span>();</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	    <span class="built_in">decrement</span>();</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    <span class="built_in">decrement</span>();</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="rb-tree的数据结构">5.1.3 RB-tree的数据结构</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------------rb_tree类---------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node,Alloc&gt;rb_tree_node_allocator;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//没有迭代器iterator?不！会在后面声明</span></span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">link_type <span class="title">get_node</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">allocate</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span></span>&#123;<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">deallocate</span>(p);&#125;</span><br><span class="line">    <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        link_type tmp = <span class="built_in">get_node</span>(); <span class="comment">//配置空间</span></span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            Chy::allocator&lt;Key&gt;::<span class="built_in">construct</span>(&amp;tmp-&gt;value_field,x);<span class="comment">//构造内容</span></span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(<span class="built_in">put_node</span>(tmp));</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span></span>&#123;<span class="comment">//复制一个节点的颜色和数值</span></span><br><span class="line">        link_type tmp = <span class="built_in">create_node</span>(x-&gt;value_field);</span><br><span class="line">        tmp-&gt;color = x-&gt;color;</span><br><span class="line">        tmp-&gt;left = <span class="number">0</span>;</span><br><span class="line">        tmp-&gt;right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span></span>&#123;</span><br><span class="line">        Chy::allocator&lt;Key&gt;::<span class="built_in">destroy</span>(&amp;p-&gt;value_field); <span class="comment">//析构内容</span></span><br><span class="line">        <span class="built_in">put_node</span>(p); <span class="comment">//释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//RB-tree只使用三笔数据表现</span></span><br><span class="line">    size_type node_count; <span class="comment">//追踪记录树的大小 (节点的数量)</span></span><br><span class="line">    link_type header;     <span class="comment">//实现上的小技巧</span></span><br><span class="line">    Compare key_compare;  <span class="comment">//节点之间的键值大小的比较准则. 应该会是一个function object</span></span><br><span class="line">    <span class="comment">//以下三个函数用于方便获取header的成员</span></span><br><span class="line">    <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;parent;&#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">left_most</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;left;&#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">right_most</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;right;&#125;</span><br><span class="line">    <span class="comment">//以下六个函数用于方便获得节点x的成员</span></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;left;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;right;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;parent;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span> x-&gt;value_field;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x));&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span></span>&#123;<span class="keyword">return</span> (color_type&amp;) (x-&gt;color);&#125;</span><br><span class="line">    <span class="comment">//获取极大值和极小值 node class有实现此功能</span></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type,reference,pointer&gt;iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    iterator __insert(base_ptr x,base_ptr y,<span class="type">const</span> value_type&amp; v);</span><br><span class="line">    link_type __copy(link_type x,link_type p);</span><br><span class="line">    <span class="type">void</span> __erase(link_type x);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">            __erase(<span class="built_in">root</span>());</span><br><span class="line">            <span class="built_in">left_most</span>() = header;</span><br><span class="line">            <span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">right_most</span>() = header;</span><br><span class="line">            node_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        header = <span class="built_in">get_node</span>(); <span class="comment">//产生一个节点空间 令header指向它</span></span><br><span class="line">        <span class="built_in">color</span>(header) = __rb_tree_red;<span class="comment">//令header为红色 用于区分header和root,在iterator的operator++中</span></span><br><span class="line">        <span class="built_in">root</span>() == <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">left_most</span>() = header;   <span class="comment">//令header的左子节点等于自己</span></span><br><span class="line">        <span class="built_in">right_most</span>() = header;  <span class="comment">//令header的右子节点等于自己</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//allocation / deallocation</span></span><br><span class="line">    <span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">            : <span class="built_in">node_count</span>(<span class="number">0</span>),<span class="built_in">key_compare</span>(comp)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">rb_tree</span>()&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">put_node</span>(header);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp;<span class="keyword">operator</span>==(<span class="type">const</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp;x);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> key_compare;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">left_most</span>();&#125; <span class="comment">//RB树的起头为最左(最小)节点处</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> header;&#125; <span class="comment">//RB树的终点为header所指处</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> node_count == <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> node_count;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span> (<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//insert/erase</span></span><br><span class="line">    <span class="comment">//将x插入到RB-Tree中 (保持节点的独一无二)</span></span><br><span class="line">    <span class="function">std::pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//将x插入到RB-Tree中 (允许节点数值重复)</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//寻找键值为k的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> value_type&amp; k)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------rb_tree类主要函数的实现--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新的数值 节点键值允许重复</span></span><br><span class="line"><span class="comment">//注意：返回的是一个RB-Tree的迭代器，指向的是新增的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//根节点开始</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;        <span class="comment">//根节点开始 从上往下寻找适当的插入节点</span></span><br><span class="line">        y = x;</span><br><span class="line">        <span class="comment">//如果当前根节点比 输入的v大，则转向左边，否则转向右边</span></span><br><span class="line">        x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x为新值插入点 y为插入点的父节点 v为新值</span></span><br><span class="line">    <span class="keyword">return</span> __insert(x,y,v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入新的数值 节点键值不允许重复</span></span><br><span class="line"><span class="comment">//注意：返回结果是pair类型，第一个元素是一个RB-Tree的迭代器，指向的是新增的节点；第二个参数表示插入成功与否</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">std::pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator,<span class="type">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//从根节点开始</span></span><br><span class="line">    <span class="type">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123; <span class="comment">//从根节点开始 往下寻找适当的插入点</span></span><br><span class="line">        y = x;</span><br><span class="line">        comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)); <span class="comment">//v键值小于目前节点的键值</span></span><br><span class="line">        x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x); <span class="comment">//遇&quot;大&quot;则向左 遇&quot;小&quot;则向右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离开while循环之后 y所指的即 插入点之父节点（此时它必为叶子结点）</span></span><br><span class="line">    iterator j = <span class="built_in">iterator</span>(y); <span class="comment">//迭代器j指向插入点的父节点y</span></span><br><span class="line">    <span class="keyword">if</span> (comp)&#123;</span><br><span class="line">        <span class="comment">//如果while循环时候，判定comp的数值，如果comp为真(表示遇到大的元素，将插入左侧)</span></span><br><span class="line">        <span class="comment">//如果插入节点的父节点是最左侧的节点</span></span><br><span class="line">        <span class="comment">//x为插入点，y为插入节点的父节点，v表示新值</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">begin</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(__insert(x,y,v), <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//插入节点的父节点不是最左侧的节点</span></span><br><span class="line">            <span class="comment">//调整j 回头准备测试</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node),<span class="built_in">KeyOfValue</span>()(v)))&#123;</span><br><span class="line">            <span class="comment">//小于新值（表示遇到小的数值，将插在右侧）</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(__insert(x,y,v), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此 表示新值一定和树中的键值重复 就不应该插入新的数值</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//真正的插入执行程序 __insert()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::__insert(base_ptr x_, base_ptr y_, <span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    <span class="comment">//参数x_为新的插入点 参数y_为插入点的父节点 参数v为新值</span></span><br><span class="line">    link_type x = (link_type)x_;</span><br><span class="line">    link_type y = (link_type)y_;</span><br><span class="line">    link_type z ;</span><br><span class="line">    <span class="comment">//key_compare 是键值大小的比较准则，应该是一个function object</span></span><br><span class="line">    <span class="keyword">if</span> (y == header||x != <span class="number">0</span>||<span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v),<span class="built_in">key</span>(x)))&#123;</span><br><span class="line">        z = <span class="built_in">create_node</span>(v); <span class="comment">//产生一个新的节点</span></span><br><span class="line">        <span class="comment">//当y即为header的时候，leftmost = z;</span></span><br><span class="line">        <span class="keyword">if</span> (y == header)&#123;</span><br><span class="line">            <span class="built_in">root</span>() = z;</span><br><span class="line">            <span class="built_in">right_most</span>() = z;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">left_most</span>())&#123;</span><br><span class="line">            <span class="comment">//y为最左节点</span></span><br><span class="line">            <span class="comment">//维护leftmost() 使其永远指向最左节点</span></span><br><span class="line">            <span class="built_in">left_most</span>() = z;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            z = <span class="built_in">create_node</span>(v);<span class="comment">//产生一个新的节点</span></span><br><span class="line">            <span class="comment">//让新节成为插入点的父节点y的右子节点</span></span><br><span class="line">            <span class="built_in">right</span>(y) = z;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="built_in">right_most</span>())&#123; <span class="comment">//维护rightmost()让其永远指向最右的节点</span></span><br><span class="line">                <span class="built_in">right_most</span>() = z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">parent</span>(z) = y; <span class="comment">//设定新节点的父节点</span></span><br><span class="line">        <span class="built_in">left</span>(z) = <span class="number">0</span>; <span class="comment">//设定新节点的左子节点</span></span><br><span class="line">        <span class="built_in">right</span>(z) = <span class="number">0</span>; <span class="comment">//设定新节点的右子节点</span></span><br><span class="line">        <span class="comment">//修改颜色</span></span><br><span class="line">        <span class="comment">//参数一为新增节点 ；参数二 为root</span></span><br><span class="line">        __rb_tree_rebalance(z,header-&gt;parent);</span><br><span class="line">        ++node_count;</span><br><span class="line">        <span class="comment">//返回一个迭代器 指向新的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必须为红色，如果插入出父节点同样为红色，就需要进行树形旋转</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_rotate_left(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    <span class="comment">//x为旋转点</span></span><br><span class="line">    __rb_tree_node_base* y = x-&gt;right;<span class="comment">//令y为旋转点的右子节点</span></span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//回马枪设定父亲节点</span></span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="comment">//令y完全替代x的地位 (需要将x对其父节点的关系完全接收回来)</span></span><br><span class="line">    <span class="keyword">if</span> (x == root)&#123;</span><br><span class="line">        root = y; <span class="comment">//x为根节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;  <span class="comment">//x为其父节点的左子节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y; <span class="comment">//x为其父节点的右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必须为红色，如果插入出父节点同样为红色，就需要进行树形旋转</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_rotate_right(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    <span class="comment">//x为旋转点</span></span><br><span class="line">    __rb_tree_node_base* y = x-&gt;left; <span class="comment">//y为旋转点的左子节点</span></span><br><span class="line">    x-&gt;left = y-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;right != <span class="number">0</span>)&#123;</span><br><span class="line">        y-&gt;right-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="comment">//令y完全替代x的地位</span></span><br><span class="line">    <span class="keyword">if</span>(x == root)&#123;</span><br><span class="line">        root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//调整RB_tree 插入节点之后，需要进行调整(颜色/翻转)从而满足要求</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_balance(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    x-&gt;color = __rb_tree_red; <span class="comment">//新节点的颜色必须是红色的</span></span><br><span class="line">    <span class="keyword">while</span>(x!=root &amp;&amp; x-&gt;parent-&gt;color == __rb_tree_red)&#123;</span><br><span class="line">        <span class="comment">//父节点为红色的</span></span><br><span class="line">        <span class="comment">//父节点为祖父节点的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left)&#123;</span><br><span class="line">            <span class="comment">//令y为伯父节点</span></span><br><span class="line">            __rb_tree_node_base* y = x-&gt;parent-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)&#123; <span class="comment">//伯父节点存在 且为红</span></span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//更改父节点的颜色为黑</span></span><br><span class="line">                y-&gt;color = __rb_tree_black;<span class="comment">//更改父节点的颜色为黑</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//更改祖父节点的颜色为红</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无伯父节点 或者伯父节点的颜色为黑</span></span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)&#123;</span><br><span class="line">                    <span class="comment">//新节点为父节点的右子节点</span></span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    <span class="comment">//第一次参数为左旋节点</span></span><br><span class="line">                    __rb_tree_rotate_left(x,root);</span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                <span class="comment">//第一次参数为右旋节点</span></span><br><span class="line">                __rb_tree_rotate_right(x-&gt;parent-&gt;parent,root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//父节点为祖父节点的右子节点</span></span><br><span class="line">            __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left; <span class="comment">//令y为伯父节点</span></span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)&#123; <span class="comment">//存在伯父节点，且为红</span></span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//更改父节点为黑</span></span><br><span class="line">                y-&gt;color = __rb_tree_black;<span class="comment">//更改伯父节点为黑</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; <span class="comment">//更改祖父节点为红</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent; <span class="comment">//准备继续往上层检查</span></span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无伯父节点 或者伯父节点 为黑</span></span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">                    <span class="comment">//新节点 为 父节点的左子节点</span></span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    __rb_tree_rotate_right(x,root); <span class="comment">//第一参数为右旋转点</span></span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                <span class="comment">//第一参数为左旋点</span></span><br><span class="line">                __rb_tree_rotate_left(x-&gt;parent-&gt;parent,root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//while结束</span></span><br><span class="line">    root-&gt;color = __rb_tree_black;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//元素查找程序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">find</span>(<span class="type">const</span> value_type &amp;k) &#123;</span><br><span class="line">    link_type y = header; <span class="comment">//last node which is  not less than k</span></span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//current node</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//key_compare 是节点大小的比较准则 function object</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x),k))&#123;</span><br><span class="line">            <span class="comment">//进行到这里 表示x的数值大于k 。遇到大的数值向左走</span></span><br><span class="line">            y = x,x = <span class="built_in">left</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator j = <span class="built_in">iterator</span> (y);</span><br><span class="line">    <span class="keyword">return</span> (j == <span class="built_in">end</span>() || <span class="built_in">key_compare</span>(k,<span class="built_in">key</span>(j.node))) ? <span class="built_in">end</span>() : j;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/************************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//注意：以下的identify定义于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">identify</span> : <span class="keyword">public</span> std::unary_function&lt;T,T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="set">5.2 set</h5>
<ul>
<li><code>set</code>的特性是 所有的元素会按照键值自动排序</li>
<li><code>set</code>的键值等同于实值</li>
<li><strong><code>set</code>不允许涵盖两个相同的键值</strong></li>
<li><strong>不可以通过迭代器修改<code>set</code>的元素数值，这会破坏元素的排列顺序。因此<code>set&lt;T&gt;::iterator</code>被定义为底层<code>RB-tree</code>的<code>const_iterator</code>,杜绝写入。也就是<code>set</code>的<code>iterators</code>是一种<code>const iterators</code></strong></li>
<li><code>set</code>类似<code>list</code>，当客户端对其进行元素的新增或者删除操作的时候，<strong>操作之前的迭代器不会失效，但是被操作的迭代器会失效</strong></li>
<li>STL提供了一组<code>set/multiset</code>的相关算法，包括交集<code>set_intersection</code><code>set_union</code><code>set_difference</code><code>set_symmetric_difference</code></li>
<li><code>set</code>利用<code>RB-tree</code>的排序机制，因此是基于红黑树进一步的函数封装</li>
</ul>
<h6 id="set源码">5.2.1 set源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> set&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">    <span class="comment">//注意key_compare 和 value_compre 使用同一个比较函数</span></span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,identify&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">    rep_type t; <span class="comment">//使用红黑树(RB-Tree)实现set</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">    <span class="comment">//set迭代器无法执行写入操作，因为set的元素有一定的次序安排，不允许用户在任意处进行写入操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_uterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    <span class="comment">//allocation/deallocation</span></span><br><span class="line">    <span class="comment">//set使用RB-Tree的insert_unique() 要求插入的元素都不可以重复</span></span><br><span class="line">    <span class="comment">//multiset 使用 insert_equal() 允许相同键值的存在</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">set</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(InputIterator first,InputIterator last)</span> : t(Compare())&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">set</span>(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x):<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">    set&lt;Key,Compare,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">        t = x.t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//set进行函数的包装</span></span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="comment">//需要注意 set使用的value_comp 事实上为RB-Tree的key_comp()</span></span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(set&lt;Key,Compare,Alloc&gt;&amp; x)</span></span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//insert / erase</span></span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;iterator,<span class="type">bool</span>&gt;pair_iterator_bool;</span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">        std::pair&lt;<span class="keyword">typename</span> rep_type::iterator,<span class="type">bool</span>&gt; p = t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(p.first,p.second);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position,<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>((rep_iterator&amp;)position,x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first,InputIterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        t.<span class="built_in">erase</span>((rep_iterator&amp;)position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        t.<span class="built_in">erase</span>((rep_iterator&amp;)first,(rep_iterator&amp;)last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set operations</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">count</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    std::pair&lt;iterator,iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下的__STL_NULL_TMPL_ARGS 被定义为&lt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;,<span class="type">const</span> set&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;,<span class="type">const</span> set&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="map">5.3 map</h5>
<ul>
<li>所有元素会根据元素的键值自动被排序</li>
<li>元素的类型是<code>pair</code>，同时拥有键值和实值；<code>map</code>不允许两个元素出现相同的键值</li>
<li>不可以修改<code>map</code>的键值 但是可以修改实值</li>
<li><code>map</code>基于红黑树实现对应的函数</li>
<li><code>map</code>和<code>set</code>一样，操作和删除操作时，操作之前的迭代器在操作之后依然有效</li>
</ul>
<h6 id="pair类型的定义">5.3.1 pair类型的定义</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    T1 first;    <span class="comment">//public</span></span><br><span class="line">    T2 second;  <span class="comment">//public</span></span><br><span class="line">    <span class="built_in">pair</span>():<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a,<span class="type">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="map源码">5.3.2 map源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> map&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;<span class="comment">//键值型别</span></span><br><span class="line">    <span class="keyword">typedef</span> T data_type;<span class="comment">//数据(实值)型别</span></span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;<span class="type">const</span> Key,T&gt;value_type; <span class="comment">//元素型别(键值/实值)</span></span><br><span class="line">    <span class="comment">//键值比较函数</span></span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="comment">//以下定义一个functor 其作用就是调用&quot;元素比较函数&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">value_compare</span> : <span class="keyword">public</span> std::binary_function&lt;value_type,value_type,<span class="type">bool</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>&lt;Key,T,Compare,Alloc&gt;;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Compare comp;</span><br><span class="line">        <span class="built_in">value_compare</span>(Compare c):<span class="built_in">comp</span>(c)&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> value_type&amp; x,<span class="type">const</span> value_type&amp; y)</span><span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">comp</span>(x.first,y.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//定义表述型别 使用map元素的型别(pair)作为第一性别，作为红黑树节点的键值型别</span></span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,_Select1st&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">    rep_type t; <span class="comment">//使用红黑树(RB-Tree)实现map</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">    <span class="comment">//map迭代器无法执行写入操作，因为map的元素有一定的次序安排，不允许用户在任意处进行写入操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reverse_iterator reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    <span class="comment">//allocation/deallocation</span></span><br><span class="line">    <span class="comment">//map使用RB-Tree的insert_unique() 要求插入的元素都不可以重复</span></span><br><span class="line">    <span class="comment">//multimap 使用 insert_equal() 允许相同键值的存在</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">map</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">map</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">map</span><span class="params">(InputIterator first,InputIterator last)</span> : t(Compare())&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">map</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">map</span>(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x):<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">    map&lt;Key,Compare,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">        t = x.t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//map进行函数的包装</span></span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="comment">//需要注意 map使用的value_comp 事实上为RB-Tree的key_comp()</span></span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">value_compare</span>(t.<span class="built_in">key_comp</span>());&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span>  </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">    <span class="comment">//注意以下 下标操作符号</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k)&#123;</span><br><span class="line">        <span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k,<span class="built_in">T</span>()))).first)).second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(map&lt;Key,Compare,Alloc&gt;&amp; x)</span></span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//insert / erase</span></span><br><span class="line"><span class="comment">//    typedef std::pair&lt;iterator,bool&gt;pair_iterator_bool;</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position,<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(position,x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first,InputIterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map operations</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">count</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    std::pair&lt;iterator,iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;const_iterator,const_iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//以下的__STL_NULL_TMPL_ARGS 被定义为&lt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> map&amp;,<span class="type">const</span> map&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> map&amp;,<span class="type">const</span> map&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="multisetmap">5.3.3 multiset/map</h6>
<p><code>muiltiset\multimap</code>和它们对应的<code>set\map</code>特性完全相同，唯一不同点时<code>multi</code>允许键值重复，因此插入采用的时<code>RB-tree</code>的底层函数的<code>insert_equal()</code>而不是<code>insert_unique()</code>。</p>
<h5 id="hashtable">5.4 hashtable</h5>
<p>上面介绍的是以<code>RB-tree</code>为底层机制的容器，其在有序性和查找的性能(<code>logn</code>)上都不错。但还有一种在查找上的时间复杂度可在常数内完成的结构，那就是哈希表即：</p>
<ul>
<li>二叉搜索树具有对数平均时间的表现，<strong>但是这个需要满足的假设前提是输入的数据需要具备随机性</strong></li>
<li><code>hashtable</code>散列表这种结构在插入、删除、搜寻等操作层面上也具有常数平均时间的表现。<strong>而且不需要依赖元素的随机性，这种表现是以统计为基础的</strong></li>
</ul>
<p><strong>哈希表的特点：</strong></p>
<ul>
<li><code>hashtable</code>可提供对任何有名项的存取和删除操作</li>
<li>因为操作的对象是有名项，因此<code>hashtable</code>可以作为一种字典结构</li>
<li><strong>将一个元素映射成为一个 “大小可以接受的索引”简称为<code>hash function</code>散列函数</strong></li>
<li>考虑到元素的个数大于<code>array</code>的容量，<strong>可能有不同的元素被映射到相同的位置，简称为冲突</strong></li>
<li>解决冲突的方法有很多，线性探测、二次探测、<strong>开链</strong></li>
</ul>
<p>具体的hash思想可见<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构篇</a>，在<code>SGI STL</code>版本的<code>hash_table</code>使用的是<strong>开链法</strong>来解决哈希冲突,节点结构体如下： <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/hashtablelist.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_node</span>&#123;</span><br><span class="line">    __hashtable_node* next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="hashtable的迭代器">5.4.1 hashtable的迭代器</h6>
<ul>
<li><code>hashable</code>迭代器维持着与整个<code>buckets vector</code>的关系，并记录目前所指的节点</li>
<li>前进操作是从目前节点出发前进一个位置，由于节点被安置于<code>list</code>内，使用<code>next</code>进行前进操作</li>
<li><strong>如果目前是<code>list</code>的尾端，则跳转至下一个<code>bucket</code>上，正是指向下一个<code>list</code>的头部</strong></li>
<li><strong><code>hashtable</code>的迭代器没有后退操作，<code>hashtable</code>没有定义所谓的逆向迭代器</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">ExtractKey</span>,<span class="keyword">class</span> <span class="title class_">EqualKey</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_iterator</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;hashtable;</span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_iterator&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;iterator;</span><br><span class="line"><span class="comment">//    typedef __hash_const   静态迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt;node;</span><br><span class="line">    <span class="keyword">typedef</span> std::forward_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> Value* pointer;</span><br><span class="line"></span><br><span class="line">    node* cur;<span class="comment">// 迭代器目前所指的节点</span></span><br><span class="line">    hashtable* ht;<span class="comment">//保持对容器的连接关系 (因为可能需要从bucket跳到bucket)</span></span><br><span class="line">    __hashtable_iterator(node*n,hashtable* tab):<span class="built_in">cur</span>(n),<span class="built_in">ht</span>(tab)&#123;&#125;</span><br><span class="line">    __hashtable_iterator()&#123;&#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> cur-&gt;val;&#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line">    iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; it)<span class="type">const</span> &#123;<span class="keyword">return</span> cur == it.cur;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; it)<span class="type">const</span> &#123;<span class="keyword">return</span> cur != it.cur;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">HF</span>,<span class="keyword">class</span> <span class="title class_">ExK</span>,<span class="keyword">class</span> <span class="title class_">EqK</span>,<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;&amp;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="type">const</span> node* old = cur;</span><br><span class="line">    cur = cur-&gt;next; <span class="comment">//如果存在 就是他，否则进入以下的if流程</span></span><br><span class="line">    <span class="keyword">if</span> (!cur)&#123;</span><br><span class="line">        <span class="comment">//根据元素的数值，定位出下一个bucket，其起头处就是我们的目的地</span></span><br><span class="line">        size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cur = ht-&gt;buckets[bucket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">HF</span>,<span class="keyword">class</span> <span class="title class_">ExK</span>,<span class="keyword">class</span> <span class="title class_">EqK</span>,<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++<span class="keyword">this</span>; <span class="comment">//调用operator++</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="hashtable的数据结构">5.4.2 hashtable的数据结构</h6>
<ul>
<li><code>buckets</code>聚合体以<code>vector</code>完成，以利动态扩充</li>
<li><strong><code>&lt;stl_hash_fun.h&gt;</code>定义数个现成的<code>hash functions</code>全都是仿函数，<code>hash function</code>计算单元的位置，也就是元素对应的<code>bucket</code>的位置。具体调用的函数是<code>bkt_num()</code>,它调用<code>hash function</code>取得一个可以执行<code>modulus</code>(取模)运算的数值</strong>，以上的目的是出于 有些元素的型别是无法直接对其进行取模运算的，比如字符串类型 。</li>
<li>按照质数设计<code>vector</code>的大小，事先准备好<code>28</code>个质数，并设计一个函数用于查询最接近某数并大于某数的质数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Key:         节点的实值类型</span></span><br><span class="line"><span class="comment"> * Value:       节点的键值类型</span></span><br><span class="line"><span class="comment"> * HashFun:     hash function的函数型别</span></span><br><span class="line"><span class="comment"> * ExtractKey:  从节点中提取键值的方法 (函数或者仿函数)</span></span><br><span class="line"><span class="comment"> * EqualKey:    判断键值是否相同 (函数或者仿函数)</span></span><br><span class="line"><span class="comment"> * Alloc:       空间配置器 缺省使用 std::alloc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">ExtractKey</span>,<span class="keyword">class</span> <span class="title class_">EqualKey</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> HashFcn hasher;    <span class="comment">//为template型别参数重新定义一个名称</span></span><br><span class="line">    <span class="keyword">typedef</span> EqualKey key_equal;<span class="comment">//为template型别参数重新定义一个名称</span></span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//以下三者都是function objects</span></span><br><span class="line">    <span class="comment">//&lt;stl_hash_fun.h&gt; 定义有数个标准型别(如 int、c-style、string等)的hasher</span></span><br><span class="line">    hasher hash;        <span class="comment">//散列函数</span></span><br><span class="line">    key_equal equals;   <span class="comment">//判断键值是否相等</span></span><br><span class="line">    ExtractKey get_key; <span class="comment">//从节点取出键值</span></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt;node;</span><br><span class="line">    <span class="comment">//专属的节点配置器</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;node,Alloc&gt;node_allocator;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点的配置函数</span></span><br><span class="line">    <span class="function">node* <span class="title">new_node</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        node* n = node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">        n-&gt;next = <span class="number">0</span>;</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            Chy::allocator&lt;Key&gt;::<span class="built_in">construct</span>(&amp;n-&gt;val,obj);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(node_allocator::<span class="built_in">deallocate</span>(n);)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点释放函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delete_node</span><span class="params">(node* n)</span></span>&#123;</span><br><span class="line">        Chy::allocator&lt;Key&gt;::<span class="built_in">destroy</span>(n-&gt;val);</span><br><span class="line">        node_allocator::<span class="built_in">deallocate</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;node*,Alloc&gt;buckets;<span class="comment">//以vector完成桶的集合，其实值是一个node*</span></span><br><span class="line">    size_type num_elements;  <span class="comment">//node的个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bucket个数 即buckets vector的大小</span></span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buckets.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//注意假设 假设long至少有32bit</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">53</span>,         <span class="number">97</span>,         <span class="number">193</span>,       <span class="number">389</span>,       <span class="number">769</span>,</span><br><span class="line">        <span class="number">1543</span>,       <span class="number">3079</span>,       <span class="number">6151</span>,      <span class="number">12289</span>,     <span class="number">24593</span>,</span><br><span class="line">        <span class="number">49157</span>,      <span class="number">98317</span>,      <span class="number">196613</span>,    <span class="number">393241</span>,    <span class="number">786433</span>,</span><br><span class="line">        <span class="number">1572869</span>,    <span class="number">3145739</span>,    <span class="number">6291469</span>,   <span class="number">12582917</span>,  <span class="number">25165843</span>,</span><br><span class="line">        <span class="number">50331653</span>,   <span class="number">100663319</span>,  <span class="number">201326611</span>, <span class="number">402653189</span>, <span class="number">805306457</span>,</span><br><span class="line">        <span class="number">1610612741</span>, <span class="number">3221225473</span>, <span class="number">4294967291</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//找出上述28指数中，最接近并大于n的那个质数</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_next_prime(<span class="type">unsigned</span> <span class="type">long</span> n)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *first = __stl_prime_list;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *pos = std::<span class="built_in">lower_bound</span>(first,last,n);</span><br><span class="line">        <span class="comment">//使用lower_bound() 需要先进行排序</span></span><br><span class="line">        <span class="keyword">return</span> pos == last ? *(last<span class="number">-1</span>) : *pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//总共有多少个buckets。以下是hash_table的一个member function</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">//其数值将为 4294967291</span></span><br><span class="line">        <span class="keyword">return</span> __stl_prime_list[__stl_num_primes - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">hashtable</span>(size_type n,<span class="type">const</span> HashFcn&amp; hf,<span class="type">const</span> EqualKey&amp; eql)</span><br><span class="line">    :<span class="built_in">hash</span>(hf),<span class="built_in">equals</span>(eql),<span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()),<span class="built_in">num_elements</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//例子：传入50 返回53</span></span><br><span class="line">        <span class="comment">//然后保留53个元素的空间 然后将其全部填充为0</span></span><br><span class="line">        <span class="type">const</span> size_type n_buckets = <span class="built_in">next_size</span>(n);</span><br><span class="line">        buckets.<span class="built_in">reserve</span>(n_buckets);</span><br><span class="line">        <span class="comment">//设定所有的buckets的初值为0(node*)</span></span><br><span class="line">        buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">begin</span>(),n_buckets,(node*)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//------------------------------bkt_num函数---------------------------</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//版本1：接受实值（value）和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj), n); <span class="comment">//调用版本4</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本2：只接受实值（value）</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj)); <span class="comment">//调用版本3</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本3，只接受键值</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(key, buckets.<span class="built_in">size</span>()); <span class="comment">//调用版本4</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本4：接受键值和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % n; <span class="comment">//SGI的所有内建的hash()，在后面的hash functions中介绍</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//相关对应的函数</span></span><br><span class="line">    <span class="comment">//next_size()返回最接近n并大于n的质数</span></span><br><span class="line">    <span class="function">size_type <span class="title">next_size</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __stl_next_prime(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;iterator;</span><br><span class="line">    <span class="comment">//插入操作和表格重整</span></span><br><span class="line">    <span class="comment">//插入元素不允许重复</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type&amp; obj)&#123;</span><br><span class="line">        <span class="comment">//判断是否需要重建表格  如果需要就进行扩充</span></span><br><span class="line">        <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//函数判断是否需要重建表格 如果不需要立刻返回，如果需要 就重建表格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type num_elements_hint)</span></span>&#123;</span><br><span class="line">        <span class="comment">//表格重建与否的原则是：元素的个数(新增元素计入之后)和先前分配的bucket vector进行比较</span></span><br><span class="line">        <span class="comment">//如果前者的大于后者 就需要表格的重建</span></span><br><span class="line">        <span class="comment">//因此 bucket(list)的最大容量和buckets vector的大小相同</span></span><br><span class="line">        <span class="type">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (old_n &lt; num_elements_hint)&#123;</span><br><span class="line">            <span class="comment">//需要重新分配内存</span></span><br><span class="line">            <span class="comment">//计算下一个质数</span></span><br><span class="line">            <span class="type">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; old_n)&#123;</span><br><span class="line">                std::vector&lt;node*,Alloc&gt;<span class="built_in">tmp</span>(n,(node*)<span class="number">0</span>);</span><br><span class="line">                __STL_TRY&#123;</span><br><span class="line">                    <span class="comment">//处理每一个旧的bucket</span></span><br><span class="line">                    <span class="keyword">for</span> (size_type bucket=<span class="number">0</span>;bucket&lt;old_n;bucket++) &#123;</span><br><span class="line">                        <span class="comment">//指向节点所对应的的串行的起始节点</span></span><br><span class="line">                        node* first = buckets[bucket];</span><br><span class="line">                        <span class="comment">//处理每一个旧的bucket所含(串行)的每一个节点</span></span><br><span class="line">                        <span class="keyword">while</span>(first)&#123;</span><br><span class="line">                            <span class="comment">//串行节点还未结束</span></span><br><span class="line">                            <span class="comment">//找出节点落在哪一个新的bucket内部</span></span><br><span class="line">                            size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val,n);</span><br><span class="line">                            <span class="comment">//以下四个操作颇为巧妙</span></span><br><span class="line">                            <span class="comment">//(1)令旧bucket指向其所对应的串行的下一个节点(以便迭代处理)</span></span><br><span class="line">                            buckets[bucket] = first-&gt;next;</span><br><span class="line">                            <span class="comment">//(2)(3)将当前节点插入到新的bucket内部，成为其对应串行的第一个节点</span></span><br><span class="line">                            first-&gt;next = tmp[new_bucket];</span><br><span class="line">                            tmp[new_bucket] = first;</span><br><span class="line">                            <span class="comment">//(4)回到旧的bucket所指向的待处理的串行，准备处理下一个节点</span></span><br><span class="line">                            first = buckets[bucket];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//对调新旧两个buckets</span></span><br><span class="line">                    <span class="comment">//离开的时候会释放tmp的内存</span></span><br><span class="line">                    buckets.<span class="built_in">swap</span>(tmp);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要重建表格的情况下插入新的节点 键值不允许重复</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert_unique_noresize</span>(<span class="type">const</span> value_type&amp; obj)&#123;</span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj) ;<span class="comment">//决定obj应该位于 第n n bucket</span></span><br><span class="line">        node* first = buckets[n]; <span class="comment">//令first指向bucket对应的串行头部</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果Buckets[n]已经被占用 此时first不再是0 于是进入以下循环</span></span><br><span class="line">        <span class="comment">//走过bucket所对应的整个链表</span></span><br><span class="line">        <span class="keyword">for</span> (node* cur = first;cur;cur = cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val)),<span class="built_in">get_key</span>(obj))&#123;</span><br><span class="line">                <span class="comment">//如果发现和链表中的某个键值是相同的 就不插入 立刻返回</span></span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//离开上述循环(或者根本没有进入循环的时候)first指向bucket的所指链表的头部节点</span></span><br><span class="line">            node* tmp = <span class="built_in">new_node</span>(obj); <span class="comment">//产生新的节点</span></span><br><span class="line">            tmp-&gt;next = first;</span><br><span class="line">            buckets[n] = tmp; <span class="comment">//令新的节点成为链表的第一个节点</span></span><br><span class="line">            ++num_elements;   <span class="comment">//节点的个数累加</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(tmp,<span class="keyword">this</span>),<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//客户端执行的是另外一种节点的插入行为(不再是insert_unique 而是insert_equal)</span></span><br><span class="line">    <span class="comment">//插入元素 允许重复</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否需要重建表格 如果需要就进行扩充</span></span><br><span class="line">        <span class="built_in">resize</span>(num_elements+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要重建表格的情况下 插入新的节点，键值是允许重复的</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj); <span class="comment">//决定obj应该位于第 n bucket</span></span><br><span class="line">        node* first = buckets[n];<span class="comment">//令first指向的bucket对应的链表的头部</span></span><br><span class="line">        <span class="comment">//如果bucket[n]已经被占用，此时的first不为0，进入循环</span></span><br><span class="line">        <span class="comment">//遍历整个链表</span></span><br><span class="line">        <span class="keyword">for</span>(node* cur = first;cur;cur = cur-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val),<span class="built_in">get_key</span>(obj)))&#123;</span><br><span class="line">                <span class="comment">//如果发现与链表中的某个键值相同，就马上插入，然后返回</span></span><br><span class="line">                node* tmp = <span class="built_in">new_node</span>(obj);  <span class="comment">//产生新的节点</span></span><br><span class="line">                tmp-&gt;next = cur-&gt;next;<span class="comment">//新节点插入目前的位置</span></span><br><span class="line">                cur-&gt;next = tmp;</span><br><span class="line">                ++num_elements;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">iterator</span> (tmp, <span class="keyword">this</span>); <span class="comment">//返回一个迭代器 指向新增的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行到这个时候 表示没有发现重复的数值</span></span><br><span class="line">            node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">            tmp-&gt;next = first;</span><br><span class="line">            buckets[n] = tmp;</span><br><span class="line">            ++num_elements;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//针对每一个bucket</span></span><br><span class="line">        <span class="keyword">for</span>(size_type i = <span class="number">0</span>;i &lt; buckets.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            node * cur = buckets[i];</span><br><span class="line">            <span class="comment">//删除bucket list中的每一个节点</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="number">0</span>)&#123;</span><br><span class="line">                node* next = cur-&gt;next;</span><br><span class="line">                <span class="built_in">delete_node</span>(cur);</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            buckets[i] = <span class="number">0</span>; <span class="comment">//令buckets内容为null</span></span><br><span class="line">        &#125;</span><br><span class="line">        num_elements = <span class="number">0</span>; <span class="comment">//令总的节点的个数为0</span></span><br><span class="line">        <span class="comment">//需要注意 buckets vector并没有释放空间，仍然保存先前的大小</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy_from</span><span class="params">(<span class="type">const</span> hashtable&amp; ht)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先清除己方的buckets vector，此操作是调用vector::clear() 造成所有的元素都为0</span></span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">//为己方的buckets vector保留空间，使与对方相同</span></span><br><span class="line">        <span class="comment">//如果己方的空间大于对方 就不需要改变；如果己方的空间小于对方 就会增大</span></span><br><span class="line">        buckets.<span class="built_in">reserve</span>(ht.buckets.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//从己方的buckets vector尾端开始，插入n个元素，其数值为 null 指针</span></span><br><span class="line">        <span class="comment">//注意此时buckets vector为空，所谓的尾端就是起头处</span></span><br><span class="line">        buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(),ht.buckets.<span class="built_in">size</span>(),(node*)<span class="number">0</span>);</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            <span class="comment">//针对buckets vector</span></span><br><span class="line">            <span class="keyword">for</span> (size_type i = <span class="number">0</span>;i&lt;ht.buckets.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">                <span class="comment">//复制vector的每一个元素(是一个指针，指向hashtable节点)</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="type">const</span> node* cur = ht.buckets[i])&#123;</span><br><span class="line">                    node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">                    buckets[i] = copy;</span><br><span class="line">                    <span class="comment">//针对同一个 buckets list 复制每一个节点</span></span><br><span class="line">                    <span class="keyword">for</span> (node* next = cur-&gt;next;next ; cur = next,next = cur-&gt;next) &#123;</span><br><span class="line">                        copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">                        copy = copy-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新登录的节点的个数(hashtable的大小)</span></span><br><span class="line">            num_elements = ht.num_elements;</span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>STL中哈希表一般不要外部使用，它是实现<code>hash_map</code>和<code>hash_set</code>的底层机制，编程者可以使用它们。</p>
<h5 id="hash_set">5.5 hash_set</h5>
<p>同set一样，单独以键存储。<code>hash_set</code>是以<code>hashtable</code>为底层机制，因此存储数无序的，而<code>set</code>有序。同时其所供应的接口大部分都是转调用<code>hashtable</code>的函数。<code>hash_set</code>的使用方式与<code>set</code>差不多一样.</p>
<h6 id="hash_set源码">5.5.1 hash_set源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_INTERNAL_HASH_SET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SGI_STL_INTERNAL_HASH_SET_H</span></span><br><span class="line"></span><br><span class="line">__STL_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> set woff 1174</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Value&gt;,</span><br><span class="line">          <span class="keyword">class</span> EqualKey = equal_to&lt;Value&gt;,</span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> EqualKey, <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> hash_set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;Value, Value, HashFcn, identity&lt;Value&gt;, </span><br><span class="line">                    EqualKey, Alloc&gt; ht;</span><br><span class="line">  ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equal key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hash_set</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hash_set</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equal()) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_set&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_set&amp;,</span><br><span class="line">                                               <span class="type">const</span> hash_set&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique</span>(obj);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span> </span>&#123;</span><br><span class="line">    rep.<span class="built_in">insert_unique</span>(f,l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator f, const_iterator l)</span> </span>&#123;rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="hash_map">5.6 hash_map</h5>
<p>同map一样以键值对形式存储，但其底层机制为<code>hashtable</code>，因此大部分情况支持常数时间复杂度访问，存储是无序的。使用方式与<code>map</code>相差不大</p>
<h6 id="hash_map源码">5.6.1 hash_map源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> set woff 1174</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> EqualKey = equal_to&lt;Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> EqualKey, </span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> hash_map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;pair&lt;<span class="type">const</span> Key, T&gt;, Key, HashFcn,</span><br><span class="line">                    select1st&lt;pair&lt;<span class="type">const</span> Key, T&gt; &gt;, EqualKey, Alloc&gt; ht;</span><br><span class="line">  ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">  <span class="keyword">typedef</span> T data_type;</span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equal key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::iterator iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hash_map</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hash_map</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equal()) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_map&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span></span><br><span class="line">  <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_map&amp;, <span class="type">const</span> hash_map&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(obj); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span> </span>&#123;</span><br><span class="line">    rep.<span class="built_in">insert_unique</span>(f,l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator f, const_iterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique_noresize</span>(obj); &#125;    </span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; key) &#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">find_or_insert</span>(<span class="built_in">value_type</span>(key, <span class="built_in">T</span>())).second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line">  <span class="function">pair&lt;const_iterator, const_iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="各个容器的适用场景">6. 各个容器的适用场景</h4>
<ul>
<li>1）<code>vector</code>的使用场景：只查看，而不频繁插入删除的，因为频繁插入删除会造成内存的不断搬家和删除。使用场景比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录。</li>
<li>2）<code>deque</code>的使用场景：比如排队购票系统，对排队者的存储可以采用<code>deque</code>，支持头端的快速移除，尾端的快速添加。如果采用<code>vector</code>，则头端移除时会移动大量的数据，速度慢。<code>vector</code>与<code>deque</code>的比较：
<ul>
<li>一：<code>vector.at()</code>比<code>deque.at()</code>效率高，比如<code>vector.at(0)</code>是固定的，<code>deque</code>的开始位置却是不固定的。</li>
<li>二：如果有大量释放操作的话，<code>vector</code>花的时间更少，这跟二者的内部实现有关。</li>
<li>三：<code>deque</code>支持头部的快速插入与快速移除，这是<code>deque</code>的优点。</li>
</ul></li>
<li><code>list</code>的使用场景：频繁的插入删除的场景，这时也可以使用queue和deque。使用场景比如公交车乘客的存储，随时可能有乘客上下车，支持频繁的不确实位置元素的移除插入删除。</li>
<li><code>set</code>的使用场景：大部分负责查找内容且要求有序的情况下。使用场景比如对游戏中个人得分历史记录的存储，存储要求从高分到低分的顺序排列。</li>
<li><code>map</code>的使用场景：对查找有较高的要求，使用场景比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。红黑树的查找效率，这时就体现出来了。</li>
</ul>
<h4 id="算法">7. 算法</h4>
<h5 id="stl算法分类">7.1 STL算法分类</h5>
<h6 id="质变和非质变">7.1.1 质变和非质变</h6>
<ul>
<li><strong>质变算法：</strong>是指运算过程中会更改区间内的元素的内容</li>
<li><strong>非质变算法：</strong>是指运算过程中不会更改区间内的元素内容</li>
</ul>
<h6 id="stl算法的一般形式">7.1.2 STL算法的一般形式</h6>
<p><strong>大多数算法有下列4中形式：</strong></p>
<ul>
<li><code>alg(first,last,other args);</code></li>
<li><code>alg(first,last,dest,other args);</code></li>
<li><code>alg(first,last,first2,other args);</code></li>
<li><code>alg(first,last,first2,lasst2,other args);</code></li>
</ul>
<p><strong>更一般的说法是：</strong></p>
<ul>
<li><strong>所有泛型算法的前两个参数一定是一对迭代器，通常为<code>first</code>和<code>last</code>,范围为<code>[first,last)</code></strong></li>
<li><strong>许多STL算法不止只支持一个版本，可接受仿函数<code>_if</code>结尾，如<code>find()</code>函数支持传入谓词或仿函数的<code>find_if()</code>版本</strong></li>
<li>质变算法通常会有至少提供两个版本，一个是就地进行改变操作对象的版本，<strong>另一个是<code>_copy</code>版本，拷贝一份副本，在副本上改变，如<code>replace()</code>函数就有<code>replace_copy()</code>版本</strong></li>
<li>所有的数值算法实现都在<code>&lt;stl_numeric.h&gt;，用户使用时可包含</code>#include<numeric>`调用</numeric></li>
<li>其他算法实现于<code>&lt;stl_algo.h&gt;\&lt;stl_algobase.h&gt;</code>，用户使用可通过包含<code>#include&lt;algorithm&gt;</code>调用</li>
</ul>
<h6 id="算法总览">7.1.3 算法总览</h6>
<table>
<thead>
<tr class="header">
<th>算法名称</th>
<th>算法用途</th>
<th style="text-align: center;">质变？</th>
<th>所在文件</th>
<th style="text-align: center;">所属作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>accumulate</code></td>
<td>元素求和</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_numeric.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="even">
<td><code>adjacent_difference</code></td>
<td>相邻元素差额</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_numeric.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td><code>adjacent_find</code></td>
<td>查找相邻重复(或符合条件)的元素</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>binary_search</code></td>
<td>二分查找</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>copy</code></td>
<td>复制</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="even">
<td><code>copy_backward</code></td>
<td>逆向复制</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="odd">
<td><code>copy_n</code></td>
<td>复制n个元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="even">
<td><code>count</code></td>
<td>计数</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>count_if</code></td>
<td>在特定传入的谓词或仿函数条件下计数</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>equal</code></td>
<td>判断两个区间相等与否</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">关系</td>
</tr>
<tr class="odd">
<td><code>equal_range</code></td>
<td>在有序区间寻找某值，返回一个区间</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">关系</td>
</tr>
<tr class="even">
<td><code>fill</code></td>
<td>该填元素值</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>fill_n</code></td>
<td>该填元素值，n次</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>find</code></td>
<td>循序查找</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>find_if</code></td>
<td>查找符合条件的元素</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>find_end</code></td>
<td>查找某个子序列的最后一次出现点</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>find_first_of</code></td>
<td>查找某些元素首次出现点</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>for_each</code></td>
<td>对区间的每一个元素施行某操作</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>generate</code></td>
<td>以特定操作的运算结果填充特定区间内的元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>inner_product</code></td>
<td>内积</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td><code>iter_swap</code></td>
<td>元素互换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td><code>lower_bound</code></td>
<td>返回有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>max</code></td>
<td>最大值</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>max_element</code></td>
<td>最大值所在位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>min</code></td>
<td>最小值</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>min_element</code></td>
<td>最小值所在位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>merge</code></td>
<td>合并两个序列</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>inplace_merge</code></td>
<td>合并且就地替换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>random_shuffle</code></td>
<td>随机重排元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>remove</code></td>
<td>删除某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="odd">
<td><code>remove_copy</code></td>
<td>删除某类元素并将结果存储都另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="even">
<td><code>remove_if</code></td>
<td>有条件的删除某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="odd">
<td><code>remove_copy_if</code></td>
<td>有条件的删除某类元素，并将结果存储到另外一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="even">
<td><code>replace</code></td>
<td>替换某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="odd">
<td><code>replace_copy</code></td>
<td>替换某类元素，并将结果存储到另一个元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="even">
<td><code>replace_if</code></td>
<td>有条件的替换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="odd">
<td><code>replace_copy_if</code></td>
<td>有条件的替换，并将结果存储都另一个容q器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="even">
<td><code>reverse</code></td>
<td>反转</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="odd">
<td><code>reverse_copy</code></td>
<td>反转并把结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="even">
<td><code>rotate</code></td>
<td>旋转</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">旋转</td>
</tr>
<tr class="odd">
<td><code>rotate_copy</code></td>
<td>旋转，并把结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;sta_algo.h&gt;</code></td>
<td style="text-align: center;">旋转</td>
</tr>
<tr class="even">
<td><code>search</code></td>
<td>查找某个子序列</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>search_n</code></td>
<td>查找连续发生n次的某个子序列</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>sort</code></td>
<td>排序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">排序</td>
</tr>
<tr class="odd">
<td><code>stable_sort</code></td>
<td>排序并保持等值元素的相对次序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">排序</td>
</tr>
<tr class="even">
<td><code>stable_partition</code></td>
<td>分割并保存元素的相对次序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">分割</td>
</tr>
<tr class="odd">
<td><code>swap</code></td>
<td>交换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td><code>swap_ranges</code></td>
<td>指定区间的交换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="odd">
<td><code>unique</code></td>
<td>去重</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">去重</td>
</tr>
<tr class="even">
<td><code>unique_copy</code></td>
<td>去重后的结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">去重</td>
</tr>
<tr class="odd">
<td><code>upper_bound</code></td>
<td>返回有序序列范围内的可以插入指定值而不破坏容器顺序的最后位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>make_heap</code></td>
<td>创建一个堆</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="odd">
<td><code>pop_heap</code></td>
<td>从堆取元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="even">
<td><code>push_heap</code></td>
<td>将元素插入堆</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="odd">
<td><code>sort_heap</code></td>
<td>堆heap排序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
</tbody>
</table>
<h5 id="sort">7.2 sort</h5>
<h6 id="适用容器">7.2.1 适用容器</h6>
<p><code>sort()</code>算法是最复杂堆庞大的一个，<strong>这个算法接受两个<code>RandomAccessIterator</code>迭代器，然后将区间内的元素由小到大重新排列</strong>。第二个版本则允许用户传入<strong>谓词或者仿函数</strong>作为排序条件，指定按什么规则排序。适用<code>sort</code>算法的容器有<code>vecror\deque</code>。</p>
<p><strong><em>附</em></strong>：因为关联容器的底层机制，根本不需要<code>sort</code>排序，<code>stack\queue\priority_queue</code>对进出的机制也要求不需排序，而<code>list</code>的迭代器为<code>BidirectinalIterator</code>不适用。</p>
<h6 id="sort实现的原理">7.2.2 sort实现的原理</h6>
<p>早期的STL <code>sort()</code>算法都是采用<strong>快排</strong>来实现，对于快排平均的时间复杂度为<code>O(NlogN)</code>,但是最坏的情况却会达到<code>O(N*N)</code>，<strong>因此现今的<code>STL SGI</code>改用<code>IntroSort</code>即内观排序算法，极其类似于<code>median-three QuickSort</code>三数取中快速排序算法。这种算法即使在最坏的情况下推进到<code>O(NlogN)</code>。</strong>快排的最坏情况的发生与快速排序中基准点的选择是有重大的关系，当出现下面两种情况时性能最差:</p>
<ul>
<li>在分解时每次选取的基准点为最小元素</li>
<li>在分解时每次选取的基准点为最大元素</li>
</ul>
<p><strong>快排的过程：</strong></p>
<ul>
<li>如果序列中的元素个数为0或1，结束</li>
<li>取序列中的任何一个元素，一般会取该段序列的头或者尾元素作为基准点<code>pivot</code></li>
<li>将序列分类<code>L\R</code>两段子序列，使L内的每一个元素都小于或等于基准点，R内的每一个元素都大于等于基准点</li>
<li>对<code>L\R</code>递归执行<code>QuickSort</code>,重复上述操作</li>
</ul>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/quickSort.gif" width="600"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写自己的quickSort,没有优化，遇到最坏情况的时间复杂度会变成O(N*N)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--;</span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="三点取中优化方案">7.2.3 三点取中优化方案</h6>
<p>为了避免快排出现上述所说的最坏情况，选择哪一个元素作为基准点是关键，<strong>在快排过程中采用三点取中间值的优化方案。三数取中<code>median-of-three</code>指的是在挑选基准元素时，不是简单的选择数组中的第一个元素或最后一个，而是选取某三个元素，常选头、尾和中央三个元素，并且适用三个元素之中的中位数作为基准元素进行划分</strong>。这样即使在最坏的情况下将时间复杂度推进到<code>O(NlogN)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后的快排代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">medianOfThree</span>(a, first, (first + last) / <span class="number">2</span>, last);</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--; </span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cap[first] &lt; cap[mid])</span><br><span class="line">        <span class="keyword">if</span> (cap[first] &gt;= cap[last])	<span class="comment">//last=&lt;first&lt;mid</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&lt;mid&lt;last</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[mid];</span><br><span class="line">            cap[mid] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">// first&lt;last&lt;=mid</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[last];</span><br><span class="line">            cap[last] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[first] &lt; cap[last])	<span class="comment">//last&gt;first&gt;=mid</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&gt;=mid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[last];</span><br><span class="line">        cap[last] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[mid];</span><br><span class="line">        cap[mid] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数值算法">7.3 数值算法</h5>
<p>数值算法都在头文件<code>&lt;numeric&gt;</code>中，实现于<code>&lt;stl_numeric.h&gt;。 ###### 7.3.1 accumulate</code>accumulate`算法用来计算指定区间的和，需要提供额外参数指定累加到哪一个初始值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init)</span></span>;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T，<span class="keyword">class</span> BinaryOperation &gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init,</span></span></span><br><span class="line"><span class="params"><span class="function">	BinaryOperation binary_op)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="power">7.3.2 power</h6>
<p>计算某数的n次方幂，该算法四<code>SGI</code>版本特有算法。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Integer&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">power</span><span class="params">(T x,Integer n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="adjacent_difference">7.3.3 adjacent_difference</h6>
<p>算法<code>adjacent_difference</code>用来计算[first,last)中相邻元素的差额，即它会将<code>*first</code>赋值给<code>*result</code>，并针对[first,last)内的每个迭代器<code>i</code>,进行<code>*i-*(i-1)</code>，然后赋值给<code>*++result</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InpueIterator,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="基本算法">7.4 基本算法</h5>
<p>对于SGI版本,它会把常用的一些算法定义在<code>&lt;stl_algobase.h&gt;</code>,使用时包含<code>&lt;algorithm&gt;</code>即可。</p>
<h5 id="equal">7.4.1 equal</h5>
<p>如果两个序列在<code>[first,lasst)</code>区间内相等，<code>equal</code>会返回<code>true</code>。如果第二序列元素多，则剩余元素不考虑，一般调用前要先保证元素个数一样。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator1,<span class="keyword">class</span> InputIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(InpueIterator1 first1,InpueIterator1 last1,InpueIterator1 first2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="fill">7.4.2 fill</h6>
<p>将<code>[first,last)</code>内的元素该填新值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(ForwardIterator first,ForwardIterator last,<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">###### <span class="number">7.4</span><span class="number">.3</span> fill_n</span><br><span class="line">将`[first,last)`的前n个改填新值，返回的迭代器指向被填入的最后一个元素的下一个位置。</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> OutputIterator,<span class="keyword">class</span> Size,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">fill_n</span><span class="params">(OutputIterator first,Size n,<span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="iter_swap">7.4.4 iter_swap</h6>
<p>该算法将两个<code>ForwardIterator</code>所指对象对调。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1,calss ForwardIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator a,ForwardIterator2 b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="copy">7.4.5 copy</h6>
<ul>
<li><code>copy()</code>算法是最最最常用的一个算法，</li>
<li><code>copy()</code>算法将输入区间的<code>[first,last)</code>的元素复制到目标区间<code>[result,result+(last-first))</code>中，执行完后返回一个迭代器，指向<code>result+(last-first)</code>。</li>
<li><code>copy</code>函数对参数非常宽松，对输入区间只需由<code>InputIterator</code>构成即可，输出区间尾<code>OutputIterator</code>构成即可，即意味着可以将任何容器的任何一段内容复制带任何容器的任何一段上，当然这些容器要由对应的迭代器。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InpueIterator,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span></span><br></pre></td></tr></table></figure>
<h6 id="copy_backward">7.4.6 copy_backward</h6>
<p>与<code>copy</code>非常相似，只不过<code>copy_backward</code>是以逆行方向复制到<code>result</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterator1,<span class="keyword">class</span> BidirectionalIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(BidirectionalIterator1 first,</span></span></span><br><span class="line"><span class="params"><span class="function">	BidirectionalIterator1,BidirectionalIterator2 result)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="其他算法">7.5 其他算法</h5>
<p>定义与<code>&lt;stl_algo.h&gt;</code>内地算法</p>
<h6 id="adjacent_find">7.5.1 adjacent_find</h6>
<p>该算法找出第一组满足条件的相邻元素，这里所谓的条件，在版本一中是指<strong>两元素相等</strong>，在版本二中允许用户指定一个二元为谓词运算，两操作数是相邻第一个元素和第二个元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first,ForwardIterator last)</span></span>;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator,<span class="keyword">class</span> BinaryPredicate&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator last,BinaryPredicate binary_pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find">7.5.2 find</h6>
<p>在<code>[first,lasy)</code>找出第一个符合匹配条件的元素，返回该元素所在位置的迭代器，未找到则返回<code>last</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_if">7.5.3 find_if</h6>
<p>传入一原谓词，根据指定的条件<code>pred</code>元素条件查找，返回该元素所在位置的迭代器，未找到则返回<code>last</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> predicate&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,predicate pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_end">7.5.4 find_end</h6>
<p>在序列一的<code>[first1,last1)</code>区间中，查找序列二<code>[first2,last2)</code>最后一次出现点，如果不存在，则返回<code>last1</code>。由两个版本，版本一默认使用<code>==</code>,版本二允许用户传入二元运算谓词。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1,<span class="keyword">class</span> ForwardIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIterator</span><span class="params">(ForwardIterator1 first1,ForwardIterator1 last1</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator2 first2,ForwardIterator2 last2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_first_of">7.5.5 find_first_of</h6>
<p>本算法以<code>[first2,last2)</code>区间内的元素作为查找目标，寻找它们在<code>[first1,last1)</code>第一次出现的位置，<strong>只要<code>[first2,last2)</code>任何一个元素第一次出现在<code>[first1,last1)</code>就返回</strong>。两个版本，一个默认使用<code>==</code>,一个允许用户指定二元谓词传入 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIterator</span><span class="params">(InputIterator first1,InputIterator last1</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator2 first2,ForwardIterator2 last2)</span></span>;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">627k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:30</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'TXhU0V217D2k9wXcjdYcmYLt-gzGzoHsz',
      appKey     : '7vt5hNdJIFoHxQb92AoWuR3E',
      placeholder: "骚言骚语",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
