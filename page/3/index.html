<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Trluper">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="trluper">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-28 13:30:57" itemprop="dateCreated datePublished" datetime="2022-07-28T13:30:57+08:00">2022-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-30 22:51:26" itemprop="dateModified" datetime="2022-07-30T22:51:26+08:00">2022-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="算法总览">1. 算法总览</h4>
<p>常见的排序算法有<strong>插入排序、选择排序、希尔排序、堆排序、冒泡排序、快速排序、归并排序和基数排序</strong>。常见排序算法可以分为两大类：</p>
<ul>
<li><strong>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破<code>O(nlogn)</code>，因此称为非线性时间比较类排序</strong>。</li>
<li><strong>线性时间非比较类排序：</strong>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。排序算法的时间复杂度如下： <img src="/排序算法/sort.png" width="700"></li>
</ul>
<p><strong>算法的稳定性：</strong>稳定性就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。</p>
<ul>
<li><strong>稳定排序算法</strong>：冒泡排序、插入排序、归并排序、计数排序、桶排序与基数排序</li>
<li><strong>不稳定排序算法</strong>：希尔排序、选择排序、堆排序与快速排序</li>
</ul>
<p><strong>内部排序和外部排序：</strong>内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。上面所列举的都是内部排序。像多路归并可以采用外部排序</p>
<h5 id="插入排序">1.1 插入排序</h5>
<ul>
<li><strong>基本思想：</strong>每次将当前元素插入到左侧（有序区）已经排序的数组中，使得插入之后的左侧数组依然有序。
<ul>
<li>查找出元素要插入的位置：要插的元素与之前排好的子序比较</li>
<li>将要插入位置的元素及后面的元素后移一个位置</li>
<li>将元素插入</li>
</ul></li>
<li><p><strong>复杂度</strong>：插入排序一共需要两重循环，第一重循环确定需要加入有序序列的新元素，一共n-1轮，第二重循环确定新元素在原来有序序列中的位置，平均需要<code>n/4</code>轮可以确定位<code>O(n²)</code>,空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性：</strong>每次比较时遇到第一个小于等于新元素的元素，就将新元素插入到该元素的后面，即可不破坏相等元素的相对顺序，做到算法稳定。 <img src="/排序算法/insertSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len== <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = cap[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; cap[j] &gt; tmp; j--)</span><br><span class="line">            cap[j + <span class="number">1</span>] = cap[j];</span><br><span class="line">        cap[j + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="希尔排序">1.2 希尔排序</h5>
<p>通过上面对插入排序程序的编写知道，插入排序适用于基本有序和数据量不大的排序表，<strong>希尔排序</strong>是基于这两点改进而来的。</p>
<ul>
<li><p><strong>基本思想</strong>：先将待排序表分割成若干形如 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">L</span>[i,i+d,i+<span class="number">2</span>d……,i+kd]</span><br></pre></td></tr></table></figure> 既把步长相隔增量d的记录组成一个子表，对各个子表分别进行直接插入排序。当整个表的元素已呈<strong>“基本有序”</strong>时，再次对全体记录进行一次直接插入排序。一般来说，步长取<code>d=n/2</code>，之后都已<code>1/2</code>递减。</p>
<ul>
<li>1.取一步长<code>d1&lt;n</code>，把表中全部记录分发d组</li>
<li>2.所有距离为<code>d1</code>的倍数的记录放到一组。</li>
<li>3.在各组内进行直接插入排序</li>
<li>4.取第二个步长<code>d2&lt;d1</code>，重复上述过程，直到<code>d=1</code>。</li>
<li>5.<code>d=1</code>时，再进行一次直接插入排序</li>
</ul></li>
<li><p><strong>复杂度：</strong>希尔排序的时间复杂度会随着<code>d</code>选取策略的不同而发生变化，但是通常保持在<span class="math inline">\(O(n^{1.3})~O(n^{1.5})\)</span>;希尔排序依旧属于原地排序，不需要额外的空间，所以空间复杂度与插入排序一样为<code>O(1)</code></p></li>
<li><p><strong>稳定性：</strong>虽然插入排序是稳定的排序算法，但是希尔排序因为将序列进行了拆分再进行插入排序，如此不同组中的相等元素相对位置不能保证不变，所以相等元素的相对位置会发生改变，故时不稳定排序。 <img src="/排序算法/shellSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = len / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;len ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = cap[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; cap[j] &gt; tmp; j -= d)</span><br><span class="line">                cap[j + d] = cap[j];</span><br><span class="line">            cap[j + d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="选择排序">1.3 选择排序</h5>
<p>选择排序<code>Selection-sort</code>是一种简单直观的排序算法。它的</p>
<ul>
<li><p><strong>基本思想：</strong>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始（末尾）位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></li>
<li><p><strong>复杂度：</strong>选择排序一共需要比较<code>n-1</code>轮（每轮找到最小的元素进行交换），第<code>m</code>轮比较<code>n-m</code>次，所以比较的总次数为：$ _{i=0}^{n-1}n-i <span class="math inline">\(，即为\)</span>O(N^2)<span class="math inline">\(。选择排序不需要额外的空间，故其空间复杂度为\)</span>O(1)$</p></li>
<li><p><strong>稳定性：</strong>由于选择出的元素可能会进行跨越式的交换，所以会破坏原本的顺序，所以不稳定。 <img src="/排序算法/selectionSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即使终止的选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size = cap.<span class="built_in">size</span>(); !sorted &amp;&amp; size &gt; <span class="number">1</span>; size--)</span><br><span class="line">    &#123;		<span class="comment">//每一轮size-1,最大的放在后面   </span></span><br><span class="line">        <span class="type">int</span> indexOfMax = <span class="number">0</span>;</span><br><span class="line">        sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap[indexOfMax] &lt; cap[i])		<span class="comment">//找出最大的值</span></span><br><span class="line">                indexOfMax = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sorted = <span class="literal">false</span>;	<span class="comment">//无序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Swap</span>(cap[indexOfMax], cap[size - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="冒泡排序">1.4 冒泡排序</h5>
<ul>
<li><p><strong>基本思想：</strong>从后往前（从前往后），两两比较相邻元素的值。若为逆序A[i]&lt;A[i-1]，则交换他们。每一轮将最大的放到后面（即每一次减少一次内循环）</p></li>
<li><p><strong>复杂度：</strong>冒泡排序一共需要比较<code>n-1</code>轮，第<code>m</code>轮比较<code>n-m</code>次，所以其比较总次数应为：<span class="math inline">\(\displaystyle\sum_{i=0}^{n-1}n-i\)</span>，故冒泡排序的时间复杂度为<code>O(n²)</code>。冒泡排序比较和交换的过程中不消耗额外的内存，故冒泡排序的空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性</strong>：比较时如果两个元素相等则不交换，即可做到使算法稳定 <img src="/排序算法/bubbleSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序时及时终止的冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(T&amp; cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cap.<span class="built_in">size</span>(); sorted &amp;&amp; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        sorted = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (cap[j] &gt; cap[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(cap[j], cap[j + <span class="number">1</span>]);</span><br><span class="line">                sorted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速排序">1.5 快速排序**</h5>
<ul>
<li><strong>基本思想</strong>：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。
<ul>
<li>1.选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</li>
<li>2.分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</li>
<li>3.递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</li>
</ul></li>
<li><p><strong>复杂度</strong>：<strong>快速排序的性能受到基准选择策略的影响</strong>，理论上如果每次选择基准都选择分区的第一个元素，那么这个序列越有序则时间复杂度越趋近于<code>O(n²)</code>，这是因为每次基准都是分区最大或最小的元素，那么左区间将会没有元素，而右区间将会有除了基准外的全部元素，这样就跟普通的插入排序没有区别了，<strong>因此对于快排会有优化措施</strong>。<strong>快速排序的最坏运行情况是<code>O(n²)</code>，比如说顺序数列的快排。但它的平摊期望时间是<code>O(nlogn)</code>，且<code>O(nlogn)</code> 记号中隐含的常数因子很小</strong>，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。<strong>快速排序可以实现原地排序，不需要消耗额外的内存，所以快速排序的空间复杂度为<code>O(1)</code>。</strong></p></li>
<li><p><strong>稳定性</strong>：快速排序不能保证相等元素的相对顺序不发生改变，所以不稳定。 <img src="/排序算法/quickSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写自己的quickSort,没有优化，遇到最坏情况的时间复杂度会变成O(N*N)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--;</span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="快排优化">1.5.1 快排优化</h6>
<p>对于快排，其性能受到基准选择策略的影响，当出现下面两种情况时为最坏情况：</p>
<ul>
<li>在分解时每次选取的基准点为最小元素</li>
<li>在分解时每次选取的基准点为最大元素</li>
</ul>
<p>为了避免快排出现上述所说的最坏情况，选择哪一个元素作为基准点是关键，<strong>在快排过程中采用三点取中间值的优化方案。三数取中<code>median-of-three</code>指的是在挑选基准元素时，不是简单的选择数组中的第一个元素或最后一个，而是选取某三个元素，常选头、尾和中央三个元素，并且适用三个元素之中的中位数作为基准元素进行划分</strong>。这样即使在最坏的情况下将时间复杂度推进到<code>O(NlogN)</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后的快排代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">medianOfThree</span>(a, first, (first + last) / <span class="number">2</span>, last);</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--; </span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cap[first] &lt; cap[mid])</span><br><span class="line">        <span class="keyword">if</span> (cap[first] &gt;= cap[last])	<span class="comment">//last=&lt;first&lt;mid</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&lt;mid&lt;last</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[mid];</span><br><span class="line">            cap[mid] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">// first&lt;last&lt;=mid</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[last];</span><br><span class="line">            cap[last] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[first] &lt; cap[last])	<span class="comment">//last&gt;first&gt;=mid</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&gt;=mid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[last];</span><br><span class="line">        cap[last] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[mid];</span><br><span class="line">        cap[mid] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/排序算法/quickSort.png" width="600"> 上图对优化后和优化前的快排进行了测试，很明显三数取中后对与升序和降序数组的时间得到了大大的改善，避免了最坏情况，逼近<code>O(NlogN)</code>,<strong>但是对于重复数组的优化还不能得到很好的改善，因此可以在三数取中的快排中加入以下的策略：</strong></p>
<ul>
<li><p>优化一：当待排序序列的长度分割到一定大小后，使用插入排序，这是因为对于很小部分大致有序的数组，快排不如插排效率。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</p></li>
<li><p>优化二：当待排序序列的长度分割到一定大小后如100个，使用计数排序，这样能够很明显的提升大量重复值情况下的效率</p></li>
</ul>
<h5 id="堆排序">1.6 堆排序*</h5>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个完全二叉树的结构，并同时满足堆的的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p>
<p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
<ul>
<li><strong>基本思想</strong>：
<ul>
<li><p><strong>插入：</strong>因为<strong>堆是完全二叉树，所以当加入一个元素形时，必须维持该堆仍为完全二叉树</strong>，即该新节点位置由此定下了肯定为叶子结点。接着元素插入要依据原来是大根堆还是小根堆（即不能破环该堆的性质）。把插入的元素，沿着从新节点到根节点的路径<code>i/2</code>，执行一趟冒泡操作，将新元素与其夫节点的元素比较交换，直到后者大于前者（大根堆为例）。</p></li>
<li><p><strong>删除：在大根堆中删除一个元素，其实就是删除根节点的元素</strong>。此时就需要重新组织，以便保持性质不变 。其策略是，从删除的位置开始为一个树,向下找，找到该树的最后一个叶子节点，删除该节点但保存元素到临时量；然后比较节点的左右孩子，将大的放到该根节点；这时因为大孩子的被放到根节点而成为了空(没有元素），以此类推，直到最后一个叶子我们与之前中间量保存的元素比较，完成删除排序，</p></li>
<li><p><strong>初始化：</strong>当堆刚开始时就要有n个元素，我们就要构建非空堆，我们需要在堆中执行n次插入操作。先将元素按层次插入，取位置在i=n/2的元素，如果以这个元素为根的子树是大根堆则不做操作，如果不是大根堆则从该节点开始的树进行检测替换，依次检查i-1,i-2……1</p></li>
</ul></li>
<li><p><strong>复杂度</strong>：堆排序的时间复杂度是标准的<code>O(nlogn)</code>。用数组实现堆的功能，故空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性</strong>：堆排序并不是进行线性的比较，而是根据堆的结构进行比较，所以在交换时会破坏相等元素原本的相对顺序。 <img src="/排序算法/heapSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆插入</span></span><br><span class="line"><span class="comment">该方法通过查询当前堆的大小和元素比较定位插入点，进行大根堆完全二叉树形式插入即`/2`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T&amp; heap,<span class="type">const</span> T&amp; theElement)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> currentNode=++heapsize;</span><br><span class="line">	<span class="comment">//通过比较寻找插入点，比插入值小的元素下沉</span></span><br><span class="line">	<span class="keyword">while</span>(currentNode!=<span class="number">1</span>&amp;&amp;heap[currentNode/<span class="number">2</span>]&lt;theElement)</span><br><span class="line">	&#123;</span><br><span class="line">		heap[currentNode]=heap[currentNode/<span class="number">2</span>];</span><br><span class="line">		currentNode/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入新值</span></span><br><span class="line">	heap[currenNode]=theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆删除</span></span><br><span class="line"><span class="function">templaet&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; heap)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(heapsize==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	heap[<span class="number">1</span>].~<span class="built_in">T</span>();		<span class="comment">//销毁根节点元素</span></span><br><span class="line">	T lastElement=heap[heapsize];	<span class="comment">//最后一个元素保存到临时变量</span></span><br><span class="line">	heap[heapsize--].~<span class="built_in">T</span>();			<span class="comment">//销毁最后一个元素</span></span><br><span class="line">	<span class="type">int</span> currentNode=<span class="number">1</span>,child=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;heapsize)</span><br><span class="line">	&#123;	<span class="comment">//元素进行上升</span></span><br><span class="line">		<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="comment">//判断lastElement是否可以放在heap[child]上</span></span><br><span class="line">		<span class="keyword">if</span>(lastElement&gt;=heap[child])	<span class="comment">//可以就直接退出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		heap[currentNode]=heap[child];</span><br><span class="line">		currentNode=child;</span><br><span class="line">		child*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currentNode]=lastElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(T&amp; Heap,std::<span class="type">size_t</span> _heapsize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	heapsize=_heapsize;</span><br><span class="line">	<span class="comment">//从下往上进行堆化，即从heapsize/2开始，直到root=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> root=heapsize/<span class="number">2</span>;root&gt;=<span class="number">1</span>;root--)</span><br><span class="line">	&#123;</span><br><span class="line">		T rootElement=heap[root];</span><br><span class="line">		<span class="type">int</span> child=<span class="number">2</span>*root;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;=heapsize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span>(rootElement&gt;=heap[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			heap[child/<span class="number">2</span>]=heap[child];</span><br><span class="line">			child*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[child/<span class="number">2</span>]=rootElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你也可以不用写堆排序，直接使用STL当中的<code>push_heap、pop_heap、make_heap</code>进行插入、删除和初始化一个堆。</p>
<h5 id="基数排序">1.7 基数排序*</h5>
<p>基数排序是一种<strong>非比较型整数排序算法</strong>，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<ul>
<li><strong>基本思想</strong>：基数排序排序主要通过将数字分解进行排序，如三位数的925，基数排序可通过十进制分解，将925分解成9、2、5三个数，然后依次以个位、十位、百位进行排序。<strong>在这个过程中，因为数字只有0~9,所有仅仅需要10个桶就，然后调用三次箱子排序即可</strong>：
<ul>
<li>1.将无序集合中的所有元素根据个位的大小分别分配到0-9十个桶中；</li>
<li>2.从个位为0的桶开始依据每个元素的十位将元素分配到0-9十个桶中；</li>
<li>3.每次依据的位数增加一位（百位，千位，万位），直到集合中最大的数的位数为止；</li>
<li>4.最后一次分配完成后从第0个桶开始依次取出元素，直到所有的元素被取出来，这个取出的顺序可以保证元素是从小到大的；</li>
</ul></li>
<li><p><strong>复杂度</strong>：每一次散列需要对每个元素进行分配，即n次操作，最多进行最大的数的位数轮散列分配，即k轮，所以时间复杂度为<code>O(n*k)</code>。基数排序需要<code>n+m</code>个额外空间，其中<code>n</code>为待排序集合大小，<code>m</code>为10（无负数元素）或<code>20</code>（有负数元素）</p></li>
<li><p><strong>稳定性</strong>：基数排序不会破坏相等元素的相对顺序，所以是稳定的 <img src="/排序算法/radixSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(T&amp; cap,<span class="type">int</span> place)</span> </span>&#123;	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,num=<span class="number">1</span>; i &lt; place; i++,num*=<span class="number">10</span>) &#123;<span class="comment">//num指示对哪一位进行基数排序</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">tempVec</span>(<span class="number">10</span>);<span class="comment">//二维数组，内部vector的大小看数据量 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cap.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = cap[i] / num % <span class="number">10</span>;</span><br><span class="line">            tempVec[index].<span class="built_in">push_back</span>(cap[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cap.<span class="built_in">clear</span>();		<span class="comment">//清除里面的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)		<span class="comment">//放回vec</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = tempVec[i].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (it != tempVec[i].<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cap.<span class="built_in">push_back</span>(*it);</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="归并排序">1.8 归并排序**</h5>
<ul>
<li><strong>基本思想</strong>：归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法<code>Divide and Conquer</code>的一个非常典型的应用。<strong>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序</strong>。若将两个有序表合并成一个有序表，称为二路归并。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：一是自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；二是自下而上的迭代；
<ul>
<li>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>4.重复步骤 3 直到某一指针达到序列尾；</li>
<li>5.将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul></li>
<li><p><strong>复杂度</strong>：很明显归并排序需要<code>logn</code>轮合并，每轮合并需要<code>n-1~n/2</code>次比较，所以时间复杂度为<code>O(nlogn)</code>.归并排序比较占用内存，但却是一种效率高且稳定的算法，其需要临时空间存储归并后的数据，因此空间复杂度为<code>O(N)</code></p></li>
<li><p><strong>稳定性</strong>：归并排序的合并操作并不会影响相同元素的相对顺序，故稳定。 <img src="/排序算法/mergeSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//使用迭代实现二路归并排序</span></span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(len);       <span class="comment">//合并空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)</span><br><span class="line">    &#123;   <span class="comment">//logn趟合并</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//合并相邻两子序列</span></span><br><span class="line">            <span class="type">int</span> next = j + i;</span><br><span class="line">            <span class="type">int</span> k = j;</span><br><span class="line">            <span class="keyword">while</span>(k &lt;(j+i) &amp;&amp; k&lt;len &amp;&amp; next &lt; len &amp;&amp; next &lt; (j+<span class="number">2</span>*i) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cap[k] &lt;= cap[next])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[index] = cap[k];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[index] = cap[next];</span><br><span class="line">                    next++;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k&lt;len &amp;&amp;k &lt; j + i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[index] = cap[k];</span><br><span class="line">                index++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (next &lt; len &amp;&amp; next &lt; j + <span class="number">2</span> * i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[index] = cap[next];</span><br><span class="line">                index++;</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            j = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), cap.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计数排序">1.9 计数排序</h5>
<ul>
<li><p><strong>基本思想：</strong>计数排序的核心在于<strong>将输入的数据值转化为键存储在额外开辟的数组空间中</strong>。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<strong>确定范围的整数</strong>。当输入的元素是<code>n</code>个0到k之间的整数时，它的运行时间是<code>Θ(n + k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。<strong><em>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量内存，因此堆数据范围很大的不适用，该排序算法最号应用于数据范围不大重复值多的情况</em></strong>。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>遍历数组<code>cap</code>，对值<code>i</code>作为cap的下标存入<code>+1</code>,即<code>C[i]++</code>;</li>
<li>对所有的重复值计数累加</li>
<li>从前往后遍历数组C，将对应的下标index作为值存人<code>cap</code>，并在<code>C[index]-1</code></li>
</ul></li>
<li><p><strong>复杂度</strong>：计数排序的时间复杂度与待排序元素的范围相关，其时间复杂度为<code>O(n+k)</code>,其中<code>n</code>为元素数量，<code>k</code>为元素的范围（即最大的元素与最小的元素的差加1）。计数排序需要额外开辟k个桶的空间，所以空间复杂度为<code>(k)</code>。</p></li>
<li><p><strong>稳定性</strong>：计数排序是一个非基于比较的线性时间排序算法,所以看出是一种稳定排序 <img src="/排序算法/countingSortgif.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxValue = <span class="built_in">getMaxValue</span>(cap)+<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(maxValue)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : cap)</span><br><span class="line">        tmp[i]++;</span><br><span class="line">    <span class="type">int</span> _index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxValue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (tmp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cap[_index] = i;</span><br><span class="line">            tmp[i]--;</span><br><span class="line">            _index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="桶排序">1.10 桶排序*</h5>
<ul>
<li><strong>基本思想</strong>：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：<strong>一是在额外空间充足的情况下，尽量增大桶的数量；二是使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</strong>。同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。
<ul>
<li>1.开辟m大小的空间，生成m个桶，每个桶对应一个范围；</li>
<li>2.将待排序的所有元素依次按照范围散列到对应的桶里；</li>
<li>3.对所有的桶内的元素以桶为单位排序；</li>
<li>4.从第一个桶开始依次将排好序的元素取出；</li>
</ul></li>
<li><p><strong>复杂度</strong>：对于待排序序列大小为<code>N</code>，共分为<code>M</code>个桶，<code>N</code>次循环，将每个元素装入对应的桶中。<code>M</code>次循环，对每个桶中的数据进行排序（平均每个桶有<code>N/M</code>个元素）。一般使用较为快速的排序算法，时间复杂度为 O(N/MlogN/M)，整个桶排序的时间复杂度为：<code>O(N)+O(M∗(N/M∗log(N/M))) = O(N)+O(N∗(log(N/M)) = O(N)+O(C）= O(N∗(log(N/M)+1))</code>；桶排序需要额外的m个桶的空间和n个元素的空间，故空间复杂度为<code>O(m+n)</code>。</p></li>
<li><p><strong>稳定性</strong>：桶排序的稳定性取决于桶内排序使用的算法，所以我们通常认为桶排序是稳定排序。 <img src="/排序算法/bucketSort.png" width="400"></p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/18/Makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/18/Makefile/" class="post-title-link" itemprop="url">Makefile</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-18 12:06:19" itemprop="dateCreated datePublished" datetime="2022-07-18T12:06:19+08:00">2022-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-23 13:20:49" itemprop="dateModified" datetime="2022-07-23T13:20:49+08:00">2022-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Makefile/" itemprop="url" rel="index"><span itemprop="name">Makefile</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="make">1. make</h4>
<h5 id="make是什么">1.1 make是什么</h5>
<p>make是一个命令，是管理文件的自动编译管理器，这里的自动是指能根据文件时间戳自动发现更新过的文件而减少编译的工作量，同时通过读取makefile的文件的内容来进行预期的编译工作，make将只编译有改动的文件，而不用完全编译。</p>
<h5 id="工作原理">1.2工作原理</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app:main.o hello.o</span><br><span class="line">        gcc -o app main.o hello.o</span><br><span class="line">main.o:main.c hello.h</span><br><span class="line">        gcc -c main.c</span><br><span class="line">hello.o:hello.c hello.h</span><br><span class="line">        gcc -c hello.c</span><br><span class="line">clean:</span><br><span class="line">        rm app main.o hello.o</span><br></pre></td></tr></table></figure>
<ul>
<li><code>make</code>在当前目录寻找<code>Makefile</code>或<code>makefile</code>文件。</li>
<li>如果找到，它会找文件中的第一个目标文件<code>target</code>，如上例它找到<code>app</code>这个目标文件，把这个文件作为最终的目标文件。如果<code>app</code>文件不存在,或是<code>app</code>所依赖的后面的<code>.o</code>文件的文件修改时间要比<code>app</code>这个文件新，那么<code>make</code>命令就会执行后面所定义的命令来生成<code>app</code>这个文件。</li>
<li><strong>如果<code>app</code>所依赖的<code>.o</code>文件也不存在，那么<code>make</code>命令会在当前文件中寻找目标为<code>.o</code>文件的依赖关系。如果找到，则再根据那一个规则生成<code>.o</code>文件，根据<code>.o</code>文件依赖的<code>.c</code>文件和<code>.h</code>文件，执行规则生成<code>.o</code>文件。</strong></li>
<li><strong>然后make再用<code>.o</code>文件生成执行文件<code>app</code></strong></li>
</ul>
<p><strong>总而远之，<code>make</code>会依据依赖关系一层一层地去找文件的依赖关系,直到最终编译出第一个目标文件</strong>。在找寻的过程中,如果出现错误,如最后被依赖的文件找不到,那么 make 就会直接退出并报错。</p>
<p>但是像<code>clean</code>这种没有被第一个目标文件直接或间接关联,那么它后面所定义的命令将不会被自动执行。不过，可以显式指定<code>make</code>执行<code>clean</code>，即<code>make　clean</code>。<strong>同时只要修改了与第一个目标文件存在直接或间接依赖关系的文件，都会发生重新编译和重新链接</strong></p>
<h5 id="make命令">1.3 make命令</h5>
<p>make是一个命令工具，它解释Makefile 中的指令（应该说是规则） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make [ -f file ][ options ][ targets ]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>-f file</code>:<code>make</code>默认在工作目录中寻找名为<code>GNUmakefile、makefile、Makefile</code>的文件作为<code>makefile</code>输入文件,但有时可能命名不是这些,则<code>-f</code>可以指定以上名字以外的文件作为makefile输入文件</p></li>
<li><code>options</code>
<ul>
<li><code>v：</code>显示make工具的版本信息</li>
<li><code>w：</code>在处理<code>makefile</code>之前和之后显示工作路径</li>
<li><code>C dir：</code>读取<code>makefile</code>之前改变工作路径至dir目录</li>
<li><code>n：</code>只打印要执行的命令但不执行</li>
<li><code>s：</code>执行但不显示执行的命令</li>
</ul></li>
<li><p><code>targets</code>:使用<code>make</code>命令时没有指定目标，则<code>make</code>工具默认会实现<code>makefile</code>文件内的第一个目标，如果指定了<code>make</code>工具要实现的目标则该目标为最终目标（目标可以是一个或多个）</p></li>
</ul>
<h4 id="makefile">2. Makefile</h4>
<p><code>Makefile</code>是一个脚本文件，其内部编写一些符和<code>make</code>工具解析的语法规则来进行执行一些命令。</p>
<h5 id="makefile是什么">2.1 Makefile是什么</h5>
<p><code>makefile</code>定义了一系列的规则来指定，<strong>哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译</strong>，甚至于进行更复杂的功能操作，因为<code>makefile</code>就像一个<code>Shell</code>脚本一样，其中也可以执行操作系统的命令。<code>Makefile</code>带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。<code>makefile</code>文件由<code>make</code>命令工具来执行。</p>
<p><strong>make主要解决两个问题：</strong></p>
<ul>
<li><strong>1) 大量代码的关系维护</strong>:大项目中源代码比较多，手工维护、编译时间长而且编译命令复杂，难以记忆及维护,把代码维护命令及编译命令写在<code>makefile</code>文件中，然后再用<code>make</code>工具解析此文件自动执行相应命令，可实现代码的合理编译</li>
<li><strong>2) 减少重复编译时间</strong>，在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有的目标文件，节省编译时间。</li>
</ul>
<p><code>Makefile</code>文件命名规则<code>makefile</code>和<code>Makefile</code>都可以，推荐使用<code>Makefile</code>,即<code>vim Makefile</code>。学号<code>Makefile</code>只需要学习他的<strong>一条规则，三个变量，两个函数</strong>就能上手了。</p>
<h5 id="一条规则">2.2 一条规则</h5>
<p><strong>一条规则</strong>即指完成单此任务所包含的要素，Makefile的一条规则三要素如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一条规则</span></span><br><span class="line">target... : prerequisites ...</span><br><span class="line">     command</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>target</code>:<strong>通常是要产生的文件名称，目标可以是可执行文件或其它obj文件，也可是一个标签</strong></li>
<li><code>prerequisites</code>：依赖文件，用来输入从而产生目标的文件，一个目标通常有几个依赖文件（也可以没有）。<code>prerequisites</code>中如果有一个以上的文件比<code>target</code>文件要新的话，<code>command</code>所定义的命令就会被执行。</li>
<li><code>command</code>：make执行的动作，一个规则可以含几个命令（可以没有）。有多个命令时，每个命令占一行。</li>
</ul>
<p><code>make</code>工具从上往下找寻<code>target</code>，<strong>根据<code>target</code>后对应的依赖关系，先去查找依赖项的文件,为索所有的目标文件创建依赖关系链</strong>。若依赖项不存在，则会报错： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make div.o</span><br><span class="line">make: *** No rule to make target <span class="string">&#x27;div.cpp&#x27;</span>, needed by <span class="string">&#x27;div.o&#x27;</span>.  Stop.</span><br></pre></td></tr></table></figure> 若存在，在检查依赖关系时，同时会检查目标与源文件的时间戳，当源文件时间戳更新时，make会更新依赖它的链路上所有文件，即调用command部分。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Makefile件</span></span><br><span class="line">sum.o:sum.cpp</span><br><span class="line">        g++ -c  sum.cpp -o sum.o</span><br><span class="line">main.o:main.cpp</span><br><span class="line">        g++ -c main.cpp -o main.o</span><br><span class="line">main:main.o sum.o</span><br><span class="line">        g++ main.o sum.o -o main</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make sum.o main.o main</span><br><span class="line">make: <span class="string">&#x27;sum.o&#x27;</span> is up to date.</span><br><span class="line">g++ -c main.cpp -o main.o</span><br><span class="line">g++ main.o sum.o -o main</span><br></pre></td></tr></table></figure></p>
<h5 id="变量">2.3 变量</h5>
<p>在<code>Makefile</code>中使用变量有点类似于C语言中的宏定义，使用该变量相当于内容替换，使用变量可以使<code>Makefile</code>易于维护,修改内容变得简单变量定义及使用。<strong>在<code>Makefile</code>中由自定义变量和自动变量</strong>。</p>
<h6 id="等号">2.3.1 等号</h6>
<p>在学习变量前需要熟悉Makefile中的等号，等号有4种<code>=，:=，?=，+=</code>。</p>
<ul>
<li><code>?=</code>表示，如果左边的变量没有被赋值，那么将等号右边的值赋给左边的变量。如果赋过值，则保持原来的值不变。</li>
<li><code>+=</code>表示将等号右边的值追加到左边变量中，但是中间会有一个空格。</li>
<li><code>=</code>与<code>:=</code>是比较不好区分的两个等号，可以将”=“理解为&quot;址传递&quot;或引用，”:=“理解为&quot;值传递”。</li>
</ul>
<p>在<code>Makefile</code>中是不允许将变量自己的值赋给自己的，也不允许出现循环引用。</p>
<h6 id="变量名的规则">2.3.2 变量名的规则</h6>
<p><strong><code>makefile</code>的变量名的起名规则：</strong></p>
<ul>
<li><code>makefile</code>变量名可以以数字开头</li>
<li>变量是大小写敏感的</li>
<li>变量一般都在<code>makefile</code>的头部定义</li>
<li>变量几乎可在<code>makefile</code>的任何地方使用</li>
</ul>
<h6 id="自定义变量">2.3.3 自定义变量</h6>
<ul>
<li>1）定义变量方法：<code>变量名=变量值</code>,<code>变量名？=变量值</code>,<code>变量名+=变量值</code>,<code>变量名:=变量值</code></li>
<li><ol start="2" type="1">
<li>使用变量名：<code>$(变量名)</code>或<code>$&#123;变量名&#125;</code></li>
</ol></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objs=add.o sum.o div.o mul.o</span><br><span class="line">target=main</span><br><span class="line">$(target):$(bgjs)</span><br><span class="line">		gcc &amp;(objs) -o $(target)</span><br></pre></td></tr></table></figure>
<h6 id="三个重要自动变量">2.3.4 三个重要自动变量</h6>
<p><code>Makefile</code>的自动变量有以下几个:</p>
<p><img src="/Makefile/auto.png" width="700"></p>
<p><strong>其中重要常用的三个是：</strong></p>
<ul>
<li><code>$@:</code> 表示规则中的目标</li>
<li><code>$&lt;:</code>表示规则中依赖性的第一个</li>
<li><code>$^:</code> 表示规则中的所有依赖性, 组成一个列表, 以空格隔开,如果这个列表中有重复的项则消除重复项。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">objs=add.o sum.o div.o mul.o</span><br><span class="line">target=main</span><br><span class="line">sum.o:sum.cpp</span><br><span class="line">        g++ -c  $^ -o $@</span><br><span class="line">main.o:main.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br><span class="line">$(target):$(bgjs)</span><br><span class="line">		g++ &amp;(objs) -o $(target)</span><br><span class="line">clean:</span><br><span class="line">		rm -rf $(objs) $(target)</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：自动变量只能在规则的命令中中使用</em></strong></p>
<h5 id="模式规则">2.4 模式规则</h5>
<p>如果想要进一步的偷懒，那就必须提到<strong>模式规则</strong>，模式规则用来匹配当前目录下的符合模式匹配的所有文件。模式规则类似于普通规则，<strong>只是在模式规则中，目标名中需要包含有模式字符<code>%</code>，包含有模式字符<code>%</code>的目标被用来匹配一个文件名，<code>%</code>可以匹配任何非空字符串</strong>。看到上面你觉得很绕，让我们看实例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#%表示可以匹配当前目录下的所有以.cpp为后缀的源文件，</span><br><span class="line">#并且对应生成相应名称的.o文件（注意是使用$&lt;才能生成对应.o文件</span><br><span class="line">%.o:%.cpp</span><br><span class="line">		g++ -c $&lt; -o $@</span><br></pre></td></tr></table></figure> 单独上面的这个<code>makefile</code>不能成功执行，会出现<code>No targets.Stop</code>错误 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接make，不成功</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make</span><br><span class="line">make: *** No targets.  Stop.</span><br><span class="line"><span class="comment">//传入目标，成功</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make main.o</span><br><span class="line">g++ -c main.cpp -o main.o</span><br></pre></td></tr></table></figure> 这是很正常的，因为<code>%</code>是模式匹配规则，你如果没传入目标它就无法执行<code>make</code>的工作机制。下面来讲解对<code>%</code>的解决办法</p>
<h5 id="函数">2.5 函数</h5>
<p><code>makefile</code>中的函数有很多，在这里给大家介绍两个最常用的:</p>
<ul>
<li><p><code>wildcard</code>查找指定目录下的指定类型的文件 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src = $(wildcard *.c) <span class="comment">//找到当前目录下所有后缀为.c的文件,赋值给src</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>patsubst</code>匹配替换 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = $(patsubst %.c,%.o, $(src)) <span class="comment">//把src变量里所有后缀为.c的文件替换成.o，然后赋值给obj</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong><em>注意</em></strong>：<code>patsubst</code>不是把src里的文件的后缀改为.o，是在<code>makefile.o</code>文件内部将生成的<code>.o</code>文件替换掉<code>src</code>内的<code>.cpp</code>文件，因此在<code>make</code>的时候一定是要先生成<code>.o</code>文件（这里从两者<code>*</code>和<code>%</code>就能看出)，从两者的特性能够得到以下的解决： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all:$(patsubst %.cpp,%.o,$(wildcard *.cpp))</span><br><span class="line">%.o:%.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br></pre></td></tr></table></figure> 原理：all目标获得了目录内的<code>*.cpp</code>文件，使用<code>patsubst</code>要求将<code>*.cpp</code>替换为<code>*.o</code>,但是目录中还没有<code>*.o</code>文件，则会依据make工作原理进行到下一个目标，刚好这个目标是生成<code>.o</code>文件的，则执行。</p>
<h5 id="简单示例">2.6 简单示例</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.cpp)</span><br><span class="line">objs=$(patsubst %.cpp,%.o,$(src))</span><br><span class="line">target=main</span><br><span class="line">$(target):$(objs)</span><br><span class="line">        g++ $(objs) -o $(target)</span><br><span class="line">%.o:%.cpp</span><br><span class="line">        g++ -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">#PHONY伪目标，不去判断目标文件是否存在或者更新，无条件执行</span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">        rm -rf $(objs) $(target)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#执行make</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ make</span><br><span class="line">g++ -c main.cpp -o main.o</span><br><span class="line">g++ -c sum.cpp -o sum.o</span><br><span class="line">g++ main.o sum.o -o main</span><br><span class="line">#执行makeclean</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/15/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">Linux操作系统基本命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-15 17:26:07" itemprop="dateCreated datePublished" datetime="2022-07-15T17:26:07+08:00">2022-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-14 08:35:37" itemprop="dateModified" datetime="2022-10-14T08:35:37+08:00">2022-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="shell">1. shell</h4>
<p><code>shell</code>是<code>Linux</code>系统中运行的一种特殊程序。在用户和内核之间之间充当“翻译官”，用户登陆<code>Linux</code>系统时，自动加载一个<code>Shell</code>程序，<code>Bash</code>是<code>Linux</code>系统中默认使用的<code>Shell</code>程序。</p>
<ul>
<li>内核：用于调用计算机硬件资源</li>
<li>shell：将用户指令转换成计算机语言让内核去调用计算机硬件资源 <img src="/Linux操作系统/shell.png" width="500"></li>
</ul>
<h4 id="bash解析器常用快捷键teminal">2. Bash解析器常用快捷键(Teminal)</h4>
<p><code>bash</code>是一个文件，linux系统中万物皆文件，<code>bash</code>文件位于<code>/bin/bash</code>，<code>bash</code>使用的快捷键：</p>
<ul>
<li><code>Tab</code>键:补齐命令，补齐路径，显示当前目录下的所有目录</li>
<li>使用快捷键<code>Ctrl + L</code> 清除终端上的显示(类似于DOS的cls清屏功能)，也可用<code>clear</code>指令</li>
<li><code>ctlr+c</code>的作用是中断终端的操作。</li>
<li>遍历输入的历史命令：从当前位置向上遍历<code>ctrl + p</code>或<code>↑</code>；从当前位置向下遍历<code>ctrl + n（↓）</code></li>
<li>光标相关操作</li>
<li>光标左移： <code>ctrl + b （←）</code></li>
<li>坐标右移： <code>ctrl + f （→）</code></li>
<li>移动到头部：<code>ctrl + a（Home）</code></li>
<li>移动到尾部：<code>ctlr + e（End）</code></li>
<li>字符删除</li>
<li>删除光标前边的字符：ctrl + h（Backspace）</li>
<li>删除光标后边的字符：ctrl + d</li>
<li>删除光标前所有内容：ctrl + u</li>
<li>删除光标后所有内容：ctrl + k</li>
</ul>
<h4 id="系统目录">3. 系统目录</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oot@trluper-<span class="keyword">virtual</span>-machine:/home/trluper<span class="meta"># cd /</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/<span class="meta"># ls</span></span><br><span class="line">bin    dev   lib    libx32      mnt   root  snap      sys  var</span><br><span class="line">boot   etc   lib32  lost+found  opt   run   srv       tmp</span><br><span class="line">cdrom  home  lib64  media       proc  sbin  swapfile  usr</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/</code>：根目录，一般根目录下只存放目录，<strong>在<code>Linux</code>下有且只有一个根目录</strong>。所有的东西都是从这里开始。当你在终端里输入<code>/home</code>，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</li>
<li><code>/bin</code>: <strong>这一目录中存放了供超级用户和一般用户都可以使用的命令，常用的命令<code>ls、tar、mv、cat</code>等</strong></li>
<li><code>/usr/bin</code>: <strong>安装的外部的命令，<code>usr</code>表示的是<code>unix software source</code>，不是user。</strong></li>
<li><code>/boot</code>：放置<code>linux</code>系统启动时用到的一些文件，如<code>Linux</code>的内核文件<code>/boot/vmlinuz</code>，系统引导管理器<code>/boot/grub</code>。</li>
<li><code>/dev</code>：存放<code>linux</code>系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，</li>
<li><code>/etc</code>：<strong>系统配置文件存放的目录，不建议在此目录下存放可执行文件</strong>，重要的配置文件有 <code>/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</code></li>
<li><code>/home</code>：<strong>系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，<code>~edu</code>表示用户<code>edu</code>的家目录。</strong></li>
<li><code>/lib</code>：<strong>内核级别</strong>,系统使用的函数库的目录，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/lib</code>: <strong>系统级别</strong>，目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录</li>
<li><code>/usr/local/lib</code>：<strong>用户级别</strong>，包含许多被<code>/bin/</code>和<code>/sbin/</code>中的程序使用的库文件。</li>
<li><code>/usr/include</code>：<strong>C程序语言编译使用的头文件。<code>linux</code>下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数</strong></li>
<li><code>/lost+fount</code>：系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li><code>/mnt、/media</code>:光盘默认挂载点，通常光盘挂载<code>/mnt/cdrom</code>下，也不一定，可以选择任意位置进行挂载。</li>
<li><code>/opt</code>：给主机额外安装软件所摆放的目录。</li>
<li><code>/proc</code>：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 <code>/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*</code> 等。</li>
<li><code>/root</code>：系统管理员root的家目录。</li>
<li><code>/sbin、/usr/sbin、/usr/local/sbin</code>：<strong>放置系统管理员使用的可执行命令</strong>，如<code>fdisk、shutdown、mount</code>等。<strong>与<code>/bin</code>不同的是，这几个目录是给系统管理员root使用的命令，</strong>一般用户只能&quot;查看&quot;而不能设置和使用。</li>
<li><code>/tmp</code>：<strong>一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</strong></li>
<li><code>/srv</code>：服务启动之后需要访问的数据目录，如<code>www</code>服务需要访问的网页数据存放在<code>/srv/www</code>内。</li>
<li><code>/usr</code>：<strong>应用程序存放目录，<code>/usr/bin</code>存放应用程序，<code>/usr/share</code>存放共享数据，<code>/usr/lib</code>存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。<code>/usr/local</code>:存放软件升级包。<code>/usr/share/doc:</code>系统说明文件存放目录。<code>/usr/share/man:</code>程序说明文件存放目录。</strong></li>
<li><code>/var</code>：放置系统执行过程中经常变化的文件，如随时更改的日志文件 <code>/var/log，/var/log/message</code>所有的登录文件存放目录，<code>/var/spool/mail</code>邮件存放的目录，<code>/var/run</code>程序或服务启动后，其PID存放在该目录</li>
</ul>
<h4 id="linux的文件">4. Linux的文件</h4>
<p>在Linux世界里，一切皆文件。在Linux中，文件可分为以下几种：<strong>普通文件（普通文件、可执行文件、压缩文件）、目录文件、设备文件、链接文件和套接字</strong> <img src="/Linux操作系统/linuxFile.png" width="400"></p>
<p><strong>文件符号标识：</strong></p>
<ul>
<li>普通文件:<code>-</code></li>
<li>目录：<code>d</code></li>
<li>字符设备：<code>c</code></li>
<li>管道：<code>p</code></li>
<li>符号链接：<code>l</code></li>
<li>套接字：<code>s</code></li>
<li>符号连结：<code>l</code></li>
<li>一般文件:<code>f</code></li>
</ul>
<h4 id="linux常用命令">5. Linux常用命令</h4>
<p>Linux的命令分为内建命令和外部命令。<code>shell</code>内建命令是指<code>bash</code>工具中集成的命令，一般有一些都会有一个与之同名的系统函数。外部命令是安装外部软件所带的命令。</p>
<h5 id="内建命令和外部命令的区别">5.1 内建命令和外部命令的区别</h5>
<ul>
<li><p><strong>内部命令</strong>：实际上是<code>shell</code>程序的一部分，其中包含的是一些比较简单的<code>linux</code>系统命令，这些命令由<code>shell</code>程序识别并在<code>shell</code>程序内部完成运行，通常在<code>linux</code>系统加载运行<code>shell</code>时就被加载并驻留在系统内存中。内部命令是写在bashy源码里面的，<strong>其执行速度比外部命令快，因为解析内部命令shell不需要创建子进程</strong>。<code>exit，history，cd，echo</code>等就是内建命令 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help 内建命令</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>外部命令</strong>：<strong>外部命令是<code>linux</code>系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存</strong>。通常外部命令的实体并不包含在<code>shell</code>中，但是其命令执行过程是由<code>shell</code>程序控制的。<code>shell</code>程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。外部命令是在<code>bash</code>之外额外安装的，通常放在<code>/bin，/sbin，/usr/bin，/usr/sbin，/usr/local/sbin</code>等等。可通过<code>echo $PATH</code>命令查看外部命令的存储路径 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是外部命令一个--help选项，不是help指令</span></span><br><span class="line">外部命令 --help</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><code>type</code>命令可以分辨内部命令与外部命令</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用的三个参数：-t对应-type，-a对应-all，-p对应-path，</span></span><br><span class="line">type [-a | -t | -p] name</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">type [-all | -type | -path] name</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="内建命令使用">5.2 内建命令使用</h5>
<p>所有内建命令如下：加星号的为常用项</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
<th style="text-align: center;">重要程度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>：</code></td>
<td>扩展参数列表，执行重定向操作</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>.</code></td>
<td>读取并执行指定文件中的命令（在当前shell环境中）</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>alias</code></td>
<td>为指定命令定义一个别名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>bg</code></td>
<td>将作业以后台模式运行</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>bind</code></td>
<td>将键盘序列绑定到一个<code>readline</code>函数或宏</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>break</code></td>
<td>退出<code>for、while、selec</code>t或<code>until</code>循环</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>builtin</code></td>
<td>执行指定的<code>shell</code>内建命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>caller</code></td>
<td>返回活动子函数调用的上下文</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>cd</code></td>
<td>将当前目录切换为指定目录</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>command</code></td>
<td>执行指定的命令，无需进行通常的shell查找</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>compgen</code></td>
<td>为指定单词生成可能的补全匹配</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>complete</code></td>
<td>显示指定的单词是如何补全的</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>compopt</code></td>
<td>修改指定单词的补全选项</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>continue</code></td>
<td>继续执行<code>for、while、select或until</code>循环的下一次迭代</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>declare</code></td>
<td>声明一个变量或者变量类型</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>dirs</code></td>
<td>显示当前存储目录的列表</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>disown</code></td>
<td>从进程作业表中删除指定的作业</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>echo</code></td>
<td>将指定字符串输出到<code>STDOUT</code></td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>enable</code></td>
<td>启用或禁止指定的内建<code>shell</code>命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>eval</code></td>
<td>将指定的参数拼接成一个命令，然后执行该命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>exec</code></td>
<td>用指定命令替换<code>shell</code>进程</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>exit</code></td>
<td>强制<code>shell</code>以指定的退出状态码退出</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>export</code></td>
<td>设置子<code>shell</code>进程可用的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>fc</code></td>
<td>从历史记录中选择命令列表</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>fg</code></td>
<td>将作业以前台模式运行</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>getopts</code></td>
<td>分析指定的位置参数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>hash</code></td>
<td>查找并记住指定命令的全路径名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>help</code></td>
<td>显示帮助文件</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>history</code></td>
<td>显示命令历史记录</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>jobs</code></td>
<td>列出活动作业</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>kill</code></td>
<td>向指定的进程ID发送一个系统信号</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>let</code></td>
<td>计算一个数学表达式中的每个参数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>local</code></td>
<td>在函数中创建一个作用域受限的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>logout</code></td>
<td>退出登录<code>shell</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>mapfile</code></td>
<td>从<code>STDIN</code>读取数据行，并将其加入索引数组</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>popd</code></td>
<td>从目录栈中删除记录</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>printf</code></td>
<td>使用格式化字符串显示文本</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>pushd</code></td>
<td>向目录栈添加一个目录</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>pwd</code></td>
<td>显示当前工作目录的路径名</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>read</code></td>
<td>从<code>STDIN</code>读取一行数据并将其赋值给一个变量</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>readarray</code></td>
<td>从<code>STDIN</code>读取数据行并将其放入索引数组</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>readonly</code></td>
<td>从<code>STDIN</code>读取一行数据并将其赋值给一个不可修改的变量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>return</code></td>
<td>强制函数以某个值退出，这个值可以被调用脚本提取</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>set</code></td>
<td>设置并显示环境变量的值和shell属性</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>shift</code></td>
<td>将位置参数依次向下降一个位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>shopt</code></td>
<td>打开/关闭控制<code>shell</code>可选行为的变量值</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>source</code></td>
<td>读取并执行指定文件中的命令（在当前<code>shell</code>环境中）</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>suspend</code></td>
<td>暂停<code>shell</code>的执行，直到收到一个<code>SIGCONT</code>信号</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>test</code></td>
<td>基于指定条件返回退出状态码0或1</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>times</code></td>
<td>显示累计的用户和系统时间</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>trap</code></td>
<td>如果收到了指定的系统信号，执行指定的命令</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>type</code></td>
<td>显示指定的单词如果作为命令将会如何被解释</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>typeset</code></td>
<td>声明一个变量或变量类型</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>ulimit</code></td>
<td>为系统用户设置指定的资源的上限</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="odd">
<td><code>umask</code></td>
<td>为新建的文件和目录设置默认权限</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td><code>unalias</code></td>
<td>删除指定的别名</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>unset</code></td>
<td>删除指定的环境变量或<code>shell</code>属性</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>wait</code></td>
<td>等待指定的进程完成，并返回退出状态码</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h6 id="cd命令">5.2.1 cd命令</h6>
<p><code>cd</code>命令是改变当前工作目录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ../	返回上一级目录</span><br><span class="line">cd /  进入根目录</span><br><span class="line">cd ~	进入用户主目录</span><br><span class="line">如：</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ cd ~</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ pwd</span><br><span class="line">/home/trluper</span><br></pre></td></tr></table></figure></p>
<h6 id="dirs命令">5.2.2 dirs命令</h6>
<p><code>dirs</code>命令用于显示<code>Shell</code>目录中的堆栈记录。不加选项时显示当前的Shell命令堆栈中的所有目录，显示时左边为最新加入的目录。</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>删除目录堆栈中的所有记录</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>以完整格式显示堆栈中的目录。显示用户宿主目录时，列出完整路径，而不是“~”</td>
</tr>
<tr class="odd">
<td><code>-n</code></td>
<td>显示右起第n个目录（n从0计数）</td>
</tr>
<tr class="even">
<td><code>+n</code></td>
<td>显示左起第n个目录 （n从0计数）</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td>以每行一个记录的方式列出堆栈中多有记录</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>以每行一个记录的方式列出堆栈中所有记录，并在每行加上序号（从0开始编号）</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ dirs -v</span><br><span class="line"> <span class="number">0</span>  ~/Documents</span><br></pre></td></tr></table></figure>
<h6 id="echo命令">5.2.3 echo命令</h6>
<p><code>echo</code>命令用于将输入的字符串送往标准输出，默认输出的字符间以空白字符隔开，并在最后加上换行号。常与重定向命令<code>&gt;</code>结合使用。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo [OPTION]... [STRING]...</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>参数选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-n</code></td>
<td>不输出行尾的换行符，不自动换行</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>允许对下面列出的加反斜线转义的字符进行解释</td>
</tr>
<tr class="odd">
<td><code>-E</code></td>
<td>默认选项，禁止对在STRINGs中的那些序列进行解释</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ echo -e <span class="string">&quot;这是echo&quot;</span></span><br><span class="line">这是echo</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ echo -e <span class="string">&quot;这是echo&quot;</span> &gt;test.txt</span><br></pre></td></tr></table></figure>
<h6 id="help命令">5.2.4 help命令</h6>
<p>help命令用于显示<code>shell</code>内部命令的帮助信息。<code>help</code>命令只能显示<code>shell</code>内部的命令帮助信息。而对于外部命令的帮助信息只能使用<code>man</code>或者<code>info</code>或者以外部命令的<code>--help</code>选项查看。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ help cd</span><br><span class="line">cd: cd [-L|[-P [-e]] [-@]] [dir]</span><br><span class="line">    Change the shell working directory.</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<h6 id="history命令">5.2.5 history命令</h6>
<p><code>Bash</code>有完善的历史命令，这对于简化管理操作、排查系统错误都有重要的作用，而且使用简单方便，建议大家多使用历史命令。系统保存的历史命令可以使用<code>history</code>命令查询。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history [选项] [历史命令保存文件]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>c</code></td>
<td>清空历史命令</td>
</tr>
<tr class="even">
<td><code>w</code></td>
<td>把缓存中的历史命令写入历史命令保存文件中。如果不手工指定历史命令保存文件，则放入默认历史命令保存文件<code>~/.bash_history</code>中</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ history</span><br><span class="line">    <span class="number">1</span>  ping baidu.com</span><br><span class="line">    <span class="number">2</span>  ifconfig</span><br><span class="line">    <span class="number">3</span>  sudo apt install net-tools</span><br><span class="line">    <span class="number">4</span>  ifconfig </span><br><span class="line">    <span class="number">5</span>  ping baidu.com</span><br><span class="line">    <span class="number">6</span>  sudu apt update</span><br><span class="line">    <span class="number">7</span>  sudo apt update</span><br><span class="line">    <span class="number">8</span>  ifconfig</span><br><span class="line">    <span class="number">9</span>  ssh</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h6 id="kill命令">5.2.6 kill命令</h6>
<p><code>kill</code>命令用于删除执行中的程序或工作。<code>kill</code>可将指定的信息送至程序。预设的信息为<code>SIGTERM(15)</code>，可将指定程序终止。若仍无法终止该程序，可使用<code>SIGKILL(9)</code>信息尝试强制删除程序。程序或工作的编号可利用 <code>ps</code>指令或<code>jobs</code>指令查看。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [信号] PID</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>信号编号</th>
<th>信号名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><code>EXIT</code></td>
<td>程序退出时收到该信息。</td>
</tr>
<tr class="even">
<td>1</td>
<td><code>HUP</code></td>
<td>挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。</td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>INT</code></td>
<td>表示结束进程，但并不是强制性的，常用的<code>Ctrl+C</code>组合键发出就是一个 <code>kill -2</code> 的信号。</td>
</tr>
<tr class="even">
<td>3</td>
<td><code>QUIT</code></td>
<td>退出。</td>
</tr>
<tr class="odd">
<td>9</td>
<td><code>KILL</code></td>
<td>杀死进程，即强制结束进程。</td>
</tr>
<tr class="even">
<td>11</td>
<td><code>SEGV</code></td>
<td>段错误。</td>
</tr>
<tr class="odd">
<td>15</td>
<td><code>TERM</code></td>
<td>正常结束进程，是<code>kill</code>命令的默认信号。</td>
</tr>
</tbody>
</table>
<h6 id="pwd命令">5.2.7 pwd命令</h6>
<p>命令用于显示工作目录。执行<code>pwd</code>指令可立刻得知您目前所在的工作目录的绝对路径名称。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ pwd</span><br><span class="line">/home/trluper/Documents</span><br></pre></td></tr></table></figure></p>
<h6 id="ulimit命令">5.2.8 ulimit命令</h6>
<p><code>ulimit</code>用来限制每个用户可使用的资源，如CPU、内存、句柄等。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]	设置limit</span><br><span class="line">ulimit [-SHabcdefiklmnpqrstuvxPT]			查询</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>S</code></td>
<td>表示软限制,超出设定的值会告警</td>
</tr>
<tr class="even">
<td><code>H</code></td>
<td>表示硬限制，超出设定的值会报错</td>
</tr>
<tr class="odd">
<td><code>a</code></td>
<td>列出系统所有资源限制的值</td>
</tr>
<tr class="even">
<td><code>d</code></td>
<td>每个进程数据段的最大值</td>
</tr>
<tr class="odd">
<td><code>f</code></td>
<td>当前<code>shell</code>可创建的最大文件容量</td>
</tr>
<tr class="even">
<td><code>l</code></td>
<td>可以锁定的物理内存的最大值</td>
</tr>
<tr class="odd">
<td><code>m</code></td>
<td>可以使用的常驻内存的最大值</td>
</tr>
<tr class="even">
<td><code>n</code></td>
<td>每个进程可以同时打开的最大文件句柄数</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>管道的最大值</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>堆栈的最大值</td>
</tr>
<tr class="odd">
<td><code>t</code></td>
<td>每个进程可以使用CPU的最大时间</td>
</tr>
<tr class="even">
<td><code>u</code></td>
<td>每个用户运行的最大进程并发数</td>
</tr>
<tr class="odd">
<td><code>v</code></td>
<td>当前<code>shell</code>可使用的最大虚拟内存</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -n</span><br><span class="line"><span class="number">1024</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -v</span><br><span class="line">unlimited</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ulimit -p</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h6 id="source命令和.命令">5.2.9 source命令和.命令</h6>
<p>.sh后缀的文件为Linux的脚本文件，里面可以写入许多执行命令语句。然后我们可以通过使用<code>source</code>命令或者<code>.</code>在当前shell环境来执行该脚本文件中的所有语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source test.sh</span><br><span class="line">或</span><br><span class="line">. test.sh</span><br></pre></td></tr></table></figure>
<p><strong>来看一下四个执行的区别：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.sh文件：</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;step 1 sleeping&quot;</span></span><br><span class="line">sleep <span class="number">200</span></span><br><span class="line">echo <span class="string">&quot;step 2 sleeping&quot;</span></span><br><span class="line">sleep <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行：</span></span><br><span class="line">./test.sh	<span class="comment">//当前shell下正常执行，这种执行方式需要test.sh的执行权限，开启两个进程一个是test.sh,一个是sleep</span></span><br><span class="line">sh test.sh	<span class="comment">//开启新的shell执行，不用执行权限，有读取权限即可，开两个新进程：一个bash，一个sleep</span></span><br><span class="line">. test.sh	<span class="comment">//当前shell下执行，只需要读取权限即可，开启一个新进程sleep</span></span><br><span class="line">source test.sh	<span class="comment">//同第三个一样</span></span><br></pre></td></tr></table></figure></p>
<h6 id="umask命令">5.3.10 umask命令</h6>
<p><code>umask</code>命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由umask设置的掩码决定。用户每次注册进入系统时，<code>umask</code>命令都被执行， 并自动设置掩码<code>mode</code>来限制新文件的权限。用户可以通过再次执行<code>umask</code>命令来改变默认值，新的权限将会把旧的覆盖掉。<strong>注意umask命令是指定哪些权限将在新文件的默认权限中被删除</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> umask [-p] [-S] [mode]</span><br><span class="line"> -p        以八进制数字表示掩码</span><br><span class="line"> -S        以符号格式表示掩码</span><br><span class="line"></span><br><span class="line">ugo：u表示当前用户权限，g为组用户权限，o为其他用户权限</span><br><span class="line">rwx：r为读权限(<span class="number">4</span>)，w为写权限(<span class="number">2</span>)，x为执行权限(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们通过<code>umask</code>查询其默认的删除权限代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前目录的umask掩码</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ umask</span><br><span class="line"><span class="number">0002</span></span><br></pre></td></tr></table></figure>
<p>因为umask的掩码表示被删除的权限，则目录拥有的权限为<code>777-002=765</code>，则以后建立的目录的权限为<code>u=rwx,g=r-x,o=r-x</code>。如果想要改变默认，则设置<code>umask</code>,那么以后新建的目录或文件会按这个来删除权限</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ umask -p <span class="number">555</span>		<span class="comment">//以后新建的目录和文件删除所有用户的读和执行权限</span></span><br></pre></td></tr></table></figure>
<h5 id="外部命令">5.3 外部命令</h5>
<h6 id="sudo命令">5.3.1 sudo命令</h6>
<p><code>sudo</code>命令以系统管理者的身份执行指令，也就是说，经由<code>sudo</code>所执行的外部指令就好像是<code>root</code>亲自执行。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo --help</span><br><span class="line">sudo - execute a command as another user</span><br></pre></td></tr></table></figure></p>
<p><code>usage: sudo -h | -K | -k | -V</code></p>
<ul>
<li><code>V</code> 显示版本编号</li>
<li><code>h</code> 会显示版本编号及指令的使用方式说明</li>
<li><code>l</code> 显示出自己（执行<code>sudo</code>的使用者）的权限</li>
<li><code>k</code> 将会强迫使用者在下一次执行<code>sudo</code>时问密码（不论有没有超过 N 分钟）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo cd /</span><br><span class="line">sudo: cd: command <span class="keyword">not</span> found</span><br><span class="line"><span class="comment">//注意，shell是一个命令解析器，sudo cd是错误的，因为cd是shell内置的，不是系统里面的，</span></span><br><span class="line"><span class="comment">//要进入root用户，先获取root权限 然后进入/root</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ sudo -sH</span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:/home/trluper<span class="meta"># cd /root</span></span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~# </span><br></pre></td></tr></table></figure>
<h6 id="su命令">5.3.2 su命令</h6>
<p><code>su</code>（英文全拼：<code>switch user</code>）命令用于变更为其他使用者的身份，除<code>root</code>外，需要键入该使用者的密码。使用权限：所有使用者。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~<span class="meta"># su trluper	<span class="comment">//切回用户身份</span></span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:/root$ sudo su	<span class="comment">//切回root</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> trluper: </span><br><span class="line">root@trluper-<span class="keyword">virtual</span>-machine:~# </span><br></pre></td></tr></table></figure></p>
<h6 id="ls命令">5.3.3 ls命令</h6>
<p>是英文单词<code>list</code>的简写，其功能为列出目录的内容，是用户最常用的命令之一，它类似于<code>DOS</code>下的<code>dir</code>命令。</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-a</code></td>
<td>显示所有文件及目录<code>.</code>开头的隐藏文件也会列出)</td>
</tr>
<tr class="even">
<td><code>-l</code></td>
<td>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>将文件以相反次序显示(原定依英文字母次序)</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>将文件依建立时间之先后次序列出</td>
</tr>
<tr class="odd">
<td><code>-A</code></td>
<td>同 -a ，但不列出 <code>.</code> (目前目录) 及<code>..</code>(父目录)</td>
</tr>
<tr class="even">
<td><code>-F</code></td>
<td>在列出的文件名称后加一符号；例如可执行档则加 <code>*</code>, 目录则加 <code>/</code></td>
</tr>
<tr class="odd">
<td><code>-R</code></td>
<td>若目录下有文件，则以下之文件亦皆依序列出</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ ls -l</span><br><span class="line">total <span class="number">40</span></span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Desktop</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Documents</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Downloads</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Music</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Pictures</span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">13</span> <span class="number">23</span>:<span class="number">46</span> projects</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Public</span><br><span class="line">drwx------ <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> snap</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Templates</span><br><span class="line">drwxr-xr-x <span class="number">2</span> trluper trluper <span class="number">4096</span>  <span class="number">6</span>月 <span class="number">23</span> <span class="number">15</span>:<span class="number">34</span> Videos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="man命令">5.3.4 man命令</h6>
<p>man命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息：<code>man [选项] 命令名</code> linux中各个分页的意义：</p>
<table>
<thead>
<tr class="header">
<th>分页</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>Standard commands</code>（标准命令）</td>
</tr>
<tr class="even">
<td><code>2</code></td>
<td><code>System calls</code>系统调用，如<code>open,write</code></td>
</tr>
<tr class="odd">
<td><code>3</code></td>
<td><code>Library functions</code>库函数，如<code>printf,fopen</code></td>
</tr>
<tr class="even">
<td><code>4</code></td>
<td><code>Special devices</code>（设备文件的说明，/dev下各种设备）</td>
</tr>
<tr class="odd">
<td><code>5</code></td>
<td><code>File formats</code>（文件格式，如passwd）</td>
</tr>
<tr class="even">
<td><code>6</code></td>
<td><code>Games and toys</code>（游戏和娱乐）</td>
</tr>
<tr class="odd">
<td><code>7</code></td>
<td><code>Miscellaneous</code>（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</td>
</tr>
<tr class="even">
<td><code>8</code></td>
<td><code>Administrative Commands</code>（管理员命令，如ifconfig）</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ man <span class="number">3</span> open</span><br><span class="line">NAME</span><br><span class="line">       open, openat — open file</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ...)</span></span>;</span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h6 id="makdir命令">5.3.5 makdir命令</h6>
<p>mkdir（英文全拼：<code>make directory</code>）命令用于创建目录。需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。参数<code>-p</code>可递归创建目录。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~$ cd ./Documents/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ mkdir -p a/b</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ mkdir mydir&#123;<span class="number">1.</span><span class="number">.3</span>&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a  mydir1  mydir2  mydir3</span><br></pre></td></tr></table></figure></p>
<h6 id="rmdir命令">5.3.6 rmdir命令</h6>
<p>rmdir删除指定的目录，一个目录被删除之前必须是空的，'-p'递归删除目录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">a  mydir1  mydir2  mydir3</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ rmdir -p a/b/c</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ rmdir mydir&#123;<span class="number">1.</span><span class="number">.3</span>&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br></pre></td></tr></table></figure></p>
<h6 id="touch命令">5.3.7 touch命令</h6>
<p><strong><code>touch</code>命令用于修改文件或者目录的时间属性，包括访问时间和修改时间，若文件不存在，系统会建立一个新的文件。</strong>即：</p>
<ul>
<li>1）如果文件不存在, 创建新文件(只能是普通文件，不能是文件夹)</li>
<li>2）如果文件存在, 更新文件时间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ touch test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ ls</span><br><span class="line">test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ touch test&#123;<span class="number">1.</span><span class="number">.3</span>&#125;.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ ls</span><br><span class="line">test  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure>
<h6 id="cp命令">5.3.8 cp命令</h6>
<p><code>cp</code>命令的功能是将给出的文件或目录复制到另一个文件或目录中，即：</p>
<ul>
<li>可以将一个或多个文件复制到另一个文件夹中</li>
<li>可以将目录即目录下的文件和子目录复制到另一个目录</li>
<li>可以将一个文件复制给另一个文件</li>
</ul>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a</code></td>
<td>此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合</td>
</tr>
<tr class="even">
<td><code>d</code></td>
<td>复制时保留链接。这里所说的链接相当于<code>Windows</code>系统中的快捷方式。</td>
</tr>
<tr class="odd">
<td><code>f</code></td>
<td>覆盖已经存在的目标文件而不给出提示</td>
</tr>
<tr class="even">
<td><code>i</code></td>
<td>与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答<code>y</code>时目标文件将被覆盖</td>
</tr>
<tr class="odd">
<td><code>p</code></td>
<td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td>
</tr>
<tr class="even">
<td><code>r</code></td>
<td>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</td>
</tr>
<tr class="odd">
<td><code>l</code></td>
<td>不复制文件，只是生成硬链接文件，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间</td>
</tr>
<tr class="even">
<td><code>s</code></td>
<td>不复制文件，创建文件的软链接，软链接就相当于windows的快捷键（即路径名）</td>
</tr>
<tr class="odd">
<td><code>u</code></td>
<td>当存在相同的文件时，只有源文件比目标文件新时，才会将源文件复制给目标文件</td>
</tr>
</tbody>
</table>
<p><strong>1.复制一个文件到另外一个文件夹</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 源文件 目标文件（夹）:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp test1.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">test1.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 复制多个文件到另外一个文件夹</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 源文件<span class="number">1</span> 源文件<span class="number">2</span> 目标文件夹 或cp 文件* 目标文件夹</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -u *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 复制目录到另一个目录</strong></p>
<p>只需要记住复制文件夹一定要加<code>-r</code>参数，否则会出现<code>cp: omitting directory</code>错误。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">未加-r出错:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$  cp /home/trluper/Documents/mydir_1 /home/trluper/Documents/mydir_2</span><br><span class="line">cp: -r <span class="keyword">not</span> specified; omitting directory <span class="string">&#x27;/home/trluper/Documents/mydir_1&#x27;</span></span><br><span class="line"></span><br><span class="line">加-r:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -r /home/trluper/Documents/mydir_1 /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">mydir_1  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cd mydir_1/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2/mydir_1$ ls</span><br><span class="line">mysondir  test  test1.cpp  test2.cpp  test3.cpp  test.cpp</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 复制文件到另一个文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制内容到文件</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cp test.cpp test2.cp</span><br></pre></td></tr></table></figure>
<p><strong>5. -u的重要性</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test.cpp</span><br><span class="line"></span><br><span class="line">使用-u，没有更新，因为文件没有更新变动：</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp -u *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">20</span> test.cpp</span><br><span class="line"></span><br><span class="line">未使用-u，直接更新:</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cp *.cpp /home/trluper/Documents/mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_1$ cd ../mydir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test1.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test2.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper   <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test3.cpp</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper <span class="number">127</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">28</span> test.cpp </span><br></pre></td></tr></table></figure>
<h6 id="rm命令">5.3.9 rm命令</h6>
<p>可通过<code>rm</code>删除文件或目录。使用<code>rm</code>命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在<code>rm</code>后使用<code>-i</code>参数以逐个确认要删除的文件。</p>
<h6 id="mv命令">5.3.10 mv命令</h6>
<p>用户可以使用<code>mv</code>命令来<strong>移动文件或目录</strong>，<strong>也可以给文件或目录重命名</strong>。<code>mv</code>与<code>cp</code>时不同的，<code>mv</code>是移动，<code>cp</code>是复制一个。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [OPTION]... [-T] SOURCE DEST</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--backup</code></td>
<td>若需覆盖文件，则覆盖前先行备份</td>
</tr>
<tr class="even">
<td><code>-b</code></td>
<td>当文件存在时，覆盖前，为其创建一个备份</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录</td>
</tr>
<tr class="even">
<td><code>-i</code></td>
<td>交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入<code>y</code>，表示将覆盖目标文件</td>
</tr>
<tr class="odd">
<td><code>-S</code></td>
<td>为备份文件指定后缀，而不使用默认的后缀</td>
</tr>
<tr class="even">
<td><code>-u</code></td>
<td>当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ mv ../mydir_1 .</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ls</span><br><span class="line">mydir_1  test  test.cpp</span><br><span class="line"><span class="comment">//对文件重命名</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ ls</span><br><span class="line">alogrithm.h  sum.cpp</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ mv alogrithm.h Alogrithm.h</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ ls</span><br><span class="line">Alogrithm.h  sum.cpp</span><br></pre></td></tr></table></figure>
<h6 id="cat命令">5.3.11 cat命令</h6>
<p>cat：将文件内容一次性输出到终端。缺点是终端显示的内容有限，如果文件太长无法全部显示</p>
<ul>
<li><code>-n</code>:对输出的所有行编号</li>
<li><code>-b</code>:输出内容并且给非空行编号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ cat -n test.cpp </span><br><span class="line">     <span class="number">1</span>	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">     <span class="number">2</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">     <span class="number">3</span>	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="number">4</span>	    cout&lt;&lt;<span class="string">&quot;这里是test1.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line">     <span class="number">5</span>	&#125;</span><br></pre></td></tr></table></figure>
<h6 id="less命令">5.3.12 less命令</h6>
<p>less命令将文件内容分页显示到终端，可以自由上下浏览</p>
<h6 id="head命令">5.3.13 head命令</h6>
<p>head命令从文件头部开始查看前n行的内容。如果没有指定行数，默认显示前10行内容。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head –n [行数] 文件名</span><br><span class="line">head -n <span class="number">30</span> /etc/passwd</span><br></pre></td></tr></table></figure></p>
<h6 id="find命令">5.3.14 find命令</h6>
<p><code>find</code>命令功能非常强大也很复杂，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure> <code>option</code>多达二十多种，这里列举两个：</p>
<ul>
<li>按文件名查询，使用<code>-name</code>,如<code>find . -name &quot;test.cpp&quot;</code></li>
<li>按文件类型查找，使用<code>-type</code>,如<code>find . -type f</code></li>
</ul>
<p>举例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将当前目录及其子目录下所有最近 20 天内更新过的文件列出</span></span><br><span class="line">find . -ctime  <span class="number">20</span></span><br><span class="line"><span class="comment">//查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：</span></span><br><span class="line">find /var/log -type f -mtime +<span class="number">7</span> -ok rm &#123;&#125; \;</span><br><span class="line"><span class="comment">//找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</span></span><br><span class="line">find . -type f -perm <span class="number">644</span> -exec ls -l &#123;&#125; \;</span><br><span class="line"><span class="comment">//查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：</span></span><br><span class="line">find / -type f -size <span class="number">0</span> -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>
<h6 id="grep命令">5.3.15 grep命令</h6>
<p>很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用<code>grep</code>命令。<code>grep</code>命令是一个强大的文本搜索工具，它能使用<strong>正则表达式</strong>搜索文本，并把匹配的行打印出来.<strong>其中<code>pattern</code>为模式，它要么是字符串，要么是正则表达式，总而言之是我们检索的指定信息</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] pattern filename</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-i</code></td>
<td>不区分大小写</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>只输出匹配行的计数</td>
</tr>
<tr class="odd">
<td><code>-l</code></td>
<td>查询多文件时只输出包含匹配字符的文件名</td>
</tr>
<tr class="even">
<td><code>-n</code></td>
<td>显示匹配行及行号</td>
</tr>
<tr class="odd">
<td><code>-s</code></td>
<td>不显示不存在或无匹配文本的错误信息</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示不包含匹配文本的所有行，即反向查找</td>
</tr>
<tr class="odd">
<td><code>-o</code></td>
<td>只显示匹配字符串的部分</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>实现多个选项的匹配，逻辑<code>or</code>关系</td>
</tr>
<tr class="odd">
<td><code>-E</code></td>
<td>使用扩展正则表达式，而不是基本正则表达式，在使用<code>-E</code>选项时，相当于使用<code>egrep</code></td>
</tr>
</tbody>
</table>
<p><strong>正则表达式：</strong></p>
<ul>
<li><code>^</code>：此时匹配正则表达以“某字符串”开头的行</li>
<li><code>$</code>：匹配正则表达式的以“某字符串”结尾的行</li>
<li><code>[xyz]</code>：匹配方括号中的任意一个字符</li>
<li><code>[^xyz]</code>：匹配除方括号中字符外的所有字符</li>
<li><code>*</code>：匹配<code>*</code>前面的字符，匹配0个或无数个</li>
<li><code>[ - ]</code>: 范围匹配，如<code>[A-C]</code>，即<code>A、B、C</code>都符合要求</li>
</ul>
<p><strong>1. 查找以指定字字符串开头的行</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in ^[a,q,r,f] hell.txt</span><br><span class="line"><span class="number">2</span>:QQWEWQE</span><br><span class="line"><span class="number">5</span>:FDSST</span><br><span class="line"><span class="number">7</span>:AFASRAY</span><br><span class="line"><span class="number">12</span>:ASDSAEE</span><br><span class="line"><span class="number">13</span>:FAFSDG</span><br><span class="line"><span class="number">17</span>:FBB</span><br><span class="line"><span class="number">24</span>:R</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 查找以指定字结符串尾的行</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in [a,q,r,f]$ hell.txt</span><br><span class="line"><span class="number">1</span>:dasdfDSFSDA</span><br><span class="line"><span class="number">4</span>:KKJHFR</span><br><span class="line"><span class="number">14</span>:DAGSA</span><br><span class="line"><span class="number">24</span>:R</span><br><span class="line"><span class="number">26</span>:CZXCGA</span><br></pre></td></tr></table></figure>
<p><strong>3.在文本中搜素只有一个字符的行，且为字母或数字</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in ^[[:alnum:]]$ hell.txt</span><br><span class="line"><span class="number">20</span>:Z</span><br><span class="line"><span class="number">21</span>:D</span><br><span class="line"><span class="number">22</span>:E</span><br><span class="line"><span class="number">23</span>:W</span><br><span class="line"><span class="number">24</span>:R</span><br><span class="line"><span class="number">25</span>:T</span><br></pre></td></tr></table></figure>
<p><strong>4.匹配<code>*</code>前面的字符，匹配0个或无数个</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ grep -in <span class="string">&quot;FDSS&quot;</span>* hell.txt </span><br><span class="line"><span class="number">1</span>:dasdfDSFSDA</span><br><span class="line"><span class="number">5</span>:FDSST</span><br></pre></td></tr></table></figure>
<h6 id="命令">5.3.16 |命令</h6>
<p>管道<code>|</code>一个命令的输出可以通过管道做为另一个命令的输入。即它只能处理经由前面一个指令传出的正确输出信息，对错误信息信息没有直接处理能力。然后，传递给下一个命令，作为标准的输入. 最常用的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|gerp <span class="string">&quot;进程名&quot;</span></span><br><span class="line">ps -aux|grep <span class="string">&quot;进程名&quot;</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -ef|grep bash</span><br><span class="line">trluper     <span class="number">2755</span>    <span class="number">2754</span>  <span class="number">0</span> <span class="number">16</span>:<span class="number">03</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span> -bash</span><br><span class="line">trluper     <span class="number">4549</span>    <span class="number">4548</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">29</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> -bash</span><br><span class="line">trluper     <span class="number">4716</span>    <span class="number">4549</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">49</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> bash</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -aux|grep bash</span><br><span class="line">trluper     <span class="number">2755</span>  <span class="number">0.0</span>  <span class="number">0.2</span>  <span class="number">19972</span>  <span class="number">5956</span> pts/<span class="number">1</span>    Ss+  <span class="number">16</span>:<span class="number">03</span>   <span class="number">0</span>:<span class="number">02</span> -bash</span><br><span class="line">trluper     <span class="number">4549</span>  <span class="number">0.0</span>  <span class="number">0.2</span>  <span class="number">19864</span>  <span class="number">5956</span> pts/<span class="number">0</span>    Ss   <span class="number">20</span>:<span class="number">29</span>   <span class="number">0</span>:<span class="number">00</span> -bash</span><br><span class="line">trluper     <span class="number">4718</span>  <span class="number">0.0</span>  <span class="number">0.1</span>  <span class="number">17864</span>  <span class="number">2584</span> pts/<span class="number">0</span>    S+   <span class="number">20</span>:<span class="number">49</span>   <span class="number">0</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> bas</span><br></pre></td></tr></table></figure></p>
<h6 id="ps命令">5.3.17 ps命令</h6>
<p><code>ps</code>（英文全拼：<code>process status</code>）命令用于显示当前进程的状态，类似于<code>windows</code>的任务管理器 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [options]</span><br></pre></td></tr></table></figure> <code>ps</code>的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a</code></td>
<td>显示现行终端机下的所有程序，包括其他用户的程序</td>
</tr>
<tr class="even">
<td><code>-a</code></td>
<td>显示所有终端机下执行的程序，除了阶段作业领导者之外</td>
</tr>
<tr class="odd">
<td><code>-A</code></td>
<td>显示所有程序</td>
</tr>
<tr class="even">
<td><code>-e</code></td>
<td>此选项的效果和指定”A”选项相同</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>显示UID,PPIP,C与STIME栏位</td>
</tr>
<tr class="even">
<td><code>-u</code></td>
<td>此选项的效果和指定”-U”选项相同</td>
</tr>
<tr class="odd">
<td><code>u</code></td>
<td>以用户为主的格式来显示程序状况</td>
</tr>
<tr class="even">
<td><code>-U</code></td>
<td>列出属于该用户的程序的状况，也可使用用户名称来指定</td>
</tr>
<tr class="odd">
<td><code>U</code></td>
<td>列出属于该用户的程序的状况</td>
</tr>
<tr class="even">
<td><code>x</code></td>
<td>显示所有程序，不以终端机来区分</td>
</tr>
</tbody>
</table>
<p><strong>1. <code>-aux</code>输出格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           <span class="number">1</span>  <span class="number">0.0</span>  <span class="number">0.4</span> <span class="number">166516</span> <span class="number">11808</span> ?        Ss   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">06</span> /sbin/init <span class="keyword">auto</span> noprom</span><br><span class="line">root           <span class="number">2</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [kthreadd]</span><br><span class="line">root           <span class="number">3</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [rcu_gp]</span><br><span class="line">root           <span class="number">4</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [rcu_par_gp]</span><br><span class="line">root           <span class="number">5</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        I&lt;   <span class="number">13</span>:<span class="number">20</span>   <span class="number">0</span>:<span class="number">00</span> [netns]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>USER</code>: 行程拥有者</li>
<li><code>PID: pid</code></li>
<li><code>%CPU</code>: 占用的 <code>CPU</code> 使用率</li>
<li><code>%MEM</code>: 占用的记忆体使用率</li>
<li><code>VSZ</code>: 占用的虚拟记忆体大小</li>
<li><code>RSS</code>: 占用的记忆体大小</li>
<li><code>TTY</code>: 终端的次要装置号码 (minor device number of tty)</li>
<li><code>STAT:</code> 该行程的状态:</li>
<li><code>D:</code> 无法中断的休眠状态 (通常 IO 的进程)</li>
<li><code>R:</code> 正在执行中</li>
<li><code>S:</code> 睡眠状态，可被唤醒</li>
<li><code>T:</code> 暂停执行</li>
<li><code>Z:</code> 僵尸进程</li>
<li><code>W:</code> 没有足够的记忆体分页可分配</li>
<li><code>s：</code>进程是会话首进程</li>
<li><code>&lt;:</code> 高优先序的行程</li>
<li><code>N:</code> 低优先序的行程</li>
<li><code>X：</code>死掉的进程</li>
<li><code>START:</code> 行程开始时间</li>
<li><code>TIME:</code> 执行的时间</li>
<li><code>COMMAND：</code>所执行的指令</li>
</ul>
<p><strong>2. <code>-ef</code>输出格式</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/mydir_2$ ps -ef</span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           <span class="number">1</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">06</span> /sbin/init <span class="keyword">auto</span> noprompt splash</span><br><span class="line">root           <span class="number">2</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [kthreadd]</span><br><span class="line">root           <span class="number">3</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [rcu_gp]</span><br><span class="line">root           <span class="number">4</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [rcu_par_gp]</span><br><span class="line">root           <span class="number">5</span>       <span class="number">2</span>  <span class="number">0</span> <span class="number">13</span>:<span class="number">20</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> [netns]</span><br></pre></td></tr></table></figure></p>
<h6 id="tar命令">5.3.18 tar命令</h6>
<p><code>tar</code>是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解压以恢复数据。<code>tar</code>这个命令并没有压缩的功能，它只是一个打包的命令，<strong>但是在<code>tar</code>命令中增加一个选项<code>-z</code>可以调用<code>gzip</code>实现了一个压缩的功能，实行一个先打包后压缩的过程</strong>。当然你可以调用其他的压缩命令来压缩。<code>tar</code>要指定扩展名 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只打包</span></span><br><span class="line">tar -cvf test.tar ./</span><br><span class="line"><span class="comment">//压缩当前文件内的所有内容打成和压缩成test.tar.gz包</span></span><br><span class="line">tar -zcvf test.tar.gz ./</span><br><span class="line"><span class="comment">//解压缩和解包</span></span><br><span class="line">tar -zxvf test.tar.gz</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>创建一个新归档</td>
</tr>
<tr class="even">
<td><code>-x</code></td>
<td>从归档中解出文件</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>使用归档文件，一定为最后一个参数</td>
</tr>
<tr class="even">
<td><code>-z</code></td>
<td>通过 gzip 过滤归档</td>
</tr>
<tr class="odd">
<td><code>-t</code></td>
<td>查看内容</td>
</tr>
<tr class="even">
<td><code>-r</code></td>
<td>向压缩归档文件末尾追加文件</td>
</tr>
<tr class="odd">
<td><code>-u</code></td>
<td>更新原压缩包中的文件</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示所有过程</td>
</tr>
</tbody>
</table>
<p><strong>-f 是必须的，切记，这个参数是最后一个参数，后面只能接档案名。</strong></p>
<p><strong><em>linux中的压缩后缀：</em></strong></p>
<ul>
<li><code>*.gz</code>：由<code>gzip</code>压缩，参数为<code>-z</code></li>
<li><code>*.bz2</code>:由<code>bzip2</code>压缩，参数为<code>-j</code></li>
<li><code>*.Z</code>:由<code>compress</code>压缩，参数为<code>-Z</code></li>
<li><code>*.rar:</code>由<code>rar</code>压缩，linux需下载<code>rar</code></li>
<li><code>*.zip</code>：由<code>zip</code>压缩，linux需下载<code>zip</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -zcvf mytar.tar.gz ./</span><br><span class="line">./</span><br><span class="line">./mymdir_2</span><br><span class="line">./mytar.tar.gz</span><br><span class="line">./mydir_2/</span><br><span class="line">./mydir_2/test.cpp</span><br><span class="line">./mydir_2/hell.txt</span><br><span class="line">./mydir_2/mydir_1/</span><br><span class="line">./mydir_2/mydir_1/test.cpp</span><br><span class="line">./mydir_2/mydir_1/test1.cpp</span><br><span class="line">./mydir_2/mydir_1/sondir/</span><br><span class="line">./mydir_2/mydir_1/mysondir/</span><br><span class="line">./mydir_2/mydir_1/test3.cpp</span><br><span class="line">./mydir_2/mydir_1/test</span><br><span class="line">./mydir_2/mydir_1/test2.cpp</span><br><span class="line">./mydir_2/test</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar.tar.gz</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -tvf mytar.tar.gz </span><br><span class="line">drwxr-xr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">31</span> ./</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">12</span> ./mymdir_2</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">31</span> ./mytar.tar.gz</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">39</span> ./mydir_2/</span><br><span class="line">-rw-rw-r-- trluper/trluper  <span class="number">93</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/test.cpp</span><br><span class="line">-rw-rw-r-- trluper/trluper <span class="number">161</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">20</span>:<span class="number">39</span> ./mydir_2/hell.txt</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">03</span> ./mydir_2/mydir_1/</span><br><span class="line">hrw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/mydir_1/test.cpp link to ./mydir_2/test.cpp</span><br><span class="line">-rw-rw-r-- trluper/trluper  <span class="number">93</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">34</span> ./mydir_2/mydir_1/test1.cpp</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">16</span>:<span class="number">03</span> ./mydir_2/mydir_1/sondir/</span><br><span class="line">drwxrwxr-x trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">49</span> ./mydir_2/mydir_1/mysondir/</span><br><span class="line">-rw-rw-r-- trluper/trluper   <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">04</span> ./mydir_2/mydir_1/test3.cpp</span><br><span class="line">-rwxrwxr-x trluper/trluper <span class="number">23528</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">01</span> ./mydir_2/mydir_1/test</span><br><span class="line">-rw-rw-r-- trluper/trluper     <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">04</span> ./mydir_2/mydir_1/test2.cpp</span><br><span class="line">hrwxrwxr-x trluper/trluper     <span class="number">0</span> <span class="number">2022</span><span class="number">-07</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">01</span> ./mydir_2/test link to ./mydir_2/mydir_1/test</span><br></pre></td></tr></table></figure>
<h6 id="gzip命令">5.3.19 gzip命令</h6>
<p>其实上面的<code>tar</code>加<code>-z</code>参数就已经完成了<code>gzip</code>命令的工作了。<code>tar</code>与<code>gzip</code>命令结合使用实现文件打包、压缩。<code>gzip</code>要指定扩展名</p>
<ul>
<li><code>-d</code>:解压</li>
<li><code>-r</code>:压缩所有子目录</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ tar -cvf mytar1.tar mydir_2</span><br><span class="line">mydir_2/</span><br><span class="line">mydir_2/test.cpp</span><br><span class="line">mydir_2/hell.txt</span><br><span class="line">mydir_2/mydir_1/</span><br><span class="line">mydir_2/mydir_1/test.cpp</span><br><span class="line">mydir_2/mydir_1/test1.cpp</span><br><span class="line">mydir_2/mydir_1/sondir/</span><br><span class="line">mydir_2/mydir_1/mysondir/</span><br><span class="line">mydir_2/mydir_1/test3.cpp</span><br><span class="line">mydir_2/mydir_1/test</span><br><span class="line">mydir_2/mydir_1/test2.cpp</span><br><span class="line">mydir_2/test</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar  mytar.tar.gz</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ gzip -r mytar1.tar</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar.gz  mytar.tar.gz</span><br></pre></td></tr></table></figure>
<h6 id="zip和unzip命令">5.3.20 zip和unzip命令</h6>
<p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">压缩文件：zip -r 目标文件(没有扩展名) 源文件</span><br><span class="line">解压文件：unzip -d 解压后目录文件 压缩文件</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ zip -r myzip mydir_2</span><br><span class="line">  adding: mydir_2/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/test.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/hell.<span class="built_in">txt</span> (deflated <span class="number">20</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test1.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/sondir/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/mysondir/ (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test3.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/<span class="built_in">test</span> (deflated <span class="number">79</span>%)</span><br><span class="line">  adding: mydir_2/mydir_1/test2.<span class="built_in">cpp</span> (stored <span class="number">0</span>%)</span><br><span class="line">  adding: mydir_2/<span class="built_in">test</span> (deflated <span class="number">79</span>%)</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  mytar1.tar.gz  mytar.tar.gz  myzip.zip</span><br></pre></td></tr></table></figure></p>
<h6 id="chmod命令">5.3.21 chmod命令</h6>
<p><code>chmod</code>（英文全拼：change mode）命令是控制用户对文件的权限的命令。Linux/Unix 的文件调用权限分为三级 : 文件所有者<code>Owner</code>、用户组<code>Group</code>、其它用户<code>ther Users</code>。<strong>在内建命令中我们通过设置<code>umask</code>命令来指定新建的文件的权限，但是对于已经存在的文件的权限我们要怎么去修改呢，只能使用<code>chmod</code>命令来修改</strong> <code>chmod</code> 修改文件权限有两种使用格式<strong>字母法与数字法</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字母</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ chmod o+w mydir_2/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxrwx <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ chmod <span class="number">775</span> mydir_2/</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="命令-1">5.3.22 &gt;命令</h6>
<p><code>&gt;</code>命令是重定向命令。我们在bash上运行命令，其默认输出为当前的bash终端。当我们想要看查询的东西时（如ls命令），把原来输出到终端的，可以重定向到一个文件。命令后接 <code>&gt;文件名</code>，<code>&gt;</code>会覆盖，<code>&gt;&gt;</code>不覆盖原来内容 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls -l &gt;text.txt</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ ls</span><br><span class="line">mydir_2  mymdir_2  text.txt</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents$ cat text.txt </span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxrwxr-x <span class="number">3</span> trluper trluper <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">20</span>:<span class="number">39</span> mydir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">16</span> <span class="number">15</span>:<span class="number">12</span> mymdir_2</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> trluper trluper    <span class="number">0</span>  <span class="number">7</span>月 <span class="number">17</span> <span class="number">11</span>:<span class="number">04</span> text.txt</span><br></pre></td></tr></table></figure></p>
<h6 id="ln命令">5.3.23 ln命令</h6>
<p><code>ln</code>命令是linux系统中一个非常重要命令，英文全称是“link”，即链接的意思，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 一种是<code>hard link</code>，又称为硬链接；另一种是<code>symbolic link</code>，又称为符号链接。<strong>通俗一点理解，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间。符号链接可以理解为类似windows一样的快捷方式</strong>。 符号链接 ：</p>
<ul>
<li>1.符号链接以路径的形式存在，类似于Windows操作系统中的快捷方式。</li>
<li>2.符号链接可以跨文件系统 ，硬链接不可以。</li>
<li>3.符号链接可以对一个不存在的文件名进行链接，硬链接不可以。</li>
<li>4.符号链接可以对目录进行链接，硬链接不可以。</li>
</ul>
<p><strong>硬链接：</strong></p>
<ul>
<li>1.硬链接以文件副本的形式存在，但不占用实际空间。</li>
<li>2.硬链接不允许给目录创建硬链接。</li>
<li>3.硬链接只有在同一个文件系统中才能创建。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [参数] [源文件或目录] [目标文件或目录]</span><br></pre></td></tr></table></figure>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>为每个已存在的目标文件创建备份文件</td>
</tr>
<tr class="even">
<td><code>-d</code></td>
<td>此选项允许“root”用户建立目录的硬链接</td>
</tr>
<tr class="odd">
<td><code>-f</code></td>
<td>强制创建链接，即使目标文件已经存在</td>
</tr>
<tr class="even">
<td><code>-n</code></td>
<td>把指向目录的符号链接视为一个普通文件</td>
</tr>
<tr class="odd">
<td><code>-i</code></td>
<td>交互模式，若目标文件已经存在，则提示用户确认进行覆盖</td>
</tr>
<tr class="even">
<td><code>-s</code></td>
<td>对源文件建立符号链接，而非硬链接</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>详细信息模式，输出指令的详细执行过程</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//软连接</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ln -s /home/trluper/Documents/mydir_2 ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls</span><br><span class="line">ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cd ln_file1</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file/ln_file1$ ls</span><br><span class="line">hell.txt  mydir_1  test  test.cpp</span><br><span class="line"><span class="comment">//软连接就是路径</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls -l</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> trluper trluper <span class="number">31</span>  <span class="number">7</span>月 <span class="number">17</span> <span class="number">11</span>:<span class="number">15</span> ln_file1 -&gt; /home/trluper/Documents/mydir_2</span><br><span class="line"><span class="comment">//硬链接</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ln /home/trluper/Documents/mydir_2/test.cpp lntest</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ ls</span><br><span class="line">ln_file1  lntest</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cat lntest </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;这里时test1.cpp&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="file命令">5.3.24 file命令</h6>
<p>file命令用于辨识文件类型。通过<code>file</code>指令，我们得以辨识该文件的类型。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>列出辨识结果时，不显示文件名称。</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>详细显示指令执行过程，便于排错或分析程序执行的情形。</td>
</tr>
<tr class="odd">
<td><code>-f&lt;名称文件&gt;</code></td>
<td>指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</td>
</tr>
<tr class="even">
<td><code>-L</code></td>
<td>直接显示符号连接所指向的文件的类别。</td>
</tr>
<tr class="odd">
<td><code>-m&lt;魔法数字文件&gt;</code></td>
<td>　指定魔法数字文件。</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td>显示版本信息。</td>
</tr>
<tr class="odd">
<td><code>-z</code></td>
<td>尝试去解读压缩文件的内容。</td>
</tr>
<tr class="even">
<td><code>[文件或目录...]</code></td>
<td>要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ file lntest1 </span><br><span class="line">lntest1: C++ source, Unicode text, UTF<span class="number">-8</span> text</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ file ln_file1</span><br><span class="line">ln_file1: symbolic link to /home/trluper/Documents/mydir_2</span><br></pre></td></tr></table></figure>
<h6 id="chgrp命令">5.3.25 chgrp命令</h6>
<p><strong><code>chgrp</code>命令用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组</strong>。其中，组名可以是用户组的<code>id</code>，也可以是用户组的组名。文件名可以是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户(root)，则不能改变该文件的组。<strong>同时必须在<code>/etc/group</code>有该组名。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项] 组名 文件...</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c</code></td>
<td>效果类似<code>-v</code>参数，但仅会显示更改的部分</td>
</tr>
<tr class="even">
<td><code>-f</code></td>
<td>不显示错误信息</td>
</tr>
<tr class="odd">
<td><code>-h</code></td>
<td>只对符号连接的文件作修改，而不是该其他任何相关文件</td>
</tr>
<tr class="even">
<td><code>-R</code></td>
<td>递归处理，将指令目录下的所有文件及子目录一并处理</td>
</tr>
<tr class="odd">
<td><code>-v</code></td>
<td>显示指令执行过程；</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ cat /etc/group</span><br><span class="line">root:x:<span class="number">0</span>:</span><br><span class="line">daemon:x:<span class="number">1</span>:</span><br><span class="line">bin:x:<span class="number">2</span>:</span><br><span class="line">sys:x:<span class="number">3</span>:</span><br><span class="line">adm:x:<span class="number">4</span>:syslog,trluper</span><br><span class="line">tty:x:<span class="number">5</span>:</span><br><span class="line">disk:x:<span class="number">6</span>:</span><br><span class="line">lp:x:<span class="number">7</span>:</span><br><span class="line">mail:x:<span class="number">8</span>:</span><br><span class="line">news:x:<span class="number">9</span>:</span><br><span class="line">uucp:x:<span class="number">10</span>:</span><br><span class="line">man:x:<span class="number">12</span>:</span><br><span class="line">...</span><br><span class="line"><span class="comment">//将rumenz目录由root组改为www群组</span></span><br><span class="line">chgrp -R www rumenz</span><br></pre></td></tr></table></figure>
<h6 id="top命令">5.3.26 top命令</h6>
<p><code>top</code>命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [参数]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-b</code></td>
<td>批处理</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>显示完整的治命令</td>
</tr>
<tr class="odd">
<td><code>-I</code></td>
<td>忽略失效过程</td>
</tr>
<tr class="even">
<td><code>-s</code></td>
<td>保密模式</td>
</tr>
<tr class="odd">
<td><code>-S</code></td>
<td>累积模式</td>
</tr>
<tr class="even">
<td><code>-i&lt;时间&gt;</code></td>
<td>设置间隔时间</td>
</tr>
<tr class="odd">
<td><code>-u&lt;用户名&gt;</code></td>
<td>指定用户名</td>
</tr>
<tr class="even">
<td><code>-p&lt;进程号&gt;</code></td>
<td>指定进程</td>
</tr>
<tr class="odd">
<td><code>-n&lt;次数&gt;</code></td>
<td>循环显示的次数</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/ln_file$ top -p2567</span><br><span class="line">top - <span class="number">12</span>:<span class="number">55</span>:<span class="number">36</span> up  <span class="number">2</span>:<span class="number">23</span>,  <span class="number">2</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line">Tasks:   <span class="number">0</span> total,   <span class="number">0</span> running,   <span class="number">0</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%<span class="built_in">Cpu</span>(s):  <span class="number">0.0</span> us,  <span class="number">0.0</span> sy,  <span class="number">0.0</span> ni, <span class="number">99.9</span> id,  <span class="number">0.1</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">MiB Mem :   <span class="number">2408.3</span> total,    <span class="number">493.1</span> free,    <span class="number">655.0</span> used,   <span class="number">1260.2</span> buff/cache</span><br><span class="line">MiB Swap:   <span class="number">2048.0</span> total,   <span class="number">2048.0</span> free,      <span class="number">0.0</span> used.   <span class="number">1570.8</span> avail Mem </span><br></pre></td></tr></table></figure>
<h6 id="ar命令">5.3.27 ar命令</h6>
<p><code>ar</code>命令用于<strong>建立或修改备存文件，或是从备存文件中抽取文件。可集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar [参数]</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-d</code></td>
<td>删除备存文件中的成员文件</td>
</tr>
<tr class="even">
<td><code>-m</code></td>
<td>变更成员文件在备存文件中的次序</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td>显示备存文件中的成员文件内容</td>
</tr>
<tr class="even">
<td><code>-q</code></td>
<td>将文件附加在备存文件末端</td>
</tr>
<tr class="odd">
<td><code>-r</code></td>
<td>将文件插入备存文件中</td>
</tr>
<tr class="even">
<td><code>-t</code></td>
<td>显示备存文件中所包含的文件</td>
</tr>
<tr class="odd">
<td><code>-x</code></td>
<td>自备存文件中取出成员文件</td>
</tr>
<tr class="even">
<td><code>-c</code></td>
<td>创建</td>
</tr>
<tr class="odd">
<td><code>-s</code></td>
<td>建立索引</td>
</tr>
</tbody>
</table>
<h6 id="nm命令">5.3.28 nm命令</h6>
<p><code>nm</code>是<code>names</code>的缩写，<strong><code>nm</code>命令主要是用来列出某些文件中的符号（说白了就是一些函数和全局变量等）</strong>。 一般来说，搞linux开发的人，才会用到<code>nm</code>命令，非开发的人，应该用不到. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm [参数]</span><br></pre></td></tr></table></figure></p>
<h4 id="vim编辑器">6. vim编辑器</h4>
<p><code>vi (Visual interface)</code>编辑器是<code>Linux</code>系统中最常用的文本编辑器，<code>vi</code>工作在字符模式下，不需要图形界面，非常适合远程及嵌入式工作，是效率很高的文本编辑器。<code>vim</code>是<code>vi</code>的升级版，它不仅兼容<code>vi</code>的所有指令，而且还有一些新的特性，例如<code>vim</code>可以撤消无限次、支持关键词自动完成、可以用不同的颜色来高亮你的代码。<code>vim</code>普遍被推崇为类<code>vi</code>编辑器中最好的一个。</p>
<h5 id="vim的三种模式">6.1 vim的三种模式</h5>
<p>vi有三种基本工作模式: <strong>命令模式、文本输入模式(编辑模式)、末行模式</strong></p>
<ul>
<li><p><strong>命令模式：</strong> <strong>任何时候,不管用户处于何种模式,只要按一下<code>ESC</code>键,即可使<code>vi</code>进入命令模式</strong>。我们在<code>shell</code>环境(提示符为<code>$</code>)下输入启动<code>vim</code>命令，进入编辑器时，也是处于该模式下。在命令模式下，用户可以输入各种合法的<code>vi</code>命令，用于管理自己的文档。<strong>此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的<code>vi</code>命令，则<code>vi</code>在接受用户命令之后完成相应的动作</strong>。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是<code>vi</code>的合法命令，<code>vi</code>会响铃报警。</p></li>
<li><p>文本输入模式： 在命令模式下输入插入命令<code>i（I）、附加命令a（A） 、打开命令o（O）、替换命s（S）</code>都可以进入文本输入模式，此时vi窗口的最后一行会显示“插入”,可进行文本编辑.</p></li>
<li><p>末行模式： 末行模式下，用户可以对文件进行一些附加处理。尽管命令模式下的命令可以完成很多功能，但要执行一些如字符串查找、替换、显示行号等操作还是必须要进入末行模式的。<strong>在命令模式下，输入冒号<code>:</code>即可进入末行模式。此时vi窗口的状态行会显示出冒号，等待用户输入命令。用户输入完成后，按回车执行，之后<code>vi</code>编辑器又自动返回到命令模式下</strong> <img src="/Linux操作系统/vi-vim.gif"></p></li>
</ul>
<h5 id="命令模式下的命令操作">6.2 命令模式下的命令操作</h5>
<h6 id="切换到编辑模式">6.2.1 切换到编辑模式</h6>
<p><img src="/Linux操作系统/vimbianji.png"></p>
<h6 id="光标移动">6.2.2 光标移动</h6>
<p><img src="/Linux操作系统/mousemove.png"></p>
<h6 id="删除">6.2.3 删除</h6>
<p><img src="/Linux操作系统/delete.png"> <strong>常用：<code>D</code>、<code>dG</code>、<code>nx</code>(n为数字)、<code>ndd</code></strong></p>
<h6 id="查找">6.2.4 查找</h6>
<p><img src="/Linux操作系统/find.png"></p>
<h6 id="可视模式">6.2.5 可视模式</h6>
<p><img src="/Linux操作系统/copydelete.png"></p>
<h6 id="粘贴和复制">6.2.6 粘贴和复制</h6>
<ul>
<li><code>p</code>:粘贴在光标后面</li>
<li><code>P</code>:粘贴在光标前面</li>
<li><code>y</code>:拷贝行</li>
<li><code>Y</code>:拷贝行</li>
</ul>
<h5 id="末行模式下的命令操作">6.3 末行模式下的命令操作</h5>
<h6 id="保存退出">6.3.1 保存退出</h6>
<p><img src="/Linux操作系统/saveexit.png"></p>
<h6 id="替换">6.3.2 替换</h6>
<p><img src="/Linux操作系统/tihuan.png"> 可以从上图总结：<code>s(</code>代表本行，<code>g</code>为所有(global)都替换，<code>%</code>指本文件所有行，<code>c</code>每次替换都要求确认</p>
<h6 id="分屏">6.3.3 分屏</h6>
<p><img src="/Linux操作系统/fenping.png"></p>
<h6 id="其他用法扩展">6.3.4 其他用法扩展</h6>
<p><img src="/Linux操作系统/others.png"></p>
<h5 id="vim的配置文件所在">6.4 vim的配置文件所在</h5>
<p>局部配置文件（推荐）：<code>~/.vimrc</code> 全局配置文件:<code>/etc/vim/vimrc</code></p>
<h4 id="gcc和gcc编译器">7. GCC和gcc++编译器</h4>
<h5 id="gcc和-gcc是两个不同的东西">7.1 gcc和 GCC是两个不同的东西</h5>
<ul>
<li><code>GCC:GNU Compiler Collection</code>(GUN 编译器集合)，它可以编译<code>C、C++、JAV、Fortran、Pascal、Object-C、Ada</code>等语言。</li>
<li>因此<code>gcc</code>是<code>GCC</code>中的<code>GUN C Compiler</code>（C 编译器）；<code>g++</code>是<code>GCC</code>中的<code>GUN C++ Compiler</code>（<code>C++</code>编译器）。二者都可以编译<code>c</code>或<code>cpp</code>文件。只不过用<code>gcc</code>编译<code>c++</code>需要手动添加链接库</li>
<li><strong>在编译阶段，<code>g++</code>会调用<code>gcc</code>，对于<code>c++</code>代码，两者是等价的，但是因为<code>gcc</code>命令不能自动和<code>C++</code>程序使用的库联接，所以通常使用用<code>g++</code>来编译以求自动完成链接。所以对于<code>C</code>语言程序的编译，我们应该使用<code>gcc</code> 指令，而编译<code>C++</code>程序则推荐使用<code>g++</code>指令</strong></li>
</ul>
<h5 id="gccg的四个步骤">7.2 gcc/g++的四个步骤</h5>
<p><code>gcc、g++</code>编译器从拿到一个c源文件到生成一个可执行程序，中间一共经历了<strong>四个步骤：</strong> <img src="/Linux操作系统/compile.png"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">第一步: 进行预处理</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -E <span class="number">1</span>hello.c -o <span class="number">1</span>hello.i</span><br><span class="line">第二步: 生成汇编文件</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -S <span class="number">1</span>hello.i -o <span class="number">1</span>hello.s</span><br><span class="line">第三步: 生成目标代码</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc -c <span class="number">1</span>hello.s -o <span class="number">1</span>hello.o</span><br><span class="line">第四步: 生成可以执行文件</span><br><span class="line"><span class="comment">//这条指令是完成链接这个过程的，它通过链接器ld将运行程序的目标文件和库文件链接在一起，</span></span><br><span class="line"><span class="comment">//生成最后的可执行文件</span></span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc <span class="number">1</span>hello.o -o <span class="number">1</span>hello</span><br><span class="line">第五步: 执行 </span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc​$ ./<span class="number">1</span>hello</span><br><span class="line">hello itcast</span><br><span class="line"></span><br><span class="line">也可直接将源文件生成一个可以执行文件</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc$ gcc <span class="number">1</span>hello.c -o <span class="number">1</span>hello</span><br><span class="line">deng@itcast:~/share/<span class="number">3</span>rd/<span class="number">1</span>gcc​$ ./<span class="number">1</span>hello</span><br><span class="line">hello itcast</span><br></pre></td></tr></table></figure></p>
<p><strong>常用选项</strong> <img src="/Linux操作系统/gcc.png"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello  -I /home/hello/include -L /home/hello/lib -lworld</span><br><span class="line">上面这句表示在编译hello.c时：</span><br><span class="line"></span><br><span class="line">-I /home/hello/include表示将/home/hello/include目录作为第一个寻找头文件的目录，</span><br><span class="line">寻找的顺序是：/home/hello/include--&gt;/usr/include--&gt;/usr/local/include </span><br><span class="line"></span><br><span class="line">-L /home/hello/lib表示将/home/hello/lib目录作为第一个寻找库文件的目录，</span><br><span class="line">寻找的顺序是：/home/hello/lib--&gt;/lib--&gt;/usr/lib--&gt;/usr/local/lib</span><br><span class="line"></span><br><span class="line">-lworld表示在上面的lib的路径中寻找libworld.so动态库文件或libworld.a静态库文件</span><br></pre></td></tr></table></figure></p>
<p><strong><em>附加</em></strong>：</p>
<ul>
<li><p><code>-I</code>针对头文件，未指明路径时，使用<code>#include&lt;&gt;</code>,<code>gcc/g++</code>默认目录<code>/usr/include</code>，如果使用<code>#include&lt;my.h&gt;</code>则找不到<code>my.h</code>文件，因此要通过<code>-I dir</code>参数来指定包含的头文件<code>my.h</code>的位置： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gcc hell.c -o hell -I /<span class="built_in">root</span>              (假设文件my.h存放在/root下)</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>-L</code>与<code>-I</code> 功能类似，只不过<code>-L</code>时对库文件使用，能够在指定库文件搜索路径。如果一个程序用到了目录<code>/root/lib</code>下的一个动态库<code>libsunq.so</code>，因为<code>-L dir</code>指定的是路径而没有指定文件，则需要用到 <code>-llibname</code>参数，它可以指定<code>gcc</code>去寻找<code>libsunq.so</code>或者<code>libsunq.a</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gcc hello.c -o hell -L /root/lib -lsunq</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="静态链接和动态链接">7.3 静态链接和动态链接</h5>
<h6 id="静态链接">7.3.1静态链接</h6>
<p><strong>静态链接是指由链接器在链接时将库的内容直接加入到可执行程序中。</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>对运行环境的依赖性较小，具有较好的兼容性</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间</li>
<li>库函数有了更新，必须重新编译应用程序</li>
</ul></li>
</ul>
<h6 id="动态链接">7.3.2 动态链接</h6>
<p><strong>动态链接是指连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li>在需要的时候才会调入对应的资源函数</li>
<li>简化程序的升级；有着较小的程序体积</li>
<li>实现进程之间的资源共享（避免重复拷贝）</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>依赖动态库，不能独立运行</li>
<li>动态库依赖版本问题严重</li>
</ul></li>
</ul>
<p>注：前面我们编写的应用程序大量用到了标准库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入<code>-static</code>参数。</p>
<h6 id="静态库的制作">7.3.3 静态库的制作</h6>
<p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。 按照习惯,一般以<code>.a</code>做为文件后缀名。静态库的命名一般分为三个部分：</p>
<ul>
<li>前缀：<code>lib</code></li>
<li>库名称：自己定义即可</li>
<li>后缀：<code>.a</code></li>
</ul>
<p><strong>所以最终的静态库的名字应该为：<code>libxxx.a</code></strong> <img src="/Linux操作系统/staticlinked.png" width="600"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：将c源文件生成对应的.o文件</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib$ gcc -c add.c -o add.o</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c sub.c -o sub.o </span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c mul.c -o mul.o </span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib​$ gcc -c div.c -o div.o</span><br><span class="line">步骤<span class="number">2</span>：使用打包工具ar将准备好的.o文件打包为.a文件 libtest.a</span><br><span class="line">deng@itcast:~/test/<span class="number">3</span>static_lib$ ar -rcs libAlogrithm.a add.o sub.o mul.o div.o</span><br></pre></td></tr></table></figure> <strong>在使用ar工具是时候需要添加参数：<code>-rcs</code></strong></p>
<ul>
<li><code>r</code>更新</li>
<li><code>c</code>创建</li>
<li><code>s</code>建立索引</li>
</ul>
<h6 id="静态库的使用">7.3.4 静态库的使用</h6>
<p>静态库制作完成之后，<strong>需要将<code>.a</code>文件和头文件一起发布给用户</strong>。假设测试文件为<code>main.c</code>，静态库文件为<code>libAlogrithm.a</code>，头文件为<code>Alogrithm.h</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ cat main.cpp </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Alogrithm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">20</span>,b=<span class="number">20</span>;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ g++ -<span class="type">static</span> main.cpp -I ../staticLib/ -L ../staticLib/ -lAlogrithm -o test</span><br></pre></td></tr></table></figure></p>
<h6 id="动图库的制作">7.3.5 动图库的制作</h6>
<p>共享库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题和更新问题。 按照习惯,一般以“.so”做为文件后缀名。共享库的命名一般分为三个部分：</p>
<ul>
<li>前缀：<code>lib</code></li>
<li>库名称：自己定义即可</li>
<li>后缀：<code>.so</code></li>
</ul>
<p><strong>所以最终的动态库的名字应该为：<code>libxxx.so</code></strong> <img src="/Linux操作系统/dynamiclib.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">步骤一：生成目标文件，此时要加编译选项：-fPIC（fpic）</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -fPIC -c add.c</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ gcc -fPIC -c sub.c </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -fPIC -c mul.c </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ gcc -fPIC -c div.c</span><br><span class="line">参数：-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</span><br><span class="line">步骤二：生成共享库，此时要加链接器选项: -shared（指定生成动态链接库）</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ gcc -shared add.o sub.o mul.o div.o -o libtest.so</span><br><span class="line"></span><br><span class="line">步骤三: 通过nm命令查看对应的函数</span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib$ nm libtest.so | grep add </span><br><span class="line"><span class="number">00000000000006b</span>0 T add </span><br><span class="line">deng@itcast:~/test/<span class="number">5</span>share_lib​$ nm libtest.so | grep sub </span><br><span class="line"><span class="number">00000000000006</span>c4 T sub</span><br></pre></td></tr></table></figure>
<h6 id="使用动态库">7.3.6 使用动态库</h6>
<p>静态库制作完后，需要在测试文件所在的目录创建<code>libxxx.so</code>的链接接，否则就会出现下面这个错误： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libtiger.so: cannot open shared object file: No such file <span class="keyword">or</span> direct</span><br></pre></td></tr></table></figure> 可以通过<code>ldd</code>命令查看哪些动态链接库没有找到： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/test$ ldd test1</span><br><span class="line">	linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007ffc0d5fe000</span>)</span><br><span class="line">	libAlogrithm.so =&gt; <span class="keyword">not</span> found</span><br><span class="line">	libstdc++.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span> (<span class="number">0x00007fbd2317f000</span>)</span><br><span class="line">	libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007fbd22f57000</span>)</span><br><span class="line">	libm.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libm.so<span class="number">.6</span> (<span class="number">0x00007fbd22e70000</span>)</span><br><span class="line">	/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fbd233c1000</span>)</span><br><span class="line">	libgcc_s.so<span class="number">.1</span> =&gt; /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007fbd22e50000</span>)</span><br></pre></td></tr></table></figure> <strong>这是因为程序运行时没有找到动态链接库造成的。程序编译时链接动态库和运行时使用动态链接库的概念是不同的，在运行时，程序链接的动态链接库需要在系统目录下才行</strong>。方法：</p>
<ul>
<li><strong>方法一是可在系统目录创建软链接，链接文件。</strong>这是因为用·<code>-L</code>指定动态库文件路径只能保证编译通过，是否能执行还是得看<code>/lib/</code>或<code>/usr/lib</code>下面有没有该库文件（只要没有删除，永久有效）</li>
<li>方法二当然你要可以修改<code>LD_LIBRARY_PATH</code>指定的动态库搜索路径(当前shell有效)</li>
<li>方法三是配置文件<code>/etc/ld.so.conf</code>中指定的动态库搜索路径(永久有效)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deng@itcast:~/test/<span class="number">6</span>share_test$ sudo ln -s /home/trluper/Documents/staticLib/libtest.so /lib/share_test/libtest.so</span><br></pre></td></tr></table></figure>
<p>然后同静态链接一样，引用动态库去编译：（要保证能找到头文件，因此使用<code>-I</code>) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -<span class="type">static</span> main.cpp -I ../staticLib/ -lAlogrithm -o test</span><br></pre></td></tr></table></figure></p>
<h5 id="gdb调试">7.4 gdb调试</h5>
<p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具。GDB主要帮忙你完成下面四个方面的功能：</p>
<ul>
<li>启动程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>动态的改变你程序的执行环境。</li>
</ul>
<h6 id="gdb的工作步骤">7.4.1 gdb的工作步骤</h6>
<p><strong>1. 准备工作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用gcc/g++将其编译为可执行文件，同时使用-g表示该程序可调试：</span></span><br><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ g++ -g main.cpp sum.cpp -o main</span><br></pre></td></tr></table></figure>
<p><strong>2. 启动gdb</strong></p>
<p>输入<code>gdb -q + 可执行文件</code>，启动gdb进行调试。<code>-q</code>参数可以屏蔽一些gdb版本等相关信息，使得页面看起来干净些（我用了）。至此gdb启动完毕： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trluper@trluper-<span class="keyword">virtual</span>-machine:~/Documents/staticLib$ gdb -q main</span><br><span class="line">Reading symbols from main...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p><strong>3. 查看代码（可选）</strong></p>
<p>输入<code>list（l）</code>即可查看程序源码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line"><span class="number">1</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Alogrithm.h&quot;</span></span></span><br><span class="line"><span class="number">2</span>	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">3</span>	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="number">4</span>	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">5	</span>&#123;</span><br><span class="line"><span class="number">6</span>		<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="number">7</span>		cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line"><span class="number">8</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span>	&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 设置参数（可选）</strong></p>
<p><code>set args</code>可指定运行时参数（如：<code>set args 10 20 30 40 50</code>）。<code>show args</code>命令可以查看设置好的运行参数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args <span class="number">20</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">(gdb) b <span class="number">2</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b5</span>: file main.cpp, line <span class="number">6.</span></span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/trluper/Documents/staticLib/main <span class="number">20</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;20 30 50&quot;</span>.</span><br></pre></td></tr></table></figure></p>
<p><strong>5.设置断点（可选）</strong></p>
<p>输入<code>break（b）+数字</code> 可以对程序进行断点操作（数字就是设置断点的代码行数） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b <span class="number">2</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b5</span>: file main.cpp, line <span class="number">6.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>6. 启动程序</strong></p>
<p>输入<code>run（r)</code>开始运行程序，直到遇到“断点”或者“结束” <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/trluper/Documents/staticLib/main </span><br><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at main.cpp:<span class="number">6</span></span><br><span class="line"><span class="number">6</span>		<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>7.单步执行程序（可选）</strong></p>
<ul>
<li><code>next</code>单步执行程序，但是遇到函数时会直接跳过函数，不进入函数</li>
<li><code>step</code>单步执行程序，但遇到函数会进入函数</li>
<li><code>continue</code>继续执行程序，直到遇到断点或结束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Argument list to give program being debugged when it is started is <span class="string">&quot;20 30 50&quot;</span>.</span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">7</span>		cout&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">(gdb) <span class="function">s</span></span><br><span class="line"><span class="function"><span class="title">sum</span> <span class="params">(a=<span class="number">10</span>, b=<span class="number">20</span>)</span> at sum.cpp:<span class="number">4</span></span></span><br><span class="line"><span class="function"><span class="number">4</span>		return a+b;</span></span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">5</span>	&#125;</span><br><span class="line">(gdb) s</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="built_in">main</span> () at main.cpp:<span class="number">8</span></span><br><span class="line"><span class="number">8</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>8. 查看变量值（可选）</strong></p>
<p><code>print + 变量</code>查看变量值；<code>whatis + 变量</code>查看变量数据类型。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print a</span><br><span class="line">$<span class="number">1</span> = <span class="number">10</span></span><br><span class="line">(gdb) whatis a</span><br><span class="line">type = <span class="type">int</span></span><br></pre></td></tr></table></figure></p>
<p><strong>9. 退出</strong></p>
<p>输入<code>q</code>即可退出gdb <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) q</span><br><span class="line">A debugging session is active.</span><br><span class="line">	Inferior <span class="number">1</span> [process <span class="number">3102</span>] will be killed.</span><br><span class="line">Quit anyway? (y <span class="keyword">or</span> n) y</span><br></pre></td></tr></table></figure></p>
<h6 id="其他命令">7.4.2 其他命令</h6>
<p><strong>1. 断点</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>delete + n</code></td>
<td>删除第<code>n</code>个断点</td>
</tr>
<tr class="even">
<td><code>disable + n</code></td>
<td>暂停第<code>n</code>个断点</td>
</tr>
<tr class="odd">
<td><code>enable + n</code></td>
<td>开启第<code>n</code>个断点</td>
</tr>
<tr class="even">
<td><code>clear + n</code></td>
<td>清除第<code>n</code>行的断点</td>
</tr>
<tr class="odd">
<td><code>info b</code></td>
<td>显示当前程序的断点设置情况</td>
</tr>
<tr class="even">
<td><code>delete breakpoints</code></td>
<td>清除所有断点</td>
</tr>
</tbody>
</table>
<p><strong>2. 运行信息</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>where/bt</code></td>
<td>当前运行的堆栈列表</td>
</tr>
<tr class="even">
<td><code>bt backtrace</code></td>
<td>显示当前调用堆栈</td>
</tr>
<tr class="odd">
<td><code>up/down</code></td>
<td>改变堆栈显示的深度</td>
</tr>
<tr class="even">
<td><code>info program</code></td>
<td>查看程序是否在运行，以及进程号被暂停的原因</td>
</tr>
</tbody>
</table>
<p><strong>3. 运行命令</strong></p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>until</code></td>
<td>如果你厌倦了在一个循环内单步跟踪，它可以运行程序直到退出循环体</td>
</tr>
<tr class="even">
<td><code>until + 行号</code></td>
<td>运行至某行</td>
</tr>
<tr class="odd">
<td><code>finish</code></td>
<td>运行程序，直到当前函数返回完成，并且打印函数返回时的堆栈地址和返回值及参数值等信息</td>
</tr>
<tr class="even">
<td><code>call + 行数 + （参数）</code></td>
<td>调用程序中可见的函数，并传递参数</td>
</tr>
</tbody>
</table>
<h4 id="shell脚本">8. shell脚本</h4>
<p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。对于Linux 的 Shell 种类众多，常见的有：</p>
<ul>
<li><code>Bourne Shell（/usr/bin/sh或/bin/sh）</code></li>
<li><code>Bourne Again Shell（/bin/bash）</code></li>
<li><code>C Shell（/usr/bin/csh）</code></li>
<li><code>K Shell（/usr/bin/ksh）</code></li>
<li><code>Shell for Root（/sbin/sh）</code></li>
</ul>
<p>在一般情况下，人们并不区分<code>Bourne Shell</code>和<code>Bourne Again Shell</code>，所以，像<code>#!/bin/sh，</code>它同样也可以改为 <code>#!/bin/bash</code>。<code>#!</code>告诉系统其后路径所指定的程序即是解释此脚本文件的 <code>Shell</code> 程序。</p>
<h5 id="创建一个脚本文件">8.1 创建一个脚本文件</h5>
<p>使用<code>vi/vim</code>命令来创建文件)，新建一个文件<code>test.sh</code>，扩展名为<code>sh</code>（sh代表shell），扩展名并不影响脚本执行，见名知意就好。输入一些代码，第一行一般是这样: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;Hello World !&quot;</span></span><br></pre></td></tr></table></figure> <strong><code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种<code>Shell</code></strong>。echo 命令用于向窗口输出文本。</p>
<h5 id="运行脚本的方法">8.2 运行脚本的方法</h5>
<h6 id="作为可执行程序">8.2.1 作为可执行程序</h6>
<p>将上面的代码保存到<code>test.sh</code>，并<code>cd</code>到相应目录： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ./test.sh  <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">./test.sh  <span class="comment">#执行脚本</span></span><br></pre></td></tr></table></figure> 注意，一定要写成 <code>./test.sh</code>，而不是<code>test.sh</code>，运行其它二进制的程序也一样，直接写<code>test.sh</code>的话，<code>linux</code>系统会去<code>PATH</code>里寻找有没有叫<code>test.sh</code>的，而只有 <code>/bin, /sbin, /usr/bin，/usr/sbin</code>等在<code>PATH</code>里，你的当前目录通常不在<code>PATH</code>里，所以写成<code>test.sh</code>是会找不到命令的，要用 <code>./test.sh</code> 告诉系统说，就在当前目录找。</p>
<h6 id="作为解释器参数">8.2.2 作为解释器参数</h6>
<p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure> 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<h5 id="变量">8.3 变量</h5>
<p>变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： - 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 - 中间不能有空格，可以使用下划线 _。 - 不能使用标点符号。 - 不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<p>定义变量时，变量名不加美元符号<code>$</code>，但PHP语言中变量需要。使用变量名是需要加<code>$</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">&quot;runoob.com&quot;</span></span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br><span class="line">echo <span class="string">&quot;My name is &amp;&#123;your_name&#125;teacher&quot;</span></span><br><span class="line">your_name=<span class="string">&quot;xiaoming&quot;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>变量名外面的<code>&#123;&#125;</code>是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，</li>
<li>一般推荐使用<code>&#123;&#125;</code>,比如上面的第三节，如果不加<code>&#123;&#125;</code>，则会认为your_nameteacher为一个变量名，就出错了。</li>
<li>重新赋值是允许的，仍有不用加<code>$</code>,只有使用的时候加上<code>$</code></li>
</ul>
<h4 id="ssh">9. ssh</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" class="post-title-link" itemprop="url">ubuntu使用手册</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-13 16:44:21" itemprop="dateCreated datePublished" datetime="2022-07-13T16:44:21+08:00">2022-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:50:03" itemprop="dateModified" datetime="2022-10-30T21:50:03+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ubuntu/" itemprop="url" rel="index"><span itemprop="name">ubuntu</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ubuntu常用快捷键">1. Ubuntu常用快捷键</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、打开终端：Ctr+Alt+T</span><br><span class="line"><span class="number">2</span>、关闭终端：Ctrl + Shift + Q</span><br><span class="line"><span class="number">3</span>、复制：Ctrl + Shift + C</span><br><span class="line"><span class="number">4</span>、粘贴：Ctrl + Shift + V</span><br><span class="line"><span class="number">5</span>、跳转回主机操作:ctr+alt</span><br><span class="line"><span class="number">6</span>、跳回虚拟机：Ctr+G</span><br><span class="line"><span class="number">7</span>、新建终端窗口：Ctrl + Shift + N</span><br><span class="line"><span class="number">8</span>、运行命令：Alt + F2</span><br><span class="line"><span class="number">9</span>、全屏切换：F11</span><br></pre></td></tr></table></figure>
<h4 id="apt安装">2. apt安装</h4>
<p>对于Ubuntu安装各种软件包的命令格式使用<code>apt-get</code>或者<code>apt</code>。（centOS使用<code>yum</code>），这是在线安装。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线安装</span></span><br><span class="line">sudo apt-get update		<span class="comment">//更新软件包列表</span></span><br><span class="line">sudo apt-get install	<span class="comment">//安装软件</span></span><br><span class="line">sudo apt-get remove		<span class="comment">//删除软件</span></span><br><span class="line">sudo apt-get clean		<span class="comment">//清理安装包</span></span><br></pre></td></tr></table></figure> <strong><em>附：</em></strong>如果是从Ubuntu官网已经下载好了安装包，相应离线安装的话，因为从Ubuntu的文件为deb格式，所以</p>
<ul>
<li>软件安装<code>sudo dpkg -i xxx.deb</code></li>
<li>软件卸载<code>sudo dpkg -r 软件名</code></li>
</ul>
<h5 id="安装net-tools网络工具">2.1 安装net-tools网络工具</h5>
<p><code>net-tools</code>工具箱包括<code>arp, hostname, ifconfig, netstat, rarp, route, plipconfig, slattach, mii-tool and iptunnel and ipmaddr</code>等命令。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure></p>
<h5 id="安装ssh">2.2 安装ssh</h5>
<p><code>ssh</code>用于远程登录到<code>Linux</code>服务器来管理维护系统。<code>SSH</code>是专为远程登录会话和其他网络服务提供安全性的协议；使用<code>ssh</code>服务（指实现<code>SSH</code>协议的软件）可远程登录到服务器来管理维护系统，防止远程管理过程中的信息泄露问题。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装</span></span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"><span class="comment">//查看状态</span></span><br><span class="line">service ssh status</span><br><span class="line"><span class="comment">//查看端口</span></span><br><span class="line">netstat -anp |grep <span class="number">22</span> netstat -anp |grep sshlsof -i :<span class="number">22</span></span><br></pre></td></tr></table></figure></p>
<h5 id="aptitude">2.3 aptitude</h5>
<p><code>aptitude</code> 命令与 <code>apt-get</code> 命令一样，都是Debian Linux 及其衍生系统中功能极其强大的包管理工具。与<code>apt-get</code>不同的是，<code>aptitude</code>在处理依赖问题上更佳一些。举例来说，<code>aptitude</code> 在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。它通过文本操作菜单和命令两种方式管理软件包。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装</span></span><br><span class="line">sudo apt-get install aptitude</span><br><span class="line"><span class="comment">//命令</span></span><br><span class="line">aptitude upgrade		<span class="comment">//升级系统所有的软件包</span></span><br><span class="line">aptitude dist-upgrade	<span class="comment">//将系统升级到新的发行版</span></span><br><span class="line">aptitude safe-upgrade	<span class="comment">//安全升级系统的软件包</span></span><br><span class="line">aptitude install net-tools	<span class="comment">//安装软件包</span></span><br><span class="line">ptitude purge net-tools	<span class="comment">//彻底删除软件包</span></span><br><span class="line">aptitude search ssh	<span class="comment">//根据关键词搜索软件包</span></span><br><span class="line">aptitude show ssh	<span class="comment">//查看软件包的详细信息</span></span><br><span class="line">aptitude clean		<span class="comment">//删除缓存目录中的软件包安装文件</span></span><br></pre></td></tr></table></figure></p>
<h5 id="安装gccg">2.3 安装gcc/g++</h5>
<p><code>GCC</code>原名为 <code>GNU C</code> 语言编译器，因为它原本只能处理 C语言。GCC 快速演进，变得可处理 <code>C++、Fortran、Pascal、Objective-C、Java</code> 以及 <code>Ada</code> 等他语言。实际使用中：</p>
<ul>
<li>使用 <code>gcc</code> 指令编译 C 代码</li>
<li>使用 <code>g++</code>指令编译 C++ 代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo  apt-get insatll gcc</span><br><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure>
<h5 id="安装vim">2.4 安装vim</h5>
<p><code>vim</code>是从<code>VI</code>发展而来的一个文本编辑器，功能更强大。而<code>vim.tiny</code>是vim的精简版，所以，安装<code>vim</code>势在必行。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure></p>
<h5 id="安装cmake">2.5 安装Cmake</h5>
<p><code>Camke</code>是一个高级编译工具，当你用不同的语言或者编译器开发一个项目，各就各位code完之后要生成最终的输出（<code>dll</code>或执行文件），这时候就尴尬了，你要手动去MingGW或者GCC下配置成千上万的<code>.cpp .h .o .c</code>路劲和地址吗？这时候神器就出现了<code>CMake</code>，主要功能：</p>
<ul>
<li>配置和生成各大平台的工程（vs的vcxproj，Qt的Pro）</li>
<li>生成makefile文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure>
<h5 id="第三方线程库">2.6 第三方线程库</h5>
<p><code>pthread</code>是第三方线程库，安装如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install glibc-doc</span><br><span class="line"> sudo apt-get install manpages-posix manpages-posix-dev</span><br></pre></td></tr></table></figure></p>
<h5 id="mysql安装">2.7 MySQL安装</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server;</span><br></pre></td></tr></table></figure>
<h4 id="虚拟机网络问题">3. 虚拟机网络问题</h4>
<p>有时候我们的虚拟机会出现无法连接上网的情况，解决方法如下：</p>
<ul>
<li>检查宿主主机，能正常联网</li>
<li><p>linux的ifconfig显示，没有固定IP <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        inet6 ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0x10</span>&lt;host&gt;</span><br><span class="line">        loop  txqueuelen <span class="number">1000</span>  (Local Loopback)</span><br><span class="line">        RX packets <span class="number">2588</span>  bytes <span class="number">197004</span> (<span class="number">197.0</span> KB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">2588</span>  bytes <span class="number">197004</span> (<span class="number">197.0</span> KB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>将网络管理的缓存清除后重新开启即可 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo service network-manager stop</span><br><span class="line">sudo rm /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">sudo service network-manager start</span><br><span class="line">或</span><br><span class="line">sudo service NetworkManager stop</span><br><span class="line">sudo rm /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">sudo service NetworkManager start</span><br><span class="line">sudo vim /etc/NetworkManager/NetworkManager.conf #在这个文件中把第四行的<span class="literal">false</span>改成<span class="literal">true</span></span><br><span class="line">sudo service NetworkManager restart</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="wsl的ubuntu安装">4.WSL的ubuntu安装</h4>
<h4 id="wsl下的ubuntu的ssh服务器">5. wsl下的ubuntu的ssh服务器</h4>
<p><strong>如果你想用ssh连接远程window上的wsl，你是无法直接连接Linux的ssh的，必须通过走windows端口映射才行：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove openssh-server <span class="comment">#自带的有问题卸载</span></span><br><span class="line">sudo apt-get install openssh-server <span class="comment">#重新安装</span></span><br><span class="line">sudo vim /etc/ssh/sshd_config <span class="comment">#修改配置文件</span></span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 去掉前面的“#”</span></span><br><span class="line">Port <span class="number">2222</span> <span class="comment"># 端口号 默认22，因为与Window系统自带SSH冲突故改为2222</span></span><br><span class="line">AddressFamily <span class="built_in">any</span></span><br><span class="line">ListenAddress <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">ListenAddress ::</span><br><span class="line">PasswordAuthentication yes <span class="comment"># 是否允许使用密码登录 选“是”</span></span><br><span class="line"><span class="comment"># 其它配置没必要改变</span></span><br></pre></td></tr></table></figure> 生成成功后，我们在重启sshd，这样就可以了。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh --full-restart <span class="comment">#重启SSH服务</span></span><br></pre></td></tr></table></figure> <strong>端口映射：</strong>然后WLS2有一个问题，就是它相当于一个完整的虚拟机，所以IP地址与本机不一样，这就导致我们无法在别的设备上SSH连接</p>
<p>解决办法就是把WSL2虚拟机的IP映射到本机上(假设本机windows的ip为192.168.1.3) <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy <span class="built_in">set</span> v4tov4 listenport=<span class="number">12233</span> listenaddress=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> connectport=<span class="number">2222</span> connectaddress=<span class="number">172.18</span><span class="number">.69</span><span class="number">.154</span></span><br><span class="line"><span class="comment"># listenport win10监听的端口号</span></span><br><span class="line"><span class="comment"># listenaddress win10监听的外网地址，0.0.0.0指所有地址</span></span><br><span class="line"><span class="comment"># connectport 映射的linux的端口 也就是ssh的开启端口</span></span><br><span class="line"><span class="comment"># connectaddress linux的ip</span></span><br><span class="line"><span class="comment"># 可以理解为，所有发往win11:192.168.1.3的12233端口的tcp信息都会转发到172.18.69.154:2222</span></span><br></pre></td></tr></table></figure></p>
<p>测试：你可以在window上运行下面代码验证是否映射成功 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@本机IP -p 映射端口 <span class="comment"># 例如 ssh root@192.168.1.3 -p 12233 </span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用内透软件natapp">6. 使用内透软件natapp</h4>
<p>内网内透通过将我们的本机的ubuntu服务器与natapp的服务器连接，以支持另一台主机通过不同网段也能够通过走natapp的服务器连接该ubuntu服务器。即内网穿透。</p>
<p>在natapp中指定服务器地址即可，详细操作见<a target="_blank" rel="noopener" href="https://natapp.cn/tunnel/edit/16vldzyrj8">natapp官网</a> <img src="/ubuntu使用手册/natapp.png" width="700"> <strong><em>注：上面的ip地址和端口号中，如果你是连接wsl的那么就是window的ip地址和相应的端口映射号</em></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">STL源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-12 22:15:12" itemprop="dateCreated datePublished" datetime="2022-07-12T22:15:12+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-29 19:18:32" itemprop="dateModified" datetime="2022-10-29T19:18:32+08:00">2022-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STL/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>88k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:20</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="stl概述">1.STL概述</h4>
<h5 id="六大组件">1.1 六大组件</h5>
<ul>
<li>容器：各种数据结构,如<code>vector、list、deque、set、map</code>等,用来存放数据</li>
<li>算法：各种常用的算法（冒泡，排序）,如<code>sort、find、copy、for_each、search、erase</code></li>
<li>迭代器：扮演了容器与算法之间的胶合剂，是所谓的泛型指针</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理。注意一般都伴随着重新分配空间，那么原来的迭代器就会失效</li>
</ul>
<p>六大组件的交互关系是<code>Container</code>通过<code>Allocator</code>获得数据存储空间，<code>Alogrithm</code>通过<code>Iterator</code>存取<code>Container</code>的内容，<code>Functor</code>可以协助<code>Algorithm</code>完成不同的策略变化，<code>Adapter</code>可以修饰或套接<code>Functor</code>。本笔记将会以此对这六大组件进行介绍。</p>
<p>++说在前面：STL的实现版本由HP版本、PJ版本、RW版本、STLport版本和SGISTL版本等五个主要版本++</p>
<h4 id="空间配置器">2. 空间配置器</h4>
<p>在介绍STL的其他组件尤其是<code>container</code>组件之前，空间配置器是必须要先介绍的，因为容器内存空间的开辟需要由<code>allocator</code>去申请。allocator申请的空间是为构造原始的，<code>new</code>申请的空间是已构造的。在<code>gcc</code>中的容器使用了缺省的SGI版本的空间配置器：<code>class Alloc = alloc</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, **<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc**&gt;	<span class="comment">//默认使用了alloc</span></span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="comment">/*...实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="空间配置器的标准接口">2.1 空间配置器的标准接口</h5>
<p>allocator的必要接口（无论是哪个版本的STL）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员变量</span></span><br><span class="line">allocator::value_type;</span><br><span class="line">allocator::pointer;</span><br><span class="line">allocator::const_pointer;</span><br><span class="line">allocator::reference;</span><br><span class="line">allocator::const_reference;</span><br><span class="line">allocator::size_type;</span><br><span class="line">allocator::difference_type;</span><br><span class="line">allocator::rbind;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>();</span><br><span class="line">allocator::<span class="built_in">allocator</span>(<span class="type">const</span> allocator&amp;);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;allocator：：<span class="built_in">allocator</span>(<span class="type">const</span> allocator&lt;U&gt;&amp;);</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">allocator::~<span class="built_in">allocator</span>();</span><br><span class="line"><span class="comment">//返回某个对象的地址，等同于&amp;X</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::address</span><span class="params">(reference x)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//配置空间，n个足以存储U对象</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n,<span class="type">const</span> <span class="type">void</span>*=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//回收配置的空间,p为allocate返回的指针，n为allocate分配是指定的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::deallocate</span><span class="params">(pointer p,size_type n)</span></span>;</span><br><span class="line"><span class="comment">//对分配空间进行构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::construct</span><span class="params">(pointer,<span class="type">const</span> T&amp;x)</span></span>;</span><br><span class="line"><span class="comment">//对构造空间析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::destroy</span><span class="params">(pointer p)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="设计一个简单的空间配置器">2.1.1设计一个简单的空间配置器</h6>
<p>根据上述的接口，我们可以实现一个自己的、功能简单，接口不齐全的<code>allocator</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstddef&gt;</span>	<span class="comment">//ptrdiff_t,size_t类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myallocator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">inline</span> T* _allocate()（<span class="type">ptrdiff_t</span> size,T*)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//使用全局operator new ,相当于malloc</span></span><br><span class="line">		T* tmp=(T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size*<span class="built_in">sizeof</span>(T))));	<span class="comment">//调用全局重载运算符new</span></span><br><span class="line">		<span class="keyword">if</span>(tmp==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cerr&lt;&lt;<span class="string">&quot;out_of_memory&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _deallocate(T*buffer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//相当于free</span></span><br><span class="line">		::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _construct(T* p,<span class="type">const</span> U&amp; value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span>(p) <span class="built_in">U</span>(value);		<span class="comment">//placement new，相当于realloc，并进行构造</span></span><br><span class="line">	&#125;</span><br><span class="line">	/析构</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _destroy(T* ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">allocator</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> T  value_type;</span><br><span class="line">		<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> T* const_pointer;</span><br><span class="line">		<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">		<span class="comment">//内嵌体</span></span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rebind</span>&#123;</span><br><span class="line">			<span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//函数</span></span><br><span class="line">		<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n,<span class="type">const</span> <span class="type">void</span>* hint=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _allocate((difference_type)n,(pointer)hint);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">deallocte</span><span class="params">(pointer p,size_type n)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_deallocate(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_constrcut(p,value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_destroy(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	<span class="comment">//end of namespace myallocator</span></span><br></pre></td></tr></table></figure></p>
<h5 id="sgi空间配置器">2.2 SGI空间配置器</h5>
<p>SGI版本的空间配置器与众不同，其名称是<code>alloc</code>而不是<code>allocator</code>。<code>alloc</code>不接受任何参数，即如果你的程序要采用SGI版本的配置器，则不能使用标准写法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::allocator&lt;<span class="type">int</span>&gt;&gt; iv;</span><br></pre></td></tr></table></figure> 而应当使用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::alloc&gt; iv;</span><br></pre></td></tr></table></figure> 其实这个问题不会给我们带来困扰，在<code>GCC</code>中是使用缺省的空间配置器，我们可以不用显示的去指定，编译器默认采用SGI的这个版本。</p>
<p><strong><em>附</em></strong>：虽然SGI也提供了一个<code>aloocator</code>版本，但是不建议使用，因为效率不佳，因为它只是对<code>::operator new</code>和<code>::operator delete</code>做一个简单包装而已</p>
<h5 id="sgi的alloc">2.3 SGI的alloc</h5>
<p>我们知道<strong><code>new</code>算式包含两个步骤</strong>：一是调用<code>::operator new</code>配置内存；二是调用相应的构造函数构造对象内容。同样<strong><code>delete</code>算式也包含两个步骤</strong>：一是调用对象的析构函数析构；二是调用<code>::operator delete</code>释放内存</p>
<p>为了精密加工和效率的提升，STL的allocator把这两步操作区分开来，<strong>内存配置操作由<code>alloc::allocate()</code>负责，内存释放由<code>alloc::deallocate()</code>负责；而对象的构造和析构分别是由<code>::construct()</code>和<code>::destroy()</code>负责。</strong>STL的标准中规定配置器的定义位于<code>&lt;memory&gt;</code>中，对SGI版本来说<code>&lt;memory&gt;</code>内含有关键的两个文件，这两个文件实行上面的工作划分规则 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_alloc.h&gt;</span>		<span class="comment">//负责内存的配置和释放</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_construct.h&gt;</span>	<span class="comment">//负责构造和析构</span></span></span><br></pre></td></tr></table></figure> 在<code>&lt;stl_alloc.h&gt;</code>中定义了<strong>一、二级配置器</strong>，而在<code>&lt;stl_construct.h&gt;</code>定义了<code>construct()</code>和<code>destroy()</code>函数。</p>
<h5 id="alloc的stl_constuct">2.4 alloc的stl_constuct</h5>
<p>在<code>&lt;stl_construct.h&gt;</code>定义了多个重载的<code>construct()</code>和<code>destroy()</code>函数。这里介绍接受两个迭代器版本的<code>destroy()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator lasu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_destroy(first,last,<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个函数我们可以知道它会析构掉<code>[first,last)</code>范围内对象，<strong>如果是调用一些无关痛痒得析构函数，又万一这个范围很大的话效率会极低。因此<code>_destroy()</code>利用<code>value_type()</code>获得迭代器对象所指代得类型，在<code>_destroy</code>内部利用<code>_type_traits&lt;T&gt;</code>判断该类型得析构是否对内存空间无关痛痒，若是<code>_true_type</code>，则什么也不做就结束，若是<code>_false_type</code>则只能迭代去析构这个范围得对象。</strong></p>
<h5 id="空间配置stl_alloc">2.5 空间配置stl_alloc</h5>
<p>SGI内部是以<code>malloc()</code>和<code>free()</code>完成内存得配置与释放得。考虑到小型区块可能造成内存碎片得问题，SGI设计了双层配置器，<strong>第一级直接使用<code>molloc()</code>和<code>free()</code>,第二级则看情况采用不同策略分配：</strong></p>
<ul>
<li>当配置区块超过<code>128bytes</code>时，视为足够大，直接调用第一级得配置器</li>
<li>当配置区块小于<code>128bytes</code>时，视为小，便采用复杂的<code>memory pool</code>和自由链表管理配置</li>
</ul>
<p><strong>内存池<code>memory pool</code></strong>：内存池是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样，内存池允许在运行期以常数时间规划内存块，并且尽量避免了内存破碎的情况产生，使得内存分配的效率得到提升。</p>
<p><strong><em>注意：是只开放一级配置器还是同时开放二级，由<code>_USE_MALLOC</code>是否被定义而定，当被定义是，只开放第一级配置器，当未背定义时两级都开放。</em></strong></p>
<h6 id="一级配置器">2.5.1 一级配置器</h6>
<p>一级配置器是类名为<strong><code>template&lt;int inst&gt;class _malloc_alloc_template&#123;...&#125;</code></strong>的一个类，在<code>allocate()</code>内直接使用<code>malloc()</code>,在<code>deallocate()</code>直接使用<code>free()</code>。同时<strong>模拟<code>set_new_handler()</code>来处理内存不足的情况</strong>。奉上源码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_malloc_alloc_template</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//以下函数用来处理内存不足的情况</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span>*,<span class="type">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*_malloc_alloc_oom_handler)</span><span class="params">()</span></span>;	<span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//allocate分配</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">		<span class="type">void</span> *result=<span class="built_in">malloc</span>(n);		<span class="comment">//直接使用malloc分配</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==result)</span><br><span class="line">			result=<span class="built_in">oom_malloc</span>(n);	<span class="comment">//不断尝试</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//模拟set_new_hanlder，返回函数指针</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span><span class="params">(* set_malloc_hanlder(<span class="type">void</span>(*f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">void</span> (*old)=_malloc_alloc_oom_handler;</span><br><span class="line">		<span class="comment">//设置</span></span><br><span class="line">		_malloc_alloc_oom_handler=f;</span><br><span class="line">		<span class="keyword">return</span> (old);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数为纯虚函数，需要自己编写处理函数来不断尝试释放内存、申请内存</span></span><br><span class="line"><span class="built_in">void</span> (* _malloc_alloc_template&lt;inst&gt;::_malloc_alloc_oom_handler)()=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//malloc形式的不断尝试</span></span><br><span class="line"><span class="type">void</span> *_malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n)&#123;</span><br><span class="line">	<span class="built_in">void</span> (*my_malloc_hanlder)();	<span class="comment">//函数指针</span></span><br><span class="line">	<span class="type">void</span> *result;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;<span class="comment">//不断尝试释放，配置</span></span><br><span class="line">		my_malloc_hanlder=_malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==my_malloc_handler)</span><br><span class="line">			_ThROW_BAD_ALLOC;</span><br><span class="line">		(*my_malloc_handler)();<span class="comment">//调用释放</span></span><br><span class="line">		<span class="comment">//进行分配</span></span><br><span class="line">		result=<span class="built_in">malloc</span>(n);</span><br><span class="line">		<span class="comment">//分配成功直接返回</span></span><br><span class="line">		<span class="keyword">if</span>(result)</span><br><span class="line">			<span class="keyword">return</span>(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>查看上述的部分源代码可以知道</strong></p>
<ul>
<li>第一级空间分配器以<code>malloc()、free()、realloc()</code>等C函数执行内存配置，而不是采用<code>C++</code>的<code>::operator new</code>，<strong>因此无法使用C++的<code>new hanlder</code>机制，也就不能使用<code>set_new_hanlder()</code>,必须仿真一个类似该功能的<code>set_malloc_handler()</code></strong></li>
<li><code>allocate()</code>分配不成功后会改调用<code>oom_malloc()</code>不断尝试去释放分配，其中的<code>_malloc_alloc_oom_hanlder()</code>函数是要自己去编写指定的。如果你没有传入该函数，源码也未提供，默认为纯虚函数，则进入到<code>oom_hanlder()</code>判断后直接抛异常。</li>
</ul>
<h6 id="附加知识点new-handler机制">2.5.2 附加知识点：new handler机制</h6>
<p><code>new_handler</code>是一个void*类型的函数指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">　<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;	<span class="comment">//函数指针，只是起个名字new_handler=void*</span></span><br><span class="line"> <span class="comment">//new_handler是一个typedef后void*</span></span><br><span class="line">　<span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>new_handler</code>类型内的函数将在默认内存申请函数<code>operator new</code>和<code>operator new[]</code>申请内存失败时被调用;</li>
<li>默认情况下, 当内存不能够分配时, <code>new</code>操作将抛出一个<code>bad_alloc</code>的异常。 你可以改变这个默认操作, 通过<code>set_new_handler()</code>设置<code>new_handler</code>内的函数指针。当然 你可以使用<code>set_new_handler(0)</code>, 获得一个不抛出异常的<code>new</code>.</li>
</ul>
<p><strong>用户定义的my_handler应该可以做以下几件事之一:</strong></p>
<ul>
<li>释放内存, 产生更多可以用的内存</li>
<li>抛出bad_alloc异常(或bad_alloc派生类)</li>
<li>终止程序(比如调用abort或exit)</li>
</ul>
<h6 id="二级配置器">2.5.3 二级配置器</h6>
<p>二级配置器类名为<strong><code>template&lt;bool threads,int ints&gt;class _default_alloc_template&#123;...&#125;</code>：维护16个自由链表，负责16种小型区块内存池的次配置能力，内存池<code>memory pool</code>事先由<code>malloc</code>配置而得</strong>。为了方便管理，SGI的二级配置会主动将小额的内存需求上调至8的倍数，例如我们要求分配30bytes，那么二级配置器就会分配维护多个<code>32bytes</code>的内存块。第二级配置器多了许多机制，以避免太多的小额区块造成内存碎片，从而避免内存浪费和减轻配置负担，第二级配置的做法是：</p>
<ul>
<li>当配置区块超过<code>128bytes</code>时，视为足够大，直接调用第一级得配置器</li>
<li>当配置区块小于<code>128bytes</code>时，视为小，便采用复杂的<code>memory pool</code>管理配置，又称为次层配置。</li>
</ul>
<p><strong><code>memory pool</code>的想法是</strong>：预先配置一大块内存，一般来书为需求的2倍，并维护与之对应的自由链表<code>free list</code>。<strong>下次若有对应大小的内存需求，则直接从该链表拔出给它就行；如果客户端释还从该内存池种拔出的一部分内存，则由配置器回收到该内存池中</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free list的节点结构如下所示：节点使用union而不是struct，从而达到节省内存开销的目的。</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span>&#123;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;	<span class="comment">//未被使用时，由次指针维护</span></span><br><span class="line">	<span class="type">char</span> client_data[<span class="number">1</span>];	<span class="comment">//当内存被使用时，软件开发者使用这个，执行实际区块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>下面来介绍这种机制：</strong>从内存池中取空间给<code>free list</code>是<code>chunk_alloc()</code>函数得工作。</p>
<ul>
<li>如<code>chunk_alloc(32，20)</code>会根据<code>end_free-start_free</code>来判断内存池得水量是否充足，如果水量充足，则直接调出20个相应大小的内存区块给<code>free_list</code>；如果不充足则调用<code>malloc</code>分配至少40个<code>32bytes</code>的内存块，一个直接给客户端，19个给<code>free_list</code>维护，另外的给内存池</li>
<li>如果不够20个但至少能满足一个32bytes的内存块，也会拨出至少一个；</li>
<li>如果连一个区块都拨不出去，此时便会利用<code>malloc</code>从<code>heap</code>上配置内存，从内存中为内存池注入水源以应付需求，一般来说申请的内存是需求量的2倍。</li>
</ul>
<p><img src="/STL源码剖析/memorypool.png" width="700"></p>
<p>如上图：</p>
<ul>
<li><strong>假设程序一开始就调用<code>chunk_alloc(32,20)</code>,那么<code>malloc</code>就会配置40个<code>32bytes</code>的区块，其中第一个交出，另外19个交给<code>free_list[3]</code>维护，剩余20个交给内存池。</strong></li>
<li>接下来客户端再调用<code>chunk_alloc(64,20)</code>,此时很明显<code>free_list[7]</code>没有内存，必须向内存池请求支持，但内存池也只够10个64<code>bytes</code>的区块，那么就会交付这10，一个直接给客户端，另外9个由<code>free_list[7]</code>维护。此时内存池已经空了，</li>
<li>如果再调用<code>chunk_alloc(96,20)</code>,不仅<code>free_list[11]</code>没有内存，就连内存池也没有，那么就会调用<code>malloc</code>配置40+n个<code>96bytes</code>区块，其中第一个给客户端，19个给<code>free_list[11]</code>，另外的给内存池。</li>
<li>如果<code>malloc()</code>也无法分配内存，就会使用第一级配置，不断尝试去释放获取。</li>
</ul>
<h4 id="迭代器与traits编程技法">3. 迭代器与traits编程技法</h4>
<p><code>iterator</code>是指提供一种方法，使之能够依序巡防某个容器所含的各个元素，而又无需暴露该容器的内部表达式。STL通过泛型化将数据容器和算法分开，采用<code>iterator</code>将两者粘合起来，以<code>find</code>为例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(first!=last&amp;&amp;*first!=value)</span><br><span class="line">		++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 迭代器是一种行为类似指针的<strong>对象</strong>，而指针最常见的应用就是<strong>内容提取和成员访问</strong>，因此对于迭代器来说最重要的编程工作就是对<code>operator *、operator-&gt;、operator++</code>进行重载</p>
<h5 id="traits编程技法-stl源码的门钥">3.1 traits编程技法-STL源码的门钥</h5>
<h6 id="为什么要使用traits编程技法">3.1.1 为什么要使用traits编程技法</h6>
<p>迭代器一般都为模板，其所指对象的的型别，称为该迭代器的<code>value type</code>。模板函数虽然带有参数类型的推导，但却不是万能的：<strong>万一<code>value type</code>用于函数的反回值，毕竟template的参数推导机制只是适用于参数，无法推导返回值</strong>。<strong>我们可能可以在类内定义内嵌型别来解决，也可以使用<code>C++11</code>的的尾置返回类型</strong><code>remove_reference&lt;decltype(beg*)&gt;::type</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内嵌类型声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myiter</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;		<span class="comment">//内嵌型别声明</span></span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> I&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> I::value_type <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾置返回类型</span></span><br><span class="line"><span class="comment">//此例中我们通知编译器fcn2的返回类型与解引用beg的参数的结果类型相同</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(T beg,T end)</span>-&gt;<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上面这个程序看起来能够解决返回值问题，但是有一个问题就是我们<strong>不能为不是类类型的定义内嵌型别</strong>，比如<strong>指针</strong>就不行，但STL又必须接受原生指针作为一种迭代器。虽然采用模板的特例化可以解决问题，但是每有需要就要特例化一个模板就很麻烦，此时就得采用<code>traits</code>的偏特例化编程。(像<code>int*,double*</code>内置类型或者自动定义的类的指针就是原生指针)</p>
<h6 id="traits和偏特例化">3.1.2 traits和偏特例化</h6>
<p><code>traits</code>单词只是说明这个类能萃取到迭代器的特性，只是一个名字的作用，告诉编程人员注意对于这种类内部会对传入的参数进行取<code>value type</code>操作，说实在就是STL当中的规范协议。如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> itrator_traits&lt;I&gt;::<span class="built_in">value_type</span>(I iter)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果I内定义了自己的<code>value type</code>，那么就会在<code>iterator_traits</code>这种类内部有取<code>value type</code>操作。这里跟我们上面提到的内嵌型别说明是一样的。上面这个类只是起到中间转换的作用，这就<code>traits</code>的特定。</p>
<p>然后我们在去实现iterator_traits的一个特例化版本即传入指针形式的偏特化版本就能取得指针的类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的机制是当我们传入T*=int*时，因为int内有定义value_type那么就肯定能获得其类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 为啥还需要const版本，引用我们最终要获取时<code>I</code>的类型，而不是<code>const+类型</code>,试想当没有const版本，调用iterator_traits&lt;const int*&gt;会获取到<code>const int</code>而不是<code>int</code>。<strong>三个版本都是需要的，后面两个版本为解决原生指针无法获取类型而采用（应用偏特例化）</strong></p>
<p>总结：</p>
<ul>
<li>实现原生指针也能推导返回值类型就是要<code>traits</code>编程技法</li>
<li><code>traits</code>不是什么C++内部关键字，它只是对STL源码编写的一个规范</li>
<li><code>traits</code>编程技法主要应用于迭代器实现，迭代器就是行为像指针的类，保证我们在使用迭代器类的<code>operator*</code>后能返回迭代器所指的元素</li>
<li><code>traits</code>编程技法的实现原理就是对类模板的偏特例化（上面的二个篇特例化模板）</li>
</ul>
<h5 id="迭代器相应型别">3.2 迭代器相应型别</h5>
<p>更加迭代器使用<code>operator*</code>时所返回的类别，一般有<code>value type,difference type,pointer,reference,itrator category</code>这五种。因此我们在对<code>traits</code>类进行<code>typedef</code>时都应当指定，以便符号STL规范，即使自己编写的迭代器类也能与STL水乳交融。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::iterator_category	iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type 		    value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::difference_type 	difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer 			pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference 			reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="value_type">3.2.1 value_type</h6>
<p><code>value_type</code>就是迭代器所指对象的型别，任何一个打算与STL算法有完美搭配的class,都应当定义自己的<code>value_type</code>内嵌型别。</p>
<h6 id="difference_type">3.2.2 difference_type</h6>
<p><code>difference_type</code>用来表示两个迭代器的距离，因此也可以用来表示一个容器的最大容量。比如STL的<code>count</code>算法统计指定值出现次数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I*&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">count</span><span class="params">(I fist,I last,<span class="type">const</span> T&amp; value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I*&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;first!=last;++first)</span><br><span class="line">		<span class="keyword">if</span>(*first==value)</span><br><span class="line">			++n;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="reference">3.2.3 reference</h6>
<p><code>reference_type</code>即我们熟知的C++当中的左值引用，这个类型允许我们通过迭代器来对容器内的元素做出改变。</p>
<h6 id="pointer">3.2.4 pointer</h6>
<p><code>pointer</code>是指指针，传回一个指针表示我们也可以通过迭代器对容器内的元素做改变。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="iterator_category">3.2.5 iterator_category</h6>
<p>这个型别是迭代器的类型型名，必须指定迭代器的分类如下： <img src="/STL源码剖析/iterator.png" width="300"> 我们在设计算法的时候，必须针对上图的某种迭代器提供一明确定义，比如有一个算法明确使用<code>ForwardIterator</code>，那就应当明确传递这种迭代器，虽然传递<code>RandomAccessIterator</code>和<code>BidirectionalIterator</code>也可以,但效率并不是最佳。</p>
<h5 id="iterator源代码展示">3.3.iterator源代码展示</h5>
<p>下面的源代码选自SGI版本的STL<code>&lt;stl_iterator.h&gt;</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ITERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ITERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//五种迭代器，作为标记型别（tag types）,不需要任何成员</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iteratoe_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为避免写代码时挂一漏万，自行开发的迭代器最好继承自下面这个 std::iterator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Category</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>=<span class="type">ptrdiff_t</span>,</span><br><span class="line">		<span class="keyword">class</span> Pointer=T*,<span class="keyword">class</span> Reference=T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//五种迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> input_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                   value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance            difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                  pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                  reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                     value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance              difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                    pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                    reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;榨汁机&quot;traits</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer            pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference          reference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生指针（naive pointer）而设计的traits偏特性化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对Pointer-to-const而设计的traits偏特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T*                    pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T                     reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某迭代器iterator的类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">category</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器的value_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器的distance_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type*</span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//........................整组advance函数............................................</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数重载，使迭代器能在编译时期就确定调用哪个函数*/</span>  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为input_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_InputIter&amp; __i, _Distance __n, input_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (__n--) ++__i;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为bidirectional_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_BidirectionalIterator&amp; __i, _Distance __n,   </span><br><span class="line">                      bidirectional_iterator_tag) </span><br><span class="line">&#123;  </span><br><span class="line">  __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);  </span><br><span class="line">  <span class="keyword">if</span> (__n &gt;= <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">while</span> (__n--) ++__i;</span><br><span class="line">  <span class="keyword">else</span>  </span><br><span class="line">    <span class="keyword">while</span> (__n++) --__i;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为random_access_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_RandomAccessIterator&amp; __i, _Distance __n,   </span><br><span class="line">                      random_access_iterator_tag) </span><br><span class="line">&#123;  </span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);  </span><br><span class="line">  __i += __n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*决定调用哪个函数，这是一个对外接口*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(_InputIterator&amp; __i, _Distance __n)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_InputIterator, _InputIterator);</span><br><span class="line">  __advance(__i, __n, <span class="built_in">iterator_category</span>(__i));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//............................整组distance函数........................................</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function">	<span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __distance(first, last,</span><br><span class="line">			std::iterator_traits&lt;InputIterator&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">	_distance(InputIterator first,InpuetIterator，input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">    	++first;</span><br><span class="line">		++n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::difference_type </span><br><span class="line">        __distance(InputIterator first, InputIterator last, </span><br><span class="line">		std::random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的<code>advan</code>函数<strong><em>如果</em></strong>不加第三个参数，因为型别都未定，<strong>是实打实的<code>template</code>，不是重载函数，如下：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_II</span><span class="params">(InputIterator&amp; __i, _Distance __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectinalIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_BI</span><span class="params">(BidirectinalIterator&amp; __i, _Distance __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_RI</span><span class="params">(RandomAccessIterator&amp; __i, _Distance __n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们调用的时候，如果选错使用<code>advance_II</code>来进行<code>advance_RI</code>的工作内容，则原本的O(1)时间复杂度就变成了O(n)，<strong>因此在源码中通过增加五个结构体，来给这些函数增加第三个确定的参数形成重载机制，在编译时能够使用重载确定调用哪一个版本，容错率高</strong>。<code>distance</code>函数也是这样的思想。这是一个值得借鉴的模板编写方式！</p>
<h4 id="序列式容器">4. 序列式容器</h4>
<p>序列式容器当中的元素都可序，但未必一定有序，全看编程者的操作。C++语言本身带有<code>array</code>，STL提供<code>vector、list、deque、stack、queue、priority_queue</code>等序列容器。由于<code>stack\queue</code>只是将<code>deque</code>改头换面而成，技术上被归为配接器。</p>
<h5 id="vector">4.1 vector</h5>
<p>在<code>vector</code>中最关键的在于器对大小的控制以及重新配置时数据的移动效率。这些在后面会介绍到，这里我们先对<code>vector</code>的源码进行简单介绍： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T			value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;		<span class="comment">//这个说明了迭代器就是普通指针</span></span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> 		size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> 	difference_type;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//Simple_alloc时SGI STL的空间配置器，</span></span><br><span class="line">	<span class="comment">//虽然vector使用了缺省的配置器,但Simple_alloc更方便以元素大小为配置单元</span></span><br><span class="line">	<span class="keyword">typedef</span> Simple_alloc&lt;value_type,Alloc&gt;data_allocator;</span><br><span class="line">	iterator start;						<span class="comment">//表示目前使用空间的头</span></span><br><span class="line">	iterator finissh;					<span class="comment">//表示目前使用空间的尾</span></span><br><span class="line">	iterator end_of_storage;			<span class="comment">//表示目前可用空间的尾</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_aux</span><span class="params">(iterator position,<span class="type">const</span> T&amp;x)</span></span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...<span class="comment">//一些操作接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 因为<code>vector</code>维护的一个连续空间，所有不论元素型别为哪一种，普通指针都可以作为<code>vector</code>的迭代器而满足所有必要条件，因为像<code>operator*,-&gt;,++,--,+,-,+=,-+</code>这些操作，普通的指针天生就具备。也就是说普通指针就是<code>RandomAccessIterator</code>，支持随机存取。</p>
<h6 id="扩容机制">4.1.1 扩容机制</h6>
<p>在不同的STL版本中，vector的扩容策略不相同，msvc编译器每次是以1.5倍且向下取整的策略进行扩容，gcc编译器则是SGI版本，每次以2.0倍的策略进行扩容。下图时MSVC中的扩容机制 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MSVC</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">34</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(n);</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;size:&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot;  capacity:&quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">size:<span class="number">1</span>  capacity:<span class="number">1</span></span><br><span class="line">size:<span class="number">2</span>  capacity:<span class="number">2</span></span><br><span class="line">size:<span class="number">3</span>  capacity:<span class="number">3</span></span><br><span class="line">size:<span class="number">4</span>  capacity:<span class="number">4</span></span><br><span class="line">size:<span class="number">5</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">6</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">7</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">8</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">9</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">10</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">11</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">12</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">13</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">14</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">15</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">16</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">17</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">18</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">19</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">20</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">21</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">22</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">23</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">24</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">25</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">26</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">27</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">28</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">29</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">30</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">31</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">32</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">33</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">34</span>  capacity:<span class="number">42</span></span><br></pre></td></tr></table></figure></p>
<p>所谓的动态增加，并不是在原空间之后接续新空间，因为无法保证原空间之后尚有可供配置的空间，二是以原来的2倍或1.5倍另外配置一块较大空间，然后将内容拷贝过来，然后才在原内容之后构造新元素，并释放原空间。因此对<code>vector</code>的任何操作若会影响到空间重新配置，指向<code>vector</code>的所有迭代器就都失效了。</p>
<h5 id="list">4.2 list</h5>
<p>相较于<code>vector</code>的连续线性空间，list就比较复杂，它的好处就是每次插入或删除元素，才配置或释放一个元素空间。<strong><code>list</code>是一个双向链表，它不再能够像<code>vector</code>一样以</strong>普通指针<strong>作为迭代器，因为其节点不保证再空间中连续存在，<code>list</code>迭代器必须有能指向<code>list</code>的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。</strong></p>
<h6 id="list的迭代器">4.2.1 list的迭代器</h6>
<p><strong><code>list</code>的迭代器的要求:</strong></p>
<ul>
<li>迭代器必须具备前移、后移的能力，因此对<code>list</code>提供的是<code>BidirectinalIterator</code></li>
<li>与vector不同，不论是何时的插入操作和删除操作、接合操作都不会造成原因的<code>list</code>迭代器失效</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	link_type node; <span class="comment">//迭代器内部需要一个普通指针，指向list的节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//constructor</span></span><br><span class="line">	__list_iterator(link_type x):<span class="built_in">node</span>(x)&#123;&#125;</span><br><span class="line">	__list_iterator()&#123;&#125;</span><br><span class="line">	__list_iterator(<span class="type">const</span> iterator&amp; x):<span class="built_in">node</span>(x.node)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node==x.node;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node!=x.node;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以下对迭代器取值，取的是节点的数据值</span></span><br><span class="line">	reference <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对迭代器累加</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">		node=(link_type)((*node).next);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">		self tmp=*<span class="keyword">this</span>;</span><br><span class="line">		++*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对迭代器减1</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">		node=(link_type)((*node).prev);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">		self tmp=*<span class="keyword">this</span>;</span><br><span class="line">		--*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="list的数据结构">4.2.2 list的数据结构</h6>
<p><code>list</code>是一个<strong>双向环形链表</strong>，所有它只需要一个指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> _list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	link_type node;		<span class="comment">//只需一个指针</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="deque">4.3 deque</h5>
<p><strong><code>deque</code>是一种双向开口的连续线性空间，即指能在头尾两端都支持元素的插入和删除</strong> <img src="/STL源码剖析/deque.png" width="500"> <code>vector</code>虽然也能支持在头尾两端进行操作，但是效率奇差，无法接受，因为在头部的插入导致后面所有元素都要后移。而<code>deque</code>则不会：</p>
<ul>
<li><code>duque</code>允许时间复杂度<code>O(1)</code>对其头端进行元素的插入和移除，<code>vector</code>为<code>O(n)</code></li>
<li><code>deque</code>没有所谓的容量概念，因为它是动态地以连续空间组合而成，随时可以增加一段新的空间并链接起来，即不会发生如<code>vector</code>那样的空间重新配置机制</li>
<li>虽然<code>deque</code>也提供<code>RandomAccessIterator</code>，但它的迭代器并不是普通指针，其复杂度和<code>vector</code>不可同道里计，因此除非必要我们应该尽量选择<code>vector</code>而不是<code>deque</code>。</li>
<li>在对<code>deque</code>进行排序操作，为了最高效率，可将<code>deque</code>先完整复制到一个<code>vector</code>身上，将<code>vector</code>排序后再复制会<code>deque</code></li>
</ul>
<h6 id="deque的中控器">4.3.1 deque的中控器</h6>
<p><code>deque</code>是逻辑上是连续空间。<code>deque</code>系由一段一段的定量空间组成，一旦必要在<code>deque</code>的前端或尾增加空间，便配置一段定量连续空间，串接在整个<code>deque</code>的头端或尾端。因此对于<code>deque</code>容器来说必须维护其整体连续的假象，并提供随机存取接口，那么必须有中央控制器和复杂的迭代架构去实现。</p>
<p><strong><code>Deque</code>采取一块所谓的<code>map</code>(注意，不是STL的map容器)作为主控，这里所谓的<code>map</code>是一小块连续的内存空间，其中每一个元素(此处成为一个结点<code>node</code>)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是<code>deque</code>的存储空间的主体。</strong><code>SGI STL</code>允许我们指定缓冲区大小，默认使用<code>512bytes</code>(<code>map</code>其实就是二重指针<code>T**</code>) <img src="/STL源码剖析/dequemap.png" width="500"></p>
<h6 id="deque的迭代器">4.3.2 deque的迭代器</h6>
<p>对于<code>deque</code>，维持其整体连续的假象，落在了迭代器的<code>operator++</code>和<code>operator--</code>两个重载运算符上。</p>
<ul>
<li>该迭代器必须能够指出分段连续空间在哪里</li>
<li>其次他必须能够判断自己是否已经处在其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃到下一个或上一个缓冲区。</li>
</ul>
<p>因此为了能够正确跳跃，<code>deque</code>必须随时掌握管控中心<code>map</code>。如下的实现方式可行: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>,<span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span>&#123; <span class="comment">//为继承 std::iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;,T*,Bufsize&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*,Bufsize&gt; const_iterator;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> __deque_buf_size(Bufsize,<span class="built_in">sizeof</span>(T));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未继承std::iterator,所以必须自行撰写下述五个必要的迭代器相应型别</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref renference; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持与容器的联结</span></span><br><span class="line">    T* cur; <span class="comment">//此迭代器所指之缓冲区中的现行(current)元素</span></span><br><span class="line">    T* first; <span class="comment">//此迭代器所指之缓冲区中的头</span></span><br><span class="line">    T* last; <span class="comment">//此迭代器所指之缓冲区中的尾(含备用空间)</span></span><br><span class="line">    map_pointer node; <span class="comment">//指向管控中心</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n,<span class="type">size_t</span> sz)&#123;</span><br><span class="line">        <span class="keyword">return</span> n!=<span class="number">0</span>? n:(sz&lt;<span class="number">512</span>? <span class="built_in">size_t</span>(<span class="number">512</span>/sz):<span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    n!=0,返回n，表示buffer_size由	用户自定义</span></span><br><span class="line"><span class="comment">    n=0,表示buffer_size使用默认值，那么：</span></span><br><span class="line"><span class="comment">        sz&lt;512,传回512/sz;</span></span><br><span class="line"><span class="comment">        sz&gt;=512,传回1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <img src="/STL源码剖析/dequeiterator.png" width="700"> 如上图，假设我们产生一个元素类型未<code>int</code>,缓冲区为8的<code>deque</code>，经过增删操作后拥有20个元素。<strong><code>deque</code>类内的<code>start</code>和<code>finish</code>分别指向<code>deque</code>的第一个缓冲区和最后一个缓冲区，20/8=3，所以map拥有3个节点，且最后一个缓冲区还有插入元素的空间。</strong>三个指针<code>cur、first、last</code>分别如图所示，`cur·指向缓冲区的最后一个元素的下一个位置。</p>
<p>下面是deque几个重要操作： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span></span>&#123;</span><br><span class="line">	node=new_node;</span><br><span class="line">    first=*new_node;</span><br><span class="line">    last=first+<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">renference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> *cur;&#125;</span><br><span class="line"></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())*</span><br><span class="line">		(node-x.node<span class="number">-1</span>)+(cur-first)+(x.last-x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">    ++cur; <span class="comment">//切换下一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(cur==last)&#123; <span class="comment">//如果已达到所在缓冲区的尾端</span></span><br><span class="line">        <span class="built_in">set_node</span>(node+<span class="number">1</span>); <span class="comment">//利用set_node方法切换到下一个缓冲区</span></span><br><span class="line">        cur=first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>; <span class="comment">//调用operator++</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==first)&#123; <span class="comment">//如果达到缓冲区的头部</span></span><br><span class="line">        <span class="built_in">set_node</span>(node<span class="number">-1</span>); <span class="comment">//利用set_node方法切换到上一个缓冲区</span></span><br><span class="line">        cur=first;</span><br><span class="line">    &#125;</span><br><span class="line">    --cur;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>; <span class="comment">//调用operator--</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)&#123; <span class="comment">//实现随机存取、迭代器可以直接跳跃n个距离</span></span><br><span class="line">    difference_type offset=n+(cur-first);</span><br><span class="line">    <span class="keyword">if</span>(offset&gt;=<span class="number">0</span>&amp;&amp;offset&lt;<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) <span class="comment">//目标位置在统一缓冲区</span></span><br><span class="line">        cur+=n;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//目标位置不在统一缓冲区</span></span><br><span class="line">       		difference_type node_offset=offset&gt;<span class="number">0</span>?</span><br><span class="line">			offset/<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">				:-<span class="built_in">difference_type</span>((-offset<span class="number">-1</span>)/<span class="built_in">buffer_size</span>())<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">set_node</span>(node+node_offset); <span class="comment">//切换至正确的节点</span></span><br><span class="line">            cur=first+(offset-node_offset*<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()); <span class="comment">//切换至正确的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp+=n; <span class="comment">//调用operator+=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>+=-n;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp-=n; <span class="comment">//调用operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机存取第n个元素</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n)<span class="type">const</span> &#123;<span class="keyword">return</span> *(*<span class="keyword">this</span>+n);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> cur==x.cur;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> !(*<span class="keyword">this</span>==x);&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="built_in">return</span> (node==x.node)?(cur&lt;x.cur):(node&lt;x.node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="deque的数据结构">4.3.3 deque的数据结构</h6>
<p>deque除了维护<code>map</code>指针外，还必须维护<code>start、finish</code>两个迭代器，分别指向第一个缓冲区的第一个元素和最后一个缓冲区的额最后一个元素。此外，它当然也必须记住目前的map大小，因为一旦<code>map</code>所提供的节点不足，就必须重新配置更大的一块<code>map</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc,<span class="type">size_t</span> BufSiz=<span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;,T*,BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//元素的指针的指针</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start; <span class="comment">//表示第一个节点</span></span><br><span class="line">    iterator finish; <span class="comment">//表示最后一个节点</span></span><br><span class="line">    map_pointer map; <span class="comment">//指向map，map是块连续空间，其每个元素都是指针，指向一个节点</span></span><br><span class="line">    size_type map_size; <span class="comment">//map内有多个指针</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n)&#123;</span><br><span class="line">        <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">//调用operator[]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *start;&#125; <span class="comment">//调用operator*</span></span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        iterator temp=finish;</span><br><span class="line">        --temp; <span class="comment">//调用operator--</span></span><br><span class="line">        <span class="keyword">return</span> *temp; <span class="comment">//调用operator*</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> finish-start;&#125; <span class="comment">//调用operator-</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> finish==start;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="heap">4.5. heap</h5>
<p><code>heap</code>不属于STL的容器组件，但我们有必要认识它的实现思想，它是实现<code>priority queue</code>的助手。<code>priority queue</code>允许用户以任何次序将元素存入容器中，但是取出时一定时从优先权最高的元素开始取。而堆正有这样的特性，适合作为<code>priority queue</code>的底层机制。</p>
<p>对于heap的虽然讲解的时候用的是<strong>完全二叉树</strong>的形式来讲解，但只是为了更直观的表达而已，一般来说实现都是采用数组的形式来实现的，同时为了达到空间可增长，采用<code>vector+heap算法</code>来实现堆。</p>
<p><img src="/STL源码剖析/heapSort.gif" width="500"></p>
<h6 id="push_heap算法">4.5.1 push_heap算法</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意，此函式被调用时，新元素已置于底部容器的最尾端</span></span><br><span class="line">    __push_heap_aux(first, last, <span class="built_in">distance_type</span>(first),<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap_aux</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last, Distance*, T*)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>),<span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">    <span class="comment">// 以上系根据implicit representation heap的结构特性：新值必置于底部</span></span><br><span class="line">    <span class="comment">// 容器的最尾端，此即第一个洞号：(last-first)–1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 push_back()不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __push_heap(RandomAccessIterator first, Distance holeIndex,Distance topIndex, T value) </span><br><span class="line">&#123;</span><br><span class="line">    Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 找出父节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value) &#123;</span><br><span class="line">        <span class="comment">// 当尚未到达顶端，且父节点小于新值（于是不符合 heap 的次序特性）</span></span><br><span class="line">        <span class="comment">// 由于以㆖使用 operator&lt;，可知 STL heap 是一种 max-heap（大者为父）</span></span><br><span class="line">        *(first + holeIndex) = *(first + parent); <span class="comment">//令洞值为父值</span></span><br><span class="line">        holeIndex = parent; <span class="comment">// percolate up：调整洞号，向上提升至父节点</span></span><br><span class="line">        parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 新洞的父节点</span></span><br><span class="line">    &#125; <span class="comment">// 持续至顶端，或满足heap的次序特性为止</span></span><br><span class="line">    </span><br><span class="line">    *(first + holeIndex) = value; <span class="comment">//令洞值为新值，完成插入动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pop_heap算法">4.5.2 pop_heap算法</h6>
<p><strong><code>pop_heap</code>算法思路如下：</strong></p>
<ul>
<li>1.把根节点元素取出，把最后一个节点的元素取出</li>
<li>2.将原根节点元素放在vector的最后一个节点处</li>
<li>3.将原先的最后一个节点的元素放置到原根节点处作为新根节点</li>
<li>4.将新根节点逐个与子节点比较，直到其值比子节点都大时，结束算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __pop_heap_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap_aux(RandomAccessIterator first,RandomAccessIterator last, T*) </span><br><span class="line">&#123;</span><br><span class="line">    __pop_heap(first, last<span class="number">-1</span>, last<span class="number">-1</span>, <span class="built_in">T</span>(*(last<span class="number">-1</span>)),</span><br><span class="line">    <span class="built_in">distance_type</span>(first));</span><br><span class="line">    <span class="comment">// 以上，根据 implicit representation heap 的次序特性，pop操作的结果</span></span><br><span class="line">    <span class="comment">// 应为底部容器的第一个元素。因此，首先设定欲调整值为尾值，然后将首值调至</span></span><br><span class="line">    <span class="comment">// 尾节点（所以以上将迭代器 result设为 last-1）。然后重整 [first, last-1)，</span></span><br><span class="line">    <span class="comment">// 使之重新成一个合格的 heap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 pop_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap(RandomAccessIterator first,</span><br><span class="line">        RandomAccessIterator last,</span><br><span class="line">        RandomAccessIterator result,</span><br><span class="line">        T value, Distance*) </span><br><span class="line">&#123;</span><br><span class="line">    *result = *first; <span class="comment">// 设定尾值为首值，于是尾值即为欲求结果，</span></span><br><span class="line">                      <span class="comment">// 可由客端稍后再以底层容器之 pop_back() 取出尾值</span></span><br><span class="line"> </span><br><span class="line">    __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">    <span class="comment">// 以上欲重新调整 heap，洞号为 0（亦即树根处），欲调整值为 value（原尾值）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="sort_heap算法">4.5.3 sort_heap算法</h6>
<p>既然每次<code>pop_heap</code>可获得<code>heap</code>之中键值最大的元素，如果持续对整个<code>heap</code>做<code>pop_heap</code>动作，每次将操作范围从后向前缩减一个元素（因为pop_heap会把键值最大的元素放在底部容器的最尾端），当整个程序执行完毕，我们便有了一个递增序列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [first,last) 排列为一个heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 make_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first,RandomAccessIterator last, T*,Distance*) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//如果长度为0或1，不必重新排列</span></span><br><span class="line"> </span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    <span class="comment">// 找出第一个需要重排的子树头部，以parent标示出。由于任何叶节点都不需执行</span></span><br><span class="line">    <span class="comment">// perlocate down，所以有以下计算。parent命名不佳，名为holeIndex 更好</span></span><br><span class="line">    Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 重排以 parent 为首的子树。len是为了让__adjust_heap() 判断操作范围</span></span><br><span class="line">        __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 走完根节点，就结束。</span></span><br><span class="line">        parent--; <span class="comment">// （即将重排之子树的）头部向前一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="priority_queue">4.6 priority_queue</h5>
<p><code>priority_queue</code>是一个拥有权值观念的<code>queue</code>。其内部的元素不再像<code>queue</code>依照被存入的次序排列，而是按照元素的权值排列，权值最高者，排在最前面。缺省情况下<code>proority_queue</code>利用一个<code>max-heap</code>和<code>vector</code>为底部容器。<code>priority_queue</code>没有迭代器(<code>queue</code>和<code>stack</code>也没有) <img src="/STL源码剖析/priorityqueue.png" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;,</span><br><span class="line">    <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line">    Compare comp; <span class="comment">// 元素大小比较标准</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : c(), comp(x) &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以下用到的 make_heap(), push_heap(), pop_heap()都是泛型算法</span></span><br><span class="line">    <span class="comment">// 注意，任一个建构式都立刻于底层容器内产生一个 implicit representation heap</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; x)</span><br><span class="line">        : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(),comp); &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last)</span><br><span class="line">        : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        __STL_TRY &#123;</span><br><span class="line">            <span class="comment">// push_heap是泛型算法，先利用底层容器的 push_back() 将新元素推入末端，再重排heap</span></span><br><span class="line">            c.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); <span class="comment">//push_heap是泛型算法</span></span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        __STL_TRY &#123;</span><br><span class="line">            <span class="comment">//pop_heap 是泛型算法，从 heap 内取出一个元素。它并不是真正将元素</span></span><br><span class="line">            <span class="comment">//弹出，而是重排 heap，然后再以底层容器的 pop_back() 取得被弹出的元素</span></span><br><span class="line">            <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">            c.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="关联式容器">5. 关联式容器</h4>
<p>标准的STL关联式容器分为<code>set</code>集合和<code>map</code>映射表两大类。以及两大衍生体<code>multiset</code>和<code>multimap</code>。这些容器的底层机制均与<code>RB-tree</code>完成。红黑树是一个独立容器，但不对外界使用。同时<code>SGI STL</code>还提供了一个不在标准规则之外的管理容器<code>hash_table</code>，以及以<code>hash_table</code>为底层机制完成的<code>hash_set、hash_map、hash_multiset、hash_multimap</code>。</p>
<p>所谓关联式容器类似于关联式数据库：每笔数据都有一个键值和一个实值，当元素插入到关联式容器时会按照键值大小以某种规则将这个元素放置于合适的位置，因此对于关联式容器没有<code>push_back、push_front、pop_back、pop_front</code>这样的行为。</p>
<h5 id="rb-tree">5.1 RB-tree</h5>
<p>关于红黑树的的定义和一些平衡原理见<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构篇</a>，这里列举一些<code>SGI STL</code>的<code>RB-tree</code>源码。</p>
<h6 id="rb-tree结构体">5.1.1 RB-tree结构体</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">RB树的节点结构:</span><br><span class="line"><span class="comment">//由于红黑树的各种操作常需要上溯其父级节点，因此特别安排一个parent指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;     <span class="comment">// 红色为0</span></span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">  color_type color;     <span class="comment">// 节点颜色，红色或黑色</span></span><br><span class="line">  base_ptr parent;      <span class="comment">// 该指针指向其父节点</span></span><br><span class="line">  base_ptr left;        <span class="comment">// 指向左节点</span></span><br><span class="line">  base_ptr right;       <span class="comment">// 指向右节点</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	 <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left; <span class="comment">//一直向左走，找到最小值</span></span><br><span class="line">	 <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right; <span class="comment">//一直向右走，找到最大值</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node</span> : <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;   <span class="comment">//节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="rb-tree迭代器">5.1.2 RB-tree迭代器</h6>
<p><code>RB-tree</code>的迭代器属于双向迭代器，但不具备随机定位的能力，与<code>list</code>较为相似，比较特殊的是他具有前进和后退的操作。<code>RB-tree</code>迭代器的<code>operator++</code>是调用了基层迭代器的<code>increment()</code>函数，其<code>operator--</code>调用<code>decrement()</code>函数。 <img src="/STL源码剖析/rbtreeiterator.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基层迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_tree_base_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	base_ptr node; <span class="comment">//用来与容器之间产生一个连接的关系</span></span><br><span class="line">	<span class="comment">//实现operator++</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(node-&gt;right != <span class="number">0</span>)&#123;</span><br><span class="line">	        <span class="comment">//状况1：右子结点存在，则当前可以看成是根节点,则找出右子树的最左结点</span></span><br><span class="line">	        node = node-&gt;right;</span><br><span class="line">	        <span class="keyword">while</span>(node-&gt;left != <span class="number">0</span>)</span><br><span class="line">	            node = node-&gt;left;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">	        <span class="comment">//状况2：没有右子节点,找出父节点</span></span><br><span class="line">			<span class="comment">//如果现行节点本身是个右子节点，就一直上溯，直到不为右子节点为止</span></span><br><span class="line">	        base_ptr y = node-&gt;parent;</span><br><span class="line">	        <span class="keyword">while</span>(y-&gt;right == node)&#123;</span><br><span class="line">	            node = y;</span><br><span class="line">	            y = y-&gt;parent;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">if</span>(node-&gt;right != y)</span><br><span class="line">	            <span class="comment">//状况3：如果当前的node不是根节点，则y即为所求</span></span><br><span class="line">	            node = y;</span><br><span class="line">	        <span class="comment">//状况4：如果当前的node是根节点，则node为所求</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//实现--</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(node-&gt;color == rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)</span><br><span class="line">	        <span class="comment">//状况1：如果当前结点是header结点，那么其前驱应该是mostright结点，也就是其右子结点</span></span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//状况2：也就是当前是根节点，那么其前驱应该是左子树中最右结点</span></span><br><span class="line">                base_ptr y = node-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(y-&gt;right != <span class="number">0</span>)</span><br><span class="line">                    y = y-&gt;right;</span><br><span class="line">                node = y;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//状况3：如果当前不是根节点，也没有左子节点，那么当前处于右子树的最左结点，要去找根节点</span></span><br><span class="line">                base_ptr y = node-&gt;parent;</span><br><span class="line">                <span class="keyword">while</span>(y-&gt;left == node)</span><br><span class="line">				&#123;</span><br><span class="line">                    node = y;</span><br><span class="line">                    y = y-&gt;parent;</span><br><span class="line">                &#125;</span><br><span class="line">                node = y;</span><br><span class="line">                <span class="comment">//如果当前处于root结点，y则为header结点，那么当前必定只有root一个结点</span></span><br><span class="line">                <span class="comment">//则可以得到node = header，y = root</span></span><br><span class="line">                <span class="comment">//最终得到node = y，不需要特殊处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正规迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value,<span class="keyword">typename</span> Ref,<span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_tree_iterator</span>:<span class="keyword">public</span> rb_tree_base_iterator&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,Value&amp;,Value*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,<span class="type">const</span> Value&amp;,<span class="type">const</span> Vallue*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,Ref,Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>(link_type x)&#123;node = x&#125;;</span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>(<span class="type">const</span> iterator&amp; it)&#123;node = it.node&#125;;</span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">link_type</span>(node)-&gt;value_field;</span><br><span class="line">	&#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">	    <span class="built_in">increment</span>();</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    <span class="built_in">increment</span>();</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	    <span class="built_in">decrement</span>();</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    <span class="built_in">decrement</span>();</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="rb-tree的数据结构">5.1.3 RB-tree的数据结构</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------------rb_tree类---------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node,Alloc&gt;rb_tree_node_allocator;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//没有迭代器iterator?不！会在后面声明</span></span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">link_type <span class="title">get_node</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">allocate</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span></span>&#123;<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">deallocate</span>(p);&#125;</span><br><span class="line">    <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        link_type tmp = <span class="built_in">get_node</span>(); <span class="comment">//配置空间</span></span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            Chy::allocator&lt;Key&gt;::<span class="built_in">construct</span>(&amp;tmp-&gt;value_field,x);<span class="comment">//构造内容</span></span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(<span class="built_in">put_node</span>(tmp));</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span></span>&#123;<span class="comment">//复制一个节点的颜色和数值</span></span><br><span class="line">        link_type tmp = <span class="built_in">create_node</span>(x-&gt;value_field);</span><br><span class="line">        tmp-&gt;color = x-&gt;color;</span><br><span class="line">        tmp-&gt;left = <span class="number">0</span>;</span><br><span class="line">        tmp-&gt;right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span></span>&#123;</span><br><span class="line">        Chy::allocator&lt;Key&gt;::<span class="built_in">destroy</span>(&amp;p-&gt;value_field); <span class="comment">//析构内容</span></span><br><span class="line">        <span class="built_in">put_node</span>(p); <span class="comment">//释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//RB-tree只使用三笔数据表现</span></span><br><span class="line">    size_type node_count; <span class="comment">//追踪记录树的大小 (节点的数量)</span></span><br><span class="line">    link_type header;     <span class="comment">//实现上的小技巧</span></span><br><span class="line">    Compare key_compare;  <span class="comment">//节点之间的键值大小的比较准则. 应该会是一个function object</span></span><br><span class="line">    <span class="comment">//以下三个函数用于方便获取header的成员</span></span><br><span class="line">    <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;parent;&#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">left_most</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;left;&#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">right_most</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;right;&#125;</span><br><span class="line">    <span class="comment">//以下六个函数用于方便获得节点x的成员</span></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;left;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;right;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;parent;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span> x-&gt;value_field;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x));&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span></span>&#123;<span class="keyword">return</span> (color_type&amp;) (x-&gt;color);&#125;</span><br><span class="line">    <span class="comment">//获取极大值和极小值 node class有实现此功能</span></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type,reference,pointer&gt;iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    iterator __insert(base_ptr x,base_ptr y,<span class="type">const</span> value_type&amp; v);</span><br><span class="line">    link_type __copy(link_type x,link_type p);</span><br><span class="line">    <span class="type">void</span> __erase(link_type x);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">            __erase(<span class="built_in">root</span>());</span><br><span class="line">            <span class="built_in">left_most</span>() = header;</span><br><span class="line">            <span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">right_most</span>() = header;</span><br><span class="line">            node_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        header = <span class="built_in">get_node</span>(); <span class="comment">//产生一个节点空间 令header指向它</span></span><br><span class="line">        <span class="built_in">color</span>(header) = __rb_tree_red;<span class="comment">//令header为红色 用于区分header和root,在iterator的operator++中</span></span><br><span class="line">        <span class="built_in">root</span>() == <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">left_most</span>() = header;   <span class="comment">//令header的左子节点等于自己</span></span><br><span class="line">        <span class="built_in">right_most</span>() = header;  <span class="comment">//令header的右子节点等于自己</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//allocation / deallocation</span></span><br><span class="line">    <span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">            : <span class="built_in">node_count</span>(<span class="number">0</span>),<span class="built_in">key_compare</span>(comp)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">rb_tree</span>()&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">put_node</span>(header);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp;<span class="keyword">operator</span>==(<span class="type">const</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp;x);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> key_compare;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">left_most</span>();&#125; <span class="comment">//RB树的起头为最左(最小)节点处</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> header;&#125; <span class="comment">//RB树的终点为header所指处</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> node_count == <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> node_count;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span> (<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//insert/erase</span></span><br><span class="line">    <span class="comment">//将x插入到RB-Tree中 (保持节点的独一无二)</span></span><br><span class="line">    <span class="function">std::pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//将x插入到RB-Tree中 (允许节点数值重复)</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//寻找键值为k的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> value_type&amp; k)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------rb_tree类主要函数的实现--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新的数值 节点键值允许重复</span></span><br><span class="line"><span class="comment">//注意：返回的是一个RB-Tree的迭代器，指向的是新增的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//根节点开始</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;        <span class="comment">//根节点开始 从上往下寻找适当的插入节点</span></span><br><span class="line">        y = x;</span><br><span class="line">        <span class="comment">//如果当前根节点比 输入的v大，则转向左边，否则转向右边</span></span><br><span class="line">        x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x为新值插入点 y为插入点的父节点 v为新值</span></span><br><span class="line">    <span class="keyword">return</span> __insert(x,y,v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入新的数值 节点键值不允许重复</span></span><br><span class="line"><span class="comment">//注意：返回结果是pair类型，第一个元素是一个RB-Tree的迭代器，指向的是新增的节点；第二个参数表示插入成功与否</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">std::pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator,<span class="type">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//从根节点开始</span></span><br><span class="line">    <span class="type">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123; <span class="comment">//从根节点开始 往下寻找适当的插入点</span></span><br><span class="line">        y = x;</span><br><span class="line">        comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)); <span class="comment">//v键值小于目前节点的键值</span></span><br><span class="line">        x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x); <span class="comment">//遇&quot;大&quot;则向左 遇&quot;小&quot;则向右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离开while循环之后 y所指的即 插入点之父节点（此时它必为叶子结点）</span></span><br><span class="line">    iterator j = <span class="built_in">iterator</span>(y); <span class="comment">//迭代器j指向插入点的父节点y</span></span><br><span class="line">    <span class="keyword">if</span> (comp)&#123;</span><br><span class="line">        <span class="comment">//如果while循环时候，判定comp的数值，如果comp为真(表示遇到大的元素，将插入左侧)</span></span><br><span class="line">        <span class="comment">//如果插入节点的父节点是最左侧的节点</span></span><br><span class="line">        <span class="comment">//x为插入点，y为插入节点的父节点，v表示新值</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">begin</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(__insert(x,y,v), <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//插入节点的父节点不是最左侧的节点</span></span><br><span class="line">            <span class="comment">//调整j 回头准备测试</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node),<span class="built_in">KeyOfValue</span>()(v)))&#123;</span><br><span class="line">            <span class="comment">//小于新值（表示遇到小的数值，将插在右侧）</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(__insert(x,y,v), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此 表示新值一定和树中的键值重复 就不应该插入新的数值</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//真正的插入执行程序 __insert()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::__insert(base_ptr x_, base_ptr y_, <span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    <span class="comment">//参数x_为新的插入点 参数y_为插入点的父节点 参数v为新值</span></span><br><span class="line">    link_type x = (link_type)x_;</span><br><span class="line">    link_type y = (link_type)y_;</span><br><span class="line">    link_type z ;</span><br><span class="line">    <span class="comment">//key_compare 是键值大小的比较准则，应该是一个function object</span></span><br><span class="line">    <span class="keyword">if</span> (y == header||x != <span class="number">0</span>||<span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v),<span class="built_in">key</span>(x)))&#123;</span><br><span class="line">        z = <span class="built_in">create_node</span>(v); <span class="comment">//产生一个新的节点</span></span><br><span class="line">        <span class="comment">//当y即为header的时候，leftmost = z;</span></span><br><span class="line">        <span class="keyword">if</span> (y == header)&#123;</span><br><span class="line">            <span class="built_in">root</span>() = z;</span><br><span class="line">            <span class="built_in">right_most</span>() = z;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">left_most</span>())&#123;</span><br><span class="line">            <span class="comment">//y为最左节点</span></span><br><span class="line">            <span class="comment">//维护leftmost() 使其永远指向最左节点</span></span><br><span class="line">            <span class="built_in">left_most</span>() = z;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            z = <span class="built_in">create_node</span>(v);<span class="comment">//产生一个新的节点</span></span><br><span class="line">            <span class="comment">//让新节成为插入点的父节点y的右子节点</span></span><br><span class="line">            <span class="built_in">right</span>(y) = z;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="built_in">right_most</span>())&#123; <span class="comment">//维护rightmost()让其永远指向最右的节点</span></span><br><span class="line">                <span class="built_in">right_most</span>() = z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">parent</span>(z) = y; <span class="comment">//设定新节点的父节点</span></span><br><span class="line">        <span class="built_in">left</span>(z) = <span class="number">0</span>; <span class="comment">//设定新节点的左子节点</span></span><br><span class="line">        <span class="built_in">right</span>(z) = <span class="number">0</span>; <span class="comment">//设定新节点的右子节点</span></span><br><span class="line">        <span class="comment">//修改颜色</span></span><br><span class="line">        <span class="comment">//参数一为新增节点 ；参数二 为root</span></span><br><span class="line">        __rb_tree_rebalance(z,header-&gt;parent);</span><br><span class="line">        ++node_count;</span><br><span class="line">        <span class="comment">//返回一个迭代器 指向新的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必须为红色，如果插入出父节点同样为红色，就需要进行树形旋转</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_rotate_left(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    <span class="comment">//x为旋转点</span></span><br><span class="line">    __rb_tree_node_base* y = x-&gt;right;<span class="comment">//令y为旋转点的右子节点</span></span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//回马枪设定父亲节点</span></span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="comment">//令y完全替代x的地位 (需要将x对其父节点的关系完全接收回来)</span></span><br><span class="line">    <span class="keyword">if</span> (x == root)&#123;</span><br><span class="line">        root = y; <span class="comment">//x为根节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;  <span class="comment">//x为其父节点的左子节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y; <span class="comment">//x为其父节点的右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必须为红色，如果插入出父节点同样为红色，就需要进行树形旋转</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_rotate_right(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    <span class="comment">//x为旋转点</span></span><br><span class="line">    __rb_tree_node_base* y = x-&gt;left; <span class="comment">//y为旋转点的左子节点</span></span><br><span class="line">    x-&gt;left = y-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;right != <span class="number">0</span>)&#123;</span><br><span class="line">        y-&gt;right-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="comment">//令y完全替代x的地位</span></span><br><span class="line">    <span class="keyword">if</span>(x == root)&#123;</span><br><span class="line">        root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//调整RB_tree 插入节点之后，需要进行调整(颜色/翻转)从而满足要求</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_balance(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    x-&gt;color = __rb_tree_red; <span class="comment">//新节点的颜色必须是红色的</span></span><br><span class="line">    <span class="keyword">while</span>(x!=root &amp;&amp; x-&gt;parent-&gt;color == __rb_tree_red)&#123;</span><br><span class="line">        <span class="comment">//父节点为红色的</span></span><br><span class="line">        <span class="comment">//父节点为祖父节点的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left)&#123;</span><br><span class="line">            <span class="comment">//令y为伯父节点</span></span><br><span class="line">            __rb_tree_node_base* y = x-&gt;parent-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)&#123; <span class="comment">//伯父节点存在 且为红</span></span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//更改父节点的颜色为黑</span></span><br><span class="line">                y-&gt;color = __rb_tree_black;<span class="comment">//更改父节点的颜色为黑</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//更改祖父节点的颜色为红</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无伯父节点 或者伯父节点的颜色为黑</span></span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)&#123;</span><br><span class="line">                    <span class="comment">//新节点为父节点的右子节点</span></span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    <span class="comment">//第一次参数为左旋节点</span></span><br><span class="line">                    __rb_tree_rotate_left(x,root);</span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                <span class="comment">//第一次参数为右旋节点</span></span><br><span class="line">                __rb_tree_rotate_right(x-&gt;parent-&gt;parent,root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//父节点为祖父节点的右子节点</span></span><br><span class="line">            __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left; <span class="comment">//令y为伯父节点</span></span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)&#123; <span class="comment">//存在伯父节点，且为红</span></span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//更改父节点为黑</span></span><br><span class="line">                y-&gt;color = __rb_tree_black;<span class="comment">//更改伯父节点为黑</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; <span class="comment">//更改祖父节点为红</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent; <span class="comment">//准备继续往上层检查</span></span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无伯父节点 或者伯父节点 为黑</span></span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">                    <span class="comment">//新节点 为 父节点的左子节点</span></span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    __rb_tree_rotate_right(x,root); <span class="comment">//第一参数为右旋转点</span></span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                <span class="comment">//第一参数为左旋点</span></span><br><span class="line">                __rb_tree_rotate_left(x-&gt;parent-&gt;parent,root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//while结束</span></span><br><span class="line">    root-&gt;color = __rb_tree_black;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//元素查找程序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">find</span>(<span class="type">const</span> value_type &amp;k) &#123;</span><br><span class="line">    link_type y = header; <span class="comment">//last node which is  not less than k</span></span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//current node</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//key_compare 是节点大小的比较准则 function object</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x),k))&#123;</span><br><span class="line">            <span class="comment">//进行到这里 表示x的数值大于k 。遇到大的数值向左走</span></span><br><span class="line">            y = x,x = <span class="built_in">left</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator j = <span class="built_in">iterator</span> (y);</span><br><span class="line">    <span class="keyword">return</span> (j == <span class="built_in">end</span>() || <span class="built_in">key_compare</span>(k,<span class="built_in">key</span>(j.node))) ? <span class="built_in">end</span>() : j;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/************************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//注意：以下的identify定义于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">identify</span> : <span class="keyword">public</span> std::unary_function&lt;T,T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="set">5.2 set</h5>
<ul>
<li><code>set</code>的特性是 所有的元素会按照键值自动排序</li>
<li><code>set</code>的键值等同于实值</li>
<li><strong><code>set</code>不允许涵盖两个相同的键值</strong></li>
<li><strong>不可以通过迭代器修改<code>set</code>的元素数值，这会破坏元素的排列顺序。因此<code>set&lt;T&gt;::iterator</code>被定义为底层<code>RB-tree</code>的<code>const_iterator</code>,杜绝写入。也就是<code>set</code>的<code>iterators</code>是一种<code>const iterators</code></strong></li>
<li><code>set</code>类似<code>list</code>，当客户端对其进行元素的新增或者删除操作的时候，<strong>操作之前的迭代器不会失效，但是被操作的迭代器会失效</strong></li>
<li>STL提供了一组<code>set/multiset</code>的相关算法，包括交集<code>set_intersection</code><code>set_union</code><code>set_difference</code><code>set_symmetric_difference</code></li>
<li><code>set</code>利用<code>RB-tree</code>的排序机制，因此是基于红黑树进一步的函数封装</li>
</ul>
<h6 id="set源码">5.2.1 set源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> set&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">    <span class="comment">//注意key_compare 和 value_compre 使用同一个比较函数</span></span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,identify&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">    rep_type t; <span class="comment">//使用红黑树(RB-Tree)实现set</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">    <span class="comment">//set迭代器无法执行写入操作，因为set的元素有一定的次序安排，不允许用户在任意处进行写入操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_uterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    <span class="comment">//allocation/deallocation</span></span><br><span class="line">    <span class="comment">//set使用RB-Tree的insert_unique() 要求插入的元素都不可以重复</span></span><br><span class="line">    <span class="comment">//multiset 使用 insert_equal() 允许相同键值的存在</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">set</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(InputIterator first,InputIterator last)</span> : t(Compare())&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">set</span>(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x):<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">    set&lt;Key,Compare,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">        t = x.t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//set进行函数的包装</span></span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="comment">//需要注意 set使用的value_comp 事实上为RB-Tree的key_comp()</span></span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(set&lt;Key,Compare,Alloc&gt;&amp; x)</span></span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//insert / erase</span></span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;iterator,<span class="type">bool</span>&gt;pair_iterator_bool;</span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">        std::pair&lt;<span class="keyword">typename</span> rep_type::iterator,<span class="type">bool</span>&gt; p = t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(p.first,p.second);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position,<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>((rep_iterator&amp;)position,x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first,InputIterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        t.<span class="built_in">erase</span>((rep_iterator&amp;)position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        t.<span class="built_in">erase</span>((rep_iterator&amp;)first,(rep_iterator&amp;)last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set operations</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">count</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    std::pair&lt;iterator,iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下的__STL_NULL_TMPL_ARGS 被定义为&lt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;,<span class="type">const</span> set&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;,<span class="type">const</span> set&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="map">5.3 map</h5>
<ul>
<li>所有元素会根据元素的键值自动被排序</li>
<li>元素的类型是<code>pair</code>，同时拥有键值和实值；<code>map</code>不允许两个元素出现相同的键值</li>
<li>不可以修改<code>map</code>的键值 但是可以修改实值</li>
<li><code>map</code>基于红黑树实现对应的函数</li>
<li><code>map</code>和<code>set</code>一样，操作和删除操作时，操作之前的迭代器在操作之后依然有效</li>
</ul>
<h6 id="pair类型的定义">5.3.1 pair类型的定义</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    T1 first;    <span class="comment">//public</span></span><br><span class="line">    T2 second;  <span class="comment">//public</span></span><br><span class="line">    <span class="built_in">pair</span>():<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a,<span class="type">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="map源码">5.3.2 map源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> map&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;<span class="comment">//键值型别</span></span><br><span class="line">    <span class="keyword">typedef</span> T data_type;<span class="comment">//数据(实值)型别</span></span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;<span class="type">const</span> Key,T&gt;value_type; <span class="comment">//元素型别(键值/实值)</span></span><br><span class="line">    <span class="comment">//键值比较函数</span></span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="comment">//以下定义一个functor 其作用就是调用&quot;元素比较函数&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">value_compare</span> : <span class="keyword">public</span> std::binary_function&lt;value_type,value_type,<span class="type">bool</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>&lt;Key,T,Compare,Alloc&gt;;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Compare comp;</span><br><span class="line">        <span class="built_in">value_compare</span>(Compare c):<span class="built_in">comp</span>(c)&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> value_type&amp; x,<span class="type">const</span> value_type&amp; y)</span><span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">comp</span>(x.first,y.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//定义表述型别 使用map元素的型别(pair)作为第一性别，作为红黑树节点的键值型别</span></span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,_Select1st&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">    rep_type t; <span class="comment">//使用红黑树(RB-Tree)实现map</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">    <span class="comment">//map迭代器无法执行写入操作，因为map的元素有一定的次序安排，不允许用户在任意处进行写入操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reverse_iterator reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    <span class="comment">//allocation/deallocation</span></span><br><span class="line">    <span class="comment">//map使用RB-Tree的insert_unique() 要求插入的元素都不可以重复</span></span><br><span class="line">    <span class="comment">//multimap 使用 insert_equal() 允许相同键值的存在</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">map</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">map</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">map</span><span class="params">(InputIterator first,InputIterator last)</span> : t(Compare())&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">map</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">map</span>(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x):<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">    map&lt;Key,Compare,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">        t = x.t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//map进行函数的包装</span></span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="comment">//需要注意 map使用的value_comp 事实上为RB-Tree的key_comp()</span></span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">value_compare</span>(t.<span class="built_in">key_comp</span>());&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span>  </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">    <span class="comment">//注意以下 下标操作符号</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k)&#123;</span><br><span class="line">        <span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k,<span class="built_in">T</span>()))).first)).second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(map&lt;Key,Compare,Alloc&gt;&amp; x)</span></span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//insert / erase</span></span><br><span class="line"><span class="comment">//    typedef std::pair&lt;iterator,bool&gt;pair_iterator_bool;</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position,<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(position,x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first,InputIterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map operations</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">count</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    std::pair&lt;iterator,iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;const_iterator,const_iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//以下的__STL_NULL_TMPL_ARGS 被定义为&lt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> map&amp;,<span class="type">const</span> map&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> map&amp;,<span class="type">const</span> map&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="multisetmap">5.3.3 multiset/map</h6>
<p><code>muiltiset\multimap</code>和它们对应的<code>set\map</code>特性完全相同，唯一不同点时<code>multi</code>允许键值重复，因此插入采用的时<code>RB-tree</code>的底层函数的<code>insert_equal()</code>而不是<code>insert_unique()</code>。</p>
<h5 id="hashtable">5.4 hashtable</h5>
<p>上面介绍的是以<code>RB-tree</code>为底层机制的容器，其在有序性和查找的性能(<code>logn</code>)上都不错。但还有一种在查找上的时间复杂度可在常数内完成的结构，那就是哈希表即：</p>
<ul>
<li>二叉搜索树具有对数平均时间的表现，<strong>但是这个需要满足的假设前提是输入的数据需要具备随机性</strong></li>
<li><code>hashtable</code>散列表这种结构在插入、删除、搜寻等操作层面上也具有常数平均时间的表现。<strong>而且不需要依赖元素的随机性，这种表现是以统计为基础的</strong></li>
</ul>
<p><strong>哈希表的特点：</strong></p>
<ul>
<li><code>hashtable</code>可提供对任何有名项的存取和删除操作</li>
<li>因为操作的对象是有名项，因此<code>hashtable</code>可以作为一种字典结构</li>
<li><strong>将一个元素映射成为一个 “大小可以接受的索引”简称为<code>hash function</code>散列函数</strong></li>
<li>考虑到元素的个数大于<code>array</code>的容量，<strong>可能有不同的元素被映射到相同的位置，简称为冲突</strong></li>
<li>解决冲突的方法有很多，线性探测、二次探测、<strong>开链</strong></li>
</ul>
<p>具体的hash思想可见<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构篇</a>，在<code>SGI STL</code>版本的<code>hash_table</code>使用的是<strong>开链法</strong>来解决哈希冲突,节点结构体如下： <img src="/STL源码剖析/hashtablelist.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_node</span>&#123;</span><br><span class="line">    __hashtable_node* next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="hashtable的迭代器">5.4.1 hashtable的迭代器</h6>
<ul>
<li><code>hashable</code>迭代器维持着与整个<code>buckets vector</code>的关系，并记录目前所指的节点</li>
<li>前进操作是从目前节点出发前进一个位置，由于节点被安置于<code>list</code>内，使用<code>next</code>进行前进操作</li>
<li><strong>如果目前是<code>list</code>的尾端，则跳转至下一个<code>bucket</code>上，正是指向下一个<code>list</code>的头部</strong></li>
<li><strong><code>hashtable</code>的迭代器没有后退操作，<code>hashtable</code>没有定义所谓的逆向迭代器</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">ExtractKey</span>,<span class="keyword">class</span> <span class="title class_">EqualKey</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_iterator</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;hashtable;</span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_iterator&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;iterator;</span><br><span class="line"><span class="comment">//    typedef __hash_const   静态迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt;node;</span><br><span class="line">    <span class="keyword">typedef</span> std::forward_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> Value* pointer;</span><br><span class="line"></span><br><span class="line">    node* cur;<span class="comment">// 迭代器目前所指的节点</span></span><br><span class="line">    hashtable* ht;<span class="comment">//保持对容器的连接关系 (因为可能需要从bucket跳到bucket)</span></span><br><span class="line">    __hashtable_iterator(node*n,hashtable* tab):<span class="built_in">cur</span>(n),<span class="built_in">ht</span>(tab)&#123;&#125;</span><br><span class="line">    __hashtable_iterator()&#123;&#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> cur-&gt;val;&#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line">    iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; it)<span class="type">const</span> &#123;<span class="keyword">return</span> cur == it.cur;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; it)<span class="type">const</span> &#123;<span class="keyword">return</span> cur != it.cur;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">HF</span>,<span class="keyword">class</span> <span class="title class_">ExK</span>,<span class="keyword">class</span> <span class="title class_">EqK</span>,<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;&amp;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="type">const</span> node* old = cur;</span><br><span class="line">    cur = cur-&gt;next; <span class="comment">//如果存在 就是他，否则进入以下的if流程</span></span><br><span class="line">    <span class="keyword">if</span> (!cur)&#123;</span><br><span class="line">        <span class="comment">//根据元素的数值，定位出下一个bucket，其起头处就是我们的目的地</span></span><br><span class="line">        size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cur = ht-&gt;buckets[bucket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">HF</span>,<span class="keyword">class</span> <span class="title class_">ExK</span>,<span class="keyword">class</span> <span class="title class_">EqK</span>,<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++<span class="keyword">this</span>; <span class="comment">//调用operator++</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="hashtable的数据结构">5.4.2 hashtable的数据结构</h6>
<ul>
<li><code>buckets</code>聚合体以<code>vector</code>完成，以利动态扩充</li>
<li><strong><code>&lt;stl_hash_fun.h&gt;</code>定义数个现成的<code>hash functions</code>全都是仿函数，<code>hash function</code>计算单元的位置，也就是元素对应的<code>bucket</code>的位置。具体调用的函数是<code>bkt_num()</code>,它调用<code>hash function</code>取得一个可以执行<code>modulus</code>(取模)运算的数值</strong>，以上的目的是出于 有些元素的型别是无法直接对其进行取模运算的，比如字符串类型 。</li>
<li>按照质数设计<code>vector</code>的大小，事先准备好<code>28</code>个质数，并设计一个函数用于查询最接近某数并大于某数的质数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Key:         节点的实值类型</span></span><br><span class="line"><span class="comment"> * Value:       节点的键值类型</span></span><br><span class="line"><span class="comment"> * HashFun:     hash function的函数型别</span></span><br><span class="line"><span class="comment"> * ExtractKey:  从节点中提取键值的方法 (函数或者仿函数)</span></span><br><span class="line"><span class="comment"> * EqualKey:    判断键值是否相同 (函数或者仿函数)</span></span><br><span class="line"><span class="comment"> * Alloc:       空间配置器 缺省使用 std::alloc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">ExtractKey</span>,<span class="keyword">class</span> <span class="title class_">EqualKey</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> HashFcn hasher;    <span class="comment">//为template型别参数重新定义一个名称</span></span><br><span class="line">    <span class="keyword">typedef</span> EqualKey key_equal;<span class="comment">//为template型别参数重新定义一个名称</span></span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//以下三者都是function objects</span></span><br><span class="line">    <span class="comment">//&lt;stl_hash_fun.h&gt; 定义有数个标准型别(如 int、c-style、string等)的hasher</span></span><br><span class="line">    hasher hash;        <span class="comment">//散列函数</span></span><br><span class="line">    key_equal equals;   <span class="comment">//判断键值是否相等</span></span><br><span class="line">    ExtractKey get_key; <span class="comment">//从节点取出键值</span></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt;node;</span><br><span class="line">    <span class="comment">//专属的节点配置器</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;node,Alloc&gt;node_allocator;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点的配置函数</span></span><br><span class="line">    <span class="function">node* <span class="title">new_node</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        node* n = node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">        n-&gt;next = <span class="number">0</span>;</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            Chy::allocator&lt;Key&gt;::<span class="built_in">construct</span>(&amp;n-&gt;val,obj);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(node_allocator::<span class="built_in">deallocate</span>(n);)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点释放函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delete_node</span><span class="params">(node* n)</span></span>&#123;</span><br><span class="line">        Chy::allocator&lt;Key&gt;::<span class="built_in">destroy</span>(n-&gt;val);</span><br><span class="line">        node_allocator::<span class="built_in">deallocate</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;node*,Alloc&gt;buckets;<span class="comment">//以vector完成桶的集合，其实值是一个node*</span></span><br><span class="line">    size_type num_elements;  <span class="comment">//node的个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bucket个数 即buckets vector的大小</span></span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buckets.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//注意假设 假设long至少有32bit</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">53</span>,         <span class="number">97</span>,         <span class="number">193</span>,       <span class="number">389</span>,       <span class="number">769</span>,</span><br><span class="line">        <span class="number">1543</span>,       <span class="number">3079</span>,       <span class="number">6151</span>,      <span class="number">12289</span>,     <span class="number">24593</span>,</span><br><span class="line">        <span class="number">49157</span>,      <span class="number">98317</span>,      <span class="number">196613</span>,    <span class="number">393241</span>,    <span class="number">786433</span>,</span><br><span class="line">        <span class="number">1572869</span>,    <span class="number">3145739</span>,    <span class="number">6291469</span>,   <span class="number">12582917</span>,  <span class="number">25165843</span>,</span><br><span class="line">        <span class="number">50331653</span>,   <span class="number">100663319</span>,  <span class="number">201326611</span>, <span class="number">402653189</span>, <span class="number">805306457</span>,</span><br><span class="line">        <span class="number">1610612741</span>, <span class="number">3221225473</span>, <span class="number">4294967291</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//找出上述28指数中，最接近并大于n的那个质数</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_next_prime(<span class="type">unsigned</span> <span class="type">long</span> n)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *first = __stl_prime_list;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *pos = std::<span class="built_in">lower_bound</span>(first,last,n);</span><br><span class="line">        <span class="comment">//使用lower_bound() 需要先进行排序</span></span><br><span class="line">        <span class="keyword">return</span> pos == last ? *(last<span class="number">-1</span>) : *pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//总共有多少个buckets。以下是hash_table的一个member function</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">//其数值将为 4294967291</span></span><br><span class="line">        <span class="keyword">return</span> __stl_prime_list[__stl_num_primes - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">hashtable</span>(size_type n,<span class="type">const</span> HashFcn&amp; hf,<span class="type">const</span> EqualKey&amp; eql)</span><br><span class="line">    :<span class="built_in">hash</span>(hf),<span class="built_in">equals</span>(eql),<span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()),<span class="built_in">num_elements</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//例子：传入50 返回53</span></span><br><span class="line">        <span class="comment">//然后保留53个元素的空间 然后将其全部填充为0</span></span><br><span class="line">        <span class="type">const</span> size_type n_buckets = <span class="built_in">next_size</span>(n);</span><br><span class="line">        buckets.<span class="built_in">reserve</span>(n_buckets);</span><br><span class="line">        <span class="comment">//设定所有的buckets的初值为0(node*)</span></span><br><span class="line">        buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">begin</span>(),n_buckets,(node*)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//------------------------------bkt_num函数---------------------------</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//版本1：接受实值（value）和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj), n); <span class="comment">//调用版本4</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本2：只接受实值（value）</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj)); <span class="comment">//调用版本3</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本3，只接受键值</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(key, buckets.<span class="built_in">size</span>()); <span class="comment">//调用版本4</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本4：接受键值和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % n; <span class="comment">//SGI的所有内建的hash()，在后面的hash functions中介绍</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//相关对应的函数</span></span><br><span class="line">    <span class="comment">//next_size()返回最接近n并大于n的质数</span></span><br><span class="line">    <span class="function">size_type <span class="title">next_size</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __stl_next_prime(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;iterator;</span><br><span class="line">    <span class="comment">//插入操作和表格重整</span></span><br><span class="line">    <span class="comment">//插入元素不允许重复</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type&amp; obj)&#123;</span><br><span class="line">        <span class="comment">//判断是否需要重建表格  如果需要就进行扩充</span></span><br><span class="line">        <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//函数判断是否需要重建表格 如果不需要立刻返回，如果需要 就重建表格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type num_elements_hint)</span></span>&#123;</span><br><span class="line">        <span class="comment">//表格重建与否的原则是：元素的个数(新增元素计入之后)和先前分配的bucket vector进行比较</span></span><br><span class="line">        <span class="comment">//如果前者的大于后者 就需要表格的重建</span></span><br><span class="line">        <span class="comment">//因此 bucket(list)的最大容量和buckets vector的大小相同</span></span><br><span class="line">        <span class="type">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (old_n &lt; num_elements_hint)&#123;</span><br><span class="line">            <span class="comment">//需要重新分配内存</span></span><br><span class="line">            <span class="comment">//计算下一个质数</span></span><br><span class="line">            <span class="type">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; old_n)&#123;</span><br><span class="line">                std::vector&lt;node*,Alloc&gt;<span class="built_in">tmp</span>(n,(node*)<span class="number">0</span>);</span><br><span class="line">                __STL_TRY&#123;</span><br><span class="line">                    <span class="comment">//处理每一个旧的bucket</span></span><br><span class="line">                    <span class="keyword">for</span> (size_type bucket=<span class="number">0</span>;bucket&lt;old_n;bucket++) &#123;</span><br><span class="line">                        <span class="comment">//指向节点所对应的的串行的起始节点</span></span><br><span class="line">                        node* first = buckets[bucket];</span><br><span class="line">                        <span class="comment">//处理每一个旧的bucket所含(串行)的每一个节点</span></span><br><span class="line">                        <span class="keyword">while</span>(first)&#123;</span><br><span class="line">                            <span class="comment">//串行节点还未结束</span></span><br><span class="line">                            <span class="comment">//找出节点落在哪一个新的bucket内部</span></span><br><span class="line">                            size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val,n);</span><br><span class="line">                            <span class="comment">//以下四个操作颇为巧妙</span></span><br><span class="line">                            <span class="comment">//(1)令旧bucket指向其所对应的串行的下一个节点(以便迭代处理)</span></span><br><span class="line">                            buckets[bucket] = first-&gt;next;</span><br><span class="line">                            <span class="comment">//(2)(3)将当前节点插入到新的bucket内部，成为其对应串行的第一个节点</span></span><br><span class="line">                            first-&gt;next = tmp[new_bucket];</span><br><span class="line">                            tmp[new_bucket] = first;</span><br><span class="line">                            <span class="comment">//(4)回到旧的bucket所指向的待处理的串行，准备处理下一个节点</span></span><br><span class="line">                            first = buckets[bucket];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//对调新旧两个buckets</span></span><br><span class="line">                    <span class="comment">//离开的时候会释放tmp的内存</span></span><br><span class="line">                    buckets.<span class="built_in">swap</span>(tmp);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要重建表格的情况下插入新的节点 键值不允许重复</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert_unique_noresize</span>(<span class="type">const</span> value_type&amp; obj)&#123;</span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj) ;<span class="comment">//决定obj应该位于 第n n bucket</span></span><br><span class="line">        node* first = buckets[n]; <span class="comment">//令first指向bucket对应的串行头部</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果Buckets[n]已经被占用 此时first不再是0 于是进入以下循环</span></span><br><span class="line">        <span class="comment">//走过bucket所对应的整个链表</span></span><br><span class="line">        <span class="keyword">for</span> (node* cur = first;cur;cur = cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val)),<span class="built_in">get_key</span>(obj))&#123;</span><br><span class="line">                <span class="comment">//如果发现和链表中的某个键值是相同的 就不插入 立刻返回</span></span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//离开上述循环(或者根本没有进入循环的时候)first指向bucket的所指链表的头部节点</span></span><br><span class="line">            node* tmp = <span class="built_in">new_node</span>(obj); <span class="comment">//产生新的节点</span></span><br><span class="line">            tmp-&gt;next = first;</span><br><span class="line">            buckets[n] = tmp; <span class="comment">//令新的节点成为链表的第一个节点</span></span><br><span class="line">            ++num_elements;   <span class="comment">//节点的个数累加</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(tmp,<span class="keyword">this</span>),<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//客户端执行的是另外一种节点的插入行为(不再是insert_unique 而是insert_equal)</span></span><br><span class="line">    <span class="comment">//插入元素 允许重复</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否需要重建表格 如果需要就进行扩充</span></span><br><span class="line">        <span class="built_in">resize</span>(num_elements+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要重建表格的情况下 插入新的节点，键值是允许重复的</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj); <span class="comment">//决定obj应该位于第 n bucket</span></span><br><span class="line">        node* first = buckets[n];<span class="comment">//令first指向的bucket对应的链表的头部</span></span><br><span class="line">        <span class="comment">//如果bucket[n]已经被占用，此时的first不为0，进入循环</span></span><br><span class="line">        <span class="comment">//遍历整个链表</span></span><br><span class="line">        <span class="keyword">for</span>(node* cur = first;cur;cur = cur-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val),<span class="built_in">get_key</span>(obj)))&#123;</span><br><span class="line">                <span class="comment">//如果发现与链表中的某个键值相同，就马上插入，然后返回</span></span><br><span class="line">                node* tmp = <span class="built_in">new_node</span>(obj);  <span class="comment">//产生新的节点</span></span><br><span class="line">                tmp-&gt;next = cur-&gt;next;<span class="comment">//新节点插入目前的位置</span></span><br><span class="line">                cur-&gt;next = tmp;</span><br><span class="line">                ++num_elements;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">iterator</span> (tmp, <span class="keyword">this</span>); <span class="comment">//返回一个迭代器 指向新增的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行到这个时候 表示没有发现重复的数值</span></span><br><span class="line">            node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">            tmp-&gt;next = first;</span><br><span class="line">            buckets[n] = tmp;</span><br><span class="line">            ++num_elements;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//针对每一个bucket</span></span><br><span class="line">        <span class="keyword">for</span>(size_type i = <span class="number">0</span>;i &lt; buckets.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            node * cur = buckets[i];</span><br><span class="line">            <span class="comment">//删除bucket list中的每一个节点</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="number">0</span>)&#123;</span><br><span class="line">                node* next = cur-&gt;next;</span><br><span class="line">                <span class="built_in">delete_node</span>(cur);</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            buckets[i] = <span class="number">0</span>; <span class="comment">//令buckets内容为null</span></span><br><span class="line">        &#125;</span><br><span class="line">        num_elements = <span class="number">0</span>; <span class="comment">//令总的节点的个数为0</span></span><br><span class="line">        <span class="comment">//需要注意 buckets vector并没有释放空间，仍然保存先前的大小</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy_from</span><span class="params">(<span class="type">const</span> hashtable&amp; ht)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先清除己方的buckets vector，此操作是调用vector::clear() 造成所有的元素都为0</span></span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">//为己方的buckets vector保留空间，使与对方相同</span></span><br><span class="line">        <span class="comment">//如果己方的空间大于对方 就不需要改变；如果己方的空间小于对方 就会增大</span></span><br><span class="line">        buckets.<span class="built_in">reserve</span>(ht.buckets.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//从己方的buckets vector尾端开始，插入n个元素，其数值为 null 指针</span></span><br><span class="line">        <span class="comment">//注意此时buckets vector为空，所谓的尾端就是起头处</span></span><br><span class="line">        buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(),ht.buckets.<span class="built_in">size</span>(),(node*)<span class="number">0</span>);</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            <span class="comment">//针对buckets vector</span></span><br><span class="line">            <span class="keyword">for</span> (size_type i = <span class="number">0</span>;i&lt;ht.buckets.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">                <span class="comment">//复制vector的每一个元素(是一个指针，指向hashtable节点)</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="type">const</span> node* cur = ht.buckets[i])&#123;</span><br><span class="line">                    node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">                    buckets[i] = copy;</span><br><span class="line">                    <span class="comment">//针对同一个 buckets list 复制每一个节点</span></span><br><span class="line">                    <span class="keyword">for</span> (node* next = cur-&gt;next;next ; cur = next,next = cur-&gt;next) &#123;</span><br><span class="line">                        copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">                        copy = copy-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新登录的节点的个数(hashtable的大小)</span></span><br><span class="line">            num_elements = ht.num_elements;</span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>STL中哈希表一般不要外部使用，它是实现<code>hash_map</code>和<code>hash_set</code>的底层机制，编程者可以使用它们。</p>
<h5 id="hash_set">5.5 hash_set</h5>
<p>同set一样，单独以键存储。<code>hash_set</code>是以<code>hashtable</code>为底层机制，因此存储数无序的，而<code>set</code>有序。同时其所供应的接口大部分都是转调用<code>hashtable</code>的函数。<code>hash_set</code>的使用方式与<code>set</code>差不多一样.</p>
<h6 id="hash_set源码">5.5.1 hash_set源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_INTERNAL_HASH_SET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SGI_STL_INTERNAL_HASH_SET_H</span></span><br><span class="line"></span><br><span class="line">__STL_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> set woff 1174</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Value&gt;,</span><br><span class="line">          <span class="keyword">class</span> EqualKey = equal_to&lt;Value&gt;,</span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> EqualKey, <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> hash_set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;Value, Value, HashFcn, identity&lt;Value&gt;, </span><br><span class="line">                    EqualKey, Alloc&gt; ht;</span><br><span class="line">  ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equal key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hash_set</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hash_set</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equal()) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_set&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_set&amp;,</span><br><span class="line">                                               <span class="type">const</span> hash_set&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique</span>(obj);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span> </span>&#123;</span><br><span class="line">    rep.<span class="built_in">insert_unique</span>(f,l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator f, const_iterator l)</span> </span>&#123;rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="hash_map">5.6 hash_map</h5>
<p>同map一样以键值对形式存储，但其底层机制为<code>hashtable</code>，因此大部分情况支持常数时间复杂度访问，存储是无序的。使用方式与<code>map</code>相差不大</p>
<h6 id="hash_map源码">5.6.1 hash_map源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> set woff 1174</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> EqualKey = equal_to&lt;Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> EqualKey, </span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> hash_map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;pair&lt;<span class="type">const</span> Key, T&gt;, Key, HashFcn,</span><br><span class="line">                    select1st&lt;pair&lt;<span class="type">const</span> Key, T&gt; &gt;, EqualKey, Alloc&gt; ht;</span><br><span class="line">  ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">  <span class="keyword">typedef</span> T data_type;</span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equal key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::iterator iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hash_map</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hash_map</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equal()) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_map&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span></span><br><span class="line">  <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_map&amp;, <span class="type">const</span> hash_map&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(obj); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span> </span>&#123;</span><br><span class="line">    rep.<span class="built_in">insert_unique</span>(f,l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator f, const_iterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique_noresize</span>(obj); &#125;    </span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; key) &#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">find_or_insert</span>(<span class="built_in">value_type</span>(key, <span class="built_in">T</span>())).second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line">  <span class="function">pair&lt;const_iterator, const_iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="各个容器的适用场景">6. 各个容器的适用场景</h4>
<ul>
<li>1）<code>vector</code>的使用场景：只查看，而不频繁插入删除的，因为频繁插入删除会造成内存的不断搬家和删除。使用场景比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录。</li>
<li>2）<code>deque</code>的使用场景：比如排队购票系统，对排队者的存储可以采用<code>deque</code>，支持头端的快速移除，尾端的快速添加。如果采用<code>vector</code>，则头端移除时会移动大量的数据，速度慢。<code>vector</code>与<code>deque</code>的比较：
<ul>
<li>一：<code>vector.at()</code>比<code>deque.at()</code>效率高，比如<code>vector.at(0)</code>是固定的，<code>deque</code>的开始位置却是不固定的。</li>
<li>二：如果有大量释放操作的话，<code>vector</code>花的时间更少，这跟二者的内部实现有关。</li>
<li>三：<code>deque</code>支持头部的快速插入与快速移除，这是<code>deque</code>的优点。</li>
</ul></li>
<li><code>list</code>的使用场景：频繁的插入删除的场景，这时也可以使用queue和deque。使用场景比如公交车乘客的存储，随时可能有乘客上下车，支持频繁的不确实位置元素的移除插入删除。</li>
<li><code>set</code>的使用场景：大部分负责查找内容且要求有序的情况下。使用场景比如对游戏中个人得分历史记录的存储，存储要求从高分到低分的顺序排列。</li>
<li><code>map</code>的使用场景：对查找有较高的要求，使用场景比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。红黑树的查找效率，这时就体现出来了。</li>
</ul>
<h4 id="算法">7. 算法</h4>
<h5 id="stl算法分类">7.1 STL算法分类</h5>
<h6 id="质变和非质变">7.1.1 质变和非质变</h6>
<ul>
<li><strong>质变算法：</strong>是指运算过程中会更改区间内的元素的内容</li>
<li><strong>非质变算法：</strong>是指运算过程中不会更改区间内的元素内容</li>
</ul>
<h6 id="stl算法的一般形式">7.1.2 STL算法的一般形式</h6>
<p><strong>大多数算法有下列4中形式：</strong></p>
<ul>
<li><code>alg(first,last,other args);</code></li>
<li><code>alg(first,last,dest,other args);</code></li>
<li><code>alg(first,last,first2,other args);</code></li>
<li><code>alg(first,last,first2,lasst2,other args);</code></li>
</ul>
<p><strong>更一般的说法是：</strong></p>
<ul>
<li><strong>所有泛型算法的前两个参数一定是一对迭代器，通常为<code>first</code>和<code>last</code>,范围为<code>[first,last)</code></strong></li>
<li><strong>许多STL算法不止只支持一个版本，可接受仿函数<code>_if</code>结尾，如<code>find()</code>函数支持传入谓词或仿函数的<code>find_if()</code>版本</strong></li>
<li>质变算法通常会有至少提供两个版本，一个是就地进行改变操作对象的版本，<strong>另一个是<code>_copy</code>版本，拷贝一份副本，在副本上改变，如<code>replace()</code>函数就有<code>replace_copy()</code>版本</strong></li>
<li>所有的数值算法实现都在<code>&lt;stl_numeric.h&gt;，用户使用时可包含</code>#include<numeric>`调用</numeric></li>
<li>其他算法实现于<code>&lt;stl_algo.h&gt;\&lt;stl_algobase.h&gt;</code>，用户使用可通过包含<code>#include&lt;algorithm&gt;</code>调用</li>
</ul>
<h6 id="算法总览">7.1.3 算法总览</h6>
<table>
<thead>
<tr class="header">
<th>算法名称</th>
<th>算法用途</th>
<th style="text-align: center;">质变？</th>
<th>所在文件</th>
<th style="text-align: center;">所属作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>accumulate</code></td>
<td>元素求和</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_numeric.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="even">
<td><code>adjacent_difference</code></td>
<td>相邻元素差额</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_numeric.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td><code>adjacent_find</code></td>
<td>查找相邻重复(或符合条件)的元素</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>binary_search</code></td>
<td>二分查找</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>copy</code></td>
<td>复制</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="even">
<td><code>copy_backward</code></td>
<td>逆向复制</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="odd">
<td><code>copy_n</code></td>
<td>复制n个元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="even">
<td><code>count</code></td>
<td>计数</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>count_if</code></td>
<td>在特定传入的谓词或仿函数条件下计数</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>equal</code></td>
<td>判断两个区间相等与否</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">关系</td>
</tr>
<tr class="odd">
<td><code>equal_range</code></td>
<td>在有序区间寻找某值，返回一个区间</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">关系</td>
</tr>
<tr class="even">
<td><code>fill</code></td>
<td>该填元素值</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>fill_n</code></td>
<td>该填元素值，n次</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>find</code></td>
<td>循序查找</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>find_if</code></td>
<td>查找符合条件的元素</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>find_end</code></td>
<td>查找某个子序列的最后一次出现点</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>find_first_of</code></td>
<td>查找某些元素首次出现点</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>for_each</code></td>
<td>对区间的每一个元素施行某操作</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>generate</code></td>
<td>以特定操作的运算结果填充特定区间内的元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>inner_product</code></td>
<td>内积</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td><code>iter_swap</code></td>
<td>元素互换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td><code>lower_bound</code></td>
<td>返回有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>max</code></td>
<td>最大值</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>max_element</code></td>
<td>最大值所在位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>min</code></td>
<td>最小值</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>min_element</code></td>
<td>最小值所在位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>merge</code></td>
<td>合并两个序列</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>inplace_merge</code></td>
<td>合并且就地替换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>random_shuffle</code></td>
<td>随机重排元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>remove</code></td>
<td>删除某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="odd">
<td><code>remove_copy</code></td>
<td>删除某类元素并将结果存储都另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="even">
<td><code>remove_if</code></td>
<td>有条件的删除某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="odd">
<td><code>remove_copy_if</code></td>
<td>有条件的删除某类元素，并将结果存储到另外一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="even">
<td><code>replace</code></td>
<td>替换某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="odd">
<td><code>replace_copy</code></td>
<td>替换某类元素，并将结果存储到另一个元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="even">
<td><code>replace_if</code></td>
<td>有条件的替换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="odd">
<td><code>replace_copy_if</code></td>
<td>有条件的替换，并将结果存储都另一个容q器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="even">
<td><code>reverse</code></td>
<td>反转</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="odd">
<td><code>reverse_copy</code></td>
<td>反转并把结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="even">
<td><code>rotate</code></td>
<td>旋转</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">旋转</td>
</tr>
<tr class="odd">
<td><code>rotate_copy</code></td>
<td>旋转，并把结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;sta_algo.h&gt;</code></td>
<td style="text-align: center;">旋转</td>
</tr>
<tr class="even">
<td><code>search</code></td>
<td>查找某个子序列</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>search_n</code></td>
<td>查找连续发生n次的某个子序列</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>sort</code></td>
<td>排序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">排序</td>
</tr>
<tr class="odd">
<td><code>stable_sort</code></td>
<td>排序并保持等值元素的相对次序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">排序</td>
</tr>
<tr class="even">
<td><code>stable_partition</code></td>
<td>分割并保存元素的相对次序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">分割</td>
</tr>
<tr class="odd">
<td><code>swap</code></td>
<td>交换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td><code>swap_ranges</code></td>
<td>指定区间的交换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="odd">
<td><code>unique</code></td>
<td>去重</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">去重</td>
</tr>
<tr class="even">
<td><code>unique_copy</code></td>
<td>去重后的结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">去重</td>
</tr>
<tr class="odd">
<td><code>upper_bound</code></td>
<td>返回有序序列范围内的可以插入指定值而不破坏容器顺序的最后位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>make_heap</code></td>
<td>创建一个堆</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="odd">
<td><code>pop_heap</code></td>
<td>从堆取元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="even">
<td><code>push_heap</code></td>
<td>将元素插入堆</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="odd">
<td><code>sort_heap</code></td>
<td>堆heap排序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
</tbody>
</table>
<h5 id="sort">7.2 sort</h5>
<h6 id="适用容器">7.2.1 适用容器</h6>
<p><code>sort()</code>算法是最复杂堆庞大的一个，<strong>这个算法接受两个<code>RandomAccessIterator</code>迭代器，然后将区间内的元素由小到大重新排列</strong>。第二个版本则允许用户传入<strong>谓词或者仿函数</strong>作为排序条件，指定按什么规则排序。适用<code>sort</code>算法的容器有<code>vecror\deque</code>。</p>
<p><strong><em>附</em></strong>：因为关联容器的底层机制，根本不需要<code>sort</code>排序，<code>stack\queue\priority_queue</code>对进出的机制也要求不需排序，而<code>list</code>的迭代器为<code>BidirectinalIterator</code>不适用。</p>
<h6 id="sort实现的原理">7.2.2 sort实现的原理</h6>
<p>早期的STL <code>sort()</code>算法都是采用<strong>快排</strong>来实现，对于快排平均的时间复杂度为<code>O(NlogN)</code>,但是最坏的情况却会达到<code>O(N*N)</code>，<strong>因此现今的<code>STL SGI</code>改用<code>IntroSort</code>即内观排序算法，极其类似于<code>median-three QuickSort</code>三数取中快速排序算法。这种算法即使在最坏的情况下推进到<code>O(NlogN)</code>。</strong>快排的最坏情况的发生与快速排序中基准点的选择是有重大的关系，当出现下面两种情况时性能最差:</p>
<ul>
<li>在分解时每次选取的基准点为最小元素</li>
<li>在分解时每次选取的基准点为最大元素</li>
</ul>
<p><strong>快排的过程：</strong></p>
<ul>
<li>如果序列中的元素个数为0或1，结束</li>
<li>取序列中的任何一个元素，一般会取该段序列的头或者尾元素作为基准点<code>pivot</code></li>
<li>将序列分类<code>L\R</code>两段子序列，使L内的每一个元素都小于或等于基准点，R内的每一个元素都大于等于基准点</li>
<li>对<code>L\R</code>递归执行<code>QuickSort</code>,重复上述操作</li>
</ul>
<p><img src="/STL源码剖析/quickSort.gif" width="600"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写自己的quickSort,没有优化，遇到最坏情况的时间复杂度会变成O(N*N)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--;</span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="三点取中优化方案">7.2.3 三点取中优化方案</h6>
<p>为了避免快排出现上述所说的最坏情况，选择哪一个元素作为基准点是关键，<strong>在快排过程中采用三点取中间值的优化方案。三数取中<code>median-of-three</code>指的是在挑选基准元素时，不是简单的选择数组中的第一个元素或最后一个，而是选取某三个元素，常选头、尾和中央三个元素，并且适用三个元素之中的中位数作为基准元素进行划分</strong>。这样即使在最坏的情况下将时间复杂度推进到<code>O(NlogN)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后的快排代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">medianOfThree</span>(a, first, (first + last) / <span class="number">2</span>, last);</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--; </span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cap[first] &lt; cap[mid])</span><br><span class="line">        <span class="keyword">if</span> (cap[first] &gt;= cap[last])	<span class="comment">//last=&lt;first&lt;mid</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&lt;mid&lt;last</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[mid];</span><br><span class="line">            cap[mid] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">// first&lt;last&lt;=mid</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[last];</span><br><span class="line">            cap[last] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[first] &lt; cap[last])	<span class="comment">//last&gt;first&gt;=mid</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&gt;=mid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[last];</span><br><span class="line">        cap[last] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[mid];</span><br><span class="line">        cap[mid] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数值算法">7.3 数值算法</h5>
<p>数值算法都在头文件<code>&lt;numeric&gt;</code>中，实现于<code>&lt;stl_numeric.h&gt;。 ###### 7.3.1 accumulate</code>accumulate`算法用来计算指定区间的和，需要提供额外参数指定累加到哪一个初始值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init)</span></span>;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T，<span class="keyword">class</span> BinaryOperation &gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init,</span></span></span><br><span class="line"><span class="params"><span class="function">	BinaryOperation binary_op)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="power">7.3.2 power</h6>
<p>计算某数的n次方幂，该算法四<code>SGI</code>版本特有算法。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Integer&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">power</span><span class="params">(T x,Integer n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="adjacent_difference">7.3.3 adjacent_difference</h6>
<p>算法<code>adjacent_difference</code>用来计算[first,last)中相邻元素的差额，即它会将<code>*first</code>赋值给<code>*result</code>，并针对[first,last)内的每个迭代器<code>i</code>,进行<code>*i-*(i-1)</code>，然后赋值给<code>*++result</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InpueIterator,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="基本算法">7.4 基本算法</h5>
<p>对于SGI版本,它会把常用的一些算法定义在<code>&lt;stl_algobase.h&gt;</code>,使用时包含<code>&lt;algorithm&gt;</code>即可。</p>
<h5 id="equal">7.4.1 equal</h5>
<p>如果两个序列在<code>[first,lasst)</code>区间内相等，<code>equal</code>会返回<code>true</code>。如果第二序列元素多，则剩余元素不考虑，一般调用前要先保证元素个数一样。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator1,<span class="keyword">class</span> InputIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(InpueIterator1 first1,InpueIterator1 last1,InpueIterator1 first2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="fill">7.4.2 fill</h6>
<p>将<code>[first,last)</code>内的元素该填新值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(ForwardIterator first,ForwardIterator last,<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">###### <span class="number">7.4</span><span class="number">.3</span> fill_n</span><br><span class="line">将`[first,last)`的前n个改填新值，返回的迭代器指向被填入的最后一个元素的下一个位置。</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> OutputIterator,<span class="keyword">class</span> Size,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">fill_n</span><span class="params">(OutputIterator first,Size n,<span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="iter_swap">7.4.4 iter_swap</h6>
<p>该算法将两个<code>ForwardIterator</code>所指对象对调。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1,calss ForwardIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator a,ForwardIterator2 b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="copy">7.4.5 copy</h6>
<ul>
<li><code>copy()</code>算法是最最最常用的一个算法，</li>
<li><code>copy()</code>算法将输入区间的<code>[first,last)</code>的元素复制到目标区间<code>[result,result+(last-first))</code>中，执行完后返回一个迭代器，指向<code>result+(last-first)</code>。</li>
<li><code>copy</code>函数对参数非常宽松，对输入区间只需由<code>InputIterator</code>构成即可，输出区间尾<code>OutputIterator</code>构成即可，即意味着可以将任何容器的任何一段内容复制带任何容器的任何一段上，当然这些容器要由对应的迭代器。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InpueIterator,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span></span><br></pre></td></tr></table></figure>
<h6 id="copy_backward">7.4.6 copy_backward</h6>
<p>与<code>copy</code>非常相似，只不过<code>copy_backward</code>是以逆行方向复制到<code>result</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterator1,<span class="keyword">class</span> BidirectionalIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(BidirectionalIterator1 first,</span></span></span><br><span class="line"><span class="params"><span class="function">	BidirectionalIterator1,BidirectionalIterator2 result)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="其他算法">7.5 其他算法</h5>
<p>定义与<code>&lt;stl_algo.h&gt;</code>内地算法</p>
<h6 id="adjacent_find">7.5.1 adjacent_find</h6>
<p>该算法找出第一组满足条件的相邻元素，这里所谓的条件，在版本一中是指<strong>两元素相等</strong>，在版本二中允许用户指定一个二元为谓词运算，两操作数是相邻第一个元素和第二个元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first,ForwardIterator last)</span></span>;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator,<span class="keyword">class</span> BinaryPredicate&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator last,BinaryPredicate binary_pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find">7.5.2 find</h6>
<p>在<code>[first,lasy)</code>找出第一个符合匹配条件的元素，返回该元素所在位置的迭代器，未找到则返回<code>last</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_if">7.5.3 find_if</h6>
<p>传入一原谓词，根据指定的条件<code>pred</code>元素条件查找，返回该元素所在位置的迭代器，未找到则返回<code>last</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> predicate&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,predicate pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_end">7.5.4 find_end</h6>
<p>在序列一的<code>[first1,last1)</code>区间中，查找序列二<code>[first2,last2)</code>最后一次出现点，如果不存在，则返回<code>last1</code>。由两个版本，版本一默认使用<code>==</code>,版本二允许用户传入二元运算谓词。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1,<span class="keyword">class</span> ForwardIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIterator</span><span class="params">(ForwardIterator1 first1,ForwardIterator1 last1</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator2 first2,ForwardIterator2 last2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_first_of">7.5.5 find_first_of</h6>
<p>本算法以<code>[first2,last2)</code>区间内的元素作为查找目标，寻找它们在<code>[first1,last1)</code>第一次出现的位置，<strong>只要<code>[first2,last2)</code>任何一个元素第一次出现在<code>[first1,last1)</code>就返回</strong>。两个版本，一个默认使用<code>==</code>,一个允许用户指定二元谓词传入 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIterator</span><span class="params">(InputIterator first1,InputIterator last1</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator2 first2,ForwardIterator2 last2)</span></span>;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">数据结构(C++实现)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-12 22:05:56" itemprop="dateCreated datePublished" datetime="2022-07-12T22:05:56+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-07 18:05:00" itemprop="dateModified" datetime="2022-08-07T18:05:00+08:00">2022-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>56k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>50 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="说在前面">1.说在前面</h4>
<p>c++支持两种类--<strong>抽象类和具体类</strong>。一个抽象类包含着没有实现代码的成员函数（纯虚函数）。具体了类没有纯虚函数。只有具体类才可以实例化（但抽象类实例化指针和引用是运行的），即只能对具体类建立实例或对象。</p>
<p><strong>在这里主要讲解各种数据结构的思想，列举抽象类接口和实现一部分具体类的接口功能。</strong></p>
<h4 id="数组">2. 数组</h4>
<h5 id="数组介绍">2.1 数组介绍</h5>
<p>数组是有序表的一种，其内存是在物理上是连续的，对于这种数据结构而言，其优缺点如下： <strong>优点</strong>：</p>
<ul>
<li>支持下标访问随机访问，访问指定位置快时间复杂读为<code>O(1)</code></li>
<li>没有额外的存储空间来存储指针之类的</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>对于插入操作比较麻烦，需要将插入位置后的元素后移一位，造成最坏情况下时间复杂度为O(n)</li>
<li>同时分配的内存是连续，一次性分配，若元素装满后还想插入元素，则需要另外开辟，将原来的元素拷贝过去再插入，造成效率低下。</li>
</ul>
<p>对于数组，不建议自己去写一个类实现，而是使用STL中带有的<code>vetcor</code>，这款容器能实现按1.5或2倍扩容机制增长，且支持迭代器，是C++开发中最长用到的功能齐全的容器。</p>
<h5 id="实现">2.2 实现</h5>
<h6 id="linerlist抽象类">2.2.1 linerList抽象类</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">linearList</span></span><br><span class="line">&#123;		<span class="comment">//抽象类ADT</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">linearList</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> tehIndex)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span>  T&amp;  <span class="keyword">operator</span>[](<span class="type">int</span> theIndex)=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T&amp; elements)</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> theIndex)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> theIndex, <span class="type">const</span> T&amp; theInserElement)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">output</span><span class="params">(std::ostream&amp; os)</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="c实现">2.2.2 C++实现</h6>
<p>在线性表的数组描述中，我们用<strong>一维动态分配的数组<code>element</code></strong>，变量<code>lsitsize</code>表示当前存储的线性表元素个数，用<code>arrayLength</code>表示线性表容量。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">arrayList</span> :<span class="keyword">public</span> linearList&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">arrayList</span>(<span class="type">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">arrayList</span>(<span class="type">const</span> arrayList&lt;T&gt;&amp;);</span><br><span class="line">	~<span class="built_in">arrayList</span>() &#123; <span class="keyword">delete</span>[]element; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> listsize == <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> listsize; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> arrayLength; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> )</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> theIndex)<span class="type">const</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T&amp; element)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> theIndex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> theIndex, <span class="type">const</span> T&amp; theInserElement)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">output</span><span class="params">(std::ostream&amp; os)</span><span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">checkIndex</span><span class="params">(<span class="type">const</span> <span class="type">int</span> indexOf)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">//std::shared_ptr&lt;T[]，end_connection&gt; elememt;	</span></span><br><span class="line">	<span class="comment">//不建议使用智能指针形式的动态数组，</span></span><br><span class="line">	<span class="comment">//因为析构函数使用的是默认delete,而不是delete[],</span></span><br><span class="line">	<span class="comment">//若要使用则应该定义自己得删除器</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increaseLength</span><span class="params">(T*&amp; , <span class="type">int</span> , <span class="type">int</span>)</span></span>;<span class="comment">//扩容操作</span></span><br><span class="line">	T* element;</span><br><span class="line">	std::<span class="type">size_t</span> listsize;</span><br><span class="line">	std::<span class="type">size_t</span> arrayLength;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素，后面的元素向前移动一位</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; arrayLisst&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">int</span> index)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;下标访问越界&quot;</span>);</span><br><span class="line">	<span class="built_in">copy</span>(element+index+<span class="number">1</span>,element+listsize,element+index);</span><br><span class="line">	element[--listsize].~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="c实现-1">2.2.3 C实现</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C版本</span></span><br><span class="line"><span class="comment">//结构体定义：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span>	<span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType	*elem;</span><br><span class="line">	<span class="type">int</span>	length;</span><br><span class="line">	<span class="type">int</span>	listsize;</span><br><span class="line"></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//创建一个顺序表：</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="comment">//分配动态内存，malloc函数返回一个void*的指针，强制转换为ElemType*。</span></span><br><span class="line">	L.elem=(ElemType*）<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="built_in">seziof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span>(!L.elem)<span class="built_in">exit</span>(OVERFLOW);		<span class="comment">//分配内存失败。</span></span><br><span class="line">	L.length=<span class="number">0</span>;					<span class="comment">//初始化为0</span></span><br><span class="line">	L.listsize=LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入前，要把插入的位置后面的元素后移，也就是要先判断插入前的内存是否足够元素插入，</span></span><br><span class="line"><span class="comment">//若不足够，则需要扩容。在进行元素后移，元素插入。其时间复杂度为O(n)</span></span><br><span class="line">Status <span class="built_in">Insert_List</span>(SqList &amp;L，<span class="type">int</span> i,ElemType	e)	<span class="comment">//i为插入的位置，e为要插入的元素</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>&amp;&amp;i&gt;L.length+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;=L.listsize)</span><br><span class="line">	&#123;</span><br><span class="line">		ElemType *newbase=(ElemType*)<span class="built_in">realloc</span>(L.elem,LISTINCREMENT*<span class="built_in">seziof</span>(ElemType));</span><br><span class="line">		<span class="keyword">if</span>(!L.elem)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		L.elem=newbase;</span><br><span class="line">		L.listsize+=LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	ElemType *q=&amp;(L.elem[i<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(Elemtype *p=&amp;(L.elem[length<span class="number">-1</span>];q&gt;=p;p--)</span><br><span class="line">		*(p+<span class="number">1</span>）=*p;</span><br><span class="line">	*q=e;</span><br><span class="line">	++L.length;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作，O(n)</span></span><br><span class="line">Status <span class="built_in">Delet_List</span>(SqList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">	ElemType *q=&amp;((L-&gt;Elem)[i<span class="number">-1</span>]);</span><br><span class="line">	e=*q;</span><br><span class="line">	q+=<span class="number">1</span>;</span><br><span class="line">	ElemType *p=&amp;(L.elme[length<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(q;q&lt;=p;q++)</span><br><span class="line">		*(q<span class="number">-1</span>)=*q;</span><br><span class="line">	L.length-=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//取值操作</span></span><br><span class="line">Status <span class="built_in">GetElem_List</span>(SqList L,<span class="type">int</span> i, ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>&amp;&amp;i&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		e=L.elem[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作</span></span><br><span class="line">Status <span class="built_in">LocateElem_List</span>(SqList L,ElemType e,Status （*compare)(ElemType,ElemType))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>	i=<span class="number">1</span>;</span><br><span class="line">	ElemType *p=l.elem;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=L.length&amp;&amp;<span class="built_in">compare</span>(*p++,e))<span class="comment">//回调函数</span></span><br><span class="line">		i++;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=L.length)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">MergeList</span>(SqList La,SqList Lb,SqList &amp;Lc)</span><br><span class="line">&#123;</span><br><span class="line">	ElemType* pa=La.elem;</span><br><span class="line">	ElemType* pb=Lb.elem;</span><br><span class="line">	ElemType* pa_last=pa+La.length<span class="number">-1</span>;</span><br><span class="line">	ElemType* pb_last=pb+Lb.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	Lc.listsize=La.length+Lb.length;</span><br><span class="line">	Lc.elem=(ElemType*)<span class="built_in">malloc</span>(Lc.listsize*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">	ElemType* pc=Lc-&gt;elem;</span><br><span class="line">	<span class="keyword">if</span>(Lc.elem==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(pa&lt;=pa_last&amp;&amp;pb&lt;=pb_last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*pa&lt;=*pb)</span><br><span class="line">		*pc++=*pa++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		*pc++=*pb++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pa&lt;=pa_last)</span><br><span class="line">		*pc++=*pa++;</span><br><span class="line">	<span class="keyword">while</span>(pb&lt;=pb_last)</span><br><span class="line">		*pc++=*pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表">3. 链表</h4>
<h5 id="单链表介绍">3.1 单链表介绍</h5>
<p>链表克服了数组插入删除时的元素移动步骤，但是代价是牺牲一定的内存来存储指针，其优缺点如下 <strong>优点：</strong></p>
<ul>
<li>链表通过指针来指向下一个元素，带来的好处是插入删除无须移动插入位置后的元素的元素，也不必前移删除位置后的元素，只需要将指针指向后方元素即可。</li>
<li>通过指针来指向下一个元素，这就意味着我们不必像数组那样分配严格物理意义上的联系内存，即使内存不连续，也能成功访问。只有在需要的时候才去创建空间。大小不固定，拓展很灵活。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>因为内存是不联系的，那么链表不支持随机访问，如果访问链表中指定位置节点，只能从头或者尾部进行遍历。</li>
<li>因为除了存储数据，还有存储相应的指针，同一长度的数组和链表，链表会造成内存的消耗多</li>
</ul>
<p><img src="/数据结构-C-实现/simplelist.png" width="600"></p>
<h5 id="实现-1">3.2 实现</h5>
<h6 id="c实现-2">3.2.1 C++实现</h6>
<p><strong>1.存储结构以及类整体声明及定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++实现</span></span><br><span class="line"><span class="comment">//结构类,其思想同c的数据就跟链表一样，只不过在类内其增加构造函数：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chainNode</span>&#123;</span><br><span class="line">	T element;</span><br><span class="line">	chainNode *next;</span><br><span class="line">	<span class="built_in">chainNode</span>(<span class="type">const</span> T&amp; element)</span><br><span class="line">		&#123;<span class="keyword">this</span>-&gt;element=element;&#125;</span><br><span class="line">	<span class="built_in">chainNode</span>(<span class="type">const</span> T&amp; element,chainNode&lt;T&gt; *next)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;element=element;</span><br><span class="line">		<span class="keyword">this</span>-&gt;next=next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对象类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chain</span>:<span class="keyword">public</span> linearList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">chain</span>(<span class="type">int</span> initialCapacity=<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">chain</span>(<span class="type">const</span> chain&lt;T&gt;&amp;);</span><br><span class="line">	~<span class="built_in">chain</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> listSize==<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> listSize;&#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> theIndex)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> theIndex)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> theIndex,<span class="type">const</span> T&amp; theElement)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(ostream&amp; os)</span><span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">checkIndex</span><span class="params">(<span class="type">int</span> theIndex)</span><span class="type">const</span></span>;</span><br><span class="line">	chainNode&lt;T&gt;* firstNode;</span><br><span class="line">	<span class="type">int</span> listSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2. 构造函数和拷贝构造函数</strong></p>
<p>为了创建一个空链表，只需令第一个<code>firstNode</code>的值为<code>NULL</code>，链表不需要预先分配堆空间，它是随用随建立的一个形式。不过为了与<code>arrayList</code>相容，构造函数还是具有一个表示初始容量的形参<code>initialCapacity</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">chain&lt;T&gt;::<span class="built_in">chain</span>(<span class="type">int</span> initialCapacity)&#123;</span><br><span class="line">	<span class="keyword">if</span>(initialCapacity&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;The capacity is wrong&quot;</span>);</span><br><span class="line">	firstNode=<span class="literal">NULL</span>;</span><br><span class="line">	listSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">chain&lt;T&gt;::<span class="built_in">chain</span>(<span class="type">const</span> chain&lt;T&gt;&amp; theList)&#123;</span><br><span class="line">	listSize=theList.listSize;</span><br><span class="line">	<span class="keyword">if</span>(listSize==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		firstNode=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	chainNode&lt;T&gt; *sourceNode=theList.firstNode;		<span class="comment">//使用拷贝构造函数,深拷贝</span></span><br><span class="line">	firstNode=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(sourcNode-&gt;element);</span><br><span class="line">	sourceNode=sourceNode-&gt;next;</span><br><span class="line">	chainNode&lt;T&gt; *intermediateValue=firstNode;</span><br><span class="line">	<span class="keyword">while</span>(sourceNode!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		intermediateValue=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(sourceNode-&gt;element);</span><br><span class="line">		sourceNode=sourceNode-&gt;next;</span><br><span class="line">		intermediate=intermediate-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	intermediate-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">chain&lt;T&gt;::~<span class="built_in">chain</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(firstNode!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		chianNode&lt;T&gt; *nextNode=firstNode-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> firstNode;</span><br><span class="line">		firstNode=nextNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. get函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; chain&lt;T&gt;::<span class="built_in">get</span>(<span class="type">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">checkIndex</span>(theIndex);</span><br><span class="line">	chainNode&lt;T&gt; *targetNode=firstNode;</span><br><span class="line">	<span class="keyword">while</span>(theIndex&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNode=targetNode-&gt;next;</span><br><span class="line">		theIndex--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> targetNode-&gt;element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.插入函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> chain&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">int</span> theIndex,<span class="type">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">checkIndex</span>(theIndex);</span><br><span class="line">	chainNode&lt;T&gt; *newNode=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(the Element);</span><br><span class="line">	<span class="keyword">if</span>(theIndex==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		newNode-&gt;next=firstNode;</span><br><span class="line">		firstNode=newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		chainNode&lt;T&gt; *insertLocation=firstNode;</span><br><span class="line">		<span class="keyword">while</span>(theIndex&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			insertLocation=inserLocation-&gt;next;</span><br><span class="line">			theIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		newNode-&gt;next=inserLocation-&gt;next;</span><br><span class="line">		inserLocation-&gt;next=newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	++listSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>5. 删除函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> chain&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">checkIndex</span>(theIndex);</span><br><span class="line">	chainNode&lt;T&gt;* eraseNode;</span><br><span class="line">	<span class="keyword">if</span>(theIndex==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		eraseNode=fiirstNode;</span><br><span class="line">		firstNode=eraseNode-&gt;next;</span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		chianNode&lt;T&gt; *frontNode=firstNode;</span><br><span class="line">		<span class="keyword">while</span>(theIndex&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			frontNode=frontNode-&gt;next;</span><br><span class="line">			theIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		eraseNode=frontNode-&gt;next;</span><br><span class="line">		frontNode-&gt;next=eraseNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> eraseNode;</span><br><span class="line">	listSize--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 除单链表外还有:</p>
<ul>
<li>循环链表：我们可以采用两个措施使链表的应用代码简洁高效：①把链表描述成一个单向循环链表。②在链表的前面加一个头结点。</li>
<li>双向链表：即有指向后继的指针，又有指向前驱的指针。</li>
</ul>
<p>这里不再介绍这两个，因为实现跟单链表相似，无非就是加了指针指向。</p>
<h6 id="c实现-3">3.2.2 C实现</h6>
<p><strong>1. 存储结构以及实现结构体</strong></p>
<p><code>LinkList、next</code>是指向结构的指针,用间接访问<code>-&gt;</code>符号。其中<code>LinkList</code>是链表的头指针，若<code>LinkList==NULL</code>(为空指针）,则表示链表为空。有时候我们会把头指针指向的是一个头结点（其数据域不存储任何东西或者存储链表长度等附加信息）,指针域<code>next</code>指向下一个结构。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c版本</span></span><br><span class="line"><span class="comment">//单链表的存储结构设置：</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 建立单链表：这个算法是从尾到表头进行建立的（当然也可以从表头到表尾）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatLinkList</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 L=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">	<span class="comment">//L=(LinkList)malloc(sizeof(LNode));</span></span><br><span class="line">	L-&gt;next==<span class="literal">NULL</span>;		<span class="comment">//建立一带头结点的单链表</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		LNode* p=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">		p-&gt;data=<span class="built_in">scanf</span>();</span><br><span class="line">		p-&gt;next=L-&gt;next;</span><br><span class="line">		L-&gt;next=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 插入操作：从头指针开始达到指定的位置，创建新节点（结构），插入。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">InsertElem</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNoed *p=L-&gt;next;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	s=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));		<span class="comment">//为新结构体分配动态内存</span></span><br><span class="line">	<span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 删除操作：从头指针开始达到指定的位置，改变next指针的指向，释放（free)要删除的结构（节点）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status  <span class="title">DeleteElem</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	LNode *q=p+<span class="number">1</span>;</span><br><span class="line">	p-&gt;next=q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 查找操作：与顺序表一样，应用回调函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(LinkList L,EemType e,<span class="type">int</span> (*compare)(ElemType,ElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=L-next;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="built_in">compare</span>(p-&gt;data,e)))</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="双向链表介绍">3.3 双向链表介绍</h5>
<p>链表的每一个节点给中既有指向下一个结点的指针，也有指向上一个结点的指针，可以快速的找到当前节点的前一个节点，适用于需要双向查找节点值的情况。 <img src="/数据结构-C-实现/shuangList.png" width="600"> <strong>双链表相对于单链表的优点：</strong></p>
<ul>
<li><strong>删除单链表中的某个节点时，一定要得到待删除节点的前驱，得到其前驱的方法一般是在定位待删除节点的时候一路保存当前节点的前驱</strong>，这样指针的总的的移动操作为2n次，如果是用双链表，就不需要去定位前驱，所以指针的总的的移动操作为n次。</li>
<li><strong>查找时也是一样的，可以用二分法的思路，从头节点向后和尾节点向前同时进行，这样效率也可以提高一倍。</strong></li>
</ul>
<p>但是市场上对于单链表的使用要超过双链表,，因为从存储结构来看，每一个双链表的节点都比单链表的节点多一个指针，如果长度是<code>n</code>，就需要<code>n*lenght</code>（32位是4字节，64位是8字节）的空间，这在一些追求时间效率不高的应用下就不适用了，因为他占的空间大于单链表的<code>1/3</code>，所以设计者就会一时间换空间。</p>
<h5 id="应用">3.4 应用</h5>
<h6 id="箱子排序链表形式">3.4.1 箱子排序(链表形式)</h6>
<p><strong>1. 箱子排序的原理</strong></p>
<p>对于链表因为若用冒泡选择排序，我们时间复制度是为<code>O(n*n)</code>。采用箱子排序会更快，时间复杂度为<code>O(n)</code>。<strong>所谓的箱子排序就是将值相同的节点放到一个箱子内，然后再将排好序的箱子内的链表串接起来形参有序链表。</strong>事先分好各个箱子大小。每一个箱子都是一个链表。一个箱子的节点数目介于<code>0~n</code>之间。它要做的是：</p>
<ul>
<li>逐个删除输入链表，把删除的节点分配到相应的箱子里；</li>
<li>把每一个箱子中的节点连接起来，使其成为一个有序链表；</li>
</ul>
<p><strong><em>注意</em></strong>：箱子排序适用于对有大量重复的数据进行排序，并且数据范围不大。不然试想一下假设有0~10000范围的数据，这个时候我们就得分好并管理10000个箱子，这是很麻烦的。</p>
<p><strong>2. 下面以学生的划分6个优秀等级作为例子</strong></p>
<p>学生结构包含：学生姓名，学生优秀等级。用大小为6的vector<studentStruct>表示分配了6个箱子。代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(2n)</span></span><br><span class="line"><span class="comment">//学生结构类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">studentStruct</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//等级为0，1，2，3，4，5</span></span><br><span class="line">	<span class="type">int</span> rank;		<span class="comment">//方便访问测试，直接将成员变量设为public</span></span><br><span class="line">	string name;</span><br><span class="line">	studentStruct* next;</span><br><span class="line">	<span class="built_in">studentStruct</span>():<span class="built_in">rank</span>(<span class="number">-1</span>),<span class="built_in">name</span>(<span class="string">&quot;&quot;</span>),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">studentStruct</span>(<span class="type">int</span> _rank,string _name):<span class="built_in">rank</span>(_rank),<span class="built_in">name</span>(_name),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">studentStruct</span>(<span class="type">const</span> stduentStrcut&amp; s):<span class="built_in">rank</span>(s.rank),<span class="built_in">name</span>(s.name),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	studentStruct&amp; <span class="keyword">operator</span>=(<span class="type">const</span> studentStruct* s)&#123;</span><br><span class="line">		name=s.name;</span><br><span class="line">		rank=s.rank;</span><br><span class="line">		next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">studentStruct</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箱子排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">boxSort</span><span class="params">(T* head)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//初始化六个空的节点，标识为-1</span></span><br><span class="line">	<span class="function">vector&lt;T*&gt; <span class="title">vec</span><span class="params">(<span class="number">6</span>)</span></span>;		<span class="comment">//当前索引的第一个位置</span></span><br><span class="line">	<span class="function">vector&lt;T*&gt; <span class="title">lastNode</span><span class="params">(<span class="number">6</span>)</span></span>;	<span class="comment">//记录当前索引最后一个节点的位置</span></span><br><span class="line">	<span class="comment">//遍历传入的链表，将学生节点分好箱子</span></span><br><span class="line">	<span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="type">int</span> index = head-&gt;rank % <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">if</span> (vec[index] == <span class="literal">NULL</span>) &#123;<span class="comment">//该位置为空，直接存入</span></span><br><span class="line">			vec[index] = head;</span><br><span class="line">			lastNode[index] = head;	<span class="comment">//刚存入的就是最后一个节点</span></span><br><span class="line">			head = head-&gt;next;</span><br><span class="line">			lastNode[index]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			T* tempNode = head-&gt;next;</span><br><span class="line">			head-&gt;next = lastNode[index]-&gt;next;		<span class="comment">//置NULL</span></span><br><span class="line">			lastNode[index]-&gt;next = head;</span><br><span class="line">			lastNode[index] = head;</span><br><span class="line">			head = tempNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将vector内的各个分散链表串接起来,未使用lastNode版本</span></span><br><span class="line">	T* endNext = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (endNext != <span class="literal">NULL</span>)<span class="comment">//不是第一次进入循环，进行连接</span></span><br><span class="line">			endNext-&gt;next = *it;</span><br><span class="line">		endNext = *it;</span><br><span class="line">		<span class="keyword">while</span> (endNext != <span class="literal">NULL</span> &amp;&amp; endNext-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//endNext!=NULL是防止该所谓位置无值，endNext是索引有值遍历到最后一个</span></span><br><span class="line">			endNext = endNext-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*，将vector内的各个分散链表串接起来，使用lastNode版本 */</span></span><br><span class="line">	T* first=<span class="literal">NULL</span>,*last=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	for(auto i=0;i&lt;lastNode.size();i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		if(last==NULL)&#123;</span></span><br><span class="line"><span class="comment">			last=lastNode[i];</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else if(last!=NULL&amp;&amp;lastNode[i]!=NULL)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			last-&gt;next=vec[i];</span></span><br><span class="line"><span class="comment">			last=lastNode[i];</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></studentStruct></p>
<h6 id="基数排序数组形式">3.4.2 基数排序（数组形式）</h6>
<p>对于上面的箱子排序，对于数据范围很大的数据很难有实践意义，<strong>基数排序</strong>为克服这一点而出现的。基数排序排序主要通过将数字分解进行排序，如三位数的925，技术排序可通过十进制分解，将925分解成9、2、5三个数，然后依次以个位、十位、百位进行排序。<strong>在这个过程中，因为数字只有0~9,所有仅仅需要10个桶就，然后调用三次箱子排序即可</strong>，时间复杂度为O(n<em>m) <img src="/数据结构-C-实现/jishusort.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">potencySort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> num)</span> </span>&#123;	<span class="comment">//num指示按哪位排序</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">tempVec</span>(<span class="number">10</span>);		<span class="comment">//二维数组，内部vector的大小看数据量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> index = vec[i] / num % <span class="number">10</span>;</span><br><span class="line">		tempVec[index].<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	vec.<span class="built_in">clear</span>();		<span class="comment">//清除里面的数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)		<span class="comment">//放回vec</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = tempVec[i].<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">while</span> (it != tempVec[i].<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">			++it;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </em><strong>注意：适用数据重复比较平均的时候，若是全部数据都在一个桶内，则会导致二维数组空间浪费</strong><em>。假设有10000000万数据排序，分配500万，则10</em>500*4=2亿字节，则需要190M内存，因此数据若是分配的比较均匀，则秩序分配200万，需要内存76M就足够了</p>
<h6 id="并查集">3.4.3 并查集</h6>
<p>要知道什么是<strong>并查集</strong>，就要先知道什么是<strong>等价类</strong>。所谓的<strong>等价类</strong>就是指再一个给的n元素的集合R中有两两配对的等价关系且已经是等价关系的最大<strong>集合</strong>（等价类是集合），<strong>如<code>n=14.R=&#123;(1,11),(7,11),(2,12),(12,8),(11,12),(3,13),(13,14)&#125;</code>,如果<code>(a,b)∈R</code>则<code>a,b</code>两个类是等价的，且不能在外部找到其他等价关系。</strong>等价具有自反性、对称性、传递性。即：</p>
<ul>
<li>若<code>a∈R</code>，则<code>(a,a)</code>必属于R，自反性</li>
<li>若<code>(a,b)∈R</code>，则必有<code>(b,a)∈R</code>，对称性</li>
<li>若<code>(a,b)∈R，(b,c)∈R</code>，则<code>(a,c)∈R</code>，传递性</li>
</ul>
<p>等价类分为<strong>离线等价类</strong>和<strong>在线等价类</strong>。在线等价类又称为<strong>并查集</strong></p>
<ul>
<li>离线等价类：n和R已知，确定了所有的等价类关系，且每个元素只能属于一个等价类，即只能在一个集合R</li>
<li><p><strong>在线等价类（并查集）</strong>：初始又n个元素，每个元素刚开始都属于一个独立的等价类。需要执行以下的步骤：</p></li>
<li><code>conbine(a,b)</code>,把包含a和b的等价类合并成一个等价类</li>
<li><p><code>find(theElement)</code>,确定元素在哪一个等价类，目的是对给定的两个元素，确定是否属于同一个类，对同一类元素返回相同结果，否则返回不同结果</p></li>
</ul>
<p><strong>经典的机器调度和布线问题，后续树会讲到</strong></p>
<h4 id="栈">4. 栈</h4>
<h5 id="栈的介绍">4.1 栈的介绍</h5>
<p>栈是一种重要的线性结构，通常称，<strong>栈和队列是限定插入和删除只能在表的“端点”进行操作的线性表。</strong></p>
<ul>
<li>栈的元素必须<code>“后进先出LIFO“</code>。</li>
<li>栈的操作只能在这个线性表的表尾进行。</li>
<li>对于栈来说，这个表尾称为栈的栈顶（top），相应的表头称为栈底（bottom）。</li>
<li>因为栈的本质是一个线性表，线性表有两种存储形式，那么栈也有分为栈的顺序存储结构和栈的链式存储结构。</li>
<li>最开始栈中不含有任何数据，叫做空栈，此时栈顶就是栈底。然后数据从栈顶进入，栈顶栈底分离，整个栈的当前容量变大。数据出栈时从栈顶弹出，栈顶下移，整个栈的当前容量变小。 <img src="/数据结构-C-实现/stack.gif" width="500"></li>
</ul>
<h5 id="实现-2">4.2 实现</h5>
<p>栈的<strong>顺序存储结构</strong>是利用一组<strong>地址连续的存储单元</strong>依次存放自栈底到栈顶的数据元素，同时附设指针<code>top</code>指示栈顶元素在顺序栈中的位置，先为栈分配一个合理的容量，在应用过程中，当栈的空间不够时再逐渐扩大。</p>
<p>按设定的的初始分量进行第一次存储分配，<code>base</code>可称为栈底指针，在顺序栈中，它始终指向栈底位置。若为<code>base</code>的值为<code>NULL</code>，则表明<strong>栈结构不存在</strong>。<code>top</code>为栈顶指针，其初值指向栈底，既<code>top=base</code>作为<strong>栈空</strong>的标记，每当压入心得栈顶元素时，栈顶<code>top+1</code>，删除<code>-1</code>.因此非空栈的栈顶指针始终在栈顶元素的下一个位置上</p>
<h6 id="c实现-4">4.2.1 C++实现</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Stack</span>();</span><br><span class="line">	<span class="built_in">stack</span>(<span class="type">int</span> cap):<span class="built_in">capacity</span>(cap),<span class="built_in">elements</span>(<span class="keyword">new</span> T[capacity])&#123;&#125;</span><br><span class="line">	<span class="built_in">Stack</span>(<span class="type">const</span> Stack&amp;);</span><br><span class="line">	Stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Stack&amp;);</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Stack</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">capacity</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">increaseCapaciyu</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="type">int</span> base=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> capacity=<span class="number">10</span>;</span><br><span class="line">	T* elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="c实现-5">4.2.2 C实现</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序栈的存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType *base;</span><br><span class="line">	ElemType  *top;</span><br><span class="line">	<span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个顺序栈：注意此时top=base;</span></span><br><span class="line"><span class="function">status <span class="title">InitialStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//构造一个空栈</span></span><br><span class="line">	s.base=(ElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span>（S.base==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stackszie=STACK_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶元素：先判断栈不空</span></span><br><span class="line"><span class="function">status <span class="title">GetTopElem</span><span class="params">(SqStack S,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//取栈顶元素</span></span><br><span class="line">	<span class="keyword">if</span>(S.base==S.top)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	e=*(S.top<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素：判断当前的容量是否足够吗、不够则增加，再插入</span></span><br><span class="line"><span class="function">status 	<span class="title">PushElem</span><span class="params">(SqStack &amp;S,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//插入栈顶元素</span></span><br><span class="line">	<span class="type">int</span> length=(S.top-S.base)/<span class="built_in">sizeof</span>(ElemType);</span><br><span class="line">	<span class="keyword">if</span>(length&gt;=S.stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		ElemType *newbase=(ElemType*)<span class="built_in">realloc</span></span><br><span class="line">			(S.base,(S.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">		<span class="keyword">if</span>(newbase==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		S.base=newbase;</span><br><span class="line">		S.top=S.base+S.stacksize;</span><br><span class="line">		S.stacksize+=STACKINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++=e;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素：</span></span><br><span class="line"><span class="function">Status <span class="title">pop</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	e=*--S.top;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="应用-1">4.3 应用</h5>
<p>栈的能应用于各式各样的后进先出的地方，比如表达式括号匹配，四则运算、迷宫问题等。</p>
<h6 id="健壮四则运算">4.3.1 健壮四则运算</h6>
<p><strong>我的思路：</strong></p>
<ul>
<li>1、把输入的式子中其它<code>&#123;&#125;[]</code>转化为<code>()</code>的形式</li>
<li>2、输入的式子可能有负值，将其转化为减法运算，既前面加0</li>
<li>3、对于<code>(</code>和空运算符栈情况下，运算符直接入栈</li>
<li>4、数字判断长度后，转化为int入栈</li>
<li>5、对于<code>* /</code>，运算符栈顶元素若是同级，则栈顶元素出栈运算，这样避免同出现<code>8/2/2=8</code>的情况</li>
<li>6、对于<code>+ -</code>同级或高级的栈顶运算符也要出栈运算，注意<code>2-2*3+2</code>的特殊情况处理，代码129-142就是处理这种情况。</li>
<li>7、对于)，则直接出栈运算直到(即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">change_bracket</span><span class="params">(string&amp; str)</span></span>;    <span class="comment">//改变&#x27;&#123;&#x27;[&#x27;为&#x27;(&#x27;,改&#x27;]&#x27;,&#x27;&#125;&#x27;为&#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">addZero</span><span class="params">(string&amp; str)</span></span>;    <span class="comment">//判断表达式的是否为有负值，有则前面加0,改为减法</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">handler</span><span class="params">(string&amp; str)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">caculate</span><span class="params">(<span class="type">char</span> s, <span class="type">int</span> a, <span class="type">int</span> b)</span></span>;    <span class="comment">//进行计算</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line">    <span class="built_in">change_bracket</span>(input);</span><br><span class="line">    <span class="built_in">addZero</span>(input);</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">handler</span>(input);</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_bracket</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;&#123;&#x27;</span> || *it == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            *it = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;&#125;&#x27;</span> || *it == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            *it = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addZero</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*str.<span class="built_in">begin</span>() == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>(), <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m = str.<span class="built_in">begin</span>() + <span class="number">1</span>; m != str.<span class="built_in">end</span>(); m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (((*m == <span class="string">&#x27;-&#x27;</span> &amp;&amp; *(m - <span class="number">1</span>) &lt; <span class="string">&#x27;0&#x27;</span>) || (*m == <span class="string">&#x27;-&#x27;</span> &amp;&amp; *(m - <span class="number">1</span>) &gt; <span class="string">&#x27;9&#x27;</span>))&amp;&amp;*(m<span class="number">-1</span>)!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            m = str.<span class="built_in">insert</span>(m, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">caculate</span><span class="params">(<span class="type">char</span> s, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (s)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        c = a * b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        c = a / b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        c = a + b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        c = a - b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">handler</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; in_num;      <span class="comment">//数字栈</span></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; in_char;    <span class="comment">//运算符栈</span></span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">        &#123;<span class="comment">//处理数字</span></span><br><span class="line">            <span class="type">int</span> j = i, num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; str.<span class="built_in">length</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[i + <span class="number">1</span>]))</span><br><span class="line">             &#123;  i++;		&#125;</span><br><span class="line">            <span class="comment">//拷贝子串数字</span></span><br><span class="line">            string str_num = str.<span class="built_in">substr</span>(j, i - j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; str_num.<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;<span class="comment">//转为数字</span></span><br><span class="line">                num = num * <span class="number">10</span> + str_num[k] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//压入数字栈</span></span><br><span class="line">            in_num.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理(，空运算符栈，直接压入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || in_char.<span class="built_in">empty</span>())</span><br><span class="line">            in_char.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        <span class="comment">//处理*,/，既同级的直接前一个先算</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>() &amp;&amp; (tmp == <span class="string">&#x27;/&#x27;</span> || tmp == <span class="string">&#x27;*&#x27;</span>))<span class="comment">//要弹出/进行计算</span></span><br><span class="line">            &#123;</span><br><span class="line">                b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                in_char.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            in_char.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理+ -</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//同理，同级和高级的先处理</span></span><br><span class="line">            tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>() &amp;&amp; (tmp == <span class="string">&#x27;+&#x27;</span> || tmp == <span class="string">&#x27;-&#x27;</span> || tmp==<span class="string">&#x27;*&#x27;</span> ||tmp==<span class="string">&#x27;/&#x27;</span> ))</span><br><span class="line">            &#123;</span><br><span class="line">                b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                in_char.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (tmp == <span class="string">&#x27;+&#x27;</span> || tmp == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                    in_num.<span class="built_in">pop</span>();</span><br><span class="line">                    a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                    in_num.<span class="built_in">pop</span>();</span><br><span class="line">                    in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                    in_char.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            in_char.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                in_char.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//更新tmp</span></span><br><span class="line">                tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出(</span></span><br><span class="line">            in_char.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!in_char.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">        b = in_num.<span class="built_in">top</span>();</span><br><span class="line">        in_num.<span class="built_in">pop</span>();</span><br><span class="line">        a = in_num.<span class="built_in">top</span>();</span><br><span class="line">        in_num.<span class="built_in">pop</span>();</span><br><span class="line">        in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">        in_char.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in_num.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="括号匹配">4.3.2 括号匹配</h6>
<p>给的一个括号字符串，判断这个字符串是否有效即括号是否匹配。有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。 <img src="/数据结构-C-实现/kuohao.gif" width="200"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketsOK</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	stack&lt;<span class="type">char</span>&gt; in_char;</span><br><span class="line">	<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (it != s.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">&#x27;(&#x27;</span> || *it == <span class="string">&#x27;&#123;&#x27;</span> || *it == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">			in_char.<span class="built_in">push</span>(*it);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="type">char</span> c = in_char.<span class="built_in">top</span>();</span><br><span class="line">			in_char.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> &amp;&amp; (c + <span class="number">1</span>) != *it)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &amp;&amp; (c + <span class="number">2</span>) != *it)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="队列">5. 队列</h4>
<p><strong>队列是一先进先出的线性结构，允许插入的一端叫做队尾，允许删除的一端叫队头。</strong></p>
<h5 id="链队列">5.1 链队列</h5>
<p>一个链队列需要两个分别<strong>指示队头和队尾的指针（头指针和尾指针）</strong>才能唯一确定。和线性表的单链表一样，为操作方便，也给队列添加一头结点，并令头指针指向头结点。所以空队列的判决条件为头指针和尾指针均指在头结点。链队列的操作为单链表插入和删除操作的特殊情况，只需修改尾指针和头指针即可。读取时的时间复杂度为O(1)。插入、删除时的时间复杂度为O(1)。 <img src="/数据结构-C-实现/listqueue.png" width="500"> <strong>优点：</strong></p>
<ul>
<li>相比普通的队列，元素出队时无需移动大量元素，只需移动头指针。</li>
<li>可动态分配空间，不需要预先分配大量存储空间。</li>
<li>适合处理用户排队等待的情况。</li>
</ul>
<p><strong>缺点：</strong> -- 需要为表中的逻辑关系增加额外的存储空间。</p>
<h5 id="循环队列">5.2 循环队列</h5>
<p>在循环队列中，空队特征是front = rear, 队满时也会有front = rear; 判断条件将出现二义性（到底是空还是满？） <img src="/数据结构-C-实现/jiaqueque.png" width="500"> <strong>解决方案有三种：</strong></p>
<ul>
<li><ol type="1">
<li>加设标志位，让删除动作使其为1，插入动作使其为0， 则可识别当前front == rear;</li>
</ol></li>
<li><ol start="2" type="1">
<li>使用一个计数器记录队列中元素个数（即队列长度）</li>
</ol></li>
<li><ol start="3" type="1">
<li>人为浪费一个单元，令队满特征为 front = (rear +1)%N---空闲单元法</li>
</ol></li>
</ul>
<p><strong>这里采用空闲单元法解决二义性问题。</strong> <img src="/数据结构-C-实现/xunqueue.gif" width="500"></p>
<h5 id="实现-3">5.3 实现</h5>
<p>这里我们均采用C来实现链队列和循环队列</p>
<h6 id="链队列实现">5.3.1 链队列实现</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链队列的存储结构：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">QNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType	data;</span><br><span class="line">	<span class="keyword">struct</span>  <span class="title class_">QNode</span>  *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	QueuePtr front;	<span class="comment">//队头指针（指向头结点）</span></span><br><span class="line">	QueuePtr  rear;	<span class="comment">//队尾指针（指向尾结点）</span></span><br><span class="line">&#125;LinkQueue</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链队列：</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//构造一空队列</span></span><br><span class="line">	Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">	Q.front=Q.rear;	<span class="comment">//队头队尾指针均指向头结点。</span></span><br><span class="line">	<span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列：</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(Q.front!=<span class="literal">NULL</span>)&#123;		<span class="comment">//从队头开始一步步free队头</span></span><br><span class="line">		Q.rear=Q.front-&gt;next;     <span class="comment">//队尾移至队头结点的下一个结点（结构体）</span></span><br><span class="line">		<span class="built_in">free</span>(Q.front);			<span class="comment">//释放动态内存</span></span><br><span class="line">		Q.front=Q.rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入操作：从队尾插入</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QNode *p=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">	<span class="comment">//QNode *p=(QNode*)malloc(sizeof(QNode));</span></span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	p-&gt;data=e;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q.rear-&gt;next=p;</span><br><span class="line">	Q.rear=p;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function">Status <span class="title">DeletQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)<span class="keyword">return</span> ERROR;</span><br><span class="line">	QNode *p=Q.front-&gt;next;</span><br><span class="line">	e=p-&gt;data;</span><br><span class="line">	Q.front-&gt;next=p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==p)<span class="comment">//判断是否为空了，若空了，则队头和队尾指向头结点（相等）。</span></span><br><span class="line">		Q.rear=Q.front;</span><br><span class="line">	<span class="built_in">free</span>(p)</span><br><span class="line">	<span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="跳表和哈希散列">6. 跳表和哈希散列</h4>
<p>有序链表、有序数组、跳表和哈希表的渐进性能如下：</p>
<table>
<thead>
<tr class="header">
<th>数据结构</th>
<th>最坏情况</th>
<th>平均情况</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>有序数组</td>
<td>查找<code>O(lngn)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(lngn)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
</tr>
<tr class="even">
<td>有序链表</td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
</tr>
<tr class="odd">
<td>跳表</td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(logn)</code>、插入<code>O(logn)</code>、删除<code>O(logn)</code></td>
</tr>
<tr class="even">
<td>哈希表</td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(1)</code>、插入<code>O(1)</code>、删除<code>O(1)</code></td>
</tr>
</tbody>
</table>
<p>在C+的STL中适用了哈希散列的容器有：<code>unordered_map、unordered_set、hash_map、hash_multimap、hash_multiset、hash_set</code></p>
<h5 id="跳表">6.1 跳表</h5>
<p>对于有序数组，我们进行二分查找所需要的时间为<code>O(logn)</code>。但是在有序链表上仍然需要的时间为<code>O(n)</code>，<strong>为了提高有序链表的查找性能，可以在全部或者部分节点增加额外的指针，在查找时，通过这些指针，可以跳过链表的若干个点，不必查看所有节点来寻找</strong> <strong>调表</strong>采用<strong>随机技术</strong>来决定链表的哪些节点应增加额外的指针，以及增加多少个指针，基于这种技术，跳表的查找、插入、删除的<strong>平均时间复杂度为<code>O(logn)</code></strong>,最坏情况为<code>O(n)</code>. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构skipNOde</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">skipNode</span>&#123;</span><br><span class="line">	K element;</span><br><span class="line">	skipNode&lt;K&gt; **next;			<span class="comment">//指针数组</span></span><br><span class="line">	<span class="built_in">skipNode</span>(<span class="type">const</span> K&amp; ele,<span class="type">int</span> size):</span><br><span class="line">		<span class="built_in">element</span>(ele)&#123;next=<span class="keyword">new</span> skipNode&lt;K&gt;* [size];&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体的指针域有next数组统一管理，next[i]表示i级链表的指针，元素存储在element内</span></span><br></pre></td></tr></table></figure></p>
<h6 id="实现原理">6.1.1 实现原理</h6>
<p>在一个用有序链表中查找指定值，至多需要N次值的比较。如果链表的中部节点加一个指针，则比较次数可以减少到<code>N/2+1</code>。这个时候我们在查找一个数时，首先是与中部的这个节点进行值比较，如果查找的数对关键字小，则只在左半部分继续查找，若大，则在右半部分查找。如下图所示: <img src="/数据结构-C-实现/skiplist.gif" width="500"> 上图非常形象的展现了跳表的查找操作：如果跳表有多级索引，如图建立了一级索引，则从一级索引出发.</p>
<p><strong>1. 索引级数的分配</strong></p>
<ul>
<li>在跳表中对<code>n</code>个元素而言，以均等分<code>p=0.5</code>,则最多可有链表级数为<code>maxLevel=logn-1</code>。</li>
<li>对于第<code>i</code>级链表，每<code>2^i</code>个元素取一个进行连接 <img src="/数据结构-C-实现/skiplist.png" width="500"></li>
</ul>
<p><strong>2. 插入和删除</strong></p>
<p>在插入和删除的时候，如果要保持索引级数分配的规则结构，要耗时<code>O(n)</code>，我们指定i级链表有<code>n/(2^i)</code>个元素，在插入的时候新数据属于<code>i</code>级链表的概率为<code>1/(2^i)</code>。</p>
<p><strong>插入步骤：</strong></p>
<ul>
<li>进行查找<code>O(logn)</code>，找到要插入的位置</li>
<li>插入时，要为新数据分配一个级，分配过程就是我们之前说的<strong>随机数生成器</strong>完成（随机数只是尽可能的维护这种结构规则，不是严格意义上的）</li>
<li>当新数据插入<code>i</code>级链表的时候，只会对<code>0~i</code>级链表产生影响，因此要记住这些链表的前驱</li>
<li>然后只需对next[0~i]进行重新next指针指向</li>
</ul>
<p>对于删除，我们无法控制结构即没有生成随机数操作来中和，<strong>删除操作：</strong></p>
<ul>
<li>要删除指定节点，就必须先找到该节点所在处</li>
<li>知道节点的所找链表级数<code>i</code>，则只会影响<code>0~i</code>级的链表</li>
<li>对<code>0~i</code>级进行<code>next</code>指针重指向</li>
</ul>
<p><strong>为什么插入要随机数：</strong>试想一下，如果插入一直指定一个级数去插入，那么极端情况下将会使跳表退化成单链表，也就失去了跳表的作用，作为一种动态数据结构，我们需要某种手段来维护级数与元素个数之间的平衡。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> skipList&lt;T&gt;::<span class="built_in">level</span>()<span class="type">const</span>&#123;</span><br><span class="line">	<span class="comment">//返回一个链表级数随机数</span></span><br><span class="line">	<span class="type">int</span> lev=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">rand</span>()&lt;=cutoff)</span><br><span class="line">		lev++;</span><br><span class="line">	<span class="keyword">return</span> (lev&lt;maxLevel)?lev:maxLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="哈希表散列表">6.2 哈希表（散列表）</h5>
<p><strong>哈希表就是根据设定的哈希函数和处理冲突的方法将关键字映射到一个有限的连续的地址集（哈希数组）</strong>。当关键字的范围太大，不能用理想方法表示时，可以采用并不理想的哈希表和哈希函数：哈希表的位置的数量比关键字少，哈希函数把若干个不同关键字映射到哈希表的同一个位置（哈希表的每一个位置叫一个桶），桶的数量等于哈希表的长度。</p>
<p>构造哈希表，最常遇到的问题无非就是：</p>
<ul>
<li><strong>冲突</strong>：当两个不同关键字经哈希函数计算后的桶相同时，冲突就发生了。但这对于一个桶可以容纳多个数对的桶来说，并没有什么影响</li>
<li><strong>溢出</strong>：桶没有位置可以存储新的数对，就会溢出</li>
</ul>
<h6 id="实现原理-1">6.2.1 实现原理</h6>
<p><strong>哈希表的建立会适用特定的哈希函数将关键字进行计算转化生成我们访问的下标</strong>，这样就能够建立起<strong>访问、插入、删除</strong>的<code>O(1)</code>操作。因此最重要的是哈希函数的选择和对下标的实现。构造哈希函数的原则是：</p>
<ul>
<li><strong>①函数本身便于计算；</strong></li>
<li><strong>②计算出来的地址分布均匀，即对任一关键字k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突。</strong></li>
</ul>
<p>以下是对哈希函数的常用思想：</p>
<ul>
<li><strong>直接定址法</strong>：<strong>取关键字某个线性函数值为哈希地址</strong>，即<code>H(key)=a*key+b</code></li>
<li><strong>数字分析法</strong>：<strong>前提关键字都是知道的，在此基础上分析数据，依数据选择取哪些位作为<code>key</code>值</strong>。例子：比如现有<code>80</code>个<code>8</code>位的十进制数，只能分配长为<code>100</code>的哈希表供你使用，此时就要依据这<code>8</code>位中哪些位取值分散而从中选取2位为哈希地址来尽可能避免冲突。</li>
<li><strong>平方取中法</strong>：<strong>取关键字平方后的中间几位为哈希地址</strong>，平方取中法比较适用于不清楚关键字的分布，且位数也不是很大的情况。</li>
<li><strong>折叠法</strong>：<strong>将关键字分成位数相同的几部分（最后一部分的位数可以不同），然后取这些部分叠加和作为哈希地址</strong>。折叠法比较适用于不清楚关键字的分布，但是关键字位数较多 的情况</li>
<li><strong>除留余数法</strong>：<strong>取关键字被某个不大于哈希表长m的数<code>p</code>除后所得余数为哈希地址</strong>，即<code>h（k）=k  %  p</code> ，其中<code>%</code>为模p取余运算。一般<code>p</code>选为质数</li>
<li><strong>位与法</strong>：哈希数组的长度一般选择2的幂，在C/C++中位运算相对较为高效，选择2的幂作为数组长度，可以将取模运算转换成<strong>二进制位与</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//专业版hash&lt;string&gt;</span></span><br><span class="line"><span class="comment">//将string关键字转换为size_t的整型哈希值</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash</span>&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string thekey)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> hashValue=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> length=(<span class="type">int</span>) theKey.<span class="built_in">length</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">			hashValue=<span class="number">5</span>*hashValue+thekey.<span class="built_in">at</span>(i);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_t</span>(hashValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="解决hash冲突方案">6.2.2 解决hash冲突方案</h6>
<ul>
<li><strong>开放定址法</strong>: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</li>
<li><strong>再哈希法</strong>：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。</li>
<li><strong>链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中</strong></li>
<li><strong>建立公共溢出区</strong>：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。</li>
</ul>
<h4 id="二叉树">7. 二叉树</h4>
<h5 id="树的概念">7.1 树的概念</h5>
<p>树型结构是一类重要的非线性结构。树（Tree)是n个结点的有限集，在任一非空树中：</p>
<ul>
<li>有且只有一个特定的称为根（Root)的结点，没有前驱的结点称为根结点。</li>
<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、T3.....Tm，每一个集合本身又是一颗树，并且称为根Root的子树。</li>
<li>每一个非根结点有且只有一个父结点；</li>
</ul>
<p><strong>基本术语</strong>：</p>
<ul>
<li><strong>节点的度：一个节点含有的子树的个数称为该节点的度</strong></li>
<li><strong>叶子：度为0的节点</strong></li>
<li><strong>非终端节点或分支节点</strong>：度不为零的节点；</li>
<li><strong>树的度</strong>：树内所有节点的度的最大值；</li>
<li><strong>双亲节点或父节点</strong>：若一个结点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点或子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li><strong>堂兄弟节点</strong>：双亲在同一层的节点互为堂兄弟；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙；</li>
<li><strong>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</strong></li>
<li><strong>树的高度或深度：树中节点的最大层次；</strong></li>
<li>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
<li><strong>有序树/无序树：如果将树中节点的各个子树看成从左到右是有次序的，则称该树为有序树，否则为无序树；</strong></li>
</ul>
<h5 id="二叉树-1">7.2 二叉树</h5>
<p>二叉树是另一种树型结构，它的特定是每个结点至多只有两棵子树。且二叉树的子树有左右之分，其次序不能任意颠倒。也可为空树。<strong>二叉树和树的根本区别是：</strong></p>
<ul>
<li>二叉树的每个元素恰好有两颗子树。而树可有任意数量的子树</li>
<li>在二叉树中，每个元素的子树都是有序的，即左子树和右子数之分。而树的子树是无序的</li>
<li>二叉树可以为空。而树不能为空</li>
</ul>
<h5 id="二叉树特性">7.3 二叉树特性</h5>
<p>二叉树具有较多的特性，使用也比较广泛：</p>
<ul>
<li><strong>在二叉树的第<code>i</code>层上至多有<code>2^(i-1)</code>个结点<code>i&gt;=1</code>;</strong></li>
<li>深度为K的二叉树至多有<code>2^(k)-1</code>个结点<code>K&gt;=1</code>;</li>
<li><strong>对任何一颗二叉树<code>T</code>，如果其终端结点数为<code>n0</code>，度为2的结点数为<code>n2</code>，则<code>n0=n2+1</code>;</strong></li>
<li>具有n个结点的完全二叉树的深度为<code>L[log2(n)]+1</code>;<code>(L[X]表示取不大于X的最大整数）</code></li>
<li><strong>如果对一颗有<code>n</code>个结点的完全二叉树（深度为<code>L[log2(n)]+1</code>）的结点按层序编号（从第一层到<code>L[log2(n)]+1</code>层，每层从左到右），则对任一结点<code>i(1&lt;=i&lt;=n)</code>,，有：</strong></li>
<li>①<code>i=1</code>，则结点<code>i</code>是二叉树的根，无双亲；<code>i&gt;1</code>,则其双亲时结点<code>[i/2]</code></li>
<li>②如果<code>2i&gt;n</code>，则结点<code>i</code>无左孩子，否则其左孩子为<code>2i</code></li>
<li>③如果<code>2i+1&gt;n</code>，则结点无右孩子，否则其右孩子为<code>2i+1</code></li>
</ul>
<p><strong>满二叉树和完全为叉树</strong>： <strong>满二叉树：</strong>当高度为<code>h</code>的二叉树恰好有<code>2^h-1</code>个元素时，为满二叉树 <strong>完全二叉树：</strong>最后一层的叶子只能空右左节点，不能有右节点而没有左节点,下图为完全被二叉树 <img src="/数据结构-C-实现/binaryTree.png" width="400"></p>
<h5 id="二叉树的存储结构">7.4 二叉树的存储结构</h5>
<p>二叉树的存储结构一般有顺序存储和链式存储。顺序存储也成为数组形式的描述，而链式存储是二叉树最常用的存储结构，它是用两个左右孩子指针指向其左右孩子节点。</p>
<h6 id="顺序存储">7.4.1 顺序存储</h6>
<p>顺序存储就是用一组地址连续的存储单元依次至上而下、从左到右存储完全二叉树的节点元素，所以顺序存储结构仅适用于完全二叉树和满二叉树（否则会造成空间浪费）。二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。如上图的完全二叉树在数组形式的存储如下： <img src="/数据结构-C-实现/arrayTree.png" width="400"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> ElemType sqBiTree[MAX_TREE_SIZE];</span><br><span class="line">sqBiTree bt;</span><br></pre></td></tr></table></figure></p>
<h6 id="链式存储结构">7.4.2 链式存储结构</h6>
<p>既然顺序存储不能满足二叉树的存储需求，那么考虑采用链式存储。由二叉树定义可知，二叉树的每个结点最多有两个孩子。因此，可以将结点数据结构定义为一个数据和两个指针域。表示方式如图 <img src="/数据结构-C-实现/listTree.png" width="300"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> stuct BiTNode&#123;</span><br><span class="line">TElemType data;</span><br><span class="line">strcut BiTNode *lchild,*rchlid;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></p>
<h5 id="实现-4">7.5 实现</h5>
<p>对于二叉树的实现这里主要讲解C++语言的实现</p>
<h6 id="结构体和实现类">7.5.1 结构体和实现类</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点类，用于构建树中的节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T data;</span><br><span class="line">	binaryTreeNode&lt;T&gt;* lchid,* rchild;</span><br><span class="line">	<span class="built_in">binaryTreeNode</span>() :<span class="built_in">lchild</span>(<span class="literal">NULL</span>),<span class="built_in">rchild</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTreeNode</span>(<span class="type">const</span> T&amp; _data) :<span class="built_in">data</span>(_data),<span class="built_in">lchild</span>(<span class="literal">NULL</span>),<span class="built_in">rchild</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTreeNode</span>(<span class="type">const</span> T&amp; _data,binaryTreeNode&lt;T&gt;* left,binaryTreeNode&lt;T&gt;* right) :</span><br><span class="line">		<span class="built_in">data</span>(_data),<span class="built_in">lchild</span>(left),<span class="built_in">rchild</span>(right) &#123;&#125;</span><br><span class="line">	~<span class="built_in">binaryTreeNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">binaryTree</span>() :<span class="built_in">size</span>(<span class="number">1</span>), <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">binaryTreeNode</span>&lt;T&gt;()) &#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTree</span>(<span class="type">const</span> T&amp; _data):<span class="built_in">size</span>(<span class="number">1</span>),<span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">binaryTreeNode</span>&lt;T&gt;(_data))&#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTree</span>(binaryTreeNode&lt;T&gt;* node) :<span class="built_in">size</span>(<span class="number">1</span>), <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">binaryTreeNode</span>&lt;T&gt;(node-&gt;data, node-&gt;lchid, node-&gt;rchild)) &#123;&#125;</span><br><span class="line">	~<span class="built_in">binaryTree</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">binaryTreeNode&lt;T&gt;* <span class="title">getRoot</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTree&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">leveltOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">indsert</span><span class="params">(binaryTreeNode&lt;T&gt;* insert_Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">del</span><span class="params">(<span class="type">int</span> index)</span></span>;						<span class="comment">//使用层次遍历定位</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::<span class="type">size_t</span> <span class="title">height</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="type">size_t</span> size;</span><br><span class="line">	binaryTreeNode&lt;T&gt;* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="前序遍历">7.5.2 前序遍历</h6>
<p>前序遍历是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。 <img src="/数据结构-C-实现/preOrder.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Node==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(Node-&gt;data);</span><br><span class="line">	<span class="built_in">preOrder</span>(vec,Node-&gt;lchild);</span><br><span class="line">	<span class="built_in">preOrder</span>(vec,Node-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归版本,使用栈这个辅助数据结构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	stack&lt;binaryTreeNode&lt;T&gt;*&gt; _sta;</span><br><span class="line">	<span class="keyword">if</span>(Node!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">auto</span> p=Node;</span><br><span class="line">		<span class="keyword">while</span>(!_sta.<span class="built_in">empty</span>()||p!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">				vec.<span class="built_in">push_back</span>(p-&gt;data);</span><br><span class="line">				_sta.<span class="built_in">push</span>(p);</span><br><span class="line">				p=p-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!_sta.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				p=_sta.<span class="built_in">top</span>();</span><br><span class="line">				_sta.<span class="built_in">pop</span>();</span><br><span class="line">				p=p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="中序遍历">7.5.3 中序遍历</h6>
<p>中序遍历就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。 <img src="/数据结构-C-实现/inOrder.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTree&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Node==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inOrder</span>(vec,Node-&gt;lchild);</span><br><span class="line">	vec.<span class="built_in">push_back</span>(Node-&gt;data);</span><br><span class="line">	<span class="built_in">inOrder</span>(vec,Node-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 非递归使用栈结构进行辅助 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">binaryTree&lt;T&gt; *<span class="title">GoFarLeft</span><span class="params">(binaryTree&lt;T&gt;* t,stack&lt;binaryTreeNode&lt;T&gt;*&gt; &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//找到t树的最左孩子的指针，用指针返回，同时压栈所有遍历过的最左指针</span></span><br><span class="line">	<span class="keyword">if</span>(!t)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(t-&gt;lchild)&#123;</span><br><span class="line">		S.<span class="built_in">push</span>(t);</span><br><span class="line">		t=t-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec,binaryTree&lt;T&gt;*	root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;binaryTreeNode&lt;T&gt;*&gt; _sta</span><br><span class="line">	aotu t=<span class="built_in">GoFarLeft</span>(root,_sta);</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(t-&gt;data);</span><br><span class="line">		<span class="keyword">if</span>(t-&gt;rchild)</span><br><span class="line">			t=<span class="built_in">GoFarLeft</span>(t-&gt;rchild,_sta);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!_sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			t=_sta.<span class="built_in">top</span>();</span><br><span class="line">			_sta.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="后序遍历">7.5.4 后序遍历</h6>
<p>后序遍历就是从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。 <img src="/数据结构-C-实现/postOrder.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Node==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">postOrder</span>(vec,Node-&gt;lchild);</span><br><span class="line">	<span class="built_in">postOrder</span>(vec,Node-&gt;rchild);</span><br><span class="line">	vec.<span class="built_in">push_back</span>(Node-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 后序遍历的非递归算法，同样采用栈数据结构辅助 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strcut TreeNode &#123;</span></span><br><span class="line"><span class="comment">//  ElemType data;</span></span><br><span class="line"><span class="comment">//  TreeNode *left, *right;</span></span><br><span class="line"><span class="comment">//  TreeNode() &#123;</span></span><br><span class="line"><span class="comment">//      left = right = NULL;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(vector&lt;T&gt;&amp; vec,binaryTreeNode&lt;T&gt; *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *p = root, *r = <span class="literal">NULL</span>;</span><br><span class="line">    stack&lt;binaryTreeNode&lt;T&gt;*&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (p || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;<span class="comment">//走到最左边</span></span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild &amp;&amp; p-&gt;rchild != r)<span class="comment">//右子树存在，未被访问</span></span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(p-&gt;data)</span><br><span class="line">                r = p;<span class="comment">//记录最近访问过的节点</span></span><br><span class="line">                p = <span class="literal">NULL</span>;<span class="comment">//节点访问完后，重置p指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="层次遍历">7.5.5 层次遍历</h6>
<p>层次遍历中一般使用<strong>队列</strong>作为辅助工具，将根节点压入后，访问其左右孩子节点并压入，然后根节点出队列，依据队列的先进先出，再访问根节点的左孩子节点的孩子节点并压入，然后是根节点的右孩子节点的孩子节点压入，以此递推下去。 <img src="/数据结构-C-实现/level.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">level</span><span class="params">(vector&lt;T&gt;&amp; vec,binaryTreeNode&lt;T&gt; *root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		queue&lt;binaryTreeNode&lt;T&gt;*&gt; _que;</span><br><span class="line">		_que.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span>(!_que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="keyword">auto</span> t=_que.<span class="built_in">front</span>();</span><br><span class="line">			_que.<span class="built_in">pop</span>();</span><br><span class="line">			vec.<span class="built_in">push_back</span>(t-&gt;data);</span><br><span class="line">			<span class="keyword">if</span>(t-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">				_que.<span class="built_in">push</span>(t-&gt;lchild);</span><br><span class="line">			<span class="keyword">if</span>(t-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">				_que.<span class="built_in">push</span>(t-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="求树的深度">7.5.6 求树的深度</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">height</span><span class="params">(binaTreeNode&lt;T&gt;* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> hl=<span class="built_in">heught</span>(root-&gt;lchild);</span><br><span class="line">	<span class="type">size_t</span> hr=<span class="built_in">height</span>(root-&gt;rchild);</span><br><span class="line">	<span class="keyword">if</span>(hl&gt;hr)</span><br><span class="line">		<span class="keyword">return</span> hl++;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> hr++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="应用-2">7.6 应用</h5>
<h6 id="并查集-1">7.6.1 并查集</h6>
<p>在介绍链表时侯我们将来并查集的概念，知道<strong>在线等价类</strong>就是并查集。但是使用链表解决并查集不是最优解，这里我们介绍树来解决并查集问题。在在线等价类的问题当中，初始时有n个元素，每个元素都属于一个独立的等价类。需要执行以下的操作:</p>
<ul>
<li>①<code>conbine(a,b)</code>,把包含a,b的等价类合并为一个等价类</li>
<li>②<code>find(Element)</code>,确定元素<code>Element</code>在哪一个类，目的是对给定的两个元素，确定是否属于同一个类（同类，返回相同结果，否则不同）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">combine</span>(a,b)</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">classA=<span class="built_in">find</span>(a);</span><br><span class="line">classB=<span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span>(classA!=classB)</span><br><span class="line"><span class="built_in">unite</span>(classA,classB);</span><br></pre></td></tr></table></figure>
<p>并查集问题的求解策略：<strong>把每一个集合表示为一棵树。</strong></p>
<ul>
<li><strong>在查找时</strong>：把根元素作为集合标识符，因此find(a)返回的会是根元素。当且仅当a和b属于同一集合，<code>find(a)==find(b)</code>为真.</li>
<li><strong>在合并时</strong>：假设调用语句<code>unite(classA,classB)</code>,<code>classA</code>和<code>classB</code>分别是不同集合的根，为了把两集合合并，得让一颗树成为另一颗树的子树。<strong>合并采用重量规则：若根为i的树的结点数少于根为j的树的节点数，则将j作为i的父节点。否则，将i作为j的父节点。</strong></li>
</ul>
<p><strong>1. 重量规则使用的结构（顺序结构）</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重量规则使用的结构（顺序结构）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unionFindNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElementType data;</span><br><span class="line">	<span class="type">int</span> parent;	<span class="comment">///root为true时，表示树的重量，false时，为夫节点的指针(索引)</span></span><br><span class="line">	<span class="type">bool</span> root;</span><br><span class="line">	<span class="built_in">unionFindNode</span>()&#123;parent=<span class="number">1</span>;root=ture;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong>节点点内数字是<code>parent</code>的值,节点外的数字是该节点的索引，索引也同时是该节点所表示的元素，即中间的节点的元素值是下面一个节点的<code>parent</code>值（下面的<code>find</code>函数就说明了这一点）</p>
<p><strong>2. 构建重量规则的树（该树使用顺序结构的形式）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">int</span> numberOfElements)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//初始化numberiOfElements课树，每棵树包含一个元素</span></span><br><span class="line">	unionFindNode node=<span class="keyword">new</span> unionFindNode[unmberOfElements+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 查找</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回元素所在树的根</span></span><br><span class="line"><span class="comment">//theRoot是要返回的根，同时紧缩根到下标为index的节点路径上的节点到根的路径长度</span></span><br><span class="line">	<span class="type">int</span> theRoot=index;</span><br><span class="line">	<span class="keyword">while</span>(!node[theRoot].root)</span><br><span class="line">		theRoot=node[theRoot].parent;</span><br><span class="line">	<span class="type">int</span> currentNode=index;</span><br><span class="line">	<span class="keyword">while</span>(currentNode!=theRoot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> parentNode=node[currentNode].parent;</span><br><span class="line">		node[currentNode].parent=theRoot;</span><br><span class="line">		currentNode=parentNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> theRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 合并</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> rootA,<span class="type">int</span> rootB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node[rooaA].parent&lt;node[rootB].parent)</span><br><span class="line">	&#123;</span><br><span class="line">		node[rootB].parent+=node[rootA].parent;</span><br><span class="line">		node[rootA].root=<span class="literal">false</span>;</span><br><span class="line">		node[rootA].parent=rootB;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node[rootA].parent+=node[rootB].parent;</span><br><span class="line">		node[rootB].root=<span class="literal">false</span>;</span><br><span class="line">		node[rootB].parent=rootA;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="二叉树的右视图">7.6.2 二叉树的右视图</h6>
<h6 id="完全二叉树">7.6.3 完全二叉树</h6>
<h6 id="对称二叉树">7.6.4 对称二叉树</h6>
<h6 id="平衡二叉树">7.6.5 平衡二叉树</h6>
<h6 id="二叉树剪枝">7.6.6 二叉树剪枝</h6>
<h4 id="堆">8. 堆</h4>
<ul>
<li><strong>大根树/小根树</strong>：定义是指它的每个节点都大于/小于或等于其子节点的值。</li>
<li>大根堆/小根堆：一个大根堆/小根堆既是大根树/小根树，也是完全二叉树</li>
</ul>
<p>下图演示的堆的初始化和删除根节点的动态演示： <img src="/数据结构-C-实现/heapSort.gif" width="500"></p>
<h5 id="堆的操作">8.1 堆的操作</h5>
<h6 id="堆的插入">8.1.1 堆的插入</h6>
<p>因为<strong>堆是完全二叉树，所以当加入一个元素形时，必须维持该堆仍为完全二叉树</strong>，即该新节点位置由此定下了。接着元素插入要依据原来是大根堆还是小根堆（即不能破环该堆的性质）。把插入的元素，沿着从新节点到根节点的路径，执行一趟冒泡操作，将新元素与其夫节点的元素比较交换，直到后者大于前者（大根堆为例）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该方法通过查询当前堆的大小和元素比较定位插入点，进行大根堆完全二叉树形式插入即`/2`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> currentNode=++heapsize;</span><br><span class="line">	<span class="comment">//通过比较寻找插入点，比插入值小的元素下沉</span></span><br><span class="line">	<span class="keyword">while</span>(currentNode!=<span class="number">1</span>&amp;&amp;heap[currentNode/<span class="number">2</span>]&lt;theElement)</span><br><span class="line">	&#123;</span><br><span class="line">		heap[currentNode]=heap[currentNode/<span class="number">2</span>];</span><br><span class="line">		currentNode/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入新值</span></span><br><span class="line">	heap[currenNode]=theElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="堆的删除">8.1.2 堆的删除</h6>
<p><strong>在大根堆中删除一个元素，其实就是删除根节点的元素</strong>。此时就需要重新组织，以便保持性质不变 。其策略是，从删除的位置开始为一个树,向下找，找到该树的最后一个叶子节点，删除该节点但保存元素到临时量；然后比较删除（这个删除只是指元素替换了，而不是前面那个销毁删除）节点的左右孩子，将大的放到该根节点；这时因为大孩子的被放到根节点而成为了空(没有元素），此时我们像之前一样比较该结点的左右孩子，将大的放到该结点，以此类推……，直到最后一个叶子我们与之前中间量保存的元素比较，完成删除排序，如下图所示（小根堆）： <img src="/数据结构-C-实现/heap.png" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">templaet&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(heapsize==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	heap[<span class="number">1</span>].~<span class="built_in">T</span>();		<span class="comment">//销毁根节点元素</span></span><br><span class="line">	T lastElement=heap[heapsize];	<span class="comment">//最后一个元素保存到临时变量</span></span><br><span class="line">	heap[heapsize--].~<span class="built_in">T</span>();			<span class="comment">//销毁最后一个元素</span></span><br><span class="line">	<span class="type">int</span> currentNode=<span class="number">1</span>,child=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;heapsize)</span><br><span class="line">	&#123;	<span class="comment">//元素进行上升</span></span><br><span class="line">		<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="comment">//判断lastElement是否可以放在heap[child]上</span></span><br><span class="line">		<span class="keyword">if</span>(lastElement&gt;=heap[child])	<span class="comment">//可以就直接退出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		heap[currentNode]=heap[child];</span><br><span class="line">		currentNode=child;</span><br><span class="line">		child*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currentNode]=lastElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong><em>附：</em></strong>若是指定位置或元素删除，也是一样的方法，先遍历定位要删除的元素，将其销毁，它的消耗只会影响到它的子树，而不会向上影响，因此只需要将子树的元素比较大小然后抬升即可，方法同删除根节点是一模一样的</p>
<h6 id="堆的初始化">8.1.3 堆的初始化</h6>
<p>初始化：当堆刚开始时就要有n个元素，我们就要构建非空堆，我们需要在堆中执行n次插入操作。先将元素按层次插入，取位置在i=n/2的元素，如果以这个元素为根的子树是大根堆则不做操作，如果不是大根堆则从该节点开始的树进行检测替换，依次检查i-1,i-2……1 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(T *theHeap,std::<span class="type">size_t</span> _heapsize)</span></span>&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]heap;</span><br><span class="line">	heap =theheap;</span><br><span class="line">	heapsize=_heapsize;</span><br><span class="line">	<span class="comment">//从下往上进行堆化，即从heapsize/2开始，直到root=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> root=heapsize/<span class="number">2</span>;root&gt;=<span class="number">1</span>;root--)</span><br><span class="line">	&#123;</span><br><span class="line">		T rootElement=heap[root];</span><br><span class="line">		<span class="type">int</span> child=<span class="number">2</span>*root;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;=heapsize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span>(rootElement&gt;=heap[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			heap[child/<span class="number">2</span>]=heap[child];</span><br><span class="line">			child*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[child/<span class="number">2</span>]=rootElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉搜索树">9. 二叉搜索树</h4>
<p>主要有二叉搜索树和索引二叉搜索树。二叉搜索树的查找、插入和删除操作的所需平均时间为O(log2n),最坏的情况为O(n)。对于给定一个关键字，使用二叉搜索树，可以在O(n)时间内，找到最接近它的关键字。二叉搜索树是一颗二叉树，可能为空，一颗非空的二叉搜索树满足以下特点：</p>
<ul>
<li>每个元素有一个关键字，并且任意两个元素的关键字都不同（有重复值的二叉搜索树除外），<strong>因此所有的关键字都是唯一的</strong></li>
<li><strong>在根节点的左子树中，元素的关键字(如果有的话）都小于根节点关键字</strong></li>
<li><strong>在根节点的右子树中，元素的关键字都大于根节点的关键字</strong></li>
<li>根节点的左右子树也都是二叉树</li>
</ul>
<h5 id="实现-5">9.1 实现</h5>
<h6 id="搜索">9.1.1 搜索</h6>
<p>要查找关键字为<code>theKey</code>的元素，先从根查找，如果根为空，则搜索树为空的；若不为空，则将<code>theKey</code>与根关键字比较大小，由二叉树搜索树的性质知，比根的大，则向右子数查找，若小，则向左子树查找，依次类推，直到找到或者到<code>NULL</code>为止。如下图查找<code>5</code> <img src="/数据结构-C-实现/search.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">pair&lt;<span class="type">const</span> K,E&gt;*binarySearchTree&lt;K,E&gt;::<span class="built_in">find</span>(<span class="type">const</span> K&amp; theKey,</span><br><span class="line">	binaryTreeNode&lt;<span class="type">const</span>  K,E&gt;*p)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(theKey&lt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(theKey&lt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;rightChild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> &amp;p-&gt;element;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="插入">9.1.2 插入</h6>
<p>重复的关键字进行值更新，从根节点开始比较，直到遇到相同的关键或<code>NULL</code> <img src="/数据结构-C-实现/insert.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="type">void</span> binarySearchTree&lt;K,E&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;<span class="type">const</span> K,E&gt;&amp;</span><br><span class="line">thePair,binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt; *p)</span><br><span class="line">&#123;</span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt; *pp=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pp=p;</span><br><span class="line">		<span class="keyword">if</span>(thePair.first&lt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(thePair.first&gt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;rightChild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;element.second=thePair.second;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt; *newNode</span><br><span class="line">		=<span class="keyword">new</span> binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;(thePair);</span><br><span class="line">	<span class="keyword">if</span>(rootNode==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode=newNode;</span><br><span class="line">		rootNode-&gt;leftChild=rootNode-&gt;rightChild=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(pp-&gt;element.first&lt;thePair.first)</span><br><span class="line">		pp-&gt;rightChild=newNode;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		pp-&gt;leftChild=newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	stSize++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从上面的程序来看，二叉搜索树如果不添平衡操作容易退化成单链表，那么这是就会造成结构的失效，下一节我们会介绍一个平衡的办法。</p>
<h6 id="删除">9.1.3 删除</h6>
<p>假设要删除接节点<code>p</code>，我们要考虑三种情况：<strong>①<code>p</code>是叶子；②<code>p</code>只有一颗非空子树；③<code>p</code>有两颗非空子树</strong></p>
<ul>
<li>第一种情况非常好做，只有释放叶子节点的空间即可，若是根节点，置为<code>NULL</code> <img src="/数据结构-C-实现/one.gif" width="500"></li>
<li>第二种情况也较为简单 ，如果<code>p</code>是根节点，则<code>p</code>的唯一子树的根节点成为新的搜索树的根节点。若<code>p</code>有父节点<code>pp</code>，则修改<code>pp</code>的指针域，使它指向<code>p</code>的唯一孩子，然后释放节点<code>p</code> <img src="/数据结构-C-实现/two.gif" width="500"></li>
<li>第三种情况较复杂，我们先将该节点的元素替换为它左子树的最大元素（或者右子树的最小的一个元素）。然后把替换的节点删除，该删除的结点如果有左子树，则该左子树变为该结点的双亲的右子树（或者删除的结点如果有右子树，则该右子树变为该结点的双亲的左子树） <img src="/数据结构-C-实现/three.gif" width="500"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="type">void</span> binarySearchTree&lt;K,E&gt;::<span class="built_in">erase</span>(<span class="type">const</span> K&amp; theKey)</span><br><span class="line">&#123;</span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;* p=rootNode,*pp=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p.element.first!=theKey)</span><br><span class="line">	&#123;											<span class="comment">//定位关键值相等的节点</span></span><br><span class="line">		pp=p;</span><br><span class="line">		<span class="keyword">if</span>(p.element.first&lt;theKey)<span class="number">8</span> </span><br><span class="line">		p=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		p=p-&gt;rightChild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)	<span class="comment">//不存在</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;leftChild!=<span class="literal">NULL</span>&amp;&amp;p-&gt;rightChild!=<span class="literal">NULL</span>)		<span class="comment">//第三种情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;* theMaxNode=p-&gt;leftNode,*s=p;</span><br><span class="line">		<span class="keyword">while</span>(theMaxNode-&gt;rightChild!=<span class="literal">NULL</span>)	<span class="comment">//寻找左子树最大值进行替换</span></span><br><span class="line">		&#123;</span><br><span class="line">			s=theMaxNode;</span><br><span class="line">			theMaxNode=theMaxNode-&gt;rightChild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//p-&gt;element=theMaxNode-&gt;element;  无法这样移动，因为key是常量</span></span><br><span class="line">		binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;* q=<span class="keyword">new</span> binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;</span><br><span class="line">			(theMaxNode-&gt;element,p-&gt;leftChild,p-&gt;rightChild);		<span class="comment">//这样移动合法</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pp==<span class="literal">NULL</span>)		<span class="comment">//即删除的是根节点的情况</span></span><br><span class="line">			rootNode=q;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p==pp-&gt;leftNode)		<span class="comment">//不是根节点，判断p是pp的左树还是右树</span></span><br><span class="line">			pp-&gt;leftChild=q;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pp-&gt;rightChild=q;</span><br><span class="line">		<span class="keyword">if</span>(s==p) q-&gt;leftChild=theMaxNode-&gt;leftChild;</span><br><span class="line">			<span class="keyword">delete</span> p;</span><br><span class="line">		p=s						<span class="comment">//为简化下面判断if(p-&gt;leftChild!=NULL)语句</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;*c;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;leftChild!=<span class="literal">NULL</span>)</span><br><span class="line">		c=p-&gt;leftChild;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		c=p-&gt;rightChild;</span><br><span class="line">	<span class="comment">//删除p</span></span><br><span class="line">	<span class="keyword">if</span>(p==rootNode)</span><br><span class="line">		rootNode=c;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p==pp-&gt;leftChild)</span><br><span class="line">			pp-&gt;leftChild=c;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pp-&gt;rightChild=c;</span><br><span class="line">	&#125;</span><br><span class="line">	stSize--;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="平衡二叉搜索树avl">10. 平衡二叉搜索树AVL</h4>
<p>如果搜索树的高度总是<code>O(logn)</code>，我们能保证查找、插入、删除的时间为<code>O(logn)</code>。最坏情况下的高度为O(logn)的树为<strong>平衡树（balanced tree)</strong>。<strong>但是正如上面搜索树所讲的，在大量的插入后搜索树极其容易不平衡导致元素大量在一个分支上，退化成链表，这时候查找、插入、删除的时间复杂的就不为<code>O(logn)</code></strong>。平衡二叉搜索树就是为解决这个问题而得出的数据结构。</p>
<h5 id="平衡二叉搜索树的定义">10.1 平衡二叉搜索树的定义</h5>
<p>一颗空的二叉树是AVL树；如果T是一颗非空的二叉树，<code>T1</code>和<code>T2</code>分别是其左子树和右子数，那么当<code>T</code>满足以下条件时，<code>T</code>是一颗AVL树：</p>
<ul>
<li>①<code>T1</code>和<code>T2</code>是AVL树；</li>
<li>②<code>|hl-hr|≤1</code>，其中<code>hl</code>和<code>hr</code>分别是<code>Tl</code>和<code>TR</code>的高。</li>
</ul>
<p>一颗AVL搜索树既是二叉搜索树，也是AVL树。如果用AVL搜索树来描述字典，并在对数级时间内完成每一种字典操作，那么，我们必须确定AVL树的下列特征：</p>
<ul>
<li><strong>一颗<code>n</code>个元素的AVL树，其高度是<code>O(logn)</code></strong></li>
<li>对于每一个<code>n.n≥0</code>，都存在一颗AVL树</li>
<li>对一颗<code>n</code>元素的AVL搜索树，在<code>O(高度)=O(logn)</code>的时间内可以实现查找</li>
<li><strong>将一个新元素插入一颗<code>n</code>元素AVL搜索树种，可以得到一颗<code>n+1</code>元素的AVL树，且插入用时为<code>O(logn)</code></strong></li>
<li><strong>一个元素从一颗<code>n</code>元素的AVL搜索树删除，可以得到一颗<code>n-1</code>的AVL搜索树，而且用时为<code>O(logn)</code></strong></li>
</ul>
<p><strong>AVL树的描述：</strong>AVL树一般用链表进行描述，为简化插入和删除操作，我们为每一个节点添加一个平衡因子<code>bf</code>，假设x的左子树高度为<code>hl</code>,右子树高度为<code>hr</code>，节点<code>x</code>的平衡因子<code>bf(x)</code>定义为：</p>
<ul>
<li><code>bf(x)=hl-hr</code></li>
<li><code>bf(x)</code>取值只能为<code>0，-1，1</code></li>
</ul>
<p><img src="/数据结构-C-实现/balanceTree.png" width="500"></p>
<p>这里主要讲解平衡二叉搜索树的搜索、插入和删除操作。</p>
<h5 id="搜索-1">10.2 搜索</h5>
<p>同二叉搜索树一样的操作，<code>n</code>元素的AVL树的高度是<code>O(logn)</code>，所以搜索时间为<code>O(logn)</code>。要查找关键字为theKey的元素，先从根查找，如果根为空，则搜索树为空的；若不为空，则将theKey与根关键字比较大小，由二叉树搜索树的性质知，比根的大，则向右子数查找，若小，则向左子树查找，依次类推，直到找到或者到<code>NULL</code>为止。如下图查找<code>5</code>。实现略</p>
<h5 id="插入操作">10.3 插入操作</h5>
<p>AVL树因为要保证每个结点的平衡因子要时时刻刻都符合要求，则树中每插入一个结点，都可能引起平衡被打破，所以每次插入一个结点，<strong>都要从插入的结点往上进行检查是否有哪个结点需要调整。要在插入新结点后进行平衡检查，则需要把插入结点的插入过程的下行路线上的每一个结点都依次记录下来，这个可以借助于栈来实现，在查找插入位置的过程，把每一个结点指针放入栈中</strong>．</p>
<h6 id="插入的具体步骤">10.3.1 插入的具体步骤</h6>
<ul>
<li><strong>第一步：</strong>从根结点开始，首先查找要插入的位置。如果结点值相等则更新，如果小于则向左走，如果大于则向右走，把这个过程中的每一个结点都放入一个栈中，这样直到到达叶子结点，即找到了插入的位置．然后<code>new</code>出来一个结点进行插入</li>
<li><strong>第二部</strong>：插入完成以后进行平衡调整。取出栈中的元素进行检查：插入的结点对于取出的结点如果是左边插入，则平衡因子<code>+１</code>，如果右边插入则平衡因子<code>-１</code>．</li>
<li><strong>第三步1</strong>：如果加减<code>１</code>以后平衡因子是<code>０</code>，即意味着插入节点之前平衡因子只能是<code>±１</code>，插入该节点以后，该子树的左右子树高度相等，因此并不改变该子树的高度，也就并不影响整棵树的高度，所以树是平衡的，不需要<strong>第三步2</strong>：调整，调整结束<code>break</code> ；</li>
<li><p>如果插入后平衡因子是<code>+1</code>或者<code>-1</code>，则意味着该节点所在的子树的高度发生变化（因为在此之前该节点的平衡因子只能是０），所以以该节点为root的子树的高度一定是增加了，所以要向上继续检查是否有哪个节点的平衡因子因为插入了一个节点平衡因子变为<code>±２</code>，所以继续取出stack中的下一个节点进行上述同样的检查</p></li>
<li><strong>第四步</strong>：如果平衡因子是正负２，则平衡打破，需要进行调整，下面详述调整过程：
<ul>
<li>１．<code>bf=-2</code>: 如果该节点的孩子节点平衡因子是负值：则对该节点进行一次左旋转即调整完成；如该该节点的孩子节点的平衡因子是正值：则需要进行先左后右旋转．</li>
<li>２．<code>bf=+2:</code>如果该孩子节点<code>bf</code>是正值：则对该节点进行一次右旋转即可；如果孩子节点<code>bf</code>是负值：则对该节点进行先右后左旋转即可．</li>
</ul></li>
</ul>
<p>调整平衡完成以后需要将该子树的新根节点挂到之前的根节点下面．以上即整个插入过程．</p>
<h6 id="失衡的情况">10.3.2 失衡的情况</h6>
<p>如果按二叉搜索树的插入算法会影响AVL树将不在是AVL树。如下图按二叉搜索树的方式将32插入VAL搜索树而导致失衡 <img src="/数据结构-C-实现/compare.png" width="500"> 因此，插入操作必须维护各节点的<code>|bf|≤1</code>。<strong>插入破环原AVL搜索二叉树结构是以下情形：</strong></p>
<ul>
<li>在不平衡树中，平衡因子的值限于<code>2，1，0，-1，-2</code></li>
<li>平衡因子为<code>2</code>的节点插入前平衡因子为<code>1</code>，同样<code>-2</code>的插入前为<code>-1</code></li>
<li><strong>只有从根到新插入节点路径上的节点，其平衡因子在插入后会改变</strong></li>
<li><strong>假设<code>A</code>是离新插入节点最近的</strong>祖先<strong>，且平衡因子是<code>-2</code>或<code>2</code>（在上面的图中A是关键字为40的节点），在插入前，从<code>A</code>到新插入节点的路径上，所有节点的平衡因子都是0</strong></li>
</ul>
<p>对于平衡与失衡的判断存在与否，主要就是看<code>A</code>这一节点存不存在，即平衡因子变为<code>2</code>或<code>-2</code>的最近祖先节点存在与否：</p>
<p><strong><code>A</code>节点不存在</strong>：那么从根节点至新插入节点的途中，所有节点在插入前的平衡因子都为<code>0</code>或者为-1但插入左则或者为1但插入右侧，由于插入操作平衡因子增减0或1，所以从根节点到插入新节点的途径的节点平衡因子可能改变，但树的平衡不会改变。 <img src="/数据结构-C-实现/Aisnot.png" width="500"></p>
<h6 id="失衡的种类">10.3.3 失衡的种类</h6>
<p><strong><code>A</code>节点存在</strong>：就出现平衡因子<code>|bf|=2</code>的情况，破坏了平衡，此时就需要进行平衡操作。其不平衡的情况有两类</p>
<ul>
<li><code>L</code>型不平衡,新插入的节点在A的左子树中</li>
<li><code>R</code>型不平衡,新插入的节点在A的右子树中</li>
</ul>
<p>同时，从根到新插入节点的路径上，根据A的孙节点情况，还可在细分（包含新节点的A的子树高度至少为2，因为有定义知A的平衡因子为2或-2,A才存在孙节点），此时细分为<code>LL,LR,RL,RR</code>。 <img src="/数据结构-C-实现/four.png" width="500"></p>
<ul>
<li><ol type="1">
<li><code>6</code>节点的左子树<code>3</code>节点高度比右子树<code>7</code>节点<strong>大<code>2</code></strong>，左子树<code>3</code>节点的左子树<code>1</code>节点高度<strong>大于</strong>右子树<code>4</code>节点，这种情况成为左左<code>LL</code>(左孩子的左子树深度大)。</li>
</ol></li>
<li><ol start="2" type="1">
<li><code>6</code>节点的左子树<code>2</code>节点高度比右子树<code>7</code>节点<strong>大<code>2</code></strong>，左子树<code>2</code>节点的左子树<code>1</code>节点高度<strong>小于</strong>右子树<code>4</code>节点，这种情况成为左右<code>LR</code>。</li>
</ol></li>
<li><ol start="3" type="1">
<li><code>2</code>节点的左子树<code>1</code>节点高度比右子树<code>5</code>节点<strong>小<code>2</code></strong>，右子树<code>5</code>节点的左子树<code>3</code>节点高度<strong>大于</strong>右子树<code>6</code>节点，这种情况成为右左<code>RL</code>。</li>
</ol></li>
<li><ol start="4" type="1">
<li><code>2</code>节点的左子树<code>1</code>节点高度比右子树<code>4</code>节点<strong>小<code>2</code></strong>，右子树<code>4</code>节点的左子树<code>3</code>节点高度<strong>小于</strong>右子树<code>6</code>节点，这种情况成为右右<code>RR</code>。</li>
</ol></li>
</ul>
<h6 id="ll型平衡操作">10.3.4 LL型平衡操作</h6>
<p><strong>右旋：</strong>在最小平衡子树根节点平衡因子&gt;=2且在根节点的左孩子的左孩子插入元素即<code>LL</code>，要进行右旋 <img src="/数据结构-C-实现/rightxuan.gif" width="500"> 右旋如上所示，绕<code>|bf|=2</code>的节点（以下统称为<code>root</code>）进行旋转，根节点的左孩子成为新的根节点，而原来的<code>root</code>成为其右孩子，同时若新的根节点原来的右子树成为<code>root</code>的左子树,如下 <img src="/数据结构-C-实现/rightxuan.png" width="500"></p>
<h6 id="rr型平衡操作">10.3.5 RR型平衡操作</h6>
<p>在最小平衡子树根节点<code>bf&gt;=-2</code>且在根节点的右孩子的右孩子插入元素，进行<strong>左旋。</strong> <img src="/数据结构-C-实现/leftxuan.gif" width="500"> 其动作与<code>LL</code>一样，只不过方向相反。</p>
<h6 id="lr型平衡操作">10.3.6 LR型平衡操作</h6>
<p>在最小平衡子树根节点<code>80</code>的左孩子<code>50</code>的右孩子<code>70</code>的子节点插入新元素，先绕根节点的左孩子节点<code>50</code>右旋，再围根节点<code>80</code>左旋 <img src="/数据结构-C-实现/lr.png" width="600"></p>
<h6 id="rl型平衡操作">10.3.7 RL型平衡操作</h6>
<p>最小平衡子树根节点<code>80</code>的右孩子<code>100</code>的左孩子<code>90</code>的子节点<code>95</code>插入新元素，先绕根节点的右孩子节点<code>100</code>右旋，再围根节点<code>80</code>左旋 <img src="/数据结构-C-实现/rl.png" width="600"> 其动态展示如下： <img src="/数据结构-C-实现/rl.gif" width="500"></p>
<h5 id="删除操作">10.4 删除操作</h5>
<h6 id="删除节点">10.4.1 删除节点</h6>
<p>执行二叉搜索树得删除操作，AVL树删除节点，首先查找要删除的节点，找到以后，要删除的节点分为两种情况：</p>
<ul>
<li>１.要删除的节点左右两个孩子都存在，直接删除不方便，则在右子树中查找最小的节点，将其值替换为要删除的节点的值，因为右子树的最小节点必然没有左孩子，即只有一个孩子．然后问题转化为删除这个右子树中最小的节点．（或者也可以将问题转化为删除左子树里最大的节点）</li>
<li>２.要删除的孩子节点只有一个孩子节点，则直接将仅有的一个孩子节点提上来即可．</li>
</ul>
<h6 id="平衡性检查">10.4.2 平衡性检查</h6>
<p>删除以后将进行从删除节点向上进行平衡性的检查。<strong>在查找要删除的节点的过程中，将经过的路径上的节点位置全部存放到一个<code>stack</code></strong>。在平衡型检查过程种取出栈顶元素<code>pr</code>并弹出栈顶元素，如果删除的节点<code>pr</code>的<code>key</code>值比该节点的<code>key</code>值小,则必定是左树删除则<code>pr-&gt;bf-1</code>了，否则<code>pr-&gt;bf+1</code>。会造成以下三种情况：</p>
<ul>
<li>１．删除后如果<code>|pr-&gt;bf|=1</code>：则在删除节点之前<code>pr-&gt;bf０</code>，即左右平衡，<strong>删除了以后左树或者右树少了一个节点，但<code>pr</code>这个子树的高度并没发生变化．对与pr的上面的所有节点而言树高并没有发生变化，所以调整完成．</strong></li>
<li>２．如果删除后|pr-&gt;bf|=０<code>,则在删除之前平衡因子是</code>±１<code>，现在删除节点以后变为</code>０<code>，则</code>pr<code>子树的高度减</code>１`（发生了变化，影响到了上面的节点），则要向上（出栈）继续检查，</li>
<li>３．如果删除后造成<code>|pr-&gt;bf|==２</code>,则平衡打破，进行平衡调整.</li>
</ul>
<h4 id="红黑树">11. 红黑树</h4>
<p>平衡索引二叉树是高度平衡的二叉树，频繁的插入和删除，会引起频繁的<code>rebalance</code>,导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转的数据结构，所以红黑树在查找，插入删除的性能都是接近<code>O(logn)</code>,且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RB树的节点结构:</span><br><span class="line"><span class="comment">//由于红黑树的各种操作常需要上溯其父级节点，因此特别安排一个parent指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> _rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> _rb_tree_color_type _rb_tree_red=<span class="literal">false</span>;	<span class="comment">//红色为0</span></span><br><span class="line"><span class="type">const</span> _rb_tree_color_type _rb_tree_black=<span class="literal">true</span>;	<span class="comment">//黑色为1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_color_type	 color_type;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node_base*	 base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span>				 value_type;</span><br><span class="line">	</span><br><span class="line">	color_type color;		<span class="comment">//结点颜色</span></span><br><span class="line">	base_ptr parent;		<span class="comment">//父节点指针</span></span><br><span class="line">	base_ptr left;</span><br><span class="line">	base_ptr right;</span><br><span class="line">	value_type value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="红黑树特点">11.1 红黑树特点</h5>
<p><strong>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍</strong>，因此，红黑树是一种<strong>弱平衡二叉树</strong>，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。红黑树具有以下的性质：</p>
<ul>
<li>每个节点非红即黑</li>
<li><strong><code>RB1</code>：根节点是黑的;</strong></li>
<li><strong><code>RB1</code>：每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</strong></li>
<li><strong><code>RB2</code>：</strong>如果一个节点是红色的，则它的子节点必须是黑色的，即红节点不能连续**</li>
<li><strong><code>RB3</code>：</strong>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</li>
</ul>
<p><strong>一个节点的阶</strong>是指从该节点到一外部节点路径上黑色指针的数量，定理：</p>
<ul>
<li>设根到外部节点的路径长度length是该路径上的指针数量。如果P和Q是红-黑树中的两条从根至外部节点的路径，那么<code>length(P)≤2length(Q)</code></li>
<li>令<code>h</code>是一颗红-黑树的高度（不包括外部节点），<code>n</code>是树的内部节点数量，而<code>r</code>是根节点的阶，则有:
<ul>
<li>①<code>h≤2r</code></li>
<li>②<code>n≥2^r-1</code></li>
<li>③<code>h≤2log2(n+1)</code></li>
</ul></li>
</ul>
<h5 id="红黑树操作">11.2 红黑树操作</h5>
<ul>
<li><strong>搜索：</strong>使用普通的二叉搜索树的搜索代码。对红黑树来说，时间复杂度为<code>O(logn)</code>。比较而言，二叉搜索树、AVL、红黑树搜索都使用相同代码，而且在最坏的情况下AVL树的高度是最小的，所以在搜索为主的应用中，avl是最优的。</li>
<li><strong>插入：</strong>红黑树的插入使用的是普通二叉搜索树插入算法，对插入的元素，需要上色。如果插入前树是空的，那么新节点是根节点，颜色应是黑色。</li>
</ul>
<p><strong>对红黑树的插入删除要维护其原本的性质：</strong>假设插入前的树是非空的，如果新节点的颜色是黑色，那么从根到外部节点路径上，将有一个特殊的黑色节点作为新节点的孩子。如果新节点是红色，那么可能出现两个连续的红色节点。所以把新节点赋为黑色肯定不符合<code>RB3</code>，而把新节点赋为红色虽然一定符合<code>RB3</code>,但可能违反了<code>RB2</code>。对红黑树的插入删除要维护其原本的性质。</p>
<h6 id="赋为红色而造成的不平衡类型">11.2.1 赋为红色而造成的不平衡类型</h6>
<p>如果是新节点赋为红色而造成<code>RB2</code>规则被破坏，我们就说树的平衡杯破坏了。<strong>此时平衡破坏则必有有两连续红色节点，一个是新节点<code>u</code>,一个是其父结点<code>pu</code>。而此时祖父节点<code>gu</code>一定是黑色的</strong>。有以下情况</p>
<ul>
<li>当<code>pu</code>是<code>gu</code>的左孩子，<code>u</code>也是<code>pu</code>的左孩子时且<code>gu</code>的另一个孩子（右孩子）是黑色的（为外部节点），该不平衡类型为<code>LLb</code>类型。</li>
<li>当<code>pu</code>是<code>gu</code>的左孩子，<code>u</code>是<code>pu</code>的左孩子时且<code>gu</code>的另一个孩子（右孩子）是红色的（不是外部节点），该不平衡类型为<code>LLr</code>类型。</li>
</ul>
<p>依次类推出<code>LRb、LRr、RRb、RRr、RLb、RLr</code></p>
<p><strong>平衡方法；</strong></p>
<ul>
<li><p><code>XYr</code>型的不平衡<strong>可以通过改变颜色来处理</strong>：将<code>pu</code>节点变为黑色，对于LLr和LRr的<code>gu</code>的右孩子要由红色变为黑色，另外如果gu不是根则改为红色，如果是根节点则保持gu为黑色不变；<strong>因为<code>gu</code>由黑变红的情况可能导致上一层平衡破坏，如果破坏了（即原<code>gu</code>与<code>gu</code>父结点都为红）此时将<code>gu</code>变为<code>u</code>,<code>gu</code>父结点变为<code>pu</code>,<code>gu</code>祖父节点为<code>gu</code>,分析是<code>XYr</code>类型还是<code>XYb</code>类型，继续恢复平衡操作。</strong> <img src="/数据结构-C-实现/blackRed.png" width="600"></p></li>
<li><p>XYb型则需要旋转。插入后依次旋转足以保持平衡。<strong>该旋转的改变同AVL相似</strong> <img src="/数据结构-C-实现/brxuan.png" width="600"></p></li>
</ul>
<p><strong><em>附：</em></strong>对于删除操作，首先使用二叉搜索树的删除算法。然后进行颜色变动，需要的话还要进行一次旋转。 - 删除红色节点，不会影响规则，只需将相应的需要变色的指针变色即可。 - 删除黑色节点，会影响RB3（不是根节点时）。使用该删除算法，不会违反除RB3外的其它红黑树规则。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cy973071263/article/details/122543826">红黑树详解</a></p>
<h4 id="图">12. 图</h4>
<p><strong>图是一个用线或边连接在一起的节点(顶点）的集合。严格地说图是有限集<code>V</code>和<code>E</code>的有序对<code>G=(V,E)</code>。<code>V</code>中的元素为顶点，<code>E</code>为边。</strong>对于图我们需要先了解以下预备知识：</p>
<ul>
<li>图的术语：顶点、边、邻接、关联、度、回路、路径、连通构件、<strong>生成树</strong></li>
<li>图的类型：无向图、有向图和加权图</li>
<li>常用描述方法：邻接矩阵、<strong>矩阵邻接表和邻接链表</strong></li>
<li><strong>图的标准搜索方法：广度优先搜索和深度优先搜索</strong></li>
<li>图的算法：寻找图的路径、寻找无向图的联通构件、<strong>寻找连通无向图的生成树</strong></li>
</ul>
<h5 id="图的基本概念">12.1 图的基本概念</h5>
<ul>
<li>每一条边连接两个顶定，用元组<code>(i,j)</code>表示，<code>i\j</code>表示连接的顶点。带方向的叫有向边，不带方向叫无向边。</li>
<li>当且仅当<code>(i,j)</code>是图的边，称顶定<code>i</code>和<code>j</code>是<strong>邻接</strong>的。边<code>(i,j)</code>关联</li>
<li>如果图的所以边都是无向的，则称图为无向图；都是有向的为有向图</li>
<li>一个图不能有重复的边，即任意两个顶点，在无向图只有一条边，有向图是<code>i</code>到<code>j</code>即<code>(i,j)</code>,<code>j</code>到<code>i</code>即<code>(j,i)</code>各一条</li>
<li>为每条边赋予值，成为权。此时成为加权有向图和加权无向图</li>
<li>简单路径：除最后一个和第一个顶点之外，其余所有顶点都要求不同（如521，525）</li>
<li><strong>环路：一条始点和终点相同的简单路径</strong></li>
<li><strong>连通：图的每一对顶点之间都有一条路径</strong></li>
<li><strong>生成树：没有环路的连通无向图是一颗树。一个G的子图，包含G的所有顶点，且为一棵树，则称为G的生成树</strong></li>
<li>二分图：顶点被分为两个子集A，每条边都有一个顶点在A，另一个在B</li>
<li><strong>度：一个顶点相关联的边数</strong></li>
</ul>
<h5 id="无权图的描述">12.2 无权图的描述</h5>
<p>无向图最常用的描述方法都是基于邻接的方式，如<strong>邻接矩阵、邻接链表和邻接数组</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">graph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">graph</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">numberOfVertices</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;	<span class="comment">//顶点数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">numberofEdge</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;		<span class="comment">//边数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">exitsEdge</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span>)</span><span class="type">const</span></span>=<span class="number">0</span>;	<span class="comment">//判断两顶点是否关联</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">insertEdg</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>=<span class="number">0</span>;			<span class="comment">//添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eraseEdge</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>=<span class="number">0</span>;			<span class="comment">//删除边</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">degree</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>=<span class="number">0</span>;			<span class="comment">//指定顶点的度</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">inDegree</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> </span>=<span class="number">0</span>;			<span class="comment">//入度</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">outDegree</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>=<span class="number">0</span>;			<span class="comment">//出度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/数据结构-C-实现/graph.png" width="200"></p>
<h6 id="邻接矩阵">12.2.1 邻接矩阵</h6>
<p>一个<code>n</code>顶点图<code>G=(V,E)</code>的邻接矩阵是一个<code>n*n</code>矩阵，其中每个元素是<code>0</code>或<code>1</code>（对角线上的元素都为0，因为没有自连边）。将矩阵映射到一个<code>n*n</code>布尔型二维数组进行存储。因为无向图的邻接矩阵是对称的即<code>A(i,j)=A(j,i)</code>，所以只需存储上三角或下三角元素。因为采用布尔类型1字节，所以共用了<code>n^2</code>字节。</p>
<ul>
<li><strong>优势：</strong>因为无向图的邻接矩阵是对称的即<code>A(i,j)=A(j,i)</code>，所以只需存储上三角或下三角元素。无向图的度为所在行（或列）的元素和。同时对于有向图，出度为该行的元素和，入度为该列的元素和</li>
<li><strong>缺点：</strong>内存空间浪费</li>
</ul>
<h6 id="邻接链表">12.2.2 邻接链表</h6>
<p><strong>一个顶点<code>i</code>的邻接表是一个线性表，它包含了所有邻接i的顶点。在一个图的邻接表中，图的每一个顶点都有一个邻接表。当邻接表用链表表示时，就是邻接链表</strong>。 我们可使用类型为链表的数组<code>aList</code>来描述所有邻接表（指针数组）。<code>aList[i]-&gt;next</code>指向顶点<code>i</code>的邻接表的第一个顶点的数组下标索引<code>index</code>，通过访问<code>aList[index]</code>得到该点的邻接表，<code>(i,index)</code>是图的一条边。。 <img src="/数据结构-C-实现/linList.png" width="500"></p>
<p>一个指针和一个整数需要4字节的存储空间，顶点需要<code>8(n+1)</code>(为了数组下标对应，不使用下标0的空间，所以<code>n+1</code>)字节存储<code>n+1</code>个<code>next</code>指针和<code>index</code>域。</p>
<h6 id="邻接数组">12.2.3 邻接数组</h6>
<p>在邻接数组中同邻接链表相似，只不过每一个邻接表用一个<strong>数组线性表如vector</strong>而非链表来描述。</p>
<h5 id="链表类的实现">12.3 链表类的实现</h5>
<p>下面的程序给出了邻接链表的的数据成员和一些实现方法，仅供参考，构造函数的时间复杂度为<code>O(n)</code>，方法<code>existsEdgr(i,j)</code>的时间复杂度为<code>O(d^out)</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">linkedDigraph</span>:<span class="keyword">public</span> graph&lt;<span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> n;		<span class="comment">//顶点数</span></span><br><span class="line">	<span class="type">int</span> e;		<span class="comment">//边数</span></span><br><span class="line">	vector&lt;List&gt; vlist;	<span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">linkedDigraph</span>(<span class="type">int</span> numberOfv=<span class="number">0</span>)</span><br><span class="line">	&#123;	<span class="comment">//构造函数</span></span><br><span class="line">		<span class="keyword">if</span>(numberOfv&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">illegalParameterValue</span>(<span class="string">&quot;Number of vertices must be &gt;=0)</span></span><br><span class="line"><span class="string">		n=numberOfv;</span></span><br><span class="line"><span class="string">		e=0;</span></span><br><span class="line"><span class="string">		aList=new graphChain&lt;int&gt;[n+1];</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//析构函数</span></span><br><span class="line"><span class="string">	~linkedDigraph()&#123;delete[] aList;&#125;</span></span><br><span class="line"><span class="string">	//边是否存在</span></span><br><span class="line"><span class="string">	bool existsEdge(int i,int j)const</span></span><br><span class="line"><span class="string">	&#123;//当且仅当(i,j)时返回treu</span></span><br><span class="line"><span class="string">		if(i&lt;1||j&lt;1||i&gt;n||j&gt;n||vList[i].indexOf(j)==-1)</span></span><br><span class="line"><span class="string">			return false;</span></span><br><span class="line"><span class="string">		else</span></span><br><span class="line"><span class="string">			return true;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//插入边</span></span><br><span class="line"><span class="string">	void insertEdge(int i，int j)</span></span><br><span class="line"><span class="string">	&#123;</span></span><br><span class="line"><span class="string">		if(aLsit[i].indexOf(j)==-1)</span></span><br><span class="line"><span class="string">		&#123;</span></span><br><span class="line"><span class="string">			//新边</span></span><br><span class="line"><span class="string">			aList[i].Insert(j);</span></span><br><span class="line"><span class="string">			aList[j].Insert(i);</span></span><br><span class="line"><span class="string">			e++;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;；</span></span><br></pre></td></tr></table></figure></p>
<h5 id="图的遍历">12.4 图的遍历</h5>
<p>图的遍历有<strong>广度优先搜索(BFS)</strong>和<strong>深度优先搜索(DFS)</strong>两种</p>
<h6 id="广度优先搜索bfs">12.4.1 广度优先搜索(BFS)</h6>
<p>广度优先搜索(BFS),从一个顶点开始，搜索该顶点所有可到达顶点的，新顶点再重复搜索可到达的顶点的方法(已到达的标记为已达，避免重复到达记录，因为顶点是<code>1~n</code>,可使用<code>record[u]=0</code>(未到达)/<code>lable</code>(已到达),<code>u</code>为<code>1~n</code>）。<strong>这种搜索性质可使用队列实现</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">arrayQueue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	reach[v]=label;</span><br><span class="line">	q.<span class="built_in">push</span>(v);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> w=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vertexIterator&lt;T&gt;*iw=<span class="built_in">iterator</span>(w);</span><br><span class="line">		<span class="type">int</span> u;</span><br><span class="line">		<span class="keyword">while</span>((u=iw-&gt;<span class="built_in">next</span>())!=<span class="number">0</span>)	<span class="comment">//u的相邻点，无则返回0</span></span><br><span class="line">			<span class="keyword">if</span>(reach[u]==<span class="number">0</span>)		<span class="comment">//相邻点是没有到达过的</span></span><br><span class="line">			&#123;</span><br><span class="line">				q.<span class="built_in">push</span>(u);</span><br><span class="line">				reach[u]=label;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">delete</span> iw;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="深度优先搜索dfs">12.4.2 深度优先搜索(DFS)</h6>
<p>深度优先搜索(DFS).从一个顶点<code>v</code>出发，首先将v标记为已到达，后选择一个邻接于<code>v</code>的尚未到达的顶点<code>u</code>。<code>u</code>再重复上述操作，直到新<code>u</code>不存在，即无法找到<code>u</code>。---&gt;<strong>一次搜一个/递归/或栈来实现</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	graph&lt;T&gt;::reach=reach;</span><br><span class="line">	graph&lt;T&gt;::label=label;</span><br><span class="line">	<span class="built_in">rDfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rDfs</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//递归</span></span><br><span class="line">	<span class="built_in">reach</span>(v)=label;</span><br><span class="line">	vertexIterator&lt;T&gt;*iv=<span class="built_in">iterator</span>(v);</span><br><span class="line">	<span class="type">int</span> u;</span><br><span class="line">	<span class="keyword">while</span>((u=iv-&gt;<span class="built_in">next</span>())!=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span>(reach[u]==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">rDfs</span>(u);</span><br><span class="line">	<span class="keyword">delete</span> iv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="图的应用">12.5 图的应用</h5>
<h6 id="最短路径">12.5.1 最短路径</h6>
<p>主要讨论带权有向图，将路径上的第一个顶点称为源点，最后一个顶点为终点。</p>
<p><strong>1. 迪杰斯特拉算法</strong></p>
<p><strong>迪杰斯特拉算法是求从某个源点到其余各顶点的最短路径</strong>的算法。该算法思想是<strong>按路径长度递增的次序产生一个最短路径</strong>。描述要借助两个集合<code>S、U</code></p>
<ul>
<li><ol type="1">
<li>初始时，<code>S</code>只包含起点<code>s</code>；<code>U</code>包含除<code>s</code>外的其他顶点，且<code>U</code>中顶点的距离为<strong>起点s到该顶点的距离</strong>(例如，<code>U</code>中顶点<code>v</code>的距离为<code>(s,v)</code>的长度，如果<code>s</code>和<code>v</code>不相邻，则<code>v</code>的距离为<code>∞</code>]。</li>
</ol></li>
<li><ol start="2" type="1">
<li>从U中选出<strong>距离最短的顶点k</strong>，并将顶点k加入<code>S</code>中；同时，从<code>U</code>中移除顶点k。</li>
</ol></li>
<li><ol start="3" type="1">
<li>更新<code>U</code>中各个顶点到起点<code>s</code>的距离。这是由于上一步中确定了<code>k</code>是求出最短路径的顶点，从而可以利用<code>k</code>来更新其它顶点的距离；例如，<code>l(sv)&gt;l(sk)+l(kv)</code>,那么就得用<code>l(sk)+l(kv)</code>替换<code>l(sv)</code></li>
</ol></li>
<li><ol start="4" type="1">
<li>重复步骤(2)和(3)，直到遍历完所有顶点。 <img src="/数据结构-C-实现/D.png" width="350"> <strong>如下所示解法：</strong> <img src="/数据结构-C-实现/D2.png" width="500"></li>
</ol></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D算法最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec, map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//该集合指示未进行迭代的顶点</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; notDofVertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (i != V)</span><br><span class="line">            notDofVertices.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="type">int</span> currentVertice = V; <span class="comment">//记录迭代的顶点</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">2048</span><span class="number">-1</span>;	<span class="comment">//2048表示∞</span></span><br><span class="line">    <span class="keyword">while</span> (!notDofVertices.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//确定点V到点notDofVertices[index]最短路径min，确定顶点index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; notDofVertices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[currentVertice][notDofVertices[i]]&gt; min)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                index = notDofVertices[i];</span><br><span class="line">                min = vec[currentVertice][index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先保存一些原来的顶点</span></span><br><span class="line">        <span class="type">int</span> originV = currentVertice;</span><br><span class="line">        <span class="comment">//下一次迭代要遍历的顶点</span></span><br><span class="line">        currentVertice = index;</span><br><span class="line">        <span class="comment">//从notDofVertices删除顶点index</span></span><br><span class="line">        <span class="keyword">auto</span> t = <span class="built_in">find</span>(notDofVertices.<span class="built_in">begin</span>(), notDofVertices.<span class="built_in">end</span>(),index);</span><br><span class="line">        notDofVertices.<span class="built_in">erase</span>(t, t + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//点放入w</span></span><br><span class="line">        w[index] = min;</span><br><span class="line">        <span class="comment">//更新vec</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; notDofVertices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            index = notDofVertices[i];</span><br><span class="line">            vec[currentVertice][index] = vec[originV][index] &lt;= vec[currentVertice][index] + min?</span><br><span class="line">                vec[originV][index] : vec[currentVertice][index] + min;</span><br><span class="line">        &#125;</span><br><span class="line">        min = <span class="number">2048</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用int main()&#123;</span></span><br><span class="line">	 vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec&#123; &#123;<span class="number">2048</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2048</span>,<span class="number">2048</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2</span>,<span class="number">2048</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2048</span>,<span class="number">2048</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2048</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2048</span>,<span class="number">1</span>,<span class="number">2048</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2048</span>,<span class="number">2048</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2048</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2048</span>,<span class="number">2048</span>,<span class="number">5</span>,<span class="number">2048</span>,<span class="number">2</span>,<span class="number">2048</span>&#125; &#125;;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mymap;</span><br><span class="line">    <span class="built_in">dijkstra</span>(vec, mymap, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 弗洛伊德算法</strong></p>
<p><strong>弗洛伊德算法是求每一对顶点之间的最短路径</strong>，其实调用<code>n</code>次<code>dijkstra</code>函数也能求出每一对顶点之间的最短路径，时间复杂度为<code>O(n*n*n)</code>。但是在这里我们介绍比较简洁的<code>Floyd</code>算法。<code>Floyd</code>算法的<strong>基本思想,可以将问题分解:</strong></p>
<ul>
<li><strong>第一先找出最短的距离</strong></li>
<li><strong>第二再考虑如何找出对应的行进路线。</strong></li>
</ul>
<p>如何找出最短路径呢，这里还是用到<strong>动态规划的知识</strong>，对于任何一个城市而言，<code>i</code>到<code>j</code>的最短距离不外乎存在<code>i</code>到<code>j</code>之间经过<code>k</code>和不经过<code>k</code>两种可能，所以可以令<code>k=1，2，3，...，n</code>(n是城市的数目)，<strong>在检查<code>d(ij)</code>与<code>d(ik)+d(kj)</code>的值；在此<code>d(ik)</code>与<code>d(kj)</code>分别是目前为止所知道的<code>i</code>到<code>k</code>与<code>k</code>到<code>j</code>的最短距离，因此<code>d(ik)+d(kj)</code>就是<code>i</code>到<code>j</code>经过<code>k</code>的最短距离</strong>。所以，若有<code>d(ij)&gt;d(ik)+d(kj)</code>，就表示从<code>i</code>出发经过<code>k</code>再到<code>j</code>的距离要比原来的<code>i</code>到<code>j</code>距离短，自然把<code>i</code>到<code>j</code>的<code>d(ij)</code>重写为<code>d(ik)+d(kj)</code>，<strong>每当一个k查完了，<code>d(ij)</code>就是目前的<code>i</code>到<code>j</code>的最短距离。重复这一过程，最后当查完所有的<code>k</code>时，<code>d(ij)</code>里面存放的就是i到j之间的最短距离了。</strong></p>
<p><strong>实现过程：</strong></p>
<ul>
<li>写出图的初始距离矩阵<code>W0</code>和初始路由矩阵<code>R0</code></li>
</ul>
<p><span class="math display">\[
W^0=
\begin{cases}
d_{ij}，当v_i与v_j间有边时\\
∞，当v_i与v_j间无边时\\
0，i=j
\end{cases}
\]</span> <span class="math display">\[
R^0=
\begin{cases}
j，当W^0&lt;∞，i→j前次经过的中间点\\
0，W^0=∞或i=j
\end{cases}
\]</span></p>
<ul>
<li>依次将G中的各节点<code>K</code>作为中间节点，求<code>Wij</code>的最短路径,<code>k=1,2,3...n</code>。当节点<code>K</code>为中间节点时,要更新矩阵：</li>
</ul>
<p><span class="math display">\[
W^K=
\begin{cases}
min(W^{K-1}_{ij},W^{k-1}_{ik}+W^{k-1}_{kj})
\end{cases}
\]</span> <span class="math display">\[
R^k_{ij}=
\begin{cases}
k，,W^{k-1}_{ik}+W^{k-1}_{kj}时进行更新\\
r^{k-1}_{ij}，不更新
\end{cases}
\]</span></p>
<ul>
<li>当<code>k=n</code>时，得到的W矩阵即为各顶点间的最短距离，<code>R</code>为路径选择 <strong>如下的例题：</strong> <img src="/数据结构-C-实现/F.png" width="200"> 由<code>R0</code>知道经过V1作为中间节点可得<code>W1</code>和<code>R1</code>： <img src="/数据结构-C-实现/F2.png" width="600"> 再由<code>R1</code>知道经过<code>V2</code>可得<code>W2</code>和<code>R2</code> <img src="/数据结构-C-实现/F3.png" width="600"></li>
</ul>
<p><strong>经过上面的两个图可以知道，我们对矩阵的改变其实只用看当前节点所在的行和列，有数字时可能会发生改变，此时进行<code>d(ij)</code>与<code>d(ik)+d(kj)</code>的比较看是否要更新。</strong></p>
<h6 id="拓扑排序">12.5.2 拓扑排序</h6>
<p>当且仅当一个有向图为有向无环图<code>DAG，directed acyclic graph</code>时，才能得到对应于该图的拓扑排序。每个有向无环图都至少存在一种拓扑排序。<strong>一般来说拓扑排序主要应用于判断有向图是否有环</strong>。</p>
<p><strong>实现：</strong>对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则必无环。一般采用邻接表，每个头节点增加一存储入度的数据域。一般为避免重复检测入度为0的点，可设一栈或队列暂存入度为0的点，也可以设置标志位<code>isnotPutInSet</code></p>
<ul>
<li>在有向图中选择一个没有前驱即入度为<code>0</code>的顶点输出之</li>
<li>从图中删除该顶点和所有以他为头的弧，并且相应的尾顶点<code>入度-1</code></li>
<li>重复上述两步直至无法输出</li>
<li>若此时输出的顶点数小于有向图的定点数，则说明有向图中存在回路，否则输出的顶点的顺序即为一个拓扑序列</li>
</ul>
<p><img src="/数据结构-C-实现/topoSort.png" width="300"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(n*n)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">graph</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> indegree;</span><br><span class="line">    <span class="type">int</span> numberofVertices;</span><br><span class="line">    <span class="built_in">graph</span>(<span class="type">int</span> _in, <span class="type">int</span> vertices) :<span class="built_in">indegree</span>(_in), <span class="built_in">numberofVertices</span>(vertices) &#123;&#125;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; linkV;</span><br><span class="line">    <span class="type">bool</span> isnotPutInSet = <span class="literal">true</span>;</span><br><span class="line">    ~<span class="built_in">graph</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">(vector&lt;graph&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; zeroIndegreeVertices;</span><br><span class="line">   <span class="comment">// int Size = vec.size();</span></span><br><span class="line">    <span class="comment">//int count = 0;</span></span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (it != vec.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;indegree == <span class="number">0</span> &amp;&amp; it-&gt;isnotPutInSet)</span><br><span class="line">        &#123;</span><br><span class="line">            zeroIndegreeVertices.<span class="built_in">insert</span>(it-&gt;numberofVertices);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = it-&gt;linkV.<span class="built_in">begin</span>(); iter != it-&gt;linkV.<span class="built_in">end</span>(); iter++)</span><br><span class="line">            &#123;</span><br><span class="line">                --vec[*iter<span class="number">-1</span>].indegree;</span><br><span class="line">            &#125;</span><br><span class="line">            it-&gt;isnotPutInSet = <span class="literal">false</span>;</span><br><span class="line">            it = vec.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() == zeroIndegreeVertices.<span class="built_in">size</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;该图无环路&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;该图有环路&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调试</span></span><br><span class="line">	vector&lt;graph&gt; gvec;</span><br><span class="line">    <span class="function">graph <span class="title">v1</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    v1.linkV.<span class="built_in">insert</span>(&#123; <span class="number">2</span>,<span class="number">4</span> &#125;);</span><br><span class="line">    <span class="function">graph <span class="title">v2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    v2.linkV.<span class="built_in">insert</span>(&#123; <span class="number">3</span>,<span class="number">4</span> &#125;);</span><br><span class="line">    <span class="function">graph <span class="title">v3</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">graph <span class="title">v4</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    v4.linkV.<span class="built_in">insert</span>(&#123; <span class="number">3</span> &#125;);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v4);</span><br><span class="line">    <span class="built_in">topoSort</span>(gvec);</span><br></pre></td></tr></table></figure></p>
<h6 id="最小生成树">12.5.3 最小生成树</h6>
<p>最小代价生成树即指对带权无向图包含所有<code>n</code>个顶点和<code>n-1</code>条边，联通所有结点后代价最小的树。假设<code>N =(V，&#123; E &#125;)</code>是一个连通网，<code>U</code>是顶点集<code>V</code>的一个非空子集。若<code>(u , v)</code>是一条具有最小权值（代价）的边，其中<code>u∈U</code>， <code>v∈(V - U)</code>，则必存在一棵包含边（u，v）的最小生成树。最小生成树的算法有<strong>普里姆算法和克鲁斯卡尔算法。</strong></p>
<p><strong>1. 普里姆(prim)算法</strong></p>
<p><strong>算法思路：</strong>首先就是从图中的一个起点<code>a</code>开始，把<code>a</code>加入<code>U</code>集合，然后，寻找从与<code>a</code>有关联的边中，权重最小的那条边并且该边的终点<code>b</code>在顶点集合：<code>(V-U)</code>中，我们也把<code>b</code>加入到集合<code>U</code>中，并且输出边<code>(a，b)</code>的信息，这样我们的集合U就有：<code>&#123;a,b&#125;</code>，然后，我们寻找与<code>a</code>关联和<code>b</code>关联的边中，权重最小的那条边并且该边的终点在集合：<code>(V-U)</code>中，我们把<code>c</code>加入到集合<code>U</code>中，并且输出对应的那条边的信息，这样我们的集合U就有：<code>&#123;a,b,c&#125;</code>这三个元素了，依次类推，直到所有顶点都加入到了集合<code>U</code>。其实就是<strong>贪心算法</strong> <img src="/数据结构-C-实现/prim.png" width="600"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用邻接矩阵结构，复杂度为O(n*n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ve;     <span class="comment">//U集合记录顶点，</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; reachV;    <span class="comment">//记录已到达过的顶点</span></span><br><span class="line">    ve.<span class="built_in">push_back</span>(<span class="number">0</span>);    <span class="comment">//直接将V0加入集合U</span></span><br><span class="line">    reachV.<span class="built_in">insert</span>(<span class="number">0</span>);   <span class="comment">//0已到达过</span></span><br><span class="line">    <span class="keyword">while</span> (ve.<span class="built_in">size</span>() != vec.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX;</span><br><span class="line">        <span class="type">int</span> sourceV = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> toVertice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ve.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> vertice = ve[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vec[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &lt; vec[vertice][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;   <span class="comment">//若当前记录的的min权值大于当前两节点边的权值，进行更新</span></span><br><span class="line">                    <span class="keyword">if</span> (reachV.<span class="built_in">find</span>(j)==reachV.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        min = vec[vertice][j];</span><br><span class="line">                        toVertice = j;</span><br><span class="line">                        sourceV = vertice;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ve.<span class="built_in">push_back</span>(toVertice);</span><br><span class="line">        reachV.<span class="built_in">insert</span>(toVertice);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;V&quot;</span>&lt;&lt;sourceV+<span class="number">1</span> &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; <span class="string">&quot;V&quot;</span></span><br><span class="line">			&lt;&lt; toVertice+<span class="number">1</span> &lt;&lt; <span class="string">&quot; 权值:&quot;</span> &lt;&lt; min &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec&#123; &#123;INT_MAX,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,INT_MAX,INT_MAX&#125;,</span><br><span class="line">                            &#123;<span class="number">6</span>,INT_MAX,<span class="number">5</span>,INT_MAX,<span class="number">3</span>,INT_MAX&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>,<span class="number">5</span>,INT_MAX,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>,INT_MAX,<span class="number">5</span>,INT_MAX,INT_MAX,<span class="number">2</span>&#125;,</span><br><span class="line">                            &#123;INT_MAX,<span class="number">3</span>,<span class="number">6</span>,INT_MAX,INT_MAX,<span class="number">6</span>&#125;,</span><br><span class="line">                            &#123;INT_MAX,INT_MAX,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,INT_MAX&#125; &#125;;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">auto</span> i : it)</span><br><span class="line">               <span class="keyword">if</span> (i == INT_MAX)</span><br><span class="line">                   cout &lt;&lt; <span class="string">&quot;∞ &quot;</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">           cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">prim</span>(vec);</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 克鲁斯卡算法</strong></p>
<p>算法思路：</p>
<ul>
<li>（1）将图中的所有边都去掉。</li>
<li>（2）将边按权值从小到大的顺序添加到图中，保证添加的过程中不会形成环</li>
<li>（3）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。 <img src="/数据结构-C-实现/kelusika.png" width="700"></li>
</ul>
<h4 id="b-tree">13. B-Tree</h4>
<p>对存储在磁盘上的数据，<code>B-Tree</code>是一种适合索引方法的数据结构。</p>
<h5 id="b-tree的特点">13.1 B-Tree的特点</h5>
<p><code>B-Tree</code>也称B树是一种平衡的多路查找树。一颗3阶的B树，其内部节点必须有2~3个孩子。因此可知道一颗m阶B树（空树/m叉树），必须满足以下特性：</p>
<ul>
<li><strong>树中每个结点至多有<code>m</code>棵子树，即至多含有<code>m-1</code>个关键字</strong></li>
<li><strong>若根结点不是叶子结点，则至少有两棵子树</strong></li>
<li>除根之外的所有非终端结点至少有<code>[m/2]</code>棵子树，<code>[]</code>表示向上取整。</li>
<li>所有非终端结点包含下列信息数据<code>n,P0,K1,P1,K2......Kn,Pn</code>;其中<code>Kn</code>为关键字，<code>Pn</code>为指向下面子树根节点的指针。他有：
<ul>
<li>①当<code>i&lt;j</code>时，<code>Ki&lt;Kj</code>；</li>
<li>②当<code>i&lt;j</code>时，对于指针<code>Pi</code>指向的子树根节点的关键子都必须小于<code>Kj</code>，而当<code>i&gt;j</code>时必须<code>Pi</code>所指子树根节点的关键子都必须大于<code>Kj</code>（即从小到大）；</li>
<li>③关键子个数<code>[m/2]-1≤n≤m-1</code></li>
</ul></li>
<li><strong>所有叶子结点都在同一层</strong> <img src="/数据结构-C-实现/BTree.png" width="600"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> m 3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span>&#123;</span><br><span class="line"><span class="type">int</span> keyNum;						<span class="comment">//该节点关键字数量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span> *parent;			<span class="comment">//指向父亲结点</span></span><br><span class="line">KeyTyep	key[m+<span class="number">1</span>];				    <span class="comment">//关键字大小，0号单元未使用</span></span><br><span class="line"><span class="keyword">struct</span>	<span class="title class_">BTNode</span>	*ptr[m+<span class="number">1</span>];		<span class="comment">//指向子树的指针，0号单元未使用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>	*recptr[m+<span class="number">1</span>]；			<span class="comment">//指向该关键字的数据域</span></span><br><span class="line">&#125;BTNode,*BTree;</span><br></pre></td></tr></table></figure>
<h5 id="b-tree的高">13.2 B-Tree的高</h5>
<p>对于B-Tree的定理有：设T为一颗高度为<code>h</code>的<code>m</code>阶B-Tree，n为T的元素个数，<code>d=[m/2]</code>,则有：</p>
<ul>
<li><span class="math inline">\(2d^{h-1}≤n≤m^k-1\)</span></li>
<li><span class="math inline">\(log_m{n+1}≤h≤log_d \frac{n+1}2+1\)</span></li>
</ul>
<p>则有上面的公式可以知道，一颗高度为5的200阶B-Tree至少有<span class="math inline">\(2*10^8-1\)</span>个元素。这种高度低且一个节点有多个元素的结构很符合磁盘的一次性存储与取出大小适当数据量。</p>
<h5 id="b-tree的操作">13.3 B-Tree的操作</h5>
<h6 id="b-tree的搜索">13.3.1 B-Tree的搜索</h6>
<p>B-Tree的搜索算法与m叉搜索树的搜索算法相同。在搜索过程中，从根部至外部节点路径上的所有内部节点通过比较关键子大小选择以哪条路径行进，直到相等或者到<code>NULL</code>，因此，磁盘访问次数最多是<code>h</code></p>
<h6 id="b-tree的插入">13.3.2 B-Tree的插入</h6>
<p>对于B-Tree的插入，首先经过关键字搜索比较找到插入的节点，之后有如下法则</p>
<ul>
<li>为空时直接插入到根节点记录</li>
<li>插入的节点为不饱和节点，则直接插入，不必做其他操作</li>
<li><strong>如果插入的时饱和节点，则先插入，然后取中上升，其余的进行分裂</strong> <img src="/数据结构-C-实现/BTreeInsert.png" width="600"></li>
</ul>
<h6 id="b-tree的删除">13.3.3 B-Tree的删除</h6>
<p>B-Tree的删除会破坏规则：每个非终端节点至少含有<code>[m/2]</code>棵子树，即每个非终端节点的要有<code>[m/2]-1</code>个关键字；或者破坏了指针指向。因此为恢复该规则进行操作有：</p>
<p><strong>删除叶子关键字：</strong></p>
<ul>
<li>若该叶子节点删除该关键字后，仍满足关键字数量范围，直接删除</li>
<li>若叶子结点删除该关键字后，不满足关键字数量范围，但兄弟结点关键字＞<code>[m/2]-1</code>,兄弟借（途经父亲）</li>
<li>若叶子结点删除该关键字后，不满足关键字数量范围，且兄弟结点关键字=<code>[m/2]-1</code>,向父借，拖父下水 <img src="/数据结构-C-实现/BTreeDeleteLeaf.png" width="500"></li>
</ul>
<p><strong>删除非叶子关键字</strong>:</p>
<ul>
<li>向该节点要删除的关键字的左子树最大关键字或右子树最小关键字借。</li>
<li>题目已规定要向谁借，但借完不符合要求，但此时兄弟可借，直接借兄弟的</li>
<li>借完不和，兄也不可借，兄弟合并 <img src="/数据结构-C-实现/BTreeDeleteNotLeaf.png" width="700"></li>
</ul>
<h4 id="b树">14. B+树</h4>
<h5 id="b树与b树的不同点">14.1 B+树与B树的不同点</h5>
<p><strong>B+树是应文件系统所需而出的一种B-树的变型树</strong>。一棵m阶的B+树和m阶的B-树的差异在于：</p>
<ul>
<li><p><strong>非叶子结点的子树指针与关键字个数相同或者子树指针数=关键字个数+1</strong>；</p></li>
<li><p><strong>非叶结点仅具有索引下一层作用，不存储数据的指针，跟记录有关的信息均存放在叶结点中</strong>。</p></li>
<li><p>非叶子结点的子树指针<code>P[i]</code>，指向关键字值属于<code>[K[i], K[i+1])</code>的子树（B树是开区间）；</p></li>
<li><p><strong>为所有叶子结点增加一个链指针；树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</strong></p></li>
<li><p><strong>所有关键字具体数据或者数据“地址”只存储在叶子结点。</strong></p></li>
</ul>
<p><img src="/数据结构-C-实现/BTreeadd.png" width="700"></p>
<p><strong><em>注意：说到B+Tree的叶子节点，必须区分MySQL中的聚簇索引和非聚簇索引（二级索引），在聚簇索引的叶子节点存储的是完整的行数据，而二级索引叶子节点存储的是数据<code>行指针</code>,这里的<code>行指针</code>的实质是叶子节点保存只是行的主键值，因此非聚簇索引必须还要在聚簇索引结构上进行查找，这也是为什么它被称为二级索引</em></strong></p>
<h5 id="为什么b树更适合做索引">14.2 为什么B+树更适合做索引</h5>
<p><strong>我们先分析B+d与众不同的特点：</strong></p>
<ul>
<li>第一个就是B+树在B树的基础之上最重要的改进就是非叶子结点只存储关键字和下一层的索引，不存储Data域，只在叶子结点存储Data域；</li>
<li>第二点就是所有叶子结点增加一个链指针，使所有叶结点构成一个有序链表，因此当我们需要有序遍历所有关键字时，直接从最小关键字的叶子结点开始遍历即可。</li>
</ul>
<h6 id="非叶子结点不存储data域的好处">14.2.1非叶子结点不存储Data域的好处</h6>
<ul>
<li><p><strong>每一个结点可以存放更多的关键字和下一层的索引。数据库是存储在磁盘上的，我们读取数据是从磁盘读取到内存中，我们在进行磁盘预读取时，是以块的单位进行数据读取，我们在检索B/B+树的结点时，每次以块为单位将一个结点读取到内存中，若一块磁盘包含了树结点以外的数据，就造成了浪费，因此我们需要使每一个结点的数据大小正好或者接近一块磁盘的大小</strong>。于是我们在构建B+/B树时，树的阶数其实就取决于一块磁盘中能容纳多少个关键字以及相关的索引和Data域。<strong>B+树的非叶子结点不存储Data域，因此它可以存储更多个关键字和下一层索引，因此B+树会比B树更宽胖</strong>。若我需要查找的关键字正好在叶子结点，B+树所进行的I/O次数更少,因为途中经过每一层，我们都需要进行一次I/O读取一个结点，B+树会更矮，途径的层数会更少。</p></li>
<li><p>使得B+树查询速度更稳定，B+树所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p></li>
</ul>
<h6 id="所有叶结点构成一个有序链表的好处">14.2.2所有叶结点构成一个有序链表的好处</h6>
<ul>
<li><p><strong>B+树便于区间查找（这点才是B+树作为索引的关键）</strong>，我们进行数据库查询大多为区间查询，B+树天然具备排序功能，B+树所有的叶子结点构成了一个有序链表，在查询大小区间的数据时候更方便，B+树查询，只需通过头结点往下找到第一个叶子结点，然后在叶子结点的链表上就行遍历即可完成区间查询，而B树的关键字大小相邻近的结点可能隔得很远，要想进行区间查询需要不停的进行中序遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li>
<li><p>B+树全结点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要进行中序遍历，这有利于数据库做全表扫描。</p></li>
</ul>
<p><strong>总结B+树优点(选择B+树作为索引的原因)</strong></p>
<ul>
<li>因为没有非叶子节点没有存储数据，因此单一非叶子结点能存储更多的关键字索引</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；</li>
<li>所有叶子节点形成有序链表，便于范围查询以及全结点遍历更快。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">C++面向对象&模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-11 21:49:55" itemprop="dateCreated datePublished" datetime="2022-07-11T21:49:55+08:00">2022-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-24 17:57:41" itemprop="dateModified" datetime="2022-07-24T17:57:41+08:00">2022-07-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="面向对象程序设计">1. 面向对象程序设计</h4>
<p>面向对象程序设计的核心思想是<strong>数据抽象、继承和动态绑定</strong>。通过数据抽象，我们可以将类的接口与实现相分离；使用继承。可以使用相似的类型对其关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别。</p>
<ul>
<li>1）继承：根部类为基类（相似于java的父类），其他继承于基类的类为派生类。</li>
<li>2）虚函数：某些函数，基类希望它的派生类各自定义适合其自生的函数</li>
<li>3）动态绑定：能使用同一代码分别处理基类和派生类。如虚函数运行版本由实参决定。</li>
</ul>
<h5 id="定义基类">1.1 定义基类</h5>
<ul>
<li>作为继承关系中根结点的类<strong>通常有定义了一个虚析构函数</strong>。</li>
<li>基类中的成员函数分为两种：<strong>一是派生类要进行重写覆盖的函数，称为虚函数</strong>；<strong>二是希望直接继承而不改变的函数</strong>。当我们使用指针或引用调用虚函数时，该调用将被<strong>动态绑定</strong>。</li>
<li>基类通过在其成员函数的声明语句之前加上关键字<code>virtual</code>使得函数执行<strong>动态绑定</strong>。其只能出现在类内部声明或定义中。</li>
<li>派生类可以继承定义在基类中的成员，但是派生类的的成员函数不一定有权访问从基类继承而来的成员。派生类能访问公有成员，但不能访问私有成员。为解决这一问题，引入了新访问运算符：<code>protected</code>(派生类有权访问，禁止用户访问）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;		<span class="comment">//定义基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Quote</span>(<span class="type">const</span> Quote&amp; q):<span class="built_in">bookNo</span>(q.bookNo),<span class="built_in">price</span>(q.price)&#123;&#125;</span><br><span class="line">	<span class="built_in">Quote</span>(<span class="type">const</span> string&amp; _book,<span class="type">const</span> <span class="type">double</span> _price):<span class="built_in">bookNo</span>(_book),<span class="built_in">price</span>(_price)&#123;&#125;</span><br><span class="line">	<span class="function">string <span class="title">isbn</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> n*price;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string bookNo;		<span class="comment">//派生类无权访问</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">double</span> price=<span class="number">0</span>;		<span class="comment">//派生类可访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="定义派生类">1.2 定义派生类</h5>
<p>派生类需要使用类派生列表来指出它是从哪个基类继承而来的，每个基类前面可以有三种访问说明符<code>public、private、protected</code>中的一个。<strong>派生类需要将继承来的成员函数需要覆盖的进行重新声明。如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分，也能将公有类型的对象绑定到基类的引用或者指针上。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_Book</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="built_in">Bulk_Book</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Bulk_Book</span>(<span class="type">const</span> Bulk_Book&amp; bb):<span class="built_in">Quote</span>(bb.<span class="built_in">isbn</span>(),bb.price),</span><br><span class="line">			<span class="built_in">min_qty</span>(bb.<span class="built_in">getMin_qty</span>()),<span class="built_in">discount</span>(bb.<span class="built_in">getDiscount</span>())&#123;&#125;</span><br><span class="line">	<span class="built_in">Bulk_Book</span>(<span class="type">const</span> string&amp; _book,<span class="type">double</span> p,<span class="type">size_t</span> qty,<span class="type">double</span> disc):<span class="built_in">Quote</span>(_book,p),<span class="built_in">min_qyt</span>(qyt),<span class="built_in">discount</span>(disc)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span> n)</span><span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;min_qyt)</span><br><span class="line">			<span class="keyword">return</span> n*price*discount;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> n*price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">getMin_qty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> min_qty;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getDiscpunt</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> discount;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Bulk_Book</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">size_t</span> min_qty=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> discount=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>派生类经常(但不总是)覆盖虚函数，派生类如果没有覆盖虚函数，则会直接继承其在基类中的版本。</li>
<li>派生类可以在它要覆盖的函数前面使用<code>virtual</code>,但不是非得这样做。C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数，既添加一个<code>override</code>。</li>
<li><strong>因为派生类对象中含有与基类对应得组成部分，所以我们能把派生类对象当成基类对象来使用（java的多态），同时也可把基类的指针或引用绑定到派生类对象得基类部分上。这种转换被称为派生类到基类的转换</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;			<span class="comment">//基类对象</span></span><br><span class="line">Bulk_Book bulk;		<span class="comment">//派生类对象</span></span><br><span class="line">Quote *p=&amp;item;		<span class="comment">//基类指针绑定带基类对象</span></span><br><span class="line">p=&amp;bulk;			<span class="comment">//基类指针也可绑定到派生类对象，反之不行（不安全）</span></span><br><span class="line">Quote &amp;r=bulk;		<span class="comment">//基类引用绑定带派生类上</span></span><br></pre></td></tr></table></figure>
<h6 id="派生类构造函数">1.2.1 派生类构造函数</h6>
<p><strong>派生类需要用基类的构造函数来初始化,每个类控制它自己的成员初始化过程</strong>。基类部分和自己的数据成员都在构造函数初始化阶段执行初始化操作，只不过由基类构造函数来初始化Bulk_quote的基类部分 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Bulk_Book</span>(<span class="type">const</span> Bulk_Book&amp; bb):<span class="built_in">Quote</span>(bb.<span class="built_in">isbn</span>(),bb.price),</span><br><span class="line">			<span class="built_in">min_qty</span>(bb.<span class="built_in">getMin_qty</span>()),<span class="built_in">discount</span>(bb.<span class="built_in">getDiscount</span>())&#123;&#125;</span><br><span class="line"><span class="built_in">Bulk_Book</span>(<span class="type">const</span> string&amp; _book,<span class="type">double</span> p,<span class="type">size_t</span> qty,<span class="type">double</span> disc):<span class="built_in">Quote</span>(_book,p),<span class="built_in">min_qyt</span>(qyt),<span class="built_in">discount</span>(disc)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="派生类使用基类成员">1.2.2 派生类使用基类成员</h6>
<p>派生类<strong>可以访问由基类继承来的的公有成员和受保护成员</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span> n)</span><span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;min_qyt)</span><br><span class="line">			<span class="keyword">return</span> n*price*discount;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> n*price;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="继承与静态成员">1.2.3 继承与静态成员</h6>
<p><strong>如果基类定义了一个静态成员，则在整个继承体系中都只存在该成员的唯一定义</strong>，无论从基类中派生出多少个类，<strong>对每个静态成员来说都只存在唯一的实例,属于一个类</strong>。静态成员遵循同样的访问控制规则，<strong>如果基类中成员private，派生类无权访问（只能由接口访问、或将该派生类声明为友元）</strong>，如果可访问，那么可通过基类或者派生类使用它。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">statmen</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::f</span><span class="params">(<span class="type">const</span> Derived &amp;s)</span></span>&#123;</span><br><span class="line">	Base::<span class="built_in">statmen</span>();		<span class="comment">//Base定义了statmen</span></span><br><span class="line">	Derived::<span class="built_in">statmen</span>();	<span class="comment">//Derived继承了statmen</span></span><br><span class="line">	s.<span class="built_in">statmen</span>();			<span class="comment">//通过Derived对象调用</span></span><br><span class="line">	<span class="built_in">statmen</span>();			<span class="comment">//通过this对象调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>其他规则：</strong></p>
<ul>
<li><strong>如果想将某个类用作基类，那么这个类必须已经定义而非仅仅声明，因为派生类要使用基类当中的成员，另外，这个规定隐含表示了：一个类不能派生它本身。</strong></li>
<li>一个类可以同时是基类和派生类。</li>
<li>可以通过<code>class Base final &#123;&#125;;</code>来阻止其他类来继承该类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Base是D1的直接基类，是D2的间接基类（D1既是派生类又是基类）。</span></span><br><span class="line"><span class="comment">//最终的派生链末端的类会包含直接基类的子对象以及每个间接基类的子对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>:<span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>:<span class="keyword">public</span> D1&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="类型转换与继承">1.3 类型转换与继承</h5>
<ul>
<li><p><strong>存在继承关系，我们可以将一个基类的引用或者指针绑定到派生类对象上</strong>。<strong><em>当使用存在继承关系的类型时，需将静态类型与动态类型区分开来：表达式的静态类型在编译时总是已知的，是变量声明时的类型或表达式生成的类型；动态类型是变量或者表达式表示的内存中对象的类型。但如果表达式既不是引用也不是指针，那么静态类型永远与动态类型一致。</em></strong></p></li>
<li><strong>不存在从基类向派生类的隐式类型转换(不安全)</strong>。
<ul>
<li><p>每个派生类对象包含一个基类部分，才能实现派生类向基类的隐式转换，所以一个基类不能隐式地转换为派生类： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_Book&amp; bulkr=base;		<span class="comment">//错误</span></span><br><span class="line">Bulk_Book* bulkp=&amp;base;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>另外一个特殊的是即使一个基类指针绑定在派生类对象上，我们也不能执行基类向派生类的转换，因为编译器判断的是指针或者引用的静态类型： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_Book bulk;</span><br><span class="line">Quote *itemp=&amp;bulk;		<span class="comment">//正确</span></span><br><span class="line">Bulk_Book *bulkp=itemp;	<span class="comment">//错误，不允许</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>对象之间不存在类型转换。派生类向基类的自动类型转换只针对指针或者引用</strong>，我们初始化或者赋值一个类类型的对象，实际上是在调用某个函数，这些函数可以接受一个引用作为参数，允许我们向基类形参传递一个派生类的对象，但又由于这些不是虚函数，显然这些函数只能处理基类的对象，派生类自有的成员被切掉了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为拷贝和赋值的参数为const Quote&amp;的引用类型</span></span><br><span class="line">Bulk_Book bulk;		<span class="comment">//派生类对象</span></span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;	<span class="comment">//允许，只不过在Bulk_Book上新增的被切掉</span></span><br><span class="line">item=bulk;			<span class="comment">//允许</span></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h5 id="虚函数">1.4 虚函数</h5>
<p><strong>当我们使用基类的引用或指针调用虚函数时会执行动态绑定(直到运行时，我们才会知道调用的是哪个版本---动态类型）。</strong></p>
<p><strong>1. 某个虚函数(参数）通过指针或者引用调用时，直到运行时才能确定调用哪个版本的函数，被调用的是与指针或者引用的动态类型匹配的哪个，需要注意的是只有通过指针或者引用调用虚函数才会发生动态绑定。通过对象调用的虚函数版本在编译时确定。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,<span class="type">const</span> Quote &amp;items,<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">//根据传入的items调用net_price,允许时才知道时基类的net_price还是派生类的</span></span><br><span class="line">	<span class="type">double</span> ret= items.<span class="built_in">net_price</span>(n);</span><br><span class="line">	os&lt;&lt;<span class="string">&quot;isbn:&quot;</span>&lt;&lt;items.<span class="built_in">isbn</span>()&lt;&lt;<span class="string">&quot; sold_num:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; total_price:&quot;</span>&lt;&lt;ret&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function">Quote <span class="title">base</span><span class="params">(<span class="string">&quot;0-2121-755&quot;</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout,base,<span class="number">10</span>);		<span class="comment">//item引用调用的是quote版本的net_price</span></span><br><span class="line"><span class="function">Bulk_quote <span class="title">bu_base</span><span class="params">(<span class="string">&quot;021-1141-143&quot;</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">0.9</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout,bu_base,<span class="number">10</span>);	<span class="comment">//item引用调用的是Bulk_quote版本的net_price</span></span><br></pre></td></tr></table></figure> <strong><em>注意：既当且仅当对通过引用或者指针调用虚函数时，才会出现运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同（这时支持多态性的根本所在）。</em></strong></p>
<p><strong>2. 一旦某个函数被声明为虚函数，则在所有派生类中都是虚函数（可加virtual也可不加），覆盖的版本形参类型、返回类型必须一致，(但如果返回的是类的引用或者指针时，可以不一样,但须保证基类和派生类的类型是可转换的，这将在后面简述：注意处)</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> )</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> B&amp; <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>;		<span class="comment">//可覆盖，但是不能加override</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span><span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="comment">//void f2(int)override;	//错误，参数不一样</span></span><br><span class="line">	<span class="function">D1&amp; <span class="title">f3</span><span class="params">()</span><span class="keyword">override</span></span>;		<span class="comment">//正确</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.final和override说名符：</strong>c++新标准中的<code>override</code>是为了说明派生类的中的虚函数，能让编译器为程序员发现一些错误：如参数并不匹配，返回类型不一致等，同时也让编译者知道它是一个（基类虚函数）到派生类重写的虚函数。<strong>函数被指定为<code>final</code>,则之后任何尝试覆盖该函数的操作都将引发错误</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span><span class="type">const</span> <span class="keyword">final</span></span>;		<span class="comment">//不允许后续的其他继承类覆盖</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.虚函数运行默认实参</strong>：虚函数也可以有默认实参，但是实参值由该次调用的<strong>静态类型决定</strong>，也就是如果通过基类的引用或指针调用虚函数，则使用基类虚函数定义的默认实参，不管动态类型如何。<strong>因此虚函数如果使用实参，最好基类和派生类的中定义的默认实参是一致的。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a=<span class="number">1</span>,<span class="type">int</span> b=<span class="number">4</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">B b;</span><br><span class="line">A *P=&amp;B;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();		<span class="comment">//调用B中的f，但是传入参数为A的默认参数，即B::f(0,3);</span></span><br></pre></td></tr></table></figure></p>
<p><strong>5. 回避虚函数的动态绑定机制：</strong>有些情况下希望强制执行虚函数的某个特定版本，可以使用作用域运算符，强制调用某个派生类或者基类的虚函数。如上述的<code>item</code>,如果是要<code>Quote</code>的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doeble ret=item.Queto::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="抽象基类">1.5 抽象基类</h5>
<p>含有<strong>纯虚函数</strong>的类是抽象基类。纯虚函数无需定义，通过在函数声明语句的分号之前书写=0就可以将一个虚函数说明为纯虚函数，它告诉用户该函数对于该类没有实际意义。不能在类的内部为一个=0的函数提供函数体。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Disc_quote</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Disc_quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Dis_quote</span>(<span class="type">const</span> string&amp; book,<span class="type">double</span> price,std::<span class="type">size_t</span> qty,<span class="type">double</span> disc):</span><br><span class="line">	<span class="built_in">Queto</span>(book,price),<span class="built_in">quantity</span>(qty),<span class="built_in">discount</span>(disc)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">net_prince</span><span class="params">(std::<span class="type">size_t</span> n)</span></span>=<span class="number">0</span>;		<span class="comment">//纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std:<span class="type">size_t</span> quantity=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> discount=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 这种抽象基类负责定义接口，后续的其他类可以覆盖该接口。<strong>我们不能实例化一个抽象基类的对象，但可以定义它的派生类（前提是该派生类覆盖定义了该纯虚函数）</strong>。</p>
<p>这个时候我们讲<code>Bulk_queto</code>直接继承与<code>Disc_quote</code>,而不是<code>Quot</code>e,值得一提的是，派生类构造函数只初始化它的直接基类： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> :<span class="keyword">public</span> Disc_quote</span><br><span class="line">&#123;	<span class="comment">//继承了isbn,prince,bookNo</span></span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">		:<span class="built_in">Disc_quote</span>(book,p,qty,disc) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span><span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="访问控制与继承">1.6 访问控制与继承</h5>
<p>每个类分别控制自己成员的初始化过程和成员可访问特性</p>
<h6 id="protected">1.6.1 protected</h6>
<p><code>protected</code>受保护的成员，对类用户来说是不可访问的，对于派生类和友元来说是可访问的。派生类的成员或者友元只能通过派生类对象来访问基类的受保护成员！ <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;		<span class="comment">//能访问Sneaky::port_mem</span></span><br><span class="line">	<span class="comment">//friend void clobber(Base&amp;);			//不能访问Base::port_,e,</span></span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp; s)</span></span>&#123;s.j=s.port_mem=<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure> 为什么第二条<code>friend void clobber(Base&amp;)</code>；是不允许的，<strong>因为<code>void clobber(Base&amp;)</code>；不是<code>Base</code>类的友员</strong>，试想一下如果这种方法可行，那么就意味着用户可以自己制作一个派生类，此时就很容易规避了protected不能被用户访问的特性，这是一个弊端，所以说派生类的成员或者友元只能通过派生类对象来访问继承自基类的受保护成员！</p>
<h6 id="公有私有和受保护继承">1.6.2 公有、私有和受保护继承</h6>
<p>类对其继承而来的成员的访问权限收到两个因素影响：<strong>一是基类中该成员的访问说明符；二是派生类的派生列表中的说明符。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> port_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 如果继承是<code>public</code>的，则尊循原来的访问说明符，如果继承是<code>private</code>的，则所有继承成员都是私有的，如果继承是受保护的，则继承的公有成员都是受保护的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pub_exam</span>:<span class="keyword">public</span>  Base&#123;</span><br><span class="line"><span class="comment">//成员性质保持不变</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> port_mem;&#125;	<span class="comment">//可被访问</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> priv_mem;&#125;	<span class="comment">//错误，private不可访问（可用基类接口、或声明为友员）</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">priv_exam</span>:<span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="comment">//private只是不会影响派生类对基类的原有访问。</span></span><br><span class="line"><span class="comment">//该继承类的成员都是private</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> port_mem;&#125;	<span class="comment">//可被访问</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> priv_mem;&#125;	<span class="comment">//错误，private不可访问（可用基类接口、或声明为友员）</span></span><br><span class="line">&#125;；</span><br><span class="line">使用：</span><br><span class="line">pub_exam d1;</span><br><span class="line">priv_exam d2;</span><br><span class="line">d1.<span class="built_in">pub_mem</span>();		<span class="comment">//正确，该函数再派生类中是public</span></span><br><span class="line">d2.<span class="built_in">pub_mem</span>();		<span class="comment">//错误，该函数再派生类中是private</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以派生访问说明符对于派生类的成员能否访问其直接基类的成员没什么影响，</span></span><br><span class="line"><span class="comment">//只是影响派生类用户对于基类成员的访问权限。同时也可控制继承自派生类的新类的访问权限。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ds</span>:<span class="keyword">public</span> pub_exam&#123;</span><br><span class="line"><span class="comment">//成员性质不变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">as</span>:<span class="keyword">public</span> priv_exam&#123;</span><br><span class="line"><span class="comment">//都是private,无法直接访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：</em></strong></p>
<ul>
<li><strong>当派生类公有继承基类时，用户代码才能实现派生类向基类的转换，否则不能；</strong></li>
<li>无论什么方式继承，派生类的成员函数和友元都可以使用派生类向基类的转换；</li>
<li>如果D是公有或者受保护继承B，则D的派生类的成员和友元可以使用向基类B的类型转换，否则不能</li>
</ul>
<h6 id="友员和继承">1.6.3 友员和继承</h6>
<p>就如友员关系无法传递一样，友员关系同样无法被继承。既基类的友员再访问派生类成员时不具有特殊性，同理派生类的友员也不买随意访问基类成员。</p>
<h6 id="改变个别成员的可访问性">1.6.4 改变个别成员的可访问性</h6>
<p>当需要改变派生类继承的某个名字的访问级别，通过使用using声明： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">private</span> Base&#123;		<span class="comment">//private继承，则默认下的继承类成员为私有</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	usnig Base::size;		<span class="comment">//保持与Base基类一样的public</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::n;			<span class="comment">//保持与基类一样的protected</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="继承中类的作用域">1.7 继承中类的作用域</h5>
<p>每个类都有自己的作用域，在这个域中我们声明和定义类的成员。<strong>当存在继承时，派生类的作用域嵌套在其基类作用域之内。如果有多次继承，则一环一环嵌套下去。</strong></p>
<h6 id="编译时进行名字查找">1.7.1 编译时进行名字查找</h6>
<p><strong>一个对象、引用和指针的静态类型决定了该对象的哪些成员是可见的，我们使用哪些成员仍然是由静态成员类型所决定的</strong>：如我们在上面的Disc_quote添加一新成员： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Disc_quote</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::pair&lt;<span class="type">size_t</span>,<span class="type">double</span>&gt; <span class="title">discount_policy</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;quanlity,discount&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用：Quote不包含有新成员;而Bulk_quote继承自Disc_quote</span></span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Bulk_quote* blukp=&amp;bulk;			<span class="comment">//静态类型于动态类型一致</span></span><br><span class="line">Quote* itemp=&amp;bulk;					<span class="comment">//基类指针指向派生类对象，即静态与动态不一致</span></span><br><span class="line">bulkp-&gt;<span class="built_in">discount_policy</span>();			<span class="comment">//正确</span></span><br><span class="line">itemp-&gt;<span class="built_in">discount_policy</span>();			<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p>
<h6 id="名字冲突与继承">1.7.2 名字冲突与继承</h6>
<p>与其他作用域一样，派生类也能重用定义在其直接或间接基类中的名字，此时定义在内存作用域的名字将会隐藏定义在外层（即基类）的名字: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">punlic:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getMem</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> mem;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getMem</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> mem;&#125;		<span class="comment">//隐藏了基类中的getMem</span></span><br><span class="line">	<span class="comment">//那么我们在需要被隐藏成员时，可以通过**使用域作用运算符**获取：</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get_A_mem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> A::mem&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mem;		<span class="comment">//隐藏了基类中的mem</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>理解c++继承中函数解析过程：假定我们调用<code>p-&gt;getMem()</code>或者<code>obj.getMem()</code>,则以此执行下面四个步骤:</strong></p>
<blockquote>
<ol type="1">
<li>首先确定<code>p</code>或<code>obj</code>的静态类型。因为我们调用的是一个成员，所有它们必定是类类型</li>
<li>在<code>p</code>或<code>obj</code>的静态类型对应的类中寻找<code>getMem</code>成员，如果找不到则以此在它的基类中寻找，直到继承链的顶端。若到顶端都没找到，则编译器报错。</li>
<li>一旦找到了<code>getMmem</code>，就进行常规的类型检查（参数个数和类型）以确认找到的<code>getMem</code>，对于本次调用是否合法。</li>
<li>假设调用合法，则编译器将根据调用是否是虚函数而产生不同代码：如果<code>getMem</code>是虚函数且我们是通过引用或指针形式进行调用，则编译器产生的代码将在运行时确定到底是运行该虚函数的哪一个版本。反之，则常规调用函数</li>
</ol>
</blockquote>
<h6 id="名字查找先于类型检查">1.7.3 名字查找先于类型检查</h6>
<p>声明在内层作用域中的函数不会重载声明在外层作用域的函数。因此派生类的成员也不会重载基类中的成员，而是隐藏掉外层作用域成员。所以下面的调用是错误的: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">memfcn</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">B d;</span><br><span class="line">A c;</span><br><span class="line">c.<span class="built_in">memfvn</span>();		<span class="comment">//正确</span></span><br><span class="line">d.<span class="built_in">memfcn</span>(<span class="number">10</span>);	<span class="comment">//正确</span></span><br><span class="line">d.<span class="built_in">memfcn</span>();		<span class="comment">//错误，参数列表为空的memcn被隐藏了</span></span><br><span class="line">d.A::<span class="built_in">memfcn</span>();	<span class="comment">//正确，通过作用域访问</span></span><br></pre></td></tr></table></figure></p>
<h6 id="虚函数与作用域">1.7.4 虚函数与作用域</h6>
<p>现<strong>在我们应该能够理解为什么虚函数必须要有相同的形参列表。因为假如不同,就会被隐藏，我们就无法通过基类引用或指针调用派生类的虚函数了</strong>，而是通过作用域运算符<code>::</code>访问，这就失去了多态这个重要性质。</p>
<h5 id="构造函数与拷贝控制">1.8 构造函数与拷贝控制</h5>
<p>继承体系中的类也需要控制当其对象执行一系列操作时发生什么样的行为。</p>
<h6 id="虚析构函数">1.8.1 虚析构函数</h6>
<p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个<strong>虚析构函数</strong>，这样我们就能动态分配继承体系中的对象了：<strong>假如当我们要<code>delete</code>一个动态<code>Quote*</code>指针时，该指针实际可能是<code>Bulk_quote</code>类型的对象。那么此时编译器就必须清楚它应该执行的是<code>Bulk_quote</code>的析构函数，所以应该在基类定义一个虚析构函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 之前我们介绍过一条经验准则<strong>：若一个类有析构函数，则必应当需要拷贝和赋值操作。</strong>一般基类的析构函数并不需要遵循这条经验准则，这是一个重要例外。同时虚析构函数会阻止类合成移动操作。</p>
<h6 id="基类合成拷贝控制与继承">1.8.2 基类合成拷贝控制与继承</h6>
<p>基类或者派生类的合成拷贝控制成员的行为与其他类似：</p>
<ul>
<li><strong>合成派生类默认构造函数运行了直接基类的默认构造函数，直接基类又运行了间接基类的构造函数</strong>（如上面的<code>Quote、Disc_quote、Bulk_quote</code>的构造函数）,<strong>顺序时会先先执行基类的默认构造函数，再执行派生类构造函数</strong></li>
<li>在上文继承体系中所有类都使用合成的析构函数，派生类隐式使用，基类显式使用，<strong>派生类的析构函数释放成员，销毁直接基类</strong></li>
</ul>
<p><strong>1. 派生类中删除的拷贝控制与基类的关系：</strong></p>
<ul>
<li><strong>如果基类的默认构造函数、拷贝控制成员、析构函数是删除或者不可访问，则派生类中对应的成员也是删除的，因为没办法执行对基类的操作；</strong></li>
<li><strong>如果基类的析构函数是删除的，则派生类拷贝控制成员和移动构造函数是删除的，因为没法销毁基类对象</strong></li>
<li>编译器不会合成删除掉的移动操作。如果基类的移动操作是删除的，则派生类当中的也是删除的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">const</span> B&amp;)=<span class="keyword">delete</span>;	<span class="comment">//拷贝构造是删除的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">D d;		<span class="comment">//正确，使用合成的默认构造哈桑农户</span></span><br><span class="line"><span class="function">D <span class="title">d1</span><span class="params">(d)</span></span>;	<span class="comment">//错误，基类的拷贝构造函数时删除的，那么派生类的拷贝构造也被删除了</span></span><br><span class="line"><span class="function">D <span class="title">d3</span><span class="params">(std::move(d))</span></span>;	<span class="comment">//错误，编译器不会合成删除掉移动操作，会隐式调用拷贝构造，但它也被删除，</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 移动操作与继承</strong></p>
<p><strong>多数基类定义一个虚析构函数，因此默认下基类不含合成的移动操作，这导致派生类也没有移动操作</strong>（没有移动操作，但使用的时候用到移动操会默认使用拷贝构造函数）。当确实需要移动操作时应在基类中定义，并同时定义拷贝操作 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Quote</span>(<span class="type">const</span> Quote&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Quote</span>(Quote&amp;&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Quote&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="派生类的拷贝控制成员">1.8.3 派生类的拷贝控制成员</h6>
<p>正如派生类构造函数一样要初始化基类部分的成员，<strong>派生类的拷贝控制成员不仅拷贝自身成员，也负责了拷贝基类部分的成员。</strong> <strong>1. 当为派生类定义拷贝或移动构造函数时，我们通常使用对应得函数初始化对象得基类部分。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">calss base&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">D</span>(<span class="type">const</span> D&amp; d):<span class="built_in">Base</span>(d)&#123;&#125;</span><br><span class="line">	<span class="built_in">D</span>(D&amp;&amp; d):<span class="built_in">Base</span>(std::<span class="built_in">move</span>(d))&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 派生类赋值运算符,与拷贝和移动构造函数一样，派生类赋值运算符也必须显式地为其基类部分赋值。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">calss base&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">D</span>(<span class="type">const</span> D&amp; d):<span class="built_in">Base</span>(d)&#123;&#125;</span><br><span class="line">	<span class="built_in">D</span>(D&amp;&amp; d):<span class="built_in">Base</span>(std::<span class="built_in">move</span>(d))&#123;&#125;</span><br><span class="line">	D&amp; <span class="keyword">operator</span>=(<span class="type">const</span> D&amp; d)&#123;</span><br><span class="line">		Base::<span class="keyword">operator</span>=(d);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 继承的构造函数.在c++新标准中，允许派生类能够直接用基类定义的构造函数,但不能继承默认构造函数和拷贝，移动构造函数，如果不定义，编译器负责合成。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>:<span class="keyword">public</span> Disc_qupte&#123;</span><br><span class="line">	<span class="keyword">using</span> Disc_quote::Disc_quote;		<span class="comment">//继承Disc_Quot的构造函数</span></span><br><span class="line">	<span class="function"><span class="type">double</span> 	<span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span><span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>using（起到注明作用，提示用户有继承构造函数）作用于编译器时令其产生代码</strong>，对于基类的每个构造函数，派生类都生成一个形参列表完全对应的：</p>
<ul>
<li>构造函数的<code>using</code>不会改变构造函数的访问级别；</li>
<li><strong>当基类构造函数含有默认实参，实参不会被继承，而是生成一个形参列表中除去默认实参的构造函数</strong>（例如，若基类有一个接受两个形参的构造函数，其中第二个有默认实参，则派生类将获得两个构造函数：一个是构造函数接受两个形参，另一个只接受一个形参，该形参是没有默认实参的那个）。P558 ；</li>
<li>如果派生类定义了与基类构造函数形参相同的构造函数，则不会继承该构造函数，而是替换</li>
</ul>
<h5 id="单例模式">1.9 单例模式</h5>
<p><strong>定义：单例模式是一个类只能实例化一个对象,实现单例模式的思路:</strong></p>
<ul>
<li>1）.把无参构造函数和拷贝构造函数私有化</li>
<li>2）.定义一个类内的类静态成员指针</li>
<li>3）在类外初始化时，<code>new</code>一个对象</li>
<li>4）把指针的权限设置为私有，然后提供一个静态成员函数让外面获取这个指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Maker</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.把构造函数私有化</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Maker</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Maker</span>(<span class="type">const</span> Maker &amp;m)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员函数，访问静态成员变量</span></span><br><span class="line">	<span class="comment">//4.把指针的权限设置为私有，然后提供一个静态成员函数让外面获取这个指针</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Maker* <span class="title">getMaker</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pMaker;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//2.定义一个类内的静态成员指针</span></span><br><span class="line">	<span class="type">static</span> Maker *pMaker;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//3.在类外初始化时，new一个对象</span></span><br><span class="line">Maker *Maker::pMaker = <span class="keyword">new</span> Maker;<span class="comment">//这里可以new是因为在Maker::作用域，编译器把它当成在类内</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Maker *m = Maker::<span class="built_in">getMaker</span>();</span><br><span class="line">	Maker *m2 = Maker::<span class="built_in">getMaker</span>();		<span class="comment">//m和m2是同一对象</span></span><br><span class="line">	<span class="comment">//Maker m3 = *m;//调用拷贝构造，这里会产生新对象，所以要把拷贝构造也私有化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板与泛型编程">2. 模板与泛型编程</h4>
<p>面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况，不同之处在于：<strong>OOP能处理类型在程序运行之前都未知的情况；而泛型编程，在编译时就能知道类型。之前介绍过的容器、迭代器和泛型算法都是泛型编程的例子</strong></p>
<p><strong><em>必须知道的原理</em></strong>：<strong>模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义</strong>，这个过程叫做<strong>模板实例化</strong>。编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。即模板类在没有调用之前是不会生成代码的。 <strong><em>注意：</em></strong>要区分类实例化和模板实例化，类实例即为创建对象，模板实例化为定义一个实例类</p>
<h5 id="函数模板">2.1 函数模板</h5>
<p>一个函数模板就是一个公式，可以用来针对特定类型的函数版本。比如我们定义一个比较函数模板： <strong>1. 定义函数模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">int</span>  <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;v1,<span class="type">const</span> T&amp; v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v1&lt;v2) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v1&gt;v2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板定义以关键字<code>template</code>开始，后跟一模板参数类型列表（由逗号分隔的一个或多个模板参数，由&lt;&gt;括起）。 当我们使用模板时，显式或隐式的指定模板实参，将其绑定到模板参数上。</p>
<p><strong>2.模板实例</strong></p>
<p>我们调用该模板时候编译器就会根据我们提供的实参来实例化一个特定版本的函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;&lt;endl;		<span class="comment">//实例化了一int compare(const int&amp; v1,const int&amp; v2)函数</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3.模板类型参数</strong></p>
<p>上面自定义的模板函数有模板参数列表,<strong>这些参数可以指定函数参数列表、返回类型、函数体内的变量声明和类型转换</strong>，其内的类型参数前必须使用<code>class</code>或者<code>typename</code>,在这里两个的含义完全相同。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">class</span> U&gt; <span class="title">T</span><span class="params">(<span class="type">const</span> T&amp; v1,<span class="type">const</span> U&amp; v2)</span></span>&#123;</span><br><span class="line">	T tep=v1;</span><br><span class="line">	U up=v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 非类型模板参数</strong></p>
<p>除了定义模板类型参数，还可以定义<strong>非类型模板参数</strong>。<strong>非类型参数表示一个值而非一个类型，通过一个特定的类型名而不是关键字<code>typename</code>、<code>class</code>来指定非类型参数</strong>。例如：编写一个<code>compare</code>版本处理字符串字面常量，这种字面常量是<code>const char</code>数组：（因为数组是无法拷贝的，所以采用引用），该非类型模板定义了两个非类型参数，第一个将要表示第一个数组长度，第二个表示第二个数组长度: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非类型模板参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N,<span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N],<span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>当非类型模板被实例化时，非类型参数被一个用户提供的或编译器推断的值所替代。这些值必须是常量表达式，绑定到指针或引用的非类型实参必须具有静态生存周期（static)</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;Hi&quot;</span>,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//编译器会将字面常量大小代替`N\M`，从而实例模板。</span></span><br><span class="line"><span class="comment">//编译器会在字符串字面常量末尾插入一个空字符作为终结符，所以编译器实例的版本是：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[<span class="number">3</span>],<span class="type">const</span> <span class="type">char</span> (&amp;p2)[<span class="number">6</span>])</span></span>;</span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong>一个非类型参数可以是整型、指向对象或函数的指针或者左值引用。</p>
<h5 id="类模板">2.2 类模板</h5>
<p>函数模板不同的是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后面的&lt;&gt;中提供额外信息----作为类模板参数的实参</p>
<h6 id="定义类模板">2.2.1 定义类模板</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">BlobPtr</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;		<span class="comment">//value_type=T</span></span><br><span class="line">	<span class="comment">//typename 告诉编译器size_type是个类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BlobPtr</span>&lt;T&gt;;		<span class="comment">//类BlobPtr&lt;T&gt;为友员</span></span><br><span class="line">	<span class="built_in">Blob</span>() :<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;()) &#123;<span class="built_in">addStatic</span>();&#125;	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il) :<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)) </span><br><span class="line">		&#123;<span class="built_in">addStatic</span>();&#125;	<span class="comment">//含参构造函数</span></span><br><span class="line">	~<span class="built_in">Blob</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">Size</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;					<span class="comment">//元素数量</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;						<span class="comment">//判空</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T&amp; e)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(e); &#125;				<span class="comment">//尾部添加</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T&amp;&amp; e)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(e)); &#125;	<span class="comment">//右值引用尾部添加</span></span><br><span class="line">	<span class="comment">//静态接口</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addStatic</span><span class="params">()</span> </span>&#123; count_object++; &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">getStatic</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count_object; &#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">Pop_back</span><span class="params">()</span></span>;													<span class="comment">//删除尾部元素</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">Back</span><span class="params">()</span></span>;														<span class="comment">//取尾部元素</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">Front</span><span class="params">()</span></span>;														<span class="comment">//取头部元素</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);									<span class="comment">//下标访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string&amp; msg)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="type">static</span> count_object=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">void</span>  Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="type">const</span> string&amp; msg)<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= <span class="built_in">Size</span>() || i &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="built_in">Pop_back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="built_in">Back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="built_in">Front</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;front on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;[] on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (*data)[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">size_t</span> Blob&lt;T&gt;::count_object = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类通过弱引用智能指针控制Blob的shared_ptr指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">M</span>&gt;<span class="keyword">class</span> <span class="title class_">BlobPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() :<span class="built_in">current_location</span>(<span class="number">0</span>) &#123;  &#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;M&gt;&amp; a, <span class="type">size_t</span> si = <span class="number">0</span>) :<span class="built_in">wptr</span>(a.data), <span class="built_in">current_location</span>(si) &#123;  &#125;</span><br><span class="line">	M&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(current_location, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (*p)[current_location];</span><br><span class="line">	&#125;</span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		++current_location;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">		--current_location;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setWptr</span><span class="params">(Blob&lt;M&gt;&amp; a)</span> </span>&#123; wptr = a.data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;vector&lt;M&gt;&gt; <span class="built_in">check</span>(std::<span class="type">size_t</span>, <span class="type">const</span> string&amp;)<span class="type">const</span>;</span><br><span class="line">	std::weak_ptr&lt;vector&lt;M&gt;&gt; wptr;</span><br><span class="line">	<span class="type">size_t</span> current_location;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">M</span>&gt; <span class="keyword">inline</span> std::shared_ptr&lt;vector&lt;M&gt;&gt; BlobPtr&lt;M&gt;::</span><br><span class="line"><span class="built_in">check</span>(std::<span class="type">size_t</span> i, <span class="type">const</span> string&amp; msg)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> q = wptr.<span class="built_in">lock</span>();</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= q-&gt;<span class="built_in">size</span>())</span><br><span class="line">			<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">		<span class="keyword">return</span> q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用示例</span></span><br><span class="line">Blob&lt;string&gt; blob;</span><br><span class="line">Blob&lt;string&gt; blob2;</span><br><span class="line">Blob&lt;<span class="type">int</span>&gt;blob3;</span><br><span class="line">cout &lt;&lt; blob.<span class="built_in">getStatic</span>()&lt;&lt;blob3.<span class="built_in">getStatic</span>() &lt;&lt; endl;	<span class="comment">//2 1</span></span><br><span class="line">blob.<span class="built_in">Push_back</span>(<span class="string">&quot;trluper&quot;</span>);</span><br><span class="line">blob.<span class="built_in">Push_back</span>(<span class="string">&quot;github&quot;</span>);</span><br><span class="line">BlobPtr&lt;string&gt; bp;</span><br><span class="line">bp.<span class="built_in">setWptr</span>(blob);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!blob.<span class="built_in">Empty</span>()) &#123;</span><br><span class="line">	string s = blob.<span class="built_in">Front</span>();</span><br><span class="line">	s = blob.<span class="built_in">Back</span>();</span><br><span class="line">	++bp;</span><br><span class="line">	s = *bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从上面一个完整的类模板可以看到：</strong></p>
<ul>
<li><strong>类模板的成员函数可定义在类内也可在类外，类内定义的成员函数默认内联（inline)</strong>。类模板成员函数具有和模板相同的模板参数。因此，<strong>在类外定义成员函数必须以关键字<code>template</code>关键字开始，后接类模板参数列表</strong>：<code>template&lt;class T&gt;</code></li>
<li><code>inline</code>关键字放在模板之后，函数之前即可</li>
<li>我们使用一个类模板类型必须提供模板参数。但有一个例外：在模板类内作用域可以直接使用模板名而不需要要提供参数<code>&lt;T&gt;</code>，但在类外定义的时候需要提供参数<code>&lt;T&gt;</code></li>
<li>在函数体内，我们进入了类作用域，所以可以不用再提供模板参数。</li>
<li><strong>模板和非模板友类：如果一类模板包含了一个非类模板友元，则友元被授权可以访问所有模板实例；如果是包含模板友元，类可以授权给所有友元模板实例，也可以只授权特定实例：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">C2</span>&#123;</span><br><span class="line">	<span class="comment">//只要pal和C2的实例类型是一致的，那么实例化后的pal就是它的友类,</span></span><br><span class="line">	<span class="comment">//跟friend class BlobPtr&lt;T&gt;;一样</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">pal</span>&lt;T&gt;;</span><br><span class="line">	<span class="comment">//pal2的所有实例都是C2的友类，不管类型是否一样</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">x</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">pal2</span>;</span><br><span class="line">	<span class="comment">//对于非模板类，时C2所有实例的友类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">pal3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="类模板的静态成员">2.2.2 类模板的静态成员</h6>
<ul>
<li>对于任意给定的模板参数<code>X</code>，其都有<code>count_object、getStatic、addStatic</code>成员，所有的<code>foo&lt;x&gt;</code>类型对象都共享相同的<code>count_object、getStatic、addStatic</code>。注意时相同的类型参数<code>X</code>情况下共享，不同类型各自拥有</li>
<li>类外初始化要加上<code>tempalte&lt;class T&gt;</code>,如<code>template&lt;class T&gt;size_t Blob&lt;T&gt;::count_object = 0;</code></li>
<li>可以使用实例类访问<code>Blob&lt;String&gt;::getStatic()</code>，也可以使用实例化的对象访问<code>blob.getStatic()</code></li>
</ul>
<h5 id="模板参数">2.3 模板参数</h5>
<p>摸版参数（如上面一直用到的<code>T</code>）遵循普通作用域规则，一个模板参数的可用范围是其声明之后至模板声明或定义结束之前。它也会隐藏外层作用域中声明的相同的名字。</p>
<ul>
<li>模板声明需要包含模板参数，如：<code>template &lt;typename T&gt;int compare(const T&amp;, const T&amp;);</code></li>
<li>由于我们通过作用域运算符来访问静态成员和类型成员，但是在模板中，编译器无法区分访问的是类型还是静态成员。如<code>T::size_type *p</code>;到底是定义<code>p</code>变量还是将<code>size_type</code>这个静态成员与<code>p</code>相乘。为了区分，<strong>编译器是认为在模板中通过作用域访问的是变量。所以必须通过关键字<code>typename</code>来告诉编译器现在使用的是个类型</strong>，如前面类模板中的<code>typedef typename std::vector&lt;T&gt;::size_type size_type;</code></li>
</ul>
<p><strong>1. 默认模板实参</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tempalte&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">F</span>=less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b,F f=<span class="built_in">F</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(a,b))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(b,a))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为模板参数提供了<strong>默认实参</strong>，<strong>指出<code>compare</code>默认将使用标准库的<code>less</code>函数对象类，但用户调用该函数时可以提供自己的比较操作，但该操作接受的实参类型应当与<code>compare</code>的前两个类型兼容。</strong>对于一个模板参数，只有当它右侧所有参数都有默认实参时，它才可以有默认实参</p>
<p>如果一个类模板为其所有模板参数提供了默认实参，<strong>且希望使用默认实参，那么就必须在模板名后跟一个空尖括号</strong>。用int实例化的average_precision模板名后跟的是尖括号。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt;<span class="keyword">class</span> Numbers&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Numbers&lt;doubel&gt; los;</span><br><span class="line">Numebers&lt;&gt;average_precision;		<span class="comment">//使用默认实参</span></span><br></pre></td></tr></table></figure></p>
<h5 id="控制实例化">2.4 控制实例化</h5>
<p>当多个或多个独立的编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件就都会有该模板的一个实例类。在多个文件<strong>实例化相同模板类的额外开销可能非常严重</strong>。我们可以通过<strong>显式实例化来避免这种开销</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;	<span class="comment">//声明</span></span><br></pre></td></tr></table></figure> <strong><code>declaration</code>是一个类或函数的声明，其中所有模板参数已被替换为实参</strong>。遇到<code>extern</code>模板声明，编译不会在本文件中生成实例化代码，而是去别处寻找。声明必须出现在使用实例化版本的代码，否则会自动实例化，对于一个给定的实例化版本，可能有多个<code>extern</code>声明但只有一个定义。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern声明，那么接下来实例化一个对应对象和函数并不会在本文件生成一个实例化类和函数</span></span><br><span class="line"><span class="comment">//简而言之，就是我这些类型的类和函数在别的地方定义，在这只是调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">int</span> <span class="title">conpare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;,<span class="type">const</span> <span class="type">int</span> &amp;)</span></span>;</span><br><span class="line">Blob&lt;String&gt; sa1,sa2;</span><br><span class="line"><span class="comment">//下面会在本文件生成一个int类型的实例化类（你看不到，但是编译器生成知道）</span></span><br><span class="line">Blob&lt;<span class="type">int</span>&gt; a1&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">Blob&lt;<span class="type">int</span>&gt; <span class="title">a2</span><span class="params">(a1)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="模板参数和返回值的推断">2.5 模板参数和返回值的推断</h5>
<p>从<strong>函数实参来确定模板实参的过程称为模板实参推断</strong>，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参生成的函数版本，与给定的函数调用最为匹配。</p>
<h6 id="类型转换与模板类型参数">2.5.1 类型转换与模板类型参数</h6>
<ul>
<li><strong>模板函数对const的转换要求很低</strong>。向函数模板传递参数时允许<code>const</code>转换：可以将<code>非const对象</code>的引用（或指针）传递给一个<code>const</code>引用（或指针）形参,也可以将<code>const</code>传递给<code>非const</code>，只不过const会被忽略</li>
<li>数组或函数指针转换，如果函数形参不是引用类型，数组实参转换为指向数组首元素的指针，函数实参转换为指向该函数的指针</li>
<li><strong>其他算术类型转换、派生类到基类的转换</strong>不能应用于函数模板。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">fobj</span><span class="params">(T,T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; T <span class="title">fref</span><span class="params">(<span class="type">const</span> T&amp;,<span class="type">const</span>&amp; T)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">s2</span><span class="params">(<span class="string">&quot;another value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1,s2);		<span class="comment">//调用fobj(string,string),const会被忽略</span></span><br><span class="line"><span class="built_in">fref</span>(s1,s2);		<span class="comment">//调用fref(const string&amp;,const string&amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a,b);			<span class="comment">//调用fobj(int*,int*)</span></span><br><span class="line"><span class="built_in">fobj</span>(a,b)/			<span class="comment">//错误，数字类型不能与引用匹配</span></span><br></pre></td></tr></table></figure>
<h6 id="函数模板必需显示实参情况">2.5.2 函数模板必需显示实参情况</h6>
<p>某些情况，编译器无法推断类型，我们希望用户指定<code>template &lt;typename T1, typename T2, typename T3&gt; T1 sum(T2, T3)</code>; 每次调用sum时调用者必须为<code>T1</code>提供一个显式模板实参(因为我们在实例化这个模板函数时，提供的实参只是<code>T2、T3</code>的，<strong>编译器能推断它们的类型，但无法推断T1的</strong>. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val3 = <span class="built_in">sum</span>&lt;<span class="type">long</span>  <span class="type">long</span>&gt;(i,lng);	<span class="comment">//此时T1是long long型的，</span></span><br></pre></td></tr></table></figure></p>
<h6 id="尾置返回类型与转换">2.5.3 尾置返回类型与转换</h6>
<p><strong>有时需返回一个元素的值，但是迭代器操作只能生成元素的引用而不是元素</strong>。为了获得元素类型，可以使用标准库的类型转换：<code>remove_reference&lt;int&amp;&gt;</code>则它的<code>type</code>成员会是<code>int</code> 。更一般地<code>remove_reference&lt;decltype(beg*)&gt;::type</code> 将获得beg引用元素的类型，组合使用<code>remove_reference</code>尾置返回和<code>decltyp</code>e，就可以在函数中返回元素值的拷贝: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此例中我们通知编译器fcn2的返回类型与解引用beg的参数的结果类型相同</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(T beg,T end)</span>-&gt;<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于下面这个，但是不能用，因为此时*beg标识符未定义，只能后置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">typename remove_reference&lt;decltype(*beg)&gt;::type fcn(T beg,T end)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	return *beg;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>type</code>是一个类的成员，所以必须在返回类型的声明中用<code>typename</code>显式告知编译器返回的是一个类型。</li>
<li><code>decltype</code>关键字，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值</li>
</ul>
<h6 id="模板函数的例外规则即对称对move的支持">2.5.4 模板函数的例外规则（即对称）对move的支持</h6>
<p><strong>模板库例外规则支持move标准库的正确工作：</strong> - 第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值<code>i</code>传递给函数的右值引用参数，且此右值引用为模板参数类型<code>T&amp;&amp;</code>时，编译器推断模板类型参数为实参的左值引用类型（<strong>即右值引用的这种函数模板支持传入左值</strong>） - 在第一例外规则的基础上，第二个例外绑定规则：如果我们间接创建一个引用的引用（实参传入形参），则这些引用形成“折叠”：在所有情况下（除一个例外），引用会折叠成一个普通左值引用类型： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="title">func</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="comment">//实参传入为左值引用X&amp;</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; m=i;</span><br><span class="line"><span class="type">int</span>&amp;&amp; a=<span class="built_in">move</span>(i);</span><br><span class="line"><span class="built_in">func</span>(i);		<span class="comment">//传入左值i,则int&amp;和int&amp;&amp;折叠成int&amp;</span></span><br><span class="line"><span class="built_in">func</span>(a);		<span class="comment">//传入右值a,则int&amp;&amp;和int&amp;&amp;折叠成int&amp;&amp;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>即函数参数时<code>T&amp;&amp;</code>，就意味着我们既可以传递给move一个右值，也可以是左值</strong>，下面以<code>move</code>函数源码为例子探索模板函数的该原理：</p>
<ul>
<li><code>std::move(string(&quot;byte&quot;))</code>向<code>move</code>传递的是一个<strong>右值</strong>，推断出的<code>T</code>的类型为<code>string</code>因此将模板实例化，<code>type</code>类型为<code>string</code>, <code>t</code>的类型为<code>string&amp;&amp;</code>，move的返回类型为<code>string&amp;&amp;</code>,函数体返回<code>static_cast&lt;string&amp;&amp;&gt; (t)</code> 然而<code>t</code>的类型已经是<code>string&amp;&amp;</code>所以类型转换什么都不做，因此调用结果就是右值引用。</li>
<li>如果向<code>move</code>传递一个左值，推断出T类型为<code>string&amp;</code> ,<code>remove_reference</code>用<code>string&amp;</code>进行实例化，故其<code>type</code>成员为<code>string</code>，返回类型<code>string&amp;&amp;</code>,<code>t</code>实例化为<code>string&amp;</code>,<code>string&amp; string&amp;&amp;</code>折叠为<code>string&amp;</code> 故,<code>string&amp;&amp; move(string&amp; t)</code>这也正是我们希望的：将一个右值引用绑定到一个左值，返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code></li>
<li>通常情况下，<code>static_cast</code>只能用于合法的类型转换，但是针对右值引用，可以显式地将左值转换为右值引用，而对于操作右值的代码来说，将右值绑定到左值特性允许它们截断左值，尽管编译器允许这种用法，但是要求我们<code>static_cast</code>以防止意外地转换。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;<span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重载与模板">2.6 重载与模板</h5>
<p><strong>函数模板可以被另一个模板或一个普通非模板函数重载</strong>，名字相同的函数必须有不同数量或类型的参数。<strong>匹配规则：</strong></p>
<ul>
<li>和往常一样，如果恰有一个函数提供比任何其他函数更好的匹配，则选择此函数，但是，如果有多个函数提供同样好的匹配，则：</li>
<li>如果同样好的函数中只有一个是非模板函数，则选在此函数</li>
<li>如果同样好的函数中没有非模板，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板，否则，此调用有歧义</li>
</ul>
<p><strong><em>注意：</em></strong>在定义任何函数之前，记得声明所有重载的函数版本，这样就不必担心编译器由于未遇到希望调用的函数而实例化一个并非你所需的版本</p>
<h5 id="可变参数模板">2.7 可变参数模板</h5>
<p><strong>可变参数模板，即一个接受可变数目参数的模板函数或模板类</strong>。可变数目的参数被称为<strong>参数包</strong>，存在两种参数包，一是模板参数包，表示零个或多个模板参数；二是函数参数包，表示零个或多个函数参数。通过用一个省略号来指出一个模板参数或函数参数表示一个包:</p>
<ul>
<li><code>class…</code> 或<code>typename…</code>指出接下来表示零个或多个类型的列表；</li>
<li>一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表</li>
<li>在一个函数参数列表中，如果一个参数的类型是模板参数包，则此参数也是一个函数参数包</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args 是一个模板参数包；rest 是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args 表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest 表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp; ... rest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="type">double</span> d = <span class="number">3.14</span>; string s = <span class="string">&quot;how now brown cow&quot;</span>;</span><br><span class="line"><span class="built_in">foo</span>(i, s, <span class="number">42</span>, d);	<span class="comment">//相当于void foo(const int&amp;, const string&amp;, const int&amp;, const double&amp;);</span></span><br><span class="line"><span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);	<span class="comment">//相当于void foo(const string&amp;， const int&amp;, const char[3]&amp;);</span></span><br><span class="line"><span class="built_in">foo</span>(d, s);			<span class="comment">//相当于void foo(const double&amp;, const string&amp;);</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>);			<span class="comment">//相当于void foo(const char[3]&amp;);</span></span><br></pre></td></tr></table></figure>
<h6 id="sizeof运算符">2.7.1 sizeof…运算符</h6>
<p>当想要知道包中有多少元素时，可以使用 sizeof… 运算符，其返回一个常量表达式，且不会对其实参求值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Args&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(Args...args)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; endl;	<span class="comment">//类型参数的数目</span></span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;	<span class="comment">//函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="编写可变参数函数模板">2.7.2 编写可变参数函数模板</h6>
<ul>
<li>可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身</li>
<li>为了终止递归，还需要定义一个非可变参数的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来终止递归并打印最后一个元素的函数，其实可变参数模板也能匹配，但是非可变模板更特例化，因此编译器会选择非可变参数版本</span></span><br><span class="line"><span class="comment">//此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包中除了最后一个元素之外的其他元素都会调用这个版本的 print</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;...rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;			  <span class="comment">//打印第一个实参</span></span><br><span class="line">	<span class="comment">//递归调用，打印其他实参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);<span class="comment">//递归传参时，rest 的第一个参数赋给形参的 const T&amp; t，剩下的参数继续以参数包 rest 存在，并继续递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到了一个专业化名词<strong>包扩展</strong>，即是指可变参数函数模版在一次次<strong>调归后对模板参数包和函数参数包的展开</strong>，下列代码是对上述的解释： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;...rest)</span>	<span class="comment">//扩展Args，为print生成函数参数列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);								<span class="comment">//扩展rest，为print递归调用生成实参列表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于Args的扩展</span></span><br><span class="line"><span class="built_in">print</span>(cout, i, s, <span class="number">42</span>);	<span class="comment">//包中有两个参数</span></span><br><span class="line"><span class="comment">//实例化为ostream&amp; print(ostream&amp;, const int&amp;, const string&amp;, const int&amp;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于第二个扩展，发生在对print的递归调用中</span></span><br><span class="line"><span class="comment">//模式是函数参数包的名字（即rest），此模式扩展出一个由包中元素组成的、逗号分隔的列表，因此等价于</span></span><br><span class="line"><span class="built_in">print</span>(os, s, <span class="number">42</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="函数模板特例化">2.8 函数模板特例化</h5>
<p>在某些情况下，通用模板的定义对特定类型是不适合的，但通用定义又可能编译失败或做得不正确。因此，有时可以利用特定知识编写更高效的代码，而非从通用模板实例化，因此当不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本。</p>
<p><strong><em>注意</em></strong>函数模板只有全特例化，不存在偏特化，你认为的偏特化只是重载函数模板</p>
<h6 id="定义函数模板特例化">2.8.1 定义函数模板特例化</h6>
<ul>
<li>当特例化一个函数模板时，<strong>必须为原模板中的每一个模板参数提供实参</strong>。</li>
<li>为了指出正在实例化一个模板，应该使用关键字<code>template&lt;&gt;</code>,指出将为原模板所有模板参数提供实参</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;	<span class="comment">//声明放前面</span></span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; p1, <span class="type">const</span> T&amp; p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compare 的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p1, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;typname T&gt;<span class="function"><span class="type">int</span> <span class="title">campare</span><span class="params">(<span class="type">const</span> T* p1,<span class="type">const</span> T* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(*p1,*p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="函数重载与模板特例化">2.8.2 函数重载与模板特例化</h6>
<ul>
<li>当定义函数模板的特例化版本时，本质上是接管了编译器的工作，为原模板的一个特殊实例提供了定义</li>
<li>特例化的本质是实例化一个模板，而非重载，因此特例化影响象函数匹配</li>
<li>为了特例化一个模板，原模板的声明必须在作用域中，而且，在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中</li>
<li>模板及其特例化版本应该声明在同一个头文件中，所有同名模板的声明应该放在前面，然后是这些模板的特例化版本</li>
</ul>
<h5 id="类模板部分特例化">2.9 类模板部分特例化</h5>
<ul>
<li>与函数模板不同，<strong>类模板的特例化不必为所有模板参数提供实参，可以只指定一部分而非所有模板参数</strong>，或是参数的一部分而非全部特性,即类模板支持偏特化。</li>
<li>我们只能部分特例化类模板，而不能部分特例化函数模板，函数模板不支持偏特化</li>
<li><strong>我们可以只特例化特定成员函数而不是特例化整个类模板</strong></li>
<li><strong>类模板即可以全特化，也可以偏特化</strong></li>
</ul>
<h6 id="类全特化">2.9.1 类全特化</h6>
<p>类模板全特化比较好理解，跟函数模板一样，全特化已经是一个类实例了，当编译器匹配时会优先匹配参数一致的实例 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">	<span class="built_in">Foo</span>(<span class="type">const</span> T &amp;t ): <span class="built_in">mem</span>(t)&#123; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">	T mem;</span><br><span class="line">	<span class="comment">//Foo的其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全特化类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">struct</span> <span class="title class_">Foo</span>(string*)</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;	<span class="comment">//实例化Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();		<span class="comment">//实例化Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo fi;			<span class="comment">//调用全特化实例化Foo&lt;string*&gt;::Foo()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();		<span class="comment">//使用全特化的类</span></span><br></pre></td></tr></table></figure></p>
<h6 id="类偏特化">2.9.2 类偏特化</h6>
<p>对类模板我们可以进行偏特化，比如下面这个类 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;      <span class="comment">// 普通类模板，有两个模板参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定一部分参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;　　　         <span class="comment">// 偏特化版本，指定其中一个参数，即指定了部分类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&lt;<span class="type">int</span> , T2&gt; &#123; ..... &#125;;　　<span class="comment">// 当实例化时的第一个参数为int 则会优先调用这个版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者只特化里面的函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;			<span class="comment">//正在特例化一个函数成员模板</span></span><br><span class="line"><span class="type">void</span> B&lt;<span class="type">int</span>&gt;::Bar	<span class="comment">//正在特例化B&lt;int&gt;的成员Bar</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//进行应用于int的特例化处理</span></span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">还有一种更为重要的特例化形式，在traits编程技法中会用到，以达到完美解决对于原生指针无法进行返回值说明的问题（详间STL源码剖析中的迭代器部分）</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;　　　<span class="comment">//这个偏特化版本只接收指针类型的模板实参 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&lt;T*&gt; &#123; ..... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&lt;T&amp;&gt; &#123; ..... &#125;;     <span class="comment">// 这个偏特化版本只接受引用类型的模板实参</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/" class="post-title-link" itemprop="url">c++primer前部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-07 19:54:22" itemprop="dateCreated datePublished" datetime="2022-07-07T19:54:22+08:00">2022-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 20:50:21" itemprop="dateModified" datetime="2022-07-26T20:50:21+08:00">2022-07-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>89k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:21</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="类型">1.类型</h4>
<h5 id="基本内置类型">1.1 基本内置类型</h5>
<p>基本内置类型有算术类型和空类型。算术类型分两类为整型和浮点型，下图显示了C++的算数类型: <img src="/c-primer前部分/clipboard.png" width="600"></p>
<h5 id="复合类型">1.2 复合类型</h5>
<p>c++有几种复合类型：数组、结构、string、引用和指针。这里讨论引用和指针。</p>
<h6 id="引用">1.2.1 引用</h6>
<p>引用为对象起了另外一个名字。引用类型必须与其所引用的对象类型一致，通过<code>&amp;d</code>的形式定义引用类型。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp;d=value;	<span class="comment">//引用必须被初始化</span></span><br><span class="line">d=<span class="number">20</span>;	<span class="comment">//即value=d=20</span></span><br><span class="line"><span class="type">int</span> i=d;	<span class="comment">//即i=value;</span></span><br></pre></td></tr></table></figure> 程序把引用和它的初始值绑定在一起（而不是拷贝）。一但绑定了，无法再重新绑定另外的对象。引用并非是对象，只是已存在对象的别名。</p>
<h6 id="指针">1.2.2 指针</h6>
<p>与引用类似，指针也实现了对其他对象的间接访问。但与引用相比也有不同，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象，指针也无须在定义时赋初值。 指针的值应是下列4种状态之一：</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针</li>
<li>无效指针，即上述情况外的其他值</li>
</ul>
<h4 id="类型转换">2.类型转换</h4>
<p>如果两种类型可以相互转换，那么它们就是关联的。</p>
<h5 id="隐式转换">2.1 隐式转换</h5>
<p><code>如int ival=3.14+3；</code>。编译器会自动转换运算对象的类型的情况：</p>
<ul>
<li>①在大多数表达式中，比int型小的整型值首先提升为较大的整数类型</li>
<li>②条件语句中，非bool类型转化为bool类型</li>
<li>③初始化中，右值转换为左值类型</li>
<li>④算术运算和关系运算的对象要转化为同一种类型：先整型提升、再看是否为带符号运算（有符号&lt;不带符号，应当减少带符号与不带符号的混用）</li>
<li>⑤函数调用也会发生转换</li>
<li>⑥*void类型指针的转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">-11</span>;</span><br><span class="line">	<span class="type">int</span> c=a+b;		<span class="comment">//强制转换为int</span></span><br><span class="line">	<span class="type">unsigned</span> d=a+B;		<span class="comment">//输出了错误结果4294967295,理论计算结果为-1，带符号型的为负值，带符号&lt;不带符号，+-*\这些运算都会隐式转换为不带符号类型，若左值不声明为带符号型出错</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="显示转换">2.2 显示转换</h5>
<p>强制类型转换形式是<code>cast_name&lt;type&gt;(expression)</code>(一般多为右值，但当type为引用类型时，为左值）。</p>
<ul>
<li><code>type</code>是转换的目标类型，</li>
<li><code>expression</code>是要转换的值。</li>
<li><code>cast_name:static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。</code>
<ul>
<li>①<code>static_cast</code>:任何有明确定义的类型转换，只要不包含底层<code>const</code>，均可使用</li>
<li>②<code>const_cast</code>:只能改变运算对象的底层<code>const</code>，即只改变常量属性，不能改变类型</li>
<li>③<code>dynamic_cast</code>:用于将基类的指针或者引用安全地转换成派生类的指针或引用。</li>
<li>④<code>reinterpret_cast</code>:通常为运算对象的位模式提供较低层次上的重新解释。<code>reinterpret_cast</code>可以用来在任意类型间进行转换，转换后其正确性由程序员保证。</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>	*pc;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);	<span class="comment">//合法，但通过p写值是未定义行为</span></span><br><span class="line"><span class="comment">//上面我们称为去const性质（常量对象转化为非常量对象，这种情况编译器此时就不允许我们进行写操作了）</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cp=&amp;c;</span><br><span class="line"><span class="type">char</span>* q=<span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(cp);		<span class="comment">//不合法，想改变底层const</span></span><br><span class="line">string a = <span class="built_in">static_cast</span>&lt;string&gt;(cp);	<span class="comment">//合法，字符串转换为string类型</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;string&gt;(cp)				<span class="comment">//不合法</span></span><br></pre></td></tr></table></figure>
<h4 id="const关键字">3. const关键字</h4>
<p>使用关键字<code>const</code>对变量类型加以限定，它的值不能被改变。注意在默认情况下，<code>const</code>对象仅在文件内有效。如果像让const对象能在文件间共享，加<code>extern</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> buffer=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> buffer=<span class="number">25</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="const引用">3.1 const引用</h5>
<p>把引用绑定在<code>const</code>对象上，称为对常量的引用。与普通引用所不同的是，对常量的引用不能被用作修改它所绑定的对象：(非常量引用不能绑定常量对象，但允许常量引用绑定非常量对象）: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onst <span class="type">int</span> ci=<span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri=ci;</span><br><span class="line"><span class="type">int</span> &amp;a=ci;		<span class="comment">//错误，不能用非常量引用绑定常量对象</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">40</span>;</span><br><span class="line">r1=<span class="number">42</span>;		<span class="comment">//错误，r1是对常量的引用，不能被修改所绑定的对象ci</span></span><br><span class="line"><span class="type">int</span> &amp;r=ci;	<span class="comment">//错误，不能非常量引用绑定常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;d=i;		<span class="comment">//允许const int&amp; 绑定在一个int对象上</span></span><br></pre></td></tr></table></figure> 还有以下也不允许：<strong>一个常量引用绑定另外一种类型。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> i=<span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p=i;</span><br><span class="line"><span class="comment">/*实际的底层：</span></span><br><span class="line"><span class="comment">double i=3;</span></span><br><span class="line"><span class="comment">int temp=i;</span></span><br><span class="line"><span class="comment">const int &amp;p=temp;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure> 原因是为了确保<code>p</code>绑定的是整型，编译器会把上述的代码中的i由双精度浮点数生产一个临时整型（常）量，此时p就绑定了一个临时量对象<code>temp</code>。如果<code>p</code>不是常量，此时不能对<code>p</code>赋值来改变i的值（因为实际改变的是零时<code>temp</code>的值），在c++看来这是非法的。</p>
<h5 id="指针和const">3.2指针和const</h5>
<p>与引用一样，也可以让指针指向常量或非常量。指向常量的指针不能改变其所指向对象的值。且常量指针必须初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *p 	<span class="comment">//表示 指向的内容不能改变。</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> p	<span class="comment">//就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。</span></span><br></pre></td></tr></table></figure></p>
<h5 id="顶层const和底层const">3.3顶层const和底层const</h5>
<p>一般来说对于指针而言才有底层和顶层这个区分。顶层const表示指针本身是一个常量，底层const表示指针所指向的对象是一个常量。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci=<span class="number">42</span>;	<span class="comment">//顶层const,不能修改ci的值</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> cr=<span class="number">40</span>;	<span class="comment">//顶层const</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p=&amp;i;	<span class="comment">//顶层const,不允许修改p的值</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p1=&amp;i;	<span class="comment">//底层const，允许修改p1的值，但不能修改ci的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2=&amp;ci;	<span class="comment">//底层const，允许修改p2的值，但不能修改ci的值</span></span><br></pre></td></tr></table></figure> <strong><em>注意：执行对象拷贝时，必须至少具有相同底层const资格，或非常量可转化为常量，但反过来不行。如下的两句</em></strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> *p=&amp;i;	<span class="comment">//底层const</span></span><br><span class="line"><span class="type">int</span>* f = p;		<span class="comment">//不允许</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* g = i;	<span class="comment">//合法</span></span><br></pre></td></tr></table></figure></p>
<h4 id="标准库string">4.标准库string</h4>
<p>C++大大增强了对字符串的支持，除了可以使用C风格的字符串，还可以使用内置的 string 类。string 类处理起字符串来会方便很多，完全可以代替C语言中的字符数组或字符串指针。string类重载许多运算符，如<code>&lt;,&gt;,&lt;=,&gt;=,==,!=,[],+</code>,以及输出流<code>&lt;&lt;</code>和<code>&gt;&gt;</code></p>
<h5 id="string的构造">4.1 string的构造</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> naemspace std;</span><br><span class="line">string s1;		<span class="comment">//未定义具体值，则调用string类的未传参构造函数，s1=&quot;&quot;</span></span><br><span class="line">string s2=s1;	<span class="comment">//赋值拷贝</span></span><br><span class="line">string s3=<span class="string">&quot;value&quot;</span>;	<span class="comment">//赋值拷贝</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;		<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>;	<span class="comment">//s4的内容为ccccccccccc，直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(s3,<span class="number">2</span>)</span></span>;	<span class="comment">//结果为lue</span></span><br></pre></td></tr></table></figure>
<h5 id="string关于长度的函数">4.2 string关于长度的函数</h5>
<p>string支持较多的关于长度的函数，这里通过表格形式列举：</p>
<table>
<thead>
<tr class="header">
<th>函数名</th>
<th>功能</th>
<th>调用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>size()</code></td>
<td>返回字符数量</td>
<td><code>s.size()</code></td>
</tr>
<tr class="even">
<td><code>length()</code></td>
<td>返回字符数量</td>
<td><code>s.length()</code></td>
</tr>
<tr class="odd">
<td><code>empty()</code></td>
<td>判空操作</td>
<td><code>s.empty()</code></td>
</tr>
<tr class="even">
<td><code>capacity</code></td>
<td>返回字符容量</td>
<td><code>s.capacity()</code></td>
</tr>
<tr class="odd">
<td><code>reserve(size_t)</code></td>
<td>保留内存以存储一定数量的字符</td>
<td><code>s.reserve(20)</code></td>
</tr>
<tr class="even">
<td><code>resize(size_t)</code></td>
<td>改变字符数量</td>
<td><code>s.reszie(20)</code></td>
</tr>
</tbody>
</table>
<h5 id="string的增删">4.3 string的增删</h5>
<p>一般来说相同名称的接口有很多个重载，因此列举的只是一部分，读者可以在实际开发中依据编辑器给的提示选择： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s2=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">s1=s1+<span class="string">&quot; &quot;</span>+s2;	<span class="comment">//重载+运算符</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>,<span class="string">&quot;ins&quot;</span>); <span class="comment">//从s1的1位置开始，插入&quot;ins&quot;字符串，即s1=&quot;hinsello&quot;;</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;ins&quot;</span>, <span class="number">2</span>);<span class="comment">//从s1的1位置开始，插入&quot;ins&quot;字符串的前2个字符，即s1=&quot;hinello&quot;;</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;ins&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//从s1的1位置开始，插入&quot;ins&quot;字符串的从1位置开始的2个字符，即s1=&quot;hnsello&quot;;</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="type">char</span> c)</span></span>;<span class="comment">//在it处插入字符c，返回插入后迭代器的位置，该insert不是string的insert，而是算法层的函数</span></span><br><span class="line">s1.<span class="built_in">append</span>(str);</span><br><span class="line">s1.<span class="built_in">push_back</span>(<span class="type">char</span> c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊</span></span><br><span class="line">s1.<span class="built_in">assign</span>(str);		<span class="comment">//赋新值，旧值全部删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">iterator s1.<span class="built_in">erase</span>(iterator first, iterator last);<span class="comment">//删除[first，last）之间的所有字符，返回删除后迭代器的位置</span></span><br><span class="line">iterator s1.<span class="built_in">erase</span>(iterator it);<span class="comment">//删除it指向的字符，返回删除后迭代器的位置</span></span><br><span class="line">string&amp;  s1.<span class="built_in">erase</span>(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> n = npos);<span class="comment">//删除pos开始的n个字符，返回修改后的字符串</span></span><br></pre></td></tr></table></figure></p>
<h5 id="string的查找">4.4 string的查找</h5>
<p>string类的查找函数提供了比较多的接口，以下是列举的一些常用<code>find</code>函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，-1表示查找不到子串</span></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">(charc, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="type">size_t</span> <span class="title">rfind</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</span></span><br><span class="line"><span class="number">4.</span> <span class="function"><span class="type">size_t</span> <span class="title">rfind</span> <span class="params">(charc, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">5.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">6.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">7.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</span></span><br><span class="line"><span class="number">8.</span> <span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</span></span><br></pre></td></tr></table></figure></p>
<h5 id="string的遍历和排序">4.5 string的遍历和排序</h5>
<p>string支持下标<code>[]</code>随机访问，也支持迭代器遍历，因此对于遍历string可通过这些功能来遍历。排序我们使用<code>algorithm</code>头文件内的<code>sort</code>，<code>sort</code>内部的实现机制是快排，并且通过修改避免快排中复杂都最高的情况 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="comment">//foreach循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">	<span class="built_in">printf</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">	cout&lt;&lt;c&lt;&lt;ends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string::iterator it=s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it&lt;s.<span class="built_in">end</span>())&#123;</span><br><span class="line">	cout&lt;&lt;*it&lt;&lt;ends;</span><br><span class="line">	it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="其他操作">4.6 其他操作</h5>
<p><img src="/c-primer前部分/cctype.png" width="600"></p>
<p><strong><em>注意</em></strong>：在c++中存在一个从<code>const char*</code>到<code>string</code>的隐式类型转换，却不存在从一个<code>string</code>对象到<code>C_string</code>的自动类型转换。对于<code>string</code>类型的字符串，可以通过<code>c_str()</code>函数返回<code>string</code>对象对应的<code>C_string</code>. 通常，程序员在整个程序中应坚持使用<code>string</code>类对象，直到必须将内容转化为<code>char*</code>时才将其转换为<code>C_string</code>.</p>
<h4 id="初见迭代器">5. 初见迭代器</h4>
<p>这里尽对迭代器做一个简单的介绍，更加具体的见<strong>STL源码剖析</strong>。我们可通过下标运算符来访问string和vector对象的元素。还有一种是通过迭代器（iterator)进行访问，在c++中我们强烈推荐使用迭代器而不是下标，因为标准库几乎为每一种容器都提供了迭代器，而迭代器提供了对对象的间接访问。</p>
<ul>
<li><p><strong>使用迭代器</strong>：有迭代器的类型同时拥有返回迭代器成员的函数，如<code>begin</code>和<code>end</code>,其中<code>begin</code>成员负责返回指向第一个元素；<code>end</code>成员负责返回尾元素的下一个位置。和指针类似，也能通过解引用迭代器来获取它所指示的元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">begin</span>()!=s.<span class="built_in">end</span>())&#123;	<span class="comment">//确保s非空</span></span><br><span class="line"><span class="keyword">auto</span> it=s.<span class="built_in">begin</span>();	<span class="comment">//it表示s的第一个字符地址</span></span><br><span class="line">*it=<span class="built_in">toupper</span>(*it);	<span class="comment">//将第一个改为大写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>将迭代器从一个元素移动到另外一个元素：使用递增++运算符达到这个目的，如下 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>()&amp;&amp;!<span class="built_in">isspace</span>(*it);it++)to</span><br><span class="line">*it=<span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="迭代器类型">5.1迭代器类型</h5>
<p>拥有迭代器的标准库类类型使用iterator和const_iterator来表示迭代器类型.所以如果对象是一个常量，只能用const_iterator。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;	<span class="comment">//it能读写vector&lt;int&gt;的有元素</span></span><br><span class="line">string::iterator it2;		<span class="comment">//it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;		<span class="comment">//it3只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4;			<span class="comment">//只能读，无法写</span></span><br></pre></td></tr></table></figure></p>
<h5 id="迭代器运算">5.2 迭代器运算</h5>
<p>迭代器的递增运算令迭代器每次移动一个元素，所有标准库都支持递增运算，也能用==和!=对两个有效迭代器进行比较。以下是vector和string提供的个更多的关系运算: <img src="/c-primer前部分/iterator.png" width="600" align="middle"></p>
<h4 id="异常处理">6.异常处理</h4>
<p>异常处理包括：</p>
<ul>
<li><code>throw</code>表达式：异常检测部分使用<code>throw</code>表达式来表示它遇到了无法处理的问题。</li>
<li><code>try</code>语句块：异常处理部分使用<code>try</code>语句块处理异常，<code>try</code>语句块代码中抛出的异常会被某个<code>catch</code>子句处理。（<code>catch</code>为异常处理代码）</li>
<li>一套异常类：用于<code>throw</code>语句和相关<code>catch</code>子句之间传递异常的具体信息</li>
</ul>
<p><strong>1）throw表达式</strong> throw表达式引发一个异常。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(item1.<span class="built_in">isbn</span>()!=item2.<span class="built_in">isbn</span>())</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to	same ISBN&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;item1+item2&lt;&lt;endl;</span><br></pre></td></tr></table></figure> c++标准异常类,它们分别位于4个头文件中：</p>
<ul>
<li>①<code>exception</code></li>
<li>②<code>stdexcept</code></li>
<li>③<code>new</code>头文件定义的<code>bad_alloc</code></li>
<li>④<code>type_inof</code>头文件定义的<code>bad_cast</code></li>
</ul>
<p><img src="/c-primer前部分/exception.png" width="600"></p>
<h4 id="函数">7.函数</h4>
<h5 id="局部对象">7.1 局部对象</h5>
<p>在c++中，名字有作用域，对象有<strong>生命周期。</strong></p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见</li>
<li>对象的生命周期是程序执行过程中该对象存在时间</li>
</ul>
<p>形参和函数体内部定义的变量统称为<strong>局部变量</strong>。所有在函数体之外定义的对象存在于程序的整个执行过程。</p>
<ul>
<li><strong>自动对象</strong>：只存在于块执行期间的对象为自动对象。<strong>即对于局部变量，当函数的执行路径经过变量定义语句时创建该对象，到达块末尾时销毁它</strong>。</li>
<li><strong>局部静态对象</strong>：将局部变量定义成static类型从而可获得。在定义中初始化时生产该对象，直到程序终止才被销毁（即static修饰得变量只会被初始化一次）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">size_t</span> ctr=<span class="number">0</span>;	<span class="comment">//只被初始化一次</span></span><br><span class="line">	<span class="keyword">return</span>	++ctr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>:i++)</span><br><span class="line">	cout&lt;&lt;<span class="built_in">count</span>()&lt;&lt;endl;	<span class="comment">//输出得一次为1、2、3.....10</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="参数传递">7.2 参数传递</h5>
<p>形参的类型决定了形参与实参得交互方式。若形参为引用类型，则对应得实参被引用传递，引用形参是它对应实参得别名。当实参的值被拷贝给形参时，形参和实参是两个独立的对象，此时实参被值传递。</p>
<ul>
<li><strong>①指针形参</strong>：和其他非引用形参一样，形参的指针执行拷贝时，拷贝的是实参指针，两个指针是不同的指针，但他们都指向同一对象，因此可修改指向对象的值。</li>
<li><strong>②引用行参</strong>：引用参数绑定初始化它的对象，改变形参也就改变了所引对象的值。使用引用能避免拷贝。</li>
</ul>
<h6 id="指针形参与const">7.2.1 指针形参与const</h6>
<p>达到不改变实参和形参所指对象的值，而且调用时，若改变了值，编译器报错。但需注意(于底层const)允许非常量初始化常量对象（形参），但不允许常量(实参）初始化一个非常量对象（形参）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> a)</span></span>;	<span class="comment">//顶层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* a)</span></span>;	<span class="comment">//底层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>* a)</span></span>;		<span class="comment">//正常指针参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span>* y = &amp;x;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* a = &amp;x;</span><br><span class="line">	<span class="type">int</span>* <span class="type">const</span> b = &amp;x;</span><br><span class="line">	<span class="built_in">func1</span>(b);</span><br><span class="line">	<span class="comment">//func1(a); 不允许，实参为底层，形参为顶层，想用底层初始化顶层是不被允许的</span></span><br><span class="line">	<span class="built_in">func2</span>(a);</span><br><span class="line">	<span class="built_in">func2</span>(b);</span><br><span class="line">	<span class="built_in">func3</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;顶层const可以用非常亮初始化一个常量对象（形参），反之不行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	*a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;底层const可以用非常亮初始化一个常量对象（形参），反之不行&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//*a=20;		//错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span>* a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;不允许常量初始化一个非常量对象（形参）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	*a = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="引用形参与const">7.2.2 引用形参与const</h6>
<p>常量引用时候我们经常要用到的东西。同<code>const</code>指针形参一样，同样不能修改值。普通引用（即没有<code>const</code>)的限制:</p>
<ul>
<li>不允许实参为const对象（即非常量不能初始化常量对象）</li>
<li>不允许实参为字面值</li>
<li>不能提供类型转换</li>
</ul>
<p>const引用形参却能克服这些限制。但就是不能改变绑定的值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="type">const</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">	<span class="comment">//func1(a) 不允许，普通引用不允许实参为const</span></span><br><span class="line">	<span class="comment">//func1(10) 不允许，普通引用形参不允许实参为字面值</span></span><br><span class="line">	<span class="built_in">func1</span>(b);</span><br><span class="line">	<span class="built_in">func2</span>(a);</span><br><span class="line">	<span class="built_in">func2</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;这里是func1&quot;</span>&lt;&lt;endl;</span><br><span class="line">	a=<span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;这里是function2&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//a=40;		不允许对const引用的修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="数组形参">7.2.3 数组形参</h6>
<p>因为数组不能被拷贝，所以无法以值传递的方式使用数组参数。但数组会被转换为指针，所以当我们传递一个数组时，实际上传递的指向数组首元素的指针。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这三个函数声明均为const int*类型。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="comment">//还有数组引用形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> (&amp;arry)[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="可变形参函数">7.2.4 可变形参函数</h6>
<p>有时我们无法预知应该向函数传递几个参数，所以可使用可变形参函数.c++11新标准提供了以下主要方法：</p>
<ul>
<li>若所以实参类型相同，可传递一个名为initializer_list的标准库类型</li>
<li>若实参类型不同，编写一个可变参数模板</li>
<li><strong>c++还有一种形参类型（省略符），用它来传递可变数量的实参。</strong></li>
</ul>
<p><strong>1.initializer_list形参</strong></p>
<p>它是一种标准库类型，定义在同名（initializer_list)头文件中。它提供的操作有：</p>
<p><img src="/c-primer前部分/initializer.png" width="600"> 和vector不同的是，initializer_list对象中的元素是常量值，我们无法修改它们的值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">msg</span><span class="params">(initializer_list&lt;string&gt; li)</span>	<span class="comment">//均为string类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	functionbody;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.省略符形参</strong></p>
<p>省略符形参应该仅仅用于c和c++的通用的类型（因为省略符的实际就是为了c++能够访问特殊c代码所设计的，这些代码使用了varargs的c标准库功能）。使用参数是用位置数字代号作为形参变量 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略符形参只有两种形式：</span></span><br><span class="line"><span class="built_in">foo</span>(parm_list,...);	<span class="comment">//指定部分形参类型</span></span><br><span class="line"><span class="built_in">foo</span>(...);			<span class="comment">//均无指定</span></span><br><span class="line"><span class="comment">//用数字作为代号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="返回值">7.3返回值</h5>
<ul>
<li>①c++11新标准规定，函数可以返回花括号包围的列表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">	....<span class="comment">//expect\actual为string对象</span></span><br><span class="line">	<span class="keyword">if</span>(expected.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(expected==actual)</span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="string">&quot;funtionX&quot;</span>,<span class="string">&quot;OK&quot;</span>&#125;;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>c++11新标准规定，main函数的类型如果不为void,也可没有return语句（编译器会自己添加return 0;)</li>
</ul>
<h5 id="函数重载">7.4函数重载</h5>
<p>如果同一作用域内的几个<strong>函数名字相同但形参列表不同，称为重载函数</strong>（函数的重载应该使用于那些操作非常类似的函数）,返回值也可不同（但不是必须）。如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* beg,<span class="type">const</span> <span class="type">int</span> *end)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> aa[],<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure> 这些重载函数形参类型不同，当调用这些函数时，编译器会根据传递的实参类型推断调用的是哪个函数。</p>
<h6 id="重载和const形参">7.4.1 重载和const形参</h6>
<ul>
<li>拥有顶层const和没有顶层const的形参无法区分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>	<span class="title">lookup</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>	<span class="title">lookup</span><span class="params">(<span class="type">const</span> <span class="type">int</span>)</span></span>;	<span class="comment">//不能识别，不要这样用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>	<span class="title">lookup</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> )</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>底层const可区分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;	<span class="comment">//重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">int</span> *）；</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> lookup(<span class="type">const</span> <span class="type">int</span>*);	<span class="comment">//重载</span></span></span></span><br></pre></td></tr></table></figure>
<h6 id="const_cast和重载">7.4.2 const_cast和重载</h6>
<p>const_cast在重载函数的情景中最有用。例子如下 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">shorterString</span><span class="params">(<span class="type">const</span> string&amp; s1,<span class="type">const</span> string&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size&lt;=s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上面这个参数和返回类型都是<code>const string</code>的引用。当我们传入的参数时非常量的时候，我们当然希望返回的是<code>string</code>的引用，而不是<code>const string</code>的引用，这时候就用到显示类型转换<code>const_cast</code>.改进如下：重载另一<code>shorterString</code>函数: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">shorterString</span><span class="params">(string&amp; s1,string&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span>&amp; r=<span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其参数和返回值均为<code>string&amp;</code>。在该函数内部调用<code>const</code>的版本，参数强制转换为<code>const string&amp;</code>型 执行后返回后<code>auto&amp; r</code>。无<code>const</code>版本再强制转为<code>string&amp;</code>。 你觉得很不应该，直接在无<code>const</code>函数实现不就行了吗，其实不是的，这样写是为了方便代码的维护,要修改的时候我们只有修改<code>const</code>版本</p>
<h5 id="特殊用途语言特性">7.5特殊用途语言特性</h5>
<p>这里介绍<strong>默认实参、内联函数和constexpr函数</strong>。</p>
<h6 id="默认实参">7.5.1 默认实参</h6>
<p>某些函数再多次调用时都被赋予一个相同值，这个反复出现的值就为默认实参。其声明定义如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> ht=<span class="number">24</span>,<span class="type">int</span> wid=<span class="number">10</span>,<span class="type">char</span>  backgrd=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">typedef</span> string::szie_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht=<span class="number">24</span>,sz wid=<span class="number">10</span>,<span class="type">char</span>  backgrd=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数时：</span></span><br><span class="line">string window;</span><br><span class="line">window=<span class="built_in">screen</span>();		<span class="comment">//默认实参</span></span><br><span class="line">window=<span class="built_in">screen</span>(<span class="number">60</span>);	<span class="comment">//等价于screen(60,10,&#x27; &#x27;);</span></span><br><span class="line">window=<span class="built_in">screen</span>(<span class="number">60</span>,<span class="number">10</span>,<span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h6 id="内联函数和constexptr函数">7.5.2 内联函数和constexptr函数</h6>
<p>因为调用函数要先保存寄存器，并在返回时恢复。有一定的时间开销。而内联函数可避免调用函数的开销。关键字是<code>inline</code>. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string&amp; <span class="title">shorterString</span><span class="params">(<span class="type">const</span> string&amp; s1,<span class="type">const</span> string&amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size&lt;=s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>constexptr函数</code>:指能用于常量表达式的函数。函数的返回类型及所有形参的的类型都是字面值，函数体中有且仅有一条return语句。</p>
<h5 id="lambda表达式">7.6 lambda表达式</h5>
<p>我们可以向一个算法传递任何类别可调用对象，如果可以对其使用调用运算符()，则称它为可调用的。c++中可调用对象有函数、函数指针、重载函数调用运算符类、<code>lambda</code>表达式。</p>
<p><strong>一个<code>lambda</code>表达式表示一个可调用的代码单元，可将其理解为一个未命名的内联函数。一个<code>lambda</code>具有一个返回类型、一个参数列表和一个函数体(同函数一样）。与函数不同的是，<code>lambda</code>可定义在函数内部，有捕获列表：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list)-&gt;<span class="keyword">return</span> type&#123;	function body 	&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>captue list</code>（捕获列表）是一个lambda所在函数中定义的局部变量列表（通常为空）</li>
<li><code>return type</code>为返回类型，</li>
<li><code>parameter list</code>为参数列表、</li>
<li><code>function body</code>为函数体</li>
</ul>
<p>可以忽略参数列表（等价于指定一个空参数列表）和返回类型（此时根据代码推断，有return返回相应类型，没有为void)，<strong>但必须包含捕获列表和函数体：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=[] &#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;endl;	<span class="comment">//调用时也有调用运算符()</span></span><br><span class="line"><span class="comment">//lambda不能设默认参数，因此一个lambda调用时实参数目必须与形参一一对应。</span></span><br><span class="line">[](<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="捕获规则">7.6.1 捕获规则</h6>
<p>lambda表达式的捕获列表有值捕获和引用捕获 <img src="/c-primer前部分/lambda.png" width="700"> <strong>我们可以在捕获列表中写一个<code>&amp;</code>或者<code>=</code>，指示编译器推断捕获列表。<code>&amp;</code>告诉编译器采用捕获引用方式，<code>=</code>则表示采用值捕获方式</strong>。我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：</p>
<ul>
<li>当混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个<code>&amp;</code>或<code>=</code>（必须隐式）</li>
<li>当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">biggies</span><span class="params">(vector&lt;string&gt; &amp;words,vector&lt;string&gt;::size_type sz,ostream &amp;os,string c=<span class="string">&quot; &quot;</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//words,sz c采用值捕获，os为引用捕获</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[=,&amp;os](<span class="type">const</span> string &amp;s)&#123;os&lt;&lt;s&lt;&lt;c&lt;&lt;ends;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。<strong>如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字<code>mutable</code></strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">auto</span> k=[s]()<span class="keyword">mutable</span>-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> s++;&#125;;</span><br><span class="line">	<span class="keyword">auto</span> j=<span class="built_in">k</span>();		<span class="comment">//j=3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="类">8.类</h4>
<p>c++语言中，使用类定义自己的数据类型，是我们更容易编写、调试和修改程序。类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>。 <strong>数据抽象是一种依赖接口和实现的分离编程技术</strong>。类的接口包括用户所能执行的操作，类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。要实现数据抽象，首先要定义抽象数据类型。</p>
<h5 id="定义抽象数据类型">8.1 定义抽象数据类型</h5>
<p><strong>成员函数的声明必须在类的内部</strong>，它的定义既可以在类的内部也可以在类的外部。而作为接口组成部分的非成员函数，他们的定义和声明都在类的外部。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;		<span class="comment">//Sales_data类</span></span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> 	BookNo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	std::string 	BookNo;</span><br><span class="line">	<span class="type">unsigned</span>  units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure> 上面这个类成员函数有<code>isbn、combine、avg_prince</code>。其中<code>isbn</code>在类的内部定义，<code>combine</code>和<code>avg_price</code>定义在类外部（声明于类内部）。</p>
<h5 id="成员函数">8.2 成员函数</h5>
<h6 id="const修饰函数---常量成员函数">8.2.1 const修饰函数---常量成员函数</h6>
<ul>
<li>在类中将成员函数修饰为<code>const</code>表明在该函数体内，<strong><em>不能修改对象的数据成员而且它不能调用非const函数</em></strong>。</li>
<li><p><strong>为什么不能调用非<code>const</code>函数</strong>:因为非<code>const</code>函数可能修改数据成员，<code>const</code>成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数。</p></li>
<li><p>同时这里的<code>const</code>也有修改隐式<code>this</code>指针的作用，使<code>T*const register this</code>为<code>const T*const register this</code>，这样<code>this</code>指针就能绑定到一个常量（<code>const</code>）对象上。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;	<span class="comment">//set函数设置值，不能声明为const函数</span></span><br><span class="line">			i=n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span><span class="type">const</span></span>&#123;		<span class="comment">//get函数只取值，声明为const符合规范设计</span></span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h6 id="this指针">8.2.2 this指针</h6>
<p>上面提到了<code>this</code>指针，它指的是对于类的内部成员函数，其参数列表的第一若不显式写出总是隐藏有一个<code>this</code>指针:</p>
<ul>
<li><strong><em>成员函数this指针：成员函数通过一个名为this的隐式参数来访问调用它的那个对象</em></strong>。<code>this</code>指针是一个指向当前对象的指针，或者说当前对象的地址。</li>
<li><strong>this指针只能在一个类的非静态成员函数中使用（全局函数、静态函数不能使用）</strong>。</li>
<li>C++的非静态成员函数的第一个默认并且被隐藏的参数是<code>T *const register this</code>。比如我们在<code>Student</code>这个类里声明这样一个函数：<code>int SetName(const char *name)</code>;其实编译器处理的时候会变为 <code>int SetName(Student *const register this, const char *name)</code>;</li>
</ul>
<h6 id="类的静态函数没有this指针">8.2.3 类的静态函数没有this指针</h6>
<p><strong>静态函数如同静态变量一样，他不属于具体的哪一个对象而是属于类</strong>，静态函数表示了整个类范围意义上的信息。<strong>而this指针却实实在在的对应一个对象，所以this指针不能被静态函数使用了</strong>，同理，全局函数也一样。</p>
<p><strong><em>注意：</em></strong>在静态成员函数的实现中不能直接引用类中说明的非静态成员，但可以引用类中说明的静态成员。非静态成员函数即可以引用类中静态成员和非静态成员（这点非常重要）</p>
<h6 id="this指针什么时候创建的">8.2.4 this指针什么时候创建的</h6>
<p><strong><code>this</code>在成员函数的开始执行前构造的，在成员的执行结束后清除</strong>。<code>this</code>指针只有在成员函数中才有定义。因此你获得一个对象后，不能通过对象使用<code>this</code>指针。所以，我们也无法知道一个对象的this指针的位置（只有在成员函数里才有<code>this</code>指针的位置，<code>this</code>指针存于寄存器中）。</p>
<p>当然，在成员函数里，是可以知道<code>this</code>指针的位置的（可以<code>&amp;this</code>获得)，也可以直接使用的: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个返回this对象的函数：</span></span><br><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">	units_sold+=rhs.units_sold;		<span class="comment">//把rhs的成员加到this对象的成员上</span></span><br><span class="line">	revenue+=rhs.revenue;			<span class="comment">//同理</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;					<span class="comment">//返回调用该函数的对象（引用）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="类相关的非成员函数">8.3类相关的非成员函数</h5>
<p>类的定义常常需要辅助函数（非成员函数），它们的声明要与类声明在同一头文件中。最常用的就是输入输出的非成员函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream &amp;is,Sales_data&amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> price=<span class="number">0</span>;</span><br><span class="line">	is&gt;&gt;item.BookNO&gt;&gt;item.units_sold&gt;&gt;price;</span><br><span class="line">	item.revenue=price*item.units_sold</span><br><span class="line">	<span class="keyword">return</span> is</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="built_in">print</span>(ostream &amp;os,Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	os&lt;&lt;item.<span class="built_in">isbn</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.units_sold&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">	&lt;&lt;item.revenue&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.<span class="built_in">avg_price</span>();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Sales_data sum=lhs;		<span class="comment">//lhs拷贝给sum</span></span><br><span class="line">	sum.<span class="built_in">combine</span>(rhs);		<span class="comment">//将rhs的数据加到sum中，sum存放lhs和rhs和</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="类的静态成员">8.4类的静态成员</h5>
<h6 id="什么是静态成员声明">8.4.1 什么是静态成员（声明）</h6>
<p><strong>有时候我们需要一些成员与类本身直接相关</strong>，而不是与类的各个对象保持关联。在该成员变动时，希望每个对象都能使用新值，就如银行利率。这个时候就引入了类的静态成员 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			amount+=amoubt*interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">static</span>	<span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string owner;</span><br><span class="line">		<span class="type">double</span> amount;</span><br><span class="line">		<span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="title">doubleinitRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 类的静态成员存在于任何对象之外，对象中不包含任何与静态成员有关的数据（），<strong>因此<code>Account</code>的对象只包含了两个数据成员<code>owner和amount</code>。<code>interestRate</code>被所有对象共享。</strong> 静态成员函数也不与对象绑定，它们不包含<code>this</code>指针，所以静态成员函数不能被声明为<code>const</code>。</p>
<h6 id="定义静态成员及类外初始化静态成员变量和静态成员函数">8.4.2 定义静态成员及类外初始化（静态成员变量和静态成员函数）</h6>
<p>和其他成员函数一样，可在内部定义也可在外部定义（在外部时，不可重复使用static关键字，static只出现在内部声明语句） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Account::rate</span><span class="params">(<span class="type">double</span> newRate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	interestRate=newRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 静态成员不属于类的对象，因此它们并不是在创建对象时被定义的，<strong>即它们不是由类的构造函数初始化的</strong>。<strong>类似于全局变量，静态数据成员定义在任何函数之外，它一旦被定义，就一直存在于程序整个生命周期，它只能被定义一次</strong>。（一般在类外初始化） 如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> Account::interestRate=<span class="built_in">initRate</span>();		<span class="comment">//定义并初始化一个静态成员</span></span><br></pre></td></tr></table></figure></p>
<h6 id="使用静态成员">8.4.3 使用静态成员</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用域运算符直接访问静态成员</span></span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    r=Account::<span class="built_in">rate</span>();</span><br><span class="line"><span class="comment">//使用类的对象、引用或者指针访问</span></span><br><span class="line">	Account ac1;</span><br><span class="line">	Account *ac2=&amp;ac1;</span><br><span class="line">	r=ac1.<span class="built_in">rate</span>();</span><br><span class="line">	r=ac2-&gt;<span class="built_in">rata</span>();</span><br><span class="line">成员函数不需要使用域运算符，可直接使用静态成员</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			amount+=amoubt*interestRate;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> interestRate;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构造函数">8.5 构造函数</h5>
<p>每个类都定义了它的对象被初始化的方式，类是通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数就是<strong>构造函数</strong>。<strong>构造函数的任务就是初始化对象的数据成员，只要类的对象被创建，就会执行构造函数----&gt;拷贝。</strong></p>
<ul>
<li><strong>构造函数</strong>：构造函数的名字与类名相同，没有返回(值）类型，不能被声明为<code>const</code>（const对象执行构造函数时，执行完毕才成为const对象）。</li>
<li><strong>拷贝和赋值：</strong>拷贝是构造行为，状态取决于用于构造的对象；赋值是对已构造对象进行状态更新。赋值侧重于更新，构造侧重于构造。</li>
</ul>
<h6 id="默认构造函数--也可写成默认实参的构造函数还是默认构造函数">8.5.1 默认构造函数--&gt;也可写成默认实参的构造函数（还是默认构造函数）</h6>
<p>在没有为对象提供初始值，类没有显示地定义任何构造函数，编译器会为我们隐式的定义一个构造函数，称为合成的默认构造函数。其初始化规则：</p>
<ul>
<li>类内如果存在初始值，用它来初始化成员</li>
<li>没有，默认初始化（为0）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;		<span class="comment">//Sales_data类</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Sales_data</span>()=<span class="keyword">default</span>;	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> std::stsring&amp; s,<span class="type">unsigned</span> n,<span class="type">double</span> p):</span><br><span class="line">		<span class="built_in">BookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n) &#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> BookNo;&#125;</span><br><span class="line">	<span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	std::string BookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>c++11新标准，可以通过=default来要求编译器生成合成的默认构造函数（default在类内部声明为内联的，在外部就不是）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;</span><br></pre></td></tr></table></figure> 同时上面这条语句中，在<strong>初始化列表</strong>中有数据成员<code>units_sold,revenue</code>被忽略，那么他等价于<code>Salse_data(const std::string&amp; s):BookNo(s)，units_sold(0),revenue(0) &#123;&#125;;</code></p>
<h6 id="构造函数初始值列表">8.5.2 构造函数初始值列表</h6>
<ul>
<li>冒号和花括号之间的部分。其负责为新创建的对象的一个或几个数据成员赋值。列表是是类内置成员的名字，其()括号内就为初始值（注意不是赋值而是初始化）。</li>
<li><strong><em>注意：列表对成员变量的初始化是按其类内声明顺序初始化，而不是列表顺序。</em></strong></li>
<li>使用初始化列表是直接初始化,因此具有更高的效率，而在函数体内是先初始化再赋值。存在效率的差异，如果是类对象，那么效率更低</li>
<li>构造函数的初始值列表解决了初始值必不可少的三种情况：</li>
</ul>
<ol type="1">
<li><strong>一是const或者引用成员，他们必须被初始化，因为在函数体内是赋值而不是初始化</strong>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况1</span></span><br><span class="line">Class  Test&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Test</span>(<span class="type">int</span> ii);	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> ci;		<span class="comment">//未被初始化</span></span><br><span class="line">		<span class="type">int</span> &amp;ri;			<span class="comment">//未被初始化</span></span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> cr=<span class="number">10</span>;	<span class="comment">//已类内初始化</span></span><br><span class="line">&#125;;</span><br><span class="line">Test:<span class="built_in">Test</span>(<span class="type">int</span> ii)&#123;</span><br><span class="line">	i=ii;</span><br><span class="line">	ci=ii;		<span class="comment">//错误，不能给const赋值</span></span><br><span class="line">	ri=i;			<span class="comment">//错误，引用必须创建时被初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.<strong>二是当成员属于某种类类型且该类型没有默认构造函数，也必须将这个成员初始化。</strong>尝试在内部通过赋值的方式初始化，但没有默认的构造函数，即参数列表为空，那么test就会首先被默认初始化，但是Test类没有默认的构造函数从而出现错误，所以初始化只能放在列表中。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;	<span class="comment">//无默认构造函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Test&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mytest</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mytest</span>():<span class="built_in">test</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#123;       <span class="comment">//初始化ok</span></span><br><span class="line">        <span class="comment">//test(Test(1,2,3));//error: no match for call to &#x27;(Test) (Test)&#x27;</span></span><br><span class="line">        <span class="comment">//test=Test(12,3,4);//error: no matching function for call to &#x27;Test::Test()&#x27;</span></span><br><span class="line">        <span class="comment">//test(1,2,3);//error: no match for call to &#x27;(Test) (int, int, int)&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Test test; <span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 3.<strong>三是需要初始化的数据成员是对象(存在继承关系，继承时调用基类构造函数)原因同样是创建对象时，要初始类成员的每一个成员</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Test</span> (<span class="type">int</span> x)&#123; int_x = x;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt; int_x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> int_x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mytest</span>:<span class="keyword">public</span> Test&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mytest</span>():<span class="built_in">Test</span>(<span class="number">110</span>)&#123;<span class="comment">//打印出110</span></span><br><span class="line">      <span class="comment">//Test(110);  //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用 。不报错但打印随机数：14887136</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：从无到有叫初始化，初始化（调用拷贝构造函数）创建了新对象；赋值（调用赋值操作符）没有创建新对象，而是对已有的对象赋值。</em></strong></p>
<h6 id="类外构造函数的定义">8.5.3 类外构造函数的定义</h6>
<p>以istream为参数的的构造函数因为要执行一些实际操作。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非成员函数</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">((istream &amp;is,Sales_data&amp; item)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">double</span> price=<span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	is&gt;&gt;item.BookNO&gt;&gt;item.units_sold&gt;&gt;price;</span></span></span><br><span class="line"><span class="params"><span class="function">	item.revenue=price*item.units_sold</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">return</span> is</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//构造函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">Sales_data::Sales_data(std::istream &amp;is)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	read(is,*<span class="keyword">this</span>);	<span class="comment">//read函数的作用是从is中读取一条交易信息后存入this</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure> 该构造函数的初始值列表是为空的，但对象的成员仍能够初始化。第二个参数的<code>this</code>是一个<code>Sale_data</code>对象的引用。 其他的诸如<strong>拷贝构造、赋值构造、析构和移动构造</strong>放在后面的<strong>拷贝控制</strong>详细讲述。</p>
<h6 id="委托构造函数">8.5.4 委托构造函数</h6>
<p>c++11新标准扩展了构造函数初始值的功能，使得我们可以定义委托构造函数。所谓的委托构造函数其实就是一个构造函数的任务交给零一构造函数去完成， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">		<span class="built_in">Sales_data</span>(sting s,<span class="type">unsigned</span> cnt,<span class="type">double</span> price):</span><br><span class="line">			<span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(cnt),<span class="built_in">revenue</span>(cny*price)&#123;&#125;</span><br><span class="line">		<span class="comment">//委托构造函数</span></span><br><span class="line">		<span class="built_in">Sales_data</span>():<span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">		<span class="built_in">Sales_data</span>(string s):<span class="built_in">Sales_data</span>(s,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="转换构造函数">8.5.5转换构造函数</h6>
<p>如果构造函数只接受一个实参，<strong>那么实际上定义了转换为此类类型的隐式转换机制</strong>。这种构造函数称为<strong>转换构造函数</strong>，但只允许一步类类型转换。如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;<span class="comment">//这个构造函数。支持了转换构造,参数为const</span></span><br></pre></td></tr></table></figure> 在类中我们定义了一个<code>Sales_data &amp;combine(const Sales_data&amp;);</code>函数,参数为<code>const</code>，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data item;	<span class="comment">//执行了默认构造函数</span></span><br><span class="line">string null_book=<span class="string">&quot;9-999-999&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(null_book);<span class="comment">//在这里combine函数的参数时Sales_data类型，因此这里用单参转换构造函数构造了一零时Sales_data对象，即null_book隐式转换为Sales_data类型</span></span><br></pre></td></tr></table></figure> 在这里<code>combine</code>函数的参数实际是<code>Sales_data</code>类型，因此这里调用单参转换构造函数<code>Salse_data(const std::string&amp; s):BookNo(s)&#123;&#125;;</code>构造了一零时<code>Sales_data</code>对象，即null_book隐式转换为Sales_data类型,然后在执行该语句。 <strong><em>注意：形参必须声明为<code>const</code></em></strong></p>
<h6 id="深浅拷贝区别">8.5.6 深浅拷贝区别</h6>
<p><strong>背景：</strong></p>
<ol type="1">
<li><strong>默认的拷贝构造函数进行了简单的赋值操作（浅拷贝）</strong></li>
<li><strong>浅拷贝的问题：当多个对象执行默认拷贝构造函数时会多次释放同一个分配的内存空间</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> age)&#123;</span><br><span class="line">		pName=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName,name);</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Student</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(pName);</span><br><span class="line">			pName=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;小明&quot;</span>，<span class="number">22</span>)</span>；</span></span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;		<span class="comment">//执行默认拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p>如下图，两个对象的<code>name</code>指针指向同一块内存。在释放时，这会导致同一块内存会被释放两次，这是不允许的。 <img src="/c-primer前部分/copy.png" width="600" align="middle"> <strong>深拷贝解决浅拷贝问题：自己写拷贝构造函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> Student &amp;stu)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自己的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//1.申请空间</span></span><br><span class="line">	pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(stu.pName) + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//2.拷贝数据</span></span><br><span class="line">	<span class="built_in">strcpy</span>(pName, stu.pName);</span><br><span class="line">	age = stu.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="访问控制和封装">8.6 访问控制和封装</h5>
<h6 id="封装">8.6.1 封装</h6>
<p>我们为类定义了接口，但并没有机制制约用户使用这些接口。使用访问说明符加强类的封装性：</p>
<ul>
<li><code>public</code>:<code>public</code>说明符之后的成员在整个程序可被访问</li>
<li><code>private</code>:可以被类的成员函数访问，但不能被使用该类的代码访问。</li>
<li><code>protected</code>:被该关键词修饰的成员不能被外部访问，但是能够给成员函数和继承的类访问</li>
<li><code>class</code>:<code>class</code>和<code>struct</code>一样的作用,声明一个类，唯一不同是定义在第一个访问说明符之前的成员的访问权限不同<code>struct</code>是<code>public</code>,<code>class</code>是<code>private</code></li>
</ul>
<h6 id="友元">8.6.2 友元</h6>
<p>在真正的项目中，有一些一起声明在头文件的类的非成员函数，它们作为类的接口的一部分，想要访问该类的私有成员，但不是类的的成员，因此无法做到，而友元可以很好的解决这类问题：</p>
<p><strong>类可以允许其他类或者函数访问它的非公有成员，只要让这些类或函数成为该类的友员(friend)即可。友元函数必须被声明过。</strong>友元分为<strong>非成员函数友元、类友元和成员函数友元</strong>。</p>
<ul>
<li><p>非成员函数友元：即非成员函数在类内部声明<code>friends</code>。增加一条friend关键字开头的函数声明即可。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;		<span class="comment">//Sales_data类</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//三个非成员函数声明友元</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="built_in">Sales_data</span>()=<span class="keyword">default</span>;	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">Salse_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">BookNo</span>(s)&#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> std::stsring&amp; s,<span class="type">unsigned</span> n,<span class="type">double</span> p):</span><br><span class="line">	<span class="built_in">BookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n) &#123;&#125;;</span><br><span class="line">	<span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> BookNo;&#125;</span><br><span class="line">	<span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span>  <span class="type">const</span></span>;</span><br><span class="line">	std::string BookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li>类友元：即在类A中声明另一个类B为它的友元，那么类B可以访问类A的私有成员，但是A不能访问B的私有成员，如果要访问，那么应该也罢A声明为B的友元，即友元使单向的。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	friends <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearA</span><span class="params">()</span></span>;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>成员函数友元:即将类A中声明一个类B的函数为友元，该函数能够访问A的私有成员 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">B::clearB</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong><em>注意:要使某个类成员函数为另一类的友元，则必须组织程序的结构使声明和定义符合</em></strong></p>
<ol type="1">
<li>首先要定义B类，其中声明<code>clearB</code>函数但不定义。（在<code>clearB</code>使用<code>A</code>的成员之前必须先声明<code>A</code>）</li>
<li>定义<code>A</code>类，包括对<code>clearB</code>的友元声明</li>
<li>最后定义<code>clearB</code></li>
</ol>
<h5 id="类的其他特性">8.7 类的其他特性</h5>
<h6 id="成员函数的重载">8.7.1 成员函数的重载</h6>
<p>成员函数可支持重载，参数不同即可以。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Screen</span>()=defalut;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">(<span class="type">char</span> s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(<span class="type">char</span> s,<span class="type">size_t</span> i)</span></span>;	<span class="comment">//成员函数重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="内联函数">8.7.2 内联函数</h6>
<p>在类中成为内联函数有两种：</p>
<ul>
<li>在类内定义的（隐式内联）</li>
<li>有inline关键字(显示内联）</li>
</ul>
<h6 id="可变数据成员">8.7.3 可变数据成员</h6>
<p>在类中，存在<code>const</code>函数防止类内成员在此函数的修改，但有时候对于有些成员我们希望在任何函数都能够得到可变的保证，即使是在<code>const</code>函数总，因此出现了<code>mutable</code>关键字。只有被该关键字修饰的成员变量无论在类的哪个成员函数内都能得到可修改的保证： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">get</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">		acces_time++;</span><br><span class="line">		<span class="keyword">return</span> acces_time;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">size_t</span> acces_time=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="聚合类">8.8 聚合类</h5>
<p>当一个类满足下述条件使，是聚合类（使用户可以直接访问其成员）：</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，也没有virtual函数。</li>
</ul>
<h4 id="io库">9.IO库</h4>
<h5 id="io类">9.1 IO类</h5>
<p>IO库设施和主要的类包括：</p>
<ul>
<li><code>ostream</code>类型，提供输出操作;<code>istream</code>类型，提供输入操作</li>
<li><code>cin</code>,一个<code>istream</code>对象，从标准输入读取数据;<code>cout</code>,一个<code>ostream</code>对象，向标准输出写入数;<code>cerr</code>，一个<code>ostream对</code>象，用于输出程序错误信息，写入到标准错误</li>
<li><code>&gt;&gt;</code>运算符，用于一个<code>istream</code>对象读取输入数据;<code>&lt;&lt;</code>运算符，用于一个<code>ostream</code>对象写入输出数据</li>
<li><code>getline()</code>,从一个给的的<code>istream</code>读取一行数据，存入一个给定的<code>string</code>对象。<code>getline(cin,s1)</code>; 读取内容，直到遇到换行符（换行符也被读取,但<code>s1</code>不存取换行符）。</li>
</ul>
<p><img src="/c-primer前部分/IO.png" width="600"></p>
<ul>
<li><code>iostream</code>定义了读写了基本类型</li>
<li><code>fstream</code>定义了读写命名文件的类型</li>
<li><code>sstream</code>定义了读写内存<code>string</code>对象的类型</li>
</ul>
<h5 id="条件状态">9.2 条件状态</h5>
<p>以前用条件判断语句<code>while(cin&gt;&gt;i);        //EOF时结束，即达到了文件结束跳出循环（ctrl+z)</code>。来判断流是否有效，但我们无法知道流的具体状态。所以有如下IO库条件状态。 IO库定义了一个与机器无关的<code>iostate</code>类型。它提供了表达流状态的完整功能<code>（badbit、failbit、eofbit、goodbit</code>:</p>
<ul>
<li><code>badbit</code>表示发生系统级的错误，如不可恢复的读写错误。通常情况下一旦<code>badbit</code>被置位，流就无法再使用了--4（代表数字）。</li>
<li><code>failbit</code> 表示发生可恢复的错误，如期望读取一个数值，却读出一个字符等错误。这种问题通常是可以修改的，流还可以继续使用---2。</li>
<li>当到达文件的结束位置时，<code>eofbit</code> 和 <code>failbit</code> 都会被置位---1。</li>
<li><code>goodbit</code> 被置位表示流未发生错误。如果<code>badbit failbit 和eofbit</code> 任何一个被置位，则检查流状态的条件会失败---0。</li>
</ul>
<p>对应的<code>bad(), fail(), eof(), good()</code>能检查对应位是否被置位，返回1表示被置位。<strong>但是，<code>badbit</code>被置位时，<code>fail()</code>也会返回1。所以使用<code>good()</code>和<code>fail()</code>是确定流能否使用的正确方法</strong>。实际上，流当做条件使用的代码就等价于<code>!fail()</code>。而且<code>eof()</code> 和<code>bad()</code> 操作只能表示特定的错误.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> std::ios;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> m=ios::badbit;			<span class="comment">//4</span></span><br><span class="line">	ios::iostate n=ios::failbit;	<span class="comment">//2</span></span><br><span class="line">	ios::iostate m=ios::eofbit;		<span class="comment">//1</span></span><br><span class="line">	ios_base::iostate p=ios::goodbit;	<span class="comment">//0</span></span><br><span class="line">	<span class="type">int</span> number</span><br><span class="line">	cin&gt;&gt;number;			<span class="comment">//输入字符串 ada</span></span><br><span class="line">	<span class="keyword">auto</span> s=cin.<span class="built_in">rdstate</span>();	<span class="comment">//被置2</span></span><br><span class="line">	cin.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">auto</span> x=cin.<span class="built_in">rdstate</span>();	<span class="comment">//0</span></span><br><span class="line">	cin.<span class="built_in">setstate</span>(s);		<span class="comment">//置2</span></span><br><span class="line">	<span class="keyword">auto</span> y=cin.<span class="built_in">rdstate</span>();	<span class="comment">//为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="管理输出缓冲">9.3 管理输出缓冲</h5>
<p>输出缓存刷新是指数据数据真正写到输出设备和文件，在C++中导致输出缓存刷新的的原因有：</p>
<ul>
<li>程序正常结束，作为<code>main</code>函数的<code>retrun</code>操作的一部分，缓存刷新执行</li>
<li>缓冲区满使，需要刷新，而后新的数据才能继续写入缓冲区</li>
<li>显式调用<code>endl</code>刷新缓冲区</li>
<li>每个输出操作之后，可使用操纵符<code>unitbuf</code>设置流的内部状态，来清空缓冲区。默认下，对<code>cerr</code>是设置<code>unitbuf</code>的，因此对于<code>cerr</code>来说写入到<code>cerr</code>的内容都是立即刷新的</li>
<li>一个输出流可能关联到另一个流。当读写被关联流时，关联到的流的缓冲区会被刷新。比如默认情况下，<code>cin</code>和<code>cerr</code>都被关联到<code>cout</code>,因此读<code>cin</code>或<code>cerr</code>都会导致<code>cout</code>的缓冲区被刷新</li>
</ul>
<p>每个输出流都管理一个缓冲区，最重要得是刷新缓冲区：</p>
<ul>
<li><code>endl</code>:输出操作后刷新缓冲区（会额外输出换行符）</li>
<li><code>flush</code>:输出操作后刷新缓冲区（没有额外字符）</li>
<li><code>ends</code>:输出操作后刷新缓冲区(额外输出空格符）</li>
</ul>
<h6 id="nitbuf操作符每次输出都会flush">9.3.1 nitbuf操作符：每次输出都会flush</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;unitbuf;	<span class="comment">//所有输出操作后会立即刷新缓冲区</span></span><br><span class="line">cout&lt;&lt;nounitflush;	<span class="comment">//回到正常模式</span></span><br></pre></td></tr></table></figure>
<h6 id="关联输入输出流">9.3.2 关联输入输出流</h6>
<p>标准库默认将cout于cin关联在一起。手动关联操作<code>tie</code>，有带参和不带参两个版本 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带参：返回指向输出流得指针</span></span><br><span class="line"><span class="comment">//带参：接受一个ostream得指针参数，将对象关联到该输出流</span></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);</span><br></pre></td></tr></table></figure></p>
<h5 id="文件输入输出">9.4 文件输入输出</h5>
<ul>
<li>ifstream从一个给定文件读取数据</li>
<li>ofstream向一个给定文件写入数据</li>
<li>fstream向给定文件读写</li>
</ul>
<p>除了继承了iostream类型的行为之外，fstream中定义的类型还增加了新的成员来管理与流关联的文件。如下： <img src="/c-primer前部分/fstream.png" width="600"></p>
<h6 id="继承关系">9.4.1 继承关系</h6>
<p>因为<code>fstream</code>继承自<code>iostream</code>，<code>ifstream</code>继承自<code>istream</code>，<code>ofstream</code>继承自<code>ostream</code>。所以由继承机制的：<strong>派生类（继承类）的对象可以当作其基类（被继承类）的对象来使用</strong>。所以在参数为<code>ostream&amp;</code>的函数中允许我们传入一个<code>ofstream</code>型参数，同理其他两个也是一样 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s=<span class="string">&quot;xxx/xxxx/xxx.txt&quot;</span>;</span><br><span class="line">	<span class="function">fstream <span class="title">f</span><span class="params">(s)</span></span>;</span><br><span class="line">	<span class="built_in">func</span>(f);	<span class="comment">//允许传入一个fstream参数，派生类像基类转换</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(iostream&amp; io)</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="open和close">9.4.2 open和close</h6>
<p>若我们定义了一个空文件流对象: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstream file;</span><br></pre></td></tr></table></figure> 我们可以使用<code>open</code>来将<code>file</code>与相应的文件关联起来 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">open</span>(filename);	<span class="comment">//若调用open失败，则failbit会被置位</span></span><br></pre></td></tr></table></figure> 所以我们在执行open后，判断流的状态是一个好习惯，流的状态有效，才能对流执行操作。操作完后手动关闭。当流对象离开作用域域是，流对象会被销毁，结果是会自动调用<code>close</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(file)&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">if</span>(!file.failbit)&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure> <strong><em>注意：<code>ofstream</code>是对写文件，从程序写出到文件，<code>ifstream</code>是从文件读入到程序中。这点不要搞混</em></strong></p>
<h6 id="文件模式">9.4.3 文件模式</h6>
<p>每个流都有关联的文件模式，用来指出如何使用文件。<code>ofstream</code>关联<code>out</code>、<code>ifstream</code>关联<code>in</code>、<code>fstream</code>关联<code>in</code>和<code>out</code>。 <img src="/c-primer前部分/filemode.png" width="600"></p>
<ul>
<li>只可以对<code>ofstream</code>或<code>fstream</code>对象设定<code>out</code>模式;只可以对<code>ifstream</code>或<code>fstream</code>对象设定<code>in</code>模式</li>
<li>只有当<code>out</code>被设定时才可设定<code>trunc</code>模式</li>
<li><code>trunc</code>没被设定，<code>app</code>就可设定。且在<code>app</code>模式下，文件也是<code>out</code>模式下打开(open)</li>
<li>即使没有设定<code>trunc</code>模式，<code>out</code>模式打开（open)的文件也会被截断。所以为保留out模式打开的文件，需要指定<code>app</code>模式（或同时指定in模式）</li>
<li><code>ate</code>和<code>binary</code>模式可用于任何文件流，与任何模式组合。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IOFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fstream isfile;</span><br><span class="line">	ofstream out;</span><br><span class="line">	ifstream in;</span><br><span class="line">	out.<span class="built_in">open</span>(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (out) &#123;	<span class="comment">//判断是否打开成功</span></span><br><span class="line">		out &lt;&lt; <span class="string">&quot;out成功了&quot;</span> &lt;&lt; endl;</span><br><span class="line">		out.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	isfile.<span class="built_in">open</span>(<span class="string">&quot;D:\\test.txt&quot;</span>, std::fstream::app);</span><br><span class="line">	<span class="keyword">if</span> (isfile) &#123;</span><br><span class="line">		isfile &lt;&lt; <span class="string">&quot;isfile也成功了&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string s;</span><br><span class="line">		isfile &gt;&gt; s;</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;	<span class="comment">//打印换行，因为写入时已经指定app在末尾</span></span><br><span class="line">		isfile.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	in.<span class="built_in">open</span>(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (in) &#123;</span><br><span class="line">		string s;</span><br><span class="line">		in &gt;&gt; s;</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">		in.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>out会发生截断是因为每次写操作没有定位到文件末尾，所以防止截断是设定app模式</p>
<h5 id="string流">9.5 string流</h5>
<p><strong>与<code>fstream</code>类似，<code>string</code>也分别继承于<code>iostream</code>。</strong><code>istringstream</code>从<code>string</code>读取数据，<code>ostringstream</code>向<code>string</code>写入，<code>stringstream</code>即可写入也可读取。 <img src="/c-primer前部分/stringstream.png" width="600"></p>
<h5 id="常用成员函数">9.6 常用成员函数</h5>
<h6 id="istream的成员函数">9.6.1 <code>istream</code>的成员函数:</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>() <span class="comment">//一次只能读取一个字符</span></span><br><span class="line">cin.<span class="built_in">get</span>(一个参数) <span class="comment">//读一个字符</span></span><br><span class="line">cin.<span class="built_in">get</span>(两个参数) <span class="comment">//可以读字符串</span></span><br><span class="line">cin.<span class="built_in">getline</span>()<span class="comment">//取一行，换行符丢弃</span></span><br><span class="line">cin.<span class="built_in">ignore</span>()<span class="comment">//忽略</span></span><br><span class="line">cin.<span class="built_in">peek</span>()<span class="comment">//偷窥，只看不从缓冲区拿走</span></span><br><span class="line">cin.<span class="built_in">putback</span>()<span class="comment">//放回缓冲区</span></span><br></pre></td></tr></table></figure>
<h6 id="ostream可用">9.6.2 <code>ostream</code>可用</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过流成员函数实现格式化的输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">99</span>;</span><br><span class="line">	cout.<span class="built_in">width</span>(<span class="number">20</span>);<span class="comment">//设置宽度</span></span><br><span class="line">	cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);<span class="comment">//填充</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::left);<span class="comment">//让数据在左边</span></span><br><span class="line">	cout.<span class="built_in">unsetf</span>(ios::dec);<span class="comment">//卸载十进制</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::hex);<span class="comment">//安装十六进制</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::showbase);<span class="comment">//显示基数</span></span><br><span class="line">	cout.<span class="built_in">unsetf</span>(ios::hex);<span class="comment">//卸载十六进制</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::oct);<span class="comment">//安装八进制</span></span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过控制符来格式化输出，引入头文件iomanip</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//重载了&lt;&lt;运算符</span></span><br><span class="line">	<span class="type">int</span> num = <span class="number">99</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">20</span>);<span class="comment">//设置宽度</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;~&#x27;</span>);<span class="comment">//填充</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::showbase);<span class="comment">//显示基数</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::left);<span class="comment">//让数据在左边</span></span><br><span class="line">	cout &lt;&lt; hex;<span class="comment">//六十进制</span></span><br><span class="line">	cout &lt;&lt; oct;<span class="comment">//八进制</span></span><br><span class="line">	cout &lt;&lt; dec;<span class="comment">//十进制</span></span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="fstrem常用">9.6.3 <code>fstrem</code>常用</h6>
<p>主要读写：其有write()/read()成员函，重载&lt;&gt;运算符 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名:悟空&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Maker <span class="title">m1</span><span class="params">(<span class="string">&quot;悟空&quot;</span>,<span class="number">18</span>)</span>；</span></span><br><span class="line"><span class="function">ofstream ofs</span>;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc | ios::binary);</span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;m1, <span class="built_in">sizeof</span>(Maker));</span><br></pre></td></tr></table></figure> <strong><em>注：当文件读写时，类中的成员变量不要有string类型，因为：</em></strong></p>
<ul>
<li>①string类中有一个成员指针char*,该指针指向存储字符串的空间</li>
<li>②当我们把string类的数据存储到文件中，再读出来时，不能保证指针有效</li>
</ul>
<h4 id="动态内存">10.动态内存</h4>
<h5 id="生命周期">10.1 生命周期</h5>
<p><strong>目前的我们接触到的对象或者静态static都有着严格的生命周期：</strong></p>
<ul>
<li><strong>全局：</strong>程序启动时自动分配，程序结束时销毁</li>
<li><strong>局部对象：</strong>进入其所定义的程序时被创建，离开块时销毁</li>
<li><strong>静态：</strong>第一次使用前分配，程序结束时销毁</li>
</ul>
<p>上述中的变量只使用了静态内存和栈内存。它们会自动创建和销毁。静态内存保存局部static、类static成员以及定义在任何函数之外的变量。栈内存保存定义在函数内的非static对象</p>
<p>除了上述的自动分配外，<strong>c++还支持动态分配对象</strong>。（其生命周期与它们在哪创建无关，只有显式的被释放时，这些对象才会被销毁）。<strong>它们被分配在内存池，称作自由空间或堆。程序用堆来存储动态分配</strong>。</p>
<h5 id="new动态内存">10.2 new动态内存</h5>
<h6 id="直接动态内存管理">10.2.1 直接动态内存管理</h6>
<p>c++的动态内存管理是通过一对运算符来完成：</p>
<ul>
<li><code>new</code>,在动态内存中为对象分配空间并返回一个指向该对象的指针</li>
<li><code>delete</code>,接受一个动态对象的指针，销毁该对象，并释放关联的内存。</li>
</ul>
<p>不再使用的动态内存应及时释放，否则会造成内存泄漏。释放<code>delete</code>的时机要适宜，否则在还有指针引用内存的时候释放，会导致引用非法内存的指针错误.<strong>内存泄漏：分配内存使用完毕后不释放将引起内存泄漏，会榨干内存。 相对于智能指针，直接管理内存的类与使用智能指针的类不同，他们不能依赖类拷贝、赋值和销毁操作的任何默认定义。</strong>虽然如此，但有时候我们不得不用的<code>new与delete</code>。在后面我们还会介绍跟高级的内存分配工具<code>allocator类</code></p>
<h6 id="使用new动态分配和初始化对象">10.2.2 使用new动态分配和初始化对象</h6>
<p>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是<strong>返回一个指向该对象的指针</strong>。默认情况下，动态分配的对象是默认初始化的，这意味着<strong>内置类型或组合类型的对象的值是未定义的，而类类型对象将默认构造函数进行初始化</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *ps=<span class="keyword">new</span> string;	<span class="comment">//初始化为空的string。类类型--&gt;默认构造,等价于与值初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>;	<span class="comment">//p指向一个动态分配、未初始化的无名对象。内置类型--&gt;值初始化</span></span><br></pre></td></tr></table></figure> 也可以直接初始化一个动态分配的对象： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line">string *ps=<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;trluper&quot;</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;* pv=<span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure> <strong><em>注意：对于内置类型，注意值初始化和默认初始化的区别：</em></strong></p>
<ul>
<li>对于定义了自己的构造函数的类类型（如string），要求值初始化是没有意义的，因为不管采用什么形式，对象都会通过默认构造函数来初始化；</li>
<li>对于内置类型，值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。</li>
<li>对于类中那些依赖于编译器合成的默认构造函数的内置类型对象，如果它们未在类内初始化，它们的值也是未定义的</li>
</ul>
<p>如果我们提供了一个括号包围的初始化器，就可以使用auto，此时初始化器可以推断我们想要分配的对象的类型，<strong>只有当括号中仅有单一初始化器才能使用auto</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1=<span class="keyword">new</span> <span class="built_in">auto</span>(obj);</span><br><span class="line"><span class="keyword">auto</span> p2=<span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125;;	<span class="comment">//错误，括号中只能有单一初始化器</span></span><br></pre></td></tr></table></figure></p>
<h6 id="动态分片的const对象">10.2.3 动态分片的const对象</h6>
<p><strong>动态分配的const对象必须进行初始化</strong>。对于定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* pci=<span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);		<span class="comment">//显示初始化</span></span><br><span class="line"><span class="type">const</span> string *pcs=<span class="keyword">new</span> <span class="type">const</span> string;		<span class="comment">//隐式</span></span><br></pre></td></tr></table></figure></p>
<h6 id="内存耗尽">10.2.4 内存耗尽</h6>
<p>默认情况下，<strong>如果<code>new</code>不能分配所要求的内存空间，会抛出一个类型为<code>bad_alloc</code>的异常</strong>。我们也可以改变使用<code>new</code>的方式来阻止它抛出异常（称为定位new)。<code>bad_alloc</code>和<code>nothrow</code>都定义在头文件<code>new</code>中： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> *p1=<span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//如果分配失败，会抛出一个类型为`bad_alloc`的异常</span></span><br><span class="line"><span class="type">int</span> *p2=<span class="built_in">new</span>(nothrow) <span class="type">int</span>;<span class="comment">//如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure></p>
<h6 id="释放内存">10.2.5 释放内存</h6>
<p><code>delete</code>表达式接受一个指针，指向我们想要释放的对象:<code>delete p</code>。 <strong>指针值和<code>delete</code>：</strong>传递给<code>delete</code>的指针必须指向动态分配的内存，或者是一个空指针。释放一块并<code>非new</code>分配的内存，或者将相同的指针值释放多次，其行为是未定义的。虽然一个<code>const对象</code>的值不能被改变，但它本身是可以被销毁的.<code>delete</code>条件有：</p>
<ul>
<li>应与<code>new</code>配对使用，既只能释放<code>new</code>分配得内存</li>
<li>不要再次释放已经释放得内存</li>
<li>如果使用<code>new[]</code>分配动态数组，应用<code>delete[]</code>释放</li>
<li>对空指针使用<code>delete</code>是安全的</li>
</ul>
<p>不需要再使用该动态分配的内存时，必须释放，否则容易内存泄漏！！以下是两个版本的use_factory函数。（p是已经new分配好的返回指针） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_factory</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//函数结束，不再需要，则释放</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">use_factory</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用p</span></span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//函数结束，仍然需要，则返回后由调用这释放</span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="动态数组">10.2.6 动态数组</h6>
<p>某些应用需要一次性为很对对象分配内存（如vector)。为了支持这种需求，c++语言和标准库提供两者方法：</p>
<ul>
<li>分配和初始化一个对象数组</li>
<li>应用allocator类</li>
</ul>
<p>通常第二种法方会提供更好的性能和更灵活的管理内存能力，我们将在后面介绍，同时<strong>“STL源码剖析”</strong>会更详细。这类我们说说<code>new[]</code></p>
<p><strong>new和数组</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[size];		<span class="comment">//返回的指向第一个元素对象指针</span></span><br><span class="line"><span class="comment">//初始化动态分配对象的数组</span></span><br><span class="line"><span class="comment">//不加括号——默认初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];		<span class="comment">//默认初始化</span></span><br><span class="line"><span class="comment">//大小之后加一对空括号——值初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]();		<span class="comment">//10个值初始化为0</span></span><br><span class="line"><span class="comment">//大小之后跟一个花括号列表——初始化器初始化</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放，使用特殊的delete来释放动态数组，在delete前加上一个空方括号对(方括号必须加上)</span></span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure> 当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。但此指针不能解引用——毕竟它不指向任何元素。</p>
<p><strong><em>注意：</em></strong>我们得到的时数组元素的指针，而不是数组的对象，所以我们不能调用标准库函数中的<code>begin()和end()</code>，也不能使用<code>范围for循环</code>。</p>
<h6 id="placement-new">10.2.7 placement new</h6>
<p><code>placement new</code>相当于C语言中的<code>realloc</code>，在已有空间的基础上，重新分配一个空间，可以不破坏原来数据，也可以把数据全部用新值覆盖。这个操作就是把已有的空间当成一个缓冲区来使用，这样子就减少了分配空间所耗费的时间，因为直接用new操作符分配内存的话，在堆中查找足够大的剩余空间速度是比较慢的。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是在指针p所指向的内存空间创建一个T1类型的对象，但是对象的内容是从T2类型的对象转换过来的,</span></span><br><span class="line"><span class="comment">//就是在已有空间的基础上重新调整分配的空间，类似于realloc函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _construct(T1 * p, <span class="type">const</span> T2&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">new</span>(p) <span class="built_in">T1</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="三种new重要">10.2.8 三种new(重要)</h6>
<p><code>new</code>存在三种操作符，其含义和应用的场景都不同。在这里我们必须再次提到<code>new operator</code>、<code>operator new</code>和<code>operator new</code>三种<code>new</code>。在前面我们介绍的都是具有构造效果的<code>new operator</code></p>
<ul>
<li><p><code>new operator</code>指的就是new操作符，使用它会经过两个步骤：一是调用<code>::operator new</code>申请内存；二是使用类型的构造函数对内存地址进行构造。‘new operator`操作符不能被重载 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classA* p=<span class="keyword">new</span> <span class="built_in">classA</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>operator new</code>操作符是单纯的申请内存，相当于C当中的<code>malloc函数</code>，<code>operator new</code>可以重载。<code>::operator new</code>和<code>::operator delete</code>前面加上<code>::</code>表示全局，使用时就像<code>malloc</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *tmp=(<span class="type">int</span>*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size*<span class="built_in">siezeof</span>(<span class="type">int</span>))));</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>placement new</code>仅仅返回已经申请好内存的指针，它通常应用在对效率要求高的场景下，提前申请好内存，能够节省申请内存过程中耗费的时间</p></li>
</ul>
<h5 id="new-operator与c的malloc的比较">10.3 new operator与C的malloc的比较</h5>
<p>首先我们来看<code>operator new</code>生成的源码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLIBCXX_WEAK_DEFINITION <span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> sz)</span> _<span class="title">GLIBCXX_THROW</span> <span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">void</span> *p;</span><br><span class="line">  <span class="comment">/* malloc (0) is unpredictable; avoid it.  */</span></span><br><span class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>)</span><br><span class="line">    sz = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (__builtin_expect ((p = <span class="built_in">malloc</span> (sz)) == <span class="number">0</span>, <span class="literal">false</span>))<span class="comment">//底层仍然使用malloc</span></span><br><span class="line">    &#123;</span><br><span class="line">      new_handler handler = std::<span class="built_in">get_new_handler</span> ();</span><br><span class="line">      <span class="keyword">if</span> (! handler)</span><br><span class="line">	_GLIBCXX_THROW_OR_ABORT(<span class="built_in">bad_alloc</span>());</span><br><span class="line">      <span class="built_in">handler</span> ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从上面可以看到operator new的内部实现仍然使用<code>malloc</code>，也就不奇怪new的行为像<code>malloc</code>。</p>
<p>这里主要介绍<code>new operator</code>与malloc主要区别如下：</p>
<ul>
<li><code>new operator</code>分配内存按照数据类型进行分配，<code>malloc</code>分配内存按照指定的大小分配；</li>
<li><code>new</code>返回的是指定对象的指针，而<code>malloc</code>返回的是void*，因此malloc的返回值一般都需要进行类型转化。</li>
<li><code>new</code>不仅分配一段内存，而且会调用构造函数，<code>malloc</code>不会。</li>
<li><code>new</code>分配的内存要用<code>delete</code>销毁，<code>malloc</code>要用<code>free</code>来销毁；<code>delete</code>销毁的时候会调用对象的析构函数，而<code>free</code>则不会。</li>
<li><code>new</code>是一个操作符可以重载，内部实现仍然使用<code>malloc</code>这个库函数。</li>
<li><code>malloc</code>分配的内存不够的时候，可以用<code>realloc</code>扩容。new则能使用<code>replacement new</code>方式来到底<code>realloc</code>功能</li>
<li><code>new</code>如果分配失败了会抛出<code>bad_malloc</code>的异常，而<code>malloc</code>失败了会返回<code>NULL</code>。</li>
<li>8、申请数组时： <code>new[]</code>一次分配所有内存，多次调用构造函数，搭配使用<code>delete[]</code>，<code>delete[]</code>多次调用析构函数，销毁数组中的每个对象。而<code>malloc</code>是通过<code>free(p)</code>来释放。</li>
</ul>
<h5 id="shared_ptr智能指针">10.4 shared_ptr智能指针</h5>
<p>为了更安全地使用动态内存，新标准库提供了两种智能指针。智能指针类似于常规指针，<strong>但区别是它负责自动释放所指向的对象：</strong></p>
<ul>
<li><code>shared_ptr</code>,它允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code>，独占一个对象（一个指针指向一个对象）</li>
<li><code>weak_ptr</code>,弱引用，指向<code>shared_ptr</code>所过来的对象</li>
</ul>
<p>上述的三种类型都定义在<code>memory</code>头文件中</p>
<h6 id="shared_ptr类">10.4.1 shared_ptr类</h6>
<p>类似于vector,智能指针也是模板。使用该类的理由有以下几点：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; p1;		<span class="comment">//p1指向string</span></span><br><span class="line">shared_ptr&lt;list&lt;T&gt;&gt; p2;		<span class="comment">//指向int的list</span></span><br></pre></td></tr></table></figure>
<p><img src="/c-primer前部分/shared_ptr.png" width="700"></p>
<h6 id="make_shared函数">10.4.2 make_shared函数</h6>
<p>最安全的分配和使用动态内存的方法是调用该函数。<code>make_shared&lt;T&gt;(args)</code>函数在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hared_ptr&lt;<span class="type">int</span>&gt; p3=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//指向一个值为42的int的shared_ptr</span></span><br><span class="line">shared_ptr&lt;string&gt; p4=<span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">//指向一个值为9999999999的string</span></span><br><span class="line">share_ptr&lt;<span class="type">int</span>&gt; p5=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//指向值初始化为0的int</span></span><br><span class="line"><span class="keyword">auto</span> p5=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//指向值初始化为0的int</span></span><br></pre></td></tr></table></figure></p>
<h6 id="shared_ptr的拷贝和赋值和释放">10.4.3 shared_ptr的拷贝和赋值和释放</h6>
<ul>
<li><p>当进行拷贝和赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他<code>shared_ptr</code>指向相同的对象。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;		<span class="comment">//q是p的拷贝，递增了的计数器。对象此时有俩引用者</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>当给相应的<code>shared_ptr</code>赋予一个新值，计数器递减，当为0时，自动释放自己所管理的对象。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);		<span class="comment">//创建shared_ptr,为值43动态分配内存，拷贝</span></span><br><span class="line">p=r;		<span class="comment">//给p新赋值r,令他指向了另一个地址，此时</span></span><br><span class="line">			<span class="comment">//递增r所指向的引用计数</span></span><br><span class="line">			<span class="comment">//递减p原来的指向的对象的引用计数</span></span><br><span class="line">			<span class="comment">//若递减后为0，已没有引用者，自动释放</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong><code>销毁\释放原理</code></strong>：通过一个特殊的成员函数————析构函数完成销毁工作（每个类都有一个析构函数）。<strong>析构函数一般用来来释放对象所分配的的资源</strong>。<code>shared_ptr</code>的析构函数会递减它所指向对象的引用计数，当为0时，就会销毁对象，释放内存。</p>
<ul>
<li>当对象被销毁时，将递减其引用引用计数并检查它是否为0，如下这个例子： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;foo&gt; <span class="title">factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line"><span class="comment">//该函数返回shared_ptr</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_shared</span>&lt;foo&gt;(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">use_factory</span>(T arg)</span><br><span class="line">&#123;	</span><br><span class="line">shared_ptr&lt;Foo&gt; p=<span class="built_in">factory</span>(arg);</span><br><span class="line"><span class="comment">//为arg用智能指针动态分配内存，达到能够自动释放的目的</span></span><br><span class="line">&#125;<span class="comment">//对象p离开了此作用域被销毁，此时计数减一（此例为0--&gt;释放内存）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">shared_ptr&lt;Foo&gt; p=<span class="built_in">factory</span>(arg)	</span><br><span class="line"><span class="comment">//为arg用智能指针动态分配内存，达到能够自动释放的目的</span></span><br><span class="line"><span class="keyword">return</span> p;	<span class="comment">//引用加1，为2</span></span><br><span class="line">&#125;	<span class="comment">//此时p减一，但不为0，不释放</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="shared_ptr的共享数据">10.4.4 shared_ptr的共享数据</h6>
<p>到目前为止，我们使用的类中，分配的资源都与对应对象生存期一致。当我们拷贝一个<code>vector</code>时，<code>原vector</code>和<code>副本vector</code>中的元素是相互分离的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v1;</span><br><span class="line">&#123;<span class="comment">//新作用域</span></span><br><span class="line">    vector&lt;string&gt; v2=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line">    v1=v2; <span class="comment">//从v2拷贝元素到v1</span></span><br><span class="line">&#125; <span class="comment">//v2被销毁，其中的元素也被销毁</span></span><br><span class="line"><span class="comment">//v1依然有三个元素</span></span><br></pre></td></tr></table></figure> 所以此时的<code>V2只是V1</code>的一份赋值过来的值。指向的不是共同地址的数据。(这里的共同是指内存地址是同一个）。为了达到这个目的，<code>shared_ptr</code>就排上了用场--&gt;多个对象共享数据。</p>
<h6 id="定义strblob类">10.4.5 定义StrBlob类</h6>
<p>下面的是创建一个类模板（实现多个对象共享数据），每个<code>strBlob</code>对象设置一个<code>shared_ptr</code>来管理动态分配的vector。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlob</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::vector&lt;std::string&gt;::size_type size_type;</span><br><span class="line">	<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">StrBlob</span>();</span><br><span class="line">	<span class="comment">//可变形参构造函数，内元素均为字面值且为strig</span></span><br><span class="line">	<span class="built_in">StrBlob</span>(std::initializer_list&lt;std::string&gt; il);</span><br><span class="line">	<span class="comment">//容器大小和判空</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span>  <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="comment">//添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> std::string &amp;t)</span> </span>&#123; data-&gt;push_back; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//外部获得类的data</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;* <span class="built_in">get</span>()&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置data</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(shared_ptr&lt;std::vector&lt;std::string&gt;&gt;* p)</span></span>&#123;</span><br><span class="line">		data=p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//元素访问</span></span><br><span class="line">	<span class="function">std::string &amp;<span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string &amp;<span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//声明智能指针data</span></span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;</span><br><span class="line">	<span class="comment">//如果data[i]不合法，抛出一个异常</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span>()：<span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;()) &#123;&#125;</span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span>(initializer_list&lt;string&gt; il):</span><br><span class="line">       <span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;(il)) &#123;&#125;</span><br><span class="line"><span class="comment">//检查函数，i&gt;size，抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrBlob::check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取头元素</span></span><br><span class="line"><span class="function">string &amp;<span class="title">StrBlob::front</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;front on empty StrBlob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取尾元素</span></span><br><span class="line"><span class="function">string&amp; <span class="title">StrBlob::back</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;back on empty StrBlob&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弹出尾部元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrBlob::pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class="line">	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了该类后，我们创建类的对象，可以通过<code>get</code>函数获得智能指针，通过<code>set</code>赋给类的新对象即可.这样实现了类多个对象的数据共享。这要看很像类的静态成员，但它比静态成员有一个好处就是，当没有对象引用时，会释放，而不像静态成员持续到程序结束时才释放</p>
<h6 id="shared_ptr和new结合使用">10.4.6 shared_ptr和new结合使用</h6>
<p>我们可以用<code>new</code>返回的指针来初始化智能指针。因为接受指针参数的智能指针构造函数是<code>explicit</code>的，<strong>因此我们不能将一个内置指针隐式转换成一个智能指针</strong>，必须使用直接初始化形式而且使用字面值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);    <span class="comment">//错误：必须使用直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;   <span class="comment">//正确：使用了直接初始化形式</span></span><br></pre></td></tr></table></figure> 同理，一个返回<code>shared_ptr</code>的函数不能在其返回语句中隐式转换成一个普通指针： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(p);  <span class="comment">//错误：隐式转换为shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));  <span class="comment">//正确：显式地用int*创建shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所关联的对象。 <strong><em>注意：</em></strong>内置指针是指内置类型<code>（如int、char)</code>的指针，一般没有默认构造函数。普通指针是普通类型的指针），一般有默认构造函数</p>
<p><img src="/c-primer前部分/shared.png" width="700"></p>
<h6 id="莫交错使用new和shared_ptr">10.4.7 莫交错使用new和shared_ptr</h6>
<p>当将一个<code>shared_ptr</code>绑定到一个普通指针时，我们就将内存的管理责任交给了这个<code>shared_ptr</code>。一旦这么做了，我们就不应该再使用内置指针来访问<code>shared_ptr</code>所指向的内存了。如下列子: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; p)</span></span>&#123;</span><br><span class="line"><span class="comment">//空函数，离开时p对象被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;  <span class="comment">//危险：x是一个普通指针，而不是一个智能指针</span></span><br><span class="line"><span class="comment">//process(x);           //错误：不能将int*转换成一个shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));   <span class="comment">//临时shared_ptr，合法的，但内存会被释放，引用计数变为0</span></span><br><span class="line"><span class="type">int</span> j=*x;   <span class="comment">//未定义的：x是一个空悬指针</span></span><br></pre></td></tr></table></figure></p>
<p><strong>上述代码中<code>x</code>是一个普通指针，当把<code>x</code>传给<code>process</code>时，报错，因为普通指针不能隐式的转换为智能指针。传入的实参显示转换为智能指针，此时<code>x</code>就将内存交给了<code>shared_ptr</code>管理</strong>，当该函数执行完毕时，该指针指针<code>shared_ptr</code>被销毁（x所指向的内存没了），<code>x</code>也就成了空悬指针。</p>
<p>使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。而且内置指针很可能成为空悬指针</p>
<h6 id="智能指针和异常">10.4.8 智能指针和异常</h6>
<p>使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//如果在这里抛出了异常,其内存也会释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面这种清空就不会释放：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">43</span>);</span><br><span class="line"><span class="comment">//如果在这里抛出了异常</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;<span class="comment">//因为抛出了异常，无法执行delete p语句</span></span><br></pre></td></tr></table></figure></p>
<h6 id="删除器">10.4.9 删除器</h6>
<p>某些类没有定义析构函数，此时我们可以使用<code>shared_ptr</code>来保证该类生成的对象的内存被正确释放，首先定义一个函数（删除器）来代替得<code>delete</code>。下面以连接为例子，<code>destination</code>类是连接信息类 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一些类和接口</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;		<span class="comment">//该类标识我们连接的信息，如端口，地址</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connnection</span>;		<span class="comment">//连接类，已连接信息记录</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destionatin *p)</span></span>;	<span class="comment">//请求连接,返回一个连接类记录信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnection</span><span class="params">(connection)</span></span>;		<span class="comment">//关闭连接,内含delete操作</span></span><br><span class="line"><span class="comment">//对声明的类和接口定义</span></span><br><span class="line">....</span><br><span class="line"><span class="comment">//定义删除器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connecttion</span><span class="params">(connection *p)</span></span>&#123;</span><br><span class="line">	<span class="built_in">disconnection</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shared_ptr使用删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">	connection c=<span class="built_in">connect</span>(&amp;d)；	<span class="comment">//返回一个连接类信息</span></span><br><span class="line">	shared_ptr&lt;connection&gt; <span class="built_in">p</span>(&amp;c,end_connnection);	<span class="comment">//shared_ptr的用法，自定义删除器</span></span><br><span class="line">	<span class="comment">//这样。当f函数退出时，即使是由异常引起的，Connection也会被释放关掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当对象智能指针对象p离开函数f的作用域时，自动调用end_connection函数，end_connection函数又调用disconnection函数执行delete操作，注意形参时指针类型</p>
<h6 id="shared_ptr与数组">10.4.10 shared_ptr与数组</h6>
<p>与<code>unique_ptr</code>不同，<code>shared_ptr</code>不直接支持管理动态数组。如果我们希望使用<code>shared_ptr</code>管理一个动态数组，<strong>必须提供自己定义的删除器(因为删除是我们默认的是<code>delete</code>而不是<code>delete[]</code>)：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了使用shared_ptr,必须提供一个删除器</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>],[](<span class="type">int</span> *p)&#123;<span class="keyword">delete</span> [] p;&#125;)</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>();   <span class="comment">//使用我们提供的lambda释放数组，它使用delete[]</span></span><br></pre></td></tr></table></figure> <code>shared_ptr</code>未定义下标运算符，<strong>而且智能指针类型不支持指针算数运算</strong>。因此，为了访问数组中的元素，必须用<code>get</code>获取一个内置指针，然后用它来访问数组元素： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</span><br><span class="line">    *(sp.<span class="built_in">get</span>()+i)=i;  <span class="comment">//使用get获取一个内置指针</span></span><br></pre></td></tr></table></figure></p>
<h5 id="unique_ptr">10.5 unique_ptr</h5>
<p><code>unique_ptr</code>是C++的另一个智能指针，与<code>shared_ptr</code>不同的是，任何时刻，都至多只能有一<code>unique_ptr</code>智能指针指向一个对象，当<code>unique_ptr</code>指针被销毁时，其对象也被销毁。</p>
<h6 id="unique_ptr的初始化">10.5.1 unique_ptr的初始化</h6>
<p>与<code>shared_ptr</code>不同，没有类似<code>make_shared</code>的标准函数返回一个<code>unique_ptr</code>。因此，当我们定义一个<code>unique_ptr</code>时，需要将其绑定到一个<code>new</code>返回的指针上。类似于<code>shared_ptr</code>（接受参数的构造函数有<code>explicit修饰</code>），所以初始化<code>unique_ptr</code><strong>必须采用直接初始化方式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p;		<span class="comment">//定义</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;		<span class="comment">//定义并初始化，指向一个值为24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr不支持普通的拷贝和赋值：</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">24</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p2</span>(p1);		<span class="comment">//错误，不支持拷贝</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;p3;</span><br><span class="line">p3=p1;						<span class="comment">//或p3(p2)错误，不允许赋值</span></span><br></pre></td></tr></table></figure>
<p><img src="/c-primer前部分/unique_ptr.png" width="700"></p>
<p>虽然我们无法拷贝或者赋值，但我们可以通过调用<code>release或reset</code>将指针所有权从一个<code>（const)unique_ptr</code>转移给另一个<code>unique_ptr</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;	<span class="comment">//p1转移给p2，p1置空</span></span><br><span class="line">unique_ptr&lt;string&gt;<span class="built_in">p3</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line"><span class="comment">//p3转移给p2ertyui</span></span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">//p2释放原来的，p3被置空，p2指向的p3的</span></span><br></pre></td></tr></table></figure> <strong><code>release</code>函数会切断智能指针和它原来管理的对象的联系</strong>，它返回的指针通常用来初始化另一个智能指针或给另一个智能指针赋值。 如果我们不用另一个智能指针来保存<code>release</code>返回的指针，我们的程序就要负责资源的释放： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=p2.<span class="built_in">release</span>();		<span class="comment">//后面程序应该有delete(p);操作</span></span><br></pre></td></tr></table></figure></p>
<h6 id="向unique_ptr传递删除器">10.5.2 向unique_ptr传递删除器</h6>
<p>和<code>shared_ptr</code>一样，<code>unique_ptr</code>默认情况（源代码）使用<code>delete</code>释放它指向的对象。我们可和<code>shared_ptr</code>一样重载一个<code>unique_ptr</code>中的删除器。</p>
<p>重载一个<code>unique_ptr</code>中的删除器会影响到<code>unique_ptr类型</code>以及如何构造（或<code>reset</code>）该类型的对象：<strong>我们必须在尖括号中<code>unique_ptr</code>指向类型之后提供删除器类型</strong>，即在创建或<code>reset</code>一个这种<code>unique_pt</code>r类型的对象时，必须提供一个指定类型的可调用对象（删除器） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span></span><br><span class="line"><span class="comment">//它会调用一个名为fcn的delT类型对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT,delT&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> objT,fcn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(desitination &amp;d)</span></span>&#123;</span><br><span class="line">	connection c=<span class="built_in">connect</span>(&amp;d)；	<span class="comment">//返回一个连接类信息</span></span><br><span class="line">	<span class="comment">//当p被销毁时，连接会关闭</span></span><br><span class="line">	unique_ptr&lt;connection,<span class="keyword">decltype</span>(end_connection)*&gt; <span class="built_in">p</span>(&amp;c,end_connnection);</span><br><span class="line">	<span class="comment">//这样。当f函数退出时，即使是由异常引起的，Connection也会被释放关掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong><em>注：</em></strong><code>decltype</code>是C++11新增的一个关键字，和<code>auto</code>的功能一样，用来在编译时期进行自动类型推导。引入<code>decltype</code>是因为<code>auto</code>并不适用于所有的自动类型推导场景，在某些特殊情况下auto用起来很不方便，甚至压根无法使用。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> varName=value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varName=value;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li><code>auto</code>根据<code>=</code>右边的初始值推导出变量的类型，<code>decltype</code>根据<code>exp</code>表达式推导出变量的类型，跟``=右边的value没有关系</li>
<li><code>auto</code>要求变量必须初始化，这是因为<code>auto</code>根据变量的初始值来推导变量类型的，如果不初始化，变量的类型也就无法推导</li>
<li>而<code>decltype</code>不要求，因此可以写成如下形式 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varName;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h6 id="指向数组的unique_ptr">10.5.3 指向数组的unique_ptr</h6>
<p>标准库提供了一个可以管理<code>new</code>分配的数组的<code>unique_ptr</code>版本。使用<code>unique_ptr</code>管理动态数组时，我们必须在对象类型后面跟一对方括号,下面是用法介绍： <img src="/c-primer前部分/uniquearry.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">up.<span class="built_in">release</span>();   <span class="comment">//自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>
<p>另外一方面，当一个unique_tr指向一个数组时，我们可以使用下标运算符来访问数组中的元素： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</span><br><span class="line">    up[i]=i;  <span class="comment">//为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure></p>
<h5 id="weak_ptr">10.6 weak_ptr</h5>
<p><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针,是弱用智能指针，<strong>它指向一个有<code>shared_ptr</code>管理的对象。将一个<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变<code>share_ptr</code>的引用计数。</strong> <img src="/c-primer前部分/weak_ptr.png" width="700"> 当我们创建一个<code>weak_ptr</code>时，我们要用以<code>shared_ptr</code>初始化它： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">43</span>);</span><br><span class="line"><span class="function">weak_ptr <span class="title">wp</span><span class="params">(p)</span></span>;		<span class="comment">//wp若共享p,p的引用计数不变</span></span><br></pre></td></tr></table></figure> 由于对象可能不存在，不能直接使用<code>weak_ptr</code>直接访问对象，必须调用<code>lock(</code>)函数！该函数会检查<code>weak_ptr</code>指向的对象是否存在，若存在，则返回一个指向共享对象的<code>shared_ptr</code>。如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; q=wp.<span class="built_in">lock</span>())	</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使用q访问对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="allocator类">10.7 allocator类</h5>
<p>在前面我们主要介绍了<code>new,delete和智能指针</code>。但他们分配的内存不是原始的，它们在分配的时候要对内存进行构造。<strong>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</strong> <img src="/c-primer前部分/allocator.png" width="700"></p>
<h6 id="allocate分配未构造内存">10.7.1 allocate：分配未构造内存</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;string&gt; allco;	<span class="comment">//定义可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p=alloc.<span class="built_in">allocate</span>(n);	<span class="comment">//分配n个为初始化的string</span></span><br></pre></td></tr></table></figure>
<p><code>alloc</code>完成了分配n个<code>string</code>的连续内存的工作，并且返回一个指向这一块内存的首地址给指针<code>p</code>。我希望p记住这个首地址在哪免得我后边找不到了，所以把它设为<code>const</code>的。</p>
<h6 id="construct创建对象">10.7.2 construct：创建对象</h6>
<p>下面我让<code>alloc</code>为我在这些内存上构造对象：<code>alloc.construct(内存地址，参数......)</code>，括号里的“参数”是给我这块内存的对象类型的构造函数的参数，比如这里对于<code>string</code>，可以这样: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string *S=p;	<span class="comment">//将首地址给S</span></span><br><span class="line">alloc.<span class="built_in">constrcut</span>(S,<span class="number">10</span>,<span class="string">&#x27;A&#x27;</span>);		<span class="comment">//该内存构造string &quot;AAAAAAAAAA&quot;</span></span><br><span class="line">S++;			<span class="comment">//把内存地址往后挪，以便后续的构造</span></span><br></pre></td></tr></table></figure> <strong><em>注意：使用未构造的对象的内存空间是错误</em></strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;*p&lt;&lt;endl;		<span class="comment">//正确，p是指向首地址</span></span><br><span class="line">cout&lt;&lt;*S&lt;&lt;endl;		<span class="comment">//错误，还没构造</span></span><br></pre></td></tr></table></figure></p>
<h6 id="destroy摧毁对象">10.7.3 destroy：摧毁对象</h6>
<p>当我们用完对象后，必须对每个构造的元素调用<code>destory</code>来摧毁它们。我们只能对真正构造了的元素进行<code>destory</code>操作,而且只有摧毁的内存或未构造的内存才能被<code>deallocate</code>回收。<code>destroy</code>参数接受一指针，对指向的对象执行析构函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q!=p)</span><br><span class="line">alloc.<span class="built_in">destroy</span>(--q);</span><br></pre></td></tr></table></figure> 一旦元素被销毁，我们就可以重新使用这部分内存来保存其他string,也可以将其归还给系统。释放内存通过调用dealloccate来完成： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.<span class="built_in">dealloccate</span>(p,n);	<span class="comment">//p必须是allocate返回的指针，n必须是分配时指定的n</span></span><br></pre></td></tr></table></figure></p>
<h6 id="拷贝和填充未初始化的内存算法">10.7.4 拷贝和填充未初始化的内存算法</h6>
<p>allocator还有两个伴随算法，可以在未初始化内存中创建对象。它们都定义在头文件<code>memory</code>中。 <img src="/c-primer前部分/allocator_algorithm.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配动态内存</span></span><br><span class="line"><span class="keyword">auto</span> p=alloc.<span class="built_in">allocate</span>(v.<span class="built_in">size</span>()*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//拷贝vi的元素到未构造内存,返回下一个未构造地址</span></span><br><span class="line"><span class="keyword">auto</span> q=<span class="built_in">uninitialized_copy</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),p);</span><br><span class="line"><span class="comment">//将剩余空间构造为42</span></span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(q,vi.<span class="built_in">size</span>(),<span class="number">42</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="拷贝控制">11.拷贝控制</h4>
<p>如何控制类型对象拷贝、赋值、移动和销毁，<strong>有对应的五种特殊成员函数来控制这些操作：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数</strong></p>
<h5 id="拷贝构造函数">11.1 拷贝构造函数</h5>
<h6 id="拷贝构造函数-1">11.1.1 拷贝构造函数</h6>
<p>个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>&#123;</span><br><span class="line"><span class="built_in">foo</span>();			<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="type">const</span> foo&amp;);	<span class="comment">//拷贝构造函数</span></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>第一个参数几乎总是<code>const</code>的（虽然可以不为<code>const</code>)，拷贝构造函数在几种情况下都会被隐式的调用，因此拷贝构造函数通常不应该是<code>explicit</code>(<code>explicit</code>修饰的不能拷贝初始化，只能直接初始化，不能隐式转换类类型）。</strong></p>
<h6 id="合成拷贝构造函">11.1.2 合成拷贝构造函</h6>
<p>如果我们没有为一个类定义拷贝构造函数，<strong>编译器会为我们定义默认的拷贝构造函数（即使有其他的构造函数）</strong>。但有些类，合成的拷贝构造函数用来阻止我们拷贝该类类型的对象。<strong>但一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中（从给定对象依次将每个非static成员拷贝到正在创建的对象中）。</strong> <strong>如何拷贝：</strong></p>
<ul>
<li>对类类型（需要include&lt;&gt;的就为类类型)的成员，会使用其拷贝构造函数来拷贝</li>
<li>内置类型的成员则直接拷贝</li>
<li>对数组，合成拷贝构造函数会逐元素拷贝数组类型成员</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...		<span class="comment">//其他构造函数</span></span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;);	<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string Book_NO;</span><br><span class="line">	<span class="type">int</span> units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data &amp;data):<span class="built_in">Book_NO</span>(data.Book_NO),<span class="built_in">units_sold</span>(data.units_sold)</span><br><span class="line">	<span class="built_in">revenue</span>(data.revenue)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="拷贝初始化">11.1.3 拷贝初始化</h6>
<ul>
<li><strong>使用<code>=</code>进行的初始化是拷贝形式的初始化，编译器将等号右边的初始值拷贝到新创建的对象上去</strong>。这时将调用对象定义的<strong>拷贝构造函数</strong>进行操作，只要这些构造函数满足这样的调用就会被隐式的调用。但是被explicit修饰的拷贝构造函数将会禁止该构造函数进行这样隐式的调用（因为可能由隐式类型转换）。</li>
<li>不使用<code>=</code>进行初始化的操作就是直接初始化,采用<code>()</code>直接进行初始化。这里调用的构造函数就是直接使用对应的<strong>构造函数</strong>进行初始化。explicit修饰的构造函数能用于直接初始化。这种形式没有什么限制。</li>
</ul>
<p><strong><em>总结：</em></strong> <strong>直接初始化：</strong>根据提供的参数选择最匹配的构造函数 <strong>拷贝初始化：</strong>右侧运算对象拷贝到正在创建的对象中，通常由拷贝构造函数完成。</p>
<h6 id="拷贝构造函数的参数必须是引用">11.1.4 拷贝构造函数的参数必须是引用</h6>
<p><strong>因为在函数调用中，非引用类型的的参数要进行拷贝初始化；函数返回一个非引用类型，调用方的返回结果也是一个拷贝，所以拷贝函数此时被用来初始化非引用类型的数据。如果拷贝构造函数的参数不是引用类型都是类型形参，为获得它的实参，那么它自身就会无限的调用自身的死循环。P（442）</strong></p>
<h6 id="构造函数不能为虚函数">11.1.5 构造函数不能为虚函数</h6>
<p>我们知道，<strong>每个有虚函数的类都有属于自己的虚函数表<code>vtbl</code>，虚函数表在编译器构建好。当我们的派生类重写了虚函数，那么在虚表中就会替换掉父类的虚函数指针为子类的虚函数指针。当我们创建一个对象时，会在对象的内存模型中有自己的指向虚表的指针<code>vtpr</code>，对象通过虚表才知道调用的是哪一版本的虚函数</strong> <img src="/c-primer前部分/vtpr.png" width="500"> 如果构造函数是虚函数,那么也会如上面的机制一样在虚表有一个指向自己构造函数版本的虚函数指针。现在有两个类<code>A</code>和<code>B</code>,<code>B</code>是<code>A</code>的派生类，在构造<code>B</code>的对象的时候发现继承于<code>A</code>的部分要先构造，它就要求调用<code>A</code>的构造函数，但是这些构造函数已经是虚函数了，而虚表指针必须是在构造一个对象的时候分配了内存才能得到，而你有调用不到构造函数，<strong>这就陷入了一个矛盾的处境：你要用虚表指针<code>vtpr</code>去调用构造函数，而虚表指针<code>vtpr</code>只有当年调用构造申请了内存后才能得到，这形成了一个死结。</strong></p>
<p><strong><em>附加</em></strong>：vptr的初始化工作早于构造函数中的初始化列表</p>
<h5 id="拷贝赋值运算符">11.2 拷贝赋值运算符</h5>
<p>与类控制对象如何初始化一样，类也可以控制对象如何赋值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data trans,accum;</span><br><span class="line">trans=accum;		<span class="comment">//使用Sales_data的拷贝运算符</span></span><br></pre></td></tr></table></figure> <strong><em>注意区分：拷贝构造函数是在对象创建时拷贝，而赋值拷贝时在对象已经创建后进行赋值，这就是两者的区别</em></strong></p>
<h6 id="重载赋值运算符">11.2.1 重载赋值运算符</h6>
<p>重载运算符的本质是函数。其名由<code>operator</code>关键字接要定义的运算符组成。赋值运算符<code>operator=</code>的函数，其也有返回类型和参数（参数表示要运算的对象），运算符如果是成员函数，则运算对象就绑定在隐式的this指针上。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> foo&amp;);	<span class="comment">//赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="合成拷贝赋值运算符">11.2.2 合成拷贝赋值运算符</h6>
<p>与拷贝构造函数一样，在没有定义自己的拷贝运算符时，<strong>编译器会生成一个合成拷贝赋值运算符</strong>。同样，对于某些类，合成拷贝赋值运算符会禁止该类型对象的赋值，如果不是此目的，它会赋值（非static)。</p>
<h5 id="析构函数">11.3 析构函数</h5>
<p>析构函数释放对象使用的资源，并销毁对象的非<code>static</code>数据成员。析构函数时类的成员函数，名字由波浪号<code>~</code>接类名构成，没有返回值，也不接受参数，既不能重载但一般定义未虚函数重写，类只有一个析构函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">foo</span>();	<span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="定义析构函数">11.3.1 定义析构函数</h6>
<p>析构函数同构造函数一样，也由一函数体和一个析构部分。在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。<strong>析构部分是隐式的，销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销魂内置类型成员什么也不需要做（隐式的）。</strong></p>
<ul>
<li>隐式销毁一个内置指针类型的成员不会delete它所指向的对象</li>
<li>智能指针式类类型的，所以具有析构函数，所以智能指针在析构阶段被自动销毁</li>
</ul>
<p><strong>什么时候调用析构函数：无论何时一个对象被销毁，就会自动调用其析构函数</strong>:</p>
<ul>
<li>变量离开作用域时被销毁</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器被销毁时，其元素被销毁</li>
<li>对于动态分配对象，当指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<p>由于析构函数的自动允许，我们程序可以按需要分配资源，无需担心何时释放这些资源。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">//语句块作用域</span></span><br><span class="line">	Sales_data* p=<span class="keyword">new</span> Sales_data;	<span class="comment">//p是一个普通指针</span></span><br><span class="line">	<span class="keyword">auto</span> p2=<span class="built_in">make_shared</span>&lt;Sales_data&gt;();	<span class="comment">//p2是一个智能指针</span></span><br><span class="line">	<span class="function">Sales_data <span class="title">item</span><span class="params">(*p)</span></span>;			<span class="comment">//使用拷贝构造</span></span><br><span class="line">	vector&lt;Sales_data&gt;vec;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(*p2);</span><br><span class="line">	<span class="keyword">delete</span> p;						<span class="comment">//释放p</span></span><br><span class="line">	<span class="comment">//离开作用域后，p2的计数归0，自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="合成析构函数">11.3.2 合成析构函数</h6>
<p><strong>当一个类未定义析构函数时，编译器会为它定义一个合成析构函数。同时同拷贝构造函数、拷贝赋值运算符一样，对于某些类，合成析构函数被用来阻止该类型的对象被销毁</strong>。如果不是这种情况，合成析构函数的函数体就为空。<strong>析构函数体自身不直接销毁成员，而是在析构函数体之后隐含的析构阶段中被销毁</strong></p>
<h5 id="c对这些构造函数的法则">11.4 C++对这些构造函数的法则</h5>
<p>目前为止介绍了三个拷贝控制操作：拷贝构造函数、拷贝赋值运算符、析构函数，知道我们若是不显示定义，编译器会自动合成默认的拷贝构造和赋值构造函数以及析构函数。c++新标准还引入了：一个类还可以定义一个移动构造函数、一个移动赋值运算符。对于它们，编译器有自己的一套法则</p>
<h6 id="三五法则">11.4.1 三/五法则</h6>
<p>对于这些构造函数，我们有时候不必全部定义，有如下的法则：</p>
<ul>
<li>（1）需要析构函数的了也需要拷贝和赋值操作</li>
<li>（2）如果类需要一个析构函数，那么几乎可以肯定它也需要拷贝构造函数和拷贝赋值运算符</li>
<li>（3）需要拷贝操作的类也需要赋值操作，反之亦然</li>
</ul>
<p>总结：即一般来说类中一般以三</p>
<h6 id="default默认合成">11.4.2 =default：默认合成</h6>
<p>同默认合成构造函数一样，可以用<code>=default</code>来显示要求合成拷贝构造函数，默认为内联的。<strong>若不要内联，则在类的外部定义为<code>=default</code></strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;)=<span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="delete阻止拷贝">11.4.3 =delete：阻止拷贝</h6>
<p>上面我们总是讲到有些拷贝构造、赋值构造和析构会阻止它们的应用功能，这就是用<code>=delete</code>定义的函数。虽然大多数类定义了拷贝构造函数和拷贝赋值运算符，但对于某些类，这些操作没有实际意义，如<code>iostream</code>类阻止了拷贝以避免多个对象写入或读取相同的<code>IO</code>缓冲。所以这种情况就要阻止拷贝的发生。<strong><em>在新标准之前（<code>=delet</code>e前)，类是通过将其拷贝构造函数和拷贝赋值运输符声明为private来阻止拷贝：</em></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp;);		<span class="comment">//阻止拷贝构造</span></span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;);		<span class="comment">//阻止赋值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新标准下，我们可以将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。 <strong>删除的函数</strong>：我们声明了它，但不能以任何方式使用它，我们在相应的拷贝构造和拷贝运算符后加<code>=delete</code>即可 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mm</span>&#123;</span><br><span class="line">	<span class="built_in">mm</span>()=<span class="keyword">default</span>;		<span class="comment">//合成构造函数</span></span><br><span class="line">	<span class="built_in">mm</span>(<span class="type">const</span> mm&amp;)=<span class="keyword">delete</span>;		<span class="comment">//阻止拷贝</span></span><br><span class="line">	mm &amp;<span class="keyword">operator</span>=(<span class="type">const</span> mm &amp;)=<span class="keyword">delete</span>;		<span class="comment">//阻止赋值</span></span><br><span class="line">	~<span class="built_in">mm</span>();				<span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 与<code>default</code>不同:</p>
<ul>
<li><code>delete</code>必须出现在函数第一声明的时候；</li>
<li>还有一点不同的是我们可以对任何函数<code>=delete</code>，而<code>default</code>只能是默认合成构造函数和拷贝控制成员，但一般而言，对于析构函数我们不应该使用<code>=delete</code>(因为这样我们就无法销毁类型对象了）</li>
</ul>
<h6 id="合成的拷贝控制成员可能是删除的">11.4.4 合成的拷贝控制成员可能是删除的</h6>
<p><strong>正如前面所将的，合成的拷贝控制操作可能是阻止类型的：</strong></p>
<ul>
<li>如果类的某个成员的析构函数是删除或不可访问的（如<code>private</code>),则类的合成析构函数被定义为删除的</li>
<li>如果类的某个成员的拷贝构造函数是删除或不可访问的，则类的合成拷贝构造函数被定义为删除。同样，析构函数是删除或不可访问，合成拷贝构造函数被定义为删除</li>
<li><strong>如果类的某个成员的拷贝赋值运算符是删除或不可访问的，或者类有一个<code>const</code>的或者引用的成员，则类的合成拷贝赋值运算符被定义为删除</strong></li>
<li><strong>如果类的某个成员的析构函数是删除或不可访问的、或者类有一个引用成员，它没有类内初始器、或是类内有一个<code>const</code>成员，他没有类内初始器且其类型为显示定义默认构造函数，则该类的默认构造函数被定义为删除的</strong></li>
</ul>
<p><strong><em>即：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数被定义为删除</em></strong></p>
<h5 id="对象移动">11.5 对象移动</h5>
<p>新标准一个最主要的特征是可以移动而非拷贝对象的能力。使用移动而不是拷贝：</p>
<ul>
<li>①在对象较大时，进行拷贝代价很高。</li>
<li>②对于像IO类和unique_ptr这些类，这些类都包含了不能被共享的资源，因此不能拷贝但可以移动。</li>
</ul>
<p>该特性主要针对这样一种场景：<strong>一个对象在被拷贝之后就不在使用了或者马上就会被析构掉，这种情况下，使用移动操作而非拷贝操作将会大幅度提升性能。移动操作的思想是接管源对象的内容。</strong></p>
<h6 id="右值与左值">11.5.1 右值与左值</h6>
<ul>
<li><strong>左值</strong>：返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式。</li>
<li><strong>右值</strong>：右值要么是字面常量，要么是在常量表达式求职过程中创建的临时对象。</li>
</ul>
<p>左值持久；右值短暂。</p>
<h6 id="右值引用和左值引用">11.5.2 右值引用和左值引用</h6>
<p>为了支持移动，新标准引入了新类型的引用——<strong>右值引用</strong>。<strong>通过&amp;&amp;获得右值引用。右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。因此我们可以将一个右值引用资源“移动”到另一个对象去。</strong>不难知道，不管是左值引用还是右值引用都是变量的一个别名：</p>
<ul>
<li><strong>左值引用</strong>：不能将其绑定到要求转换的公式、字面常量或者是返会右值的表达式，即左值引用是绑定对象（左值）的。</li>
<li><strong>右值引用</strong>：与左值引用恰恰相反，可绑定右值，但不能绑定左值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r=i;		<span class="comment">//正确，左值引用绑定对象（左值）</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr=i;	<span class="comment">//错误，右值引用不能绑定左值</span></span><br><span class="line"><span class="type">int</span> &amp;r2=i*<span class="number">42</span>;	<span class="comment">//错误，左值引用不能绑定右值</span></span><br><span class="line"><span class="comment">//可以将一个const的左值引用或者一个右值引用绑定到这类表达式上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3=i*<span class="number">42</span>;	<span class="comment">//正确，可以将const的引用绑定到右值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;r3=i*<span class="number">42</span>;	<span class="comment">//正确</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于右值引用只能绑定到临时对象，我们可以知道：<strong>①所引用的对象将要被销毁，②该对象没有其他用户。这两个特性意味着使用右值引用的代码可以自由地接管所引用的对象的资源。</strong></p>
<p><strong>记住变量是左值，我们不能将右值引用绑定到变量上，即使这个变量本身是右值引用也不行！</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  &amp;&amp;r1=<span class="number">42</span>;		<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;r2=r1;		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p>
<h6 id="move函数">11.5.3 move函数</h6>
<p>新标准提供了一个函数解决右值引用无法绑定左值的函数，通过调用新标准库函数move来获得绑定到左值的右值引用。该函数定义在头文件<code>utility</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;r2=std::<span class="built_in">move</span>(r1);		<span class="comment">//可行</span></span><br></pre></td></tr></table></figure> 调用<code>move</code>之后，我们可以销毁一个移后员对象，也可以赋予它新值，但不能使用一个移后源对象的值。 有了这些知识我们就能看接下来的<strong>移动拷贝构造函数和移动赋值运算符</strong>。类似string类，自定义的类支持移动和拷贝，会十分方便。它们从指定对象“窃取”资源，而不是拷贝资源。</p>
<h6 id="移动拷贝构造函数">11.5.4 移动拷贝构造函数</h6>
<p>类似于拷贝构造函数，<strong>第一个参数是该类类型的右值引用</strong>，其他额外参数必须有默认值。<strong>移动构造函数需要确保移后源对象处于这样一个状态：销毁它是无害的。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> <span class="comment">//移动操作不应抛出任何异常</span></span><br><span class="line">    <span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">    :<span class="built_in">elements</span>(s.elements), <span class="built_in">first_free</span>(s.first_free), <span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//另s进入这样一个状态——对其运行析构函数是安全的</span></span><br><span class="line">    s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>上面这个程序不分配任何内存，只是接管了s的内存，接管之后，将给定对象的指针都设为<code>nullptr</code>,这样就完成了移动操作</strong>。此源对象继续存在（但已经没有管理任何内存），当允许其析构函数时，源对象被销毁。<strong>注意：不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</strong></p>
<blockquote>
<p><strong>为什么要声明<code>noexcept</code></strong> 虽然移动操作通常不会异常抛出，但抛出异常时允许的。而且标准库容器能对异常发生时其自身的行为提供保障。&gt;<code>noexcept</code>它告诉编译器该函数不会抛出异常，否则编译器会认为移动操作可能会发生异常，并且为了处理这种可&gt;能性做一些额外的工作。</p>
</blockquote>
<h6 id="移动赋值运算符">11.5.5 移动赋值运算符</h6>
<p>移动赋值运算符指向析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为<code>noexcept</code>。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(); <span class="comment">//释放已有元素</span></span><br><span class="line">        elements = rhs.elements;</span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="移动操作的要求">11.5.6 移动操作的要求</h6>
<ul>
<li><strong>移动源对象必须可析构</strong>：当我们编写一个移动操作，必须保证移动源进入一个可析构状态，如上面的例子中，我们将移动源数据置为<code>nullptr</code>。其次，还应保证，对象移动后还是有效的，既可以重新赋值。</li>
<li><strong>合成的移动操作</strong>：<strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时（指针型），编译器才会为它合成移动构造函数或移动赋值运算符。</strong></li>
<li><strong>移动右值，拷贝左值</strong>：在一个类中，既定义了移动又定义了拷贝，编译器使用匹配规则进行匹配。在定义了拷贝但没有定义移动，右值也使用拷贝构造函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器会为X和hasX合成移动操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">//内置类型可以移动</span></span><br><span class="line">    std::string s; <span class="comment">//string 定义了自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasX</span>&#123;</span><br><span class="line">    X mem;  <span class="comment">//X有合成的移动操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X x, x2 = std::<span class="built_in">move</span>(x);        <span class="comment">//使用合成的移动构造函数</span></span><br><span class="line">hasX hx, hx2 = std::<span class="built_in">move</span>(hx);  <span class="comment">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>
<p>移动操作永远不会隐式定义为删除的函数。如果我们显示地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。移动构造函数被定义为删除的函数的条件是：</p>
<ul>
<li>有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者有类成员未定义自己的拷贝构造函数且编译器不能为其合成构造函数。移动赋值运算符的情况类似。</li>
<li>如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。</li>
<li>如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。</li>
<li>如果有类成员是<code>const</code>或是引用，则类的移动赋值运算符被定义为删除的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假定Y是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasY</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">hasY</span>() = defualt;</span><br><span class="line">    <span class="built_in">hasY</span>(hasY&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Y mem;  <span class="comment">//hasY将有一个删除的移动构造函数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hasY hy, hy2 = std::move(hy); //错误，移动构造函数是删除的</span></span><br></pre></td></tr></table></figure>
<p><strong>如果类定义了一个移动构造拷贝和/或一个移动赋值运算符，该类的合成拷贝构造函数和拷贝赋值运算符将会被定义为删除的</strong>。因此定义了一个移动构造函数或者移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员都被默认为删除的。（三/五法则）</p>
<h6 id="移动迭代器">11.5.7 移动迭代器</h6>
<p>新标准库定义了一种<strong>移动迭代器适配器</strong>。<strong>移动迭代器的解引用生成一个右值引用</strong>（其他的迭代器一般时指向元素的左值）。 通过调用标准库函数的<code>make_move_iterator</code>函数将以普通迭代器转换为移动迭代器。移动迭代器支持正常迭代器的工作。<strong>但值得注意的是只有在确定算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，能可以使用移动迭代器。否则使用移动迭代器销毁了原来数据，还想使用是错误的行为。</strong></p>
<h5 id="实际运用">11.6 实际运用</h5>
<p>在我们已经运用的类中，如<strong><code>string</code>、标准库容器它们的对象行为像一个值，即我们拷贝这些类的对象是，副本和原对象是独立的，互不影响</strong>。 但像<code>shared_ptr</code>类，<strong>这些智能指针的对象的行为像一个指针，副本和原对象使用相同的底层数据，即数据共享，它们之间会互相影响。</strong></p>
<h6 id="行为像值的类">11.6.1 行为像值的类</h6>
<p>这种行为的类，它们得对象都有着自己的一份数据： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span>  string&amp; s=<span class="built_in">string</span>())</span><br><span class="line">		:<span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)),<span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;		<span class="comment">//ps指向自己分配的空间,构造函数</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">		:<span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p.ps)),<span class="built_in">i</span>(p.i)&#123;&#125;		<span class="comment">//拷贝构造函数</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;);		<span class="comment">//赋值运算符</span></span><br><span class="line">	~<span class="built_in">HasPtr</span>()&#123;<span class="keyword">delete</span> ps;&#125;					<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string *ps;</span><br><span class="line">	<span class="type">int</span> i；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 上面这个类除了拷贝赋值运算符外，其他的成员函数都定义了。<strong>构造函数和拷贝构造函数都动态分配它们自己的<code>string</code>,以及分配自己栈内存给整型<code>i</code></strong>；赋值运算符通常组合了析构函数和构造函数的操作，我们编写的赋值运算符还应该是异常安全的--当异常发生时，仍能将左侧运算对象置于一个有意义的状态。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p)&#123;</span><br><span class="line">	<span class="keyword">auto</span> newp=<span class="keyword">new</span> <span class="built_in">string</span>(*p.ps);</span><br><span class="line">	<span class="keyword">delete</span> ps;</span><br><span class="line">	ps=newp;</span><br><span class="line">	i=p.i;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> delete这个对象原来的指向的<code>string</code>，再将<code>newp</code>的管理权给它。在编写赋值运算符时，需要注意：</p>
<ul>
<li>如果将一个对象赋予它自身，赋值运算符必须能正确工作</li>
<li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作</li>
</ul>
<p>一个好的赋值运算符，往往会借助一个局部零时对象拷贝，如上的<code>newp</code>。（就如在上面的程序中，如果p和this是同一个对象，如果不借助中间<code>newp</code>而直接<code>delete ps</code>将会发生错误）。你也可以增加判断语句<code>if(this!=p)</code>避免增加一个零时量</p>
<h6 id="行为像指针的类">11.6.2 行为像指针的类</h6>
<p>令一个类展现类似指针行为的最好方法是<code>shared_ptr</code>来管理类中的资源，拷贝一个<code>shared_ptr</code>会拷贝（赋值）所指向的指针，共享数据，只要当s<code>hare_ptr</code>引用计数为0时才会释放资源。 <strong>另一个方法是不用<code>shared_ptr</code>，而是设计自己的引用计数，这种情况下，我们可以自己直接管理资源</strong> <strong>引用计数：</strong></p>
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还有创建一个引用计数，用来记录多少对象与正在创建的对象共享数据状态。</li>
<li>拷贝构造函数不分配计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户共享</li>
<li>析构函数递减计数器，指出gong共享状态的用户少了一个。若为0，则释放</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧。若左侧为0，则销毁释放。</li>
</ul>
<p>怎么存放计数器：将计数器保存在动态内存中，当创建一个对象时，我们分配一个计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;, HasPtr&amp;)</span></span>;	<span class="comment">//交换操作</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span>  string&amp; s=<span class="built_in">string</span>())</span><br><span class="line">		:<span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)),<span class="built_in">i</span>(<span class="number">0</span>),<span class="built_in">use</span>(<span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>))&#123;&#125;		<span class="comment">//构造函数,计数器为1</span></span><br><span class="line">	<span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">		:<span class="built_in">ps</span>(p.ps),<span class="built_in">i</span>(p.i),<span class="built_in">use</span>(p.use)&#123;*use++&#125;		<span class="comment">//拷贝构造函数,共享ps,use</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;);			<span class="comment">//赋值运算符</span></span><br><span class="line">	~<span class="built_in">HasPtr</span>()；					<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string *ps;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">size_t</span> *use;							<span class="comment">//引用计数器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数定义：</span></span><br><span class="line">HasPtr::~<span class="built_in">HasPtr</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span>(--*use==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">delete</span> ps;			<span class="comment">//计数为0时，释放</span></span><br><span class="line">		<span class="keyword">delete</span> use;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符定义：</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;p)&#123;</span><br><span class="line">	++*p.use;		<span class="comment">//递增右侧计数器</span></span><br><span class="line">	<span class="keyword">if</span>(--*use==<span class="number">0</span>)&#123;		<span class="comment">//递减左侧计数器，并判断</span></span><br><span class="line">		delele ps;</span><br><span class="line">		<span class="keyword">delete</span> use;</span><br><span class="line">	&#125;</span><br><span class="line">	ps=p.ps;			<span class="comment">//共享该堆内数据</span></span><br><span class="line">	i=p.i;</span><br><span class="line">	use=p.use;		<span class="comment">//共享计数器</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;		<span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换操作</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp; p1,HasPtr &amp;p2)</span></span>&#123;		<span class="comment">//定义该类自己的swap</span></span><br><span class="line">	<span class="keyword">using</span> std::swap;</span><br><span class="line">	<span class="built_in">swap</span>(p1.ps,p2,ps);		<span class="comment">//交换指针</span></span><br><span class="line">	<span class="built_in">swap</span>(p1.i,p2.i);			<span class="comment">//交换int成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="重载运算与类型转换">12.重载运算与类型转换</h4>
<p>当运算符被用于类类型对象时，c++语言允许我们为其指定新的含义，同时我们也能自定义类类型转换规则。<strong>重载运算符：</strong> <strong>它的名字由<code>operator</code>和其后要定义的运算符共同组成，它们的参数数量应该与运算符作用的运算对象数量一样多</strong>。 <strong>调用时左侧元素对象传递给第一个参数（若为成员函数则传给隐式this指针），右侧运算对象传递给之后的参数。重载不改变运算符原有的优先级</strong> 不能重载运算对象全为内置类型的运算符，既一定要包含至少一个类类型参数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span>,<span class="type">int</span>);		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure> <img src="/c-primer前部分/operator.png" width="700"></p>
<h5 id="输入和输出运算符">12.1 输入和输出运算符</h5>
<p>类需要定义适合其对象的新版本以支持IO操作，方便！</p>
<h6 id="重载输出运算符">12.1.1 重载输出运算符&lt;&lt;</h6>
<p>通常情况下第一个形参是<strong>非常量对象<code>ostream</code>的引用</strong>，之所以是<strong>非常量</strong>是因为向流写入对象会改变其状态，第二个参数(要IO操作的)是常量的引用.返回ostream对象。</p>
<ol type="1">
<li>输出运算不要考虑格式化操作，尤其不会打印换行符，应当主要负责打印对象的内容。</li>
<li>与<code>iostream</code>兼容的<strong>输入输出运算符必须是普通的非成员函数</strong>，而不能是类的成员函数，否则左侧的运算对象是我们类的一个对象。因此如果想为自定义类重载IO运算符就要定义成非成员函数，但是为了读取私有数据成员，常声明为友元</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> Sales_data &amp;item)&#123;		<span class="comment">//非成员函数</span></span><br><span class="line">	os&lt;&lt;item.<span class="built_in">isbn</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.units_sold&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">	&lt;&lt;item.revenue&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line">Sales_data data;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(cout,data);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">cout&lt;&lt;data;</span><br></pre></td></tr></table></figure>
<h6 id="重载输入运算符">12.1.2 重载输入运算符&gt;&gt;</h6>
<p>输入运算符的第一个形参是将要读取的流的引用，第二个形参是将要读取到的对象的引用，返回流的引用.输入运算符负担从流中读取数据到对象的工作，需要注意的是，应当处理输入可能失败的状态: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(ostream&amp; is, Sales_data &amp;item)&#123;		<span class="comment">//非成员函数</span></span><br><span class="line">	<span class="type">double</span> price;			<span class="comment">//临时变量</span></span><br><span class="line">	is&gt;&gt;item.units_sold&gt;&gt;item.bookNo&gt;&gt;price;	<span class="comment">//读取</span></span><br><span class="line">	<span class="keyword">if</span>(is)		<span class="comment">//检查输入是否成功</span></span><br><span class="line">		item.revenue=item.unit_sold*price;</span><br><span class="line">	<span class="keyword">else</span>			<span class="comment">//失败，则置为默认状态</span></span><br><span class="line">		item=<span class="built_in">Sales_data</span>();</span><br><span class="line">	retuen is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="算术和关系运算符">12.2 算术和关系运算符</h5>
<p>我<strong>们把算术和关系运算符定义为非成员函数来允许对左侧或右侧的运算对象进行转换，因为不需要改变运算对象的状态，形参都是常量的引用。</strong> 算术运算符计算它的两个对象并得到一个新值，有区别于任意一个运算对象，位于一个局部变量内，操作完成后返回该局部变量的副本 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data&amp;,rhs)&#123;</span><br><span class="line">	Sales_data sum=lhs;</span><br><span class="line">	sum+=rhs;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="相等运算符">12.2.1 相等运算符</h6>
<p>C++中的相等运算符应当比较每一个数据成员，当对应的成员都相等时才认为两个对象相等，所以我们的相等运算符不但应当比较<code>bookNo</code>，还应当比较具体的销售数据。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data&amp; rhs)&#123;</span><br><span class="line">	<span class="keyword">return</span>	lhs.<span class="built_in">isbn</span>()==rhs.<span class="built_in">isbn</span>()&amp;&amp;lhs.<span class="built_in">units_sold</span>()==rhs.<span class="built_in">units_sold</span>()</span><br><span class="line">	&amp;&amp;lhs.<span class="built_in">revenue</span>()==rhs.<span class="built_in">revenue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Sales_data&amp; lhs,<span class="type">const</span> Sales_data&amp; rhs)&#123;</span><br><span class="line">	<span class="keyword">return</span> !lhs==rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>显然如果一个类有判断两个对象是否相等的操作，我们应当重载运算符而不是新增函数，更容易使用</li>
<li>定义了<code>operator==</code>应当能判断一组给定的对象中是否有重复数据</li>
<li>相等运算符应当具有传递性，既<code>a==b、b==c</code>为真,那么<code>a==c</code>也该为真</li>
<li>定义了<code>operator==</code>则应该定义<code>operator!=</code>并且可以利用已经重载的运算符来实现另一个运算符（如上例）</li>
</ul>
<h6 id="关系运算符">12.2.2 关系运算符</h6>
<ul>
<li><p>关系运算符应当定义顺序关系，令其与关联容器中对关键字的要求一致 , 如果类同时含有==运算符的话，应当定义关系与其保持一致，如果两个对象是<code>!=</code>的，那么一个对象应当<code>&lt;</code>另外一个</p></li>
<li><p>需要指出的是，<code>Sales_data</code>是不存在逻辑可靠的<code>&lt;</code>定义的，首先，我们不能只比较<code>ISBN</code>，如果<code>ISBN</code>相同但<code>revenue</code>和<code>units_sold</code>是不相等的，但一个对象<code>units_sold</code>大，一个<code>revenue</code>大，所以一个对象并不比另一个小（任意对象不比另一个小，按道理讲这两个对象是相等的），但对象其实又不是相等的，所以逻辑会出现问题。所以像这种类不定义<code>&lt;</code>比较好</p></li>
</ul>
<h5 id="赋值运算符">12.3 赋值运算符</h5>
<p>将类的一个对象赋值给另一个对象，类也可以定义其他赋值运算符来使用a值运算符：它可以使用别的类型作为右值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrVec&amp; <span class="keyword">operator</span>=(Strvec&amp; li)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;li)&#123;</span><br><span class="line">			<span class="keyword">this</span>.elements=li.elements;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	StrVec&amp; <span class="keyword">operator</span>+=(Strvec&amp; li)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;li)&#123;</span><br><span class="line">			<span class="keyword">this</span>.elements+=li.elements;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="下标运算符">12.4 下标运算符</h5>
<p>下标运算符必须是<strong>成员函数，通常以所访问的元素的引用作为返回值</strong>，进一步，最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，返回常量引用来确保不会对返回的对象赋值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index)&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.<span class="built_in">size</span>()&lt;index<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;index is out of range&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> elements[index];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.<span class="built_in">size</span>()&lt;index<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;index is out of range&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> elements[index];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="递增和递减运算符">12.5 递增和递减运算符</h5>
<p>在迭代器类中通常会实现递增运算符<code>++</code>和递减运算符<code>--</code>，着两种运算符使得类可以在元素序列中前后移动，建议将其设为成员函数。其有前置和后置版本: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	A&amp; <span class="keyword">operator</span>++();</span><br><span class="line">	A&amp; <span class="keyword">operator</span>--();</span><br><span class="line">	A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>);		<span class="comment">//后置版本</span></span><br><span class="line">	A&amp; <span class="keyword">operator</span>--(<span class="type">int</span>);		<span class="comment">//后置版本</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">	++num;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	--num;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 前置后置运算符使用同一个符号，意味着其重载版本所用的名字是相同的，并且运算对象的数量和类型也相同，为了解决这个问题，后置版本接受一个额外的int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是参加运算。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	A* ret=<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> *ret;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	A* ret=<span class="keyword">this</span>;</span><br><span class="line">	--*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> *ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="成员访问运算符">12.6 成员访问运算符</h5>
<p>在迭代器类和智能指针类中，常常会用到解引用运算符<code>*</code>和箭头运算符。类成员访问运算符<code>*</code>和<code>-&gt;</code>可以被重载，但它较为麻烦。<strong>它被定义用于为一个类赋予&quot;指针&quot;行为。运算符<code>-&gt;</code> 必须是一个成员函数。如果使用了<code>-&gt;</code> 运算符，返回类型必须是指针或者是类的对象。</strong></p>
<p>运算符 <code>-&gt;</code> 通常与指针引用运算符 <code>*</code> 结合使用，用于实现&quot;智能指针&quot;的功能。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁时，或者当指针指向另一个对象时，会自动删除对象。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(vector&lt;<span class="type">int</span>&gt; vec) :<span class="built_in">vec</span>(vec) &#123;&#125;;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span>*() &#123;	<span class="comment">//返回类型</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;vec[current++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> current=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;* ve = &amp;vec;</span><br><span class="line">	<span class="function">B <span class="title">m</span><span class="params">(vec)</span></span>;</span><br><span class="line">	*m;</span><br><span class="line">	B* x = &amp;m;</span><br><span class="line">	x-&gt;<span class="keyword">operator</span>-&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt;运算符<code>-&gt;</code>的重载比较特别，它只能是非静态的成员函数形式，而且没有参数。如果返回值是一个原始指针，那么就将运算符的右操作数当作这个原始指针所指向类型的成员进返回；如果返回值是另一个类型的实例，那么就继续调用这个返回类型的 <code>operator-&gt;()</code> ，直到有一个调用返回一个原始指针为止，然后按第一种情况处理。</p>
<p>既然<code>-&gt;</code> 的重载可以返回一个类型的实例而非指针，那如果返回本身的类型呢，它会继续调用自己的<code>operator-&gt;()</code>，永无止尽 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Joke</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Joke&amp; <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Joke j;</span><br><span class="line">    std::cout &lt;&lt; j-&gt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其中 <code>j-&gt;i</code> 会导致自身的 operator-&gt;() 被无限调用。但编译器不是傻子，在使用GCC 4.8.2编译的时候，直接报错： <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error: </span>circular pointer delegation detected</span><br></pre></td></tr></table></figure></p>
<h5 id="函数调用运算符">12.7 函数调用运算符</h5>
<p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类得对象成员函数: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">absInt</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value&lt;<span class="number">0</span>?-value:value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line">absInt  abs;</span><br><span class="line"><span class="type">int</span> ui=<span class="built_in">abs</span>(<span class="number">-40</span>);		<span class="comment">//对类对象像调用函数一样调用</span></span><br></pre></td></tr></table></figure></p>
<h5 id="类型转换运算符">12.8 类型转换运算符</h5>
<p>在讲类的时候，<strong>提到单个参数的构造函数定义了一种隐式类型转换</strong>。这里，我们通过类型转换运算符和转换构造函数共同定义类类型转换，也被称为用户定义的类型转换</p>
<h6 id="类型转换运算符-1">12.8.1 类型转换运算符</h6>
<p><strong>是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型</strong>。<code>operator type()const</code>该运算符没有显式的返回类型，形参，必须定义成类的成员函数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SmallInt</span>(<span class="type">const</span> <span class="type">int</span>&amp; i = <span class="number">0</span>) :<span class="built_in">val</span>(i) &#123;	<span class="comment">//转换构造函数</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i&gt;<span class="number">255</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Bad_int_value&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">aadd</span><span class="params">(<span class="type">const</span> SmallInt&amp; s)</span> </span>&#123; <span class="keyword">return</span> val + s.<span class="built_in">get</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;		<span class="comment">//类型转换运算符</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure> 定义了内置类型向类型的转换(转换构造函数），也定义了类类型向内置类型的转换(类型转换运算符） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SmallInt si;		<span class="comment">//构造函数 si=0,si为Smallint对象</span></span><br><span class="line">	si = <span class="number">4</span>;				<span class="comment">//合成默认赋值运算符 si=4，si为Smallint对象</span></span><br><span class="line">	<span class="type">int</span> i=si+<span class="number">3</span>;			<span class="comment">//调用类型转换运算符，si转换为int</span></span><br><span class="line">	si.<span class="built_in">aadd</span>(i);			<span class="comment">//会调用单参const构造函数构造零时对象，后在调用aadd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型转换运算符可能有意外结果，因为如果类型转换自动发生，用户可能感觉意外。我们经常会定义向bool的转换，但是类类型的对象转换为bool后就能被用在任何需要算术类型的地方<code>int i=42; cin&lt;&lt;i;</code>会造成cin转换为bool类型，然后左移位i个位置。为防止这样的情况发生，C++11=-引入了显式类型转换运算符: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;		<span class="comment">//类型转换运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示调用</span></span><br><span class="line"><span class="type">int</span> i=si.<span class="keyword">operator</span> <span class="built_in">int</span>() + <span class="number">3</span>;			<span class="comment">//si转换为int</span></span><br></pre></td></tr></table></figure> 这种情况下当显式地请求转换，才会执行类类型到内置类型的转换。但是如果表达式被用作条件，编译器将会执行显式的类型转换。<strong>即如果表达式出现在：<code>if while do的条件部分，for语句头的条件表达式，逻辑与或非</code>，显式类型转换将会被隐式执行</strong>。</p>
<h6 id="避免二义性的类型转换">12.8.2 避免二义性的类型转换</h6>
<p>需要确保在类类型和目标类型之间只存在唯一一种转换方式，否则代码会有二义性。</p>
<ul>
<li>比如两个类提供了相同的类型转换方式，或者一个类定义了多个转换运算符。存在二义性，就必须显式地调用类型转换运算符或者转换构造函数。</li>
<li>如果定义了多个参数都为算术类型的构造函数和对应类型转换运算符，有可能会产生二义性，原因是在隐式类型转换时，标准类型转换级别一致，这决定了编译器选择最佳匹配的过程。如果转换级别有一个更高，则不会出现二义性错误</li>
</ul>
<h4 id="函数对象">13. 函数对象</h4>
<h5 id="lambda是函数对象">13.1 lambda是函数对象</h5>
<p>我们编写一个<code>lambda</code>后，编译器将表达式翻译成一个未命名类的未命名对象，这个类中有一个重载的函数调用运算符。如下面这个<code>lambda</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">const</span> string&amp;a,<span class="type">const</span> string&amp;b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();&#125;);</span><br></pre></td></tr></table></figure> 相似于下面类对象：由于默认情况下<code>lambda</code>不能改变它捕获的变量，因此在默认情况下<code>lambda</code>生成的类当中的函数调用运算符是<code>const</code>成员函数: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shorter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp;a,<span class="type">const</span> string&amp;b)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="生成类对于lambda的值捕获与引用捕获的不同">13.2 生成类对于lambda的值捕获与引用捕获的不同</h5>
<p><strong>当<code>lambda</code>表达式通过</strong>引用捕获变量时<strong>，程序确保<code>lambda</code>执行引用时所引用的对象确实存在，编译器可以直接使用该引用而无需再<code>lambda</code>产生的类中将其存储。但是通过值捕获时，在<code>lambda</code>生成的类中需要为值捕获的变量生成数据成员，创建构造函数：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> w=<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[sz](<span class="type">const</span> string&amp;a,)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;&#125;);</span><br></pre></td></tr></table></figure> 该<code>lambda</code>值捕获<code>sz</code>，则其产生的类将形如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sizecmp</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Sziecamp</span>(<span class="type">size_t</span> n):<span class="built_in">sz</span>(n)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp;a)</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">size_t</span> sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 标准库定义了一组表示算术、关系、逻辑运算符的类，都被定义成模板的形式，可以为其指定具体的应用类型即调用运算符的形参类型。</p>
<h5 id="标准库定义的函数对象">13.3 标准库定义的函数对象</h5>
<p>标准库定义了一组表示算术、关系、逻辑运算符的类，都被定义成模板的形式，可以为其指定具体的应用类型即调用运算符的形参类型。 <img src="/c-primer前部分/func.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="type">int</span>&gt; intadd;</span><br><span class="line"><span class="type">int</span> sum=<span class="built_in">intadd</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure> 表示运算符的函数对象类常用来替换算法中的默认运算符，如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用greater代替默认的，此时执行降序排序</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),greater&lt;string&gt;);</span><br></pre></td></tr></table></figure> 第三个实参是<code>greater&lt;string&gt;</code>类型的一个未命名的对象，需要注意的是，标准库定义的函数对象也适用于指针，但不能用大于小于号而是用<code>less</code>函数对象</p>
<h5 id="可调用对象与function">13.4 可调用对象与function</h5>
<p><strong><code>function</code>函数是一直通用、多态的函数封装，它的实例可以对任何可以调用的目标进行存储、赋值和调用操作。是C++现有的对可以调用实体的一种安全的包裹，简而言之，<code>function</code>就是可调用对象的容器。</strong> 进一步讲，<code>function</code>模板类就是为了解决<code>lambda</code>表达式的存入问题，因为每个<code>lambda</code>有它自己的类型，该类型会与<code>map</code>中的定好的值的类型不匹配，步骤：</p>
<ul>
<li><strong>C++的可调用对象有：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类</strong>，其实可调用对象也有类型，每个<code>lambda</code>有它自己唯一的类类型，函数及函数指针的类型由其返回值和实参类型决定</li>
<li><strong>不同类型的可调用对象可能共享同一种调用形式</strong>，指明了返回类型和传递给调用的实参类型。例如普通函数加、<code>lambda</code>表达式减和函数对象类除法的调用方法都为:<code>mod(a,b)</code>为了利用这些可调用对象，可以定义一个函数表来存储指向这些可调用对象的指针。</li>
<li>用运算符符号的<code>string</code>对象作为关键字，<strong>用实现运算符的函数作为值构建运算符到函数指针的映射</strong><code>map&lt;string, function&lt;int(*)(int,int)&gt;&gt; binops;</code></li>
<li>再利用<code>function&lt;T&gt; f</code>来创建可放入容器中的类型，无论函数指针，<code>lambda</code>表达式，函数对象、类的对象都可保存，<strong>但也不能把重载函数的名字直接存入<code>map</code>中，而是要利用函数指针或者<code>lambda</code>表达式</strong>；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line">map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; bin;</span><br><span class="line"><span class="built_in">int</span> (*fp)(<span class="type">int</span>,<span class="type">int</span>)=add;</span><br><span class="line">bin.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,fp&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/c-primer前部分/funcoperate.png" width="700"></p>
<h4 id="容器概述">14.容器概述</h4>
<h5 id="stl提供了六大组件">14.1 STL提供了六大组件</h5>
<ul>
<li>容器：各种数据结构,如<code>vector、list、deque、set、map</code>等,用来存放数据</li>
<li>算法：各种常用的算法（冒泡，排序）,如<code>sort、find、copy、for_each</code></li>
<li>迭代器：扮演了容器与算法之间的胶合剂（类似于指针等）</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理。注意一般都伴随着重新分配空间，那么原来的迭代器就会失效</li>
</ul>
<p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p>
<h5 id="三大重点组件">14.2 三大重点组件</h5>
<p>容器有<strong>序列式容器</strong>和<strong>关联式容器</strong>：</p>
<ul>
<li>序列式容器：序列式容器就是容器元素在容器中的位置是由元素进入容器的时间和地点来决定</li>
<li>关联式容器：关联式容器是指容器已经有了一定的规则，容器元素在容器中的位置由容器的规则来决定</li>
</ul>
<p>算法分为<strong>质变算法</strong>和<strong>非质变算法</strong>： - 质变算法：：是指运算过程中会更改区间内的元素的内容 - 非质变算法：是指运算过程中不会更改区间内的元素内容</p>
<p><strong>迭代器</strong></p>
<ul>
<li><strong>输入迭代器</strong>：提供对数据的只读访问 只读，支持<code>++、==、！=</code></li>
<li><strong>输出迭代器</strong>：提供对数据的只写访问 只写，支持<code>++</code></li>
<li><strong>前向迭代器</strong>：提供读写操作，并能向前推进迭代器 读写，支持<code>++、==、！=</code></li>
<li><strong>双向迭代器</strong>：提供读写操作，并能向前和向后操作 读写，支持<code>++、--，</code></li>
<li><strong>随机访问迭代器</strong>：提供读写操作，并能在数据中随机移动 读写，支持<code>++、--、[n]、+n、-n、&lt;、&lt;=、&gt;、&gt;=</code></li>
</ul>
<p><strong>重点学习双向迭代器和随机访问迭代器</strong></p>
<ul>
<li>双向迭代器：++,--可以访问下一个元素和上一个元素(list、forward_list、关联容器set/map）</li>
<li>随机访问迭代器：+2，可以跳2个元素访问元素、下标访问（vector、deque、string、array)</li>
</ul>
<p>三大组件的关系：容器存储数据，并且提供迭代器，算法使用迭代器来操作容器中的元素 ##### 14.3 STL优点</p>
<ul>
<li>STL是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li>
<li><strong>STL的一个重要特点是数据结构和算法的分离</strong>。尽管这是个简单的概念，但是这种分离使得 STL 变得非常通用。例如:在 STL 的<code>vector</code>容器中，可以放入元素、基础数据类型变量、元素的地址；STL 的<code>sort()</code>排序函数可以用来操作 <code>ector,list</code>等容器。</li>
<li>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就行了。这样他们就可以把精力放在程序开发的别的方面。</li>
<li>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</li>
</ul>
<p><strong>高可重用性</strong>：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知 识，已经给大家介绍了。</p>
<p><strong>高性能</strong>：如<code>map</code>可以高效地从十万条记录里面查找出指定的记录，因为<code>map</code>是采用红黑树的变体实现的。(红黑树是平横二叉树的一种) 高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</p>
<h4 id="序列式式容器">15. 序列式式容器</h4>
<p>所有容器类都有共享公共接口，不同容器按不同方式对其进行扩展</p>
<h5 id="顺序容器种类">15.1 顺序容器种类</h5>
<p>所有顺序容器都提供了快速顺序访问元素的能力。下表中的string我们已经在前面介绍，这里不重复做介绍： <img src="/c-primer前部分/rongqi.png" width="700"></p>
<ul>
<li><strong><code>string和vector</code>将元素保存在连续的内存空间内，因此由元素的下标来计算其地址是非常快速的</strong>。但是，在这两种容器的中间位置添加或删除元素就会非常耗时。即随机访问迭代器</li>
<li><strong><code>list</code>和<code>forward_list</code>在任何位置添加/删除元素都非常快速</strong>。作为代价，这两个容器不支持元素的随机访问。而且，与<code>vector、array、deque</code>相比，这两个容器的额外内存开销(指针开销)也很大。另外<code>forward_list</code>没有<code>size</code>操作。</li>
</ul>
<p><strong>确定使用哪种顺序容器:</strong></p>
<ul>
<li>通常使用vector是最好的选择，除非你有更好的理由选择其他容器</li>
<li>注重空间开销的，不要使用list或forward_list</li>
<li>只在头尾，不在中间插入/删除元素的，使用deque</li>
<li>在中间插入/删除元素的，使用list或forward_list</li>
</ul>
<p>总之选择哪一种容器需要依据需求而决定</p>
<h5 id="序列容器支持的操作概览">15.2 序列容器支持的操作概览</h5>
<h6 id="容器操作">15.2.1 容器操作</h6>
<p>对与序列式容器，它们有一些公共接口，支持相同的操作方式(除特别标注)： <img src="/c-primer前部分/rongqioperate.png" width="600"></p>
<h6 id="顺序容器操作迭代器">15.2.2 顺序容器操作：迭代器</h6>
<p>标准容器类型上所有迭代器都允许我们访问容器中的元素（通过解引用运算符来实现），所有迭代器都定义了递增运算符。 <img src="/c-primer前部分/iteratoroperate.png" width="700"> 个迭代器的范围由一对迭代器表示，两个迭代器分别指向同一容器中的首元素<code>begin</code>和尾元素之后<code>end</code>的位置,其标准的数学表达为<code>[begin,end)</code>。 <strong>对一个非常量对象调用<code>begin、end、rbegin、rend</code>（反向跌代），得到的是返回<code>iterator</code>的版本；对一个<code>const</code>对象调用这些函数时，才会得到一个const版本</strong>。但以c开头的版本还是可以获得<code>const_iterator</code>的，而不管容器的类型是什么,<strong>因此当不需要写访问时，应使用<code>cbegin</code>和<code>cend</code>.</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; a=&#123;<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;making&quot;</span>,<span class="string">&quot;track&quot;</span>,<span class="string">&quot;2025&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">begin</span>();		<span class="comment">//list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">rbegin</span>();	<span class="comment">//list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">cbegin</span>();	<span class="comment">//list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">crbegin</span>();	<span class="comment">//list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure></p>
<h6 id="顺序容器操作定义和初始化">15.2.3 顺序容器操作：定义和初始化</h6>
<p>每个容器都定义了一个默认构造函数（除array,它按默认方式初始化）: <img src="/c-primer前部分/rongqichushihua.png" width="700"></p>
<p><strong>1. 当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了，元素类型也可以不同，只要能将元素类型转换即可</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; ls=&#123;<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;making&quot;</span>,<span class="string">&quot;track&quot;</span>,<span class="string">&quot;2025&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt;vec=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">ls_1</span><span class="params">(ls)</span></span>;		<span class="comment">//正确，类型匹配</span></span><br><span class="line"><span class="comment">//deque&lt;string&gt; dq(ls);		//错误，容器类型不匹配</span></span><br><span class="line"><span class="comment">//vector&lt;string&gt; ves(vec);	//错误，元素类型不匹配</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">ves</span><span class="params">(vec.begin(),vec.end())</span></span>;	<span class="comment">//正确，元素类型const char*可向string转换</span></span><br></pre></td></tr></table></figure> <strong>2. 与顺序容器大小相关的构造函数:除了有与关联容器相同的构造函数外，顺序容器（除array)还提供了另一个构造函数：它接受一个容器大小和一个（可选的）元素初始值。如果不提供元素初始值，则标准库会创建一个值初始化器</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">veci</span><span class="params">(<span class="number">10</span>,<span class="number">-1</span>)</span></span>;	<span class="comment">//10个int元素，初始值为-1</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">ls</span><span class="params">(<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>)</span></span>;	<span class="comment">//10个string元素，初始值为hi</span></span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">fls</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//10个int元素，初始值为0，注意区分()和&#123;&#125;</span></span><br></pre></td></tr></table></figure> <strong>3. 标准库array具有固定大小：大小也是array类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,10&gt; ia1;		<span class="comment">//默认初始化10个int</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; ia2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;	<span class="comment">//列表初始化</span></span><br><span class="line">array&lt;<span class="type">int</span> 10&gt;ia3=&#123;<span class="number">10</span>&#125;;					<span class="comment">//第一个元素围为10，其余为0</span></span><br><span class="line"><span class="comment">//但ia3定义后在这样赋值不允许：(因为array不允许插入和删除）</span></span><br><span class="line">ia3=&#123;<span class="number">10</span>&#125;;	<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//数组类型无法拷贝和赋值，但array可以</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; ia4=ia2;		<span class="comment">//只有数组类型匹配array&lt;int,10&gt;即合法</span></span><br></pre></td></tr></table></figure></p>
<h6 id="顺序容器操作添加元素">15.2.4 顺序容器操作：添加元素</h6>
<p><img src="/c-primer前部分/pushback.png" width="700"> <strong>1. 除<code>array</code>和<code>forward_list</code>之外，每个顺序容器（包括<code>string</code>类型)都支持<code>push_back</code>,它将一个元素加到容器尾部:</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(<span class="type">size_t</span> cnt, string &amp;word)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt&gt;<span class="number">1</span>)</span><br><span class="line">word.<span class="built_in">push_back</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 除<code>string</code>和<code>vector</code>不支持<code>push_front</code>外，<code>list、forward_list、deque</code>容器都支持push_front,即将元素插入到容器头部</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> ix=<span class="number">0</span>;ix!=<span class="number">4</span>;++ix)</span><br><span class="line">p.<span class="built_in">push_front</span>(ix);</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 特定位置插入元素<code>insert</code>。forward_list有自己版本的<code>insert</code></strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; sece;</span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">begin</span>(),<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//插入范围元素</span></span><br><span class="line">ist&lt;string&gt; p=&#123;<span class="string">&quot;wwj&quot;</span>,<span class="string">&quot;love&quot;</span>&#125;;</span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">begin</span>(),<span class="number">10</span>,<span class="string">&quot;CRF&quot;</span>);		<span class="comment">//10个“CRF&quot;插入到容器头部</span></span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">begin</span>()+<span class="number">3</span>,p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//p容器的内容拷贝插入到了sece第四个元素前</span></span><br><span class="line">sece.<span class="built_in">insert</span>(sece.<span class="built_in">end</span>(),&#123;<span class="string">&quot;these&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="string">&quot;are&quot;</span>,<span class="string">&quot;finished&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//将元素值列表插入到尾部</span></span><br></pre></td></tr></table></figure> 以上的insert调用后，会返回新添加的第一个元素的迭代器，若没有插入元素则返回原迭代器</p>
<p><strong>4.c++新标准引入三个新成员：<code>emplace_front</code>对应<code>push_front</code>、<code>emplace_back</code>对应<code>push_back</code>、<code>emplace</code>对应<code>insert</code>。主要区别是这些操作是构造不是拷贝元素。也就说明传入给<code>emplace</code>的参数必须与元素类型的构造函数相匹配(即个数、类型一样），先假设有定义的<code>Sales_data</code>类型有一个三参构造函数：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Sales_data&gt; c;</span><br><span class="line">c.<span class="built_in">emplace_back</span>(<span class="string">&quot;p78&quot;</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"><span class="comment">//该式子等价于c.push_back(Sales_data(&quot;p78&quot;,20,30));</span></span><br></pre></td></tr></table></figure></p>
<h6 id="顺序容器操作访问元素">15.2.5 顺序容器操作：访问元素</h6>
<p><img src="/c-primer前部分/fangwen.png" width="700"> 这些访问操作（<code>back、front</code>、下标、<code>at</code>)返回的都是引用，如果容器是一个<code>const</code>对象，则返回的是<code>const</code>的引用，不是则返回普通的引用（可以改变元素值）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!c.<span class="built_in">empty</span>())&#123;</span><br><span class="line">	c.<span class="built_in">front</span>()=<span class="number">42</span>;	<span class="comment">//将42赋予c的第一个元素</span></span><br><span class="line">	<span class="keyword">auto</span> &amp;v1=c.<span class="built_in">back</span>();</span><br><span class="line">	v1=<span class="number">1024</span>;		<span class="comment">//改变最后一个元素的值</span></span><br><span class="line">	<span class="keyword">auto</span> v2=c.<span class="built_in">back</span>();</span><br><span class="line">	v2=<span class="number">0</span>;		<span class="comment">//无法改变值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="顺序容器操作删除元素">15.2.6 顺序容器操作：删除元素</h6>
<p><img src="/c-primer前部分/delete.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除list中的所有奇数：</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it=lst.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it!=lst.<span class="built_in">end</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span>(*it%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">		it=lst.<span class="built_in">erase</span>(it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="顺序容器操作赋值和swap">15.2.7 顺序容器操作：赋值和swap</h6>
<p>该表中的赋值运算符可用于所有容器: <img src="/c-primer前部分/fuzhi.png" width="700"></p>
<p><strong>1. 赋值运算符<code>=</code>要求左边和右边的运算对象具有相同的类型。<code>assign</code>允许我们从一个相容 的类型赋值，或者从容器一个子序列赋值</strong>(由于左右两边的运算容器大小可能不同，所有<code>array</code>无法使用<code>assign</code>)。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一：</span></span><br><span class="line">list&lt;string&gt;names;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt;oldstyle&#123;<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>,<span class="string">&quot;man&quot;</span>&#125;;</span><br><span class="line">names.<span class="built_in">assign</span>(oldstyle.<span class="built_in">cbegin</span>(),oldstyle.<span class="built_in">cend</span>());	<span class="comment">//names的元素替换为oldstyle中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">slist</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">//1个元素且为空字符串</span></span><br><span class="line">slist.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="string">&quot;Hello&quot;</span>）；	<span class="comment">//10个元素且都为Hello</span></span><br></pre></td></tr></table></figure></p>
<p><strong><code>swap</code>操作交换两个相同类型容器的内容。除<code>array</code>外，交换两个容器内容的操作保证会很快——元素本身未交换，swap只是交换了两个容器的内部数据结构（即只是交换了第一次指向的指针)。即也代表着指向容器的迭代器、引用和指针在<code>swap</code>前后都不会改变（除<code>string</code>、<code>array</code>容器）</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">s1</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">vector&lt;string&gt;<span class="built_in">s2</span>(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">swap</span>(s1,s2);		<span class="comment">//执行完后s1指向的是30个元素，s2是（42）</span></span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong>对于<code>array</code>，<code>swap</code>会真正交换它们的元素。</p>
<h6 id="顺序容器操作改变容器大小">15.2.8 顺序容器操作：改变容器大小</h6>
<p><img src="/c-primer前部分/resize.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst</span><span class="params">(<span class="number">10</span>,<span class="number">42</span>)</span></span>;</span><br><span class="line">lst.<span class="built_in">resize</span>(<span class="number">20</span>);		<span class="comment">//将后10个值赋值为0</span></span><br><span class="line">lst.<span class="built_in">resize</span>(<span class="number">30</span>,<span class="number">-1</span>);	<span class="comment">//将10个值为-1的添加到尾部</span></span><br><span class="line">lst.<span class="built_in">resize</span>(<span class="number">10</span>);		<span class="comment">//删除后20个元素</span></span><br></pre></td></tr></table></figure></p>
<h6 id="容器操作可能使迭代器失效">15.2.9 容器操作可能使迭代器失效</h6>
<p>在对容器进行添加删除可能会使迭代器失效。一个失效的指针、引用和迭代器只是不再表示任何元素。此题的<code>vector</code>的<code>end</code>作为条件，要时时刻刻在插入或删除后更新。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>，<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter=vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(iter!=vi.<span class="built_in">end</span>())&#123;</span><br><span class="line">	<span class="keyword">if</span>(*iter%<span class="number">2</span>)&#123;</span><br><span class="line">		iter=vi.<span class="built_in">insert</span>(iter,*iter);	<span class="comment">//返回插入后的的迭代器</span></span><br><span class="line">		iter+=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		iter=vi.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="关系运算符-1">15.2.10 关系运算符</h6>
<ul>
<li>关系运算符两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素</li>
<li>比较两个容器实际上是进行元素的逐对比较，比较方式与string比较类似。</li>
<li>容器的关系运算符使用元素的关系运算符完成比较</li>
<li>只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</li>
</ul>
<h5 id="vector容器">15.3vector容器</h5>
<p><code>vector</code>是STL常用的容器之一，它和数组一样拥有连续的内存空间，但却比数组更好用。<strong><code>String</code>和<code>vector</code>均使用随机访问迭代器。<code>vector</code>在空间配置器下重新分配空间，那么原来的迭代器就会失效.</strong> <img src="/c-primer前部分/vector.png" width="500"></p>
<h6 id="vector的扩容机制">15.3.1 vector的扩容机制</h6>
<p><strong>对于能够快速随机访问的(下标访问），其内存是连续的，当我们的内存不够时，容器必须分配新的内存空间来保存已有的和新的元素(即将旧内存的元素拷贝到新内存，添加新元素，释放旧内存），所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为O(n)。</strong>。</p>
<p>当不得不获取新的内存空间时，<code>vector</code>和<code>string</code>的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可以来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。<strong>在不同的编译器中，vector的扩容策略不相同，msvc编译器每次是以1.5倍且向下取整的策略进行扩容，gcc编译器则是每次以2.0倍的策略进行扩容。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MSVC</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">34</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(n);</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;size:&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot;  capacity:&quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">size:<span class="number">1</span>  capacity:<span class="number">1</span></span><br><span class="line">size:<span class="number">2</span>  capacity:<span class="number">2</span></span><br><span class="line">size:<span class="number">3</span>  capacity:<span class="number">3</span></span><br><span class="line">size:<span class="number">4</span>  capacity:<span class="number">4</span></span><br><span class="line">size:<span class="number">5</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">6</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">7</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">8</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">9</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">10</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">11</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">12</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">13</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">14</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">15</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">16</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">17</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">18</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">19</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">20</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">21</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">22</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">23</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">24</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">25</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">26</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">27</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">28</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">29</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">30</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">31</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">32</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">33</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">34</span>  capacity:<span class="number">42</span></span><br></pre></td></tr></table></figure></p>
<h6 id="管理容量的成员函数">15.3.2 管理容量的成员函数</h6>
<p><img src="/c-primer前部分/managercapacity.png" width="700"></p>
<ul>
<li><code>reverse</code>并不改变容器中元素的数量，它仅影响<code>vector</code>预先分配多大的内存空间。</li>
<li>如果需求大小小于或等于当前容量，<code>reverse</code>什么也不做。且需求大小小于当前容量，容器不会退回内存空间。</li>
</ul>
<p><strong>源码：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type __new_size)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (__new_size &gt; <span class="built_in">size</span>()) </span><br><span class="line">		  _M_default_append(__new_size - <span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">		  _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start + __new_size);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//reserve</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (__n &gt; <span class="built_in">max_size</span>())</span><br><span class="line">	__throw_length_error(__N(<span class="string">&quot;vector::reserve&quot;</span>));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">capacity</span>() &lt; __n)</span><br><span class="line">	_M_reallocate(__n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="vector构造函数">15.3.3 vector构造函数</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v; <span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br><span class="line"><span class="comment">//例子 使用第二个构造函数 我们可以...</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>; </span><br></pre></td></tr></table></figure>
<h6 id="vector数据存取操作">15.3.4 vector数据存取操作</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> idx); <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>
<h6 id="vector插入和删除操作">15.3.5 vector插入和删除操作</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele);<span class="comment">//迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line"><span class="built_in">push_back</span>(ele); <span class="comment">//尾部插入元素ele</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);<span class="comment">//删除迭代器指向的元素</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure>
<h5 id="deque容器">15.4 deque容器</h5>
<p><strong><code>Vector</code>容器是单向开口的连续内存空间，<code>deque</code>则是一种双向开口的连续线性空间</strong>。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受 <img src="/c-primer前部分/deque.png" width="500"></p>
<p>虽然<code>deque</code>容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和<code>vector</code>不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用<code>vector</code>，而不是<code>deque</code>。对<code>deque</code>进行的排序操作，为了最高效率，可将<code>deque</code>先完整的复制到一个<code>vector</code>中，对<code>vector</code>容器进行排序，再复制回<code>deque</code>.</p>
<h6 id="deque容器实现原理">15.4.1 deque容器实现原理</h6>
<p><strong><code>deque</code>是由一段一段的定量的连续空间构成。一旦有必要在<code>deque</code>前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在<code>deque</code>的头端或者尾端。<code>deque</code>最大的工作就是维护这些分段连续的内存空间的整体性的假象</strong>，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p>
<p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。 <strong><code>Deque</code>采取一块所谓的<code>map</code>(注意，不是STL的map容器)作为主控，这里所谓的<code>map</code>是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是<code>deque</code>的存储空间的主体。</strong> <img src="/c-primer前部分/dequemap.png" width="500"></p>
<h6 id="deque常用api">15.4.2 deque常用API</h6>
<p><strong>1. deque构造函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;deq);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.deque赋值操作</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">deque&amp;<span class="keyword">operator</span>=(<span class="type">const</span> deque &amp;deq); <span class="comment">//重载等号操作符 </span></span><br><span class="line"><span class="built_in">swap</span>(deq);<span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3. deque双端插入和删除操作</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//删除容器第一个数据</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4. deque访问操作</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span>(idx);<span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个数据。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure></p>
<p><strong>5. deque插入操作</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure></p>
<h5 id="list容器">15.5 list容器</h5>
<p><strong>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</strong> 相较于<code>vector</code>的连续线性空间，<code>list</code>就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，<code>list</code>对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，<code>list</code>永远是常数时间。</p>
<p><strong><code>list</code>和<code>vector</code>是两个最常被使用的容器。<code>list</code>容器是一个双向链表:</strong></p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
<li>链表灵活，但是空间和时间额外耗费较大 <img src="/c-primer前部分/list.png" width="500"></li>
</ul>
<h6 id="list容器的迭代器">15.5.1 list容器的迭代器</h6>
<p><code>list</code>容器不能像<code>vector</code>一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。<code>list</code>迭代器必须有能力指向<code>list</code>的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”<code>list</code>正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员</p>
<p><strong>由于<code>list</code>是一个双向链表，迭代器必须能够具备前移、后移的能力，所以<code>list</code>容器提供的是Bidirectional Iterators.<code>list</code>有一个重要的性质，插入操作和删除操作都不会造成原有<code>list</code>迭代器的失效</strong>。这与<code>vector</code>是不同的，<code>vector</code>插入操作可能造内存重新配置导致原有的迭代器全部失效。</p>
<h6 id="list常用api">15.5.2 list常用API</h6>
<p><strong>1. list构造函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; lstT;<span class="comment">//list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list &amp;lst);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. list数据元素插入和删除操作</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器中最后一个元素</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器开头插入一个元素</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">remove</span>(elem);<span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3. list赋值操作</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">list&amp;<span class="keyword">operator</span>=(<span class="type">const</span> list &amp;lst);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(lst);<span class="comment">//将lst与本身的元素互换。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4. list数据的存取、反转和排序</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素。</span></span><br><span class="line"><span class="built_in">reverse</span>();<span class="comment">//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span></span><br><span class="line"><span class="built_in">sort</span>(); <span class="comment">//list排序</span></span><br></pre></td></tr></table></figure></p>
<p><strong>5. list和forward_list独有的函数</strong> 与其他容器不同，链表类型的<code>list</code>和<code>forward_list</code>定义了几个成员函数形式的算法。<strong>特别的是，它们定义可独有的<code>sort、merge、remove、reverse、unique</code>。</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数名</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>lst.merge(lst2)</code></td>
<td style="text-align: center;">将<code>lst2</code>合并到<code>lst</code>,<code>lst</code>和<code>lst2</code>必须都是有序的，合并后<code>lst2</code>为空，默认为<code>&lt;</code>即升序合并</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>lst.merge(lst2,cmp)</code></td>
<td style="text-align: center;">使用给定的<code>cmp</code>合并</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>lst.remove(val)</code></td>
<td style="text-align: center;">内部调用<code>erase</code>删除给的值</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>lst.remove_if(pred)</code></td>
<td style="text-align: center;">使用一元谓词为真时删除</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>lst.reverse()</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>lst.sort()</code></td>
<td style="text-align: center;">升序排序</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>lst.sort(cmp)</code></td>
<td style="text-align: center;">使用谓词为真时排序</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>lst.unique()</code></td>
<td style="text-align: center;">去重，调用前必须有序</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>lst.unique(pred)</code></td>
<td style="text-align: center;">使用一元谓词为真时去重</td>
</tr>
</tbody>
</table>
<h4 id="适配器">16. 适配器</h4>
<p>除了顺序容器，还定义了三个顺序容器适配器：<code>stack（栈）、queue（队列）和priority_queue</code>。本质上，<strong>适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。</strong> <img src="/c-primer前部分/shipeiqi.png" width="700"></p>
<h5 id="适配器使用概览">16.1 适配器使用概览</h5>
<h6 id="定义适配器">16.1.1 定义适配器</h6>
<p>每个适配器都定义了<strong>两个构造函数：默认构造函数创建一个空对象;接受一个容器的构造函数拷贝该容器来初始化适配器。（下面的API介绍）</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span>；	<span class="comment">//接受一个容器对象初始化适配器，deq是一个deque&lt;int&gt;</span></span></span><br></pre></td></tr></table></figure> <strong>默认情况下，<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是在<code>vector</code>之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;string,vector&lt;string&gt;&gt; str_stk;	<span class="comment">//在vector上实现空栈</span></span><br><span class="line">stack&lt;string,vector&lt;string&gt;&gt; <span class="built_in">str_stk</span>(sevc);	<span class="comment">//构造在vector上实现，并初始化</span></span><br></pre></td></tr></table></figure></p>
<h6 id="适配器限制">16.1.2 适配器限制</h6>
<p>所有的适配器都要求能够删除和添加元素的能力，因此适配器不能构造在array上实现：</p>
<ul>
<li><strong><code>stack</code>——要求有<code>pop、push</code>和<code>top</code>能力，所以可用（除<code>array、forward_list</code>）的容器构造</strong></li>
<li><strong><code>queue</code>——要求有<code>back、push、front、pop</code>能力，所以可构造在<code>list、deque</code>，不能<code>vector</code></strong></li>
<li><strong><code>priority_queue</code>——要求有<code>front、push、pop和top</code>，所以可用<code>vector、deque</code>，但不能<code>list</code></strong></li>
</ul>
<h5 id="stacks适配器">16.2 stacks适配器</h5>
<p><code>stack</code>是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。<code>stack</code>容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取<code>stack</code>的其他元素。换言之，<code>stack</code>不允许有遍历行为。有元素推入栈的操作称为:<code>push</code>,将元素推出的操作称为<code>pop</code>. <img src="/c-primer前部分/stack.png" width="500"> <strong>栈适配器默认基于<code>deque</code>实现，也可以在<code>list</code>和<code>vector之</code>上实现</strong>。虽然<code>stack</code>是基于<code>deque</code>实现的，但我们不能调用<code>push_back</code>等等这些操作，我们必须调用它自己的操作。</p>
<h6 id="stack常用api">16.2.1 stack常用API</h6>
<p>Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，<strong>也不提供迭代器。</strong></p>
<p><strong>1. stack构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;<span class="comment">//stack采用模板类实现， stack对象的默认构造形式： </span></span><br><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack &amp;stk);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p><strong>2. stack数据存取操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>
<p><strong>3. stack赋值操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&amp;<span class="keyword">operator</span>=(<span class="type">const</span> stack &amp;stk);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>
<h5 id="queue适配器">16.3 queue适配器</h5>
<p><code>queue</code>是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，<code>queue</code>容器允许从一端新增元素，从另一端移除元素。<code>queue</code>默认基于<code>deque</code>实现，<code>priority_queue</code>默认基于<code>vector</code>实现</p>
<p><img src="/c-primer前部分/queue.png" width="500"></p>
<h6 id="queue常用api">16.3.1 queue常用API</h6>
<p><code>queue</code>所有元素的进出都必须符合”先进先出”的条件，只有<code>queue</code>的顶端元素，才有机会被外界取用。<code>queue</code><strong>不提供遍历功能，也不提供迭代器</strong>。</p>
<p><strong>1. queue构造函数</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：</span><br><span class="line">queue(const queue &amp;que);//拷贝构造函数</span><br></pre></td></tr></table></figure></p>
<p><strong>2. queue赋值操作</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&amp;<span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3.queue存取、插入和删除操作</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure></p>
<h4 id="关联式容器">17. 关联式容器</h4>
<h5 id="关联容器概述">17.1 关联容器概述</h5>
<p>与顺序容器不同，<strong>关联容器中的元素是按着元素的关键字来保存和访问的</strong>。顺序容器中的元素是按着它们在容器中的位置来顺序保存和访问。c++两个主要的关联容器是<code>map</code>和<code>set</code>。 <img src="/c-primer前部分/guanlian.png" width="700"></p>
<ul>
<li><code>map</code>中的元素是关键字-值<code>key-value</code>对。关键字起到索引的作用，值则是与索引相关联的数据。</li>
<li><code>set</code>中只包含一个关键字，<code>set</code>支持高效的关键字查询操作——检查一给定关键字是否在<code>set</code>中</li>
<li>标准库提供8个关联容器，它们的不同体现在三个维度上：<strong>①每个容器或者是个set或者是个map;②或者要求不重复的关键字，或者允许重复关键字；③按顺序保存元素，或者无序保存元素</strong></li>
<li>允许重复关键字关键字的容器名字中都包含<code>multi</code>;不保持关键字按顺序存储的容器的名字都以单词<code>unordered</code>开头。<strong>无序容器使用哈希函数来组织元素</strong>。</li>
<li>类型<code>map</code>和<code>multimap</code>定义在头文件<code>map</code>中，<code>set</code>和<code>multiset</code>定义在头文件<code>set</code>中。无序容器则定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中</li>
<li><strong><code>map、multimap、set、multiset</code>都是以红黑树为底层实现机制。<code>unordered_map</code>、<code>unordered_set</code>底层哈希表的实现机理</strong></li>
</ul>
<h5 id="关键字类型要求">17.2 关键字类型要求</h5>
<p>对于有序容器<code>map、multimap、set、multiset</code>，<strong>关键字类型必须定义元素比较的方式</strong>。默认情况下，标准库使用关键字类型的<code>&lt;</code>运算来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。</p>
<p>传递给排序算法的可调用对象必须满足与关联容器中关键字一样的类型要求。<strong>我们可以自定义操作来代替关键字上的<code>&lt;</code>操作，但所提供的操作必须在关键字类型上定义一个严格弱序——可以看做“小于等于”</strong>。在实际编程中，重要的是，如果一个类型定义了“行为正常”的&lt;运算符，则它可以用作关键字类型。</p>
<p><strong>当关键字类型使用自己定义的操作时，必须在定义关联容器类型时提供此操作的类型。即用尖括号指出要定义哪种类型的容器，自定义的操作必须在尖括号中紧跟着元素类型给出。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data&amp; a,<span class="type">const</span> Sales_data&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a,<span class="built_in">isbn</span>()&lt;b.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">multiset&lt;Sales_data,<span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt;	<span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="pair类型">17.3 pair类型</h5>
<p>对组<code>pair</code>将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用<code>pair</code>的两个公有属性<code>first</code>和<code>second</code>访问。<code>pair</code>与<code>map、multimap</code>和<code>unorderedmap</code>等联合使用. <img src="/c-primer前部分/pair.png" width="700"></p>
<h5 id="都支持的操作">17.4 都支持的操作</h5>
<p><strong>1. 关联容器（有序和无序）都支持表9.2的容器操作。但不支持顺序容器的位置相关操作。如<code>push</code>和<code>pop</code>,因为关联容器是根据关键字存储的。关联容器也不支持构造函数或者插入操作这些接受一个元素值和一个数量值得操作。关联容器的迭代器都是双向的。</strong> <img src="/c-primer前部分/guanlianoperate.png" width="600"></p>
<p><strong>2. 除了上面表9.2操作，还有如下操作：</strong> <img src="/c-primer前部分/leixingbieming.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;		<span class="comment">//v1时一个string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;		<span class="comment">//v2是一个string</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;::value_type v3;	<span class="comment">//v3是一个pair&lt;const string,int&gt;</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;::mapped_type v4;	<span class="comment">//v4是一个int</span></span><br></pre></td></tr></table></figure></p>
<h5 id="map和multimap">17.5 map和multimap</h5>
<p><strong><code>map</code>类型通常被称为关联数组，其与普通数组类似，不同之处在于其下标不必是整数，我们通过一个关键字而不是位置来查找值</strong>。如查找电话号码：我们可以把联系人名字作为关键字，电话号码作为值。<strong><code>map</code>与<code>multimap</code>的不同就是<code>map</code>不允许关键字重复，而<code>multimap</code>则相反。它们存储的元素是<code>pair</code>.</strong></p>
<p>我们不可以通过的迭代器改变它们的的键值，<strong>因为<code>map</code>和<code>multimap</code>的键值关系到元素的排列规则，任意改变键值将会严重破坏组织。如果想要修改元素的实值，那么是可以的。</strong></p>
<h6 id="map定义">17.5.1 map定义</h6>
<p>支持空容器、拷贝初始化、范围初始化、值初始化，赋值初始化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_count_1;		<span class="comment">//空map</span></span><br><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_count_2&#123;&#123;<span class="string">&quot;trluper&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;github&quot;</span>,<span class="number">2</span>&#125;&#125;;	<span class="comment">//初始化列表</span></span><br><span class="line"><span class="function">map&lt;string,<span class="type">size_t</span>&gt; <span class="title">word_count_3</span><span class="params">(word_count_2)</span>		<span class="comment">//拷贝初始化</span></span></span><br><span class="line"><span class="function">map&lt;string,<span class="type">size_t</span>&gt; <span class="title">word_count_4</span><span class="params">(word_count.begin(),word_count.end())</span></span>;	<span class="comment">//迭代器初始化</span></span><br></pre></td></tr></table></figure></p>
<h6 id="map和multimap迭代器">17.5.2 map和multimap迭代器</h6>
<p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的<code>value_type</code>的值的引用。必须记住，一个<code>map</code>的<code>value_type</code>是一个<code>pair</code>，我们可以改变<code>pair</code>的值，<strong>但是不能改变关键字成员的值</strong>,因为它是个<code>const</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得map迭代器</span></span><br><span class="line"><span class="keyword">auto</span> map_it=mymap.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//map_it是指向一个pair&lt;const string,size_t&gt;对象的迭代器</span></span><br><span class="line">cout&lt;&lt;map_it-&gt;fist&lt;&lt;<span class="string">&quot;---&quot;</span>&lt;&lt;map_it-&gt;second;</span><br><span class="line">++map_it-&gt;second;</span><br></pre></td></tr></table></figure></p>
<h6 id="添加元素">17.5.3 添加元素</h6>
<p>对map执行insert，必须记住元素类型是pair，且返回的是<code>pair&lt;iterator,boo&gt;</code>,第一个插入后返回的迭代器，指向指定关键字的迭代器，第二个是插入是否成功。有以下4中添加方法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="built_in">insert</span>(...); <span class="comment">//往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStu;</span><br><span class="line"><span class="comment">// 第一种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;小张&quot;</span>));</span><br><span class="line"><span class="comment">// 第二种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">inset</span>(<span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="string">&quot;校长&quot;</span>));</span><br><span class="line"><span class="comment">// 第三种 通过value_type的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>, <span class="string">&quot;小李&quot;</span>));</span><br><span class="line"><span class="comment">// 第四种 通过数组的方式插入值</span></span><br><span class="line">mapStu[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>;</span><br><span class="line">mapStu[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>insert(v)（和emplace(args))</code>返回的是<code>pair</code>类型,如果关键字已在容器中，则<code>insert</code>什么事情也不用做，且返回值中的<code>bool</code>部分为<code>false</code>；如果关键字不存在，则元素被插入容器中，且<code>bool</code>值为<code>true</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_count;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)&#123;</span><br><span class="line">	<span class="comment">//插入一个元素，关键字为word,初始值为1</span></span><br><span class="line">	<span class="keyword">auto</span> ret=word_count.<span class="built_in">insert</span>(&#123;word,<span class="number">1</span>&#125;);</span><br><span class="line">	<span class="comment">//如果键值对早已存在，则对相应的键值对的值++</span></span><br><span class="line">	<span class="keyword">if</span>(!ret.second)</span><br><span class="line">		++ret.first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ret——是一个pair类型，&lt;map&lt;string,size_t&gt;::iterator,bool&gt;</span></span><br><span class="line"><span class="comment">ret.first——是一个map迭代器，指向具有指定关键字的元素</span></span><br><span class="line"><span class="comment">ret.first-&gt;——是个pair，&lt;string,size_t&gt; </span></span><br><span class="line"><span class="comment">ret.first-&gt;second——map中元素的值部分</span></span><br><span class="line"><span class="comment">++ret.first-&gt;second——递增此值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h6 id="删除元素">17.5.4 删除元素</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除所有元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">erase</span>(keyElem);<span class="comment">//删除容器中key为keyElem的对组。</span></span><br></pre></td></tr></table></figure>
<h6 id="查找操作">17.5.5 查找操作</h6>
<p>由于下标运算符可能插入一个新元素，我们只可以对非<code>const</code>的<code>map</code>使用下标操作: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下标操作</span></span><br><span class="line">c[k];	<span class="comment">//返回关键字为k的值，若k不存在则添加键为k的元素，对其值进行初始化</span></span><br><span class="line">c.<span class="built_in">at</span>(k);<span class="comment">//访问关键字元素为k的元素，若不在，抛出out_of_range异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lower_bound和upper_bound不适用于无序容器</span></span><br><span class="line">c.<span class="built_in">find</span>(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回map.end();</span></span><br><span class="line">c.<span class="built_in">count</span>(keyElem);<span class="comment">//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span></span><br><span class="line">c.<span class="built_in">lower_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">c.<span class="built_in">upper_bound</span>(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line">c.<span class="built_in">equal_range</span>(keyElem);<span class="comment">//返回pair,pair中的元素为容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：下标操作只有非常量<code>map</code>和<code>unordered_map</code>能用。<code>set</code>类型不支持下标，因为<code>set</code>中没有与关键字相关联的“值”。<code>multimap</code>和<code>undered_multimap</code>不支持下标操作，因为这些容器中可能有多个值与一个关键字相关联</em></strong></p>
<h5 id="set和multiset">17.6 set和multiset</h5>
<p><code>set</code>就是关键字的简单集合，当只想知道一个值是否存在时，<code>set</code>是最为恰当的。<code>set</code>是不可重复，而<code>multiset</code>可重复。<code>set</code>的许多操作同<code>map</code>一样</p>
<h6 id="set定义">17.6.1 set定义</h6>
<p>同map一样支持支持空容器、拷贝初始化、范围初始化、值初始化，赋值初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; set1&#123;<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;github&quot;</span>&#125;;</span><br><span class="line"><span class="function">set&lt;string&gt; <span class="title">set2</span><span class="params">(set1)</span></span>;</span><br><span class="line"><span class="function">set&lt;string&gt; <span class="title">set3</span><span class="params">(set1.begin(),set1.end())</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h6 id="迭代器">17.6.2 迭代器</h6>
<p><code>set</code>的迭代器是<code>const</code>的，同<code>ma</code>p一样<code>set</code>中的关键字也是<code>const</code>的，可以用一个<code>set</code>迭代器来读取元素的值，但不能修改。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; iset=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator set_it=iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span>(set_it!=iset.<span class="built_in">end</span>())&#123;</span><br><span class="line">	<span class="comment">//*set_it=42;		//非法,set的关键字是const，不能修改</span></span><br><span class="line">	cout&lt;&lt;*set_it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>省下操作略写，map的操作就是set操作，除了下标操作</strong></p>
<h5 id="关联无序容器">17.7 关联无序容器</h5>
<p>新标准定义了4个无序<code>unordered</code>容器，这些容器不是使用比较运算符来组织元素的，而是使用一个哈希函数<code>hash function</code>和关键字类型的<code>==</code>运算符。除了哈希管理外，无序容器还提供了与有序容器相同的操作<code>find,insert</code>等。</p>
<h6 id="管理桶">17.7.1 管理桶</h6>
<p><strong>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器采用哈希算法（函数）将元素映射到桶</strong>。为了访问一个元素，容器首先要计算元素的哈希值，它指出了应该搜索哪个桶。该无序容器会将一个特定哈希值的所有元素都保存在相同的桶中。（如果容器允许重复关键字，自然而然相同关键字的元素也都会在同一个桶中）。所有，无序容器的性能依赖哈希函数和桶的数量及大小。</p>
<p>对于相同的参数，哈希函数必然产生相同的结果。<strong>计算一个元素的哈希值和在桶中的搜索是很快的，但如果一个桶存放太多的元素，则查找一个特定的元素会进行大量比较操作</strong>。 无序容器提供了一组管理桶函数，这些成员函数允许我们查询容器状态以及在必要时强制容器重组。 <img src="/c-primer前部分/bucket.png" width="700"></p>
<h4 id="泛型算法">18. 泛型算法</h4>
<p>标准库容器定义的操作集合惊人的小。标准库并未给每个容器添加大量功能，而是提供了一组算法，这些算法中的大多数都独立于任何特定的容器。这些算法是通用的（generic，或称泛型的）：它们可以用于不同类型的容器和不同类型的元素</p>
<p>大多数算法都定义在头文件<code>algorithm</code>中。标准库还在头文件中定义了一组数值泛型算法。<strong>一般情况下，这些算法并不直接操作容器，而是遍历两个迭代器指定的一个元素范围来操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。</strong> 迭代器令算法不依赖于容器，但算法依赖于元素类型的操作算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素，也可能在容器中移动元素，但永远不会直接添加或删除元素。</p>
<h5 id="初始泛型算法">18.1 初始泛型算法</h5>
<h6 id="只读算法">18.1.1 只读算法</h6>
<p><code>find、count、accumulate，accumulate</code>定义在头文件<code>numeric</code>中,<strong>其只读取输入范围内的元素，而不改变元素.</strong></p>
<p><strong>1. accumulate函数接收3个参数，前两个指出了是需要求和的元素范围，第三个参数是求和的初值</strong>。第三个参数的类型决定了函数中使用哪个加法运算符和返回值类型，这个特性蕴含着：将元素类型加到和的类型上的操作使可行的，如下面<code>string</code>允许+，但<code>const char*</code>不允许，没有定义+ <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="built_in">accumulate</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">string sum=<span class="built_in">accumulate</span>(vs.<span class="built_in">begin</span>(),vs.<span class="built_in">end</span>(),<span class="built_in">string</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">//const char* 没有+运算符，不能使用</span></span><br><span class="line"><span class="comment">//string sum=accumulate(vc.begin(),v.end().&quot;&quot;);</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. 只读算法<code>equal</code>，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素比较。如果所有对应元素相等，则返回<code>true</code>，否则，返回<code>false</code></strong>。要求内部元素支持<code>==</code>运算符 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">equal</span>(v1.<span class="built_in">cbehin</span>(),v1.<span class="built_in">cen</span>(),v2.<span class="built_in">cbegin</span>());</span><br></pre></td></tr></table></figure></p>
<h6 id="写容器元素算法">18.1.2 写容器元素算法</h6>
<p>一些算法将新值赋予序列中的元素。<strong>必须注意保存序列原大小至少不小于我们要求算法写入的元素数目。算法不会执行容器操作，所以它们自身无法改变容器大小。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>);		<span class="comment">//每个元素重置为0</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">begin</span>()+vec.<span class="built_in">size</span>()/<span class="number">2</span>,<span class="number">10</span>);		<span class="comment">//将一半元素置为10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一些算法接受一个迭代器来指出一个单独的目的位置，新值从目的迭代器的位置开始插入。</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec;		<span class="comment">//空vector</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">size</span>(),<span class="number">0</span>); <span class="comment">//所有元素置为0，vec.size()=0,所以对于空容器没有发生错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素：（举个反例）</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec;	<span class="comment">//空vector</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(),<span class="number">10</span>,<span class="number">0</span>);		<span class="comment">//不允许，至少容器容量为10</span></span><br></pre></td></tr></table></figure></p>
<h6 id="back_inserter">18.1.3 back_inserter</h6>
<p>一种保证算法有足够的元素空间来容纳输出数据的方法是<strong>使用插入迭代器</strong>。<strong>插入迭代器是一种向容器添加元素的迭代器。</strong> <code>back_inserter</code>定义在iterato<code>头文件中。**</code>back_inserter`接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中,并会返回下一个插入迭代器：** <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it=<span class="built_in">back_inserter</span>(vec);;</span><br><span class="line">*it=<span class="number">42</span>;		<span class="comment">//42</span></span><br><span class="line">*it=<span class="number">50</span>;		<span class="comment">//42 50</span></span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_insertor</span>(vec),<span class="number">10</span>,<span class="number">0</span>);		<span class="comment">//添加10个元素到vec:42 50 0 0 0 0 0 0 0 0 0 0</span></span><br></pre></td></tr></table></figure></p>
<h6 id="拷贝算法">18.1.4 拷贝算法</h6>
<p><strong>1. 拷贝算法<code>copy</code>接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置,返回拷贝后的下一个元素的迭代器。此算法使将输入范围的元素拷贝到目的序列中。所以目的序列的元素（内存空间）至少要和输入范围元素数量一样。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec_c</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//ret为vec_c拷贝元素的下一个元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> ret=<span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),vec_c.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure></p>
<p><strong>2. <code>replace</code>算法读入一个序列，并将其所有等于给定值得元素都改为另一个值，接受4个参数：前两个为迭代器，表示输入序列，后两个是要搜索得值、替换得值,位于<code>algorithm</code>头文件</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="built_in">replace</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>3.<code>replace_copy</code>,与<code>replace</code>不同，该算法保持原序列不变，而是生成了新序列将搜索值变为替换值。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; Mlist;</span><br><span class="line"><span class="built_in">replace_copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="built_in">back_inserter</span>(Mlist),<span class="number">0</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure> 此调用后，<code>vec</code>并未改变，<code>Mlist</code>包含<code>vec</code>的一份拷贝，不过原来在<code>vec</code>中值为0的元素在<code>Mlist</code>中都变为10.</p>
<h6 id="重排容器元素的算法">18.1.5 重排容器元素的算法</h6>
<ul>
<li>(1)某些算法会重排容器中元素的顺序，代表函数是<code>sort</code>。调用<code>sort</code>会重排输入序列中的元素，使之有序</li>
<li>(2)<code>unique</code>算法重拍序列，其把相邻重复项“消除”，并返回一个指向不重复值范围末尾的迭代器（但此words的大小没有改变）此位置之后的元素仍然存在，但是我们并不知道它们的值是什么。(去重)</li>
</ul>
<p><img src="/c-primer前部分/unique.png" width="700"></p>
<p>这是需要用到容器操作erase删除该元素。代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">elimDups</span><span class="params">(vector&lt;sting&gt;&amp; words)</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">auto</span> it=<span class="built_in">unique</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">	words.<span class="built_in">erase</span>(it,words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="定制操作">18.2 定制操作</h5>
<p>很多算法都会比较输入序列的元素，这类算法使用元素类型的<code>&lt;</code>或<code>==</code>运算符完成比较。<strong>标准库还未这些算法定义了额外的版本，允许我们定义的操作来代替默认运算符。</strong></p>
<h6 id="用函数做谓词">18.2.1 用函数做谓词</h6>
<p><strong>向算法传递函数:</strong> 我们可以按照长度重排<code>vector</code>，所以要重载<code>sort</code>。<strong>此时，<code>sort</code>接受第三个参数，最后一个参数称为谓词。谓词是一个可调用的表达式，其返回结果是一个能用作条件的值</strong>。根据它们接受的参数数量，谓词可分为一元谓词和二元谓词。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。</p>
<p><strong>谓词：指普通函数或者重载了<code>operator()</code>且返回值是<code>bool</code>类型的的函数对象。函数对象和普通函数的区别：</strong></p>
<ul>
<li>1.函数对象可以有自己的状态</li>
<li>2.普通函数没有类型，函数对象有类型</li>
<li>3.函数对象比普通函数执行效率有可能更高（成员函数自动申请为内联函数）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br></pre></td></tr></table></figure>
<p>我们将<code>words</code>按大小重排的同时，还希望将具有相同长度的元素按字典排序。我们可以使用<code>stable_sort</code>算法。这种稳定的排序算法维持了相等元素的原有顺序。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br></pre></td></tr></table></figure> <strong><em>附：函数对象是指类中重载了()，而这个类实例化的对象就叫函数对像。</em></strong></p>
<h6 id="使用lambda">18.2.2 使用lambda</h6>
<p><strong><code>lambda</code>的主要时解决传递谓词时参数的限制，其可通过捕获列表来传递多个想要传给函数体的参数</strong>。就如<code>find_if</code>，<code>find_if</code>只接受一元谓词，因此传递给<code>find_if</code>的可调用对象必须接受单一参数。此时可调用对象（一元谓词）无法传递别的参数。用lambda表达式便能解决: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findLength</span><span class="params">(vector&lt;string&gt;&amp; words,vector&lt;string&gt;::size_type sz)</span></span>&#123;</span><br><span class="line">	<span class="built_in">elimDups</span>(words);</span><br><span class="line">	<span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br><span class="line">	<span class="keyword">auto</span> s=<span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">		[sz](<span class="type">const</span> string s1)&#123;<span class="keyword">return</span> s1.<span class="built_in">size</span>()&gt;sz;&#125;);		<span class="comment">//使用lambda捕获sz,符合要求便返回迭代器</span></span><br><span class="line">	for_each(s,words.<span class="built_in">end</span>(),</span><br><span class="line">		[](<span class="type">const</span> string&amp; a)&#123;cout&lt;&lt;s&lt;&lt;endl;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="bind使函数更加灵活的函数适配器">18.3 bind：使函数更加灵活的函数适配器</h5>
<p>对于<code>lambda</code>,如果捕获列表是空的，推荐不使用它而是使用函数。如果不为空，而那些定制的函数只要求传入一元或二元谓词的时候，使用<code>lambda</code>尤为重要。<strong>但是我们可能要在很多地方使用相同的操作，编写相同的<code>lambda</code>表达式会过于麻烦，此时应该定义一个函数。为解决上面的要求，我们引入了标准库<code>bind</code>函数</strong></p>
<p><strong><code>bind()</code>函数作为函数的适配器，它可以扩大函数是使用场合，使得函数更加灵活的被使用。</strong><code>bind</code>定义在头文件<code>functional</code>中。它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表（即适用上述只能传入一元和二元谓词的要求）</p>
<h6 id="bind的一般形式">18.3.1 bind的一般形式</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable=<span class="built_in">bind</span> (callable, arg_list);</span><br></pre></td></tr></table></figure>
<p><code>newcallable</code>是一个可调用对象，当<code>newcallable</code>被调用时，<code>newcallable</code>就调用<code>callable</code>，并将参数列表<code>arg_list</code>中的参数依次序给<code>callable</code>（<strong>其中可能会包含占位符<code>_n</code>表示<code>newcallable</code>的第<code>n</code>个参数</strong>）。占位符定义在<code>placeholders</code>的命名空间中,因此使用时要声明命名空间<code>using namespace std::placeholders;</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">islength</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">size_t</span> sz)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>()&gt;sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f=<span class="built_in">bind</span>(islength,_1,<span class="number">6</span>);		<span class="comment">//s1=_1,sz=6</span></span><br><span class="line"><span class="keyword">auto</span> s=<span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),<span class="built_in">f</span>(string &amp;s));	<span class="comment">//克服了find_if只能接受元谓词的缺点_1=s;</span></span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：占位符_n不仅仅使得参数使得调用时参数减少，也能对参数的顺序进行重排 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="keyword">auto</span> fn1 = <span class="built_in">bind</span>(func, _1, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> fn2 = <span class="built_in">bind</span>(func, <span class="number">2</span>, _1, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">fn1</span>(<span class="number">10</span>);	<span class="comment">//调用func(10,2,3)</span></span><br><span class="line"><span class="built_in">fn2</span>(<span class="number">10</span>);	<span class="comment">//调用func(2,10,3);</span></span><br></pre></td></tr></table></figure></p>
<h6 id="绑定引用参数">18.3.2 绑定引用参数</h6>
<p>默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。因为bind拷贝其参数，而我们不能拷贝一个<code>ostream</code>。如果我们希望传递给<code>bind</code>一个对象而又不拷贝它，就必须使用标准库<code>ref</code>函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os,string&amp; s,<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">	 os&lt;&lt;s&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">	 <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f=<span class="built_in">bin</span>(print,<span class="built_in">ref</span>(os),_1,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="string">&quot;trluper&quot;</span>);	<span class="comment">//print(os,&quot;trluper&quot;,&#x27; &#x27;);</span></span><br></pre></td></tr></table></figure></p>
<h5 id="泛型算法的结构">18.4 泛型算法的结构</h5>
<h6 id="算法支持的迭代器">18.4.1 算法支持的迭代器</h6>
<p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别:</p>
<ul>
<li><strong>输入迭代器</strong>：提供对数据的只读访问 只读，支持<code>++、==、！=</code></li>
<li><strong>输出迭代器</strong>：提供对数据的只写访问 只写，支持<code>++</code></li>
<li><strong>前向迭代器</strong>：提供读写操作，并能向前推进迭代器 读写，支持<code>++、==、！=</code></li>
<li><strong>双向迭代器</strong>：提供读写操作，并能向前和向后操作 读写，支持<code>++、--，</code></li>
<li><strong>随机访问迭代器</strong>：提供读写操作，并能在数据中随机移动 读写，支持<code>++、--、[n]、+n、-n、&lt;、&lt;=、&gt;、&gt;=</code></li>
</ul>
<p><strong>算法还共享一组参数传递规范和一组命名规范。</strong></p>
<h6 id="形参规范">18.4.2 形参规范</h6>
<p>大多数算法有下列4中形式</p>
<ul>
<li><code>alg(beg,end,other args);</code></li>
<li><code>alg(beg,end,dest,other args);</code></li>
<li><code>alg(beg,end,beg2,other args);</code></li>
<li><code>alg(beg,end,beg2,end2,other args);</code></li>
</ul>
<p><code>alg</code>为算法名称，<code>beg</code>和<code>end</code>表示算法所操作的输入范围（几乎所有算法均支持接受一个输入范围）。同时这里还列出了<code>dest</code>（目标迭代器）、<code>beg2、end2、</code>它们都是迭代器参数，如果用到了这些参数，它们分别承担了指定目的位置和第二个范围的角色。 <strong><em>注意：</em></strong> <strong>接受单个目标迭代器的算法：向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据 接受第二个输入序列的算法：接受单独beg2的算法假定从beg2开始的序列与beg与end所表示的范围至少一样大</strong></p>
<h6 id="命名规范">18.4.3 命名规范</h6>
<p>除了上述的参数规范，算法还遵循一套命名和重载规范。这些规范处理：<strong>提供一个操作去代替默认的<code>&lt;</code>或者<code>==</code>运算符，以及算法是将输出数据写入输入序列还是一个分离目的位置</strong></p>
<p><strong>1. 重载形式</strong></p>
<p>接受谓词参数来代替算法默认的&lt;或者其他运算符，以及那些不接受额外参数的算法，通常都是重载的函数。函数一个版本用来元素类型运算符来比较元素，<strong>另一个版本接受一个额外的谓词来代替默认的<code>&lt;</code>或者<code>==</code>。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique</span>(beg,end,val);	<span class="comment">//使用默认==比较元素</span></span><br><span class="line"><span class="built_in">unique</span>(beg,end,compare);	<span class="comment">//使用传入的谓词compare比较</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. <code>_if</code>版本的算法</strong></p>
<p>接受一个元素值的算法通常会有另一个不同名（不是重载版本）版本，该版本接受一个谓词代替元素值，接受谓词参数的算法都有附加_if后缀： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg,end,val);		<span class="comment">//查找范围内val第一次出现的位置</span></span><br><span class="line"><span class="built_in">find_if</span>(beg,end,pred);	<span class="comment">//查找第一个另pred谓词为真的元素</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3. 区分拷贝元素的版本和不拷贝的版本</strong></p>
<p>默认情况下，那些能重排元素的算法（sort,stable_sort等)将重排后的元素写回给定的输入序列。这些算法还提供另一版本：将元素写道一个指定的输出目的位置，写到额外目的空间的算法都在名字后面附加一个<code>_copy</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg,end);		<span class="comment">//反转</span></span><br><span class="line"><span class="built_in">reverse_copy</span>(beg,end,dest);	<span class="comment">//反转拷贝到dest</span></span><br></pre></td></tr></table></figure></p>
<p>一些算法同时有_if和_copy:它们接受一个目的迭代器和一个谓词： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">remove_coy_if</span>(beg,end,dest,pred);</span><br></pre></td></tr></table></figure></p>
<h4 id="再探迭代器">19 再探迭代器</h4>
<p><strong>除了为每个容器定义的迭代器外，标准库在iterator头文件还定义了额外几种迭代器。</strong></p>
<ul>
<li>插入迭代器：绑定在容器上时，可用来向容器插入元素</li>
<li>流迭代器：绑定在容器上时，可用来遍历元素</li>
<li>反向迭代器（forward_list除外）：这些迭代器是向后而不是向前移动</li>
<li>移动迭代器：不是拷贝元素，而是移动它们</li>
</ul>
<h5 id="插入迭代器">19.1 插入迭代器</h5>
<p><strong>插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素</strong>。如<code>back_inserter</code>接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用<code>push_back</code>将一个具有给定值的元素添加到容器中。插入迭代器有三种类型：</p>
<ul>
<li><code>back_inserter</code>：创建一个使用<code>push_back</code>的迭代器</li>
<li><code>front_inserter</code>：创建一个使用<code>push_front</code>的迭代器</li>
<li><code>inserter</code>：创建一个使用<code>insert</code>的迭代器。接受第二个参数，元素将被插入到给定迭代器表示的元素之前</li>
</ul>
<p>只有在容器支持<code>push_front</code>的情况下，我们才可以使用<code>front_inserter</code>。类似的，只有在容器支持<code>push_back</code>的情况下，我们才能使用<code>back_inserter</code>。<strong>当调用<code>insert(c,iter)</code>时，我们得到一个迭代器，使用它时，会将元素插入到<code>iter</code>原来指向的元素之前的位置（iter一直指向固定的一个元素）</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;lst2,lst3;</span><br><span class="line"><span class="comment">//拷贝完成后，lst2为4，3，2，1</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">begin</span>(),lst.<span class="built_in">end</span>(),<span class="built_in">front_inserter</span>(lst2));</span><br><span class="line"><span class="comment">//拷贝完成后，lst3为1,2,3,4</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">begin</span>(),lst.<span class="built_in">end</span>(),<span class="built_in">inserter</span>(lst3,lst.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure></p>
<h5 id="反向迭代器">19.2 反向迭代器</h5>
<p><strong>除了<code>forward_list</code>之外，其他容器都支持反向迭代器。<code>rbegin、crbegin</code>返回指向容器尾元素的迭代器<code>rend</code>、<code>crend</code>返回指向首元素之前一个位置的迭代器。</strong> 反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。<strong>对于反向迭代器，递增<code>++</code>和递减<code>--</code>的含义是反过来的。即递增++iter是移动到前一个元素，递减<code>--iter</code>是移到下一个元素。</strong> <img src="/c-primer前部分/rbegin.png" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());		<span class="comment">//正常升序排序</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(),vec.<span class="built_in">rend</span>());		<span class="comment">//反过来了，降序排序</span></span><br></pre></td></tr></table></figure></p>
<h6 id="反向迭代器和其他迭代器之间的关系">19.2.1 反向迭代器和其他迭代器之间的关系</h6>
<p>我们想在存放了<code>words,lanuage,last</code>的<code>string</code>类型的<code>line</code>中输出打印最后一个单词<code>last</code>,使用find函数查找最后一个“，” <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> rcomm=<span class="built_in">find</span>(line.<span class="built_in">crbegin</span>(),line.<span class="built_in">crend</span>(),<span class="string">&#x27;,&#x27;</span>);		<span class="comment">//此时rcomm指向的是最后“,”的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们这样调用印，会打印出tsal逆序单词：</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(line.<span class="built_in">crbegin</span>(),rcomm)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//我们可以通过调用reverse_iterator的base成员函数可以将其转换成普通迭代器，从而正确打印：</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(rcomm.<span class="built_in">base</span>(),line.<span class="built_in">cend</span>())&lt;&lt;endl;</span><br></pre></td></tr></table></figure> <img src="/c-primer前部分/guanxi.png" width="500"></p>
<p><strong><em>注意：</em></strong>关键点在于<code>[line.crbegin(),rcomma)</code>和<code>[rcomma.base(),line.cend())</code>指向line中相同的元素范围。为了实现这一点，<code>rcomma</code>和<code>rcomma.base()</code>必须生成相邻位置而不是相同位置<code>rcomma.base()</code>在<code>rcomma</code>的下一个位置），<code>crbegin()</code>和<code>cend()</code>也是如此。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">python面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 18:24:44" itemprop="dateCreated datePublished" datetime="2022-06-30T18:24:44+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-15 10:10:48" itemprop="dateModified" datetime="2022-09-15T10:10:48+08:00">2022-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">python面向对象</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="面向对象">1. 面向对象</h4>
<h5 id="类对象提供的默认行为">1.1 类对象提供的默认行为</h5>
<p>在python的面向对象模型种，要分清<strong>类对象</strong>和<strong>实例对象</strong>。类对象就是<code>class</code>定义了一个类只会，该类提供些行为就是类对象.而实例对象就是该类的实例。每次调用类，就会生成一个实例。 类对象提供的默认行为：</p>
<ul>
<li><code>class</code>语句创建类对象并将其赋值给变量名。就像<code>def</code>一样，class语句也是可执行语句，执行时会产生类对象，并赋值变量名</li>
<li>class语句的赋值语句会创建类属性，像模块文件一样，class语句内的顶层的赋值语句（不在<code>def</code>内）会成为类对象的属性。</li>
<li>类属性提供对象的状态（变量）和行为（函数）</li>
<li>类仍然时模块内的属性。当<code>class</code>执行时，只是赋值语句而已，赋值了一个类对象</li>
</ul>
<h5 id="实例对象是具体对象">1.2 实例对象是具体对象</h5>
<p>每当调用类对象时，就会生成示例对象：</p>
<ul>
<li>调用类对象会创建新的实例对象</li>
<li>每个示例对象有类的属性并且有自己的命名空间</li>
<li><strong><em>在方法内对self属性做赋值会产生每个实例自己的属性</em></strong>：在类函数内，第一个参数总是接受方法调用的隐形主体，通常用<code>self</code>会引用正处理的实例对象（相当于C/C++的<code>this指针</code>)。对<code>self</code>的属性做赋值运算，会创建或修改实例内的数据，而不是类的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">firstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.data=value;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data);</span><br><span class="line">    data=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">s=firstClass();</span><br><span class="line">s.printdata();	<span class="comment">#0</span></span><br><span class="line">s.setdata(<span class="number">10</span>);</span><br><span class="line">s.printdata();	<span class="comment">#10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>self</code>会自动引用正在处理的示例对象，所以赋值语句会把值村储到实例的命名空间。因为<strong>类对象</strong>会产生多个实例，函数必须经过<code>self</code>参数才能识别获取正在处理的实例（就看出时c/c++中隐藏的<code>this指针</code>就行了)</p>
<h5 id="继承">1.3 继承</h5>
<p>面向对象的一大特性就是继承，以下时python中继承的核心观点：</p>
<ul>
<li>父类列在类开头的括号处</li>
<li>子类从父类中继承了函数和属性</li>
<li>实例会继承所有可读取类的属性：每个实例会从创建它的类中获取变量名，此外还有该类的父类</li>
<li>每个<code>object.attribute</code>都会开启新的独立搜索：python会对每个属性取出表达式进行对类树的独立搜索，包括self</li>
<li>一般来说逻辑的修改都是通过继承的子类修改，而不是直接修改父类</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">secondClass</span>(<span class="title class_ inherited__">firstClass</span>):</span><br><span class="line">	data=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这是第二个类&quot;</span>，sefl.data);</span><br><span class="line"></span><br><span class="line">a=secondClass();</span><br><span class="line">a.setdata(<span class="number">20</span>)</span><br><span class="line">a.printdata();		<span class="comment">#这是第二个类 20</span></span><br></pre></td></tr></table></figure>
<p>子类对属性的搜索会从下往上，即从子类到父类，直到所找属性名首次出现为止。上面的<code>printdata</code>函数覆盖了父类的<code>printdata</code>函数，这中覆盖叫做<code>重载</code>。</p>
<h5 id="类的运算符重载初识">1.4 类的运算符重载初识</h5>
<p><strong>运算符重载</strong>就是让类写成的对象可以截获并响应内置类型上的运算，如加法、切片和打印等等，在这里我们只是片面性的列举了一些重载以做了解，更加具体的将在后面介绍。运算符重载的主要注意点：</p>
<ul>
<li>运算符重载的命名方式为<code>__x__</code></li>
<li>当实例出现内置运算时，这类方法会自动调用。比如实例有<code>__add__</code>方法，当对象出现<code>+</code>表达式时，该方法就会调用</li>
<li>类可覆盖多数内置类型运算</li>
<li>运算符重载让类变得更趋像python的对象模型</li>
</ul>
<p><strong><em>注意</em></strong>：我们必须关心一个方法，那就是<code>__init__</code>方法，也称为<strong>构造函数</strong>,它用于初始化对象的状态的，<strong><em><code>__init__</code>和<code>self</code>是我们理解python面向对象特性的关键</em></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdClass</span>(<span class="title class_ inherited__">secondClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.data=value;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> ThirdClass(self.data+other);</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[ThirdClass:%s]&#x27;</span>% self.data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是ThirdClass&quot;</span>,self.data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=ThirdClass(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">a.printdata();</span><br><span class="line">a=a+<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">a.printdata();</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是ThirdClass abc</span><br><span class="line">这是ThirdClass abc123</span><br><span class="line">[ThirdClass:abc123]</span><br></pre></td></tr></table></figure> 从上面可以知道几点：</p>
<ol type="1">
<li><code>ThirdClass</code>调用传入一个参数，这是传给<code>__init__</code>构造函数的参数，即在在构建实例时自动调用<code>__init__</code>构造函数来初始化属性</li>
<li>有<code>__add__</code>函数后，即<code>+</code>运算符重载，<code>ThirdClass</code>的实例对象就可出现在<code>+</code>处，对与<code>+</code>，它把左侧的对象传给<code>self</code>，右侧的给<code>other</code>。执行完后，<strong>对于<code>__add__</code>来说要返回一个新的对象实例</strong></li>
<li>重载了<code>__str__</code>方法后，可以直接调用<code>print</code>打印对象</li>
</ol>
<h5 id="以实例介绍类的细节">1.5 以实例介绍类的细节</h5>
<h6 id="person和manager">1.5.1 person和manager</h6>
<p>在本节，将会两个类<code>person</code>和<code>manager</code>来介绍类实现的一些细节。顺带一提oython的%字符串格式为<code>&quot;%s,%d&quot; %(&quot;2222&quot;,10)</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,job=<span class="literal">None</span>,pay=<span class="number">0</span></span>):</span><br><span class="line">		self.name=name;</span><br><span class="line">		self.job=jon;</span><br><span class="line">		self.pay=pay;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span>  self.name.split()[-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self,percent</span>):</span><br><span class="line">		self.pay=<span class="built_in">int</span>(self.pay*(<span class="number">1</span>+percent))</span><br><span class="line">	<span class="comment">#print重载</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;[Person:%s,%s]&#x27;</span> % (self.name,self.pay)</span><br><span class="line"><span class="comment">#manager类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">	<span class="comment">#定制自己的构造函数，使用父类（超类）的构造函数构造</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,pay</span>):</span><br><span class="line">		self.person=Person.__init__(self,name,<span class="string">&#x27;mgr&#x27;</span>,pay);</span><br><span class="line">	<span class="comment">#重载函数，内部仍然使用超类的函数</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self,percent,bonus=<span class="number">1.0</span></span>):</span><br><span class="line">		person.giveRaise(self,percent+bonus);</span><br><span class="line">	<span class="comment">#改进点：</span></span><br><span class="line">	<span class="comment">#1. 使用内置的`Instance.__class__.__name__`,避免重复修改前部分的名称</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span><span class="string">&#x27;[%s:%s,%s]&#x27;</span> % (self.__class__.__name__,self.name,self.pay)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="对象持久化">1.5.2 对象持久化</h6>
<p>在上面我们创建的不是真正的数据库记录，如果关闭python，实例也将消失，因为它们是内存中的临时对象，这时可以使用python中<code>对象持久化</code>的功能，让对象在退出程序时依然存在。<strong>对象持久化</strong>通过3个标准库模块实现：</p>
<ul>
<li><code>pickle</code>:任意python对象和字节串之间的转化</li>
<li><code>dbm</code>：实现一个可通过键访问的文件系统，以存储字符串</li>
<li><code>shelve</code>:使用上面两个模块按照键把python对象存储到一个文件</li>
</ul>
<p>即<code>shelve</code>通过使用<code>pickle</code>将对象转为字符串，然后存储到一个<code>dbm</code>文件中键值对下，<code>shelve</code>通过键获取<code>pinkle</code>化的字符串，并用<code>pickle</code>在内存中重新创建最初对象。<code>shelve</code>就像字典一样，但是<code>shelve</code>一开始必须打开，并且在修改后关闭它 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">a=Person(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">b=Manager(<span class="string">&quot;小路&quot;</span>，<span class="number">1000</span>)</span><br><span class="line">db=shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">object</span> <span class="keyword">in</span>(a,b)</span><br><span class="line">	db[objecct.name]=<span class="built_in">object</span></span><br><span class="line">db.close();</span><br></pre></td></tr></table></figure> 此时，当前目录下会生成一个或多个名为<code>persondb</code>的文件</p>
<h5 id="抽象类">1.6 抽象类</h5>
<p>抽象类只是实现给继承者的一些接口，继承者类将接口实现什么功能完全由继承类决定，因此抽象接口类不能产生实例,只要类中有一个抽象方法，我们就不能创建该类的实例对象。在python3中，在<code>class</code>的头部使用一个关键字参数，以及特殊的<strong><span class="citation" data-cites="装饰器">@装饰器</span></strong>语法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCmeta,abstractmethod</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>(metaclass=ABCmeta):</span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">method_1</span>(<span class="params">self,*args</span>):</span><br><span class="line">		<span class="keyword">pass</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="命名空间">1.7 命名空间</h5>
<p>我们知道点号和无点号的变量名，会用不同方式进行访问，还有一些作用域是用于对对象命名空间做初始而设定的（如模块和类），总结如下：</p>
<ul>
<li>无点号运算的变量民与作用域相对应（如普通的全局和局部赋值）</li>
<li>点号的属性名<code>object.x</code>使用的是对象的命名空间</li>
<li>有些作用域会对对象的命名空间初始化（模块和类）</li>
</ul>
<h5 id="运算符重载详解">1.8 运算符重载详解</h5>
<p>运算符重载是意味着给自定义类增加操作，在类方法中拦截内置操作，当类的实例出现内置操作时，python自动调用你的方法。以下时常见的运算符重载方法：</p>
<table>
<thead>
<tr class="header">
<th>运算符重载函数名</th>
<th>重载功能</th>
<th>调用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__init__</code></td>
<td>构造函数</td>
<td>实例创建时自动调用</td>
</tr>
<tr class="even">
<td><code>__del__</code></td>
<td>析构函数</td>
<td>实例对象回收时自动调用</td>
</tr>
<tr class="odd">
<td><code>__add__</code></td>
<td>运算符<code>+</code></td>
<td>如果没有<code>__iadd__</code>，<code>X+Y,X+=Y</code>时会调用</td>
</tr>
<tr class="even">
<td><code>__sub__</code></td>
<td>运算符<code>-</code></td>
<td><code>X-Y,X-=Y</code>调用</td>
</tr>
<tr class="odd">
<td><code>__repr__,__str__</code></td>
<td>打印，转换</td>
<td><code>print(x),repr(x),str(x)</code></td>
</tr>
<tr class="even">
<td><code>__call__</code></td>
<td>函数调用</td>
<td><code>X(*args,**dargs)</code></td>
</tr>
<tr class="odd">
<td><code>__getattr__</code></td>
<td>点号运算</td>
<td><code>X.undefined</code></td>
</tr>
<tr class="even">
<td><code>__setattr__</code></td>
<td>属性赋值语句</td>
<td><code>X.attribute=value</code></td>
</tr>
<tr class="odd">
<td><code>__delattr__</code></td>
<td>属性删除</td>
<td><code>del X.attribute</code></td>
</tr>
<tr class="even">
<td><code>__getattribute__</code></td>
<td>属性获取</td>
<td><code>X.attribute</code></td>
</tr>
<tr class="odd">
<td><code>__getitem__</code></td>
<td>索引运算</td>
<td><code>x[key],x[i:j]</code></td>
</tr>
<tr class="even">
<td><code>__setitem__</code></td>
<td>索引赋值语句</td>
<td><code>x[key]=value,x[i:j]=sequance</code></td>
</tr>
<tr class="odd">
<td><code>__delitem__</code></td>
<td>索引和分片删除</td>
<td><code>del x[key],del x[i:j]</code></td>
</tr>
<tr class="even">
<td><code>__iter__</code>,<code>__next___</code></td>
<td>迭代环境</td>
<td><code>i=iter(x),next(i)</code></td>
</tr>
<tr class="odd">
<td><code>__len__</code></td>
<td>长度</td>
<td>如果没有<code>__bool__</code>，直接<code>len(x)</code></td>
</tr>
<tr class="even">
<td><code>__bool__</code></td>
<td>布尔测试</td>
<td><code>bool(x)</code></td>
</tr>
<tr class="odd">
<td><code>__lt__</code>,<code>__gt__</code></td>
<td>比较</td>
<td>从左到右以此为<code>&lt;,&gt;</code></td>
</tr>
<tr class="even">
<td><code>__le__</code>,<code>__ge__</code></td>
<td>比较</td>
<td><code>&lt;=,&gt;=</code></td>
</tr>
<tr class="odd">
<td><code>__eq__</code>,<code>__ne__</code></td>
<td>比较</td>
<td><code>==,!=</code></td>
</tr>
<tr class="even">
<td><code>__contains__</code></td>
<td>成员关系测试</td>
<td><code>item in X</code></td>
</tr>
</tbody>
</table>
<p>由上面可知，运算符的重载前后都有两个下划线标识，以区分其他变量名函数。</p>
<h6 id="索引和分片__getitem__">1.8.1 索引和分片<code>__getitem__</code></h6>
<p>如果类中定义或者继承了该运算符，则对于实例的索引运算，会自动调用<code>__getitem__</code>,会把实例传递给第一个参数，方括号内的值则传递给后面的一个参数，<code>__setitem__</code>则加了一个值value参数。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">operatorOverload</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		self.L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,index</span>):</span><br><span class="line">		<span class="keyword">return</span> self.L[index];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,index,value</span>):</span><br><span class="line">		self.L[index]=value;</span><br><span class="line">x=operatorOverload();</span><br><span class="line"><span class="comment">#索引操作</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">2</span>]);	<span class="comment">#9</span></span><br><span class="line"><span class="built_in">print</span>(x.L);		<span class="comment">#[1,2,3,4]</span></span><br><span class="line"><span class="comment">#分片操作</span></span><br><span class="line"><span class="built_in">print</span>(x[::<span class="number">2</span>])	<span class="comment">#[1,3]</span></span><br><span class="line"><span class="comment">#赋值</span></span><br><span class="line">x[::<span class="number">2</span>]=[<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="built_in">print</span>(x[:])</span><br></pre></td></tr></table></figure></p>
<h6 id="索引迭代__iter__">1.8.2 索引迭代<code>__iter__</code></h6>
<p><code>__getitem__</code>有一个买一送一的情况，该重载不仅仅支持上面所讲的<strong>索引和分片功能</strong>,同时支持了<code>for</code>循环的迭代，<strong>当类中未定义<code>__iter__</code>时，即<code>for</code>循环每次循环时都会调用类的<code>__getitem__</code></strong>。其实不仅仅指<code>for</code>循环会调用，其他的迭代环境，如<code>in成员测试，列表解析,内置函数map，列表和元组赋值运算以及类型构造方法</code>也会自动调用该方法，只有类中没有<code>__iter__</code>. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> x:	<span class="comment">#调用了__getitem__</span></span><br><span class="line">	<span class="built_in">print</span>(item,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h6 id="迭代器对象">1.8.3 迭代器对象</h6>
<p>尽管上面说的<code>__getitem__</code>支持迭代，但是它只是一直附加方法，真正的迭代还是要习惯用<code>__iter__</code>来获取迭代器，调用<code>__next__</code>访问，直到碰见异常<code>StopIteration</code>。python环境中所有迭代环境都是先尝试<code>__iter__</code>方法，然后再试<code>__getitem__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IterTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> self.start==self.end:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration;</span><br><span class="line">		self.start+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> self.start**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">m=IterTest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">q=<span class="built_in">iter</span>(m);</span><br><span class="line"><span class="built_in">print</span>(q);		<span class="comment">#&lt;__main__.IterTest object at 0x00000168A41CDFF0&gt;</span></span><br><span class="line"><span class="comment">#print(next(q))	#1</span></span><br><span class="line">L=<span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">	L.append(x);</span><br><span class="line"><span class="built_in">print</span>(L);		<span class="comment">#[1, 4, 9, 16, 25]，当print(next(q))未注释，输出为[4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<p>上面可以看到，迭代器对象就是实例<code>self</code>，这是因为<code>__next__</code>使类方法。且上面定义的迭代器使像<strong>生成器函数和表达式、<code>map</code>和<code>zip</code>内置函数</strong>一样的单迭代对象，要达到多个迭代器的效果，<code>__iter__</code>只需替迭代器定义新的状态对象，而不是返回<code>self</code>，带来的消耗是要创建多个迭代对象: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NextTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> self.start==self.end:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration;</span><br><span class="line">		self.start+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> self.start**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IterTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> NextTest(self.start,self.end);</span><br><span class="line"></span><br><span class="line">m=IterTest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">q=<span class="built_in">iter</span>(m);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(q));		<span class="comment">#1</span></span><br><span class="line">L=<span class="built_in">list</span>();</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">	L.append(x);</span><br><span class="line"><span class="built_in">print</span>(L);			<span class="comment">#[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure></p>
<h6 id="成员关系">1.8.4 成员关系</h6>
<p>再迭代领域，类通常把<code>in</code>成员关系运算符实现为一个迭代，使用<code>__iter__</code>或着<code>__getitem__</code>。要支持更加特定的成员关系，类可能要编写一个<code>__contains__</code>方法，出现是，方法优先级是<code>contains&gt;iter&gt;getitem</code>。<code>__contains__</code>方法应该把成员关系定义为对一个<strong>映射</strong>应用键，用于序列的搜索 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContainsTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.data=value;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self,x</span>):</span><br><span class="line">		<span class="keyword">return</span> x <span class="keyword">in</span> self.data;</span><br><span class="line"></span><br><span class="line">m=ContainsTest([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Contains:&quot;</span>,<span class="number">3</span> <span class="keyword">in</span> m,end=<span class="string">&#x27; &#x27;</span>);		<span class="comment">#Contains: True</span></span><br></pre></td></tr></table></figure></p>
<h6 id="属性引用">1.8.5 属性引用</h6>
<p><code>__getattr__</code>方法是拦截属性点号运算，当通过对未定义（不存在）属性名称和实例进行点号运算时，就会用属性名称作为字符串调用这个方法，如果可以通过继承找到属性就不会调用这个方法。因此，<code>__getattr__</code>可以作为钩子通过这种方式响应属性请求： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">empty</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">___getattr__</span>(<span class="params">self,attrname</span>):</span><br><span class="line">		<span class="keyword">if</span> attrname=<span class="string">&quot;age&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> AttributeError,attrname</span><br><span class="line"></span><br><span class="line">x=empty();</span><br><span class="line">x.age		<span class="comment">#40</span></span><br><span class="line">x.name		<span class="comment">#AttributeError:name</span></span><br></pre></td></tr></table></figure> <code>__setattr__</code>会拦截所有属性的赋值语句,因此如果定义了这个方法要小心。除此之外，因为它对任何赋值语句都会拦截，即使是在<code>__setattr__</code>内也不例外，为防止无限递归，要使用该方法，必须通过<strong>属性字典</strong>做索引来赋值任何实例属性<code>self.__dict__[attr]=value;</code>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self,attrname,value</span>):</span><br><span class="line">		<span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">			self.__dict__[attr]=value;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">raise</span> AttriubteError, attrname+<span class="string">&#x27;nor allowed&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="call表达式">1.8.6 call表达式</h6>
<p>当调用实例时，使用<code>__call__</code>。如果定义该方法，python1就会为实例应用函数调用表达式运行<code>__call__</code>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,*args,**agrv</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;called:&#x27;</span>,args,argv);</span><br><span class="line">c=Test();</span><br><span class="line">c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,x=<span class="number">4</span>,y=<span class="number">5</span>);	<span class="comment">#called:(1,2,3)&#123;&#x27;x&#x27;=4,&#x27;y&#x27;=5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="布尔测试">1.8.7 布尔测试</h6>
<p>python首先尝试<code>__bool__</code>来直接获取一个<code>bool</code>值，如果没有该方法，就尝试<code>__len__</code>，根据对象的长度确定一个真值。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.data=value;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span>(self.data!=<span class="literal">None</span>):</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span>;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(self.data);</span><br><span class="line">x=Truth(<span class="string">&quot;12314&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;bool yes!&#x27;</span>);	<span class="comment">#bool yes!</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(x):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;len yes!&#x27;</span>);	<span class="comment">#len yes!</span></span><br></pre></td></tr></table></figure></p>
<h6 id="迭代环境__next__和__iter__">1.8.8 迭代环境<code>__next__</code>和<code>__iter__</code></h6>
<p>python对于创建得类允许自定义迭代环境，如果用户需要定义迭代环境，必须 - 实现<code>__iter__</code>和<code>__next__</code>函数， - 同时在<code>__next__</code>函数中指定迭代退出环境,一般为产生一个异常<code>raise</code> - 在迭代中<code>__next__</code>中实现迭代对象，返回该对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __iter__(self):</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">def __next__(self):</span><br><span class="line">    <span class="keyword">if</span> self.Next is None:</span><br><span class="line">        raise StopIteration</span><br><span class="line">    self.currentNode=self.Next</span><br><span class="line">    self.Next=self.Next.next</span><br><span class="line">    <span class="keyword">return</span> self.currentNode</span><br></pre></td></tr></table></figure>
<h6 id="section">1.8.9</h6>
<h5 id="类的设计">1.9 类的设计</h5>
<p>无论是哪门语言，对于OOP，其重要的三个面向对象特性：继承、多态、封装。在python，这三个特性作用也是一样：</p>
<ul>
<li>继承：提高代码的复用性</li>
<li>多态：提高程序的可扩展性和可维护性</li>
<li>封装：方法和运算符实现行为，数据隐藏是一种惯例，以此提高程序安全性</li>
</ul>
<h6 id="封装">1.9.1 封装</h6>
<p>封装提高程序的安全性。将数据（属性）和行为（方法）包装到类对象中，在方法内部对属性进行操作，在类对象的外部调用方法，这样无需关心方法内部的具体实现细节，从而隔离了复杂度；在python中没有专门的修饰符用于属性的私有，如果该属性不希望在类对象外部被访问，前边使用两个<code>_</code>修饰 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.__age=age  <span class="comment">#年龄不希望在类的外部被使用，所以加了两个__</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.__age)</span><br><span class="line">stu1=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">stu1.show()</span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br><span class="line"><span class="comment">#print(stu1.__age)   #这句话会报错，因为__age不希望在类外面使用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;如果想在类之外使用，可以用_类名__实例属性来用&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(stu1._Student__age)</span><br></pre></td></tr></table></figure></p>
<h6 id="继承-1">1.9.2 继承</h6>
<p>在python中，如果一个类没有继承任何类，则默认继承object。python支持多继承，<strong>定义子类时，必须在其构造函数中调用父类的构造函数</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,stu_num</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.stu_num=stu_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,teachofyear</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.teachofyear=teachofyear</span><br><span class="line"></span><br><span class="line">stu=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>,<span class="number">1001</span>)</span><br><span class="line">teach=Teacher(<span class="string">&#x27;李四&#x27;</span>,<span class="number">40</span>,<span class="number">20</span>)</span><br><span class="line">stu.info()</span><br><span class="line">teach.info()</span><br></pre></td></tr></table></figure> 如上，如果子类对继承父类中的某个属性或方法不满意，可以在子类中对其（方法体）进行重新编写.<strong>子类重写后的方法中可以通过<code>super().xxx()</code>调用父类中被重写的方法</strong>。</p>
<p>另外一点，在python中object类是所有类的父类，因此所有类都有object类的属性和方法。有内置函数dir()可以查看指定对象所有属性。object还有有一个<code>__str__()</code>方法，用于返回一个对于“对象的描述”，对应于内置函数<code>str()</code>经常用于<code>print()</code>方法，帮我们查看对象的信息，所以我们经常会对<code>__str__()</code>进行重写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我的名字是&#123;0&#125;,今年&#123;1&#125;岁&#x27;</span>.<span class="built_in">format</span>(self.name,self.age)</span><br><span class="line">stu=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(stu))</span><br><span class="line"><span class="built_in">print</span>(stu)  <span class="comment">#默认会调用__str__()这样的方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(stu))</span><br></pre></td></tr></table></figure>
<h6 id="多态">1.9.3 多态</h6>
<p>多态就是“具有多种形态”,它指的是：即便不知道一个变量所引用的对象到底是 什么类型，仍然可以通过这个变量调用方法，在运行过程中根据变量所引用对象的类型， 动态决定调用哪个对象中的方法。实现多态必须有的三个条件：</p>
<ul>
<li>继承</li>
<li>方法重写</li>
<li>父类引用指向子类对象 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动物会吃&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;狗吃骨头&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猫吃鱼&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;人吃五谷杂粮&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.eat()</span><br><span class="line">fun(Cat())</span><br><span class="line">fun(Dog())</span><br><span class="line">fun(Animal())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;——————————&#x27;</span>)</span><br><span class="line">fun(Person())</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="类的浅拷贝和深拷贝">1.9.4 类的浅拷贝和深拷贝</h6>
<ul>
<li><strong>变量的赋值操作</strong>：只是形成两个变量，实际上还是指向同一个对象</li>
<li><strong>浅拷贝</strong>：python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，源对象与拷贝对象会引用同一个子对象</li>
<li><strong>深拷贝</strong>：使用copy模块的<code>deepcopy</code>函数，递归拷贝对象中包含的子对象，源对象和拷贝 对象所有的子对象也不相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Disk</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,cpu,disk</span>):</span><br><span class="line">        self.cpu=cpu</span><br><span class="line">        self.disk=disk</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.变量的赋值</span></span><br><span class="line">cpu1=CPU()</span><br><span class="line">cpu2=cpu1</span><br><span class="line"><span class="built_in">print</span>(cpu1)</span><br><span class="line"><span class="built_in">print</span>(cpu2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.类的浅深拷贝</span></span><br><span class="line">disk=Disk() <span class="comment">#创建一个硬盘类的对象</span></span><br><span class="line"><span class="built_in">print</span>(disk)</span><br><span class="line">computer=Computer(cpu1,disk)    <span class="comment">#创建一个计算机类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#浅拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">computer2=copy.copy(computer)</span><br><span class="line"><span class="built_in">print</span>(computer,computer.cpu,computer.disk)</span><br><span class="line"><span class="built_in">print</span>(computer2,computer2.cpu,computer2.disk)</span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝</span></span><br><span class="line">computer3=copy.deepcopy(computer)</span><br><span class="line"><span class="built_in">print</span>(computer,computer.cpu,computer.disk)</span><br><span class="line"><span class="built_in">print</span>(computer3,computer3.cpu,computer3.disk)</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//赋值就是简单的变量引用同一个对象</span><br><span class="line">&lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt;</span><br><span class="line">&lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#浅拷贝，对象包含的的子对象内容不拷贝，都引用同一个内容</span></span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615ED70</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615F820</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝，子对象也拷贝了</span></span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615ED70</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615DD50</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615D450</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615D3F0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="设计模式之委托模式">1.9.5 设计模式之委托模式</h6>
<p>所谓的<strong>委托</strong>，<strong>通常就是指控制对象内嵌其他对象，而把运算请求传给这些内嵌对象处理，控制器对象只负责管理工作</strong>。在python中，委托通常用<code>__getattr__</code>钩子方法实现，因为这个方法会拦截对不存在属性的读取，因此代理类可以使用<code>__getattr__</code>把任意读取操作转给被包装对象。 简而言之：通过一个类来调用另一个类里的方法来处理请求，即这两个类对象参与处理同一个请求对象，只不过一个是<strong>委托者</strong>，一个是<strong>处理者</strong>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,<span class="built_in">object</span></span>):</span><br><span class="line">		self.wrapped=<span class="built_in">object</span>;	<span class="comment">#内嵌对象</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self,attrname</span>):</span><br><span class="line">		<span class="keyword">if</span> attrname==<span class="string">&#x27;append&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped,attrname);</span><br><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">x=wrapper(L);</span><br><span class="line">x.append(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">print</span>(L)			<span class="comment">#[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure> 上述代码中，因为<code>x.append(4)</code>未在<code>wrapper</code>内定义，触发<code>__getattr__</code>函数,<code>getattr(x,y)</code>函数的作用就是点操作，即<code>x.y</code>。</p>
<h6 id="绑定和无绑定方法">1.9.6 绑定和无绑定方法</h6>
<ul>
<li>实例的绑定方法：即有<code>self</code>，且在类中没有被任何装饰器修饰的方法就是绑定到对象的方法，这类方法专门为对象定制。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    country = <span class="string">&quot;China&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">str</span>(self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;Kitty&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p.__dict__)</span><br><span class="line">p.speak()   <span class="comment">#通过对象调用 Kitty, 18</span></span><br><span class="line">Person.speak(p)   <span class="comment">#通过类调用Kitty, 18</span></span><br></pre></td></tr></table></figure>
<p>通过对象调用绑定到对象的方法，会有一个自动传值的过程，即自动将当前对象传递给方法的第一个参数（<code>self</code>，一般都叫<code>self</code>，也可以写成别的名称）；若是使用类调用，则第一个参数需要手动传值。</p>
<ul>
<li>类的绑定方法:类中使用<code>@classmethod</code>修饰的方法就是绑定到类的方法。这类方法专门为类定制。通过类名调用绑定到类的方法时，会将类本身当做参数传给类方法的第一个参数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operate_database</span>():</span><br><span class="line">    host = <span class="string">&#x27;192.168.0.5&#x27;</span></span><br><span class="line">    port = <span class="string">&#x27;3306&#x27;</span></span><br><span class="line">    user = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">cls</span>):  <span class="comment"># 约定俗成第一个参数名为cls，也可以定义为其他参数名</span></span><br><span class="line">        <span class="built_in">print</span>(cls)</span><br><span class="line">        <span class="built_in">print</span>(cls.host + <span class="string">&#x27;:&#x27;</span> + cls.port + <span class="string">&#x27; &#x27;</span> + cls.user + <span class="string">&#x27;/&#x27;</span> + cls.password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Operate_database.connect();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Operate_database&#x27;</span>&gt;</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span>:<span class="number">3306</span> abc/<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>非绑定方法:在类内部使用 <span class="citation" data-cites="staticmethod">@staticmethod</span> 修饰的方法即为非绑定方法，这类方法和普通定义的函数没有区别，不与类或对象绑定，谁都可以调用(实例和类都可以)，且没有自动传值的效果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operate_database</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port, user, password</span>):</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_passwrod</span>(<span class="params">salt, password</span>):</span><br><span class="line">        m = hashlib.md5(salt.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 加盐处理</span></span><br><span class="line">        m.update(password.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">hash_password = Operate_database.get_passwrod(<span class="string">&#x27;lala&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)  <span class="comment"># 通过类来调用</span></span><br><span class="line"><span class="built_in">print</span>(hash_password)</span><br><span class="line"></span><br><span class="line">p = Operate_database(<span class="string">&#x27;192.168.0.5&#x27;</span>, <span class="string">&#x27;3306&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line">hash_password = p.get_passwrod(p.user, p.password)  <span class="comment"># 也可以通过对象调用</span></span><br><span class="line"><span class="built_in">print</span>(hash_password)</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f7a1cc409ed6f51058c2b4a94a7e1956</span><br><span class="line">0659c7992e268962384eb17fafe88364</span><br></pre></td></tr></table></figure></p>
<h5 id="棱形继承">1.10 棱形继承</h5>
<p>在多层继承和多继承同时使用的情况下，就会出现复杂的继承关系，即重重复继乘，常说的<strong>菱形继承</strong> <img src="/python面向对象/lengxing.png" width="300"> 在这种结构中，在调用顺序上就出现了疑惑，调用顺序究竟是以下哪一种顺序呢,如果是深度，那么A会重复调用，造成不必要的消耗</p>
<ul>
<li><code>D-&gt;B-&gt;A-&gt;C-&gt;A（深度优先）</code></li>
<li><code>D-&gt;B-&gt;C-&gt;A（广度优先）</code></li>
</ul>
<p>上面问题的根源都跟MRO有关,MRO(Method Resolution Order)也叫方法解析顺序，主要用于在多重继承时判断调的属性来自于哪个类，其使用了一种叫做C3的算法，其基本思想时在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则去寻找需要的属性和方法。 <strong>要避免顶层父类某个方法被多次调用，此时就需要super()来发挥作用了,super本质上是一个类，内部记录着MRO信息，由于C3算法确保同一个类只会被搜寻一次，这样就避免了顶层父类中的方法被多次执行了</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意，这段代码是个特例，在D的注释处明显调用了B/C的构造函数，所有会执行两次A的构造函数，要使其不执行两次，则需要使用super().xxx()。这种方法很常用，应该熟记</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init A...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end A...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init B...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(B, self).__init__()</span><br><span class="line">		<span class="comment"># A.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end B...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init C...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(C, self).__init__()</span><br><span class="line">		<span class="comment"># A.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end C...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init D...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(D, self).__init__()</span><br><span class="line">		<span class="comment">#B.__init__(self)</span></span><br><span class="line">        <span class="comment">#C.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end D...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    D()</span><br></pre></td></tr></table></figure> 输出：采用广度优先搜索 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init D...</span><br><span class="line">init B...</span><br><span class="line">init C...</span><br><span class="line">init A...</span><br><span class="line">end A...</span><br><span class="line">end C...</span><br><span class="line">end B...</span><br><span class="line">end D...</span><br><span class="line"></span><br></pre></td></tr></table></figure> 值得一提的是Python类分为两种，一种叫经典类，一种叫新式类。都支持多继承，但继承方式不同：</p>
<ul>
<li><strong>新式类</strong>：从object继承来的类。（如:class A(object)），采用广度优先搜索的方式继承（即先水平搜索，再向上搜索）。</li>
<li><strong>经典类</strong>：不从object继承来的类。（如：class A()），采用深度优先搜索的方式继承（即先深入继承树的左侧，再返回，再找右侧）。</li>
</ul>
<p><strong><em>注意：Python2.x中类的是有经典类和新式类两种。Python3.x中都是新式类（类都默认继承object）。因此对于多重继承，顺序很重要，他会根据继承类在首行位置，从左到右搜索</em></strong> 实例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    attr=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    attr=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B,C):</span><br><span class="line">    <span class="keyword">pass</span>;</span><br><span class="line"></span><br><span class="line">M=D();</span><br><span class="line"><span class="built_in">print</span>(M.attr)		<span class="comment">#2</span></span><br></pre></td></tr></table></figure> 上面的代码输出为2，先解释一下：因为B、C都继承自A，D继承自B，那么在python3.x版本以上，采用了广度优先，顺序是<code>D-&gt;B-&gt;C-&gt;A</code>,在C时遇到了属性<code>attr=2</code>，停止搜索返回，输出为2</p>
<h6 id="super详解">1.10.1 super详解</h6>
<p>上面已经提到了，在python3.x版本上，都使用新式类，python避免重复调用是采用<strong>MRO(Method Resolution Order)机制也叫方法解析顺序，主要用于在多重继承时判断调的属性来自于哪个类，其使用了一种叫做C3的算法，其基本思想时在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则去寻找需要的属性和方法。</strong></p>
<p><code>super</code>本质上是一个类，但super() 和父类没有实质性的关联：</p>
<ul>
<li><code>super()</code>函数需要两个参数，第一个是类名，第二个是一般都为<code>self</code>但也会有<code>cls</code>情况，但在python3.x中使用<code>super().xxxx()</code>等同于<code>super(classname,self).xxxx()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;B&quot;</span>)</span></span><br><span class="line"><span class="function">        super().__init__()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class C(A):</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;C&quot;</span>)</span></span><br><span class="line"><span class="function">        super(C, self).__init__()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class D(B,C):</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;D&quot;</span>,D.__mro__)</span></span><br><span class="line"><span class="function">        super(D, self).__init__()</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">#输出</span></span><br><span class="line"><span class="function">D (&lt;class <span class="string">&#x27;ListNode.D&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.B&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.C&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.A&#x27;</span>&gt;, &lt;class <span class="string">&#x27;object&#x27;</span>&gt;)</span></span><br><span class="line"><span class="function">B</span></span><br><span class="line"><span class="function">C</span></span><br><span class="line"><span class="function">A</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p><code>super</code>工作原理：如果在类D中调用<code>super()</code>会传入D类，那就会在它<code>__mro__</code>上一级开始查找，它的上一级是B，就会调用B的函数，依次类推下去。如下更改D类的<code>super()</code>输出改变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;D&quot;</span>,D.__mro__)</span></span><br><span class="line"><span class="function">        super(C, self).__init__()</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">#输出：</span></span><br><span class="line"><span class="function">D (&lt;class <span class="string">&#x27;ListNode.D&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.B&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.C&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.A&#x27;</span>&gt;, &lt;class <span class="string">&#x27;object&#x27;</span>&gt;)</span></span><br><span class="line"><span class="function">A</span></span><br></pre></td></tr></table></figure>
<p>因为上一级是<code>__mro__</code>中C的上一级是A，就好执行A的<code>__init__()</code>函数</p>
<h5 id="slots可选">1.11 slots（可选）</h5>
<p>python类有一个双刃剑就是：即使我们没有在类内部创建属性，也可以在实例对象中通过<code>.</code>给实例对象创建一个属于实例的属性，这样听起来非常bug，不像java和c++这样有很好的封装性: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a=A();</span><br><span class="line">a.p=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">print</span>(a.p) <span class="comment">#20</span></span><br></pre></td></tr></table></figure> 之前提到过<code>__getattr__</code>能够对未在类内创建的属性提供操作。这里介绍python提供的<code>slots</code>来支持这一功能。 这个特殊属性一般是在类的顶层内将变量名称（字符串形式）按顺序赋值给变量<code>__slots__</code>，<strong>该属性规定：只有<code>__slots__</code>列表内的这些变量名可赋值为实例属性</strong>。它也要遵循python的规则，实例属性名必须在引用前赋值 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>:</span><br><span class="line">	__slots__=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=limiter();</span><br><span class="line"><span class="comment">#print(x.age)		#AttributeError,未赋值就引用</span></span><br><span class="line">x.age=<span class="number">40</span></span><br><span class="line"><span class="built_in">print</span>(x.age)		<span class="comment">#40</span></span><br><span class="line">x.jk=<span class="number">2</span>;				<span class="comment">#不允许，变量名不在__slots__</span></span><br></pre></td></tr></table></figure> 但是注意，类中有<code>__slots__</code>会没有<code>__dict__</code>属性，事实上，<code>__slots__</code>就是以<code>__dict__</code>的代价来起到这样一个功能的： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>:</span><br><span class="line">	__slots__=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>,<span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=limiter();</span><br><span class="line">x.jk=<span class="number">2</span>;				<span class="comment">#运行成功</span></span><br></pre></td></tr></table></figure> 没有<code>__dict__</code>，我们就不能在类的函数内随便起变量名，因此对于<code>__slots__</code>看情况使用</p>
<h5 id="装饰器">1.12. 装饰器</h5>
<p>装饰器一般有函数装饰器和类装饰器。装饰器即指通过对函数的包装来修改其他函数的功能的函数。我们知道在python中可以嵌套定义函数，<strong>但是我们外部无法直接访问嵌套内部函数，好在可以将一个函数名赋值给一个变量，其实函数名就是一个变量，只不过指向函数对象，也可通过返回函数变量名</strong>，然后通过变量名去调用<code>变量名()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">hi</span><span class="params">(name=<span class="string">&quot;yasoob&quot;</span>)</span>:</span></span><br><span class="line"><span class="function">    def greet():</span></span><br><span class="line"><span class="function">        return <span class="string">&quot;now you are in the greet() function&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    def welcome():</span></span><br><span class="line"><span class="function">        return <span class="string">&quot;now you are in the welcome() function&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    if name =</span>= <span class="string">&quot;yasoob&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> greet</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"> </span><br><span class="line">a = <span class="built_in">hi</span>()		#返回great</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">a</span>())				#调用<span class="built_in">a</span>()==<span class="built_in">great</span>()</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">&lt;function greet at <span class="number">0x7f2143c01500</span>&gt;</span><br><span class="line">now you are in the <span class="built_in">greet</span>() function</span><br></pre></td></tr></table></figure></p>
<p>既然我们能够将函数作为变量，那么变量当然可以作为参数，当我们将函数变量作为参数传递给另外一个函数时，就会产生装饰器的知识，实际上装饰器就是做这种事： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    def wrapTheFunction():</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">        a_func()</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    return wrapTheFunction</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">def a_function_requiring_decoration():</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration()</span></span><br><span class="line"><span class="function">#outputs: <span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration =</span> <span class="built_in">a_new_decorator</span>(a_function_requiring_decoration)</span><br><span class="line"><span class="meta">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">a_function_requiring_decoration</span>()</span><br><span class="line"><span class="meta">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line">#        I am the function which needs some decoration to remove my foul smell</span><br><span class="line">#        <span class="function">I am doing some boring work after executing <span class="title">a_func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="函数装饰器">1.12.1 函数装饰器</h6>
<p>上面讲解了函数装饰器的原理，提供了一种方式声明函数的特定运算模式，其原理是将函数包裹到另一个函数，在另一个函数的逻辑内实现。<strong>现在为简化其实现，使用<code>@</code>代替这些代码，所以函数装饰器在def语句前一行，由<code>@符号、后面跟着所谓的元函数</code></strong>组成。元函数就是管理另一函数（或其他可调用对象）的函数,如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">a_new_decorator</span></span><br><span class="line"><span class="function">def <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span></span><br><span class="line"><span class="function">          <span class="string">&quot;remove my foul smell&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration()</span></span><br><span class="line"><span class="function">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="function">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="function">#         I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure> 上面的<code>@a_new_decorator</code>等价于<code>a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration</code></p>
<p><strong>python内置的装饰器：</strong></p>
<ul>
<li><code>@classmethod</code>：修饰类内的方法是绑定到类的方法，该方法专门为类提供，会将类本身当作参数传给类方法的第一个参数，不需要使用对象调用当然你可以使用对象调用。</li>
<li><code>@staticmethod</code>：在类内部使用该装饰器修饰方法，这类方法不与类或对象绑定，属于静态方法，谁都可以调用，且没有自动传值功能。</li>
<li><code>@wraps(函数变量名)</code>；在上面举例的函数装饰器<code>@a_new_decorator</code>中会改变函数的<code>__name__</code>为<code>wrapTheFunction</code>，正常应该为<code>a_function_requiring_decoration</code>。这时候就需要使用<code>@wraps()</code>装饰器 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: wrapTheFunction</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="comment">#使用@wraps()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_new_decorator</span>(<span class="params">a_func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">a_func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapTheFunction</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requiring_decoration</span>():</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"><span class="comment">#输出正常</span></span><br><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: a_function_requiring_decoration</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="类装饰器">1.12.2 类装饰器</h6>
<p>类装饰器类似于函数装饰器（后续补充）</p>
<h4 id="链表实现">2. 链表实现</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value,<span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.value=value</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;节点已删除&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,Size=<span class="number">0</span>,pHead=<span class="literal">None</span></span>):</span><br><span class="line">        self.pHead=pHead</span><br><span class="line">        self.Next=pHead</span><br><span class="line">        self.Size=Size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已注销&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.Next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.currentNode=self.Next</span><br><span class="line">        self.Next=self.Next.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> self.currentNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Crease</span>(<span class="params">self</span>):</span><br><span class="line">        self.Size+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DeCrease</span>(<span class="params">self</span>):</span><br><span class="line">        self.Size-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node=ListNode(value)</span><br><span class="line">        <span class="comment">#判断是否为空链表</span></span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.pHead=node</span><br><span class="line">            <span class="keyword">return</span> self.pHead;</span><br><span class="line">        <span class="comment">#找到最后一个节点</span></span><br><span class="line">        current_Node=self.pHead;</span><br><span class="line">        preNode=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current_Node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode=current_Node</span><br><span class="line">            current_Node=current_Node.<span class="built_in">next</span></span><br><span class="line">        preNode.<span class="built_in">next</span>=node</span><br><span class="line">        self.Crease()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">erase</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            preNode=<span class="literal">None</span></span><br><span class="line">            current_node=self.pHead;</span><br><span class="line">            <span class="keyword">while</span> current_node!=<span class="literal">None</span> <span class="keyword">and</span> current_node.value != value:</span><br><span class="line">                preNode=current_node</span><br><span class="line">                current_node=current_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> preNode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">             self.pHead=self.pHead.<span class="built_in">next</span></span><br><span class="line">             self.DeCrease()</span><br><span class="line">             <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">elif</span> current_node.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode.<span class="built_in">next</span>=current_node.<span class="built_in">next</span></span><br><span class="line">            self.DeCrease()</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">return</span> self.pHead</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,value</span>):</span><br><span class="line">        Next=self.pHead</span><br><span class="line">        <span class="keyword">while</span> Next.value <span class="keyword">is</span> <span class="keyword">not</span> value:</span><br><span class="line">            Next=Next.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> Next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        current_node=self.pHead</span><br><span class="line">        preNode=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current_node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode=current_node</span><br><span class="line">            current_node=current_node.<span class="built_in">next</span></span><br><span class="line">        preNode.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        self.DeCrease()</span><br><span class="line">        <span class="keyword">return</span> current_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        retNode=self.pHead</span><br><span class="line">        self.pHead=self.pHead.<span class="built_in">next</span></span><br><span class="line">        self.DeCrease()</span><br><span class="line">        <span class="keyword">return</span> retNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_front</span>(<span class="params">self,value</span>):</span><br><span class="line">        node = ListNode(value)</span><br><span class="line">        self.Next=self.pHead</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.pHead=node</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        node.<span class="built_in">next</span>=self.pHead</span><br><span class="line">        self.pHead=node</span><br><span class="line">        self.Crease()</span><br><span class="line">        self.Next=self.pHead</span><br><span class="line">        <span class="keyword">return</span> self.pHead</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">python基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-24 09:07:58" itemprop="dateCreated datePublished" datetime="2022-06-24T09:07:58+08:00">2022-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-15 15:31:16" itemprop="dateModified" datetime="2022-10-15T15:31:16+08:00">2022-10-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="python的运行过程">1. python的运行过程</h4>
<p><img src="https://img-blog.csdnimg.cn/9f0f1b3db22d4c1e8a5bdd455e7702a7.jpeg#pic_center"></p>
<h5 id="字节码编译">1.1 字节码编译</h5>
<pre><code>当程序运行时,Python内部会将源代码(.py文件中的程序)编译成所谓的字节码的形式,就是将每一行源代码语句从上到下翻译过来,翻译成一组字节码的指令.这些字节码可以提高执行速度;比起源代码语句,字节码要执行快的多。
它会将字节码保存为一个以pyc为扩展名的文件，Python这样保存字节码是一种作为启动速度的优化.下一次运行程序时,如果你还停留在上一次修改记录的话,就会直接跳过编译直接加载.pyc文件.</code></pre>
<h5 id="pvm虚拟机">1.2 PVM虚拟机</h5>
<p>py程序编译成字节码后，字节码文件会发送给PVM，也就是python虚拟机进行出来。PVM是python运行的引擎，从根本上讲，它才算是python解释器。python虚拟机就是去模拟可执行程序在x86机器上的运行</p>
<h4 id="python的内置对象">2. python的内置对象</h4>
<p>python中没有类型声明，运行的表达式的语法决定了创建和使用对象的类型，正如以下表达式就是这些类型起源的地方。Python有五个标准的数据类型：</p>
<ul>
<li><code>Numbers</code>（数字）</li>
<li><code>String</code>（字符串）</li>
<li><code>List</code>（列表）</li>
<li><code>Tuple</code>（元组）</li>
<li><code>Dictionary</code>（字典）</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">column</th>
<th style="text-align: center;">column</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数字</td>
<td style="text-align: center;"><code>1234，3.14159，3+4j</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">字符串</td>
<td style="text-align: center;"><code>'spaw',&quot;guidos&quot;,&quot;python&quot;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">列表</td>
<td style="text-align: center;"><code>[1,[2,'there'],4]</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">字典</td>
<td style="text-align: center;"><code>&#123;'food':'spam','taste':'yum'&#125;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">元组</td>
<td style="text-align: center;"><code>(1,'spam',4,'u')</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">文件</td>
<td style="text-align: center;"><code>my=open('eggs','r')</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">集合</td>
<td style="text-align: center;"><code>set('abs'),&#123;'a','b','s'&#125;</code></td>
</tr>
</tbody>
</table>
<p>可迭代对象：字符串、列表、字典、元组、集合、文件对象 一些操作： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//数字整型</span><br><span class="line">s=<span class="number">546</span>;</span><br><span class="line">s=s*<span class="number">4</span>;</span><br><span class="line">//字符串</span><br><span class="line">s=<span class="string">&#x27;spam&#x27;</span>;</span><br><span class="line">k=<span class="built_in">len</span>(s); 	<span class="comment">#k=4</span></span><br><span class="line">s=s+<span class="string">&#x27;xyz&#x27;</span>;  <span class="comment">#s=&#x27;spamxyz&#x27;</span></span><br><span class="line">//序列操作</span><br><span class="line">s=<span class="string">&#x27;spam&#x27;</span>;</span><br><span class="line">q=s[<span class="number">0</span>];</span><br><span class="line">m=s[-<span class="number">1</span>];	<span class="comment">#字符串长度-1，即s[4-1]</span></span><br><span class="line">t=s[<span class="number">0</span>:<span class="number">3</span>]	<span class="comment">#从下标0开始，输出三个字符，即t=&#x27;spa&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>重要性质：</strong></p>
<p><strong>python的对象内存不可变性：</strong>在上面所写的例子中没有通过任何操作对原始字符串即spam变动，字符串在python中具有不可变性，在创建后就不可改变，但比总可以通过建立一个新的字符串并以同一个名字对其进行赋值（如<code>s=s+'xyz'</code>)，因为python在运行过程中会清理旧对象（动态类型）。<strong>一旦改变便意味是产生了新的对象</strong></p>
<h4 id="数字类型">3. 数字类型</h4>
<h5 id="一些内置的数学函数">3.1 一些内置的数学函数</h5>
<table>
<thead>
<tr class="header">
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>abs()</code></td>
<td>取绝对值</td>
</tr>
<tr class="even">
<td><code>pow()</code></td>
<td>计算任意N次方值</td>
</tr>
<tr class="odd">
<td><code>min()\max()</code></td>
<td>取最小值</td>
</tr>
<tr class="even">
<td><code>divmod()</code></td>
<td>同时取商和余数</td>
</tr>
<tr class="odd">
<td><code>sum()</code></td>
<td>求和</td>
</tr>
<tr class="even">
<td><code>round()</code></td>
<td>四舍五入</td>
</tr>
<tr class="odd">
<td><code>hex()</code></td>
<td>十进制转为十六进制</td>
</tr>
</tbody>
</table>
<h5 id="表达式操作符">3.2 表达式操作符</h5>
<p>与C/C++有些不同： <img src="https://img-blog.csdnimg.cn/57b3415f38e34a2a96c5b56f1dd1bffa.jpeg#pic_center"></p>
<h4 id="字符串">4. 字符串</h4>
<h5 id="raw字符串抑制转义">4.1 raw字符串抑制转义</h5>
<p>转义序列用来处理嵌入在自符串中的特殊字节编码很合适，但有些场合我们希望不要发生转义，如文件路径中<code>myfile=open('C:\new\test.txt','w')。</code>本意想打开这个文件，但是因为转义字符<code>\n</code>的存在。如果字母<code>r</code>出现在字符串第一个引号钱，意味着关闭转义：<code>myfile=open(R'C:\new\test.txt','w')'</code></p>
<h5 id="常见操作">4.2 常见操作</h5>
<p>对于python的字符串，无论是<code>&quot;&quot;</code>还是<code>''</code>都一样,支持串与串的相加，支持串与数的相乘，但不允许串与数的相加。同时支持负偏移和分片操作： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;trluper&quot;</span>;	<span class="comment">#合法</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;	<span class="comment">#合法</span></span><br><span class="line">c=<span class="built_in">str</span>[-<span class="number">1</span>];		<span class="comment">#str[len(str)-1]=str[6]</span></span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>+<span class="string">&#x27;github&#x27;</span>;</span><br><span class="line"><span class="built_in">str</span>*=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">str</span>+=<span class="number">4</span>;			<span class="comment">#error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r</span><br><span class="line">trlupergithub</span><br><span class="line">trlupergithubtrlupergithubtrlupergithubtrlupergithub</span><br></pre></td></tr></table></figure></p>
<p><strong>分片：</strong><code>Str[i:j]</code>i表示从下标为i的开始，小标j结束（不包括j）(i未输入时默认为0，j未说明默认为到最后一个元素)。即<code>str[1:-1]</code>,表示从r开始到e结束（<code>len(str)-1=6</code>），<strong>分片会产生新对象。</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br><span class="line">s=<span class="built_in">str</span>[<span class="number">1</span>:-<span class="number">1</span>];</span><br><span class="line"><span class="built_in">print</span>(s);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlupe</span><br></pre></td></tr></table></figure></p>
<p><strong>扩展分片：</strong>分片表达式有可选的第三个索引，用作步进<code>str[i:j:k]</code>，未声明时k默认为1，表示隔几个元素取 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br><span class="line">s=<span class="built_in">str</span>[<span class="number">1</span>:-<span class="number">1</span>:<span class="number">2</span>];</span><br><span class="line"><span class="built_in">print</span>(s);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rue</span><br></pre></td></tr></table></figure></p>
<h5 id="数据类型转换">4.3 数据类型转换</h5>
<p>上面讲到字符串和数字之间无法相加，会发生错误，为解决这方面问题，python提供了字符串和数字间的转换函数：</p>
<table>
<thead>
<tr class="header">
<th>函数名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>int(string s)</code></td>
<td>将字符串转换为数字</td>
</tr>
<tr class="even">
<td><code>str(int i)</code></td>
<td>将数字转换为字符串</td>
</tr>
<tr class="odd">
<td><code>float(string s</code>)</td>
<td>将字符串转换为浮点数</td>
</tr>
<tr class="even">
<td><code>repr(object)</code></td>
<td>将对象转换为字符串并返回一个字符串对象</td>
</tr>
<tr class="odd">
<td><code>ord(char c)</code></td>
<td>将单个字符转为ascii码</td>
</tr>
<tr class="even">
<td><code>chr(int i)</code></td>
<td>将数字转换为对于的ascii码</td>
</tr>
<tr class="odd">
<td><code>tuple(s)</code></td>
<td>将序列 s 转换为一个元组</td>
</tr>
<tr class="even">
<td><code>list(s)</code></td>
<td>将序列 s 转换为一个列表</td>
</tr>
<tr class="odd">
<td><code>set(s)</code></td>
<td>转换为可变集合</td>
</tr>
<tr class="even">
<td><code>dict(d)</code></td>
<td>创建一个字典。d 必须是一个序列 (key,value)元组。</td>
</tr>
</tbody>
</table>
<h5 id="修改查询字符串">4.4 修改/查询字符串</h5>
<p>对于不可变性质，如果我们要改变原有字符串的一些值，则需要利用合并、分片这样的工具来重新建立并赋值一个新字符串或者<code>replace</code>，若有必要（程序的方便和易读），需要将结果重新赋值给原变量名。查找可以使用<code>find()</code>函数或者判断<code>“Trl&quot; in str</code>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;Trluper!&#x27;</span>;</span><br><span class="line"><span class="built_in">str</span>[<span class="number">0</span>]=<span class="string">&#x27;t&#x27;</span>;	<span class="comment">#error</span></span><br><span class="line">//分片合并</span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>[:<span class="number">3</span>]+<span class="string">&quot;user&quot;</span>+<span class="built_in">str</span>[-<span class="number">1</span>];</span><br><span class="line">//replace</span><br><span class="line"><span class="built_in">str</span>=<span class="built_in">str</span>.replace(<span class="string">&quot;uper&quot;</span>,<span class="string">&quot;user&quot;</span>);</span><br><span class="line">//查找</span><br><span class="line"><span class="built_in">str</span>.find(<span class="string">&quot;trl&quot;</span>);	<span class="comment">#找到返回第一个下标，未找到则返回-1</span></span><br><span class="line">“trl” <span class="keyword">in</span> <span class="built_in">str</span>;		<span class="comment">#return True or false</span></span><br></pre></td></tr></table></figure></p>
<h5 id="字符串格式化">4.5 字符串格式化</h5>
<p>字符串格式化提供了一种组合字符串处理任务的处理思想。在python中有两种形式的<strong>字符串格式化表达式</strong>：</p>
<ol type="1">
<li>基于C的<code>printf模型</code>:在%左侧放置字符串，字符串中带有一个或多个嵌入目标(即<code>%d、%s、%c</code>这些)，<code>%</code>右侧放置一个元组或字典 。</li>
<li>python的字符串的<code>format函数</code>：通过花括号的位置或者关键字指出替换目标</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于元组的字符串格式化：</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;my name is %s,and I am %d years old&quot;</span> %(<span class="string">&quot;trluper&quot;</span>,<span class="number">24</span>);</span><br><span class="line"><span class="comment">#基于字典</span></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;my name is %(name)s,and I am %(age)d years old&quot;</span> % &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;trluper&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>&#125;;</span><br><span class="line"><span class="comment">#format函数</span></span><br><span class="line">template=<span class="string">&quot;my name is &#123;0&#125;,and i am &#123;age&#125; years old&quot;</span> ;</span><br><span class="line"><span class="built_in">str</span>=template.<span class="built_in">format</span>(<span class="string">&quot;trluper&quot;</span>,age=<span class="number">24</span>);</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> I am <span class="number">24</span> years old</span><br><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> I am <span class="number">24</span> years old</span><br><span class="line">my name <span class="keyword">is</span> trluper,<span class="keyword">and</span> i am <span class="number">24</span> years old</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串的函数接口">5. 字符串的函数接口</h4>
<h5 id="字符串查询">5.1 字符串查询</h5>
<p>建议使用<code>find</code>，因为如果没有找到匹配的字符串，<code>index</code>方法会报异常。</p>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>find(str, beg=0, end=len(string))</code></td>
<td>查找子串<code>str</code>第一次出现的位置，如果找到则返回相应的索引，否则返回-1</td>
</tr>
<tr class="even">
<td><code>rfind(str, beg=0,end=len(string))</code></td>
<td>类似于<code>find()</code>函数，不过是从右边开始查找</td>
</tr>
<tr class="odd">
<td><code>index(str, beg=0, end=len(string))</code></td>
<td>类似于<code>find</code>，只不过如果没找到会报异常。</td>
</tr>
<tr class="even">
<td><code>rindex(str, beg=0 end=len(string))</code></td>
<td>类似于<code>rfind</code>，如果没有匹配的字符串会报异常</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;my name is qlee，what your name?&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2))<span class="comment">#全部查找</span></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2,<span class="number">5</span>))<span class="comment">#从第5个元素开始查找</span></span><br><span class="line"><span class="built_in">print</span>(str1.find(str2,<span class="number">35</span>))<span class="comment"># 从第35个元素开始查找，超过元素索引或者没找到，不会报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="字符串大小写转换操作upperlowerswapcasecapitalize和title">5.2 字符串大小写转换操作（upper、lower、swapcase、capitalize和title）</h5>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>upper</code></td>
<td>将字符串中所有元素都转为大写</td>
</tr>
<tr class="even">
<td><code>lower</code></td>
<td>将字符串中所有元素都转为小写</td>
</tr>
<tr class="odd">
<td><code>swapcase</code></td>
<td>交换大小写。大写转为小写，小写转为大写</td>
</tr>
<tr class="even">
<td><code>capitalize</code></td>
<td>第一个大写，其余小写</td>
</tr>
<tr class="odd">
<td><code>title</code></td>
<td>每个单词的第一次字符大写，其余均为小写</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="string">&quot;my name is Qlee&quot;</span></span><br><span class="line"><span class="built_in">print</span>(txt.upper())</span><br><span class="line"><span class="built_in">print</span>(txt.lower())</span><br><span class="line"><span class="built_in">print</span>(txt.swapcase())</span><br><span class="line"><span class="built_in">print</span>(txt.capitalize())</span><br><span class="line"><span class="built_in">print</span>(txt.title())</span><br></pre></td></tr></table></figure>
<h5 id="字符串对齐centerjust和zfill">5.3 字符串对齐（center，just和zfill）</h5>
<p><img src="/python基础知识/1.png" width="700"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.center(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.ljust(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.rjust(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.zfill(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*********hello world!*********</span><br><span class="line">hello world!******************</span><br><span class="line">******************hello world!</span><br><span class="line">000000000000000000hello world!</span><br></pre></td></tr></table></figure>
<h5 id="分割字符串splitsplitlines和partition">5.4 分割字符串(split、splitlines和partition)</h5>
<p><img src="/python基础知识/2.png" width="700"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;my name is qlee, what is your name&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split())       <span class="comment"># 以空格为分隔符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split(<span class="string">&#x27;i&#x27;</span>,<span class="number">1</span>))   <span class="comment"># 以 i 为分隔符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.split(<span class="string">&#x27;b&#x27;</span>))     <span class="comment"># 以b为分隔符,没找到不会报错</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.partition(<span class="string">&quot;name&quot;</span>))<span class="comment">#找到第一个name，分割为三部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.rpartition(<span class="string">&quot;name&quot;</span>))<span class="comment">#反向找到第一个name，分割为三部分</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;&quot;&quot;my name is qlee</span></span><br><span class="line"><span class="string">      what is your name&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.splitlines())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;qlee,&#x27;</span>, <span class="string">&#x27;what&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;your&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;my name &#x27;</span>, <span class="string">&#x27;s qlee, what is your name&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;my name is qlee, what is your name&#x27;</span>]</span><br><span class="line">(<span class="string">&#x27;my &#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27; is qlee, what is your name&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;my name is qlee, what is your &#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;my name is qlee&#x27;</span>, <span class="string">&#x27;      what is your name&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="合并与替换joinreplace">5.5 合并与替换(join，replace)</h5>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>join(seq)</code></td>
<td>以指定字符串作为分隔符，将 <code>seq</code> 中所有的元素(的字符串表示)合并为一个新的字符串</td>
</tr>
<tr class="even">
<td><code>replace(old,new [,max])</code></td>
<td>把 将字符串中的 <code>old</code> 替换成 <code>new</code>,如果 <code>max</code>指定，则替换不超过<code>max</code>次</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------join-----------&quot;</span>)</span><br><span class="line">seq1 = (<span class="string">&quot;h&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>) <span class="comment">#元组</span></span><br><span class="line">seq2 = [<span class="string">&quot;h&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>] <span class="comment">#列表</span></span><br><span class="line">seq3 = <span class="string">&quot;hello&quot;</span> <span class="comment">#字符串</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;&quot;</span>.join(seq1)) <span class="comment">#无分隔符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot; &quot;</span>.join(seq1))<span class="comment">#空格</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;,&quot;</span>.join(seq1))<span class="comment">#&quot;,&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------replace-----------&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;my name is qlee&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>.replace(<span class="string">&quot;qlee&quot;</span>, <span class="string">&quot;lq&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------join-----------</span><br><span class="line">hello</span><br><span class="line">h e l l o</span><br><span class="line">h,e,l,l,o</span><br><span class="line">----------replace-----------</span><br><span class="line">my name <span class="keyword">is</span> lq</span><br></pre></td></tr></table></figure></p>
<h5 id="字符串的比较maxmin等">5.6 字符串的比较(&lt;,&gt;,max,min等)</h5>
<p>字符串的比较操作：</p>
<ul>
<li>运算符：<code>&gt; , &gt;=, &lt;, &lt;=, ==, !=</code></li>
<li>比较规则：从第一个以此往下比较。</li>
<li>比较原理：比较的是<code>oridinal value</code>(原始值，即ascii码值)</li>
</ul>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>max(str)</code></td>
<td>返回字符串<code>str</code>中最大的字母</td>
</tr>
<tr class="even">
<td><code>min(str)</code></td>
<td>返回字符串<code>str</code>中最小的字母</td>
</tr>
<tr class="odd">
<td><code>ord</code></td>
<td>将指定字符转换为原始值</td>
</tr>
<tr class="even">
<td><code>chr</code></td>
<td>将原始值转换为对应的字符</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;mynameisqlee&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;max(str): &quot;</span>, <span class="built_in">max</span>(<span class="built_in">str</span>),<span class="string">&quot;min(str): &quot;</span>, <span class="built_in">min</span>(<span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> &lt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;c&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">98</span>))</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="built_in">str</span>):  y <span class="built_in">min</span>(<span class="built_in">str</span>):  a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure></p>
<h5 id="判断字符串isidentifierisspaceisalphaisdecimalisnumeric和isalnum等">5.7 判断字符串(isidentifier、isspace、isalpha、isdecimal、isnumeric和isalnum等)</h5>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>isidentifier</code></td>
<td>判断字符串是不是合法标识符(字符、数字、下划线)</td>
</tr>
<tr class="even">
<td><code>isspace</code></td>
<td>判断字符是否只有空白字符(回车、换行和水平制表符)</td>
</tr>
<tr class="odd">
<td><code>isalpha</code></td>
<td>判断字符串是否全部由字母组成</td>
</tr>
<tr class="even">
<td><code>isdecimal</code></td>
<td>判断字符是否全部由十进制的数字组成，不包括中文、罗马字符</td>
</tr>
<tr class="odd">
<td><code>isdigit</code></td>
<td>判断字符串只包含数字，不包括中文数字</td>
</tr>
<tr class="even">
<td><code>isnumeric</code></td>
<td>判断字符串是否全部由数字组成，中文数字也算</td>
</tr>
<tr class="odd">
<td><code>isalnum</code></td>
<td>判断字符串是否由字母和数字组成</td>
</tr>
<tr class="even">
<td><code>islower</code></td>
<td>判断字符串中的字符是否全部为小写，字符串至少有一个字符</td>
</tr>
<tr class="odd">
<td><code>isupper</code></td>
<td>判断字符串中的字符是否全部为大写，字符串至少有一个字符</td>
</tr>
<tr class="even">
<td><code>istitle</code></td>
<td>判断字符串是否标题话，见<code>titile</code></td>
</tr>
<tr class="odd">
<td><code>isascii</code></td>
<td>如果字符串为空或字符串中的所有字符都是 ASCII，则返回 <code>True</code>，否则返回<code>False</code>。</td>
</tr>
<tr class="even">
<td><code>isprintable</code></td>
<td>如果所有字符都是可打印的，则<code>isprintable()</code>方法返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&amp;&quot;</span>.isidentifier())<span class="comment">#False,&amp;为非法标识符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;   t&quot;</span>.isspace())<span class="comment">#False,&quot;t&quot;为非空</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aldflafd你好&quot;</span>.isalpha())<span class="comment">#ture,中文也可以</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isdecimal())<span class="comment">#False,中文不属于十进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isnumeric())<span class="comment">#True,中文、罗马字符的数字也算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123abc&quot;</span>.isalnum())<span class="comment">#True,只能字母和数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123四&quot;</span>.isdigit())<span class="comment">#False，不能包括中文</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.islower())<span class="comment"># False,不能为空字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;TLUHBH&quot;</span>.isupper())<span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My Name Is Qlee&quot;</span>.istitle())<span class="comment">#True,只有第一个字符为大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是中国人&quot;</span>.isascii())<span class="comment">#False，中文不属于ascii</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello!\nAre you ?&quot;</span>.isprintable()) <span class="comment">#False,\n不可打印</span></span><br></pre></td></tr></table></figure>
<h4 id="模式匹配">6. 模式匹配</h4>
<p>字符串对象的方法能够支持基于模式的文本出处理，文本的模式匹配是一个高级工具，需要导入一个re模块，这个模块包含了搜索、分割和替换等调用。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re;</span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;Hello  se es ra df world&quot;</span>;</span><br><span class="line">match=re.match(<span class="string">&#x27;Hello[\t]*(.*)world&#x27;</span>,<span class="built_in">str</span>);</span><br><span class="line">gr=match.group(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(gr);</span><br></pre></td></tr></table></figure> 上面这个例子是在以Hello未开始，后面接这几个或零个制表符或空格的，接着将任意字符保存至组中，后以world结尾的str， 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">se es ra df</span><br></pre></td></tr></table></figure></p>
<h4 id="列表list">7. 列表(list)</h4>
<p>python的列表对象是一个任意类型对象的位置相关的有序集合，没有固定大小，不像C++数组那样，它没有固定类型的约束，同时python的核心数据类型一个优秀特性就是能支持任意类型的嵌套。<strong>同字符串不同，列表是可变对象，支持在原处修改</strong>，总结性质如下：</p>
<ul>
<li>列表是保持从左到右的序列，列表内存储的元素没有类型限制，也支持任意嵌套</li>
<li>列表可以像字符串一样索引、分片和合并</li>
<li>与字符串不同的是，列表是可变的，支持在原处修改。同时列表的长度可以改变</li>
<li>在python解释器内部，列表就是C数组，而不是链结构</li>
<li>存储的是对象引用，而不是拷贝，因此从这来看很像C/C++的指针数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#包含了整型、字符串、浮点数</span></span><br><span class="line">L=[<span class="number">123</span>,<span class="string">&quot;spam&quot;</span>,<span class="number">1.23</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">#一些接口</span></span><br><span class="line">append(<span class="built_in">object</span>, /)	<span class="comment">#将任意object在列表尾部插入</span></span><br><span class="line">pop();				<span class="comment">#移除给定偏移项</span></span><br><span class="line">insert();			<span class="comment">#插入元素</span></span><br><span class="line">remove（）;			<span class="comment">#按照值移除</span></span><br><span class="line">sort();				<span class="comment">#安照默认的升序排序</span></span><br><span class="line">reverse();			<span class="comment">#翻转</span></span><br><span class="line"><span class="keyword">del</span> L[i]			<span class="comment">#删除指定位置元素</span></span><br></pre></td></tr></table></figure>
<h4 id="列表解析">8. 列表解析</h4>
<p>处理序列和列表的方法中，python还包括了一个更高级的的操作，称为列表解析表达式.<strong>列表解析最常应用迭代协议的环境之一</strong>，列表解析把任意一个表达式应用于一个迭代对象中的元素。它可提供一种处理矩阵这样的数据结构。假如现在要从矩阵中提取第二列，使用列表解析可以很简单提取出来：<code>row[1]for row in AOI_world</code>,这种表达式有许多玩法，如<code>row[1]for row in AOI_world if row[1]%2==0</code></p>
<ul>
<li>列表解析编写代码比for循环更精简</li>
<li>执行速度更快</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AOI_world=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]];</span><br><span class="line">col2=[row[<span class="number">1</span>]<span class="keyword">for</span> row <span class="keyword">in</span> AOI_world];</span><br><span class="line"><span class="built_in">print</span>(col2);</span><br><span class="line"></span><br><span class="line"><span class="comment">#更爽的用法,rstrip函数去除右边的空白，使用if滤除开头不为p的字符串</span></span><br><span class="line">lines=[line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">if</span> line[<span class="number">0</span>]==<span class="string">&#x27;p&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure> 当然其他相关函数内容如<code>map</code>，<code>filter</code>还未介绍，但列表解析这里可以涉及一些。列表解析说白了，就是把任意一个表达式应用于一个可迭代对象中的元素，并将结束收集到一个新列表中。列表解析能够成为比<code>filter,map</code>更有用的函数工具： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用map</span></span><br><span class="line">res=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>,<span class="string">&#x27;trluper&#x27;</span>));</span><br><span class="line"><span class="comment">#用列表解析</span></span><br><span class="line">res=[<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;trluper&#x27;</span>];</span><br><span class="line"><span class="comment">#使用if的列表解析能有与filter一样的过滤功能</span></span><br><span class="line">res=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"><span class="comment">#嵌套for循环</span></span><br><span class="line">res=[x+y <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]];</span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：列表解析会产生一个新列表对象。</p>
<h4 id="字典dictionary">9. 字典(Dictionary)</h4>
<p>字典是一种映射，是一个键值对集合，通过键值获取相应的值，字典具有可变性，可以随需求增大或减小，像列表那样。字典页可以嵌套，性质总结：</p>
<ul>
<li>字典其实就是散列表也叫哈希表，通过键对生成哈希码而找到值，通过键值对映射类型</li>
<li>与列表不同，字典是无序，保存在字典中的项没有特定的顺序，因此不支持序列操作，如下标访问，是通过键值访问，键值是不可重复的</li>
<li>与列表一样，可变长，存储的元素可为任意类型，支持任意嵌套，可以在原处修改；存储的是对象引用，而不是拷贝 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keyValue_test=&#123;<span class="string">&#x27;food&#x27;</span>:<span class="string">&#x27;fish&#x27;</span>,<span class="string">&#x27;quantity&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;price&#x27;</span>:<span class="number">50</span>&#125;;</span><br><span class="line">fod_name=keyValue_test[<span class="string">&#x27;food&#x27;</span>];</span><br></pre></td></tr></table></figure> <strong>字典常用函数：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;fish&quot;</span> <span class="keyword">in</span> keyValue;		<span class="comment">#键存在判断</span></span><br><span class="line">D.keys();				<span class="comment">#返回所有键,可迭代对象</span></span><br><span class="line">D.values();				<span class="comment">#返回所有值,可迭代对象</span></span><br><span class="line">D.items();				<span class="comment">#键+值,可迭代对象</span></span><br><span class="line">D.copy();				<span class="comment">#拷贝</span></span><br><span class="line">D.get(key,\);			<span class="comment">#返回key对应的值，相当于D[key]</span></span><br><span class="line">D.update(D1);			<span class="comment">#合并字典</span></span><br><span class="line">D.pop(key);				<span class="comment">#删除键值对</span></span><br><span class="line"><span class="built_in">len</span>(D);					<span class="comment">#长度</span></span><br><span class="line"><span class="keyword">del</span> D[key];</span><br><span class="line"><span class="built_in">list</span>(D.keys())			<span class="comment">#生成键序列</span></span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>clear()</code></td>
<td>删除字典内所有元素</td>
</tr>
<tr class="even">
<td><code>copy()</code></td>
<td>返回一个字典的浅复制</td>
</tr>
<tr class="odd">
<td><code>fromkeys(seq[, val])</code></td>
<td>创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td>
</tr>
<tr class="even">
<td><code>get(key, default=None)</code></td>
<td>返回指定键的值，如果值不在字典中返回default值</td>
</tr>
<tr class="odd">
<td><code>has_key(key)</code></td>
<td>如果键在字典dict里返回true，否则返回false</td>
</tr>
<tr class="even">
<td><code>items()</code></td>
<td>以列表返回可遍历的(键, 值) 元组数组</td>
</tr>
<tr class="odd">
<td><code>keys()</code></td>
<td>以列表返回一个字典所有的键</td>
</tr>
<tr class="even">
<td><code>setdefault(key, default=None)</code></td>
<td>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr class="odd">
<td><code>update(dict2)</code></td>
<td>把字典dict2的键/值对更新到dict里</td>
</tr>
<tr class="even">
<td><code>values()</code></td>
<td>以列表返回字典中的所有值</td>
</tr>
<tr class="odd">
<td><code>pop(key[,default])</code></td>
<td>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td>
</tr>
<tr class="even">
<td><code>popitem()</code></td>
<td>返回并删除字典中的最后一对键和值。</td>
</tr>
</tbody>
</table>
<h5 id="键的排序">9.1 键的排序</h5>
<ul>
<li><p>因为字典不是序列，不包含任何可靠的从左到右的顺序排序方法，当我们需要强调某种顺序时，一个常用方法就是通过字典的keys方法收集一个键的列表，使用列表的<code>sort</code>方法进行排序： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_list=<span class="built_in">list</span>(d.keys());</span><br><span class="line"><span class="built_in">print</span>(key_list);</span><br><span class="line">key_list.sort();</span><br><span class="line"><span class="built_in">print</span>(key_list);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;quantity&#x27;</span>, <span class="string">&#x27;buyer&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;buyer&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;quantity&#x27;</span>]</span><br></pre></td></tr></table></figure></p></li>
<li><p>第二种方法是通过使用最新的<code>sorted</code>内置函数可以一步完成，<code>sorted</code>调用后会返回排序后的新列表对象 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="built_in">sorted</span>(d);</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(key,<span class="string">&quot;==&gt;&quot;</span>,d[key]);</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buyer ==&gt; TOM</span><br><span class="line">food ==&gt; fish</span><br><span class="line">price ==&gt; <span class="number">50</span></span><br><span class="line">quantity ==&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="set集合">10. set集合</h4>
<p>set集合是无序的，它既不是映射也不是序列，可以说它是存储无值的键，而且键值唯一不可变</p>
<p>创建集合对象： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python2.6版</span></span><br><span class="line">x=<span class="built_in">set</span>(<span class="string">&#x27;abcde&#x27;</span>);</span><br><span class="line">y=<span class="built_in">set</span>(<span class="string">&#x27;bdxyz&#x27;</span>);</span><br><span class="line"></span><br><span class="line">z=x&amp;y</span><br><span class="line"><span class="built_in">print</span>(z);</span><br><span class="line"></span><br><span class="line">i=x.intersection(y);</span><br><span class="line"><span class="built_in">print</span>(i);</span><br><span class="line">x.add(<span class="string">&#x27;trluper&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line">x.update(<span class="built_in">set</span>([<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;y&#x27;</span>]));</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line">x.remove(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">#python3.0</span></span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;trluper&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="元组tuple">11. 元组(tuple)</h4>
<p>元组对象是一个不可改变的列表，他有列表的有序性，但没有列表的可变性，和字符串类似。它们编写在圆括号<code>()</code>而不是<code>[]</code>和<code>&#123;&#125;</code>内,<strong><code>()</code></strong>时可选的，不是必须，。它们支持任意类型和任意嵌套。元组提供了不可变这一项约束是使用它的原因，否则使用列表。性质总结：</p>
<ul>
<li>元组是位置有序的对象集合，因此支持下标访问，支持分片。</li>
<li>与字符串一样，元组是不可比变的，不能在原处进行修改。因此元组也就是长度不可变的，在不生产一个新对象下不能增长或缩短</li>
<li>元组内的元素可为任意类型且为引用，而不是拷贝，支持任意嵌套</li>
<li>元组不支持任何方法调用，但是支持字符串和列表的一般序列操作：合并、倍乘、分块</li>
</ul>
<p>一般操作： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T=(elements);   <span class="comment">#创建元组</span></span><br><span class="line">T=i,j,k,l		<span class="comment">#省略()创建元组</span></span><br><span class="line">T[j];			<span class="comment">#访问</span></span><br><span class="line">T[i:j];			<span class="comment">#分块</span></span><br><span class="line"><span class="built_in">len</span>(T);			<span class="comment">#长度</span></span><br><span class="line">T1+T2;			<span class="comment">#合并</span></span><br><span class="line">T*<span class="number">3</span>;			<span class="comment">#内容倍乘</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> T:		<span class="comment">#迭代</span></span><br><span class="line">“trlupe<span class="string">r&quot; in T;	#元组内是否有该元素</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></p>
<p>在python3.0以上，有元组的专有调用方法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index(element);		<span class="comment">#查询元素下标</span></span><br><span class="line">count(element);		<span class="comment">#统计元素出现过几次</span></span><br></pre></td></tr></table></figure></p>
<h4 id="文件">12. 文件</h4>
<p>文件对象提供了python编程对外部文件操作的接口，要创建一个文件对象，就必须调用内置的<code>open</code>函数打开问文件： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_object=<span class="built_in">open</span>(<span class="string">&quot;*.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure> 除了<code>open</code>这个函数，python还有额外的类文件工具：管道、FIFO、套接字、通过键访问文件、对象吃久、基于描述符的文件、关系数据库等.</p>
<p><strong>文件常用函数接口：</strong></p>
<p><img src="/python基础知识/file.jpg" width="600"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_name=<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">lines=file_name.readlines();	<span class="comment">#读取整个文件到列表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><em>注意：</em></strong>在写入时，我们必须将对象转换成字符串，同样在读出时，我们也必须用转换工具将文本文件中的字符串转换乘python对象</p>
<h4 id="python的动态类型">13. python的动态类型</h4>
<h5 id="动态类型是什么">13.1 动态类型是什么</h5>
<p>python的动态类型是为什么在python不必声明变量的存在和类型的缘由。<strong>python使用动态类型和他提供的多态性来提供python语言的简洁灵活的基础。在python中我们是不会声明所使用对象的确切类型的。所谓的python动态类型，就是在程序运行的过程中自动决定对象的类型。</strong></p>
<ul>
<li>与C/C++明显不同的是，在python中，变量只是一个名字，它永远不会有任何类型约束，变量是通用的，在python中类型的概念只存在于对象中。</li>
<li>变量在赋值的时候才创建，即没有声明，当变量出现在表达式中，它会被当前引用的对象所替代，无论该对象是什么类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">就如a=<span class="number">3</span>这个简单的赋值语句，python分步：</span><br><span class="line">	<span class="number">1.</span>创建一个对象代表<span class="number">3</span>，</span><br><span class="line">　　<span class="number">2.</span>如果程序中没有变量a，则创建他。</span><br><span class="line">　　<span class="number">3.</span>将变量与对象<span class="number">3</span>连接起来。</span><br></pre></td></tr></table></figure>
<ul>
<li>变量和对象保存在内存中的不同部分，变量只是对对象的引用，这样来说变量更像是C/C++中的<code>void*</code>指针
<ul>
<li><ol type="1">
<li>变量是系统表的元素，他指向对象存放的地址空间</li>
</ol></li>
<li><ol start="2" type="1">
<li>对象是分配的一块内存，地址可被连接，有足够大空间代表对象的值，每个对象都有两个标准头部信息:一是类型标识符（标识对象类型），二是引用计数器（垃圾回收）。</li>
</ol>
<ul>
<li>2.1 <strong>类型标识符</strong>：对象知道自己的类型，一旦与变量连接，程序执行中也就知道变量是引用了哪种类型的对象。</li>
<li>2.2 <strong>引用计数</strong>：每当对象被引用到一个变量是，其引用计数会+1，反之则-1，当引用计数为0是，该对象的内存空间被自动回收，这种性质很想C++的智能指针<code>shared_ptr</code>，意味着我们在使用过程中不需要考虑对象内存释放的问题.</li>
<li>2.3 引用的过程自动完成变量指向对象地址的过程，即从变量到对象的指针</li>
</ul></li>
</ul></li>
</ul>
<h5 id="共享引用">13.2. 共享引用</h5>
<ul>
<li><p>之前我们就提到过，在python中对象是不可变性的，一旦发生改变便意味这新对象的产生。共享引用也是如此： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span>; <span class="comment">#a指向对象，对象值为3，对象引用为1</span></span><br><span class="line">b=a; <span class="comment">#b也指向该对象，对象引用为2</span></span><br><span class="line">b=b+<span class="number">2</span>; <span class="comment">#产生新对象5，引用计数为1，a所引用的对象仍为3，引用计数为1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>但有一些对象和操作也确实会在原处修改对象，如列表、字典以及一些通过<code>class</code>语句定义的对象，对列表的一个位置进行赋值会改变这个列表对象，而不是生成一个新列表（想想也是，如果每次都有生成一个新列表，那么对于数量极大的列表来说，其消耗的时间是极大的）,如果不想这样，使用<code>copy</code>函数进行拷贝成一个新对象，指向内容相同但内存不同 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同上面一样创建了新对象42，没有影响原对象</span></span><br><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">L1=L2;</span><br><span class="line">L2=<span class="number">42</span>;</span><br><span class="line"><span class="comment">#原处修改,L1和L2均变为[42,2,3]</span></span><br><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">L1=L2;</span><br><span class="line">L1[<span class="number">0</span>]=<span class="number">42</span>;</span><br><span class="line"><span class="comment">#copy函数防止原处修改，</span></span><br><span class="line"><span class="keyword">import</span> copy;</span><br><span class="line">L2=copy.copy(L1);</span><br></pre></td></tr></table></figure></p></li>
<li><p>共享引用和相等：<code>==操作符</code>，测试两个引用对象值是否相同；<code>is操作符</code>,检查对象的同一性，是否内存地址一样</p></li>
</ul>
<h5 id="引用和拷贝">13.3.引用和拷贝</h5>
<p>到这里，应该知道了引用和拷贝的区别：</p>
<ul>
<li>引用是指变量名指向对象，多个引用都是指向同意内存地址</li>
<li>而拷贝是对原对象的一份拷贝，会在PVM中开辟一份自己的内存地址存储</li>
</ul>
<p>在python中赋值操作总是存储对象的引用，而不是拷贝。如果有些时候我们不希望因多个对象的引用中的改变而造成影响（如上面所举列表例子），那么就应该用拷贝：</p>
<ul>
<li>没有限制条件的分片语句会产生一份拷贝</li>
<li><code>copy</code>方法产生一份拷贝</li>
<li>一些内置函数，如<code>list(L)</code>产生一份拷贝</li>
</ul>
<h4 id="python语句">14. python语句</h4>
<h5 id="与cc完全不同点">14.1 与C/C++完全不同点</h5>
<ul>
<li>python中所有的嵌套语句的首行以<code>:</code>结尾</li>
<li>python中不像C/C++,可省略嵌套语句的<code>()</code>，如<code>if x&gt;y:</code>,如果单条if，则必须加<code>()</code></li>
<li>每个语句最后的<code>;</code>不是必须的，可省略，但是当一行有多条语句用<code>;</code></li>
<li>缩进的结束就是代码块的结束，python没有用<code>&#123;&#125;</code>来标识代码块，而是看缩进</li>
</ul>
<h5 id="赋值和打印">14.2 赋值和打印</h5>
<h6 id="赋值">14.2.1 赋值</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;trluper&quot;</span></span><br><span class="line"><span class="built_in">str</span>,s=<span class="string">&quot;trl&quot;</span>,<span class="string">&quot;uper&quot;</span></span><br><span class="line">a,b,c,d=<span class="string">&#x27;trlu&quot;	#a=&#x27;</span>t<span class="string">&#x27;,b=&#x27;</span><span class="string">r&#x27;,c=&#x27;</span>l<span class="string">&#x27;,d=&#x27;</span><span class="string">u&#x27;</span></span><br><span class="line"><span class="string">a,*b=&quot;trluper&quot; #a=&#x27;</span>t<span class="string">&#x27; b=[&#x27;</span><span class="string">r&#x27;,&#x27;</span>l<span class="string">&#x27;,&#x27;</span><span class="string">u&#x27;,&#x27;</span>p<span class="string">&#x27;,&#x27;</span>e<span class="string">&#x27;,&#x27;</span><span class="string">r&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>在上面的表达式可以看到，<code>*b</code>并不是C/C++中的指针，而是告诉赋值表达式变量<code>b</code>匹配剩下的内容成列表</p>
<h6 id="打印">14.2.2 打印</h6>
<p>python中<code>print</code>的语法:<code>print([object,...][,sep=' '][,end='\n'][,file=sys.stdout]);</code>在表示中，方括号的的项是可选的，且这些参数跟在要打印的对象后面，以<code>name=value</code>形式出现。</p>
<ul>
<li><code>object</code>指要打印的对象</li>
<li><code>sep</code>表示没打印一个对象，都有输出一个空格。(没有显式传递，则默认` `)</li>
<li><code>end</code>表示在打印末尾输出换行符（没有传递就默认<code>\n</code>）</li>
<li><code>file</code>表示要将这些对象输出给文件、标准流还是其他文件对象。(没有显示说明，则默认<code>sys.stdout</code>)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log=<span class="built_in">open</span>(<span class="string">r&#x27;D:\Python_WorkSpace\test.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;唱&quot;</span>,<span class="string">&quot;跳&quot;</span>,<span class="string">&quot;rap&quot;</span>,<span class="string">&quot;篮球&quot;</span>,sep=<span class="string">&#x27;*&#x27;</span>,end=<span class="string">&#x27;\n&#x27;</span>,file=log);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="python的布尔值">14.3 python的布尔值</h5>
<p>对于python的<code>bool</code>类型来说，其<code>true</code>和<code>false</code>的判断：</p>
<table>
<thead>
<tr class="header">
<th>情况</th>
<th>True/False</th>
<th>情况</th>
<th>True/False</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>none</code></td>
<td><code>F</code></td>
<td>空<code>map&#123;&#125;</code></td>
<td><code>F</code></td>
</tr>
<tr class="even">
<td>数值<code>0</code></td>
<td><code>F</code></td>
<td><code>False</code></td>
<td><code>F</code></td>
</tr>
<tr class="odd">
<td>空序列</td>
<td><code>F</code></td>
<td>对象为空</td>
<td><code>F</code></td>
</tr>
</tbody>
</table>
<h5 id="判断循环语句">14.4 判断循环语句</h5>
<h6 id="ifelifelse">14.4.1 if/elif/else</h6>
<p>python中没有C/C++中的<code>switch case</code>语句块，要做判断选择只有用<code>if</code>语句,在python中没有<code>&#123;&#125;</code>作为语句块边界标识，只能靠左侧的缩进来判断语句属于哪一部分:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a==b <span class="keyword">and</span> c==d <span class="keyword">and</span> d==e):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;相等&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> c==d <span class="keyword">and</span> d==e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;cde相等&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;不相等“)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#三目运算</span></span><br><span class="line"><span class="string">A=Y if X else Z;	#X为真时A=Y,false时为A=Z</span></span><br></pre></td></tr></table></figure>
<h6 id="while语句">14.4.2 while语句</h6>
<p><code>while</code>语句书写格式时：首行以及测试表达式，内部有一行或多行缩进语句主题执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">0</span>;b=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> a&lt;b:</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">    a+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;a不小于b&quot;</span>)</span><br></pre></td></tr></table></figure>
<h6 id="for语句">14.4.3 for语句</h6>
<p><code>for</code>循环不同与c/c++，在python中，它通常是用作序列迭代器，可以遍历任何有序的序列对象内的元素，可用于字符串、列表、元组、其他内置可迭代对象； <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;target&gt; <span class="keyword">in</span> &lt;<span class="built_in">object</span>&gt;:</span><br><span class="line">	&lt;Options&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	&lt;Options&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 当运行<code>for</code>循环时,PVM会将序列对象中的元素赋值給<code>target</code>,然后在循环主题中对其进行操作。<code>for</code>循环的循环变量<code>target</code>可以是任何赋值目标(反正执行完一次后就会重新赋值，引用)。因此<code>for</code>对序列的任意嵌套都能解包。</p>
<h5 id="其他循环">14.5 其他循环</h5>
<h6 id="range函数跳遍历">14.5.1 range函数跳遍历</h6>
<p><code>range函数</code>常用在<code>for循环</code>中用来产生索引，但也可以用在任何需要整数列表的地方。<code>range</code>是一个跌代器，会根据需要产生元素： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">5</span>);	<span class="comment">#生成0，1，2，3，4</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>,<span class="number">5</span>);	<span class="comment">#生成2，3，4</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>); <span class="comment">#生成0，2，4，6，8</span></span><br><span class="line"><span class="comment">#应用,遍历X跳一个输出,其实就是相当与while循环，条件+2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(X),<span class="number">2</span>):</span><br><span class="line">	<span class="built_in">print</span>(X[i],end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure> 根据上面的解释可知：</p>
<ul>
<li>传一个参数时，会产生从0算起的整数，不包括参数值</li>
<li>传两个参数时，第一个为起始值，第二个为最大不包括值</li>
<li>传三个参数时，第三个为步进值</li>
</ul>
<h6 id="并行遍历zip和map">14.5.2 并行遍历zip和map</h6>
<p><strong><code>zip</code>函数</strong>：传而对于<code>zip()</code>，原型是<code>zip(*list)</code>，<code>list</code>是一个列表，<code>zip(*list)</code>返回的是一个元组串，如果要转为元组列表，必须使用<code>list()</code>函数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">L2=[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">L3=<span class="built_in">zip</span>(L1,L2);	<span class="comment">#L3=(1,5),(2,6),(3,7),(4,8)</span></span><br><span class="line">L4=<span class="built_in">list</span>(<span class="built_in">zip</span>(L1,L2)) <span class="comment">#L4=[(1,5),(2,6),(3,7),(4,8)]</span></span><br><span class="line"><span class="comment">#并行遍历</span></span><br><span class="line"><span class="keyword">for</span> (x,y) <span class="keyword">in</span> L3:</span><br><span class="line">	<span class="built_in">print</span>(x,y,<span class="string">&quot;x+y=&quot;</span>,x+y);</span><br><span class="line">a2,b2=<span class="built_in">zip</span>(*<span class="built_in">zip</span>(L1,L2))  <span class="comment">#a2=(1,2,3,4) b2=(5,6,7,8)</span></span><br></pre></td></tr></table></figure> 事实上，<code>zip()</code>可以接受任何类型的序列（就是任何可迭代对象）。</p>
<p><strong><code>map函数</code>:</strong> 对于map()它的原型是<code>map(function,sequence)</code>，就是对序列sequence中每个元素都执行函数function操作.比如之前的<code>a,b,c = map(int,raw_input().split())</code>，意思就是说把输入的<code>a，b，c</code>转化为整数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="built_in">ord</span>,<span class="string">&#x27;spam&#x27;</span>);	<span class="comment">#ord为ascii转换为数字，结果为115，112，97，109</span></span><br></pre></td></tr></table></figure></p>
<h6 id="filter和reduce">14.5.3 filter和reduce</h6>
<p><code>filter</code>和<code>reduce</code>都会返回可迭代对象。在python3.0,需要用<code>list</code>调用来显示其所有结果。<code>filter</code>的作用是基于某一函数的过滤器。<code>reduce</code>是没对元素都应用函数得到最后结果 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>((<span class="keyword">lambda</span> x:x&gt;<span class="number">0</span>),<span class="built_in">range</span>(-<span class="number">5</span>,<span class="number">5</span>)));	<span class="comment">#[1,2,3,4]</span></span><br><span class="line">reduce((<span class="keyword">lambda</span> x,y:x+y),[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);			<span class="comment">#10</span></span><br></pre></td></tr></table></figure></p>
<h4 id="迭代器和解析">15. 迭代器和解析</h4>
<p>在上面提到的for循环和while循环能够处理重复性任务，但是序列迭代在程序中非常常见，因此python提供了额外工具来使得这项工作变得简单高效。</p>
<h5 id="文件迭代器">15.1. 文件迭代器</h5>
<h6 id="next__">15.1.1 <code>__next()__</code></h6>
<p>在文件类中，有一个方法<code>__next__()</code>,该方法每次调用时，就会返回文件的下一行，到达文件末尾时，会抛出StopIteration异常，而不是空字符串。像这样的接口就是python中所说的<strong><em>迭代协议</em></strong>.事实上，任何这类对象都认为时可迭代的，因为它们也能以<code>for循环</code>或其他迭代工具遍历，<strong><em>因为所有迭代工具内部工作原理都是调用<code>__next__()</code>，并且捕捉StopIteration异常来确定何时离开</em></strong></p>
<p><strong><em>迭代协议：Python 迭代协议由<code>__iter__</code>方法与<code>__next__</code>方法构成，若对象具有<code>__iter__</code>方法，称该对象为“可迭代对象（iterable object）”。若对象具有<code>__next__</code>方法，称该对象为“迭代器（iterator）”。<code>__iter__</code>方法必须返回一个迭代器对象，<code>__next__</code>方法不断的返回下一元素，或者抛出StopIteration。<code>__next__</code>方法是 Python 迭代协议的核心.<code>__iter__</code>方法是迭代协议的辅助——将可迭代对象转换成迭代器</em></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		s=file.__next__();</span><br><span class="line">	<span class="keyword">except</span> StopIteration:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="built_in">print</span>(s,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="用for循环推荐">15.1.2 用for循环(推荐)</h6>
<p>读取文本文件的最佳方式就是根本不要去读，其代替的方法就是让for循环每轮自动调用<code>__next__()</code>从而前进到下一行： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>):</span><br><span class="line">	<span class="built_in">print</span>(line,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure> 不建议使用<code>readlines</code>函数，因为<code>readlines</code>时一次性把文件加载到内存，且运行速度不如<code>for循环</code>.</p>
<h6 id="手动迭代">15.1.3 手动迭代</h6>
<p>为了支持手动迭代，python提供了一内置函数<code>next()</code>，他会自动调用一个对象的<code>__next__()</code>函数。即调用<code>next(X)</code>等价于<code>X.__next__()</code>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s=<span class="built_in">next</span>(file);</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(s,end=<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure> 另一方面，再深一点看，当for循环开始时，通过iter内置函数获得一个迭代器，返回的迭代器对象含有需要的next或<code>__next__()</code>方法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it=<span class="built_in">iter</span>(file);	//获取迭代器</span><br><span class="line"><span class="built_in">print</span>(file <span class="keyword">is</span> it);</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s= it.__next__();</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(s,end=<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="字典迭代">15.2. 字典迭代</h5>
<h6 id="获取键值列表再由遍历列表遍历字典">15.2.1 获取键值列表，再由遍历列表遍历字典</h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D.keys():</span><br><span class="line">	<span class="built_in">print</span>(key,D[key]);</span><br></pre></td></tr></table></figure>
<h6 id="有字典的迭代器遍历">15.2.2 有字典的迭代器遍历</h6>
<p>字典有一个迭代器，在<strong><em>迭代的环境下（即for循环/while循环）</em></strong>会自动一次返回一个键，这样我们就不必生成键值序列来遍历： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it=<span class="built_in">iter</span>(D);	<span class="comment">#获得字典的迭代器</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">		<span class="comment">#s=it.__next__();</span></span><br><span class="line">        l=<span class="built_in">next</span>(it);</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(l,D[l]);</span><br><span class="line"></span><br></pre></td></tr></table></figure> 因此可简写for循环：（推荐） <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D:</span><br><span class="line">    <span class="built_in">print</span>(key,D[key]);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="其他迭代环境">15.3 其他迭代环境</h5>
<p>上面介绍的迭代环境是在<strong>for循环</strong>看的以及之前讲到过的<strong>列表解析</strong>也有迭代协议。其实，<strong><code>in成员测试</code>、<code>map</code>内置函数以及像<code>sorted</code>（调用后会返回排序后的列表对象）和<code>zip</code>调用这样的内置函数也使用了迭代协议</strong>。<strong><em>当应用于文件时，文件对象的迭代器都自动扫描：</em></strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>.upper,<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>))); <span class="comment">#[&quot;ADC&quot;,&quot;DADA&quot;,&quot;SSDA&quot;]</span></span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>));				<span class="comment">#[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<h4 id="函数">16. 函数</h4>
<p>作为一位C/C++、java程序员，需要了解python函数体系下的函数相关语句和表达式,因为它们有很大的不同点:</p>
<ul>
<li><code>def</code>是可执行代码，python的函数由<code>def</code>语句编写，<strong>函数只有当<code>def</code>运行后才存在，这就意味着不能在函数未运行时就去调用</strong>。</li>
<li><code>def</code>创建了一个对象并将其赋值给某一个变量，即函数名只是函数对象的引用。</li>
<li><code>lambda</code>创建一个对象但将其作为结果返回。使用<code>lambada</code>表达式创建函数，运行将函数定义内联到语法上一条<code>def</code>语句不能工作的地方。</li>
<li><code>yield</code>向调用者发回结果对象，<strong>但会记住它离开的地方</strong></li>
<li><code>global</code>声明了一个模块的变量并被赋值。默认情况下所有在一个函数总被赋值的对象，仅在函数作用域中有效。如要使得它在整个模块中都可使用，函数需要<code>global</code>语句声明</li>
<li><code>nonlocal</code>声明了将要赋值的一个封闭函数变量</li>
</ul>
<h5 id="def">16.1 def</h5>
<p><code>def</code>语句将创建一个函数对象并将其赋值给一个变量名，格式如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;name&gt;(arg1,arg2,arg3,...):</span><br><span class="line">	functions-body;</span><br><span class="line"></span><br></pre></td></tr></table></figure> python中所有语句都是实时运行的，没有像独立编译时间这样的流程。<strong><em>python函数在程序运行之前并不需要全部定义，因为<code>def</code>在运行时评估，而<code>def</code>里面的函数体调用时才评估（与C/C++不同) </em></strong>。一个<code>def</code>语句可以出现在任何地方，比如<code>if</code>,<code>while</code>甚至是<code>def</code>嵌套也是合法的： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> test:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_func</span>():</span><br><span class="line">		....</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_func1</span>():</span><br><span class="line">		....</span><br><span class="line"></span><br><span class="line"><span class="comment">#嵌套</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">	x=<span class="number">99</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">		<span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">			<span class="built_in">print</span>(x);</span><br><span class="line">		f3();	<span class="comment">#调用</span></span><br><span class="line">	f2();		<span class="comment">#调用</span></span><br><span class="line"></span><br><span class="line">f1();</span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：当我<code>def</code>嵌套时，必须在上一层函数调用嵌套函数</p>
<h5 id="python中的多态">16.2 python中的多态</h5>
<p>对于python中函数的作用，会根据传入参数的不同而有些许不同： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">times</span>(<span class="params">x,y</span>):</span><br><span class="line">	<span class="keyword">return</span> x*y;</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">times(<span class="number">2</span>,<span class="number">4</span>);	<span class="comment">#return 8</span></span><br><span class="line">times(<span class="string">&quot;tr&quot;</span>,<span class="number">4</span>);	<span class="comment">#return trtrtrtr</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 可以看到<code>times</code>实现的功能的意义完全依赖于参数<code>x</code>和<code>y</code>的类型，<strong><em>这种依赖类型的行为称为多态</em></strong>。可以说python的动态类型是实现python多态的前提条件。在python这种多头机制下，<strong>编写函数接口更多是为对象编写，而不是特定为一个类型</strong>，这样可以达到函数的复用，提升代码简易和高效性。</p>
<h5 id="作用域">16.3 作用域</h5>
<p>在代码编写过程中，变量可以在三个不同地方辅助，其对应的作用域：</p>
<ul>
<li>变量在一个<code>def</code>赋值，其作用域只在该函数有效</li>
<li>变量在<code>def</code>之外赋值，从赋值地方开始到文件结尾都有效</li>
<li>变量在嵌套<code>def</code>内，只在内层<code>def</code>内有效</li>
</ul>
<h6 id="作用域法则">16.3.1 作用域法则</h6>
<ol type="1">
<li>全局作用域的作用范围仅限单个文件。要是有其他模块的变量名，必须导入模块</li>
<li>导入模块的作用域是全局的</li>
<li>每次函数调用都创建一个新的本地作用域</li>
<li>在函数赋值的变量名除非声明为<code>global</code>或者<code>nonlocal</code>变量，否则默认为本地变量。<code>global</code>将位于函数内的变量变为全局（位于模块文件内部的顶部），<code>nonlocal</code>将嵌套函数内的变量声明为非本地</li>
<li>python执行过程变量搜索路径：<code>本地作用域--&gt;上一层结构def或lambda的本地作用域--&gt;全局作用域--&gt;内置作用域</code></li>
</ol>
<h6 id="global">16.3.2 global</h6>
<p><code>global</code>不是一个类型或者大小的声明，而是<strong><em>命名空间的声明</em></strong>，它告诉编译器python函数打算生成一个或多个全局变量名 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用法1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_func</span>(<span class="params">x,y</span>):</span><br><span class="line">	<span class="keyword">global</span> z;</span><br><span class="line">	z=x+y;</span><br><span class="line">func(<span class="number">2</span>,<span class="number">4</span>)；</span><br><span class="line"><span class="built_in">print</span>(z);	<span class="comment">#输出6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用法2，告诉函数x不是本地的，而是全局的（主要用法：将在函数内修改的全局变量保存）</span></span><br><span class="line">x=<span class="number">22</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">   <span class="keyword">global</span> x;</span><br><span class="line">   x=<span class="number">99</span></span><br><span class="line">f1();</span><br><span class="line"><span class="built_in">print</span>(x);	<span class="comment">#输出99</span></span><br></pre></td></tr></table></figure></p>
<h6 id="nonlocal">16.3.3 nonlocal</h6>
<p>与<code>global</code>一样，<code>nonlocal</code>也是将变量在嵌套作用中的修改保存下来。与<code>global</code>不同之处在于：<code>global</code>是对<code>def</code>之外的全局变量作用，而<code>nonlocal</code>更严格，是对嵌套的的变量，这样达到能够使内层嵌套对变量的修改能够保存。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_func1</span>(<span class="params">a,<span class="built_in">str</span></span>):</span><br><span class="line">	x=a;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">_f</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">		<span class="keyword">nonlocal</span> x</span><br><span class="line">		x+=<span class="number">20</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">str</span>,x);	<span class="comment">#这是一个nonlocal测试 21</span></span><br><span class="line">	_f(<span class="built_in">str</span>);</span><br><span class="line">	<span class="built_in">print</span>(x);			<span class="comment">#21</span></span><br><span class="line"></span><br><span class="line">_func1(<span class="number">1</span>,<span class="string">&quot;这是一个nonlocal测试&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="参数">17. 参数</h4>
<h5 id="引用传递">17.1 引用传递</h5>
<p>要努力区别python的传参机制和C++引用参数，对于python来说：</p>
<ul>
<li><strong>不可变参数通过“值”传递，虽然像整数、字符串这些是通过对象的引用进行传递的，但是它们的不可变性导致我们不可能在原处改变，一旦执行给变量赋新值，意味这新对象产生，变量只是新对象的一份引用。</strong>（这样来看它的效果其实就是C++中的按值传递，即发生了一份拷贝）</li>
<li><strong>可变对象时通过“指针”进行传递的。虽然列表、字典这样的对象实际上也是通过引用来传递，但效果却和不可变参数完全不同，因为它们支持原处修改，因此函数内发生的改变能够保存。</strong>（这就像C++中传递数组很像）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">2</span>;</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x</span>):</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">isinstance</span>(x,<span class="built_in">list</span>):</span><br><span class="line">		x[<span class="number">0</span>]=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">	<span class="keyword">elif</span> <span class="built_in">isinstance</span>(x,numbers.Number):</span><br><span class="line">		x=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">test(a);</span><br><span class="line"><span class="built_in">print</span>(a);	<span class="comment">#2</span></span><br><span class="line">test(b);</span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#[20,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>python通过引用来传参，意味着我们不需要进行多余的拷贝操作，能够节约内存和运行时间，同时也就支持可传递很大对象。如果我们要抑制因传入可变参数而带来的修改，可以在传入时拷贝一份作为参数<code>test(copy(b));</code></p>
<h5 id="返回值">17.2 返回值</h5>
<p><code>return</code>语句能够返回任意种类对象，所有也能够返回多个值（指的是封装进元组或列表这样的集合里）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">	x=<span class="number">2</span>;</span><br><span class="line">	y=[<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">return</span> x,y;</span><br><span class="line"></span><br><span class="line">l=func();	<span class="comment">#(2,[3,4])</span></span><br></pre></td></tr></table></figure> 上面的函数返回了元组(2,[3,4])。（因为元组的<code>()</code>不是必须的）</p>
<h5 id="参数匹配模型">17.3 参数匹配模型</h5>
<p>这些匹配模型的底层传参机制仍有是引用赋值：</p>
<ul>
<li>位置参数：默认模式，通过从左到右参数匹配(位置：调用者)</li>
<li>关键字参数；设置传参默认值，<code>name=value</code>形式，意思是当我们执行从左到右匹配，发现某参数没有传入，则调用时使用默认值(位置：被调函数)</li>
<li>关键字参数：<code>name=value</code>还可以指定我们调用时参数传递给哪一个参数变量，破环了默认模式，即不必遵循从左到右匹配，而是按名字匹配,如<code>print(&quot;trluper&quot;,sep=' ',end=' ',file=sys,stdout);</code>（位置：调用者）</li>
<li>可变参数列表，在函数的参数中有<code>*</code>号，意味着该函数支持可变参数列表，即支持传递任意个参数。单个<code>*</code>指对元组，<code>**</code>是对字典,<strong>即指在调用的时候我们传递给函数的参数会被打包参数位置信息的元组序列或者字典对象</strong>，对函数来说它会解包</li>
</ul>
<p>示例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位置参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,c</span>):</span><br><span class="line">	<span class="built_in">print</span>(a,b,c);</span><br><span class="line"><span class="comment">#关键字参数name=value形式调用</span></span><br><span class="line">f(a=<span class="number">2</span>,c=<span class="number">3</span>,b=<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#关键字参数,设置默认值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">name=<span class="string">&#x27;Bob&#x27;</span>,age=<span class="string">&#x27;&#x27;</span>,jov=<span class="string">&#x27;engineer&#x27;</span></span>):</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line"><span class="comment">#*</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">*args</span>):</span><br><span class="line">	<span class="built_in">print</span>(args);</span><br><span class="line"><span class="comment">#调用时打包成元组</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)		<span class="comment">#(1,2,3,4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#**只对关键字参数有效，将关键字参数打包成字典</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">**args</span>):</span><br><span class="line">	<span class="built_in">print</span>(args);</span><br><span class="line">f(a=<span class="number">1</span>,b=<span class="number">2</span>);		<span class="comment">#&#123;&#x27;a&#x27;=1,&#x27;b&#x27;=2&#125;</span></span><br></pre></td></tr></table></figure> <strong><em>注意</em></strong>：如要函数要混用这些模式，则顺序必须是<code>位置参数-&gt;关键字参数-&gt;*-&gt;**</code></p>
<h4 id="函数的高级话题">18. 函数的高级话题</h4>
<p>学习了函数，我们就必须要了解如何使函数聚合性更强，解耦合性能更好，设计函数的功能性。</p>
<h5 id="递归函数">18.1 递归函数</h5>
<p>较循环结构而言，对任意深度的嵌套，循环较难处理，而递归能够容易处理该类嵌套： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#能够处理任意嵌套</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L:<span class="string">&quot;可以是列表也可是元组&quot;</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">		<span class="keyword">if</span>  <span class="built_in">isinstance</span>(x,<span class="built_in">list</span>):</span><br><span class="line">			tot+=sumtree(x);</span><br><span class="line">		<span class="keyword">elif</span>  <span class="built_in">isinstance</span>(x,<span class="type">Tuple</span>):</span><br><span class="line">			tot+=sumtree(x);</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			tot+=x;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sumtree([<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],(<span class="number">3</span>,<span class="number">4</span>),<span class="number">5</span>,[<span class="number">7</span>,<span class="number">8</span>,[<span class="number">2</span>,<span class="number">3</span>]]])); <span class="comment">#38</span></span><br></pre></td></tr></table></figure></p>
<h5 id="属性存储和注解">18.2 属性存储和注解</h5>
<p>由于python函数是对象，函数对象可以赋值给其他的变量名、传递给其他函数、嵌入到数据结构、从一个函数返回给另一个函数等等。</p>
<h6 id="属性">18.2.1 属性</h6>
<p>函数除了调用以外，我们还可以检查它的<strong>属性</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sumtree.__name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(sumtree));</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sumtree</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__call__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__closure__&#x27;</span>, <span class="string">&#x27;__code__&#x27;</span>, <span class="string">&#x27;__defaults__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__get__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__globals__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__kwdefaults__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<h6 id="注解">18.2.2 注解</h6>
<p>python3.0以后，可以给函数对象附加注解信息---就是与函数的参数和结果相关的任意用户定义的数据。注解有它专有的语法，但它自身不做任何事情，注解是可选的，并且出现的时候只是直接附加在函数对象的<code>__annotations__</code>属性以供其他用户使用。语法：</p>
<ul>
<li>函数注解编写在def行</li>
<li>对于参数，它们出现在紧随参数名冒号的后面</li>
<li>对于返回值，它们编写于参数列表之后的<code>-&gt;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L:<span class="string">&quot;可以是列表也可是元组&quot;</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sumtree.__annotations__);	<span class="comment">#&#123;&#x27;L&#x27;: &#x27;可以是列表也可是元组&#x27;, &#x27;return&#x27;: &lt;class &#x27;int&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="lambda表达式">18.3. lambda表达式</h5>
<p>除了<code>def</code>之外，python提供了另一种函数对象的表达式，叫<code>lambada</code>也称匿名函数。这个表达式创建了一个之后能够调用的函数，但是它返回一个函数而不是将这个函数赋值给一个变量名，这也是为啥lambda叫匿名函数。</p>
<h6 id="lambda表达式格式">18.3.1 lambda表达式格式</h6>
<p>关键字lambda后面接参数列表，<code>:</code>后面为函数体 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arg1,rag2,...:</span><br><span class="line">	function_body;</span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong></p>
<ul>
<li>lambda是一个表达式，而不是语句。因为是一个表达式，所有它能出现在<code>def</code>不能出现的地方，如列表中、或者函数参数中等。同时它会返回一个新函数对象，我们可以选择性的将对象赋值给一个变量，方便操作。</li>
<li>lambda的主体是一个单个的表达式，而不是一个代码块。因为lambda是为编写简单函数而设计的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">min_test</span>(<span class="params">L,cmp=<span class="keyword">lambda</span> x,y:x&gt;y</span>):</span><br><span class="line">	a=L[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> e <span class="keyword">in</span> L[<span class="number">1</span>:]:</span><br><span class="line">		<span class="keyword">if</span> cmp(a,e):</span><br><span class="line">			a=e;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">min_test([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>])		<span class="comment">#0</span></span><br></pre></td></tr></table></figure>
<h4 id="深入理解迭代和解析">19深入理解迭代和解析</h4>
<h5 id="重访迭代器生成器">19.1 重访迭代器：生成器</h5>
<p>python对延迟提供了更多的支持，有两种方法尽可能延迟结果创建：</p>
<ul>
<li><strong>生成器函数</strong>：编写为常规的<code>def</code>，但是使用<code>yield</code>一次返回一个结果，在每个结果之间挂起和继续它们的状态</li>
<li><strong>生成器表达式</strong>：类似于列表解析，但是它们的返回是按需产生结果对象，而不是像列表解析一样构建一新列表</li>
</ul>
<p>由于二者都不会创建列表，因此节省了内存空间，并且允许计算时间分散到各个结果请求。</p>
<h6 id="生成器函数">19.1.1 生成器函数</h6>
<p><strong>一个送回一个值并随后从退出的地方继续的函数就叫生成器函数</strong>。<strong><em>生成器函数</em></strong>与常规函数的不同点主要在于：</p>
<ul>
<li>生成器函数自动在生成值的时刻挂起，在挂起时要保存函数的状态。</li>
<li>生成器函数代码不同是生成器<code>yield</code>一个值，而不是<code>return</code>，从该角度来看，允许生成器函数随时间产生一系列值</li>
</ul>
<p><strong>1 迭代协议</strong></p>
<p>要理解生成器，必须了解<strong>迭代协议</strong>。可迭代的对象定义了一个<code>__next__</code>方法，要么返回迭代中的下一项，要么抛出<code>StopIteration</code>异常终止迭代。一个对象的迭代器用<code>iter</code>内置函数接受。如果支持该协议，则<code>for</code>循环和其他迭代语句，使用这种迭代协议来遍历一个序列或者生成器；若不支持，迭代返回去重复序列。</p>
<p><strong>2 生成器：</strong></p>
<p>生成器函数要支持该协议，就必须得包含一条<code>yiled</code>语句，该语句被编译为生成器，一旦调用这条语句就会返回一个迭代对象，该对象支持用一个<code>__next__()</code>函数来继续执行该生成器函数接口。要终止生成器函数，可以在生成器函数末尾有一条<code>return</code>语句，终止生成，也可以引发一个<code>StopIteration</code>异常终止。<strong><em>简而言之，编写了包含<code>yiled</code>的函数称为生成器函数，<code>yield</code>语句为生成器，自动的支持迭代协议</em></strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">L</span>):</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">		<span class="keyword">yield</span> i**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]));		<span class="comment">#&lt;generator object func at 0x000001FB7F4AB450&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]):	<span class="comment">#1，4，9，16</span></span><br><span class="line">	<span class="built_in">print</span>(i);</span><br></pre></td></tr></table></figure> 从上面程序可以看到，调用一个生成器函数会返回一个生成器对象，它支持迭代协议，即生成器对象有一个<code>__next__()</code>方法，它可以开始这个函数，或者从它上一次<code>yield</code>值后的地方恢复，并且得到一系列的值，到最后一个时，产生<code>StopIteration</code>异常。</p>
<p><strong>3 扩展生成器函数协议send和next</strong></p>
<p>生成器函数协议增加了一个<code>send()</code>函数，<code>send()</code>函数生成一系列结果的下一个元素，这一点像<code>__next__()</code>,但是它提供了一种调用者与生成器之间的通信。当使用这一额外协议时，值可以通过调用<code>G.send(value)</code>发生给一个生成器 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g=func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="literal">None</span>));</span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<h6 id="生成器表达式">19.1.2 生成器表达式</h6>
<p>生成器表达式其实跟列表解析相似，区别就是列表解析是在<code>[]</code>内，而生成器表达式是在<code>()</code>内： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列表解析</span></span><br><span class="line">[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]; <span class="comment">#[0,1,4,9]</span></span><br><span class="line"><span class="comment">#生成器表达式</span></span><br><span class="line">G=(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))	<span class="comment">#generator</span></span><br><span class="line">G.__next__();</span><br><span class="line"><span class="comment">#for循环自动迭代</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span>(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)):</span><br><span class="line">	<span class="built_in">print</span>(num);</span><br></pre></td></tr></table></figure> 从上面可知道，生成器表达式很不同，不是在内存种构建结果，而是返回一个生成器对象，这个对象将会支持迭代协议并在任意迭代语境的操作。</p>
<p><strong>1 生成器是单迭代对象</strong></p>
<p>无论是生成器函数还是生成器表达式，都只支持一次活跃迭代，即不能在不同位置的有自己的迭代器： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">G=(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">iter_1=<span class="built_in">iter</span>(G);</span><br><span class="line">iter_1.__next__();		<span class="comment">#0</span></span><br><span class="line">iter_2=<span class="built_in">iter</span>(G);</span><br><span class="line">iter_2.__next_();		<span class="comment">#1</span></span><br></pre></td></tr></table></figure> 如上，两个迭代器总是在同一位置，即只能有一个活跃的迭代器</p>
<p><strong>2. 编写自己的map和zip</strong></p>
<p><strong>mymap</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mymap</span>(<span class="params">func,*seqs</span>):</span><br><span class="line">	<span class="keyword">return</span> [func(*args) <span class="keyword">for</span> args <span class="keyword">in</span> <span class="built_in">zip</span>(*seqs)]</span><br><span class="line"><span class="built_in">print</span>(mymap(<span class="built_in">pow</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)));</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">16</span>, <span class="number">243</span>, <span class="number">4096</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>myzip</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myzip</span>(<span class="params">func,*seqs</span>):</span><br><span class="line">	seqs=[<span class="built_in">list</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> seqs];</span><br><span class="line">	res=[];</span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">all</span>(seqs):</span><br><span class="line">		res.append(<span class="built_in">tuple</span>(s.pop(<span class="number">0</span>)<span class="keyword">for</span> s <span class="keyword">in</span> seqs));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="解析语法概况">19.2. 解析语法概况</h5>
<p>除了列表解析以外，python3.0还增加了集合解析和字典解析： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列表解析</span></span><br><span class="line">[f(x) <span class="keyword">for</span> x <span class="keyword">in</span> S]</span><br><span class="line"><span class="comment">#集合解析</span></span><br><span class="line">&#123;f(x) <span class="keyword">for</span> x <span class="keyword">in</span> S&#125;</span><br><span class="line"><span class="comment">#字典解析</span></span><br><span class="line">&#123;key:val <span class="keyword">for</span> (key,val) <span class="keyword">in</span> <span class="built_in">zip</span>(keys,vals)&#125;</span><br><span class="line"><span class="comment">#生成器表达式</span></span><br><span class="line">(x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br></pre></td></tr></table></figure></p>
<h4 id="模块">20. 模块</h4>
<p>模块是将程序代码和数据封装起来以方便重用，其实模块就相当于是一个命名空间。模块由两个语句和一个终于的内置函数进行处理：</p>
<ul>
<li><code>import</code>:让用户导入一个模块</li>
<li><code>from</code>:允许用户从以模块文件获取特定变量名</li>
<li><code>imp.reload</code>:在不终止python程序下，提供重新载入模块文件代码的方法.</li>
</ul>
<h5 id="import工作机制">20.1 import工作机制</h5>
<p>乍一看，我们都会认为python的<code>import</code>很像C/C++的<code>#include&lt;&gt;</code>，但是并不是完全一样，首先一点就是在导入时模块就已经运行了，即一旦<code>import a</code>模块，<code>a</code>模块里面的代码就会执行，如果<code>a</code>模块内有<code>print</code>语句的话就会输出。而<code>C</code>会在预处理阶段将头文件展开，同内部代码一样，执行<code>预处理编译--&gt;汇编--&gt;链接</code>过程</p>
<p><strong>import的三个过程：</strong></p>
<p><strong>1. 找到模块文件</strong></p>
<p>在执行钱必须找到模块文件所在的位置，导入是简单的<code>import a</code>，没有路径，也没有加后缀<code>.py</code>,因为python使用<strong>==标准模块搜索路径==</strong></p>
<p><strong>2. 编译成字节码（如果需要）</strong></p>
<p>python会检查模块文件的时间戳，当发现字节码即后缀为<code>.pyc</code>的文件比源代码<code>.py</code>旧，就会重新编译成<code>.pyc</code>文件，覆盖原字节码文件，反之，则不。若在搜索时只有<code>.pyc</code>文件，没有<code>.py</code>文件，直接加载<code>.pyc</code>文件。通过这些算法方式来提高程序启动速度。（<strong><em>注意</em></strong>：只有被导入的文件才会有<code>.pyc</code>文件） <strong><em>注意</em></strong>：因此多次在一个顶层模块导入模块，导入操作只会执行一次，因为已经生成了最新的<code>.pyc</code>文件</p>
<p><strong>3. 执行模块代码来创建其所定义的对象</strong></p>
<p>最后一步执行，不多说</p>
<h5 id="标准模块搜索路径">20.2.标准模块搜索路径</h5>
<p>大多数情况下，可以说依赖导入模块的搜索路径的自动特性，完全不要要配置路径。要配置你自己的路径，必须了解模块搜索路径的四个组件：</p>
<ul>
<li>程序主目录</li>
<li>pythonPATH(如果已经设置)</li>
<li>标准链接库目录</li>
<li>任何.pth文件内容</li>
</ul>
<p>这四个组件组合起来就变成了<code>sys.path</code>。第一个和第三个是自动定义，以及固定了，第二和第四个就可以用来扩展路径，从而包含你自己的外部源代码。</p>
<h5 id="import和from">20.3 import和from</h5>
<p>格式： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line"><span class="keyword">from</span> simple <span class="keyword">import</span> x,y</span><br><span class="line">x=<span class="number">42</span>;</span><br></pre></td></tr></table></figure> 在交互的模式下对<code>x</code>赋值运输,只会修改作用域内的变量x，而不是这个文件内的x，以from复制而来的变量名和其来源的文件之间没有联系，如果要修改，应该用<code>import</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line">simple.x=<span class="number">42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="命名空间">20.4 命名空间</h5>
<p>在模块的文件顶层（也就是不在函数或类的主体内）每一个赋值的变量名都会变成该模块的属性。我么们可以在模块外以<code>simple.x</code>对其属性进行引用。</p>
<h6 id="模块加载和作用域">20.4.1 模块加载和作用域</h6>
<ul>
<li><strong>模块语句会在首次导入时执行</strong>：模块第一次导入无论在什么地方，<strong>都会建立空的模块对象，并逐一执行模块文件内的语句</strong></li>
<li>顶层的赋值语句创建模块属性（如def,=)</li>
<li>模块的命名空间能够通过属性<code>__dict__</code>或<code>dir(simple)</code>获得</li>
<li>模块是一个独立的作用域（本地变量就是全局变量）：模板自己成立一个作用域，但是它的变量可看作全局变量，文件内都可使用</li>
</ul>
<h6 id="进行导入操作的文件的与被导入的文件的关系">20.4.2 进行导入操作的文件的与被导入的文件的关系</h6>
<p>导入操作不会赋予被导入文件种的代码对上层代码的可见度：即被导入文件无法看见进行导入操作的文件内的变量名 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#modeA.py</span></span><br><span class="line">x=<span class="number">88</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">	gloabal x;</span><br><span class="line">	x=<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#modeB.py</span></span><br><span class="line"><span class="keyword">import</span> modeA</span><br><span class="line">x=<span class="number">11</span>;</span><br><span class="line">modeA.f()</span><br><span class="line"><span class="built_in">print</span>(x,modeA.x);	<span class="comment">#11 99</span></span><br></pre></td></tr></table></figure> 总结来说：</p>
<ul>
<li>函数绝对无法看见其他函数内的变量名，除非它们是嵌套的</li>
<li>模块程序代码绝对无法看见其他模块的变量名，除非明确进行了变量导入</li>
</ul>
<h6 id="模块重载">20.4.3 模块重载</h6>
<p>我们之前提到，模块导入只会执行一次，要强制模块代码重新载入并执行，得要调用<code>reload</code>内置函数： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> simple</span><br><span class="line">reload(simple);		<span class="comment">#重载模块</span></span><br></pre></td></tr></table></figure> 重载模块有几个<strong><em>注意点：</em></strong></p>
<ul>
<li><code>reload</code>会在模块当前命名空间内执行模块文件的新代码</li>
<li>重载会影响所有使用import读取的模块属性</li>
<li>重载只会以后对以后使用from的造成影响</li>
</ul>
<h4 id="内置函数">21 内置函数</h4>
<p>python内部内置了丰富的函数供开发者调用，下面进行简单的介绍。</p>
<h5 id="数学函数">21.1 数学函数</h5>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>abs(x)</code></td>
<td>返回数字的绝对值，如<code>abs(-10)</code>返回 10</td>
</tr>
<tr class="even">
<td><code>ceil(x)</code></td>
<td>返回数字的上入整数，如<code>math.ceil(4.1)</code> 返回 5</td>
</tr>
<tr class="odd">
<td><code>cmp(x, y)</code></td>
<td>如果 <code>x &lt; y</code> 返回 -1, 如果 <code>x == y</code> 返回 0, 如果 <code>x &gt; y</code> 返回 1</td>
</tr>
<tr class="even">
<td><code>exp(x)</code></td>
<td>返回e的x次幂(ex),如<code>math.exp(1)</code> 返回2.718281828459045</td>
</tr>
<tr class="odd">
<td><code>fabs(x)</code></td>
<td>返回数字的绝对值，如<code>math.fabs(-10)</code> 返回10.0</td>
</tr>
<tr class="even">
<td><code>floor(x)</code></td>
<td>返回数字的下舍整数，如<code>math.floor(4.9)</code>返回 4</td>
</tr>
<tr class="odd">
<td><code>log(x)</code></td>
<td>如<code>math.log(math.e)</code>返回1.0,<code>math.log(100,10)</code>返回2.0</td>
</tr>
<tr class="even">
<td><code>log10(x)</code></td>
<td>返回以10为基数的x的对数，如<code>math.log10(100)</code>返回 2.0</td>
</tr>
<tr class="odd">
<td><code>max(x1, x2,...)</code></td>
<td>返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr class="even">
<td><code>min(x1, x2,...)</code></td>
<td>返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr class="odd">
<td><code>modf(x)</code></td>
<td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr class="even">
<td><code>pow(x, y)</code></td>
<td>x**y 运算后的值。</td>
</tr>
<tr class="odd">
<td><code>round(x [,n])</code></td>
<td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td>
</tr>
<tr class="even">
<td><code>sqrt(x)</code></td>
<td>返回数字x的平方根</td>
</tr>
</tbody>
</table>
<h5 id="内置函数-1">21.2 内置函数</h5>
<p>这里列举一些简单内置函数列表，不做例子解释：</p>
<table style="width:11%;">
<colgroup>
<col style="width: 5%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>abs()</code></td>
<td><code>abs()</code>函数返回数字的绝对值</td>
</tr>
<tr class="even">
<td><code>all()</code></td>
<td><code>all()</code>函数用于判断给定的可迭代参数<code>iterable</code>中的所有元素是否都为<code>TRUE</code>，如果是返回 <code>True</code>，否则返回<code>False</code>.元素除了<code>0、空、None、False</code>外都算 True</td>
</tr>
<tr class="odd">
<td><code>any()</code></td>
<td><code>any()</code>函数用于判断给定的可迭代参数<code>iterable</code>是否全部为<code>False</code>，则返回<code>False</code>，如果有一个为<code>True</code>，则返回<code>True</code>。元素除了是<code>0、空、FALSE 外都算 TRUE</code>。</td>
</tr>
<tr class="even">
<td><code>bin()</code></td>
<td><code>bin()</code>返回一个整数 <code>int</code> 或者长整数 <code>long int</code> 的二进制表示</td>
</tr>
<tr class="odd">
<td><code>bool()</code></td>
<td><code>bool()</code> 函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。</td>
</tr>
<tr class="even">
<td><code>bytearray()</code></td>
<td><code>bytearray()</code>方法返回一个新字节数组。这个数组里的元素是可变的，并且每个元素的值范围</td>
</tr>
<tr class="odd">
<td><code>callable()</code></td>
<td>函数用于检查一个对象是否是可调用的。如果返回<code>True</code>，<code>object</code>仍然可能调用失败；但如果返回<code>False</code>，调用对象<code>object</code>绝对不会成功。</td>
</tr>
<tr class="even">
<td><code>chr()</code></td>
<td><code>chr()</code>用一个范围在 <code>range（256）</code>内的（就是0～255）整数作参数，返回一个对应的字符</td>
</tr>
<tr class="odd">
<td><code>classmethod修饰符</code></td>
<td><code>classmethod</code> 修饰符对应的函数不需要实例化，不需要 <code>self</code> 参数，但第一个参数需要是表示自身类的 <code>cls</code> 参数，可以来调用类的属性，类的方法，实例化对象等。</td>
</tr>
<tr class="even">
<td><code>cmp()</code></td>
<td>cmp(x,y) 函数用于比较2个对象，如果 <code>x &lt; y</code> 返回 -1, 如果<code>x == y</code>返回 0, 如果 <code>x &gt; y</code>返回 1</td>
</tr>
<tr class="odd">
<td><code>delattr()</code></td>
<td>删除属性,<code>delattr(x, 'foobar')</code> 相等于 <code>del x.foobar</code></td>
</tr>
<tr class="even">
<td><code>dir()</code></td>
<td><code>dir()</code>函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表</td>
</tr>
<tr class="odd">
<td><code>divmod()</code></td>
<td>把除数和余数运算结果结合起来，返回一个包含商和余数的元组<code>(a / b, a % b)</code></td>
</tr>
<tr class="even">
<td><code>execfile()</code></td>
<td>函数可以用来执行一个文件</td>
</tr>
<tr class="odd">
<td><code>file()</code></td>
<td><code>file()</code>函数用于创建一个 file 对象，它有一个别名叫<code>open()</code>，更形象一些，它们是内置函数。参数是以字符串的形式传递的</td>
</tr>
<tr class="even">
<td><code>float()</code></td>
<td><code>float()</code>函数用于将整数和字符串转换成浮点数。</td>
</tr>
<tr class="odd">
<td><code>frozenset()</code></td>
<td>返回一个冻结的集合，冻结后集合不能再添加或删除任何元素，即不可变</td>
</tr>
<tr class="even">
<td><code>getattr()</code></td>
<td>返回一个对象的属性值</td>
</tr>
<tr class="odd">
<td><code>globals()</code></td>
<td><code>globals()</code>函数会以字典类型返回当前位置的全部全局变量</td>
</tr>
<tr class="even">
<td><code>hasattr()</code></td>
<td><code>hasattr()</code>函数用于判断对象是否包含对应的属性</td>
</tr>
<tr class="odd">
<td><code>hash()</code></td>
<td><code>hash()</code>用于获取取一个对象（字符串或者数值等）的哈希值</td>
</tr>
<tr class="even">
<td><code>help()</code></td>
<td><code>help()</code> 函数用于查看函数或模块用途的详细说明</td>
</tr>
<tr class="odd">
<td><code>hex()</code></td>
<td><code>hex()</code> 函数用于将10进制整数转换成16进制，以字符串形式表示</td>
</tr>
<tr class="even">
<td><code>id()</code></td>
<td><code>id()</code>函数返回对象的唯一标识符，标识符是一个整数</td>
</tr>
<tr class="odd">
<td><code>input()</code></td>
<td>标准输入流，接受一个标准输入数据，返回为 string 类型</td>
</tr>
<tr class="even">
<td><code>int()</code></td>
<td>将一个字符串或数字转换为整型</td>
</tr>
<tr class="odd">
<td><code>iter()</code></td>
<td><code>iter()</code>函数用来生成迭代器</td>
</tr>
<tr class="even">
<td><code>len</code></td>
<td><code>len()</code>方法返回对象（字符、列表、元组等）长度或项目个数</td>
</tr>
<tr class="odd">
<td><code>locals()</code></td>
<td><code>locals()</code>函数会以字典类型返回当前位置的全部局部变量</td>
</tr>
<tr class="even">
<td><code>next()</code></td>
<td><code>next()</code>返回迭代器的下一个项目,该函数于<code>iter()</code>配套使用</td>
</tr>
<tr class="odd">
<td><code>open()</code></td>
<td><code>open()</code>函数用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 <code>OSError</code></td>
</tr>
<tr class="even">
<td><code>ord()</code></td>
<td>该函数是<code>chr()</code>函数（对于 8 位的 ASCII 字符串）的配对函数，它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。</td>
</tr>
<tr class="odd">
<td><code>pow(x,y)</code></td>
<td>指数计算，返回<span class="math display">\[$x^y\]</span>$</td>
</tr>
<tr class="even">
<td><code>round()</code></td>
<td>返回浮点数 x 的四舍五入值，准确的说保留值将保留到离上一位更近的一端（四舍六入）</td>
</tr>
<tr class="odd">
<td><code>sorted()</code></td>
<td>对所有可迭代的对象进行排序操作</td>
</tr>
<tr class="even">
<td><code>str()</code></td>
<td>返回一个对象的<code>string</code>格式,将对象转化为适于人阅读的形式</td>
</tr>
</tbody>
</table>
<h6 id="compile函数">21.2.1 compile()函数</h6>
<p>compile() 函数将一个字符串编译为字节代码，格式如下: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compile</span>(source, filename, mode[, flags[, dont_inherit]])</span><br></pre></td></tr></table></figure> - <code>source</code>：字符串或者AST（Abstract Syntax Trees）对象。。 - <code>filename</code>：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。 - <code>mode</code> ：指定编译代码的种类。可以指定为 exec, eval, single。 - <code>flags</code> ：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。。 - <code>flags和dont_inherit</code>是用来控制编译源码时的标志</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">str</span> = <span class="string">&quot;for i in range(0,10): print(i)&quot;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">compile</span>(<span class="built_in">str</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;exec&#x27;</span>)   <span class="comment"># 编译为字节代码对象 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;code <span class="built_in">object</span> &lt;module&gt; at <span class="number">0x10141e0b0</span>, file <span class="string">&quot;&quot;</span>, line <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">exec</span>(c)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h6 id="complex函数">21.2.2 complex()函数</h6>
<p><code>complex()</code>函数用于创建一个值为<code>real + imag * j</code>的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span>(<span class="number">1</span>)    <span class="comment"># 数字，结果为(1 + 0j)</span></span><br><span class="line"><span class="built_in">complex</span>(<span class="string">&quot;1&quot;</span>)  <span class="comment"># 当做字符串处理，结果为(1 + 0j)</span></span><br></pre></td></tr></table></figure></p>
<h6 id="dict函数">21.2.3 dict()函数</h6>
<p>dict() 函数用于创建一个字典。有四种接口来创建字典 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>()                        # 创建空字典</span><br><span class="line"><span class="built_in">dict</span>(a=<span class="string">&#x27;a&#x27;</span>, b=<span class="string">&#x27;b&#x27;</span>, t=<span class="string">&#x27;t&#x27;</span>)     # 传入关键字</span><br><span class="line"><span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))   # 映射函数方式来构造字典</span><br><span class="line"><span class="built_in">dict</span>([(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])    # 可迭代对象方式来构造字典</span><br></pre></td></tr></table></figure></p>
<h6 id="enumerate函数">21.2.4 enumerate()函数</h6>
<p><code>enumerate()</code>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#形式</span></span><br><span class="line"><span class="built_in">enumerate</span>(sequence, [start=<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line">seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons))   <span class="comment">#[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>))       <span class="comment"># 小标从 1 开始[(1, &#x27;Spring&#x27;), (2, &#x27;Summer&#x27;), (3, &#x27;Fall&#x27;), (4, &#x27;Winter&#x27;)]</span></span><br></pre></td></tr></table></figure></p>
<h6 id="eval函数">21.2.5 eval()函数</h6>
<p><code>eval()</code>函数用来执行一个字符串表达式，并返回表达式的值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line"><span class="built_in">eval</span>( <span class="string">&#x27;3 * x&#x27;</span> )		#<span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<h6 id="filter函数">21.2.6 filter()函数</h6>
<p><code>filter()</code>函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。<strong>接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 <code>True</code> 或 <code>False</code>，最后将返回 <code>True</code> 的元素放到新列表中。</strong></p>
<blockquote>
<p>注意: Python2.7 返回列表，Python3.x 返回迭代器对象，具体内容可以查看：Python3 filter() 函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="function">    return n % <span class="number">2</span> =</span>= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">newlist = <span class="built_in">filter</span>(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(newlist) #[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h6 id="format-格式化函数">21.2.7 format 格式化函数</h6>
<p>Python2.6 开始，新增了一种格式化字符串的函数<code>str.format()</code>，它增强了字符串格式化的功能。基本语法是通过<code>&#123;&#125;</code>和<code>:</code>来代替以前的 <code>%</code>。<code>format</code> 函数可以接受不限个参数，位置可以不按顺序 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.format(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    # 不设置指定位置，按默认顺序</span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.format(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  # 设置指定位置</span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.format(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  # 设置指定位置</span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h6 id="isinstance函数">21.2.8 isinstance()函数</h6>
<p><code>isinstance()</code>判断一个对象是否是一个已知的类型，类似<code>type()</code>。<code>isinstance()</code> 与 <code>type()</code> 区别：</p>
<ul>
<li><code>type()</code>不会认为子类是一种父类类型，不考虑继承关系。</li>
<li><code>isinstance()</code>会认为子类是一种父类类型，考虑继承关系。</li>
<li>因此如果要判断两个类型是否相同推荐使用 <code>isinstance()</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#语法</span><br><span class="line"><span class="built_in">isinstance</span>(object, classinfo)</span><br><span class="line">#举例</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">isinstance</span> (a,<span class="type">int</span>)			#True</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="issubclass函数">21.2.9 issubclass()函数</h6>
<p>方法用于判断参数 <code>class</code> 是否是类型参数 <code>classinfo</code> 的子类: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">issubclass</span>(<span class="keyword">class</span>, classinfo)</span><br></pre></td></tr></table></figure></p>
<h6 id="list函数">21.2.10 list()函数</h6>
<p><code>list()</code>方法用于将元组或字符串转换为列表。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aTuple = (<span class="number">123</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>)</span><br><span class="line">list1 = <span class="built_in">list</span>(aTuple)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line">list2=<span class="built_in">list</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure> <em>注：元组与列表是非常类似的，区别在于元组的元素值不能修改，元组是放在括号中，列表是放于方括号中。</em></p>
<h6 id="range函数">21.2.11 range()函数</h6>
<p>Python3 <code>range()</code>函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。 Python3 <code>list()</code>函数是对象迭代器，可以把<code>range()</code>返回的可迭代对象转为一个列表，返回的变量类型为列表。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式</span></span><br><span class="line"><span class="built_in">range</span>(stop)</span><br><span class="line"><span class="built_in">range</span>(start, stop[, step])</span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">	<span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<h6 id="reversed函数">21.2.12 reversed()函数</h6>
<p>reversed 函数返回一个反转的迭代器。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 字符串</span><br><span class="line">seqString = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqString)))</span><br><span class="line"> </span><br><span class="line"># 元组</span><br><span class="line">seqTuple = (<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqTuple)))</span><br><span class="line"> </span><br><span class="line"><span class="meta"># range</span></span><br><span class="line">seqRange = <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqRange)))</span><br><span class="line"> </span><br><span class="line"># 列表</span><br><span class="line">seqList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(seqList)))</span><br></pre></td></tr></table></figure> 结果： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;R&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;R&#x27;</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h6 id="set函数">21.2.13 set()函数</h6>
<p><code>set()</code>函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">set</span>(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">y = <span class="built_in">set</span>(<span class="string">&#x27;google&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="built_in">set</span>([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]), <span class="built_in">set</span>([<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;l&#x27;</span>]))   <span class="comment"># 重复的被删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x &amp; y         <span class="comment"># 交集</span></span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;o&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x | y         <span class="comment"># 并集</span></span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x - y         <span class="comment"># 差集</span></span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="sorted函数">21.2.14 sorted()函数</h6>
<p><code>sorted()</code>函数对所有可迭代的对象进行排序操作 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式</span></span><br><span class="line"><span class="built_in">sorted</span>(iterable, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">example_list = [<span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">sorted</span>(example_list, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>sort 与 sorted 区别：</strong></p>
<ul>
<li><code>sort</code>是应用在 <code>list</code> 上的方法，<code>sorted</code> 可以对所有可迭代的对象进行排序操作。</li>
<li><code>list</code> 的 <code>sort</code> 方法返回的是对已经存在的列表进行操作，而内建函数<code>sorted</code>方法返回的是一个新的 <code>list</code>，而不是在原来的基础上进行的操作。</li>
</ul>
<h6 id="hash函数">21.2.15 hash()函数</h6>
<p>hash() 用于获取取一个对象（字符串或者数值等）的哈希值。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(<span class="string">&#x27;test&#x27;</span>)            <span class="comment"># 字符串</span></span><br><span class="line"><span class="comment">#哈希值</span></span><br><span class="line"><span class="number">2314058222102390712</span></span><br></pre></td></tr></table></figure></p>
<h6 id="vars函数">21.2.16 vars()函数</h6>
<p><code>vars()</code>函数返回对象<code>object</code>的属性和属性值的字典对象。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#格式</span><br><span class="line"><span class="built_in">vars</span>([object])</span><br><span class="line">#举例</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runoob</span>:</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>(Runoob))</span><br><span class="line">#输出：</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>: None&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="命令行参数add_argument用法解析">22. 命令行参数add_argument()用法解析</h4>
<h5 id="argparse介绍">22.1 argparse介绍</h5>
<p><code>argparse</code>模块是 Python 内置的一个用于命令项选项与参数解析的模块，argparse 模块可以让人轻松编写用户友好的命令行接口。通过在程序中定义好我们需要的参数，然后 argparse 将会从 sys.argv 解析出这些参数。argparse 模块还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。</p>
<p>三个步骤：</p>
<ul>
<li>1、创建一个解析器——创建 ArgumentParser() 对象</li>
<li>2、添加参数——调用 add_argument() 方法添加参数</li>
<li>3、解析参数——使用 parse_args() 解析添加的参数</li>
</ul>
<h5 id="创建一个解析器创建-argumentparser-对象">22.2 创建一个解析器——创建 ArgumentParser() 对象</h5>
<p>使用 argparse 的第一步是创建一个 ArgumentParser 对象： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure> ArgumentParser 对象包含将命令行解析成 Python 数据类型所需的全部信息。</p>
<ul>
<li><code>description</code>:大多数对 ArgumentParser 构造方法的调用都会使用 description= 关键字参数。这个参数简要描述这个程度做什么以及怎么做。在帮助消息中，这个描述会显示在命令行用法字符串和各种参数的帮助消息之间。</li>
</ul>
<h5 id="添加参数调用-add_argument-方法添加参数">22.3 添加参数——调用 add_argument() 方法添加参数</h5>
<p>给一个 ArgumentParser 添加程序参数信息是通过调用 add_argument() 方法完成的。通常，这些调用指定 ArgumentParser 如何获取命令行字符串并将其转换为对象。这些信息在 parse_args() 调用时被存储和使用。例如 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--sparse&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;GAT with sparse version or not.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">72</span>, <span class="built_in">help</span>=<span class="string">&#x27;Random seed.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10000</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of epochs to train.&#x27;</span>)</span><br></pre></td></tr></table></figure> add_argument() 方法定义如何解析命令行参数: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.add_argument(name <span class="keyword">or</span> flags...[, action][, nargs][, const][, default][, <span class="built_in">type</span>][, choices][, required][, <span class="built_in">help</span>][, metavar][, dest])</span><br></pre></td></tr></table></figure></p>
<p>每个参数解释如下: - <code>name or flags</code>: 选项字符串的名字或者列表，例如 foo 或者 -f, --foo。 - <code>action</code> : 命令行遇到参数时的动作，默认值是 store。 - <code>store_const</code>:表示赋值为const； - <code>append</code>:将遇到的值存储成列表，也就是如果参数重复则会保存多个值; - <code>append_const</code>:将参数规范中定义的一个值保存到一个列表； - <code>count</code>：存储遇到的次数；此外，也可以继承 argparse.Action 自定义参数解析； - <code>nargs</code>: 应该读取的命令行参数个数，可以是具体的数字，或者是?号，当不指定值时对于 Positional argument 使用 default，对于 Optional argument 使用 const；或者是 * 号，表示 0 或多个参数；或者是 + 号表示 1 或多个参数。 - <code>const</code>: action 和 nargs 所需要的常量值。 - <code>default</code> : 不指定参数时的默认值。 - <code>type</code>: 命令行参数应该被转换成的类型。 - <code>choices</code> : 参数可允许的值的一个容器。 - <code>required</code>: 可选参数是否可以省略 (仅针对可选参数)。 - <code>help</code> : 参数的帮助信息，当指定为 argparse.SUPPRESS 时表示不显示该参数的帮助信息. - <code>metavar</code>:在 usage 说明中的参数名称，对于必选参数默认就是参数名称，对于可选参数默认是全大写的参数名称. - <code>dest</code>: 解析后的参数名称，默认情况下，对于可选参数选取最长的名称，中划线转换为下划线.</p>
<h5 id="解析参数使用-parse_args-解析添加的参数">22.4 解析参数——使用 parse_args() 解析添加的参数</h5>
<p>rgumentParser 通过 parse_args() 方法解析参数。它将检查命令行，把每个参数转换为适当的类型然后调用相应的操作。在大多数情况下，这意味着一个简单的 Namespace 对象将从命令行解析出的属性构建： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">args = parser.parse_args()</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 22.5 实例</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"> </span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">parser.add_argument(<span class="string">&#x27;--sparse&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;GAT with sparse version or not.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">72</span>, <span class="built_in">help</span>=<span class="string">&#x27;Random seed.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10000</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of epochs to train.&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">args = parser.parse_args()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(args.sparse)</span><br><span class="line"><span class="built_in">print</span>(args.seed)</span><br><span class="line"><span class="built_in">print</span>(args.epochs)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">547k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:18</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
