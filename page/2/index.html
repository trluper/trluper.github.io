<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Trluper">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="trluper">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">git使用教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-07 10:10:47 / 修改时间：15:21:59" itemprop="dateCreated datePublished" datetime="2022-09-07T10:10:47+08:00">2022-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="git是什么">1. Git是什么</h4>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git原来是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<h5 id="git-与-svn-区别">1.1 Git 与 SVN 区别</h5>
<p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。</p>
<p><code>Git</code>与<code>SVN</code>区别点：</p>
<ul>
<li><p>1、<code>Git</code>是分布式的，<code>SVN</code>不是：这是<code>Git</code>和其它非分布式的版本控制系统，</p></li>
<li><p>2、<code>Git</code>把内容按元数据方式存储，而<code>SVN</code>是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 <code>.svn、.cvs</code>等的文件夹里。</p></li>
<li><p>3、<code>Git</code>分支和<code>SVN</code>的分支不同：分支在 <code>SVN</code>中一点都不特别，其实它就是版本库中的另外一个目录。</p></li>
<li><p>4、<code>Git</code>没有一个全局的版本号，而<code>SVN</code>有：目前为止这是跟<code>SVN</code>相比<code>Git</code>缺少的最大的一个特征。</p></li>
<li><p>5、<code>Git</code>的内容完整性要优于<code>SVN</code>：<code>Git</code>的内容存储使用的是<code>SHA-1</code>哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Git.png" width="500"></p></li>
</ul>
<h4 id="git安装">2. Git安装</h4>
<h5 id="linux下的git">2.1 Linux下的Git</h5>
<p>Git 的工作需要调用<code>curl，zlib，openssl，expat，libiconv</code>等库的代码，所以需要先安装这些依赖工具。 在有<code>yum</code>的系统上centOS或者有<code>apt-get</code>的系统上（比如 Debian 体系），可以用下面的命令安装：</p>
<h6 id="ubuntu安装">2.1.1 ubuntu安装</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \</span><br><span class="line">  libz-dev libssl-dev</span><br><span class="line"></span><br><span class="line">$ apt-get install git</span><br><span class="line"></span><br><span class="line">$ git --version</span><br><span class="line">git version <span class="number">1.8</span><span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
<h6 id="centos安装">2.1.2 centOS安装</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel \</span><br><span class="line">  openssl-devel zlib-devel</span><br><span class="line"></span><br><span class="line">$ yum -y install git-core</span><br><span class="line"></span><br><span class="line">$ git --version</span><br><span class="line">git version <span class="number">1.7</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<h5 id="windows下的git">2.2 windows下的Git</h5>
<p>在 Windows平台上安装 Git同样轻松,找到<a target="_blank" rel="noopener" href="https://gitforwindows.org/">官网下载链接</a>，点击下一步直接安装即可。</p>
<h5 id="git配置">2.3 Git配置</h5>
<p>Git 提供了一个叫做<code>git config</code>的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ul>
<li><code>/etc/gitconfig</code>文件：系统中对所有用户都普遍适用的配置。若使用<code>git config</code>时用 <code>--system</code>选项，读写的就是这个文件。</li>
<li><code>~/.gitconfig</code>文件：用户目录下的配置文件只适用于该用户。若使用<code>git config</code>时用 <code>--global</code>选项，读写的就是这个文件。</li>
<li>当前项目的<code>Git</code>目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code>里的配置会覆盖 <code>/etc/gitconfig</code>中的同名变量。</li>
</ul>
<p>在 Windows 系统上，Git 会找寻用户主目录下的 <code>.gitconfig</code>文件。主目录即 $HOME 变量指定的目录，一般都是 <code>C:\Documents and Settings\$USER。</code></p>
<p>此外，Git 还会尝试找寻 <code>/etc/gitconfig</code>文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<h6 id="用户信息">2.3.1 用户信息</h6>
<p>为了方便后续Git能跟踪到谁做了修改，我们需要设置对应的用户名与邮箱地址。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;wuwenjie&quot;</span></span><br><span class="line">$ git config --global user.email <span class="number">1229413537</span>@qq.com</span><br><span class="line"></span><br><span class="line">$ git config --list</span><br><span class="line">diff.astextplain.textconv=astextplain</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=<span class="literal">true</span></span><br><span class="line">http.sslbackend=openssl</span><br><span class="line">http.sslcainfo=D:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt</span><br><span class="line">core.autocrlf=<span class="literal">true</span></span><br><span class="line">core.fscache=<span class="literal">true</span></span><br><span class="line">core.symlinks=<span class="literal">false</span></span><br><span class="line">pull.rebase=<span class="literal">false</span></span><br><span class="line">credential.helper=manager-core</span><br><span class="line">credential.https:<span class="comment">//dev.azure.com.usehttppath=true</span></span><br><span class="line">init.defaultbranch=master</span><br><span class="line">user.email=<span class="number">1229413537</span>@qq.com</span><br><span class="line">user.name=wuwenjie</span><br></pre></td></tr></table></figure></p>
<h4 id="git工作流程">3. git工作流程</h4>
<p>git一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/git-process.png" width="500"></li>
</ul>
<h4 id="git三个区和三个状态">4. git三个区和三个状态</h4>
<p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p>
<ul>
<li><strong>工作区</strong>：就是你在电脑里能看到的目录。</li>
<li><strong>暂存区</strong>：英文叫<code>stage</code>或<code>index</code>。一般存放在<code>.git</code>目录下的<code>index</code>文件（<code>.git/index</code>）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><p><strong>版本库</strong>：工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 <code>Git</code> 的版本库。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Three.png" width="500"></p></li>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为 <code>index</code>的区域是暂存区<code>stage/index</code>，标记为 <code>master</code>的是<code>master</code>分支所代表的目录树。</li>
<li>图中我们可以看出此时<code>HEAD</code>实际是指向<code>master</code>分支的一个<code>游标</code>。所以图示的命令中出现<code>HEAD</code>的地方可以用<code>master</code>来替换。</li>
<li>图中的<code>objects</code>标识的区域为<code>Git</code>的对象库，实际位于<code>.git/objects</code>目录下，里面包含了创建的各种对象及内容。</li>
<li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li>
<li>当执行提交操作<code>git commit</code>时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 <code>master</code>指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，被 <code>master</code>分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 <code>git rm --cached &lt;file&gt;</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行 <code>git checkout</code> . 或者 <code>git checkout -- &lt;file&gt;</code>命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li>
<li><p>当执行 <code>git checkout HEAD</code> . 或者 <code>git checkout HEAD &lt;file&gt;</code>命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li>
</ul>
<h4 id="git创建仓库">5. Git创建仓库</h4>
<p>可以使用一个已经存在的目录作为<code>Git</code>仓库。<code>Git</code>使用<code>git init</code>命令来初始化一个<code>Git</code>仓库，<code>Git</code>的很多命令都需要在<code>Git</code>的仓库中运行，所以<code>git init</code>是使用<code>Git</code>的第一个命令。</p>
<p>在执行完成<code>git init</code>命令后，<code>Git</code> 仓库会生成一个<code>.git</code>目录，该目录包含了资源的所有元数据，其他的项目目录保持不变</p>
<ul>
<li><p><strong>当前目录即为仓库</strong>：使用当前目录作为 Git 仓库，我们只需使它初始化。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure> 该命令执行完后会在当前目录生成一个 .git 目录。</p></li>
<li><p><strong>使用我们指定目录作为Git仓库。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure> 初始化后，会在<code>newrepo</code>目录下会出现一个名为 <code>.git</code>的目录，所有<code>Git</code>需要的数据和资源都存放在这个目录中。</p></li>
</ul>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用<code>git add</code>命令告诉<code>Git</code>开始对这些文件进行跟踪，然后提交： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下命令将目录下以 .c 结尾及 README 文件提交到仓库中。</span></span><br><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">&#x27;初始化项目版本&#x27;</span></span><br></pre></td></tr></table></figure> &gt; 注： 在 Linux 系统中，commit 信息使用单引号 <code>'</code>，Windows 系统，commit 信息使用双引号<code>&quot;</code>。 &gt;所以在 git bash 中<code>git commit -m '提交说明'</code>这样是可以的，在 Windows 命令行中就要使用双引号 &gt;<code>git commit -m &quot;提交说明&quot;</code>。</p>
<h4 id="git的基本操作">6. Git的基本操作</h4>
<p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。Git 常用的是以下 6 个命令：<code>git clone、git push、git add 、git commit、git checkout、git pull</code>，后面我们会详细介绍。 <img src="/2022/09/07/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/git-command.png" width="500"></p>
<ul>
<li><code>workspace</code>：工作区</li>
<li><code>staging area</code>：暂存区/缓存区</li>
<li><code>local repository</code>：版本库或本地仓库</li>
<li><code>remote repository</code>：远程仓库</li>
</ul>
<h5 id="git-clone">6.1 git clone</h5>
<p>我们使用<code>git clone</code>从现有<code>Git</code>仓库中拷贝项目（类似<code>svn checkout</code>）.克隆仓库的命令格式为：<code>git clone &lt;repo&gt;</code>。</p>
<p>要克隆<code>Ruby</code>语言的<code>Git</code>代码仓库<code>Grit</code>，可以用下面的命令： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git:<span class="comment">//github.com/schacon/grit.git</span></span><br></pre></td></tr></table></figure></p>
<h5 id="提交与修改">6.2 提交与修改</h5>
<p>下表列出了有关创建与提交你的项目的快照的命令：</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>git add</code></td>
<td>添加文件到暂存区</td>
</tr>
<tr class="even">
<td><code>git status</code></td>
<td>查看仓库当前的状态，显示有变更的文件。</td>
</tr>
<tr class="odd">
<td><code>git diff</code></td>
<td>比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr class="even">
<td><code>git commit</code></td>
<td>提交暂存区到本地仓库。</td>
</tr>
<tr class="odd">
<td><code>git reset</code></td>
<td>回退版本。</td>
</tr>
<tr class="even">
<td><code>git rm</code></td>
<td>将文件从暂存区和工作区中删除。</td>
</tr>
<tr class="odd">
<td><code>git mv</code></td>
<td>移动或重命名工作区文件。</td>
</tr>
</tbody>
</table>
<h5 id="提交日志">6.3 提交日志</h5>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>git log</code></td>
<td>查看历史提交记录</td>
</tr>
<tr class="even">
<td><code>git blame &lt;file&gt;</code></td>
<td>以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody>
</table>
<h5 id="远程操作">6.4 远程操作</h5>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>git remote</code></td>
<td>远程仓库操作</td>
</tr>
<tr class="even">
<td><code>git fetch</code></td>
<td>从远程获取代码库</td>
</tr>
<tr class="odd">
<td><code>git pull</code></td>
<td>下载远程代码并合并</td>
</tr>
<tr class="even">
<td><code>git push</code></td>
<td>上传远程代码并合并</td>
</tr>
</tbody>
</table>
<h4 id="git的分支管理">7. Git的分支管理</h4>
<p>几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。<code>Git</code>分支实际上是指向更改快照的指针。有人把<code>Git</code>的分支模型称为必杀技特性，而正是因为它，将<code>Git</code>从版本控制系统家族里区分出来。</p>
<h5 id="git-branch创建分支">7.1 git branch创建分支</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">git <span class="title">branch</span> <span class="params">(branchname)</span></span></span><br></pre></td></tr></table></figure>
<p>没有参数时，<code>git branch</code>会列出你在本地的分支。当你执行<code>git init</code>的时候，默认情况下<code>Git</code>就会为你创建<code>master</code>主分支。如果我们要手动创建一个分支。执行<code>git branch (branchname)</code>即可。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure></p>
<h5 id="git-checkout切换分支">7.2 git checkout切换分支</h5>
<p>用<code>git checkout (branch)</code>切换到我们要修改的分支 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ echo <span class="string">&#x27;runoob.com&#x27;</span> &gt; test.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&#x27;add test.txt&#x27;</span></span><br><span class="line">[master <span class="number">3e92</span>c19] add test.txt</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> <span class="built_in">insertion</span>(+)</span><br><span class="line"> create mode <span class="number">100644</span> test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git checkout testing</span><br><span class="line">Switched to branch <span class="string">&#x27;testing&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure> 当我们切换到<code>testing</code>分支的时候，我们添加的新文件 <code>test.txt</code>被移除了。切换回<code>master</code>分支的时候，它们又重新出现了。</p>
<p>我们也可以使用<code>git checkout -b (branchname)</code> 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b newtest</span><br><span class="line">Switched to a <span class="keyword">new</span> branch <span class="string">&#x27;newtest&#x27;</span></span><br><span class="line">$ git rm test.txt </span><br><span class="line">rm <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ touch runoob.php</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -am <span class="string">&#x27;removed test.txt、add runoob.php&#x27;</span></span><br><span class="line">[newtest c1501a2] removed test.txt、add runoob.php</span><br><span class="line"> <span class="number">2</span> files changed, <span class="number">1</span> <span class="built_in">deletion</span>(-)</span><br><span class="line"> create mode <span class="number">100644</span> runoob.php</span><br><span class="line"> <span class="keyword">delete</span> mode <span class="number">100644</span> test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        runoob.php</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure>
<p>如你所见，我们创建了一个分支，在该分支上移除了一些文件<code>test.txt</code>，并添加了<code>runoob.php</code>文件，然后切换回我们的主分支，删除的<code>test.txt</code>文件又回来了，且新增加的<code>runoob.php</code>不存在主分支中。</p>
<p>这样就将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p>
<h5 id="合并分支">7.4 合并分支</h5>
<p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：<code>git merge</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  newtest</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git merge newtest</span><br><span class="line">Updating <span class="number">3e92</span>c19..c1501a2</span><br><span class="line">Fast-forward</span><br><span class="line"> runoob.php | <span class="number">0</span></span><br><span class="line"> test.txt   | <span class="number">1</span> -</span><br><span class="line"> <span class="number">2</span> files changed, <span class="number">1</span> <span class="built_in">deletion</span>(-)</span><br><span class="line"> create mode <span class="number">100644</span> runoob.php</span><br><span class="line"> <span class="keyword">delete</span> mode <span class="number">100644</span> test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        runoob.php</span><br></pre></td></tr></table></figure> 以上实例中我们将<code>newtest</code>分支合并到主分支去，那么<code>test.txt</code>文件被删除,<code>runoob.php</code>被添加到主分支</p>
<h5 id="删除分支">7.5 删除分支</h5>
<p>删除分支只需加个<code>-d</code>即可：<code>git branch -d (branchname)</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br><span class="line">$ git branch -<span class="function">d testing</span></span><br><span class="line"><span class="function">Deleted branch <span class="title">testing</span> <span class="params">(was <span class="number">85f</span>c7e7)</span>.</span></span><br><span class="line"><span class="function">$ git branch</span></span><br><span class="line"><span class="function">* master</span></span><br></pre></td></tr></table></figure></p>
<p>文章来源：<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-workflow.html">菜鸟教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/07/VScode%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/07/VScode%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">VScode教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-07 09:46:11 / 修改时间：11:19:39" itemprop="dateCreated datePublished" datetime="2022-09-07T09:46:11+08:00">2022-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VScode/" itemprop="url" rel="index"><span itemprop="name">VScode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="为什么使用vscode">1. 为什么使用VScode</h4>
<p>VScode是微软推出一个轻量化编辑器，只需要下载相应的编译器和包即可支持C/C++、java、python的编写。相对于VS来说，VScode更加的轻便、体积小，支持许多插件。</p>
<h4 id="vscode的界面使用">2. VScode的界面使用</h4>
<p><img src="/2022/09/07/VScode%E6%95%99%E7%A8%8B/someClick.png" width="600"></p>
<h5 id="用户设置">2.1 用户设置</h5>
<p><code>文件File--首选项preferences--设置settings</code>，打开用户设置。VScode支持选择配置，也支持编辑<code>setting.json</code>文件修改默认配置 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）editor.fontsize用来设置字体大小，可以设置editor.fontsize : <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）files.autoSave这个属性是表示文件是否进行自动保存，推荐设置为onFocusChange——文件焦点变化时自动保存。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）editor.tabCompletion用来在出现推荐值时，按下Tab键是否自动填入最佳推荐值，推荐设置为on;</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）editor.codeActionsOnSave中的source.organizeImports属性，这个属性能够在保存时，自动调整 <span class="keyword">import</span> 语句相关顺序，能够让你的 <span class="keyword">import</span> 语句按照字母顺序进行排列，推荐设置为<span class="literal">true</span>,即<span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123; <span class="string">&quot;source.organizeImports&quot;</span>: <span class="literal">true</span> &#125;；</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）editor.lineNumbers设置代码行号,即editor.lineNumbers ：<span class="literal">true</span>；</span><br></pre></td></tr></table></figure></p>
<h4 id="常用快捷键">3. 常用快捷键</h4>
<p>高效的使用vscode,记住一些常用的快捷键是必不可少的，这里罗列了一些常用的快捷键。 ##### 3.1 主命令</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+P</code></td>
<td>俗称万能键，可以输入任何命令</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+P</code></td>
<td>根据名称查找文件</td>
</tr>
</tbody>
</table>
<h5 id="编辑器与窗口管理">3.2 编辑器与窗口管理</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+N</code></td>
<td><strong>新建文件</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+N</code></td>
<td><strong>打开一个新的VSCode编辑器</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+O</code></td>
<td><strong>打开文件</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+O</code></td>
<td>打开文件夹</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+W</code></td>
<td>关闭当前文件</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+W 或 Alt+F4</code></td>
<td>关闭当前VSCode编辑器</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+\</code></td>
<td>新建窗口显示代码（相当于复制当前代码到一个新的窗口；同一引用，修改一个文件，其他相同文件会一起改变）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Alt+→</code></td>
<td>移动当前文件到右窗口，若没有右窗口，则创建一个新窗口</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Alt+←</code></td>
<td>移动当前文件到左窗口</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Tab</code></td>
<td><strong>切换文件窗口</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+B</code></td>
<td>显示/隐藏侧边栏</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl +/-</code></td>
<td>放大/缩小编辑器窗口</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+E</code></td>
<td>文件资源管理器（Explorer）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+G</code></td>
<td>git管理窗口（Source Control）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+X</code></td>
<td>扩展（插件）管理窗口（Extentions）</td>
</tr>
</tbody>
</table>
<h5 id="代码文本快捷键">3.3 代码文本快捷键</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+F</code></td>
<td><strong>查找</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+H</code></td>
<td><strong>查找替换</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Shift+F</code></td>
<td>全局查找</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+H</code></td>
<td>全局查找替换</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+D</code></td>
<td>选中下一个匹配项</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+L</code></td>
<td>选中所有匹配项（秀儿）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+[</code></td>
<td>向左缩进</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+]</code></td>
<td>向右缩进</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Alt+Up</code></td>
<td><strong>向上移动当前行</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Alt+Down</code></td>
<td>向下移动当前行</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Shift+Alt+Up</code></td>
<td><strong>向上复制当前行</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Shift+Alt+Down</code></td>
<td>向下复制当前行</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Ctrl+Enter</code></td>
<td><strong>在当前行下方插入空行（光标位置可以不在行尾）</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Ctrl+Shift+Enter</code></td>
<td>在当前行上方插入空行（光标位置可以不在行尾）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Alt+Z</code></td>
<td>切换内容是否自动换行（底部显示/隐藏滚动条</td>
</tr>
</tbody>
</table>
<p>如果在编程中忘记了快捷键，也可以使用<code>Ctrl+K/Ctrl+S</code>来查看VSCode中全部快捷键。</p>
<h4 id="插件安装">4. 插件安装</h4>
<p>在输入框中输入想要安装的插件名称，点击安装即可，推荐安装的插件有： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、Bracket Pair Colorizer：给嵌套的各种括号加上不同的颜色。</span><br><span class="line"><span class="number">2</span>、Path Intellisense：智能路径提示，可以在你输入文件路径时智能提示。</span><br><span class="line"><span class="number">3</span>、Markdown Preview：实时预览 markdown。</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-07 21:34:12" itemprop="dateCreated datePublished" datetime="2022-08-07T21:34:12+08:00">2022-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-22 09:47:06" itemprop="dateModified" datetime="2022-08-22T09:47:06+08:00">2022-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="get请求和post请求的区别">1. get请求和post请求的区别</h4>
<p><strong>在实际应用中，get和post请求的区别主要有以下几个：</strong></p>
<ul>
<li><strong><code>get</code>请求用于从服务器上获得资源，而<code>post</code>请求用于向服务器提交数据</strong></li>
<li><code>get</code>将表单中的数据按照<code>key=value</code>的形式，添加到<code>action</code>指定的<code>URL</code>后面，并且两者之间使用<code>?</code>连接，各个变量之间使用&amp;连接；post是将表单的数据放在HTTP协议的请求头或者消息体中，传递到action所指向的URL</li>
<li><strong><code>get</code>传输的数据要受到URL长度的限制（最大长度是2048个字符）；而<code>post</code>可以传输大量数据，上传文件通常使用post</strong></li>
<li><strong>使用<code>get</code>时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用<code>get</code>，对于敏感数据应使用<code>post</code></strong></li>
<li><code>get</code>使用<code>MIME</code>类型<code>application/x-www-form-urlencoded</code>的URL编码（也叫百分号编码）文本格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是<code>%20</code></li>
<li><strong><code>get</code>请求参数会被完整保留在浏览器历史记录里，而<code>post</code>中的参数不会被保留。</strong></li>
</ul>
<p><strong>但是在本质上，get和post请求没有区别：</strong></p>
<p><code>get</code>和<code>post</code>是HTTP协议中的两种发送请求的方法，而HTTP是基于<code>TCP/IP</code>的关于数据如何在万维网中如何通信的协议。因此，<code>get</code>和<code>post</code>的底层也是<code>TCP/IP</code>,也就是说，<code>get</code>和<code>post</code>都是TCP链接。</p>
<p><strong>此外，get和post还有一个重要的区别：</strong></p>
<p><code>get</code>产生一个<code>TCP</code>数据包；<code>POST</code>产生两个TCP数据包。对于<code>get</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应200（返回数据）；而对于<code>post</code>，浏览器先发送<code>header</code>，服务器响应<code>100 continue</code>，浏览器再发送<code>data</code>，服务器响应<code>200 ok</code>（返回数据）。</p>
<h4 id="tcp和udp的区别">2. TCP和UDP的区别</h4>
<ul>
<li><strong>连接性：</strong>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。UDP无连接。</li>
<li><strong>服务对象</strong>：TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；UDP支持一对一，一对多，多对一，多对多的交互通信。</li>
<li><strong>可靠性</strong>：TCP是有保证数据安全可靠的措施，可靠交付：无差错，不丢失，不重复，按序到达。UDP是尽最大努力交付，不保证可靠交付。</li>
<li><strong>拥塞控制和流量控制</strong>：TCP有拥塞控制和流量控制保证数据传输的安全性。UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li>
<li><strong>报文长度</strong>：TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li>
<li><strong>首部开销</strong>：TCP首部开销大，首部20个字节。UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</li>
<li><strong>TCP和UDP适用场景</strong>：从特点上我们已经知道，TCP是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</li>
</ul>
<p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP.png" width="600"></p>
<h4 id="tcp三次握手">3. TCP三次握手</h4>
<ul>
<li>只有<code>SYN</code>位置1表示连接请求。</li>
<li>只有<code>ACK</code>置1表示<code>ACK</code>报文段，携带数据时会消耗序号<code>seq</code>，不携带则不消耗</li>
<li><code>ACK</code>和<code>SYN</code>都置1，不能携带数据，但消耗1个序号<code>seq</code> <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/threeAndFour.png" width="600"></li>
</ul>
<h5 id="三次握手">3.1 三次握手</h5>
<ul>
<li>1、Client将标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，并将该数据包发送给Server，Client进入<code>SYN_SENT</code>状态，等待Server确认。</li>
<li>2、Server收到数据包后由标志位<code>SYN=1</code>知道Client请求建立连接，Server将标志位<code>SYN</code>和<code>ACK</code>都置为1，<code>ack=J+1</code>，随机产生一个值<code>seq=K</code>，并将该数据包发送给Client以确认连接请求，Server进入<code>SYN_RCVD</code>状态。</li>
<li>3、Client收到确认后，检查<code>ack</code>是否为J+1，ACK若为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给Server，Server检查<code>ack</code>是否为K+1，<code>ACK</code>为1，如果正确则连接建立成功，Client和Server进入<code>ESTABLISHED</code>状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<h5 id="三次握手的原因">3.2 三次握手的原因</h5>
<ul>
<li>①建立连接，</li>
<li>②第三次要回ACK的原因：如果没有第三次回ACK，会导致已经失效的连接请求报文突然又传输到服务器端，又建立客户端与服务器的连接，但客户端又不发送数据，此时导致的服务器资源浪费。 所谓已经失效的连接请求是指客户端发出的连接请求滞留在网络中，超时后但又被服务器接收到。</li>
</ul>
<h5 id="思考connect为什么会阻塞即第三次ack丢失下客户端怎么办">3.3 思考：connect为什么会阻塞（即第三次ACK丢失下客户端怎么办）</h5>
<p><strong>server端：</strong></p>
<blockquote>
<p>第三次的ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。 而Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为&gt;5.如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。</p>
</blockquote>
<p><strong>client端</strong>：</p>
<blockquote>
<p>在linux c 中，client 一般是通过<code>connect()</code>函数来连接服务器的，而<code>connect()</code>是在TCP的三次握手的第二次握手完成后就成功返回值。也就是说client在接收到 SYN+ACK包，它的TCP连接状态就为established （已连接），表示该连接已经建立。 那么如果第三次握手中的ACK包丢失的情况下，Client 向<code>server</code>端发送数据，Server端将以<code>reset</code>包响应，方能感知到Server的错误。</p>
</blockquote>
<h4 id="tcp四次挥手">4. TCP四次挥手</h4>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个<code>FIN</code>来终止这一方向的连接，收到一个<code>FIN</code> 只是意味着这一方向上没有数据流动了，即不会再发送到数据了，但是在这个TCP连接上仍然能够收数据，直到另一方也发送了<code>FIN</code>。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<h5 id="四次挥手过程">4.1 四次挥手过程</h5>
<ul>
<li>1.数据传输结束后，客户端的应用进程发出连接释放<code>FIN</code>报文段，并停止发送数据，客户端进入<code>FIN_WAIT_1</code>状态，此时客户端依然可以接收服务器发送来的数据。</li>
<li>2.服务器接收到<code>FIN</code>后，发送一个<code>ACK</code>给客户端，确认序号为收到的序号<code>+1</code>，服务器进入<code>CLOSE_WAIT</code>状态。客户端收到后进入<code>FIN_WAIT_2</code>状态。</li>
<li>3.当服务器没有数据要发送时，服务器也发送一个<code>FIN</code>报文，此时服务器进入<code>LAST_ACK</code>状态，等待客户端的确认</li>
<li>4.客户端收到服务器的<code>FIN</code>报文后，给服务器发送一个<code>ACK</code>报文，确认序列号为收到的序号<code>+1</code>。此时客户端进入<code>TIME_WAIT</code>状态，等待<code>2MSL</code>（MSL：报文段最大生存时间），然后关闭连接。</li>
</ul>
<p>应用层可以使用系统调用函数read函数==0来判断对端是否关闭连接。</p>
<h5 id="为什么要等待2msl才关闭链接">4.2 为什么要等待2MSL才关闭链接</h5>
<ul>
<li>①为保证客户端发送的最后一个ACK报文段能够到达服务器。若第4次挥手的报文段丢失了，服务器就会超时重传第3次挥手的报文段。</li>
<li>②经过2MSL时间，可以使本次连接持续时间内所以产生的报文段(主要针对滞留在网络中的）都失效，这样就可避免已失效的本次链接请求影响下一次链接请求。</li>
</ul>
<h5 id="为什么要4次挥手">4.3 为什么要4次挥手</h5>
<p>因为主动关闭的一方是已经确定没有数据要发送了，而被动关闭的一方还未<code>FIN</code>报文，先回一个<code>ACK</code>确认报文，其在<code>FIN</code>发生前可能还要发送数据，只有等待数据发生完，才能回一个<code>FIN</code>报文，主动关闭方再回一个<code>ACK</code>确认,才能达到双向关闭，</p>
<h4 id="tcp机的状态转移">5. TCP机的状态转移</h4>
<p><img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/statusSwitch.png" width="600"> [^上半部分为3次握手，下半部分为4次挥手，实线表示主动，虚线为被动，细线为特殊情况]</p>
<p><strong>状态解释：</strong></p>
<ul>
<li><code>CLOSED</code>：表示初始状态。</li>
<li><code>LISTEN</code>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li>
<li><code>SYN_SENT</code>：这个状态与<code>SYN_RCVD</code>遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。<code>SYN_SENT</code>状态表示客户端已发送SYN报文。</li>
<li><code>SYN_RCVD</code>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</li>
<li><p><code>ESTABLISHED</code>：表示连接已经建立。</p></li>
<li><strong><code>FIN_WAIT_1</code>: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文</strong>。区别是：
<ul>
<li><code>FIN_WAIT_1</code>状态是当socket在<code>ESTABLISHED</code>状态时，想主动关闭连接，向对方发送了<code>FIN</code>报文，此时该socket进入到FIN_WAIT_1状态。</li>
<li><code>FIN_WAIT_2</code>状态是当对方回应<code>ACK</code>后，该socket进入到<code>FIN_WAIT_2</code>状态，正常情况下，对方应马上回应<code>ACK</code>报文，所以<code>FIN_WAIT_1</code>状态一般较难见到，而<code>FIN_WAIT_2</code>状态可用netstat看到。</li>
</ul></li>
<li><p><code>FIN_WAIT_2</code>：<strong>主动关闭链接的一方，发出<code>FIN</code>收到<code>ACK</code>以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发，既socket上还有数据流动。</strong></p></li>
<li><p><code>TIME_WAIT</code>: <strong>表示收到了对方的<code>FIN</code>报文，并发送出了<code>ACK</code>报文，等2MSL后即可回到CLOSED可用状态。如果<code>FIN_WAIT_1</code>状态下，收到对方同时带<code>FIN</code>标志和<code>ACK</code>标志的报文时，可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code>状态。</strong></p></li>
<li><p><code>CLOSING</code>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p></li>
<li><code>CLOSE_WAIT</code>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。（服务器）</li>
<li><p><code>LAST_ACK</code>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。（服务器）</p></li>
</ul>
<h4 id="tcp的拥塞控制对整个网络">6. TCP的拥塞控制：对整个网络</h4>
<p>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。<strong>流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口<code>cwnd</code>。</strong></p>
<ul>
<li><p><strong>慢开始</strong>：最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免<code>cwnd</code>增长过大。</p></li>
<li><p><strong>拥塞避免</strong>：每经过一个往返时间<code>RTT</code>，<code>cwnd</code>只增长1。在慢开始和拥塞避免的过程中，一旦发现网络拥塞（超时），就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）</p></li>
<li><p><strong>快重传</strong>：接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。</p></li>
<li><p><strong>快恢复</strong>：当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），并将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/controlOfcrowd.png" width="600"></p></li>
</ul>
<h4 id="tcp的可靠性保证">7. TCP的可靠性保证</h4>
<p>TCP主要提供了<strong>检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制</strong>等方法实现了可靠性传输。</p>
<ul>
<li><p><strong>检验和</strong>：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部</p></li>
<li><p>最大长度：在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</p></li>
<li><p><strong>滑动窗口：</strong>我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。这就提出了一个滑动窗口的概念:不必等等确认，发送端直接发送数据，在连续收到三个重复确认应答时，重新发生要求的序列号包 <img src="/2022/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/resend.png" width="600"></p></li>
</ul>
<h4 id="tcp的滑动窗口">8. TCP的滑动窗口</h4>
<p>端对端的流量控制,也解决包乱序问题（数据包格式有SequenceNumber，是数据包的序号seq,ACK——用于确认收到，用来解决不丢包的问题)。每一次读取数据之后,回ack报文,报文中会携带当前缓冲区大小,用来告知对方发送的数据不能超过我接收的缓冲区大小。</p>
<h4 id="tcp黏包问题">9. TCP黏包问题</h4>
<p><strong>原因：</strong> TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p>
<p><strong>解决：</strong></p>
<ul>
<li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li>
<li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li>
<li>在数据包之间设置边界，如添加特殊符号 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 ，则会误判为消息的边界。</li>
</ul>
<h4 id="简述域名解析过程本机如何干预域名解析">10. 简述域名解析过程，本机如何干预域名解析</h4>
<ul>
<li><p>1）在浏览器中输入<code>www.qq.com</code>域名，操作系统会先检查自己本地的<code>hosts</code>文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p></li>
<li><p>2）如果<code>hosts</code>里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p></li>
<li><p>3）如果<code>hosts</code>与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p></li>
<li><p>4）如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p></li>
<li><p>5）如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名<code>.com</code>是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责<code>.com</code>域的这台服务器。这台负责<code>.com</code>域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址<code>qq.com</code>给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找<code>qq.com</code>域服务器，重复上面的动作，进行查询，直至找到<code>www.qq.com</code>主机。</p></li>
<li><p>6）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></li>
</ul>
<p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>
<h4 id="section">10.</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/" class="post-title-link" itemprop="url">高性能MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-04 21:34:03" itemprop="dateCreated datePublished" datetime="2022-08-04T21:34:03+08:00">2022-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-07 21:12:18" itemprop="dateModified" datetime="2022-08-07T21:12:18+08:00">2022-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="mysql的架构">1. MySQL的架构</h4>
<p>MySQL最重要最与众不同的就是它的存储引擎架构，这种架构设计将查询处理(<code>QUERY PROCESSING</code>)及其他系统任务和数据存储/提取相分离。在这里主要介绍MySQL的服务器架构、各种存储引擎之间的区别。</p>
<h5 id="逻辑架构">1.1 逻辑架构</h5>
<p>MySQL各组件协同工作的示意图如下：</p>
<ul>
<li>最上层的客户端不是MySQL独有的，像许多C/S结构都具有。</li>
<li>第二层架构是大多数MySQL的核心服务功能所在的一层，如查询解析、分析、优化、缓存和所有的内置函数，所有跨存储引擎的功能也在这一层实现：存储过程、视图、触发器等。</li>
<li>第三层包含了存储引擎，存储引擎负责MySQL中数据的存储和提取 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/Fram.png" width="400"></li>
</ul>
<h6 id="连接管理与安全性">1.1.1 连接管理与安全性</h6>
<p>每个客户端连接到MySQL服务器进程有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU时间片中执行语句。服务器会负责缓存管理线程，因此不需要为每一个新建的连接创建或者销毁线程。</p>
<p>当有来自于客户端的连接请求时，服务器会对连接信息进行认证，认证基于用户名、密码和主机信息进行。</p>
<h6 id="优化与执行">1.1.2 优化与执行</h6>
<p><strong>进行解析的过程：</strong></p>
<ul>
<li>MySQL会解析查询，并创建内部数据结构（解析树），<strong>然后对其进行各种优化：包括重写查询、决定表的读取顺序以及选择合适的索引等。</strong></li>
<li>用户可以通过特殊的关键字提示优化器来影响它的优化决策过程，也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器时如何进行优化决策的。</li>
<li>优化器不关心表使用哪种存储引擎，但存储引擎对优化查询是有影响的，因为优化器会请求存储引擎提供容量或某个具体操作的开销。</li>
</ul>
<p><strong>当然不要忘了还有查询缓存：</strong></p>
<p>对于select语句，在解析查询之前，服务器会先检查查询缓存，如果能在查询缓存中找到对应查询，服务器就不必执行解析器、优化和执行的整个过程，直接返回查询缓存中的结果集即可。</p>
<h5 id="并发控制">1.2 并发控制</h5>
<p>在MySQL当中是在两个面讨论的并发控制：服务器层和存储引擎层。在并发场景下，如果不对并发进行控制，则会导致数据的损坏无效，一般来说我们都是用锁<code>lock</code>来对其进行控制。在MySQL中的锁有共享锁(<code>shared lock</code>)、排他锁(<code>exclusive lock</code>)，也叫读锁(<code>read lock</code>)和写锁(<code>write lock</code>)</p>
<h4 id="锁">2. 锁</h4>
<p>锁这个知识点比较繁杂，下图是对锁的各个概念范围进行分类： <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/Lockrecord.png" width="700"></p>
<h5 id="锁类型兼容性">2.1 锁类型（兼容性）</h5>
<p>对于读取内容来说一般不会发生什么问题，因为本线程没有对数据进行修改，<strong>但是试想一下你正在对读的使用，另一个人正在对数据进行写入，这时候问题就来了，你读的数据会是确定呢吗?答案肯定是不确定的</strong>，因此对于读操作也要注意。而写操作就更不用说了，每一次的写入都会改变数据，必定加入排斥锁。在MySQL中读锁即为共享锁，写锁即为排斥锁。</p>
<ul>
<li><p><strong>共享锁（读锁）</strong>：读锁是共享的，或者说是不阻塞的，多个线程可以在同一时刻可以同时读取同一个资源而互不干扰，但是当有一个线程试图写时，是不被允许的，即读锁不阻塞其他的读操作，但是阻塞写操作。</p></li>
<li><p><strong>排斥锁（写锁）</strong>：写锁是排他的，一个写锁会阻塞其他的写锁和读锁。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享锁</span></span><br><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line"><span class="comment">//排他锁（X)</span></span><br><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></table></figure>
<h5 id="锁的粒度">2.2 锁的粒度</h5>
<p><strong>为提供共享资源并发性就是让锁的对象更具有选择性，即尽量只锁定需要修改的部分数据，而不是所有的资源，任何时候，在给定资源锁的粒度越小精度越高，则系统的并发程度越高。但是我们不能无限制的只加最小粒度的锁，因为锁也需要消耗资源的，如锁的各种操作、包括获得锁、检查锁是否解除、释放锁都会增加系统开销</strong>，因此对锁选择策略是在锁的开销和数据安全性之间寻找平衡折中。</p>
<h6 id="表级锁">2.2.1 表级锁</h6>
<p>表级锁是对整个表加锁的一种操作。MyISAM和InnoDB引擎都支持表级锁，</p>
<ul>
<li><strong>优点：</strong>是MySQL中锁定粒度最大的一种锁，实现简单，资源消耗也比较少，加锁快，只对一个表操作不会出现死锁。</li>
<li><strong>缺点</strong>：其锁定粒度最大，触发锁冲突的概率最高，并发度最低。</li>
</ul>
<p>表锁的语法是<code>lock tables … read/write</code>。可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。<code>lock tables</code>语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#为表t1上读锁，t2上写锁</span><br><span class="line">lock tables t1 read,t2 wirte;</span><br><span class="line">#释放锁</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line">mysql&gt; lock tables employee read;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; insert into employee <span class="title">values</span><span class="params">(<span class="string">&#x27;crf&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="number">15000</span>,now(),<span class="number">300</span>)</span></span>;</span><br><span class="line">ERROR <span class="number">1099</span> (HY000): Table <span class="string">&#x27;employee&#x27;</span> was locked with a READ lock <span class="keyword">and</span> can<span class="number">&#x27;</span>t be updated</span><br></pre></td></tr></table></figure></p>
<h6 id="行级锁">2.2.2 行级锁</h6>
<p>行级锁是MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁，在MySQL中MyISAM不支持行锁，InnoDB支持。<strong>记住行级锁只能对是有索引字段进行加锁从而锁住改行。</strong></p>
<ul>
<li><strong>优点：</strong>行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，</li>
<li><strong>缺点：</strong>因为粒度小，因此加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将退化使用的是表锁</strong>。</p>
<p><strong>其他注意事项：</strong></p>
<ul>
<li><p>在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁。</p></li>
<li><p>如果MySQL的行锁是针对范围索引加的锁，不是针对记录加的锁，所以即使是访问不同行的记录，如果使用了相同的索引键，也是会出现锁冲突的，这是因为间隙锁的原因（接下来会讲）</p></li>
<li><p>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</p></li>
<li><p>即便在条件中使用了索引字段，但具体是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p></li>
</ul>
<p><strong>隐式默认加锁</strong>：</p>
<ul>
<li>InnoDB自动加意向锁。</li>
<li>对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，<code>InnoDB</code>会自动给涉及数据集加排他锁<code>（X)</code>；</li>
<li>对于普通<code>SELECT</code>语句，InnoDB不会加任何锁；</li>
</ul>
<p><strong>显示加锁</strong>：</p>
<ul>
<li><strong>共享锁（S）</strong>：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code></li>
<li><strong>排他锁（X)</strong> ：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code></li>
</ul>
<p><strong><em>注意</em></strong>：正如上面所说的，行锁是根据索引上的索引项加锁实现的，即上面的对于的列必须有加索引才能是为行级锁，否则为表级锁，如下开两个客户端连接MySQL,因为不是索引，所以为表锁 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#客户端<span class="number">1</span>：不是索引，粒度为表锁，类型为排他锁</span><br><span class="line">mysql&gt; select id,<span class="function">job_name from employee_job where id <span class="title">in</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span> <span class="keyword">for</span> update</span>;</span><br><span class="line">+----+--------------+</span><br><span class="line">| id | job_name     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">2</span>  | 老板         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">#客户端2：</span></span><br><span class="line"><span class="function">mysql&gt; select id,job_name from employee_job where id <span class="title">in</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">ERROR <span class="number">1100</span> (HY000): Table <span class="string">&#x27;employee_job&#x27;</span> was <span class="keyword">not</span> locked with LOCK TABLES</span><br></pre></td></tr></table></figure></p>
<h6 id="页级锁">2.2.3 页级锁</h6>
<p>页级锁的粒度介于行级锁和表级锁中间的一种锁。它比表级锁速度快，比表级锁的冲突多，比行级锁的冲突少，但速度慢。因此页级是一种折中锁，一次锁定相邻的一组记录。BDB 支持页级锁。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p>
<p><strong><em>注意：行级锁不一定比表级锁要好，锁的粒度越细，代价越高，相比表级锁在表的头部直接加锁，行级锁还要扫描找到对应的行对其上锁，这样的代价其实是比较高的，所以表锁和行锁各有所长。</em></strong></p>
<h6 id="全局锁">2.2.4 全局锁</h6>
<p>MySQL提供了一个加全局读锁的方法，命令是<code>Flush tables with read lock</code>,当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#对所有数据库实例加读锁</span><br><span class="line">Flush tables with read lock</span><br><span class="line">#对所有数据库实例加写锁</span><br><span class="line">Flush tables with write lock</span><br></pre></td></tr></table></figure></p>
<h5 id="死锁">2.3 死锁</h5>
<p>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，</p>
<h6 id="引起死锁的原因">2.3.1 引起死锁的原因</h6>
<ul>
<li>①竞争不可抢占资源引起死锁（不可抢占是指没有使用完的资源，不能被抢占）</li>
<li>②竞争可消耗资源引起死锁</li>
<li>③线程推进顺序不当引起死锁</li>
</ul>
<p>情况1：有线程<code>p1</code>，<code>p2</code>，都需要资源<code>A</code>，<code>B</code>，本来可以<code>p1运行A</code> --&gt; <code>p1运行B</code> --&gt; <code>p2运行A</code> --&gt; <code>p2运行B</code>，但是顺序换了，<code>p1</code>运行<code>A</code>时<code>p2</code>运行<code>B</code>，容易发生第一种死锁。互相抢占资源对放持有的资源。</p>
<p>情况2：有<code>p1，p2，p3</code>三个线程，<code>p1</code>向<code>p2</code>发送消息并接受<code>p3</code>发送的消息，<code>p2</code>向<code>p3</code>发送消息并接受<code>p1</code>的消息，<code>p3</code>向<code>p1</code>发送消息并接受<code>p2</code>的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成死锁。</p>
<h6 id="产生死锁的必要条件">2.3.2 产生死锁的必要条件</h6>
<ul>
<li><p><strong>互斥条件</strong>：某资源只能被一个进程使用，其他进程请求该资源时，只能等待，直到资源使用完毕后释放资源。</p></li>
<li><p><strong>请求和保持条件</strong>：程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。</p></li>
<li><p><strong>不可抢占条件</strong>：进程已获得的资源没有使用完，不能被抢占。</p></li>
<li><p><strong>循环等待条件</strong>：必然存在一个循环链。</p></li>
</ul>
<h6 id="解决死锁的方式">2.3.3 解决死锁的方式</h6>
<p>在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在</p>
<ul>
<li><strong>预防死锁：</strong>在设计时，对锁的使用进行预防，以确保业务不会发生死锁，通过破坏死锁产生的后三个必要条件：即破坏请求持、不可抢占、循环等待条件之一来预防死锁。
<ul>
<li><strong>破坏请求和保持条件</strong>：所有线程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生。</li>
<li><strong>破坏不可抢占条件</strong>：当一个已经保持了某种不可抢占资源的线程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请</li>
<li><strong>破坏循环等待条件</strong>：对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</li>
</ul></li>
<li><p><strong>解除死锁：</strong>产生死锁时，能够从死锁中解脱处理，比如一种策略超时退出。在MySQL中这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置，默认为<code>50s</code>.</p></li>
<li><p><strong>检查死锁：</strong>在MySQL种有这样的机制，线程发现死锁后，会主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。可将参数<code>innodb_deadlock_detect</code>设置为<code>on</code>，表示开启这个逻辑。但是它有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，消耗大。</p></li>
<li><p><strong>一种特殊情况：</strong>在<code>REPEATABLE-READ</code>隔离级别下，如果两个线程同时对相同条件记录用<code>SELECT…FOR UPDATE</code>加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成<code>READ COMMITTED</code>，就可避免问题。</p></li>
</ul>
<h5 id="三种行级锁模式原理">2.4 三种行级锁模式（原理）</h5>
<h6 id="记录锁">2.4.1 记录锁</h6>
<p><strong>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，粒度是行级锁，类型是排他锁</strong>。一般记录锁出现在<code>select、update</code>语句，比如下面这句，它会在<code>id=1</code>的记录上加上记录锁，以阻止其他事务插入，更新，删除和更新<code>id=1</code>这一行。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id 列必须为主键列或唯一索引列</span></span><br><span class="line">SELECT * FROM test WHERE id=<span class="number">1</span> FOR UPDATE;</span><br><span class="line">UPDATE SET age = <span class="number">50</span> WHERE id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure> <strong>记录锁的条件：</strong></p>
<ul>
<li><code>id</code> 列必须为唯一索引列或主键列(主键索引)，否则上述语句加的锁就会变成临键锁(有关临键锁下面会讲)。</li>
<li>同时查询语句的条件子句必须为精准匹配即为<code>=</code>，不能为<code>&gt;、&lt;、like</code>等，否则也会退化成间隙锁或者临键锁</li>
</ul>
<p><strong><em>注意：如果要锁的列没有索引，进行全表记录加锁（行级锁的性质）</em></strong></p>
<h6 id="间隙锁">2.4.2 间隙锁</h6>
<p><strong>间隙锁<code>Gap Lock</code>是指在InnoDB存储引擎中锁可以加在不存在的空闲空间的一种锁</strong>。它能在两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。<strong>间隙锁是一种行级锁，是 InnoDB在 RR(可重复读) 隔离级别下为了解决幻读问题时引入的锁机制。</strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</p>
<p><strong>产生间隙锁的条件：</strong></p>
<ul>
<li>使用普通索引锁定，或者使用多列唯一索引，或者使用唯一索引锁定多行记录。</li>
<li>条件子句不为精确匹配，为范围</li>
</ul>
<p><strong>可能光说不好理解，看例子：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建test表，id为主键索引</span></span><br><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` <span class="built_in">int</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="built_in">varchar</span>(<span class="number">8</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">INSERT INTO `test` <span class="built_in">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;小罗&#x27;</span>),(<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;小黄&#x27;</span>),(<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>),(<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>);</span><br></pre></td></tr></table></figure> 上面的插入语句完成后，<code>test</code>表中存在的隐藏间隙如下： <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/gaplock.png" width="600"> 即有范围：<code>(-∞, 1]、(1, 5]、(5, 7]、(7, 11]、(11, +∞]</code>，那么当我使用下面语句的时候就会触发间隙锁 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM `test` WHERE `id` BETWEEN <span class="number">5</span> AND <span class="number">7</span> FOR UPDATE;</span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;小张1&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">9</span>, <span class="string">&#x27;大东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">11</span>, <span class="string">&#x27;李西&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务8插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */</span></span><br><span class="line">INSERT INTO `test` (`id`, `name`) <span class="built_in">VALUES</span> (<span class="number">12</span>, <span class="string">&#x27;张三&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure> 从上面我们可以看到，<code>(5, 7]、(7, 11]</code>这两个区间被事务1锁住，在此期间的其他事务的插入操作失败，而其它区间，都可以正常插入数据。所以我们可以得出结论：当我们给 <code>(5, 7]</code>这个区间加锁的时候，会锁住 <code>(5, 7]、(7, 11]</code>这两个区间。</p>
<p><strong>间隙锁的缺点</strong>:</p>
<ul>
<li>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。虽然解决了幻读，但在某些场景下这可能会对性能造成很大的危害</li>
<li>当Query无法利用索引的时候， Innodb会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；</li>
</ul>
<p><strong>间隙锁的作用：</strong></p>
<ul>
<li>解决可重复读隔离级别下的幻读</li>
<li>为了数据恢复和复制的需要。</li>
</ul>
<p><strong><em>注意：可重复读级别下才会有间隙锁！还有如果对不存的记录操作即使使用<code>=</code>也会产生间隙锁，如<code>select id,name from test where id=3 for update;</code>,id=3是不存在的记录</em></strong></p>
<h6 id="临键锁next-key-locks">2.4.3 临键锁（Next-Key Locks）</h6>
<p><strong><code>Next-key locks</code>是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。</strong></p>
<p>也可以理解为一种特殊的间隙锁，因此临建锁肯定也可以解决幻读的问题。 <strong>每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据</strong>。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，<strong>而临键锁只与非唯一索引列有关，在唯一索引列（包括主键索引）上不存在临键锁。</strong>即临键锁是对非唯一索引而言的。</p>
<p>假设有如下表：InnoDB，RR隔离级别，<code>id</code>主键, <code>age</code>普通索引 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/nextkeylocks.png" width="600"> 则有<code>age</code>范围:<code>(-∞, 10],(10, 24],(24, 32],(32, 45],(45, +∞]</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/事务A执行下述语句</span><br><span class="line">-- 根据非唯一索引列 UPDATE 某条记录 </span><br><span class="line">UPDATE table SET name = Vladimir WHERE age = <span class="number">24</span>; </span><br><span class="line">-- 或根据非唯一索引列 锁住某条记录 </span><br><span class="line">SELECT * FROM table WHERE age = <span class="number">24</span> FOR UPDATE;</span><br><span class="line"><span class="comment">//事务B执行下述语句</span></span><br><span class="line"><span class="function">INSERT INTO table <span class="title">VALUES</span><span class="params">(<span class="number">100</span>, <span class="number">26</span>, <span class="string">&#x27;tianqi&#x27;</span>)</span></span>; </span><br></pre></td></tr></table></figure> 上面因为<code>age=26</code>恰好在<code>(24,32]范围内</code>,age为非唯一索引，使用临检索模式的行级锁，则不管事务A执行那个语句，事务B的插入语句总会阻塞。</p>
<p><strong>总结：</strong></p>
<ul>
<li><strong>InnoDB 中的行锁的实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁。</strong></li>
<li><strong>记录锁</strong>存在于包括主键索引在内的唯一索引中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于非唯一索引中，锁定开区间范围内的一段间隔，它是基于临键锁实现的。</li>
<li><strong>临键锁</strong>存在于非唯一索引中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的间隙锁，锁定一段左开右闭的索引区间。</li>
</ul>
<h5 id="意向锁">2.5 意向锁</h5>
<p>意向锁又分为<strong>意向共享锁（IS）</strong>和 <strong>意向排他锁（IX）</strong>。在介绍意向锁的意义之前，必须明白下面四点：</p>
<ul>
<li>意向共享锁（IS）和 意向排他锁（IX）都是<strong>表锁</strong>。</li>
<li><strong>意向锁是一种不与行级锁冲突的表级锁，这一点非常重要。它只会与非意向的表锁冲突</strong></li>
<li><strong>意向锁与意向锁之间永远是兼容的</strong></li>
<li>意向锁是<code>InnoDB</code>自动加的， 不需用户干预。当兵对表或对行加排他锁时，就会获得意向排他锁；加共享锁时，会获得意向共享锁。</li>
<li>意向锁是在<code>InnoDB</code>下存在的内部锁，对于<code>MyISAM</code>而言 没有意向锁之说。</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">兼容性</th>
<th style="text-align: center;">表IS</th>
<th style="text-align: center;">表IX</th>
<th style="text-align: center;">表s</th>
<th style="text-align: center;">表x</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>表IS</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>表IX</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>表S</strong></td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>表X</strong></td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
<td style="text-align: center;">不兼容</td>
</tr>
</tbody>
</table>
<p><strong>意向锁的存在目的是为了让InnoDB中的行锁和表锁能够更高效的共存</strong>。假设有下表，InnoDB，RR隔离级别 <code>id</code>是主键 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/ilock.png" width="500"></p>
<p>加入现在有事务<code>A</code>，进行了一条<code>SELECT * FROM users WHERE id = 6 FOR UPDATE;</code>但未提交，那么事务<code>A</code>会获得<code>id=6</code>的行级锁，且为记录排他锁，同时还有自动生成一个意向排他锁。</p>
<p>这时候有个事务<code>B</code>,进行操作<code>LOCK TABLES users READ;</code>会失败，因为对于要表锁来说，必须要保证：</p>
<ul>
<li>当前没有其他事务持有<code>users</code>表的排他锁。</li>
<li>当前没有其他事务持有<code>users</code>表中任意一行的排他锁 。</li>
</ul>
<p>但是现在<code>users</code>表的排他锁已经被事务<code>A</code>持有了，事务B的这个想获取表共享锁的操作会失败。</p>
<p>上面的例子是有意向锁的情况，试想一下没有意向锁和表锁情况会这样：事务B会去检查<code>user</code>表中的每一行查看是否有排他锁，如果有则无法执行，无则会执行。很明显这样的效率极低，但有意向锁后，只需检查意向表锁即可。</p>
<h4 id="事务">3. 事务</h4>
<p>事务就是由一批SQL语句组成，可以说它是一个独立的工作单元。<strong>事务处理可以用来维护数据的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行，事务处理是一种机制，利用事务处理可以保证成批的MySQL操作不会只执行一部分，如果全部执行那没问题，如果在执行过程中发生错误，它就会进行回退以恢复到数据库以前安全版本</strong>。MySQL中InnoDB支持事务，MyISAM不支持。</p>
<h5 id="事务的acid">3.1 事务的ACID</h5>
<p>一个运行良好的事务处理系统，必须具备四大特性：原子性(<code>atomicity</code>)、一致性(<code>consistency</code>)、隔离性(<code>isolation</code>)和持久性(<code>durability</code>)。实现了ACID的数据库相比于未实现的数据库，其通常需要更强的CPU处理能力，更大的内存和磁盘空间。因此要酌情堪虑是否选用事务型存储引擎。</p>
<ul>
<li><strong>原子性</strong>：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的操作要么全部提交成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>：数据库总是从一个一致性状态转移达到另一个一致性状态，一致性状态就是由事务原子性保障，一个事务提交了，那是ok的，一个事务未提交，那也是OK的。</li>
<li><strong>隔离性</strong>：通常来说，一个事务所做的修改在未提交以前，对其他事务是不可见的。事务间是互不干扰的。</li>
<li><strong>持久性</strong>：一旦事务提交了，其所做的修改会永久保存到数据库总中，即使系统崩溃，修改的数据也不会丢失，（持久性不能做到100%保证策略，如果数据库本身就能做到吃性，那么要备份又有什么用呢）</li>
</ul>
<h5 id="隔离级别">3.2 隔离级别</h5>
<p>在SQL标准中定义了四种隔离级别，<strong>每一种级别都规定了一个事务所做的修改，在哪些事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也低</strong></p>
<ul>
<li><p><strong>未提交读(<code>read uncommitted</code>)</strong>：在该隔离级别，事务中的修改，即使没有提交，对其他事务也都是可见的。<strong>事务可以读取未提交的数据，这也被称为脏读</strong>。这个级别会导致喝多问题，从性能上来说，该级别没有比其他级别好很多，一般不推荐使用。</p></li>
<li><strong>提交读(<code>read committed</code>)：在该级别，一个事务开始时只能看见已经提交的事务的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，因此也可称为</strong>不可重复的**。这个隔离级别时大多数数据库默认的隔离级别。</li>
<li><strong>可重复读(<code>repeatable read</code>)</strong>：在该级别，保证了同一个事务多次读取同样的记录的结果是一致的。可重复读是MySQ的默认隔离级别，解决了脏读的问题，但是对于幻读无法解决。<strong>所谓的幻读就是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围插入新的记录，当之前的事务再次读取该范围记录时，产生幻行。</strong>InooDB引擎使用多版本控制MVCC解决幻读问题。</li>
<li><p><strong>可串行化(<code>serializable1</code>)</strong>：该隔离级别时最高的隔离级别，它通过强制事务串行执行，避免了前面说的幻读问题。简单来说，就是在读取每一行数据都加锁，所有会导致大量的超时和锁争问题。</p></li>
</ul>
<h5 id="事务日志">3.3 事务日志</h5>
<p>首先必须明白InnoDB存储引擎是以页为单位来管理存储空间的，真正访问页面之前，需要把在磁盘上的页缓存到内存中的缓存池之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘（checkpoint机制），通过缓存池来优化cpu和磁盘之间的鸿沟。事务的原子性、一致性和持久性由事务的<code>redo日志</code>和<code>undo日志</code>来保证。</p>
<ul>
<li><p><strong><code>REDO LOG</code>称为重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</strong><code>redo</code>日志的存在使得我们再对表进行修改时会把这些修改写进日志里，然后再写入磁盘，只有日志写入成功，才算事务的提交完成，<strong>这样即使数据库发生宕机未刷新到磁盘，也可以通过<code>redo</code>日志恢复。</strong></p></li>
<li><p><strong><code>UNDO LOG</code>称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性</strong>。有的DBA或许会认为<code>UNDO</code>是<code>REDO</code>的逆过程，其实不然。<code>undo log</code>是存储引擎(<code>innodb</code>)生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了<code>insert</code>语句操作，那么<code>undo log</code>就记录一条与之相反的delete操作，主要用于事务回滚（<code>undo log</code>记录的是每个修改操作的逆操作）和一致性非锁定定读（<code>undo log</code>回滚行记录到某种特定的版本,mvcc，多版本并发控制）。 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/log.png" width="600"></p></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zuodaoyong/article/details/123454426">MySQL事务日志详解</a></p>
<h4 id="多版本并发控制mvcc">4. 多版本并发控制MVCC</h4>
<p><strong>在MySQL你可以认为MVCC是行级锁的一种变种，为适应并提升并发性能，大多数情况下避免了加锁操作，因此开销更低，也解决了MySQL默认隔离级别可重复读下的幻读问题</strong>。MVCC旨在<code>repeatable read</code>和<code>read committed</code>下工作。</p>
<p><strong>MVCC的实现，是通过保存数据在某个时间点（说是时间点是未了更好理解，其实是事务的系统版本号）的快照来实现的。在InnoDB的MVCC中，通过在每行记录后面保存两个隐藏的列来实现，这两个列一个是保存了行的创建时间，一个保存了行的过期时间，当然存储的不是实际的时间值，而是系统版本号，系统版本号会根据没新开一个事务而自动递增</strong>。有了这两个列之后，对于<code>select\update\delete\insert</code>则必须遵循下面的规则：</p>
<ul>
<li><strong><code>select</code></strong>：对于select，InnoDB会根据一下规则来检索
<ul>
<li><ol type="a">
<li><strong>InnoDB只查找版本号早于当前事务版本号的数据行，这样确保了事务读取的行，要么在事务开始之前就已经存在，要么是当前事务自己插入或者修改的，绝不可能是该事务之后的事务进行修改的，这样解决了幻读的问题。</strong></li>
</ol></li>
<li><ol start="2" type="a">
<li><strong>行的删除版本要么未定义，要么就是大于当前事务的版本号，这就可以确保事务读取到的行，在该十五i开始前还未删除。如果之前就删除了那么删除版本号肯定有值而读取不了。</strong></li>
</ol></li>
</ul></li>
<li><p><strong><code>INSERT</code></strong>：InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p></li>
<li><p><strong><code>DELETE</code></strong>：InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p></li>
<li><p><strong><code>UPDATE</code></strong>：InnoDB为插入一行新记录，保存当前事务系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p></li>
</ul>
<p><strong><em>注意：MVCC并不能彻底解决并发带来的安全问题，它只是起到一个缓解并发冲突量的作用，如果两个事务有明显的次序要求，如事务A，B是希望A修改该行后再交由B修改，那么就必须人为事务A所在的行加锁，这样才能保证B是再A修改后才修改的</em></strong>，因此该用锁的时候还是要用，否则有MVCC就能解决这些的话，还要锁干嘛</p>
<h4 id="mysql的存储引擎">5. MySQL的存储引擎</h4>
<p>数据库存储引擎是极其重要的，这是因为：</p>
<ul>
<li>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。</li>
<li>不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL的核心就是存储引擎。</li>
<li>用户可以根据不同的需求为数据表选择不同的存储引擎(表类型)</li>
</ul>
<p>MySQL的存储引擎主要有InnoDB、MyISAM。</p>
<h5 id="innodb">5.1 InnoDB</h5>
<p>InnoDB是MySQL当中默认的事务型存储引擎，它被设计用来处理大量的短期事务，短期事务大部分情况下都是正常提交的，很少会回滚。<strong>InnoDB的数据存储在表空间<code>xxx.ibd</code>中，能将表的数据和索引放置在单独的文件中，其表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能，不过它的二级索引（非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的索引都会很大，消耗空间多</strong></p>
<p><strong>InnoDB的特点：</strong></p>
<ul>
<li><strong>采用MVCC多版本并发控制来支持高并发，并且实现了四个标准隔离级别，默认级别为可重复的，使用间隙锁和MVCC策略防止了幻读的出现。</strong></li>
<li>支持自动增长列`AUTO_INCREMENT·。自动增长列的值不能为空，且值必须唯一。MySQL中规定自增列必须为主键。</li>
<li>支持外键，保证数据的完整性和正确性。外键所在表为子表，外键所依赖的表为父表。父表中被子表外键关联的字段必须为主键</li>
<li><strong>支持行级锁，提高并发访问性能。</strong></li>
<li><strong>作为事务性存储，InnoDB通过一些机制和工具支持真正的热备份。</strong>（热备份是指在正常情况下,两余度同时工作,当某一余度出现故障时,系统可切除故障余度,启用单余度方式,降级工作.本系统采用热备份方式）</li>
</ul>
<h5 id="myisam">5.2 MyISAM</h5>
<p>MyISAM是MySQL早期的默认存储引擎。MyISAM将表存储在两个文件中：数据文件(<code>xxx.MYD</code>)和索引文件(<code>xxx.MYI</code>)。MyISAM不支持事务和行级锁，而且有一个致命的缺陷就是崩溃后无法安全恢复。</p>
<p><strong>MyISAM特点：</strong></p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>占用空间小，访问速度快 <img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/engine.png" width="700"></li>
</ul>
<h4 id="mysql的索引">6. MySQL的索引</h4>
<p>索引在MySQL中也叫<strong>键</strong>，是存储引擎用于快速找到记录的一种数据结构。因此索引对于数据库的性能非常关键，尤其是当表中的数据量越来越多时，索引对性能的影响愈发重要。总计索引的优点有三点：</p>
<ul>
<li>索引可以快速查询，大大减少了服务器查找时需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变成顺序I/O，如<code>order by</code>就是索引支持的</li>
</ul>
<p><strong>索引分类</strong>：</p>
<ul>
<li><strong>普通索引：</strong>是最基本的索引，主要其加快查询速度，可使用<code>key</code>或者<code>index</code>定义一个列的普通索引或联合普通索引。</li>
<li><strong>主键索引</strong>：即主键，一个表只能有一个主键，则也就只能有一个主键索引，不允许有重复值和<code>NULL</code>值。以<code>primary key</code>定义。</li>
<li><strong>唯一索引</strong>：不允许有重复值，但运行为<code>NULL</code>值，同时一个表可以有多个唯一索引。适用<code>unique key</code>或者<code>unique index</code>定义</li>
</ul>
<p><strong><em>注意</em></strong>：<code>key</code>和<code>index</code>的区别是，<code>key</code>除了会定义一个相应的索引之外，还会形成一种约束，约束该列的规范，比如<code>primary key</code>约束表只能有一个主键列，且不能重复不能为NULL，而<code>index</code>只是生成这一的一个索引。</p>
<h5 id="索引基础">6.1 索引基础</h5>
<p>理解索引当然是看例子更合适： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name from sahilia.actor where actor_id=<span class="number">5</span>;</span><br></pre></td></tr></table></figure> 上面这个检索语句中，如果在<code>actor_id</code>列上设有索引，则MySQL将使用索引找到<code>actor_id=5</code>的行，即MySQL会在索引上按值查找，然后返回该值的数据行。</p>
<p>索引可以包含一个或多个列(创建键)。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效的使用索引的<strong>最左前缀原则</strong>。需要明确的是<strong>最左前缀原则</strong>是发生在复合索引上的，只有复合索引才会有所谓的左和右之分，在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配</p>
<p><strong>mysql 建立多列索引（联合索引）有最左前缀的原则，即最左优先，如：</strong></p>
<ul>
<li>如果有一个 2 列的索引<code>(col1, col2)</code>，则已经对<code>(col1)、(col1, col2)</code>上建立了索引；</li>
<li>如果有一个 3 列索引<code>(col1, col2, col3)</code>，则已经对<code>(col1)、(col1, col2)、(col1, col2, col3)</code>上建立了索引；</li>
</ul>
<p><strong>原理</strong>：</p>
<p>B+树的数据项是复合的数据结构，比如<code>(name,age,sex)</code>的时候，B+树是按照从左到右的顺序来建立索引树的，比如当<code>(张三,20,F)</code>这样的数据来检索的时候，B+树就优先比较name来确定下一步的搜索方向，如果name相同则再依次比较<code>age</code>和<code>sex</code>，最后得到检索到的数据；但当<code>（20，F）</code>这样的没有<code>name</code>的数据来的时候，B+树就不知道第一步应该检查哪个节点，因此此时就不会使用联合索引。</p>
<h5 id="索引类型">6.2 索引类型</h5>
<p>索引有很多种类型，可以为不同的场景提高供更好的性能。在MySQL中，索引是在存储引擎实现的，因此没有统一的索引标准。下面介绍MySQL中的支持的索引类型。</p>
<h6 id="btree索引">6.2.1 B+Tree索引</h6>
<p>InnoDB使用的时B+Tree索引。这意味着所有的值都是按顺序存储的，<strong>且数据域都存储在叶子节点处，非叶子节点只存储索引不能存储数据</strong>，这样对于查询性能来说很稳定，都是<code>h</code>。B+Tree索引适用于全键值、键值范围或键前缀查找：比如定义了普通联合索引<code>key(last_name,first_name,birthday)</code></p>
<ul>
<li><strong>全值匹配：</strong>指的是和索引中的所有列进行匹配，即<code>last_name,first_name,birthday</code>均匹配</li>
<li><strong>匹配最左前缀</strong>：查找时，可以只列举第一列<code>last_name</code>进行查找</li>
<li><strong>匹配列前缀</strong>：也可只匹配某一列的值的开头部分，如寻找姓以<code>J</code>开头的数据</li>
<li><strong>匹配范围</strong>：对姓名<code>last_name</code>也支持范围查找。</li>
</ul>
<p><strong><em>注意：说到B+Tree的叶子节点，必须区分MySQL中的聚簇索引和非聚簇索引（二级索引），在聚簇索引的叶子节点存储的是完整的行数据，而二级索引叶子节点存储的是数据<code>行指针</code>,这里的<code>行指针</code>的实质是叶子节点保存只是行的主键值，因此非聚簇索引必须还要在聚簇索引结构上进行查找，这也是为什么它被称为二级索引</em></strong></p>
<p>更详细的B+Tree见：<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构</a></p>
<h6 id="哈希索引">6.2.2 哈希索引</h6>
<p><strong>哈希索引是基于哈希表实现的，因此对于使用哈希索引其关键字的存储是无序的，不支持范围匹配查找，只有精确匹配锁索引所有列的查询才有效。</strong>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码解决其存储的位置，因此其查找一个值的复杂度为<code>O(1)</code>，比B+Tree更快。</p>
<p>在MySQL中，只有Memory引擎显式支持哈希索引，也是其默认的索引类型。</p>
<p><strong>优点：</strong></p>
<ul>
<li>访问内存的速度很快，同时因为是通过计算哈希值来确定关键字位置，访问哈希索引的数据也很快</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不会存储字段值，所有不能使用索引中的值来避免读行。</li>
<li>哈希索引数据是按照计算的哈希值排列的，因此也就是无序的，不支持范围查找。</li>
<li>哈希索引不想B+Tree索引那样支持部分列查找，因为索引的哈希值是所有列共同计算的结果。</li>
<li>哈希冲突多的时候，维护操作的代价比较高昂。</li>
</ul>
<h5 id="为什么b树更适合做索引">6.3 为什么B+树更适合做索引</h5>
<p><strong>我们先分析B+Tree与众不同的特点：</strong></p>
<ul>
<li>第一个就是B+树在B树的基础之上最重要的改进就是非叶子结点只存储关键字和下一层的索引，不存储Data域，只在叶子结点存储Data域；</li>
<li>第二点就是所有叶子结点增加一个链指针，使所有叶结点构成一个有序链表，因此当我们需要有序遍历所有关键字时，直接从最小关键字的叶子结点开始遍历即可。</li>
</ul>
<h6 id="非叶子结点不存储data域的好处">6.3.1非叶子结点不存储Data域的好处</h6>
<ul>
<li><p><strong>每一个结点可以存放更多的关键字和下一层的索引。数据库是存储在磁盘上的，我们读取数据是从磁盘读取到内存中，我们在进行磁盘预读取时，是以块的单位进行数据读取，我们在检索B/B+树的结点时，每次以块为单位将一个结点读取到内存中，若一块磁盘包含了树结点以外的数据，就造成了浪费，因此我们需要使每一个结点的数据大小正好或者接近一块磁盘的大小</strong>。于是我们在构建B+/B树时，树的阶数其实就取决于一块磁盘中能容纳多少个关键字以及相关的索引和Data域。<strong>B+树的非叶子结点不存储Data域，因此它可以存储更多个关键字和下一层索引，因此B+树会比B树更宽胖</strong>。若我需要查找的关键字正好在叶子结点，B+树所进行的I/O次数更少,因为途中经过每一层，我们都需要进行一次I/O读取一个结点，B+树会更矮，途径的层数会更少。</p></li>
<li><p>使得B+树查询速度更稳定，B+树所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p></li>
</ul>
<h6 id="所有叶结点构成一个有序链表的好处">6.3.2所有叶结点构成一个有序链表的好处</h6>
<ul>
<li><p><strong>B+树便于区间查找（这点才是B+树作为索引的关键）</strong>，我们进行数据库查询大多为区间查询，B+树天然具备排序功能，B+树所有的叶子结点构成了一个有序链表，在查询大小区间的数据时候更方便，B+树查询，只需通过头结点往下找到第一个叶子结点，然后在叶子结点的链表上就行遍历即可完成区间查询，而B树的关键字大小相邻近的结点可能隔得很远，要想进行区间查询需要不停的进行中序遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li>
<li><p>B+树全结点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要进行中序遍历，这有利于数据库做全表扫描。</p></li>
</ul>
<p><strong>总结B+树优点(选择B+树作为索引的原因)</strong></p>
<ul>
<li>因为没有非叶子节点没有存储数据，因此单一非叶子结点能存储更多的关键字索引</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；</li>
<li>所有叶子节点形成有序链表，便于范围查询以及全结点遍历更快。</li>
</ul>
<h5 id="高性能的索引策略">6.4 高性能的索引策略</h5>
<p>正确的创建和使用索引是实现高性能查询的基础。创建索引是最忌讳的就是为每一个列都建上独立的索引或者按照错误的顺序创建联合索引，这样会大大降低性能。</p>
<h6 id="选择合适的索引序列">6.4.1 选择合适的索引序列</h6>
<p>对于B+Tree多列索引来说，按照其最左前缀匹配原则，正确的的顺序依赖于使用哪些列选择性高，同时还有考虑如何更好的满足排序和分组的需要，即满足<code>order by\group by\distinct</code>查询子句的查询需求。</p>
<p><strong>有一条经验法则：将选择性最高的列放在索引的最前面。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">count</span><span class="params">(distinct staff_id)</span>/<span class="title">count</span><span class="params">(*)</span> as staff_id_selectivity,</span></span><br><span class="line"><span class="function">	-&gt; <span class="title">count</span><span class="params">(distinct customer_id)</span>/<span class="title">count</span><span class="params">(*)</span> as customer_id_selectivoty,</span></span><br><span class="line"><span class="function">	-&gt; <span class="title">count</span><span class="params">(*)</span></span></span><br><span class="line"><span class="function">	-&gt; from payment</span>;</span><br><span class="line">-------------------------------输出--------------------------------------------------*</span><br><span class="line">staff_id_seletivity:<span class="number">0.0001</span></span><br><span class="line">customer_id_selectibity:<span class="number">0.0373</span></span><br><span class="line"><span class="built_in">count</span>(*):<span class="number">16049</span></span><br></pre></td></tr></table></figure> 从上面可以看到选择性更高的是<code>customer_id</code>，因此将其放在索引第一列： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">alter table payment add <span class="title">key</span><span class="params">(customer_id,staff_id)</span></span>;</span><br></pre></td></tr></table></figure> 最后还要说一句尽管这条关于选择性和基数的经验法则对于一般情况适用，但是别忘了还要考虑<code>where</code>子句当中的排序、分组和范围查询，要对这些折中考虑。</p>
<h5 id="聚簇索引">6.5 聚簇索引</h5>
<p>首先要明白的是聚簇索引不是开始说到的属于<strong>普通索引、唯一索引和主键索引的分类</strong>，MySQL的索引分类只有这三种。<strong>聚簇索引并不是一个单独索引类型，而是一种数据的存储方式的专有名词</strong>。</p>
<p><strong>对于InnoDB来说，InnoDB就会选择一个唯一的非空索引作为聚簇索引，当没有符合的唯一非空索引，就会隐式的定义一个主键来作为聚簇索引</strong>，因此一般情况你也可以理解主键就是聚簇索引；但是，有些时候唯一索引也有可能是聚簇索引</p>
<h6 id="聚簇索引与非聚簇索引的区别">6.5.1 聚簇索引与非聚簇索引的区别</h6>
<p>在上面说到B+Tree的时候已经介绍到了聚簇索引和非聚簇索引之间的区别，这里在系统的总结一下。</p>
<ul>
<li><strong>首先就是一张表只有有一个聚簇索引，但可以有多个非聚簇索引</strong></li>
<li><strong>另外聚簇索引的叶子节点存储的是完整的行数据，而非聚簇索引的叶子节点存储的是其相应主键列的关键字值，因此使用非聚簇索引进行查询时，除了查询非聚簇索引得到主键关键字值外，还要利用该值进行回表查询聚簇索引，最终得到整个行数据</strong>，这也是非聚簇索引又叫二级索引的由来。</li>
</ul>
<p><img src="/2022/08/04/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/aindex.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用主键索引(聚簇索引)查询</span></span><br><span class="line">select * from table where ID = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//使用非聚簇索引查询</span></span><br><span class="line">select * from table where k = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="聚簇索引的优缺点">6.5.2 聚簇索引的优缺点</h6>
<p>聚簇索引可能对性能有帮助，但也会导致严重的问题，下面分析其优缺点</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>聚簇索引的存在将相关数据都保存在一起，磁盘一次I/O就获得所有数据</strong>，如用户邮箱的管理，以ID为主键形成聚簇索引结构，则更加ID用户将其相关的数据都聚簇在叶子节点，可一下获得其所有数据。如果没有聚簇索引，则要获取该ID的所有信息要经过多次磁盘I/O</li>
<li><strong>数据访问速度更快，聚簇索引将索引和数据保存在同一个B+Tree上，因此聚簇索引比非聚簇索引的查询更快。</strong></li>
<li>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p><strong>插入速度严重依赖插入的顺序，其存储结构说明了按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式</strong>。如果不是按照逐渐顺序，会慢很大，而且最坏使用<code>optimize table</code>重新组织一下表。</p></li>
<li><p>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</p></li>
<li><p>更新行或插入行被强制移动带新的行，如果是要插入满行的一页，则会导致<code>页分类</code>。存储引擎通过页分裂称两个页面以能够存储该行，一次页分裂操作，导致表占有更多的空间。</p></li>
</ul>
<h5 id="覆盖索引">6.6 覆盖索引</h5>
<p>上面提到了二级索引想要查询行的所有列必须进行回表查询，有没有什么办法不用回表查询就能得到一些列的信息呢。这是要就用到了<strong>覆盖索引</strong>，<strong>如果一个索引包含了所有要查询字段的值，就称为为覆盖索引</strong>。在<code>select</code>前使用<code>explain</code>表示优先使用覆盖索引</p>
<p>不是所有的索引类型都能成为覆盖索引，覆盖索引必须存储该索引所在行的值，而像哈希索引、空间索引这些都不能存储。因此MySQL只有B+Tree索引能使用覆盖索引。现在来讲解覆盖索引的实现要求：</p>
<ul>
<li>表有除一个主键索引，其他列建立相应的零和索引，这一才能在二级索引存储有其他列的值。对于主键很明显在二级索引的叶子节点上</li>
<li>在<code>select</code>上使用<code>explain</code>，优先使用覆盖索引</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lengyue1084/article/details/119352209">覆盖索引详解</a></p>
<h5 id="冗余索引">6.7 冗余索引</h5>
<p>同一信息的重复储存，叫做冗余,冗余索引通常发生在为表添加新索引的时候。如<code>key(name,city)</code>和<code>key(name)</code>这两个索引就是冗余索引，能够命中后者的查询肯定能够命中前者。</p>
<p>大多数情况下我们都不需要冗余索引，因为索引的维护需要一定的开销。但有时候却页不得不创建一个冗余索引，就比如新加了一个字段，同时现有的联合索引已经非常庞大，如果再将这字段加入这个联合索引就会使得该联合索引更加庞大，此时使用新建冗余索引更好。</p>
<h4 id="优化查询">7. 优化查询</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/" class="post-title-link" itemprop="url">Linux操作系统_2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-30 22:29:06 / 修改时间：22:31:44" itemprop="dateCreated datePublished" datetime="2022-07-30T22:29:06+08:00">2022-07-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/" class="post-title-link" itemprop="url">Linux操作系统_1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-30 22:28:49 / 修改时间：22:31:06" itemprop="dateCreated datePublished" datetime="2022-07-30T22:28:49+08:00">2022-07-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 21:59:16" itemprop="dateCreated datePublished" datetime="2022-07-30T21:59:16+08:00">2022-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-05 22:38:42" itemprop="dateModified" datetime="2022-08-05T22:38:42+08:00">2022-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="了解sql">1. 了解SQL</h4>
<h5 id="数据库基础">1.1 数据库基础</h5>
<p>数据库是一个以某种有组织的方式存储的数据集合。<code>MySQL</code>数据库中只有一个用户，名为<code>root</code>，但是它可以有多个数据库，如下是与<code>Oracle</code>数据库的不同之处： <img src="/2022/07/30/MySQL/different.png" width="700"></p>
<h6 id="表的概念">1.1.1 表的概念</h6>
<p>在数据库中，<strong>表是一种结构化的文件，用来存储某种特定类型的数据</strong>。数据库中的表都有一个唯一名字来标识自己，称为<strong>表名</strong>。同时表具有一些特性，这些特性定义了数据在表中如何存储，可以存储什么样的数据，数据如何分解、各部分信息如何让命名等等。</p>
<p>描述表的这组信息就是所谓的<strong>模式</strong>，模式即指关于数据库和表的布局以及特性的信息。</p>
<h6 id="列和数据类型">1.1.2 列和数据类型</h6>
<p><strong>表由列组成，列就是表中的一个字段</strong>。列中存储着表的某部分信息，数据库中的列都有相应的类型，数据类型定义了列中可以存储的数据种类。</p>
<h6 id="行">1.1.3 行</h6>
<p><strong>虽然表由列组成，但存储过程中，表中的数据是按行存储的</strong>。每次保存的记录都存储在自己所在的行中，你也可以理解为行就是表中的一个记录。</p>
<h6 id="主键">1.1.4 主键</h6>
<p><strong>表中的每一行都应该有唯一标识自己的一列，这样搜索起来才不容易出错，保证数据的完整性</strong>，就如一个顾客列表可以使用顾客编号来作为主键,如果使用顾客姓名来搜索，万一有相同姓名的顾客搜索就容易混淆。<strong>因此对于每创建一个表来说都应该至少设置一列为主键</strong>，作为主键的列必须满足：</p>
<ul>
<li>任意两行都不具有相同的主键值</li>
<li>每一行都必须具有一个主键值（主键列不允许为NULL值）</li>
</ul>
<p>主键虽然通常定义在表的一列上，但是也可以使用多个列作为主键</p>
<h6 id="外键">1.1.5 外键</h6>
<p><strong>外键就是某个表中被定义为外键的一列，它包含另一个表的主键值</strong>，定义两个表之间的关系，一个表中可以有多个外键。其作用主要有：</p>
<ul>
<li>不用重复存储另一个表中有的数据到本表，只需通过外键建立连续即可，节省了时间和空间</li>
<li>同时在删除中必须先删除外键才能删除主键，因此能保证数据的完整性</li>
</ul>
<h4 id="mysql的安装和修改">2. MySQL的安装和修改</h4>
<p>在ubuntu中可以使用<code>sudo apt install mysql-server</code>进行安装MySQL数据库。以下是对数据库的的初始化必做事项 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#进入本地数据库shell界面</span><br><span class="line">mysql -u root -p</span><br><span class="line">#进入其他主机的数据库shell</span><br><span class="line">mysql -h 192.168.18.251 -u root -p</span><br><span class="line">#修改密码</span><br><span class="line">mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<h5 id="启动和关闭mysql服务器">2.1 启动和关闭MySQL服务器</h5>
<p>MySQLS数据库分为客户端和服务器，<code>mysql-server</code>与<code>mysql-client</code>是DBMS的两个面向不同操作对象的工具。<code>server</code>是DBMS面向物理层次，包含存储数据的一系列机制、处理方法的集成；<code>client</code>是DBMS面向用户，提供一系列工具为用户所用，这些工具包括通常写的<code>sql</code>在内都要通过<code>server</code>的编译才能操作物理数据。即在连接服务器时要先开启<code>mysql-server</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种启动mysql服务器方法</span></span><br><span class="line">service mysql start</span><br><span class="line">systemctl statrt mysql</span><br><span class="line">systemctl restart mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看状态</span></span><br><span class="line">systemctl status mysql.service</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭服务器</span></span><br><span class="line">systectl stop mysql</span><br><span class="line">service mysql stop</span><br></pre></td></tr></table></figure>
<p><strong>注意数据库shell界面</strong>，<code>shell</code>界面是<code>mysql-client</code>提供了一种人与<code>mysql</code>直接交互的命令窗口，同Linux的<code>bashShell</code>是一样的。</p>
<h5 id="其他对数据库的操作">2.2 其他对数据库的操作</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#展示目前数据库目录</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.05 sec)</span><br><span class="line"></span><br><span class="line">#创建数据库:创建一个使用utf-8字符集，并带校对规则的mydb3数据库。会对存入的数据进行检查。</span><br><span class="line">mysql&gt; create database mydb3 character set utf8 collate utf8_general_ci;</span><br><span class="line">Query OK, 1 row affected, 2 warnings (0.03 sec)</span><br><span class="line"></span><br><span class="line">#修改数据库</span><br><span class="line">mysql&gt; alter database test character set utf8;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.05 sec)</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mydb3              |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">#选择test数据库</span><br><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">#删除数据库</span><br><span class="line">mysql&gt; drop database mydb3;</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="表的创建修改和删除">2.3 表的创建、修改和删除</h5>
<p>本节主要简单介绍对表的操作关键字和相应的数据库数据类型，让读者对表创建有一个总体的认识。能够简单创建表，提升性能的表创建方法后续才会介绍到。在创建表之前，必须选择对哪一个数据库操作 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure></p>
<h6 id="mysql的数据类型">2.3.1 MySQL的数据类型</h6>
<p>数据类型是定义该列可以存储的数据以及该数据实际怎样存储的法则</p>
<p><strong>1. 串数据类型</strong> <img src="/2022/07/30/MySQL/string.png" width="700"></p>
<p><strong>2. 数值数据类型</strong> <img src="/2022/07/30/MySQL/digit.png" width="700"></p>
<p><strong>3. 日期和时间数据类型</strong> <img src="/2022/07/30/MySQL/date.png" width="700"></p>
<p><strong>4. 二进制数据类型</strong>：可以存储任何数据，如图像、多媒体、字处理文档等 <img src="/2022/07/30/MySQL/binary.png" width="700"></p>
<ul>
<li><code>bit</code>：1位，可以指定位数，如：<code>bit(3)</code></li>
<li><code>int</code>：2字节可以指定最大位数，如<code>int&lt;4&gt;</code>,最大为4位的整数</li>
<li><code>float</code>：2个字节,可以指定最大的位数和最大的小数位数，如：<code>float&lt;5,2&gt;</code> 最大为一个5位的数，小数位最多2位</li>
<li><code>double</code>：4个字节,可以指定最大的位数和最大的小数位数，如：<code>float&lt;6,4&gt;</code>最大为一个6位的数，小数位最多4位</li>
<li><code>char</code>：必须指定字符数,如<code>char(5)</code>,为不可变字符　即使存储的内容为'ab',也是用5个字符的空间存储这个数据</li>
<li><code>varchar</code>：必须指定字符数,如varchar(5) 为可变字符　如果存储的内容为'ab',占用2个字符的空间；如果为'abc',则占用3个字符的空间</li>
<li><code>text</code>: 大文本(大字符串)</li>
<li><code>blob</code>：二进制大数据,如图片，音频文件，视频文件</li>
<li><code>date</code>: 日期　如：'1921-01-02'</li>
<li><code>datetime</code>: 日期+时间　如：'1921-01-02 12:23:43'</li>
<li><code>timeStamp</code>: 时间戳，自动赋值为当前日期时间</li>
</ul>
<h6 id="创建表">2.3.2 创建表</h6>
<p>创建表使用<code>create table</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#创建CUSTOMER表，以ID作为主键，同时指示除SALARY外其他都不能为NULL</span><br><span class="line">mysql&gt; CREATE TABLE IF NOT EXISTS CUSTOMER(</span><br><span class="line">    -&gt; NAME VARCHAR(20) NOT NULL, </span><br><span class="line">    -&gt; ID VARCHAR(30) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; SALARY DOUBLE NULL,</span><br><span class="line">    -&gt; HIREDATE DATE NOT NULL,</span><br><span class="line">    -&gt; PRIMARY KEY (ID)</span><br><span class="line">    -&gt; )ENGINE=InnoDB;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure> <strong>这里有几个关键字需要介绍</strong>：</p>
<ul>
<li><p><code>NULL</code>和<code>NOT NULL</code>:这两个关键字指示我们在插入记录对于该列来说，如果是<code>NOT NULL</code>,则插入记录时该列必须要有数据，否则会报错，而<code>NULL</code>修饰的列可以允许插入的记录在该列为空。</p></li>
<li><p><code>AUTO_INCREMENT</code>:在上述的表中<code>ID</code>是标识顾客的唯一编号，它们可以任意但是必须唯一，如果认为指定那么很难维护，<code>AUTO_INCREMENT</code>则是告诉MySQL本列每增加一行时自动增量，即每次执行一个<code>insert</code>,对该列增量。</p></li>
<li><p><code>PRIMARY KEY()</code>:指示使用哪一个或哪几个字段作为主键</p></li>
<li><p><code>ENGINE=InnoDB</code>:指示使用的引擎类型为<code>InnoDB</code> ，关于引擎类型后续会讲到</p></li>
</ul>
<h6 id="更新表">2.3.3 更新表</h6>
<p>有时候我们创建了表，但是对于表的字段列需要添加或者删除操作，这时候就用到了<strong>表更新</strong>这个概念，更新表使用<code>alter table CUSTOMER add/drop ID VARCHAR(40) NOT NULL</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#添加列</span><br><span class="line">mysql&gt; alter table CUSTOMER add marriage VARCHAR(5) NULL;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">#删除列</span><br><span class="line">mysql&gt; alter table CUSTOMER DROP MARRIAGE;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">#修改列</span><br><span class="line">alter table employee modify column height float;</span><br><span class="line">#修改表的字符集:</span><br><span class="line">alter table employee character set gbk;</span><br></pre></td></tr></table></figure></p>
<h6 id="删除表">2.3.4 删除表</h6>
<p>删除数据库中的表使用<code>drop table</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE CUSTOMER;</span><br></pre></td></tr></table></figure></p>
<h6 id="重命名表">2.3.5 重命名表</h6>
<p>如果相对表的名字重命名则可使用<code>rename</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; rename table CUSTOMER TO customer;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; show tables</span>;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| customer       |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="显示表结构">2.3.6 显示表结构</h6>
<p>如果想对表的结构字段名、类型等了解，可通过<code>describe</code>来显示表结构： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; describe customer;</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| NAME     | <span class="built_in">varchar</span>(<span class="number">20</span>) | NO   |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">| ID       | <span class="built_in">varchar</span>(<span class="number">30</span>) | NO   | PRI | <span class="literal">NULL</span>    |       |</span><br><span class="line">| SALARY   | <span class="type">double</span>      | YES  |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">| HIREDATE | date        | NO   |     | <span class="literal">NULL</span>    |       |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.02</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="sql常用语句">3. SQL常用语句</h4>
<p>对于数据库来说，对数据库的操作离不开最重要的语句，而SQL语句就是对数据库操作的主流语言，可以说数据库和结构化查询语言<code>SQL</code>几乎是同义词，谈到<code>SQL</code>就当相于是在说数据库了。在数据库的操作中最常用的就是<strong>查询<code>select</code>,插入<code>insert into</code>，修改<code>update</code>和删除<code>delete</code>。</strong>也就是增删改差</p>
<h5 id="select语句">3.1 select语句</h5>
<p><code>select</code>是数据库中最常用的语句，它能从一个表或多个表中检索数据，使用<code>select</code>至少给出两个信息：一是要检索什么，从什么地方检索：<code>select what from where;</code>。<strong>你可以看作调用<code>select</code>会生成一个临时表作为结果集输出。</strong></p>
<p>如下是最简单的两句查询语句： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//产看该表所有数据</span><br><span class="line">select * from employee;</span><br><span class="line">//查看特定数据</span><br><span class="line">select name 姓名,birthday 出生日期 from employee where sal=15500;</span><br></pre></td></tr></table></figure> 上面的两条语句中：<strong>第一条既没有过滤也没有对查询结果排序</strong>，通常来说都不会使用如下低效的查询语句；<strong>第二句虽然增加了过滤条件<code>sal=15500</code>,也使用文字显示代替<code>name</code>和<code>birthday</code>作为输出界面，但是也没有对结果排序</strong></p>
<h6 id="distinct关键字">3.1.1 distinct关键字</h6>
<p>如果一个表中的一列不是主键有多个相同的值，但是我们又想查询结果只显示不同的值，这个使用就要使用到<code>distinct</code>关键字 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤表中重复数据。</span></span><br><span class="line">select DISTINCT english from student;</span><br><span class="line">select DISTINCT english,name from student;</span><br></pre></td></tr></table></figure></p>
<h6 id="limit关键字">3.1.2 limit关键字</h6>
<p>如果我们对检索的结果不要求其返回太多话，或者是限定其应该返回几行，这个时候就应该使用<code>limit</code>关键字:</p>
<ul>
<li><code>limit</code>后带一个数字的表示最多返回多少行</li>
<li><code>limit</code>后面带两个数字的表示从检索结果的的几行开始和返回的最多行数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer limit <span class="number">5</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">mysql&gt; select * from customer limit <span class="number">5</span>,<span class="number">5</span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br></pre></td></tr></table></figure>
<h6 id="order-by关键字">3.1.3 order by关键字</h6>
<p>一般来说，如果<code>select</code>语句没有对数据进行排序，则默认使用的数据在底层表中出现的顺序而显示，它可能是数据最初添加到表的顺序，但是一旦你进行过更新和删除，这个顺序就会受到MySQL重用回收存储空间的影响。因此应该采用关键字<code>order by</code>对检索结构进行排序。</p>
<ul>
<li>当<code>order by</code>后面只有一个字段名是，按该字段排序</li>
<li>当<code>order by</code>后面跟着多个字段名排序，首先是按照第一个字段排序，然后看排序后是否有相同的第一个字段值的记录，如果有，则对有相同第一个字段值的记录进行第二个字段排序。</li>
<li>默认情况下，使用的是升序排序，如果相要使用降序排序，则应该在后面添加<code>desc</code>,如<code>...order by name DESC;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name 姓名 from customer order by name;</span><br><span class="line">+---------+</span><br><span class="line">| 姓名    |</span><br><span class="line">+---------+</span><br><span class="line">| jack    |</span><br><span class="line">| lili    |</span><br><span class="line">| tom     |</span><br><span class="line">| trl     |</span><br><span class="line">| trluper |</span><br><span class="line">| 小明    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<h6 id="where关键字">3.1.4 where关键字</h6>
<p>在上面首次介绍<code>select</code>时，我们已经使用了<code>where</code>关键字，<code>where</code>关键字时对检索记录的一个筛选，只有符合<code>where</code>后面的条件才会输出这些记录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#普通条件显示</span><br><span class="line">mysql&gt; select * from customer where salary&gt;=<span class="number">15000</span> order by salary desc;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#非空显示</span></span><br><span class="line"><span class="function">mysql&gt; select * from customer where salary is <span class="keyword">not</span> null</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<p>在这里我们还需要介绍能够与<code>where</code>组合的更高级的过滤语句关键字<code>and、or</code>。上面使用<code>where</code>都是单一条件,如果要求要符合多个条件的使用怎么办？那当然是使用<code>and\or</code>来解决</p>
<ul>
<li><code>and</code>：同c++中的<code>&amp;&amp;</code>起一样的作用，优先级高于<code>or</code></li>
<li><code>or</code>：同c++中的<code>||</code>起一样的作用</li>
</ul>
<h6 id="in关键字">3.1.5 IN关键字</h6>
<p><code>IN</code>操作符用来指定条件的范围，范围中的每个条件都可以进行匹配，它的功能与<code>or</code>很相像，使用<code>IN</code>是因为：</p>
<ul>
<li>在使用长的合法选项清单是，<code>IN</code>操作符更加直观清楚，语句也不如<code>or</code>那样长冗余。</li>
<li>在使用<code>IN</code>时，计算的次序更容易管理</li>
<li><code>IN</code>操作一般比<code>or</code>操作符清单执行的更快</li>
<li><code>IN</code>操作符最多的优点是可以包含其他<code>select</code>语句，更加动态的建立<code>where</code>子句。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select * from customer where salary <span class="title">in</span><span class="params">(<span class="number">12000</span>,<span class="number">15000</span>,<span class="number">25000</span>)</span></span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| jack    | <span class="number">1</span>  |  <span class="number">12000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    | <span class="number">3</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    | <span class="number">4</span>  |  <span class="number">15000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<h6 id="not关键字">3.1.6 NOT关键字</h6>
<p><code>NOT</code>关键字有且只有一个功能，那就是否定它之后的紧跟的条件，NOT肯对<code>and、or</code>没什么用，但是对于<code>IN</code>来说却是绝配。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select * from customer where salary <span class="keyword">not</span> <span class="title">in</span><span class="params">(<span class="number">12000</span>,<span class="number">15000</span>,<span class="number">25000</span>)</span></span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| tom  | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="like和通配符">3.1.7 LIKE和通配符</h6>
<p><strong>通配符</strong>指的是用来匹配一部分的特殊字符；<strong>搜索模式</strong>则是指在搜索语句中使用字面值、通配符或两者组合成的搜索条件。<strong>使用通配符是必须在前面使用<code>LIKE</code>关键字，该关键字告诉MySQL后面跟着的搜索模式是使用通配符匹配而不是直接使用字面值匹配</strong></p>
<ul>
<li><code>%</code>通配符：该通配符是最常使用的，它可以表示任意字符出现任意次数，如<code>trl%</code>表示以<code>trl</code>开头的任意名称</li>
<li><code>_</code>通配符：同<code>%</code>是一样的作用，但是只匹配单个任意字符，即只匹配一次。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer where name like <span class="string">&#x27;trl%&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p>虽然通配符很有用，但是代价是很大的，它的搜索一般比前面的其他搜索所花时间更多，一般来说使用通配要遵循以下技巧：</p>
<ul>
<li>尽量不使用，如果有其他操作符能够达到相同效果，则应该使用这些操作符</li>
<li>假如一定要使用，则不要把通配符放在搜索模式的开始处，因为这样的搜索极慢</li>
</ul>
<h6 id="select支持算术运算">3.1.8 select支持算术运算</h6>
<p>对于MySQL中的数字类型，运行使用<code>* + - /</code>运算。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select salary,add_salary,salary+add_salary as finalSalary from custommer order by id;</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line">| salary | add_salary | finalSalary |</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line">|  <span class="number">12000</span> |        <span class="number">300</span> |       <span class="number">12300</span> |</span><br><span class="line">|  <span class="number">12500</span> |        <span class="number">300</span> |       <span class="number">12800</span> |</span><br><span class="line">|  <span class="number">15000</span> |        <span class="number">300</span> |       <span class="number">15300</span> |</span><br><span class="line">|  <span class="number">15000</span> |        <span class="number">300</span> |       <span class="number">15300</span> |</span><br><span class="line">|  <span class="number">25000</span> |        <span class="number">300</span> |       <span class="number">25300</span> |</span><br><span class="line">|  <span class="number">16000</span> |        <span class="number">300</span> |       <span class="number">16300</span> |</span><br><span class="line">+--------+------------+-------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="正则表达式进行搜索">3.2 正则表达式进行搜索</h5>
<p>前面介绍的过滤使用匹配、比较和通配符进行操作寻找符合的数据，对于一些基本情况来说足够了，但是随着过滤条件的增加，<code>where</code>子句本身的复杂性也在增加，这时候就应当使用正则表达式匹配。<strong>使用正则表达式必须在正则表达式（文本）前面使用<code>regexp</code>关键字，同·<code>like</code>一样告诉MySQL后面使用正则表达式进行匹配</strong>。</p>
<p>注意在正则表达式中，对于有特殊意义的符号，如果你不希望他被翻译成则表示里的特殊符号，应该加<code>\\</code>进行转义，如<code>. | []</code>这些通过<code>\\. \\| \\[\\]</code>经过转义后才能被认为是字符串的一部分。</p>
<h6 id="section">3.2.1 |</h6>
<p>在正则表达式中<code>|</code>上面的<code>or</code>是起到一样的作用 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer where name regexp <span class="string">&#x27;trl|tom&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| tom     | <span class="number">2</span>  |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<h6 id="section-1">3.2.2 []</h6>
<p><code>[]</code>的作用是匹配方括号内的字符之一，如<code>[123]</code>是指匹配1或2或3，同样为省略书写也可以写出<code>[1-3]</code>是同样的表示。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from customer where name regexp <span class="string">&#x27;[a-z]rl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br></pre></td></tr></table></figure></p>
<h6 id="section-2">3.2.3</h6>
<p><code>.</code>也是正则表达式中一个特殊字符，它表示匹配任意一个字符。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;.rl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------|</span><br></pre></td></tr></table></figure></p>
<h6 id="匹配字符类">3.2.4 匹配字符类</h6>
<p>MySQL中存在一些已经定义的字符集，这样就不用你自己手动去阻止这些字符集 <img src="/2022/07/30/MySQL/charSet.png" width="700"></p>
<h6 id="匹配多个字符">3.2.5 匹配多个字符</h6>
<p>至今为止，上面介绍的都是匹配单个字符的情况，是否有匹配多个字符的正则表达式特殊字符呢，当然是有的。 <img src="/2022/07/30/MySQL/muchChar.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;trl*&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意这里的重复元字符是指能够匹配当前元字符的前一个字符的多个重复值，如<code>trl*</code>,匹配<code>trl\trll\trll\trlll...\..</code>等</p>
<h6 id="定位符">3.2.6 定位符</h6>
<p>到目前为止，上面的匹配规则都是匹配一个串中任意一个为止的文本，为了能够指定匹配的为止，给出了定位符： <img src="/2022/07/30/MySQL/locate.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from customer where name regexp <span class="string">&#x27;^trl&#x27;</span>;</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| NAME    | ID | SALARY | HIREDATE   |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line">| trluper | <span class="number">5</span>  |  <span class="number">25000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+----+--------+------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select *from customer where name regexp &#x27;^trl$&#x27;</span>;</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| NAME | ID | SALARY | HIREDATE   |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line">| trl  | <span class="number">6</span>  |  <span class="number">16000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+------+----+--------+------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure> 一般来说，其他的正则表达式字符都应当与定位符结合使用</p>
<h5 id="insert语句">3.3 insert语句</h5>
<p>插入数据使用<code>insert into</code>，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入完整数据</span></span><br><span class="line"><span class="function">insert into employee <span class="title">values</span><span class="params">(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="number">15000</span>,<span class="string">&#x27;1998-05-09&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;2021-1-9&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//与select结合使用</span></span><br><span class="line"><span class="function">insert into  <span class="title">employee</span><span class="params">(id,name,salary,birthday,rank,hiredate)</span> select id,name,salary,birthday,rank,hiredate from employee_1 where name</span>=<span class="string">&#x27;trluper&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="update语句">3.4 update语句</h5>
<p>修改更新数据使用<code>update</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update customer set salary=salary+<span class="number">500</span>;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: <span class="number">6</span>  Changed: <span class="number">6</span>  Warnings: <span class="number">0</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="delete语句">3.5 delete语句</h5>
<p><code>delete</code>用来删除记录 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除所有数据</span></span><br><span class="line"><span class="keyword">delete</span> from employee;</span><br><span class="line"><span class="comment">//删除指定数据</span></span><br><span class="line"><span class="keyword">delete</span> form employee where name=<span class="string">&#x27;jack&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用truncate删除表中记录。无条件 效率高</span></span><br><span class="line">truncate table employee;</span><br></pre></td></tr></table></figure></p>
<h4 id="函数">4. 函数</h4>
<p>有时候，我们对于搜索到的列的一些东西需要得到总和、平均和拼接，总之，我们不希望查找后的结果仍然是以底层表所存储的那样呈现上来,<strong>而是希望在<code>select</code>运行阶段经过处理后得到我们想要的结果，这时候就用到了想要的MySQL函数。</strong>大多数SQL支持以下函数：</p>
<ul>
<li>用于处理文本串的文本函数，如删除或填充、大小写转换等。</li>
<li>用于数值数据进行算术的操作，如绝对值、求和等</li>
<li>用于处理日期和时间值并从时间值提取特定成分</li>
<li>返回DBMS正使用的特殊信息的系统函数，如返回登录信息、检查版本细节等</li>
</ul>
<h5 id="拼接字段">4.1 拼接字段</h5>
<p>假如我们想在<code>select</code>中让输出的结果的一个字段即显示<code>name</code>又显示<code>salary</code>,而不是分开两个字段显示，这样就用到了<code>concat()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">concat</span><span class="params">(name,<span class="string">&#x27;:&#x27;</span>,salary,<span class="string">&#x27; &#x27;</span>,hiredate)</span> as &#x27;name:salary hiredate<span class="string">&#x27;&#x27; from customer order by id;</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">| name:salary hiredate     |</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">| jack:12000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| tom:12500 2022-08-03     |</span></span></span><br><span class="line"><span class="string"><span class="function">| lili:15000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| 小明:15000 2022-08-03    |</span></span></span><br><span class="line"><span class="string"><span class="function">| trluper:25000 2022-08-03 |</span></span></span><br><span class="line"><span class="string"><span class="function">| trl:16000 2022-08-03     |</span></span></span><br><span class="line"><span class="string"><span class="function">+--------------------------+</span></span></span><br><span class="line"><span class="string"><span class="function">6 rows in set (0.00 sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：</em></strong>在MySQL中拼接两个字段只能使用<code>concat()</code>函数，而在其他的数据库中则运行使用<code>+</code>直接拼接。</p>
<h5 id="文本处理函数">4.2 文本处理函数</h5>
<p><img src="/2022/07/30/MySQL/stringFunc.png" width="700"></p>
<h5 id="日期和时间处理函数">4.3 日期和时间处理函数</h5>
<p><img src="/2022/07/30/MySQL/dateFunc.png" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">select <span class="title">now</span><span class="params">()</span>,<span class="title">year</span><span class="params">(now())</span> as 年,<span class="title">month</span><span class="params">(now() )</span>as 月,<span class="title">date</span><span class="params">(now())</span> as 日</span>; </span><br><span class="line">+---------------------+------+------+------------+</span><br><span class="line">| <span class="built_in">now</span>()               | 年   | 月   | 日         |</span><br><span class="line">+---------------------+------+------+------------+</span><br><span class="line">| <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">25</span> | <span class="number">2022</span> |    <span class="number">8</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------------------+------+------+------------+</span><br></pre></td></tr></table></figure></p>
<h5 id="数值处理函数">4.4 数值处理函数</h5>
<p><img src="/2022/07/30/MySQL/numberFunc.png" width="700"></p>
<h5 id="汇总函数">4.5 汇总函数</h5>
<p>有时候我们需要对表中的数据进行汇总，而不是把它们实际检索出来，这时候就需要这样的函数，因此MySQL专门设立了<strong>汇总函数</strong> <img src="/2022/07/30/MySQL/finalFunc.png" width="700"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#统计一个班级共有多少学生？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student</span>;</span><br><span class="line">#统计数学成绩大于<span class="number">90</span>的学生有多少个？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student where math&gt;90</span>;</span><br><span class="line">#统计总分大于<span class="number">250</span>的人数有多少？</span><br><span class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from student where math+chinese+english&gt;250</span>;</span><br><span class="line">#统计一个班级数学总成绩？</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span> from student</span>;</span><br><span class="line">#统计一个班级语文、英语、数学各科的总成绩</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span>, <span class="title">sum</span><span class="params">(chinese)</span>, <span class="title">sum</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#统计一个班级语文、英语、数学的成绩总和</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math+chinese+english)</span>from student</span>;</span><br><span class="line"><span class="function">select <span class="title">sum</span><span class="params">(math)</span>+<span class="title">sum</span><span class="params">(chinese)</span>+<span class="title">sum</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#求一个班级数学平均分？</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math)</span> from student</span>;</span><br><span class="line">#求一个班级总分平均分</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math+chinese+english)</span>from student</span>;</span><br><span class="line"><span class="function">select <span class="title">avg</span><span class="params">(math)</span>+<span class="title">avg</span><span class="params">(chinese)</span>+<span class="title">avg</span><span class="params">(english)</span> from student</span>;</span><br><span class="line">#求班级最高分和最低分</span><br><span class="line"><span class="function">select <span class="title">max</span><span class="params">(math+chinese+english)</span>,<span class="title">min</span><span class="params">(math+chinese+english)</span> from student</span>;</span><br></pre></td></tr></table></figure>
<h4 id="其他查询操作">4. 其他查询操作</h4>
<p>在这里将会介绍分组查询、子查询和组合查询等查询手段，进一步掌握查询检索方法。</p>
<h5 id="分组查询">4.1 分组查询</h5>
<p>分组查询得关键字为<code>group by</code>，使用该关键字能够使得检索后得结果按照你想要得情况进行分组,<strong>下述得<code>group by</code>句子指示是按<code>salary</code>排序并分组</strong>,这样一来我们就不用一一调用<code>select salary count(*) where salary=各个数值;</code>语句，只需要以<code>group by</code>就能执行全部，同时还有附有<code>order by</code>进行排序，如下所示： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#这句sql语句相当于<span class="function">select salary <span class="title">count</span><span class="params">(*)</span> where salary</span>=各个数值 order by salary;</span><br><span class="line">mysql&gt; select salary,<span class="built_in">count</span>(*) from customer group by salary;</span><br><span class="line">+--------+----------+</span><br><span class="line">| salary | <span class="built_in">count</span>(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|  <span class="number">12500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">13000</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">15500</span> |        <span class="number">2</span> |</span><br><span class="line">|  <span class="number">25500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">16500</span> |        <span class="number">1</span> |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="number">5</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>group by</code>分组数据，还允许对分组进行过滤，但在这里使用得不是<code>where</code>，而应该使用<code>having</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select salary,<span class="built_in">count</span>(*) from customer group by salary having salary&gt;=<span class="number">13000</span>;</span><br><span class="line">+--------+----------+</span><br><span class="line">| salary | <span class="built_in">count</span>(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|  <span class="number">13000</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">15500</span> |        <span class="number">2</span> |</span><br><span class="line">|  <span class="number">25500</span> |        <span class="number">1</span> |</span><br><span class="line">|  <span class="number">16500</span> |        <span class="number">1</span> |</span><br><span class="line">+--------+----------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="子查询">4.2 子查询</h5>
<p>迄今为止，我们上面学的得<code>select</code>查询语句都是单语句得简单查询，即都是从单个数据表中检索数据得单条语句。还有一种嵌套在其他查询中查询，内部的查询语句称为<strong>子查询</strong>。有子查询的语句从内向外处理</p>
<p><strong>使用子查询是因为在实际的应用中我们总不可能用一张表来存储全部的数据，而是让每一个表存储特定的内容，这样一来，我们就极有可能会用到一个表中的数据作为另一个表的字段名称或者条件来进行查询</strong>，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为条件</span></span><br><span class="line"><span class="function">select cust_id from order_num <span class="title">in</span><span class="params">(select order_num from orderitems where prod_id=<span class="string">&#x27;TNT2&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为计算字段</span></span><br><span class="line">select cust_name,cust_state,</span><br><span class="line">(select <span class="built_in">count</span>(*) from orders where order.cust_id=customer.cust_id) as orders from customer order by cust_name;</span><br></pre></td></tr></table></figure></p>
<h5 id="组合查询">4.3 组合查询</h5>
<p><strong>组合查询是将多个<code>select</code>语句的组合成一个结果集返回，这些组合查询通常称为并<code>union</code>或复合查询</strong>。使用组合查询的情况有以下两点：</p>
<ul>
<li>在多个查询中从不同表返回类似结构的数据要形成一个结果集</li>
<li>对单个表执行多个查询，要按单个查询结果集返回</li>
</ul>
<p>这时就可使用<code>union</code>操作符来组合数条SQL查询语句，<strong>使用时只需要在各条<code>select</code>语句之间加上<code>union</code>关键字即可，返回的结果集中会自动的去重</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary from employee where name=<span class="string">&#x27;trluper&#x27;</span></span><br><span class="line">   -&gt; <span class="keyword">union</span> select name,salary froom employee where name=<span class="string">&#x27;trl&#x27;</span>;</span><br><span class="line">+---------+--------+</span><br><span class="line">| name    | salary |</span><br><span class="line">+---------+--------+</span><br><span class="line">| trluper |  <span class="number">25500</span> |</span><br><span class="line">| trl     |  <span class="number">16500</span> |</span><br><span class="line">+---------+--------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>使用<code>union</code>时的规则:</strong></p>
<ul>
<li><code>union</code>必须由两条或以上的<code>select</code>语句上才能使用</li>
<li><code>union</code>的每个查询必须包含相同的列、表达式或聚集函数（不要求相同次序列出），输出会以第一个<code>select</code>语句的列名称为准</li>
<li>列数据必须兼容：类型不必完全相同，但是DBMS可以隐式转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select salary from employee where name=<span class="string">&#x27;trluper&#x27;</span>  <span class="keyword">union</span> select job_name from employyee_job where id=<span class="number">5</span>;</span><br><span class="line">+-----------+</span><br><span class="line">| salary    |</span><br><span class="line">+-----------+</span><br><span class="line">| <span class="number">25500</span>     |</span><br><span class="line">| c++开发   |</span><br><span class="line">+-----------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select name,salary from employee where name</span>=<span class="string">&#x27;trluper&#x27;</span>  <span class="keyword">union</span> <span class="title class_">select</span> salary,name frmom employee where name=<span class="string">&#x27;trl&#x27;</span>;</span><br><span class="line">+---------+--------+</span><br><span class="line">| name    | salary |</span><br><span class="line">+---------+--------+</span><br><span class="line">| trluper | <span class="number">25500</span>  |</span><br><span class="line">| <span class="number">16500</span>   | trl    |</span><br><span class="line">+---------+--------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="连结表多表查询">5. 连结表（多表查询）</h4>
<p><strong>我们知道将数据分不同种类存储到不同的表能够更有效率，也更方便管理，单是我们不可能在检索的时候对单个表单个表的检索，我们希望能够将不同表但相同对象的数据放置在一起，这和时候就用到了连结表。</strong>SQL最强大的功能就是能在数据检索查询的执行中连结<code>join</code>表，连结表不存在于数据库的存储中，它是在<code>select</code>运行过程依据条件创建而成。一般来说使用连结表最好是定义<strong>主键和外键</strong>，通过主外键将两者两者连结在一起。</p>
<p>下面的例子中employee的<code>ID</code>为主键，<code>employee_job</code>的外键为<code>ID</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee,employee_job where employee.id=employee_jjob.id order by salary desc;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面使用<code>where</code>子句来建立连结，但是对于连结表这一知识点来说，最好是使用它的特定规则来实现连结比较好即使用<code>join</code>关键字。如下介绍当中的：笛卡儿积、内连结、外连结。</p>
<h5 id="笛卡儿积交叉连接">5.1 笛卡儿积（交叉连接）</h5>
<p>笛卡尔集是指两个集合<code>A</code>和<code>B</code>的乘积,如下 <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如，有 A 和 B 两个集合，它们的值如下：</span><br><span class="line">A = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">B = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">集合 A×B 和 B×A 的结果集分别表示为：</span><br><span class="line">A×B=&#123;<span class="comment">(1,3)</span>, <span class="comment">(1,4)</span>, <span class="comment">(1,5)</span>, <span class="comment">(2,3)</span>, <span class="comment">(2,4)</span>, <span class="comment">(2,5)</span> &#125;;</span><br><span class="line">B×A=&#123;<span class="comment">(3,1)</span>, <span class="comment">(3,2)</span>, <span class="comment">(4,1)</span>, <span class="comment">(4,2)</span>, <span class="comment">(5,1)</span>, <span class="comment">(5,2)</span> &#125;;</span><br></pre></td></tr></table></figure> 我们发现笛卡儿积不遵从弄个交换律即<code>A*B≠B*A</code>。多表查询遵循的算法就是以上提到的笛卡尔积，表与表之间的连接可以看成是在做乘法运算。<strong>在实际应用中，应避免使用笛卡尔积，因为笛卡尔积中容易存在大量的不合理数据，简单来说就是容易导致查询结果重复、混乱。</strong>笛卡儿积使用<code>cross join</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee cross join employee_job order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 老大         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 开发         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 技术服务     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 产品经理     |</span><br><span class="line">| jack    |  <span class="number">12500</span> | c++开发      |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| lili    |  <span class="number">15500</span> | c++开发      |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 产品经理     |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 老大         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 销售         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | c++开发      |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 销售         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 老大         |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 开发         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | c++开发      |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 开发         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 销售         |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 技术服务     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 产品经理     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 开发         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 技术服务     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 产品经理     |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | 销售         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 产品经理     |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 老大         |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 销售         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">36</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="内连接">5.2 内连接</h5>
<p><strong>基于两个表直接的主键和外键相等的查询称为内部链接</strong>。只返回满足<code>on</code>后连接条件的数据（两边都有的才显示）。（对应oracle等值连接。） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee a inner join employee_job b on a.id=b.id order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br></pre></td></tr></table></figure></p>
<h5 id="外连接">5.3 外连接</h5>
<p>外连结有左外连结和右外连结，外连接与内连接的不同在于外连接对于另一个表会显示全部记录，不管符不符合后边<code>on</code>的条件，另一个表只显示符合条件的数据。</p>
<h6 id="左外连结">5.3.1 左外连结</h6>
<p><code>left join</code>是<code>left outer join</code>的简写，它的全称是左外连接，是外连接中的一种。外连接，左表<code>a</code>的记录将会全部表示出来，而右表<code>b</code>只会显示符合搜索条件的记录。右表记录不足的地方均为<code>NULL</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name,salary,job_name from employee a left join employee_job b on a.id=b.idorder by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| Adson   |  <span class="number">19000</span> | <span class="literal">NULL</span>         |</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">7</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="右外连接">5.3.2 右外连接</h6>
<p>效果同左外是相反的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ysql&gt; select name,salary,job_name from employee a right join employee_job b on a.id=b.id order by name;</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| name    | salary | job_name     |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | 销售         |</span><br><span class="line">| lili    |  <span class="number">15500</span> | 技术服务     |</span><br><span class="line">| tom     |  <span class="number">13000</span> | 产品经理     |</span><br><span class="line">| trl     |  <span class="number">16500</span> | 老大         |</span><br><span class="line">| trluper |  <span class="number">25500</span> | c++开发      |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | 开发         |</span><br><span class="line">+---------+--------+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="视图">6. 视图</h4>
<p>视图是虚拟的比表，与包含数据的表不同，视图只包含使用时动态检索数据的查询<strong>。即视图是将一个查询语句包装成一个有名字的虚拟表，我们可以通过该虚拟表来使用这个查询语句</strong>。因此对于视图来说具有以下优点：</p>
<ul>
<li>重用SQL语句</li>
<li>简化了复杂的SQL操作，在编写查询后，我们可以很方便重用它，而不用知道它的细节</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据，可以给用户授予表的特定部分的权限而不是整个表的访问权限</li>
<li>更改数据格式和表示。视图可以返回与底层表不同的数据格式和表示。</li>
<li>节省空间，有了视图，不用在去创建一个同视图一样的表，在有需要的使用视图生成一个临时表即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create view employee_view as select name,salary,hiredate from employee,employee_job where employee.id=employee_job.id;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; show tables</span>;</span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| employee       |</span><br><span class="line">| employee_job   |</span><br><span class="line">| employee_view  |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">3</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select * from employee_view</span>;</span><br><span class="line">+---------+--------+------------+</span><br><span class="line">| name    | salary | hiredate   |</span><br><span class="line">+---------+--------+------------+</span><br><span class="line">| jack    |  <span class="number">12500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| tom     |  <span class="number">13000</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| lili    |  <span class="number">15500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| 小明    |  <span class="number">15500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trluper |  <span class="number">25500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">| trl     |  <span class="number">16500</span> | <span class="number">2022</span><span class="number">-08</span><span class="number">-03</span> |</span><br><span class="line">+---------+--------+------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p><strong><em>注意</em></strong>：通常来说，视图是支持更新的，即可以对视图使用和表一样的<code>insert\update\delete</code>操作，因为视图只是一个包装<code>select</code>语句的虚拟表，因此更新一个视图会更新其相关的底层表，对视图的更新就是对底层表的更新。<strong>但是并不是所有的视图都支持更新，如果视图不能正确的确定被更新的基数据所在就不能更新。</strong></p>
<h4 id="存储过程">7. 存储过程</h4>
<p>视图能够很好的重复利用SQL语句，但是只能存储<code>select</code>语句，存储过程能够解决这个问题，<strong>存储过程（PROCEDURE）是事先经过编译并存储在数据库中的一段SQL语句的集合。调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是很有好处的。</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li>简化操作，存储过程通过把处理语句封装在容易使用的单元中。</li>
<li>简化对变动的管理，如果有表名、列名的变动时，只需要改动存储过程内的代码即可。</li>
<li>提高性能，使用存储过程比使用单独的SQL语句要快。</li>
<li>安全性大，因此使用的是存储过程内的SQL语句，数据库管理员是可以向访问数据库中存储过程的应用程序授予适当的权限，而不是向基础数据库表提供任何权限。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果使用大量的存储过程，那么使用这些存储过程的每个连接的内存使用量将大大增加</li>
<li>对于复杂的业务逻辑的存储过程的设计较为困难</li>
<li>开发和维护存储过程都不容易。</li>
<li>对数据库依赖程度较高，移值性差。</li>
</ul>
<h5 id="建立和调用存储过程">7.1 建立和调用存储过程</h5>
<p>存储过程就类似于c++中的函数，需要先定义，使用时需要调用。存储过程可以定义参数，参数分为<code>IN、OUT、INOUT</code>类型三种类型。调用存储过程使用<code>call</code></p>
<ul>
<li><code>IN</code>类型的参数表示接受调用者传入的数据；</li>
<li><code>OUT</code>类型的参数表示向调用者返回数据；</li>
<li><code>INOUT</code>类型的参数即可以接受调用者传入的参数，也可以向调用者返回数据。</li>
<li><code>declare</code>指示在存储过程中定义的变量，可使用<code>set</code>设置值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 创建存储过程</span><br><span class="line"><span class="function">CREATE PROCEDURE <span class="title">demo2</span><span class="params">(IN s_sex CHAR(<span class="number">1</span>),OUT s_count INT)</span></span></span><br><span class="line"><span class="function">	-- 存储过程体</span></span><br><span class="line"><span class="function">	BEGIN</span></span><br><span class="line"><span class="function">		-- 把SQL中查询的结果通过INTO赋给变量</span></span><br><span class="line"><span class="function">		SELECT <span class="title">COUNT</span><span class="params">(*)</span> INTO s_count FROM student WHERE sex</span>= s_sex;</span><br><span class="line">		declare id <span class="type">int</span>;</span><br><span class="line">		set id=<span class="number">15</span>;</span><br><span class="line">	END;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程</span><br><span class="line"><span class="function">call <span class="title">demo2</span><span class="params">(<span class="string">&#x27;男&#x27;</span>,nums)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的<code>SELECT COUNT(*) INTO s_count FROM student WHERE sex= s_sex;</code>语句将统计到的数目存储到<code>s_count</code>以返回给调用着，因为调用后他这是将结果返回给了<code>s_count</code>并没有输出结果集，可通过<code>select</code>输出 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s_count;</span><br></pre></td></tr></table></figure></p>
<h5 id="删除和检查存储过程">7.2 删除和检查存储过程</h5>
<p>可以通过<code>show create procedure</code>查看存储过程的详细信息，通过<code>drop procedure</code>删除存储过程 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show create procedure demo2;</span><br><span class="line">drop procedure demo2;</span><br></pre></td></tr></table></figure></p>
<h4 id="触发器">8. 触发器</h4>
<p>触发器的作用是让某一条语句在某事件发生时会自动执行。创建触发器时必须给出四条信息：</p>
<ul>
<li>唯一的触发器名称</li>
<li>触发器的关联表</li>
<li>触发器应该响应的活动，如<code>select、insert、update、delete</code>等</li>
<li>触发器何时执行<code>befor\after</code></li>
</ul>
<p>创建触发器使用<code>create trigger</code>,如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create trigger newproduct after insert on products <span class="keyword">for</span> each row select NEW.product_id;</span><br></pre></td></tr></table></figure> 上面这条触发器名称为<code>newproduct</code>,触发时机为在<code>products</code>表对每个插入行后会执行<code>select NEW.product.id</code>。这里<code>NEW</code>时关键字指定该插入行</p>
<h4 id="事务处理">9. 事务处理</h4>
<p>MySQL支持多种数据库引擎，最常见的是<code>MyISAM</code>和<code>InnoDB</code>。前者不支持事务处理，后者支持。<strong>事务处理可以用来维护数据的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行，事务处理是一种机制，利用事务处理可以保证成批的MySQL操作不会只执行一部分，如果全部执行那没问题，如果在执行过程中发生错误，它就会进行回退以恢复到数据库以前安全版本</strong>。</p>
<p>上面的这种事务处理机制保证了数据的完整性和安全性。事务处理需要知道的几个关键词如下：</p>
<ul>
<li>事务<code>transaction</code>：指一组SQL语句</li>
<li>回退<code>rollback</code>：指撤销指定SQL语句的过程</li>
<li>提交<code>commit</code>：指将未存储的SQL语句写入数据库表</li>
<li>保留的<code>savepoint</code>：指事务处理设置的临时占位符，你可以对它发布回退</li>
</ul>
<h5 id="事务的特性">9.1 事务的特性</h5>
<h6 id="事务的四大特性acid">9.1.1 事务的四大特性acid</h6>
<ul>
<li><strong>原子性</strong>：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的操作要么全部提交成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>：数据库总是从一个一致性状态转移达到另一个一致性状态，一致性状态就是由事务原子性保障，一个事务提交了，那是ok的，一个事务未提交，那也是OK的。</li>
<li><strong>隔离性</strong>：通常来说，一个事务所做的修改在未提交以前，对其他事务是不可见的。事务间是互不干扰的。</li>
<li><strong>持久性</strong>：一旦事务提交了，其所做的修改会永久保存到数据库总中，即使系统崩溃，修改的数据也不会丢失，（持久性不能做到100%保证策略，如果数据库本身就能做到吃性，那么要备份又有什么用呢）</li>
</ul>
<h6 id="事务的隔离级别">9.1.2 事务的隔离级别</h6>
<p><strong>事务的并发问题：</strong></p>
<ul>
<li>脏读 : 能读取到另一个未提交的数据（最可怕）</li>
<li>不可重复读: 对同一记录的两次读取不一致, 因为另一事务对该记录做了修改</li>
<li>幻读(虚读): 对同一记录的两次查询不一致, 因为另一事务插入了一条记录</li>
</ul>
<p><strong>四大隔离级别:</strong></p>
<ul>
<li><p><strong>未提交读(<code>read uncommitted</code>)</strong>：在该隔离级别，事务中的修改，即使没有提交，对其他事务也都是可见的。<strong>事务可以读取未提交的数据，这也被称为脏读</strong>。这个级别会导致喝多问题，从性能上来说，该级别没有比其他级别好很多，一般不推荐使用。</p></li>
<li><strong>提交读(<code>read committed</code>)：在该级别，一个事务开始时只能看见已经提交的事务的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，因此也可称为</strong>不可重复的**。这个隔离级别时大多数数据库默认的隔离级别。</li>
<li><strong>可重复读(<code>repeatable read</code>)</strong>：在该级别，保证了同一个事务多次读取同样的记录的结果是一致的。可重复读是MySQ的默认隔离级别，解决了脏读的问题，但是对于幻读无法解决。<strong>所谓的幻读就是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围插入新的记录，当之前的事务再次读取该范围记录时，产生幻行。</strong>InooDB引擎使用多版本控制MVCC解决幻读问题。</li>
<li><p><strong>可串行化(<code>serializable1</code>)</strong>：该隔离级别时最高的隔离级别，它通过强制事务串行执行，避免了前面说的幻读问题。简单来说，就是在读取每一行数据都加锁，所有会导致大量的超时和锁争问题。</p></li>
</ul>
<h5 id="rollback">9.2 rollback</h5>
<p>MySQL的<code>rollback</code>命令用来指示回退到事务开始之前的版本，如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from employee_job;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#开启事务机制</span></span><br><span class="line"><span class="function">mysql&gt; start transaction</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; <span class="keyword">delete</span> from employee_job</span>;</span><br><span class="line">Query OK, <span class="number">6</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; select * from employee_job</span>;</span><br><span class="line"><span class="function">Empty <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#回退</span></span><br><span class="line"><span class="function">mysql&gt; roolback</span>;</span><br><span class="line">mysql&gt; select * from employee_job;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br></pre></td></tr></table></figure></p>
<h5 id="commit">9.3 commit</h5>
<p>在Mysql中，如果不是在事务处理快，则提交的更改是默认自动立刻写入表中的。但是在事务处理块中，提交不会隐含执行，必须你显示的调用<code>commit</code>它才会提交到表中。但是如果在<code>start transaction</code>~<code>commit</code>当中的SQL语句出现错误时，则全部不会提交，回退事务开始前的版本 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from employee_job;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#开始事务</span></span><br><span class="line"><span class="function">mysql&gt; start transaction</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; insert into employee_job <span class="title">values</span><span class="params">(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;老板&#x27;</span>)</span></span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#提交</span></span><br><span class="line"><span class="function">mysql&gt; commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; select* from employee_job</span>;</span><br><span class="line">+----+--------------+</span><br><span class="line">| ID | JOB_NAME     |</span><br><span class="line">+----+--------------+</span><br><span class="line">| <span class="number">1</span>  | 销售         |</span><br><span class="line">| <span class="number">2</span>  | 产品经理     |</span><br><span class="line">| <span class="number">3</span>  | 技术服务     |</span><br><span class="line">| <span class="number">4</span>  | 开发         |</span><br><span class="line">| <span class="number">5</span>  | c++开发      |</span><br><span class="line">| <span class="number">6</span>  | 老大         |</span><br><span class="line">| <span class="number">2</span>  | 老板         |</span><br><span class="line">+----+--------------+</span><br><span class="line"><span class="number">7</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></p>
<h5 id="使用保留点">9.4 使用保留点</h5>
<p>为了避免一次性对事务处理块进行全部的回退或者提交，使用<code>savepoint</code>来设置保留的，已达到能支持部分回退或者提交的功能。如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">...</span><br><span class="line">savepoint point1;</span><br><span class="line">...</span><br><span class="line">savepoint point2;</span><br><span class="line">...</span><br><span class="line">rollback to point1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure> 上面的程序会回退到<code>point1</code>，因此提交的MySQL批次只有<code>point1</code>前的，后面的无法提交。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">算法题解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 21:30:13" itemprop="dateCreated datePublished" datetime="2022-07-30T21:30:13+08:00">2022-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-21 10:31:03" itemprop="dateModified" datetime="2022-09-21T10:31:03+08:00">2022-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="动态规划类">1. 动态规划类</h4>
<h5 id="打家劫舍">1.1 打家劫舍</h5>
<p><strong>问题：</strong>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]：表示第i家房屋结尾的最多能偷窃到的最高数额</span></span><br><span class="line">        <span class="comment">//初始条件：dp[0]=nums[0]、dp[1]=nums[1]</span></span><br><span class="line">        <span class="comment">//因为对邻接房屋偷窃，则dp[i]=max(dp[x])+nums[i]，0≤x&lt;i-1</span></span><br><span class="line">        <span class="comment">//这样的算法复杂度为O(N*N)，可以通过两个变量，使得算法降为O(N)</span></span><br><span class="line">        <span class="comment">//变量maxOdd表示奇次序的最大值，maxEven表示偶次序的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="comment">//初始条件</span></span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//maxOdd初始为dp[1]，maxEven初始为dp[0]</span></span><br><span class="line">        <span class="type">int</span> maxOdd=dp[<span class="number">1</span>],maxEven=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==i%<span class="number">2</span>)      <span class="comment">//为偶下标</span></span><br><span class="line">            &#123;</span><br><span class="line">               dp[i]=nums[i]+maxEven;</span><br><span class="line">                <span class="comment">//更新奇偶的最大值</span></span><br><span class="line">                <span class="keyword">if</span>(maxOdd&lt;maxEven)</span><br><span class="line">                    maxOdd=maxEven;</span><br><span class="line">                maxEven=<span class="built_in">Max</span>(maxEven,maxOdd,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>            <span class="comment">//奇下标</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=nums[i]+maxOdd;</span><br><span class="line">                <span class="keyword">if</span>(maxOdd&gt;maxEven)</span><br><span class="line">                    maxEven=maxOdd;</span><br><span class="line">                maxOdd=<span class="built_in">Max</span>(maxEven,maxOdd,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMaxValue</span>(dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="最长回文子串">1.2 最长回文子串</h5>
<p><strong>问题：</strong>给你一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]:表示s[i]是否等于s[j],相等且回文则置为true，否则为false</span></span><br><span class="line">    <span class="comment">//初始条件：dp[i][i]=true;</span></span><br><span class="line">    <span class="comment">//状态转移方程：</span></span><br><span class="line">	<span class="comment">//①若i和j是相邻的即i+1=j且s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//②若不相邻，则判断内侧是否为true，若dp[i+1][j-1]=true&amp;&amp;s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//通过增加两变量记录当前回文串的最长长度Maxlen,初始为1,以及记录回文串的下标开始index_min，初始为最后一个元素</span></span><br><span class="line">    <span class="comment">//算法的时间复杂度为O(n*n)</span></span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>||len==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(len,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> Maxlen=<span class="number">1</span>,index_min=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])<span class="comment">//如果两元素相等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i+<span class="number">1</span>)<span class="comment">//如果相邻</span></span><br><span class="line">                    dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//不相邻，判断两元素内部是否为回文串</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;Maxlen&lt;j-i+<span class="number">1</span>)<span class="comment">//更新Maxlen和index_min</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Maxlen=j-i+<span class="number">1</span>;</span><br><span class="line">                    index_min=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ret=s.<span class="built_in">substr</span>(index_min,Maxlen);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="树类">2. 树类</h4>
<h4 id="链表类">3. 链表类</h4>
<h5 id="两数相加">3.1 两数相加</h5>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head=l1;</span><br><span class="line">        <span class="type">int</span> jingwei=<span class="number">0</span>;</span><br><span class="line">        ListNode* prio;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val=l1-&gt;val+l2-&gt;val+jingwei;</span><br><span class="line">            prio=l1;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1&amp;&amp;!l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val+=jingwei;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1&amp;&amp;l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prio=l1;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                    l1-&gt;val+=jingwei;</span><br><span class="line">                    jingwei=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            prio-&gt;next=l2;</span><br><span class="line">            l1=l2;</span><br><span class="line">            l1-&gt;val+=jingwei;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1&amp;&amp;l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prio=l1;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                    l1-&gt;val+=jingwei;</span><br><span class="line">                    jingwei=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jingwei)</span><br><span class="line">            &#123;</span><br><span class="line">                prio-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(jingwei,<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="删除链表倒数第n个节点">3.2 删除链表倒数第N个节点</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        ListNode* tmp=head;</span><br><span class="line">        <span class="keyword">while</span>(tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=head;</span><br><span class="line">		<span class="comment">//删除头节点单独考虑</span></span><br><span class="line">        <span class="keyword">if</span>(len-n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> tmp-&gt;next;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len-n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next=tmp-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="合并k个有序链表">4.2 合并K个有序链表</h5>
<p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用分治的思想，分别两两合并</span></span><br><span class="line">        <span class="comment">//使用递归实现：</span></span><br><span class="line">        <span class="comment">//递归退出条件为：一是传入的只有一个链表另一个为NUL，二是传入的均为NULL，直接返回</span></span><br><span class="line">        <span class="comment">//程序结构：mergeKList为主调用，不做其他功能，merge递归入口，当达到底层是使用mergeTwoList   </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>()<span class="number">-1</span>);     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoList</span><span class="params">(ListNode* a,ListNode* b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==a||<span class="literal">NULL</span>==b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>==a?b:a;</span><br><span class="line">        ListNode* head=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;val&gt;b-&gt;val)&#123;</span><br><span class="line">            head=b;</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head=a;</span><br><span class="line">            a=a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tempNode=head;</span><br><span class="line">        <span class="keyword">while</span>(a&amp;&amp;b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;val&gt;b-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                tempNode-&gt;next=b;</span><br><span class="line">                b=b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tempNode-&gt;next=a;</span><br><span class="line">                a=a-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tempNode=tempNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a)</span><br><span class="line">            tempNode-&gt;next=a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempNode-&gt;next=b;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=(r+l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(r==l)</span><br><span class="line">            <span class="keyword">return</span> lists[r];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r&lt;l)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">mergeTwoList</span>(<span class="built_in">merge</span>(lists,l,m),<span class="built_in">merge</span>(lists,m+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串类">4. 字符串类</h4>
<h5 id="n字形变换">4.1 N字形变换</h5>
<p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。如输入字符串为 <code>PAYPALISHIRING</code> 行数为 4 时，排列如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;PAYPALISHIRING&quot;</span>, numRows = <span class="number">4</span></span><br><span class="line">输出：<span class="string">&quot;PINALSIGYAHRPI&quot;</span></span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于numRows有这样的一个规律：</span></span><br><span class="line"><span class="comment">//按规定第一列取s的前numRows个字符，即i=0.....numRows</span></span><br><span class="line"><span class="comment">//对于i行后面的列每隔(numRows-1)*2+i取一个，直到(numrow-1)*2*j&gt;s.size()为止,j&gt;=1</span></span><br><span class="line"><span class="comment">//同时对于第i行，在取s[(numRow-1)*2*j+i]时，</span></span><br><span class="line"><span class="comment">//前面应该还有当(numRows-1)*2*j+i-2i!=(numRows-1)*2*(j-1)+i时添加一个字符为s[(numsRow-1)*2*j+i-2i]</span></span><br><span class="line"><span class="comment">//或者只需排除第一行和最后一行即可</span></span><br><span class="line"><span class="comment">//时间复杂度为O(N)，空间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="built_in">convert</span>(string s, <span class="type">int</span> numRows) &#123;</span><br><span class="line">        string ret=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numRows&amp;&amp;i&lt;s.<span class="built_in">size</span>();i++)  <span class="comment">//第i行存储</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret+=s[i];</span><br><span class="line">            <span class="type">int</span> gapDistance=(numRows<span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;gapDistance*j-i&lt;s.<span class="built_in">size</span>();j++)<span class="comment">//寻找下一个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows<span class="number">-1</span>)             <span class="comment">//判断是不是第一行或者最后一行,不是则进入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret+=s[gapDistance*j-i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(gapDistance*j+i&lt;s.<span class="built_in">size</span>())</span><br><span class="line">                    ret+=s[gapDistance*j+i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> #### 5. 双指针类 ##### 5.1 无重复字符的最长子串 <strong>问题：</strong>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<blockquote>
<p>示例： 输入: s = &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用滑动窗口的思路，即双指针的应用，左指针first表示以该元素为起始点</span></span><br><span class="line">   <span class="comment">//右指针last表示[first,last)是以s[first]开头最长无重复子串，以first为起始</span></span><br><span class="line">   <span class="comment">//不断向右移动右指针，直到遇到重复的为止</span></span><br><span class="line">   <span class="comment">//用unordered_set记录来判断是否有重复元素</span></span><br><span class="line">   <span class="comment">//虽然是双循环，但是内部右指针不重置，移动次数为常数，因此时间复杂度为O(N)</span></span><br><span class="line">   <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">0</span>==len||<span class="number">1</span>==len)</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    <span class="type">int</span> last=<span class="number">0</span>,maxLen=<span class="number">1</span>;</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; hSet;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;len;first++)  <span class="comment">//左指针向前</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不是第一次进入循环，说明当前元素s[last]与hSet存在重复，不断去除前一个</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>!=first)</span><br><span class="line">            hSet.<span class="built_in">erase</span>(s[first<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//不断右移右指针，直到遇到重复的</span></span><br><span class="line">        <span class="keyword">while</span>(last&lt;len&amp;&amp;!hSet.<span class="built_in">count</span>(s[last]))</span><br><span class="line">        &#123;</span><br><span class="line">            hSet.<span class="built_in">insert</span>(s[last]);</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen=<span class="built_in">max</span>(maxLen,last-first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="盛最多水的容器">5.2 盛最多水的容器</h5>
<p><strong>问题</strong>：给定一个长度为<code>n</code>的整数数组<code>height</code>。有<code>n</code>条垂线，第<code>i</code>条线的两个端点是<code>(i, 0)</code>和<code>(i, height[i])</code>。找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//双指针，一头指向头，一个指向尾</span></span><br><span class="line">    <span class="comment">//原理不用多说，看代码即可知</span></span><br><span class="line">    <span class="comment">//复杂度O(N)</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> maxCap=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="built_in">Min</span>(height[left],height[right])*(right-left);</span><br><span class="line">        <span class="keyword">if</span>(maxCap&lt;tmp)</span><br><span class="line">            maxCap=tmp;</span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="三数之和">5.3 三数之和</h5>
<p><strong>算法思路：</strong></p>
<ul>
<li>1、特判，对于数组长度<code>n</code>，如果数组为<code>null</code>或者数组长度小于<code>3</code>，返回<code>[]</code></li>
<li>2、对数组进行排序。</li>
<li>3、遍历排序后数组：
<ul>
<li>若<code>nums[i]&gt;0</code>：因为已经排序好，所以后面不可能有三个数加和等于0，直接返回结果。</li>
<li>对于重复元素：跳过，避免出现重复解</li>
<li>令左指针<code>L=i+1</code>，右指针<code>R=n-1</code>，当 <code>L&lt;R</code>时，执行循环：
<ul>
<li>当<code>nums[i]+nums[L]+nums[R]==0</code>，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解</li>
<li>若和大于0，说明<code>nums[R]</code>太大，<code>R</code>左移</li>
<li>若和小于0，说明<code>nums[L]</code>太小，<code>L</code>右移</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line"><span class="comment">/*方法一：转化为两数之和</span></span><br><span class="line"><span class="comment">*先将nums的元素拷贝一份到unordered_set处</span></span><br><span class="line"><span class="comment">*再将将nums内的数据两两求和存储回到tmp</span></span><br><span class="line"><span class="comment">*通过在set寻找是否有符合tmp的数据求得其解</span></span><br><span class="line"><span class="comment">*时间复杂度为O(N*N),空间复杂度为O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*方法二：双指针和排序</span></span><br><span class="line"><span class="comment">*先对数组nums进行升序排序，</span></span><br><span class="line"><span class="comment">*后依次从负值取一个元素作为第一个选取的值</span></span><br><span class="line"><span class="comment">*之后定义左右指针，从左指向右前进一位选取一个元素，这里选取了两个元素执行求和得target</span></span><br><span class="line"><span class="comment">*右指针向左移动若干个位置，寻找元素与target和为0得元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line"><span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; nums[i] &lt;= <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    left = i + <span class="number">1</span>;</span><br><span class="line">    right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[left]);</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="comment">//判断下一个值是否重复，是则跳过</span></span><br><span class="line">            <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                left++;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;len<span class="number">-1</span>&amp;&amp;nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">        i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最接近的三数之和">5.4 最接近的三数之和</h5>
<p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *使用三数之和的方法：</span></span><br><span class="line"><span class="comment">    *1、先对数组进行排序</span></span><br><span class="line"><span class="comment">    *2、之后想三数之和一样遍历排序后的数组：</span></span><br><span class="line"><span class="comment">    *时间复杂度为O(N*N)，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> ret=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> right=len<span class="number">-1</span>,left=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较ret是否要更新</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(target-(nums[i]+nums[left]+nums[right]))</span><br><span class="line">                    &lt;<span class="built_in">abs</span>(target-ret))</span><br><span class="line">                    ret=nums[i]+nums[left]+nums[right];</span><br><span class="line">            <span class="comment">//双指针应该向哪边移动</span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[i]+nums[left]+nums[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[i]+nums[left]+nums[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="四数之和">5.5 四数之和</h5>
<p>给你一个由 n 个整数组成的数组<code>nums</code>，和一个目标值<code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组<code>[nums[a], nums[b], nums[c], nums[d]]</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//解决方法同三数求和一样，使用排序+双指针方法</span></span><br><span class="line">        <span class="comment">//只不过此时多加了一层循环，则时间复杂度为O(N^3),</span></span><br><span class="line">        <span class="type">long</span> Target=target;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>;i++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>&amp;&amp;Target&lt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=i+<span class="number">3</span>;j--)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="type">int</span> left=i+<span class="number">1</span>,right=j<span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="type">long</span> result=(<span class="type">long</span>)nums[i]+(<span class="type">long</span>)nums[j]+</span><br><span class="line">					 			(<span class="type">long</span>)nums[left]+(<span class="type">long</span>)nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(Target&lt;result)</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(Target&gt;result)</span><br><span class="line">                        left++;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        ret.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(right&gt;left&amp;&amp;nums[right]==nums[right<span class="number">-1</span>])</span><br><span class="line">                            right--;</span><br><span class="line">                        <span class="keyword">while</span>(right&gt;left&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])</span><br><span class="line">                            left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//跳过重复</span></span><br><span class="line">                 <span class="keyword">while</span>(j&gt;=i+<span class="number">3</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])</span><br><span class="line">                    j--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//跳过重复</span></span><br><span class="line">             <span class="keyword">while</span>(i&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>&amp;&amp;nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="深度优先搜索类">6. 深度优先搜索类</h4>
<h4 id="广度优先搜索类">7. 广度优先搜索类</h4>
<h4 id="数学">8. 数学</h4>
<h4 id="矩阵">9. 矩阵</h4>
<h4 id="图类">5. 图类</h4>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/all/">leetcode</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" class="post-title-link" itemprop="url">动态规划算法思想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-29 13:56:14" itemprop="dateCreated datePublished" datetime="2022-07-29T13:56:14+08:00">2022-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-31 10:25:02" itemprop="dateModified" datetime="2022-07-31T10:25:02+08:00">2022-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="动态规划">1. 动态规划</h4>
<p>我们遇到的问题中，有很大一部分可以用动态规划<code>Dynamic Programming</code>来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解题</p>
<h5 id="动态规划的原理">1.1 动态规划的原理</h5>
<p><strong>动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度</strong>， 因此它比回溯法、暴力法等要快许多。动态规划要求我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。由于单纯使用语言来描述动态规划晦涩难懂，因此采用例子来说明：</p>
<p><strong>问题1：假设有1元、3元和5元的硬币，如何用最少的的硬币凑够11元？</strong></p>
<p>学过贪心算法知道，加如使用贪心算法，每次拿面额最高的银币来逼近这个11是一个方法，但它不能保证一定是最少数量的。因此这里介绍动态规划来解答。正如上面所说，动态规划就是将问题小化，以上一次的子问题的最优解推出下一个的最优解：</p>
<ul>
<li>因此我们可想当面额为<code>i</code>时，最少的硬币数量是多少，我们使用<code>dp[i]</code>表示凑够<code>i</code>元时最少的硬币数量。</li>
<li>豪无疑问，当<code>i=0</code>时<code>dp[0]=0</code>，因为题目给出了1元、3元和5元的面额，我们需要对这些进行处理，因此能够得到其他的初始条件，<code>i=1</code>时<code>dp[i]=1</code>,i=3时<code>dp[3]=1</code>,i=5时<code>dp[5]=</code>。</li>
<li>完成了初始化条件后，我们可以继续推其他面额的情况，由提供的三种面额，可以知道当<code>i=2</code>时<code>dp[2]=2</code>，但<code>i=3</code>时，组成它的有两种选择，一种时三个1元硬币，另一种是直接选择3元，有<code>min(dp[3].dp[2]+1)</code>知道<code>dp[3]=1</code>是最优解，同样<code>dp[4]</code>，它可以有<code>4=1+3</code>或者<code>4=3+1</code>，两者的的数量是一致的，只不过是次序的不同，再到<code>dp[5]</code>可以检查<code>min(dp[4]+1,dp[2]+1,dp[5])</code>取最小</li>
<li>由上面的分析，我们可以很容易的分析到这样一个状态转移方程： <span class="math display">\[
dp[i]=
\begin{cases}
min(dp[i-1]+1,dp[i-3]+1,dp[i-5]+1),i&gt;5\\
1,i=1,3,5\\
2,i=2,4
\end{cases}
\]</span></li>
</ul>
<p>这样问题就迎刃而解，得如下代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 有面值1，3，5的硬币，试求组成39元时用到最少的硬币数量</span></span><br><span class="line"><span class="comment">* 首先定义dp[i]表示i元时用到得最少银币数</span></span><br><span class="line"><span class="comment">* 由题得初始化条件dp[0]=0,dp[1]=1,dp[3]=1,dp[5]=5</span></span><br><span class="line"><span class="comment">* 当i&gt;5时，会有状态转移方程dp[i]=min(dp[i-1].dp[i-3],do[i-5])+1;</span></span><br><span class="line"><span class="comment">*当i&lt;=5时，这个范围含的2，4未初始化，</span></span><br><span class="line"><span class="comment">*可以增加以判断条件当i-1&gt;=0,i-3&gt;=0,i-5&gt;0来决定，是否要在状态转移方程添加对应项</span></span><br><span class="line"><span class="comment">* 这里由于能够自己推段2，4的最小数量，直接当作初始化，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCoin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">40</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">5</span>] = <span class="number">1</span>;	</span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	dp[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] = <span class="built_in">Min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">3</span>], dp[i - <span class="number">5</span>]) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">39</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的案例可以知道，解决动态规划的策略最重要的三步是：</p>
<ul>
<li><strong>确定<code>dp</code>数组的含义</strong></li>
<li>确定可从题意得出的临界值</li>
<li><strong>确定状态转移方程</strong></li>
</ul>
<p>有了状态和状态转移方程，问题基本上也就解决了，接下来的问题只是如何写迭代代码而已。</p>
<h5 id="初级问题">1.2 初级问题</h5>
<p>上面的硬币问题只能说是很简单的动态规划问题，我们可以在来看看更复杂一点的。</p>
<p><strong>问题：</strong>一个序列有N个数：A[1],A[2],…,A[N]，求出最长连续非降子序列的长度</p>
<p>同样对于这个问题也能使用动态规划来解决，定义一个<code>dp[i]</code>表示包括当前下标<code>i</code>的非降子序列的长度，那么就有这样的条件：</p>
<ul>
<li>初始条件中，我们肯定可以知道<code>i=0</code>时<code>d[i]=1</code>。</li>
<li>状态转移方程则有<code>d=1+(s[i]&gt;=s[i-1]?d[i-1]:0)</code>，这个状态转移方程指示，我们只需将当前的访问的元素与上一个元素进行对比，如果是<code>&gt;=</code>，则与之前一样是一个非降子序列，反之则不是，重新计数非降子序列长度</li>
<li>最后只需要遍历一次<code>d[i]</code>就能得到最长非降子序列的长度，起始和结束位置也能递推</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">maxLength</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len)</span></span>;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] =<span class="number">1</span>+( s[i] &gt;= s[i - <span class="number">1</span>] ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getmaxValue</span>(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的问题可以进一步升级，不要求连续，如下：</p>
<p><strong>问题：</strong>一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度</p>
<p>虽然这个问题不要求连续，我们同样能够使用一维<code>dp[i]</code>尝试解决，同样要找出初始条件和状态转移方程。<strong>我们可以让<code>dp[i]</code>是表示在以<code>A[i]</code>结尾的即下标<code>0~i</code>的子序列的最长非降长度</strong>，那么就有如下策略：</p>
<ul>
<li>初始条件<code>dp[0]=1</code></li>
<li>状态转移方程有两种情况，一是必须在前面找到所有的个x,使得<code>A[i]&gt;=A[x]</code>，更新<code>dp[x]=dp[x]+1</code>,然后执行取最大值,如果没有找到则直接赋值为<code>dp[i]=1</code>。即</li>
</ul>
<p><span class="math display">\[
dp[i]=
\begin{cases}
max(dp[x]+1)     当之前序列存在A[i]&gt;=A[x]时，\\
1，           之前的序列不存在A[x]&lt;=A[i]时
\end{cases}
\]</span></p>
<ul>
<li>最后遍历一遍<code>dp</code>数组，取最大值，</li>
<li>该算法因为当<code>A[i]&lt;A[i-1]</code>时，需要从后往前遍历dp数组。外部循环为<code>n</code>，内部平均循环为<code>n/2</code>，因此时间复杂度为<code>O(N*N)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSonLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(len);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(i)</span></span>;</span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cap[i] &gt; cap[j]) &#123;</span><br><span class="line">                    tmp[index]=dp[j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> max=<span class="built_in">getmaxValue</span>(tmp);</span><br><span class="line">            <span class="keyword">if</span> (max==<span class="number">0</span>)</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=max+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getmaxValue</span>(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的算法分时间复杂度达到了<code>O(N*N)</code>,是否有办法使复杂度降到<code>O(NlogN)</code>？我们可以看到上面的程序之所以变为<code>O(N*N)</code>，是因为每次对<code>A[i]</code>都要遍历之前的<code>A[x]</code>，我们是否可以通过增加一个数组来存储形成的最长非降子序列，然后进行二分查找呢，经过二分查找使得复杂度变为<code>O(NlogN)</code>:</p>
<p><strong>要这样做我们必须重新定义<code>dp[i]</code>数组的意义，<code>dp[i]</code>它表示长度为<code>i+1</code>的递增子序列中，最大的序列尾数；再定义一个<code>maxL</code>变量，指示当前最长递增子序列的长度，对数组<code>dp</code>二分查找，判断<code>cap[x]</code>要插入的位置</strong></p>
<ul>
<li>若<code>cap[x]&gt;dp[maxL]</code>,表示当前该值比递增子序列的尾数都大，将<code>cap[x]</code>添加到<code>dp</code>尾部，<code>maxL++</code></li>
<li>若<code>dp[i-1]&lt;cap[x]&lt;dp[i]</code>，更新相应<code>dp[i]</code>即可</li>
</ul>
<p>显然这种方法以及不算动态规划了，是一种特殊解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; storage)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">	<span class="type">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> lo = <span class="number">0</span>, hi = maxL;</span><br><span class="line">		<span class="comment">//二分查找</span></span><br><span class="line">		<span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (dp[mid] &lt; num)</span><br><span class="line">				lo = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				hi = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[lo] = num;</span><br><span class="line">		<span class="keyword">if</span> (lo == maxL)</span><br><span class="line">		&#123;</span><br><span class="line">			maxL++;</span><br><span class="line">			<span class="keyword">if</span>(storage[<span class="number">0</span>].size&lt;maxL)</span><br><span class="line">				storage.<span class="built_in">clear</span>();</span><br><span class="line">			storage.<span class="built_in">push_back</span>(dp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>附加：如果要你返回所有最长递增子序列或者返回最长递增子序列的个数该如何解决？</em></strong> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/solution/zui-chang-di-zeng-zi-xu-lie-de-ge-shu-by-w12f/">leetcode第673题.最长递增序列的个数</a></p>
<h5 id="中级">1.3 中级</h5>
<p>上面举的例子都是对一维<code>dp</code>来解决，接下来介绍如何解决二维<code>dp</code>的问题。</p>
<p>**问题：平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果**</p>
<p>当然了，使用动态规划<code>dp</code>就要找初始条件喝状态转移方程</p>
<ul>
<li>定义二维数组<code>dp[N][M]</code>，<code>d[i][j]</code>表示从<code>A[0][0]</code>到<code>A[i][j]</code>能收集到的最多苹果数量</li>
<li>因为只能向下喝右移动，则有状态转移方程<code>d[i][j]=max(d[i-1][j],d[i][j-1])+A[i][j]</code>，其中<code>i&gt;0,j&gt;0</code></li>
<li>为了方便实现状态转移方程，我们可以人增加隔离带，即<code>A[0][j]=0、A[i][0]=0</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxApple</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cap.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> row = cap[<span class="number">0</span>].<span class="built_in">size</span>(),</span><br><span class="line">		col = cap.<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(col+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(row+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= col; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= row; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> Max = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			dp[i][j] = Max + cap[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[col][row];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述算法复杂度为<code>O(N*M)</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-28 13:30:57" itemprop="dateCreated datePublished" datetime="2022-07-28T13:30:57+08:00">2022-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-30 22:51:26" itemprop="dateModified" datetime="2022-07-30T22:51:26+08:00">2022-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="算法总览">1. 算法总览</h4>
<p>常见的排序算法有<strong>插入排序、选择排序、希尔排序、堆排序、冒泡排序、快速排序、归并排序和基数排序</strong>。常见排序算法可以分为两大类：</p>
<ul>
<li><strong>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破<code>O(nlogn)</code>，因此称为非线性时间比较类排序</strong>。</li>
<li><strong>线性时间非比较类排序：</strong>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。排序算法的时间复杂度如下： <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort.png" width="700"></li>
</ul>
<p><strong>算法的稳定性：</strong>稳定性就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。</p>
<ul>
<li><strong>稳定排序算法</strong>：冒泡排序、插入排序、归并排序、计数排序、桶排序与基数排序</li>
<li><strong>不稳定排序算法</strong>：希尔排序、选择排序、堆排序与快速排序</li>
</ul>
<p><strong>内部排序和外部排序：</strong>内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。上面所列举的都是内部排序。像多路归并可以采用外部排序</p>
<h5 id="插入排序">1.1 插入排序</h5>
<ul>
<li><strong>基本思想：</strong>每次将当前元素插入到左侧（有序区）已经排序的数组中，使得插入之后的左侧数组依然有序。
<ul>
<li>查找出元素要插入的位置：要插的元素与之前排好的子序比较</li>
<li>将要插入位置的元素及后面的元素后移一个位置</li>
<li>将元素插入</li>
</ul></li>
<li><p><strong>复杂度</strong>：插入排序一共需要两重循环，第一重循环确定需要加入有序序列的新元素，一共n-1轮，第二重循环确定新元素在原来有序序列中的位置，平均需要<code>n/4</code>轮可以确定位<code>O(n²)</code>,空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性：</strong>每次比较时遇到第一个小于等于新元素的元素，就将新元素插入到该元素的后面，即可不破坏相等元素的相对顺序，做到算法稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len== <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = cap[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; cap[j] &gt; tmp; j--)</span><br><span class="line">            cap[j + <span class="number">1</span>] = cap[j];</span><br><span class="line">        cap[j + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="希尔排序">1.2 希尔排序</h5>
<p>通过上面对插入排序程序的编写知道，插入排序适用于基本有序和数据量不大的排序表，<strong>希尔排序</strong>是基于这两点改进而来的。</p>
<ul>
<li><p><strong>基本思想</strong>：先将待排序表分割成若干形如 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">L</span>[i,i+d,i+<span class="number">2</span>d……,i+kd]</span><br></pre></td></tr></table></figure> 既把步长相隔增量d的记录组成一个子表，对各个子表分别进行直接插入排序。当整个表的元素已呈<strong>“基本有序”</strong>时，再次对全体记录进行一次直接插入排序。一般来说，步长取<code>d=n/2</code>，之后都已<code>1/2</code>递减。</p>
<ul>
<li>1.取一步长<code>d1&lt;n</code>，把表中全部记录分发d组</li>
<li>2.所有距离为<code>d1</code>的倍数的记录放到一组。</li>
<li>3.在各组内进行直接插入排序</li>
<li>4.取第二个步长<code>d2&lt;d1</code>，重复上述过程，直到<code>d=1</code>。</li>
<li>5.<code>d=1</code>时，再进行一次直接插入排序</li>
</ul></li>
<li><p><strong>复杂度：</strong>希尔排序的时间复杂度会随着<code>d</code>选取策略的不同而发生变化，但是通常保持在<span class="math inline">\(O(n^{1.3})~O(n^{1.5})\)</span>;希尔排序依旧属于原地排序，不需要额外的空间，所以空间复杂度与插入排序一样为<code>O(1)</code></p></li>
<li><p><strong>稳定性：</strong>虽然插入排序是稳定的排序算法，但是希尔排序因为将序列进行了拆分再进行插入排序，如此不同组中的相等元素相对位置不能保证不变，所以相等元素的相对位置会发生改变，故时不稳定排序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/shellSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = len / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;len ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = cap[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; cap[j] &gt; tmp; j -= d)</span><br><span class="line">                cap[j + d] = cap[j];</span><br><span class="line">            cap[j + d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="选择排序">1.3 选择排序</h5>
<p>选择排序<code>Selection-sort</code>是一种简单直观的排序算法。它的</p>
<ul>
<li><p><strong>基本思想：</strong>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始（末尾）位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></li>
<li><p><strong>复杂度：</strong>选择排序一共需要比较<code>n-1</code>轮（每轮找到最小的元素进行交换），第<code>m</code>轮比较<code>n-m</code>次，所以比较的总次数为：$ _{i=0}^{n-1}n-i <span class="math inline">\(，即为\)</span>O(N^2)<span class="math inline">\(。选择排序不需要额外的空间，故其空间复杂度为\)</span>O(1)$</p></li>
<li><p><strong>稳定性：</strong>由于选择出的元素可能会进行跨越式的交换，所以会破坏原本的顺序，所以不稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/selectionSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即使终止的选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size = cap.<span class="built_in">size</span>(); !sorted &amp;&amp; size &gt; <span class="number">1</span>; size--)</span><br><span class="line">    &#123;		<span class="comment">//每一轮size-1,最大的放在后面   </span></span><br><span class="line">        <span class="type">int</span> indexOfMax = <span class="number">0</span>;</span><br><span class="line">        sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap[indexOfMax] &lt; cap[i])		<span class="comment">//找出最大的值</span></span><br><span class="line">                indexOfMax = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sorted = <span class="literal">false</span>;	<span class="comment">//无序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Swap</span>(cap[indexOfMax], cap[size - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="冒泡排序">1.4 冒泡排序</h5>
<ul>
<li><p><strong>基本思想：</strong>从后往前（从前往后），两两比较相邻元素的值。若为逆序A[i]&lt;A[i-1]，则交换他们。每一轮将最大的放到后面（即每一次减少一次内循环）</p></li>
<li><p><strong>复杂度：</strong>冒泡排序一共需要比较<code>n-1</code>轮，第<code>m</code>轮比较<code>n-m</code>次，所以其比较总次数应为：<span class="math inline">\(\displaystyle\sum_{i=0}^{n-1}n-i\)</span>，故冒泡排序的时间复杂度为<code>O(n²)</code>。冒泡排序比较和交换的过程中不消耗额外的内存，故冒泡排序的空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性</strong>：比较时如果两个元素相等则不交换，即可做到使算法稳定 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序时及时终止的冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(T&amp; cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cap.<span class="built_in">size</span>(); sorted &amp;&amp; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        sorted = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (cap[j] &gt; cap[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(cap[j], cap[j + <span class="number">1</span>]);</span><br><span class="line">                sorted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速排序">1.5 快速排序**</h5>
<ul>
<li><strong>基本思想</strong>：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。
<ul>
<li>1.选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</li>
<li>2.分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</li>
<li>3.递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</li>
</ul></li>
<li><p><strong>复杂度</strong>：<strong>快速排序的性能受到基准选择策略的影响</strong>，理论上如果每次选择基准都选择分区的第一个元素，那么这个序列越有序则时间复杂度越趋近于<code>O(n²)</code>，这是因为每次基准都是分区最大或最小的元素，那么左区间将会没有元素，而右区间将会有除了基准外的全部元素，这样就跟普通的插入排序没有区别了，<strong>因此对于快排会有优化措施</strong>。<strong>快速排序的最坏运行情况是<code>O(n²)</code>，比如说顺序数列的快排。但它的平摊期望时间是<code>O(nlogn)</code>，且<code>O(nlogn)</code> 记号中隐含的常数因子很小</strong>，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。<strong>快速排序可以实现原地排序，不需要消耗额外的内存，所以快速排序的空间复杂度为<code>O(1)</code>。</strong></p></li>
<li><p><strong>稳定性</strong>：快速排序不能保证相等元素的相对顺序不发生改变，所以不稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写自己的quickSort,没有优化，遇到最坏情况的时间复杂度会变成O(N*N)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--;</span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="快排优化">1.5.1 快排优化</h6>
<p>对于快排，其性能受到基准选择策略的影响，当出现下面两种情况时为最坏情况：</p>
<ul>
<li>在分解时每次选取的基准点为最小元素</li>
<li>在分解时每次选取的基准点为最大元素</li>
</ul>
<p>为了避免快排出现上述所说的最坏情况，选择哪一个元素作为基准点是关键，<strong>在快排过程中采用三点取中间值的优化方案。三数取中<code>median-of-three</code>指的是在挑选基准元素时，不是简单的选择数组中的第一个元素或最后一个，而是选取某三个元素，常选头、尾和中央三个元素，并且适用三个元素之中的中位数作为基准元素进行划分</strong>。这样即使在最坏的情况下将时间复杂度推进到<code>O(NlogN)</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后的快排代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">medianOfThree</span>(a, first, (first + last) / <span class="number">2</span>, last);</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--; </span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cap[first] &lt; cap[mid])</span><br><span class="line">        <span class="keyword">if</span> (cap[first] &gt;= cap[last])	<span class="comment">//last=&lt;first&lt;mid</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&lt;mid&lt;last</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[mid];</span><br><span class="line">            cap[mid] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">// first&lt;last&lt;=mid</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[last];</span><br><span class="line">            cap[last] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[first] &lt; cap[last])	<span class="comment">//last&gt;first&gt;=mid</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&gt;=mid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[last];</span><br><span class="line">        cap[last] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[mid];</span><br><span class="line">        cap[mid] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.png" width="600"> 上图对优化后和优化前的快排进行了测试，很明显三数取中后对与升序和降序数组的时间得到了大大的改善，避免了最坏情况，逼近<code>O(NlogN)</code>,<strong>但是对于重复数组的优化还不能得到很好的改善，因此可以在三数取中的快排中加入以下的策略：</strong></p>
<ul>
<li><p>优化一：当待排序序列的长度分割到一定大小后，使用插入排序，这是因为对于很小部分大致有序的数组，快排不如插排效率。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</p></li>
<li><p>优化二：当待排序序列的长度分割到一定大小后如100个，使用计数排序，这样能够很明显的提升大量重复值情况下的效率</p></li>
</ul>
<h5 id="堆排序">1.6 堆排序*</h5>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个完全二叉树的结构，并同时满足堆的的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p>
<p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
<ul>
<li><strong>基本思想</strong>：
<ul>
<li><p><strong>插入：</strong>因为<strong>堆是完全二叉树，所以当加入一个元素形时，必须维持该堆仍为完全二叉树</strong>，即该新节点位置由此定下了肯定为叶子结点。接着元素插入要依据原来是大根堆还是小根堆（即不能破环该堆的性质）。把插入的元素，沿着从新节点到根节点的路径<code>i/2</code>，执行一趟冒泡操作，将新元素与其夫节点的元素比较交换，直到后者大于前者（大根堆为例）。</p></li>
<li><p><strong>删除：在大根堆中删除一个元素，其实就是删除根节点的元素</strong>。此时就需要重新组织，以便保持性质不变 。其策略是，从删除的位置开始为一个树,向下找，找到该树的最后一个叶子节点，删除该节点但保存元素到临时量；然后比较节点的左右孩子，将大的放到该根节点；这时因为大孩子的被放到根节点而成为了空(没有元素），以此类推，直到最后一个叶子我们与之前中间量保存的元素比较，完成删除排序，</p></li>
<li><p><strong>初始化：</strong>当堆刚开始时就要有n个元素，我们就要构建非空堆，我们需要在堆中执行n次插入操作。先将元素按层次插入，取位置在i=n/2的元素，如果以这个元素为根的子树是大根堆则不做操作，如果不是大根堆则从该节点开始的树进行检测替换，依次检查i-1,i-2……1</p></li>
</ul></li>
<li><p><strong>复杂度</strong>：堆排序的时间复杂度是标准的<code>O(nlogn)</code>。用数组实现堆的功能，故空间复杂度为<code>O(1)</code></p></li>
<li><p><strong>稳定性</strong>：堆排序并不是进行线性的比较，而是根据堆的结构进行比较，所以在交换时会破坏相等元素原本的相对顺序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/heapSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆插入</span></span><br><span class="line"><span class="comment">该方法通过查询当前堆的大小和元素比较定位插入点，进行大根堆完全二叉树形式插入即`/2`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T&amp; heap,<span class="type">const</span> T&amp; theElement)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> currentNode=++heapsize;</span><br><span class="line">	<span class="comment">//通过比较寻找插入点，比插入值小的元素下沉</span></span><br><span class="line">	<span class="keyword">while</span>(currentNode!=<span class="number">1</span>&amp;&amp;heap[currentNode/<span class="number">2</span>]&lt;theElement)</span><br><span class="line">	&#123;</span><br><span class="line">		heap[currentNode]=heap[currentNode/<span class="number">2</span>];</span><br><span class="line">		currentNode/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入新值</span></span><br><span class="line">	heap[currenNode]=theElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆删除</span></span><br><span class="line"><span class="function">templaet&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; heap)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(heapsize==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	heap[<span class="number">1</span>].~<span class="built_in">T</span>();		<span class="comment">//销毁根节点元素</span></span><br><span class="line">	T lastElement=heap[heapsize];	<span class="comment">//最后一个元素保存到临时变量</span></span><br><span class="line">	heap[heapsize--].~<span class="built_in">T</span>();			<span class="comment">//销毁最后一个元素</span></span><br><span class="line">	<span class="type">int</span> currentNode=<span class="number">1</span>,child=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;heapsize)</span><br><span class="line">	&#123;	<span class="comment">//元素进行上升</span></span><br><span class="line">		<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="comment">//判断lastElement是否可以放在heap[child]上</span></span><br><span class="line">		<span class="keyword">if</span>(lastElement&gt;=heap[child])	<span class="comment">//可以就直接退出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		heap[currentNode]=heap[child];</span><br><span class="line">		currentNode=child;</span><br><span class="line">		child*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currentNode]=lastElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(T&amp; Heap,std::<span class="type">size_t</span> _heapsize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	heapsize=_heapsize;</span><br><span class="line">	<span class="comment">//从下往上进行堆化，即从heapsize/2开始，直到root=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> root=heapsize/<span class="number">2</span>;root&gt;=<span class="number">1</span>;root--)</span><br><span class="line">	&#123;</span><br><span class="line">		T rootElement=heap[root];</span><br><span class="line">		<span class="type">int</span> child=<span class="number">2</span>*root;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;=heapsize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span>(rootElement&gt;=heap[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			heap[child/<span class="number">2</span>]=heap[child];</span><br><span class="line">			child*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[child/<span class="number">2</span>]=rootElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你也可以不用写堆排序，直接使用STL当中的<code>push_heap、pop_heap、make_heap</code>进行插入、删除和初始化一个堆。</p>
<h5 id="基数排序">1.7 基数排序*</h5>
<p>基数排序是一种<strong>非比较型整数排序算法</strong>，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<ul>
<li><strong>基本思想</strong>：基数排序排序主要通过将数字分解进行排序，如三位数的925，基数排序可通过十进制分解，将925分解成9、2、5三个数，然后依次以个位、十位、百位进行排序。<strong>在这个过程中，因为数字只有0~9,所有仅仅需要10个桶就，然后调用三次箱子排序即可</strong>：
<ul>
<li>1.将无序集合中的所有元素根据个位的大小分别分配到0-9十个桶中；</li>
<li>2.从个位为0的桶开始依据每个元素的十位将元素分配到0-9十个桶中；</li>
<li>3.每次依据的位数增加一位（百位，千位，万位），直到集合中最大的数的位数为止；</li>
<li>4.最后一次分配完成后从第0个桶开始依次取出元素，直到所有的元素被取出来，这个取出的顺序可以保证元素是从小到大的；</li>
</ul></li>
<li><p><strong>复杂度</strong>：每一次散列需要对每个元素进行分配，即n次操作，最多进行最大的数的位数轮散列分配，即k轮，所以时间复杂度为<code>O(n*k)</code>。基数排序需要<code>n+m</code>个额外空间，其中<code>n</code>为待排序集合大小，<code>m</code>为10（无负数元素）或<code>20</code>（有负数元素）</p></li>
<li><p><strong>稳定性</strong>：基数排序不会破坏相等元素的相对顺序，所以是稳定的 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/radixSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(T&amp; cap,<span class="type">int</span> place)</span> </span>&#123;	</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,num=<span class="number">1</span>; i &lt; place; i++,num*=<span class="number">10</span>) &#123;<span class="comment">//num指示对哪一位进行基数排序</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">tempVec</span>(<span class="number">10</span>);<span class="comment">//二维数组，内部vector的大小看数据量 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cap.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = cap[i] / num % <span class="number">10</span>;</span><br><span class="line">            tempVec[index].<span class="built_in">push_back</span>(cap[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cap.<span class="built_in">clear</span>();		<span class="comment">//清除里面的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)		<span class="comment">//放回vec</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = tempVec[i].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (it != tempVec[i].<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cap.<span class="built_in">push_back</span>(*it);</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="归并排序">1.8 归并排序**</h5>
<ul>
<li><strong>基本思想</strong>：归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法<code>Divide and Conquer</code>的一个非常典型的应用。<strong>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序</strong>。若将两个有序表合并成一个有序表，称为二路归并。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：一是自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；二是自下而上的迭代；
<ul>
<li>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>4.重复步骤 3 直到某一指针达到序列尾；</li>
<li>5.将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul></li>
<li><p><strong>复杂度</strong>：很明显归并排序需要<code>logn</code>轮合并，每轮合并需要<code>n-1~n/2</code>次比较，所以时间复杂度为<code>O(nlogn)</code>.归并排序比较占用内存，但却是一种效率高且稳定的算法，其需要临时空间存储归并后的数据，因此空间复杂度为<code>O(N)</code></p></li>
<li><p><strong>稳定性</strong>：归并排序的合并操作并不会影响相同元素的相对顺序，故稳定。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//使用迭代实现二路归并排序</span></span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(len);       <span class="comment">//合并空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)</span><br><span class="line">    &#123;   <span class="comment">//logn趟合并</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//合并相邻两子序列</span></span><br><span class="line">            <span class="type">int</span> next = j + i;</span><br><span class="line">            <span class="type">int</span> k = j;</span><br><span class="line">            <span class="keyword">while</span>(k &lt;(j+i) &amp;&amp; k&lt;len &amp;&amp; next &lt; len &amp;&amp; next &lt; (j+<span class="number">2</span>*i) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cap[k] &lt;= cap[next])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[index] = cap[k];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[index] = cap[next];</span><br><span class="line">                    next++;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k&lt;len &amp;&amp;k &lt; j + i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[index] = cap[k];</span><br><span class="line">                index++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (next &lt; len &amp;&amp; next &lt; j + <span class="number">2</span> * i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[index] = cap[next];</span><br><span class="line">                index++;</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            j = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), cap.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="计数排序">1.9 计数排序</h5>
<ul>
<li><p><strong>基本思想：</strong>计数排序的核心在于<strong>将输入的数据值转化为键存储在额外开辟的数组空间中</strong>。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<strong>确定范围的整数</strong>。当输入的元素是<code>n</code>个0到k之间的整数时，它的运行时间是<code>Θ(n + k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。<strong><em>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量内存，因此堆数据范围很大的不适用，该排序算法最号应用于数据范围不大重复值多的情况</em></strong>。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>遍历数组<code>cap</code>，对值<code>i</code>作为cap的下标存入<code>+1</code>,即<code>C[i]++</code>;</li>
<li>对所有的重复值计数累加</li>
<li>从前往后遍历数组C，将对应的下标index作为值存人<code>cap</code>，并在<code>C[index]-1</code></li>
</ul></li>
<li><p><strong>复杂度</strong>：计数排序的时间复杂度与待排序元素的范围相关，其时间复杂度为<code>O(n+k)</code>,其中<code>n</code>为元素数量，<code>k</code>为元素的范围（即最大的元素与最小的元素的差加1）。计数排序需要额外开辟k个桶的空间，所以空间复杂度为<code>(k)</code>。</p></li>
<li><p><strong>稳定性</strong>：计数排序是一个非基于比较的线性时间排序算法,所以看出是一种稳定排序 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/countingSortgif.gif" width="600"></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(T&amp; cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = cap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxValue = <span class="built_in">getMaxValue</span>(cap)+<span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(maxValue)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : cap)</span><br><span class="line">        tmp[i]++;</span><br><span class="line">    <span class="type">int</span> _index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxValue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (tmp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cap[_index] = i;</span><br><span class="line">            tmp[i]--;</span><br><span class="line">            _index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="桶排序">1.10 桶排序*</h5>
<ul>
<li><strong>基本思想</strong>：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：<strong>一是在额外空间充足的情况下，尽量增大桶的数量；二是使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</strong>。同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。
<ul>
<li>1.开辟m大小的空间，生成m个桶，每个桶对应一个范围；</li>
<li>2.将待排序的所有元素依次按照范围散列到对应的桶里；</li>
<li>3.对所有的桶内的元素以桶为单位排序；</li>
<li>4.从第一个桶开始依次将排好序的元素取出；</li>
</ul></li>
<li><p><strong>复杂度</strong>：对于待排序序列大小为<code>N</code>，共分为<code>M</code>个桶，<code>N</code>次循环，将每个元素装入对应的桶中。<code>M</code>次循环，对每个桶中的数据进行排序（平均每个桶有<code>N/M</code>个元素）。一般使用较为快速的排序算法，时间复杂度为 O(N/MlogN/M)，整个桶排序的时间复杂度为：<code>O(N)+O(M∗(N/M∗log(N/M))) = O(N)+O(N∗(log(N/M)) = O(N)+O(C）= O(N∗(log(N/M)+1))</code>；桶排序需要额外的m个桶的空间和n个元素的空间，故空间复杂度为<code>O(m+n)</code>。</p></li>
<li><p><strong>稳定性</strong>：桶排序的稳定性取决于桶内排序使用的算法，所以我们通常认为桶排序是稳定排序。 <img src="/2022/07/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bucketSort.png" width="400"></p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">537k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
