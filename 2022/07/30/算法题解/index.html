<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="0. 刷题规划 读者在看到这篇文章的时候不应该以本文的讲解顺序进行刷题。正常来说，按模块刷题是最好的，我的刷题是按照数组-&gt;链表-&gt;树-&gt;dp的循环进行，然后对各模块的方法进行总结，比如遇到 - 数组一类的，其可使用的方法最多：二分查找、快慢指针、双指针、滑动窗口、前缀和数组、差分数组等。 - 遇到链表，那么快慢指针是最多的。 - 遇到树，那么递归（广度or深度）是最常用的形式">
<meta property="og:type" content="article">
<meta property="og:title" content="算法题解">
<meta property="og:url" content="https://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:description" content="0. 刷题规划 读者在看到这篇文章的时候不应该以本文的讲解顺序进行刷题。正常来说，按模块刷题是最好的，我的刷题是按照数组-&gt;链表-&gt;树-&gt;dp的循环进行，然后对各模块的方法进行总结，比如遇到 - 数组一类的，其可使用的方法最多：二分查找、快慢指针、双指针、滑动窗口、前缀和数组、差分数组等。 - 遇到链表，那么快慢指针是最多的。 - 遇到树，那么递归（广度or深度）是最常用的形式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/offer69.png">
<meta property="og:image" content="https://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/69.png">
<meta property="og:image" content="https://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/39.png">
<meta property="og:image" content="https://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/31.gif">
<meta property="article:published_time" content="2022-07-30T13:30:13.000Z">
<meta property="article:modified_time" content="2023-08-25T03:11:05.258Z">
<meta property="article:author" content="trluper">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/offer69.png">

<link rel="canonical" href="https://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法题解 | Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法题解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 21:30:13" itemprop="dateCreated datePublished" datetime="2022-07-30T21:30:13+08:00">2022-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-25 11:11:05" itemprop="dateModified" datetime="2023-08-25T11:11:05+08:00">2023-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>75k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:08</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="刷题规划">0. 刷题规划</h2>
<p>读者在看到这篇文章的时候不应该以本文的讲解顺序进行刷题。正常来说，按模块刷题是最好的，我的刷题是按照<strong>数组-&gt;链表-&gt;树-&gt;dp</strong>的循环进行，然后对各模块的方法进行总结，比如遇到 - <strong>数组一类</strong>的，其可使用的方法最多：<strong>二分查找、快慢指针、双指针、滑动窗口、前缀和数组、差分数组</strong>等。 - 遇到<strong>链表</strong>，那么<strong>快慢指针是最多的</strong>。 - 遇到<strong>树</strong>，那么递归（广度or深度）是最常用的形式、非递归遍历也要顺序，记住对称性解题方式。 - 遇到<strong>动态规划</strong>，先分类其是属于哪种形式的dp（<strong>线性dp、区间dp、背包dp和状压dp</strong>），然后确定dp含义，分析状态转移方程。 - 其他方法，比如**单调栈、单调队列的实现、拓扑排序、归并排序、KMP算法、分治、广度*等算法就就需要在刷题中不断掌握</p>
<p><strong><em>注意：在解题中一定不要忽略暴力解，许多奇妙的解法就是从暴力解的思路上想出来的，一旦遇到一道不会优解的题，可以先想一想暴力解的思路，有什么地方可以优化暴力解，来达到降低时间复杂度的效果</em></strong></p>
<h2 id="动态规划类">1. 动态规划类</h2>
<p>动态规划的思想就是：<strong>如果一个问题能够由子问题一步步递推得来，即当前子问题的解将由上一次子问题的解推出，利用这种特性，使用一个数据结构<code>dp</code>来存储上一次子问题的结果，避免重复计算</strong>。</p>
<p>所以动态规划最重要的有三点：</p>
<ul>
<li>确定dp的含义</li>
<li>确定dp的初始状态</li>
<li>确定dp间的状态转移方程</li>
</ul>
<p>知道上述三点，问题也就迎刃而解。在算法当中，常见的dp类型有<strong>线性dp、区间dp、背包dp和状压dp</strong>。下面将对这几个进行讲解。</p>
<p><strong>总结</strong>：对于是否使用DP，那么就得看你能不能确定dp数组的含义，以及能够确定状态转移方程。</p>
<h3 id="线性dp">1.1 线性DP</h3>
<h4 id="打家劫舍">打家劫舍</h4>
<p><strong>问题：</strong>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态规划：当我们以nums[i]作为结尾计算其最大金额时，每次都要遍历得到当0~i-2结尾时的最大金额</span></span><br><span class="line"><span class="comment">因此我们可以使用动态规划来存储这些值，避免重复计算</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义：dp[i]表示nums[0]-nums[i]能偷的最大金额</span></span><br><span class="line"><span class="comment">- 初始条件：dp[0]=nums[0],dp[1]=max(nums[0],nums[1])</span></span><br><span class="line"><span class="comment">- 状态转移方程：dp[i]=max(dp[i-2]+nums[i],dp[i-1])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">2</span>);i&lt;len;++i)</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="打家劫舍-1">打家劫舍Ⅱ</h4>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。<strong>这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的</strong>。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<p><strong>解题思路：与打家劫舍多了一个约束：这个地方所有的房屋都 围成一圈，第一个房屋和最后一个房屋是相连的,需要考虑这种情况</strong></p>
<p>还是使用动态规划：<code>dp[i]</code>表示截至到<code>i+1</code>号房能够偷盗的最大金额，此时需要做两次不同的<code>dp</code>比较，</p>
<ul>
<li>一个是选择<code>1</code>号房屋，此时就不能选择最后一个房屋
<ul>
<li>初始状态：<code>dp1[0]=nums[0],dp[1]=max(dp1[1],dp1[0])</code></li>
<li>状态转移: <code>dp1[i]=max(dp1[i-2]+nums[i],d1[i-1])  1&lt;i&lt;n-1</code></li>
</ul></li>
<li>另一个是不选择1号屋，此时对最后一个房屋没有要求
<ul>
<li>初始状态：<code>dp2[1]=nums[1],dp2[2]=max(dp2[1],dp2[2]);</code></li>
<li>状态转移：<code>dp2[i]=max(dp2[i-2]+nums[i],dp2[i-1])  2&lt;i&lt;n</code></li>
</ul></li>
<li>最后<code>max(dp1[n-2],dp2[n-1])</code></li>
</ul>
<p>上面的dp数组可省略，因为当前状态只与前两个有关</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*/</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//vector&lt;int&gt;dp1(n-1,0);</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt;dp2(n,0);</span></span><br><span class="line">        <span class="comment">//dp1[0]=nums[0],dp1[1]=max(nums[0],nums[1]);</span></span><br><span class="line">        <span class="type">int</span> dp1_1=nums[<span class="number">0</span>],dp1_2=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="comment">//dp1[i]=max(dp1[i-2]+nums[i],dp1[i-1]);</span></span><br><span class="line">            <span class="type">int</span> temp=dp1_1;</span><br><span class="line">            dp1_1=dp1_2;</span><br><span class="line">            dp1_2=<span class="built_in">max</span>(temp+nums[i],dp1_2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp2[1]=nums[1],dp2[2]=max(nums[1],nums[2]);</span></span><br><span class="line">        <span class="type">int</span> dp2_1=nums[<span class="number">1</span>],dp2_2=<span class="built_in">max</span>(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//dp2[i]=max(dp2[i-2]+nums[i],dp2[i-1]);</span></span><br><span class="line">            <span class="type">int</span> temp=dp2_1;</span><br><span class="line">            dp2_1=dp2_2;</span><br><span class="line">            dp2_2=<span class="built_in">max</span>(temp+nums[i],dp2_2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//return max(dp1[n-2],dp2[n-1]);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp1_2,dp2_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="打家劫舍-2">打家劫舍Ⅲ</h4>
<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root </code>。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p>
<p>给定二叉树的<code> root</code> 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p>
<p><strong>解题思路：</strong></p>
<p><strong>使用动态规划+深度搜索：</strong>使用分解成子问题的方式来解决，因为一个节点只有选与不选两者可能，选会对其他节点产生影响，那么我们从自低向上的方式来解决，将一颗树分解成多个子树的求解过程，通过子树不断向整颗树递进进行求解，比如对于root，我们向求出其左右子树选与不选时的金额，我们用<code>dp[2]</code>记录，<code>dp_r[0]</code>表示不选择该右节点时右子树能得到的最大金额，<code>dp_r[1]</code>表示选择该右节点时右子树能得到的最大金额，同理<code>dp_l[0]</code>和<code>dp_l[1]</code>，那么对于<code>root</code>，它的 <code>dp_root[1]=dp_r[0]+dp_l[0]+root,dp_root[0]=max(dp_r[0],dp_l[1])+max(dp_l[0],dp_l[1]);</code></p>
<p>因此，解题步骤：</p>
<ul>
<li>构建一个<code>rootdfs(left,right)</code>，返回<code>vector&lt;int&gt;</code></li>
<li>每一次递归都要构建<code>dp[2],dp[0]</code>表示不选择改节点，<code>dp[1]</code>选择</li>
<li>初始条件<code>dp[]=0</code></li>
<li>状态转移条件：<code>dp[0]=max(dp_r[0],dp_l[1])+max(dp_l[0],dp_l[1]); dp[1]=dp_r[0]+dp_l[0]+root</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> vector&lt;<span class="type">int</span>&gt; <span class="title">robdfs</span><span class="params">(TreeNode* l,TreeNode* r,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp_l</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span>,<span class="title">dp_r</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="literal">nullptr</span>) dp_l=<span class="built_in">robdfs</span>(l-&gt;left,l-&gt;right,l-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="literal">nullptr</span>) dp_r=<span class="built_in">robdfs</span>(r-&gt;left,r-&gt;right,r-&gt;val);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="built_in">max</span>(dp_r[<span class="number">0</span>],dp_r[<span class="number">1</span>])+<span class="built_in">max</span>(dp_l[<span class="number">0</span>],dp_l[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">1</span>]=dp_r[<span class="number">0</span>]+dp_l[<span class="number">0</span>]+value;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>) dp=<span class="built_in">robdfs</span>(root-&gt;left,root-&gt;right,root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>],dp[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最大子数组的和">最大子数组的和</h4>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*动态规划：dp[i][j]，表示[i,j]范围的子数组和，我们只需记录出现的最大和即可maxValue</span></span><br><span class="line"><span class="comment">*  - 初始条件时dp[i][i]=nums[i]</span></span><br><span class="line"><span class="comment">*  - 状态转移条件时dp[i][j]=dp[i][j-1]+nums[j]</span></span><br><span class="line"><span class="comment">*时间复杂度为O(n*n)，空间复杂度为O(n*n)</span></span><br><span class="line"><span class="comment">：超时：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*优化：空间复杂度为O(1),时间复杂度为为O(n*n):超时</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*时间复杂度O(n)解法：dp</span></span><br><span class="line"><span class="comment">*从前往后遍历一下即可，要记录前面包含i-1连续子数组的和sum：</span></span><br><span class="line"><span class="comment">*- 若当前nums[i]&gt;=0，sum&gt;=0,则子数组和为sum+nums[i]</span></span><br><span class="line"><span class="comment">*- 若当前nums[i]&gt;=0，当sum&lt;0，则当前子数组和为nums[i]</span></span><br><span class="line"><span class="comment">*- 若当前nums[i]&lt;0，当sum+nums[i]&gt;=0时，可选择nums[i]继续作为连续子数组</span></span><br><span class="line"><span class="comment">*- 当nums[i]&lt;0,当sum+nums[i]&lt;0时，放弃nums[i],重新以i+1作为开始</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 上面分析总结为动态规划就是，dp[i]，i表示以nums[i]为结尾的子数组和的最大值</span></span><br><span class="line"><span class="comment">- 初始条件dp[0]=nums[0]</span></span><br><span class="line"><span class="comment">- 状态转移dp[i]=max(dp[i-1]+nums[i],nums[i])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxValue=nums[<span class="number">0</span>];</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(maxValue&lt;dp[i])</span><br><span class="line">                maxValue=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="剑指offer-丑数">剑指offer 丑数</h4>
<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 &gt;质数：因子除了1和它本身外，无其他因子</p>
<p><strong>思路：</strong>优化方法我们只需要考虑2的倍数、3的倍数和5的倍数即可</p>
<ul>
<li>此时需要更改<code>dp[i]</code>数组含义，<code>dp[i]</code>表示目前得到<code>i+1</code>个丑数是<code>dp[i]</code>，这就要保证dp[i]是递增顺序的无重复的</li>
<li>初始条件<code>dp[0]=1</code></li>
<li>难点：为了得到状态转移方程，因为有三个乘积因子2，3，5，如果一股脑不加以判断的添加，会出现非递增存储和重复的结果。比如，从dp[0]于2、3、5相乘后会得到1、2、3、5，之后dp[1]得到1、2、3、5、4、6、10，再dp[2]得到1、2、3、5、4、6、10、6、9、15...明显存在重复和乱序以及重复计算</li>
<li>因此可以使用<code>a、b、c</code>去记录分别要与<code>2、3、5</code>将要相乘的<code>dp[j]</code>，能够很好的解决乱序和重复问题,初始时<code>a=b=c=0</code></li>
<li>所以状态转移方程为：<code>dp[i]=min(min(dp[a]*2,dp[b]*3),dp[c]*5)</code>,然后于<code>dp[i]</code>相等的索引即<code>a、b、c</code>进行<code>++</code></li>
<li>直到<code>dp.size()==n</code>，然后对dp排序去最后一个元素得到第<code>n</code>个丑数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*动态规划：dp[i]记录数字i是否为丑数，是则为true,</span></span><br><span class="line"><span class="comment">*初始dp[0]=false,dp[1]=true</span></span><br><span class="line"><span class="comment">*状态转移方程dp[i]=dp[i/2]||dp[i/3]||dp[i/5],其中i/2、i/3和i/5必须为整数</span></span><br><span class="line"><span class="comment">*会超时</span></span><br><span class="line"><span class="comment">*优化：我们只需要考虑2的倍数、3的倍数和5的倍数即可</span></span><br><span class="line"><span class="comment">*此时需要更改dp[i]数组含义，dp[i]表示目前得到i+1个丑数是dp[i]</span></span><br><span class="line"><span class="comment">*- 初始条件dp[0]=1</span></span><br><span class="line"><span class="comment">*- 难点：为了得到状态转移方程，因为有三个乘积因子2，3，5，如果一股脑不加以判断的添加，会出现非递增存储和重复的结果。比如，从dp[0]于2、3、5相乘后会得到1、2、3、5，之后dp[1]得到1、2、3、5、4、6、10，再dp[2]得到1、2、3、5、4、6、10、6、9、15...明显存在重复和乱序以及重复计算</span></span><br><span class="line"><span class="comment">*- 因此可以使用a、b、c去记录分别要与2、3、5将要相乘的dp[j],初始时a=b=c=0</span></span><br><span class="line"><span class="comment">*- 所以状态转移方程为：dp[i]=min(min(dp[a]*2,dp[b]*3),dp[c]*5),然后于dp[i]相等的索引即a、b、c进行++</span></span><br><span class="line"><span class="comment">*直到dp.size()==n，然后对dp排序去最后一个元素得到第n个丑数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*超时规划</span></span><br><span class="line"><span class="comment">    int nthUglyNumber(int n) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;bool&gt; dp;</span></span><br><span class="line"><span class="comment">        dp.push_back(false);//dp[0]</span></span><br><span class="line"><span class="comment">        dp.push_back(true);//dp[1]</span></span><br><span class="line"><span class="comment">        n--;</span></span><br><span class="line"><span class="comment">        for(int i=2;n&gt;0;++i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if((i%2==0&amp;&amp;dp[i/2])||(i%3==0&amp;&amp;dp[i/3])||(i%5==0&amp;&amp;dp[i/5]))&#123;</span></span><br><span class="line"><span class="comment">                dp.push_back(true);</span></span><br><span class="line"><span class="comment">                --n;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            dp.push_back(false);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return dp.size()-1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//得到顺序丑数</span></span><br><span class="line">            <span class="type">int</span> n2=dp[a]*<span class="number">2</span>,n3=dp[b]*<span class="number">3</span>,n5=dp[c]*<span class="number">5</span>;</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(<span class="built_in">min</span>(n2,n3),n5);</span><br><span class="line">			<span class="comment">//避免重复丑数</span></span><br><span class="line">            <span class="keyword">if</span>(n2==dp[i]) ++a;</span><br><span class="line">            <span class="keyword">if</span>(n3==dp[i]) ++b;</span><br><span class="line">            <span class="keyword">if</span>(n5==dp[i]) ++c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="n个骰子的点数">n个骰子的点数</h4>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p><strong>思路：</strong></p>
<ul>
<li><code>n(n&gt;1)</code>个骰子的点数与<code>n-1</code>个骰子的点数有着密切联系，假设<code>f(n-1)</code>是<code>n</code>个骰子的点数概率结果，和为<code>x</code>的概率为<code>f(n-1,x)</code>，那么<code>f(n,x)</code>的概率结果是<code>Σf(n-1,x-i)*1/6</code>，其中<code>i=1,...,6;</code>且<code>6(n-1)&gt;=x-i&gt;=(n-1)</code></li>
<li>因为只与上一个结果有关，因此可以使用两个数组来完成，第一个是存储<code>n-1</code>个骰子的概率结果，第二个依据<code>n-1</code>来构建</li>
</ul>
<p><strong>算法过程：</strong></p>
<ul>
<li>因此上面的思想是动态规划：使用<code>dp1[i]</code>，表示<code>k-1</code>个骰子的概率结果，<code>dp[i]</code>为<code>k</code>个骰子的概率结果</li>
<li>初始条件： <code>dp1[1]=dp1[2]=..=dp1[6]=1/6</code></li>
<li>状态转移方程<code>dp[j]=Σdp1[j-i]*1/6</code> 其中<code>6(k-1)&gt;j-i&gt;=(k-1)和i=1,...,6</code></li>
<li>更新<code>dp1=dp</code>，继续上述步骤，直到<code>k&gt;n</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> a=<span class="number">1.0</span>/<span class="number">6.0</span>;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt;<span class="built_in">dp1</span>(<span class="number">7</span>,a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">k</span>(<span class="number">2</span>);k&lt;=n;++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len=<span class="number">6</span>*k+<span class="number">1</span>;</span><br><span class="line">            vector&lt;<span class="type">double</span>&gt;<span class="built_in">dp</span>(len,<span class="number">0.0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">j</span>(k);j&lt;len;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>);i&lt;<span class="number">7</span>;++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>((j-i)&gt;=(k<span class="number">-1</span>)&amp;&amp;(j-i)&lt;=<span class="number">6</span>*(k<span class="number">-1</span>))</span><br><span class="line">                        dp[j]+=dp1[j-i]*a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp1=dp;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;dp1.<span class="built_in">size</span>();++i)</span><br><span class="line">            ret.<span class="built_in">push_back</span>(dp1[i]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="单词拆分">单词拆分</h4>
<p>给你一个字符串<code>s</code>和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p><strong>思路：</strong> 遍历<code>s</code>的字符串进行拼接，查看该子串是否在<code>wordDict</code>中，子串的状态会被上一个状态所影响，因此可采用动态规划的思想来解决（比如<code>&quot;catsandog&quot;</code>和<code>[&quot;c&quot;,&quot;cats&quot;,&quot;an&quot;,&quot;dog&quot;]</code>）</p>
<p><strong>解题步骤</strong>：</p>
<ul>
<li>动态规划+哈希：使用<code>dp[i]</code>表示字符串从<code>[1,i]</code>是否可有<code>wordDict</code>构成，是则为<code>true</code>,否则为<code>false</code></li>
<li>初始状态：<code>dp[0]=true</code>,表示空串，是能够表示的，</li>
<li>状态转移方程：<code>dp[i+1]=dp[j]&amp;&amp;(s[j,i] in wordDict?)</code>,其中<code>j</code>取值满足<code>i-j&lt;=20</code>（或者也可得到<code>wordDict</code>字符串的最大长度，以此达到剪枝的目的）</li>
<li>其中从字典中查找<code>s[j,i]</code>会消耗大多是时间，我们可将<code>wordDict</code>放在哈希上，使查找的时间复杂度为<code>O(1)</code></li>
<li>因此以上时间复杂度为<code>O(n*n)</code>，空间复杂度为<code>O(n)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">bool</span>&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">       unordered_set&lt;string&gt; Set;</span><br><span class="line">       dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">       <span class="type">int</span> maxLen=<span class="number">0</span>;    <span class="comment">//记录字典的最长字符串的长度，达到剪枝目的</span></span><br><span class="line">       <span class="keyword">for</span>(string t:wordDict)</span><br><span class="line">       &#123;</span><br><span class="line">           Set.<span class="built_in">insert</span>(t);</span><br><span class="line">           maxLen=maxLen&gt;t.<span class="built_in">size</span>()?maxLen:t.<span class="built_in">size</span>();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i;!dp[i+<span class="number">1</span>]&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;len&lt;=maxLen;--j)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="function">string <span class="title">str</span><span class="params">(s.substr(j,len))</span></span>;</span><br><span class="line">               ++len;</span><br><span class="line">               <span class="keyword">if</span>(dp[j]&amp;&amp;Set.<span class="built_in">find</span>(str)!=Set.<span class="built_in">end</span>())</span><br><span class="line">                    dp[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="接雨水">接雨水</h4>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>题解思路：</strong></p>
<ul>
<li><p><strong>暴力方法：</strong> 对每一个遍历得到的柱子，分别遍历得到其左右的柱子的最大值，可得当前位置可接雨水<code>min(height[l],height[h])-height[i]</code>,此时时间复杂度为<code>O(n*n</code>，不能接受</p></li>
<li><strong>动态规划类型：</strong> 上面暴力方法中，为了得到当前位置可接雨水数量，要遍历左右两边，存在大量的重复计算，可以使用两个数组<code>leftmax[i]</code>和<code>rightmax[i]</code>来记录当前位置i左右两边的最高柱子高度，其中<code>leftmax[max]</code>在计算中更新，<code>right[max]</code>事前全部准备好，此时时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(n)</code>
<ul>
<li>即<code>leftmax[i]</code>和<code>rightmax[i]</code>来记录当前位置i左右两边的最高柱子高度</li>
<li>初始条件为<code>leftmax[0]=height[0]</code>,<code>leftmax为倒叙遍历后的最大值情况</code></li>
<li>状态转移方程是leftmax[i]=max(height[i,leftmxa[i-1]]),根据比较记录<code>sum=min(leftmax[i],rightmax[i])-height[i]</code></li>
</ul></li>
<li><strong>双指针类型：</strong> 上面的动态规划由于要存储左右最大值使得空间复杂度为<code>O(n)</code>，进一步分析可知可使用双指针，其中<code>l</code>为左指针，<code>h</code>为右指针，我们发现存水多少取决于左右最大值较小的那一个，那么无论最大那个多大，都不是它决定，而是较小的决定。
<ul>
<li>所有我们定义<code>leftmax，rightmax</code>，来记录左右指针目前走过区域的最大值，其中<code>l</code>只会向右走，<code>h</code>只会向左走</li>
<li>更新策略是用<code>height[l]</code>，<code>height[h]</code>更新<code>leftmax、rightmax</code></li>
<li>当<code>height[l]&gt;height[h]</code>时,可以肯定<code>lefmax&gt;rightmax</code>,因此可接雨水是<code>rightmax-height[h]</code>，此时--h;</li>
<li>当<code>height[l]&lt;=height[h]</code>时，可以肯定<code>lefmax&lt;=rightmax</code>,因此可接雨水是<code>leftmax-height[l]</code>，此时<code>++l</code>; -当<code>l&gt;h</code>时退出，累计的雨水即为所求</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,h=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> leftmax=<span class="number">0</span>,rightmax=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;h)</span><br><span class="line">        &#123;</span><br><span class="line">            leftmax=<span class="built_in">max</span>(leftmax,height[l]);</span><br><span class="line">            rightmax=<span class="built_in">max</span>(rightmax,height[h]);</span><br><span class="line">            <span class="keyword">if</span>(height[l]&gt;height[h])</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=rightmax-height[h];</span><br><span class="line">                --h;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=leftmax-height[l];</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*dp</span></span><br><span class="line"><span class="comment">        int n=height.size();</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; rightmax(n,0);</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt;leftmax(n,0);</span></span><br><span class="line"><span class="comment">        rightmax[n-1]=height[n-1];</span></span><br><span class="line"><span class="comment">        leftmax[0]=height[0];</span></span><br><span class="line"><span class="comment">        int sum=0;</span></span><br><span class="line"><span class="comment">        for(int i=height.size()-2;i&gt;=0;--i)</span></span><br><span class="line"><span class="comment">            rightmax[i]=max(height[i],rightmax[i+1]);</span></span><br><span class="line"><span class="comment">        for(int i(1);i&lt;n;++i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            leftmax[i]=max(leftmax[i-1],height[i]);</span></span><br><span class="line"><span class="comment">            sum+=min(leftmax[i],rightmax[i])-height[i];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最佳买股票时机含冷冻期">最佳买股票时机含冷冻期</h4>
<p>给定一个整数数组<code>prices</code>，其中第  <code>prices[i]</code> 表示第<code> i </code>天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
<li>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>因为多了个冷冻期的约束，这表示对于卖出股票后，后续能否买入，要看是否处于冷冻期 动态规划：使用二维dp解决，<code>dp[i][j]</code>中，其中第一维度表示到第<code>i</code>天能够得到最大利润，<code>p[i][0]</code>表示目前没持有股票且不处于冷冻期的最大利润；<code>p[i][1]</code>表示未持有股票且处于冷冻期，这表示在第i天卖出；<code>dp[i][2]</code>表示持有一个股票时的最大利润</p>
<ul>
<li>初始条件：<code>dp[0][0]=0,dp[0][1]=0,dp[0][2]=-prices[0]</code></li>
<li>状态转移方程：<code>dp[i][0]=max(dp[i-1][0],dp[i-1][1]);dp[i][1]=dp[i-1][2]+prices[i];dp[i][2]=max(dp[i-1][2],dp[i-1][0]-prices[i])</code></li>
</ul>
<p><strong>总结：像这样对于中间状态有多个不同的情况，在运用动态规划的时候，单个维度dp无法表示，通常可以扩展到二维，定义二维度含义表示（比如<code>打家劫舍Ⅲ</code>也是一样的道理）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">2</span>]+prices[i];</span><br><span class="line">            dp[i][<span class="number">2</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最长递增序列">最长递增序列</h4>
<p>给你一个整数数组<code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code>的子序列。</p>
<p><strong>解题思路：利用动态规划的思想一步步求解并优化</strong></p>
<p><strong>方法一：</strong> <code>dp[i]</code>数组存储表示以<code>nums[i]</code>结尾的最长递增子序列，那么对于该<code>dp</code>有</p>
<ul>
<li>初始状态：<code>dp[0]=1</code></li>
<li>状态转移：以当前位置逆序方式进行查找，直到找到第一个<code>nums[j]&lt;nums[i]</code>，那么<code>dp[i]=1+dp[j]</code>,没找到则<code>dp[i]=1</code></li>
</ul>
<p>上面的方法一的时间复杂度为<code>O(n*n)</code>，原因是对于当前的<code>nums[i]</code>，我们都必须逆序在<code>[0,i-1]</code>去寻找第一个满足<code>nums[j]&lt;nums[i]</code>的元素。</p>
<p><strong>方法二：</strong> 基于上面的思想，为了优化时间复杂度，能否对逆序寻找进行优化呢，使复杂度降为O(N)或者O(nlogn)，O(n)算法就必须使得查找为<code>O(1)</code>，这是比较难办到的。而对于<code>O(nlogn)</code>来说，是较容易，想优化到<code>logn</code>复杂度，那么不是二分就是归并了，这里我们重定义<code>dp</code>数组的意义，使得寻找遍历能够使用二分法。</p>
<p>由于题意只要求返回最大长度，因为我们只需一个<code>maxL</code>来记录当前遍历到<code>nums[i]</code>时的最大长度，<strong>我们用dp[]来有序记录当前的最长子序列数组</strong>，对于得到的<code>nums[i]</code>,器更新策略如下：</p>
<ul>
<li>对<code>nums[i]</code>先确定其插入位置，使用二分方法，初始<code>lo=0,hi=maxL</code>,</li>
<li>经过二分后确定插入位置为更新后的<code>lo</code>,另<code>dp[lo]=nums[i]</code></li>
<li>判断<code>lo==maxL?</code>,若是则说明当前的<code>nums[i]</code>在此时的递增子序列的末尾，则<code>++maxL</code></li>
</ul>
<p>时间复杂度为<code>O(nlogn)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> lo = <span class="number">0</span>, hi = maxL;</span><br><span class="line">            <span class="comment">//二分查找</span></span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[mid] &lt; num)</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[lo] = num;</span><br><span class="line">            <span class="keyword">if</span> (lo == maxL)</span><br><span class="line">                maxL++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="粉刷房子">粉刷房子</h4>
<p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>
<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个<code> n x 3</code> 的正整数矩阵<code>costs</code> 来表示的。</p>
<p>例如，<code>costs[0][0]</code> 表示第 0 号房子粉刷成红色的成本花费；<code>costs[1][2]</code> 表示第 1 号房子粉刷成绿色的花费，以此类推。</p>
<p>请计算出粉刷完所有房子最少的花费成本。</p>
<p><strong>解题思路：</strong></p>
<p>由于粉刷房子只有三种颜色可选择，却要求相邻房子不能相同，要求满足上面条件的最小花费，这是一个多中间值的dp问题，因此可以使用二维动态规划</p>
<p>使用动态规划：<code>dp[i][j]</code>，其中<code>i</code>为<code>[0:n-1]</code>表示第<code>i</code>栋方正，<code>j</code>为<code>[0:2]</code>表示颜色，<strong>0为红色，1为蓝色，2为绿色</strong>，<code>dp[i][j]</code>即表示满足相邻方正不同色情况下，到<code>[0:i]</code>栋房子的粉刷策略的最低消费,最后一个房子以<code>j</code>颜色结尾。所以：</p>
<ul>
<li>初始状态：<code>dp[0][0]=costs[0][0],dp[0][1]=costs[0][1],dp[0][2]=costs[0][2]</code></li>
<li>状态转移方程：<code>dp[i][0]=costs[i][0]+min(dp[i-1][1],dp[i-1][2]);``dp[i][1]=costs[i][1]+min(dp[i-1][0],dp[i-1][2]);``dp[i][2]=costs[i][2]+min(dp[i-1][1],dp[i-1][0])</code></li>
</ul>
<p>时间复杂度为O(n),空间复杂度为O(n)，由于只与上一个状态有关，因此空间复杂度可优化至O(1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=costs.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=costs[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]=costs[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">2</span>]=costs[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=costs[i][<span class="number">0</span>]+<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=costs[i][<span class="number">1</span>]+<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=costs[i][<span class="number">2</span>]+<span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],<span class="built_in">min</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>],dp[n<span class="number">-1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间dp">1.2 区间DP</h3>
<h4 id="最长回文子串">最长回文子串</h4>
<p><strong>问题：</strong>给你一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]:表示s[i]是否等于s[j],相等且回文则置为true，否则为false</span></span><br><span class="line">    <span class="comment">//初始条件：dp[i][i]=true;</span></span><br><span class="line">    <span class="comment">//状态转移方程：</span></span><br><span class="line">	<span class="comment">//①若i和j是相邻的即i+1=j且s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//②若不相邻，则判断内侧是否为true，若dp[i+1][j-1]=true&amp;&amp;s[i]==s[j],则dp[i][j]=true</span></span><br><span class="line">    <span class="comment">//通过增加两变量记录当前回文串的最长长度Maxlen,初始为1,以及记录回文串的下标开始index_min，初始为最后一个元素</span></span><br><span class="line">    <span class="comment">//算法的时间复杂度为O(n*n)</span></span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>||len==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(len,<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> Maxlen=<span class="number">1</span>,index_min=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])<span class="comment">//如果两元素相等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i+<span class="number">1</span>)<span class="comment">//如果相邻</span></span><br><span class="line">                    dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//不相邻，判断两元素内部是否为回文串</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;Maxlen&lt;j-i+<span class="number">1</span>)<span class="comment">//更新Maxlen和index_min</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Maxlen=j-i+<span class="number">1</span>;</span><br><span class="line">                    index_min=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ret=s.<span class="built_in">substr</span>(index_min,Maxlen);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="最长回文子序列">最长回文子序列</h4>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*动态规划：dp[i][j]，其中0=&lt;i&lt;=j&lt;=n,dp[i][j]表示序列s在i~j范围内的最长回文子序列长度。</span></span><br><span class="line"><span class="comment">                    对于回文序列的问题，我们必须注意循环的顺序，首先i从大到小，j从小到大且满足j&gt;=i，直                  到得到dp[0][n-1]</span></span><br><span class="line"><span class="comment">            初始条件：①当i=j时，dp[i][j]=1</span></span><br><span class="line"><span class="comment">                     ②当i&gt;j时，dp[i][j]=0</span></span><br><span class="line"><span class="comment">            状态转移方程：①当s[i]=s[j且相邻即i+1=j,dp[i][j]=dp[i][j-1]+1</span></span><br><span class="line"><span class="comment">                         ②当s[i]=s[j]且不相邻,dp[i][j]=dp[i+1][j-1]+2</span></span><br><span class="line"><span class="comment">                         ③当s[i]!=s[j]且相邻，dp[i][j]=1</span></span><br><span class="line"><span class="comment">                         ④当s[i]!=s[j]，此时s[i]和s[j]不能同时作为回文子序列的首尾，则有</span></span><br><span class="line"><span class="comment">                         dp[i][j]=max(dp[i][j-1],dp[i+1][j])</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxLen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>==j)</span><br><span class="line">                        dp[i][j]=dp[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>==j)</span><br><span class="line">                        dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;maxLen)</span><br><span class="line">                    maxLen=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最长公共子序列">最长公共子序列</h4>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 <strong>公共子序列 </strong>的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：<strong>它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</strong></p>
<p>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但<code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code>的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<p><strong>解法一：</strong> 暴力解：以<code>text1</code>的<code>text1[i]</code>作为开头，得到以它开头的最长公共子序列，最后得到最长序列，时间复杂度为<code>O(nmm)</code></p>
<p><strong>解法二：</strong> 暴力解的时间复杂度较高，其原因是进行了一些不必要的比较，使用动态规划来优化。该题可以由子问题一步一步构建而来。</p>
<p>最长公共子序列是典型的二维dp例题，需要记住这个思想：</p>
<ul>
<li>给出<code>dp[i][j]</code>，其中行数为<code>1+text1.size()</code>,列数为<code>1+text2.size()</code></li>
<li>那么定义<code>dp[i][j]</code>其表示<code>text1[0:i-1]</code>和<code>text2[0:j-1]</code>的最长公共子序列，那么对于更新，则有</li>
<li>初始状态<code>dp[0][0:m]=0,dp[0:n][0]=0</code></li>
<li>状态转移方程：
<ul>
<li>当<code>text1[i-1]==text2[j-1]</code>，那么此时<code>dp[i][j]=1+dp[i-1][j-1]</code>(写对角线)</li>
<li>当<code>text1[i-1]!=text2[j-1]</code>，对于<code>dp[i][j]</code>的取值分析，我们需要考虑
<ul>
<li><code>text1[0:i-2]</code>和<code>text2[0:j-1]</code>的最长公共子序列（上）</li>
<li><code>text1[0:i-1]</code>和<code>text2[0:j-2]</code>的最长公共子序列（左）</li>
</ul></li>
<li>由于之前已经计算过两者，因此<code>dp[i][j]</code>取它们两者较大者即可，即<code>dp[i][j]=max(dp[i][j-1],dp[i-1][j])</code></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=text1.<span class="built_in">size</span>(),m=text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>该题与编辑距离有共同相似处。</strong></p>
</blockquote>
<h4 id="编辑距离">编辑距离</h4>
<blockquote>
<p>给你两个单词<code>word1</code>和<code>word2</code>， 请返回将 <code>word1</code>转换成<code>word2</code>所使用的最少操作数 。</p>
</blockquote>
<blockquote>
<p>你可以对一个单词进行如下三种操作：</p>
</blockquote>
<blockquote>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
</blockquote>
<h5 id="思路">思路</h5>
<p><strong>借鉴于官方题解，更加清晰得描述解题思路：</strong> 使用动态规划来解决，尝试使用由前一个子问题推导得到下一个子问题的答案，最终回到最终解。</p>
<p><strong>分析：</strong> 当我们直到word1的前<code>i-1</code>和<code>j-1</code>字符的最小编辑距离，如何利用它们得到前<code>i</code>和<code>j</code>字符的最小编辑记录。</p>
<p>假如用<code>A=horse</code>和<code>B=ros</code>作为例子，我们因为有三种操作，因此也就得比较三种操作得到最小值：</p>
<ul>
<li><p><strong>在单词 <code>A</code> 中插入一个字符</strong>：如果我们知道 <code>horse</code> 到 <code>ro</code>的编辑距离为<code>a</code>(即 <code>horse</code> 经过a步就能变为<code>ro</code>,<code>dp[i][j-1]</code>=a)，那么显然<code>horse</code> 到<code>ros</code>的编辑距离不会超过 <code>a + 1</code>。这是因为经过<code>dp[i][j-1]</code>后，在单词<code>A</code>的末尾添加字符<code>s</code>，就能在<code>a + 1</code>次操作后将 <code>horse</code> 和 <code>ros</code> 变为相同的字符串；</p></li>
<li><p><strong>在单词 A中删除一个字符</strong>：如果我们知道 <code>hors</code> 到<code>ros</code> 的编辑距离为<code>b</code>,即<code>dp[i-1][j]=b</code>，那么显然 <code>horse</code> 到 <code>ros</code> 的编辑距离不会超过 <code>b + 1</code>，原因是只需要多删除一个<code>e</code>即可；</p></li>
<li><p><strong>在A中替换一个单词</strong>，如果我们知道 <code>hors</code> 到<code>ro</code>的编辑距离为 <code>c</code>，那么显然 <code>horse</code> 到 <code>ros</code> 的编辑距离不会超过 <code>c + 1</code>，原因是因为<code>A</code>中加入了<code>e</code>，而B中加入了<code>s</code>，因此在<code>e</code>替换为<code>s</code>时，需要额外加1个操作上，如果相等，那么dp[i][j]=dp[i-1][j-1]</p></li>
</ul>
<p>因此基于上述分析： - 当<code>A[i]==B[i]</code>时，<code>dp[i][j]=min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1])</code> - 当<code>A[i]!=B[i]</code>时,<code>dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1</code></p>
<h4 id="步骤">步骤</h4>
<ul>
<li>定义<code>dp[i][j]</code>，表示<code>word1</code>的前i个字符与<code>word2</code>的前<code>j</code>个字符的最小编辑距离。</li>
<li>初始化<code>dp[0][i]=i</code>,<code>dp[i][0]=i</code>，当另一个字符串为空时，最小编辑距离当然时另一个字符串得长度</li>
<li>状态转移方程：
<ul>
<li>当<code>A[i]==B[i]</code>时，<code>dp[i][j]=min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1])</code></li>
<li>当<code>A[i]!=B[i]</code>时,<code>dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1</code></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=word1.<span class="built_in">size</span>(),m=word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n*m==<span class="number">0</span>) <span class="keyword">return</span> n&gt;<span class="number">0</span>?n:m;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//初始状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m+<span class="number">1</span>;++i)</span><br><span class="line">            dp[<span class="number">0</span>][i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m+<span class="number">1</span>;++j)&#123;</span><br><span class="line">                <span class="type">int</span> Aadd=dp[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> Adelete=dp[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> ASwitch=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]!=word2[j<span class="number">-1</span>]) ASwitch+=<span class="number">1</span>;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(Aadd,<span class="built_in">min</span>(Adelete,ASwitch));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="背包dp">1.3 背包DP</h3>
<h3 id="状压dp">1.4 状压DP</h3>
<h3 id="剑指offer62-圆圈中最后剩余的数字">1.5 剑指offer62 圆圈中最后剩余的数字</h3>
<p><strong>1、约瑟夫问题：</strong> 这个问题实际上是<strong>约瑟夫问题</strong>，这个问题描述是 &gt;N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。</p>
<p><strong>2、问题转化</strong> 既然约塞夫问题就是用人来举例的，那我们也给每个人一个编号（索引值），每个人用字母代替</p>
<p>下面这个例子是<code>N=8 m=3</code>的例子</p>
<p>我们定义<code>F(n,m)</code>表示最后剩下那个人的索引号，因此我们只关系最后剩下来这个人的索引号的变化情况即可 <img src="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/offer69.png" width="700"> 从8个人开始，每次杀掉一个人，去掉被杀的人，然后把杀掉那个人之后的第一个人作为开头重新编号</p>
<ul>
<li>第一次C被杀掉，人数变成7，D作为开头，（最终活下来的G的编号从6变成3）</li>
<li>第二次F被杀掉，人数变成6，G作为开头，（最终活下来的G的编号从3变成0）</li>
<li>第三次A被杀掉，人数变成5，B作为开头，（最终活下来的G的编号从0变成3）</li>
<li>以此类推，当只剩一个人时，他的编号必定为0！（重点！）</li>
</ul>
<p><strong>3、反推（动态规划的思想）</strong> 现在我们知道了G的索引号的变化过程，那么我们反推一下 从<code>N = 7</code> 到<code>N = 8</code> 的过程</p>
<p>如何才能将<code>N = 7</code> 的排列变回到<code>N = 8</code> 呢？</p>
<p>我们先把被杀掉的<code>C</code>补充回来，然后右移<code>m</code>个人，发现溢出了，再把溢出的补充在最前面</p>
<p>神奇了 经过这个操作就恢复了<code>N = 8</code>的排列了！ <img src="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/69.png" width="700"> 因此我们可以推出递推公式<span class="math inline">\(f(8,3) = [f(7, 3) + 3] % 8\)</span> 进行推广泛化，即$ f(n,m) = [f(n-1, m) + m] % n$ <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">2</span>);i&lt;=n;++i)</span><br><span class="line">            ans=(ans+m)%i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/">该题题解来自leetcode的爱吃火锅的木易</a></p>
<h2 id="树类">2. 树类</h2>
<blockquote>
<p>引用leetcode上<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">星晴大佬的笔记</a></p>
</blockquote>
<ul>
<li>引言：</li>
</ul>
<p>力扣上很多树的题目都是可以用递归很快地解决的，而这一系列递归解法中蕴含了一种很强大的递归思维：对称性递归(symmetric recursion) 什么是对称性递归？就是对一个对称的数据结构（这里指二叉树）从整体的对称性思考，把大问题分解成子问题进行递归，即不是单独考虑一部分(比如树的左子树)，<strong>而是同时考虑对称的两部分(左右子树)，从而写出对称性的递归代码</strong></p>
<ul>
<li><p>题型分类： 可以用对称性递归解决的二叉树问题大多是判断性问题(bool类型函数),这一类问题又可以分为以下两类：</p>
<ul>
<li>1、不需要构造辅助函数。这一类题目有两种情况：
<ul>
<li>第一种是单树问题，且不需要用到子树的某一部分(比如根节点左子树的右子树)，只要利用根节点左右子树的对称性即可进行递归。</li>
<li>第二种是双树问题，即本身题目要求比较两棵树，那么不需要构造新函数。该类型题目如下： <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100.相同的树</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226.翻转二叉树</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110.平衡二叉树</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543.二叉树的直径</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617.合并二叉树</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">572.另一个树的子树</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/univalued-binary-tree/">965.单值二叉树</a></li>
</ul></li>
<li>2、需要构造辅助函数。这类题目通常只用根节点子树对称性无法完全解决问题，必须要用到子树的某一部分进行递归，即要调用辅助函数比较两个部分子树。形式上主函数参数列表只有一个根节点，辅助函数参数列表有两个节点。该类型题目如下： <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101.对称二叉树</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指offer26.s树的子结构</a></li>
</ul></li>
<li>解题模板 下面给出二叉树对称性递归的解题模板
<ul>
<li><p>1、递归结束条件：特殊情况的判断 如果是单树问题，一般来说只要进行以下判断： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>/递归函数;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>/递归函数;。</span><br></pre></td></tr></table></figure> 如果是双树问题(根节点分别为p,q)，一般来说进行以下判断： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p &amp;&amp; !q)<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!p || !q)<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br></pre></td></tr></table></figure> 当然也不完全是这些情况，比如有的需要加上节点值的判断，需要具体问题需要具体分析</p></li>
<li>2、返回值
<ul>
<li>通常对称性递归的返回值是多个条件的复合判断语句</li>
<li>可能是以下几种条件判断的组合：
<ul>
<li>节点非空的判断</li>
<li>节点值比较判断</li>
<li>(单树)调用根节点左右子树的递归函数进行递归判断</li>
<li>(双树)调用两棵树的左右子树的递归函数进行判断</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="二叉树">2.1 二叉树</h3>
<h4 id="i-从上到下打印二叉树层次遍历">2.1.1 I-从上到下打印二叉树（层次遍历）</h4>
<p>【剑指offer】从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//使用队列实现这种遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; myqueue;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            myqueue.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            myqueue.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!myqueue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp=myqueue.<span class="built_in">front</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            myqueue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">                myqueue.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">                myqueue.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> #### 2.1.2 III-从上到下打印二叉树(之字型) 【剑指offer】实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通过两个栈存储来实现，一个是奇数层的队列，一个为偶数层栈</span></span><br><span class="line"><span class="comment">*不同的是入栈的方式不同：</span></span><br><span class="line"><span class="comment">*- 如果把第一层认为是奇数层，那么对于奇数栈来说，它从左向右遍历，则必须左子树先入栈</span></span><br><span class="line"><span class="comment">*- 对于偶数栈来说，从右往左遍历，则必须右子树先入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; evenS;</span><br><span class="line">        stack&lt;TreeNode*&gt; oddS;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        oddS.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!oddS.<span class="built_in">empty</span>()||!evenS.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur=<span class="literal">NULL</span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span>(!oddS.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cur=oddS.<span class="built_in">top</span>();</span><br><span class="line">                oddS.<span class="built_in">pop</span>();</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    evenS.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                    evenS.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!tmp.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!evenS.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cur=evenS.<span class="built_in">top</span>();</span><br><span class="line">                evenS.<span class="built_in">pop</span>();</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                    oddS.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    oddS.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="树的子结构">2.1.3 树的子结构</h4>
<p>【剑指offer】输入两棵二叉树<code>A</code>和<code>B</code>，判断<code>B</code>是不是<code>A</code>的子结构。(约定空树不是任意一个树的子结构)</p>
<p><code>B</code>是<code>A</code>的子结构， 即 <code>A</code>中有出现和<code>B</code>相同的结构和节点值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">给定的树 B：</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span> </span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">返回 <span class="literal">true</span>，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br></pre></td></tr></table></figure> <strong>题解：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对称性</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *两个树的结构相同，则根节点相同，左右子树的结构也要相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果任一子树为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(!A||!B)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如不为空，则可判断以根节点为根，以根节点的左子树为根，或者以根节点的右子树为根，</span></span><br><span class="line">        <span class="comment">//三者中只要满足一个与B相同，则可认为B是A的子结构</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasSameDfs</span>(A,B)||<span class="built_in">isSubStructure</span>(A-&gt;left,B)||<span class="built_in">isSubStructure</span>(A-&gt;right,B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasSameDfs</span><span class="params">(TreeNode*A,TreeNode*B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件1：B为NULL时，说明B可全部由A表示</span></span><br><span class="line">        <span class="keyword">if</span>(!B)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//条件2是：A为NULL，但B不为NULL，说明A不能完全表示B；或者值不相等</span></span><br><span class="line">        <span class="keyword">if</span>(!A||A-&gt;val!=B-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//上面都不满足，则说明当前A-&gt;val==B-&gt;val，继续比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasSameDfs</span>(A-&gt;left,B-&gt;left)&amp;&amp;<span class="built_in">hasSameDfs</span>(A-&gt;right,B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="树的镜像翻转二叉树">2.1.4 树的镜像(翻转二叉树)</h4>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *对称递归：在递归中交换左右子树,无需</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//交换左右子树</span></span><br><span class="line">        TreeNode* tmp=root-&gt;left;</span><br><span class="line">        root-&gt;left=root-&gt;right;</span><br><span class="line">        root-&gt;right=tmp;</span><br><span class="line">        <span class="comment">//对称递归</span></span><br><span class="line">        <span class="built_in">mirrorTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="重建二叉树">2.1.5 重建二叉树</h4>
<p>入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><strong>思路：</strong>自顶向下构造</p>
<ul>
<li>二叉树的中序遍历中根节点将数组分为左右子树,前序遍历的结果第一个元素总是当前分支的根，因此可构造一个辅助函数<code>TreeNode* build(preorder,inorder,preB,preE,inB,inE)</code></li>
<li><code>preB、preE</code>表示当前要构建根节点及其子树的所有节点的始末位置，<code>inB、inP</code>则表示中序遍历的</li>
<li>递归构造规律
<ul>
<li>用前序结果的第一个<code>preorder[preB]</code>构造根节点</li>
<li>在中序遍历中寻找该根节点位置Incur，此时知道中序遍历的<code>[inB,Incur-1](Incur-1&gt;=inB)</code>为左子树，对应于前序遍历的<code>[preB+1,PreB+Incur-inB](PreB+Incur-inB&gt;=preB+1)</code></li>
<li>同理中序遍历的<code>[Incur+1,inE]</code>为右子树，对应于前序遍历的<code>[preB+Incur-inB+1,preE]</code></li>
</ul></li>
<li>终止条件
<ul>
<li><code>if(preB&gt;preE) return NULL;</code></li>
</ul></li>
<li>优化
<ul>
<li>优化：在构造的第二步中每次都要寻找中序遍历的根节点，导致时间复杂度为<code>O(n*n)</code>，用<code>unorder_map</code>来存储，时间复杂度为<code>O(n)</code></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *二叉树的前序遍历和中序遍历，在中序遍历中根节点将数组分为左右子树,前序遍历的结果第一个元素总是当前分支的根</span></span><br><span class="line"><span class="comment"> *因此，可构造一个辅助函数TreeNode* build(preorder,inorder,preB,preE,inB,inE)</span></span><br><span class="line"><span class="comment"> *preB、preE表示当前要构建根节点及其子树的所有节点的始末位置，inB、inP则表示中序遍历的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *构造规律：</span></span><br><span class="line"><span class="comment"> - 用前序结果的第一个preorder[preB]构造根节点</span></span><br><span class="line"><span class="comment"> - 在中序遍历中寻找该根节点位置Incur，此时知道中序遍历的[inB,Incur-1](Incur-1&gt;=inB)为左子树，对应于前序遍历的[preB+1,PreB+Incur-inB](PreB+Incur-inB&gt;=preB+1)</span></span><br><span class="line"><span class="comment"> - 同理中序遍历的[Incur+1,inE]为右子树，对应于前序遍历的[preB+Incur-inB+1,preE]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *终止条件：</span></span><br><span class="line"><span class="comment"> *if(preB&gt;preE) return NULL;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *优化：在构造的第二步中每次都要寻找中序遍历的根节点，导致时间复杂度为O(n*n)，用unorder_map来存储，时间复杂度为O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;inorder.<span class="built_in">size</span>();++i)</span><br><span class="line">            hmap[inorder[i]]=i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(preorder,hmap,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; hmap,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> preB,<span class="type">int</span> preE,<span class="type">int</span> inB,<span class="type">int</span> inE)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preB&gt;preE)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preB]);</span><br><span class="line">        <span class="type">int</span> Incur=hmap[preorder[preB]];</span><br><span class="line">        <span class="comment">//构造左右子树</span></span><br><span class="line">        root-&gt;left=<span class="built_in">build</span>(preorder,hmap,preB+<span class="number">1</span>,preB+Incur-inB,inB,Incur<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">build</span>(preorder,hmap,preB+Incur-inB+<span class="number">1</span>,preE,Incur+<span class="number">1</span>,inE);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="序列化二叉树">2.1.6 序列化二叉树</h4>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>思路：</p>
<ul>
<li>上面的重建二叉树利用了前序遍历和中序遍历的分布性质，但前提是数中不存在相同的值，此题并未说明值保证不同，因此无法使用前序和中序的性质。</li>
<li>可考虑层序遍历来构造，<strong>在序列化中构造含空的层序遍历结果，然后用该层序遍历能够还原出二叉树</strong></li>
<li>在下方程序中最聪明的就是用<code>ostringstream\istringstream</code>来记录层序结果，然后构造节点数组，最关键的是<code>index</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//unordered_map&lt;char,int&gt;myMap;</span></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用层序遍历，空节点用&#x27;#&#x27;表示</span></span><br><span class="line">        <span class="comment">//考虑到ostringstream能够以&quot; &quot;自动分割，可采用ostringstream对像来存储</span></span><br><span class="line">        ostringstream output;</span><br><span class="line">        queue&lt;TreeNode*&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            root=Q.<span class="built_in">front</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                output&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">                Q.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                output&lt;&lt;<span class="string">&quot;# &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过带有null的层序遍历来构造二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        vector&lt;TreeNode*&gt; vec;</span><br><span class="line">        <span class="function">istringstream <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">while</span>(input&gt;&gt;s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="string">&quot;#&quot;</span>)</span><br><span class="line">                vec.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                vec.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(s)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;vec.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i]==<span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            vec[i]-&gt;left=vec[++index];</span><br><span class="line">            vec[i]-&gt;right=vec[++index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树">2.2 二叉搜索树</h3>
<p>二叉搜索树具有左子树比根节点小，右子树比根节点大的特点。</p>
<h4 id="不同的二叉搜索树">2.2.1 不同的二叉搜索树</h4>
<p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
<ul>
<li><p>解法一：递归+记忆 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/下面这个方法更上面的递归是一样的，只不过优化了重复计算</span><br><span class="line"><span class="comment">//发现存在许多的重复计算，用unordered_map来存储n与子树数量的计算过的结果，后续可以直接用</span></span><br><span class="line">*/</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果存在已经计算的结果，直接使用</span></span><br><span class="line">        <span class="keyword">if</span>(result.<span class="built_in">find</span>(n)!=result.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> result[n];</span><br><span class="line">        <span class="type">long</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//还是使用递归，当以i为根节点时，计算其左右子树各有多少种类，此时m*n即可得到以i为根时的种类</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//以i为根时的总数</span></span><br><span class="line">            <span class="comment">//左子树有多少种</span></span><br><span class="line">            <span class="type">long</span> leftnums=<span class="built_in">numTrees</span>(i<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//右子树有多少种</span></span><br><span class="line">            <span class="type">long</span> rightnums=<span class="built_in">numTrees</span>(n-i);</span><br><span class="line">            <span class="comment">//相乘就是以节点i为根的种类数</span></span><br><span class="line">            count+=leftnums*rightnums;</span><br><span class="line">        &#125;</span><br><span class="line">        result[n]=count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>解法二：动态规划</p></li>
</ul>
<h4 id="二叉搜索树的最近公共祖先节点">2.2.2 二叉搜索树的最近公共祖先节点</h4>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  <code>root = [6,2,8,0,4,7,9,null,null,3,5]</code>，寻找2、4的最近祖先，那么2就是最近的公共祖先</p>
<p><strong>思路：</strong>自顶向下的搜索（循环和递归均可）</p>
<ul>
<li>树为二叉搜索树，那么又左子树小于根节点，右子树大于根节点的规则，可有这样几种情况</li>
<li><code>p-&gt;val&gt;root-&gt;val&amp;&amp;q-&gt;val&gt;root-&gt;val</code>，说明<code>p、q</code>都位于右子树，此时最近的公共祖先必不是<code>root</code>,向右前进</li>
<li><code>p-&gt;val&lt;root-&gt;cal&amp;&amp;q-&gt;val&lt;root-&gt;val</code>，说明<code>p、q</code>都位于左子树，此时最近的公共祖先必不是<code>root</code>,向左前进</li>
<li>若有任一<code>p</code>或<code>q</code>的<code>val</code>值等于<code>root-&gt;val</code>，那么<code>root</code>必然是最近祖先节点</li>
<li>当<code>p\q</code>分别位于<code>root</code>的左右子树时，<code>root</code>为最近的祖先节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//优化，减少在循环当中的条件判断，保证p-&gt;val&gt;q-&gt;val</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val&lt;q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=tmp;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val&gt;root-&gt;val)</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val&lt;root-&gt;val)</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的最近公共祖先">2.2.3 二叉树的最近公共祖先</h4>
<p>这是<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/?envType=study-plan&amp;id=lcof&amp;plan=lcof&amp;plan_progress=xxf1bgos">二叉搜索树的最近公共祖先</a>的升级版本。不具有二叉搜索树的大小性质。</p>
<p>题目：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>思路：<strong>因为节点一定在树上且唯一，那么在不同分支找到的节点一定是不同的即分别是p、q</strong></p>
<ul>
<li>情况总结，若<code>root</code>是它们的最近公共祖先，那么有以下3种情况：
<ul>
<li><code>p、q</code>分别位于<code>root</code>的左右子树 (2)</li>
<li><code>p==root</code>，<code>q</code>位于<code>root</code>的左子树或者右子树(3)</li>
<li><code>q==root</code>，<code>p</code>位于<code>root</code>的左子树或者右子树(4)</li>
</ul></li>
<li>退出条件：<code>root==NULL,return NULL;root==p,return root;root==q,return root</code> (1)</li>
<li>递归规则：用<code>isleft</code>记录<code>root</code>左子树的遍历结果；<code>isright</code>记录<code>root</code>右子树的遍历结果，因此采用的是自底向上的回溯，因此返回的一定是最近的祖先节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>||root==p||root==q)	<span class="comment">//(1)</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* isleft=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* isright=<span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(isleft&amp;&amp;isright)		<span class="comment">//(2)</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(isleft)		<span class="comment">//(3)</span></span><br><span class="line">            <span class="keyword">return</span> isleft;</span><br><span class="line">        <span class="keyword">else</span>			<span class="comment">//(4)</span></span><br><span class="line">            <span class="keyword">return</span> isright;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树的后续遍历">2.2.4 二叉搜索树的后续遍历</h4>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p><strong>思路：</strong>后序遍历的结果由[左|右|根]的特点，由根节点一知，很容易构造根节点，关键点是如何确定左右分界处。二叉搜索树中，左子树均小于根节点，右子树均大于根节点，因此可通过遍历比较来确定其左右子树的分界线 <strong>解法1：</strong> 算法步骤：</p>
<ul>
<li>构造一辅助函数<code>verify(postorder,int b,int e)</code>，<code>b、e</code>分别表示当前树的后序遍历范围</li>
<li>通过由前往后的遍历确定左右子树分界点，当<code>postorder[i]&gt;postorder[e]</code>时，即可确定[b,i-1]为左子树节点，<code>[i,e-1]</code>为右子树节点</li>
<li>继续遍历<code>[i,e-1]</code>范围，确定在该范围不存在小于<code>postorder[e]</code>的元素，则进入下一个递归</li>
<li>递归退出条件：<code>b&gt;=e，return true;</code></li>
<li>上述算法时间复杂度为<span class="math inline">\(O(n^2)\)</span>，空间复杂度为<span class="math inline">\(O(n)\)</span>，原因是，每一次递归为确定分界处，需要遍历数组， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder,<span class="type">int</span> b,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&gt;=e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>,i=b;</span><br><span class="line">        <span class="keyword">while</span>(postorder[i]&lt;postorder[e])</span><br><span class="line">            ++i;</span><br><span class="line">        index=i;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;e&amp;&amp;postorder[i]&gt;postorder[e])</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">return</span> i==e&amp;&amp;<span class="built_in">verify</span>(postorder,b,index<span class="number">-1</span>)&amp;&amp;<span class="built_in">verify</span>(postorder,index,e<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">verify</span>(postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>解法二：</strong></p>
<ul>
<li>我们发现是可以通过记录根节点的大小即当前节点的上下界将比较推迟到当前递归，这样就避免了数组的遍历使得时间复杂度为<span class="math inline">\(O(n)\)</span>。</li>
<li><code>左子树&lt;根节点</code>，<code>右子树&gt;根节点</code>，那么引入辅助函数<code>vrify(postorder,ma,mi)</code>，其中<code>ma</code>为上界，<code>mi</code>为下限。刚开设设为<code>INT_MAX</code>和<code>-INT_MIN</code></li>
<li>取最后一个元素val，比较其值时候在该范围内，不在直接返回<code>false</code></li>
<li>若在，则删除最后一个元素，进入下一轮递归</li>
<li>必须先对右子树递归，并更新其下限在<code>val</code>;然后在左子树递归中，更新其上界在<code>val</code></li>
<li>当数组为空时，说明符合搜索时的后序遍历，返回<code>true</code>；否则返回<code>false</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">verify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder,<span class="type">int</span> MA,<span class="type">int</span> MI)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> postorder.<span class="built_in">empty</span>();</span><br><span class="line">        <span class="type">int</span> curr=postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(curr&lt;=MI||curr&gt;=MA)</span><br><span class="line">            <span class="keyword">return</span> postorder.<span class="built_in">empty</span>();</span><br><span class="line">        postorder.<span class="built_in">erase</span>(postorder.<span class="built_in">end</span>()<span class="number">-1</span>,postorder.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">verify</span>(postorder,MA,curr);</span><br><span class="line">        <span class="built_in">verify</span>(postorder,curr,MI);</span><br><span class="line">        <span class="keyword">return</span> postorder.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">verify</span>(postorder,INT_MAX,-INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="平衡二叉树">2.3 平衡二叉树</h3>
<p>平衡二叉树又称为AVL树，它的设计是为了防止在二叉搜索树中退化成链表的一种数据结果，特点：</p>
<ul>
<li>规定左右子树的的深度差不能超过1，即平衡因子<code>|bf|&lt;=1</code></li>
<li>左子树值小于根节点，右子树大于</li>
</ul>
<h4 id="平衡二叉树判断">2.3.1 平衡二叉树判断</h4>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> *解法<span class="number">1</span>：自顶向上(暴力解)，得到每个节点左右深度，当&gt;<span class="number">1</span>时返回<span class="number">-1</span>，由于存在大量的重复计算</span><br><span class="line"> *时间复杂度为<span class="built_in">O</span>(n*n)</span><br><span class="line"> *</span><br><span class="line"> *解法<span class="number">2</span>：自低向上，规避了重复计算，时间复杂度为<span class="built_in">O</span>(n)</span><br><span class="line"> *借辅助函数<span class="built_in">height</span>(root)计算节点的深度，返回两种情况</span><br><span class="line"> 返回值：</span><br><span class="line"> - 当节点root 左 / 右子树的深度差 ≤<span class="number">1</span> ：则返回当前子树的深度，即节点 root 的左 / 右子树的深度最大值 +<span class="number">1</span> </span><br><span class="line"> （  <span class="built_in">max</span>(left, right) + <span class="number">1</span> ）；</span><br><span class="line"> - 当节点root 左 / 右子树的深度差 &gt;<span class="number">2</span> ：则返回 −<span class="number">1</span> ，代表 此子树不是平衡树 。</span><br><span class="line">   终止条件</span><br><span class="line">root=<span class="literal">NULL</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">leftheight==<span class="number">-1</span>||rightheight==<span class="number">-1</span>||<span class="built_in">abs</span>(leftheight,rightheight)&gt;<span class="number">1</span> <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> <span class="built_in">isBalanced</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root)&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftheight=<span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightheight=<span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftheight==<span class="number">-1</span>||rightheight==<span class="number">-1</span>||<span class="built_in">abs</span>(leftheight-rightheight)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(leftheight,rightheight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="链表类">3. 链表类</h2>
<h3 id="两数相加">3.1 两数相加</h3>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head=l1;</span><br><span class="line">        <span class="type">int</span> jingwei=<span class="number">0</span>;</span><br><span class="line">        ListNode* prio;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val=l1-&gt;val+l2-&gt;val+jingwei;</span><br><span class="line">            prio=l1;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1&amp;&amp;!l2)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;val+=jingwei;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1&amp;&amp;l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prio=l1;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                    l1-&gt;val+=jingwei;</span><br><span class="line">                    jingwei=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            prio-&gt;next=l2;</span><br><span class="line">            l1=l2;</span><br><span class="line">            l1-&gt;val+=jingwei;</span><br><span class="line">            jingwei=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1&amp;&amp;l1-&gt;val&gt;<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prio=l1;</span><br><span class="line">                jingwei=<span class="number">1</span>;</span><br><span class="line">                l1-&gt;val-=<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">                    l1-&gt;val+=jingwei;</span><br><span class="line">                    jingwei=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jingwei)</span><br><span class="line">            &#123;</span><br><span class="line">                prio-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(jingwei,<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除链表倒数第n个节点">3.2 删除链表倒数第N个节点</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        ListNode* tmp=head;</span><br><span class="line">        <span class="keyword">while</span>(tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=head;</span><br><span class="line">		<span class="comment">//删除头节点单独考虑</span></span><br><span class="line">        <span class="keyword">if</span>(len-n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> tmp-&gt;next;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len-n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next=tmp-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="合并k个有序链表">3.3 合并K个有序链表</h3>
<p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用分治的思想，分别两两合并</span></span><br><span class="line">        <span class="comment">//使用递归实现：</span></span><br><span class="line">        <span class="comment">//递归退出条件为：一是传入的只有一个链表另一个为NUL，二是传入的均为NULL，直接返回</span></span><br><span class="line">        <span class="comment">//程序结构：mergeKList为主调用，不做其他功能，merge递归入口，当达到底层是使用mergeTwoList   </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>()<span class="number">-1</span>);     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoList</span><span class="params">(ListNode* a,ListNode* b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>==a||<span class="literal">NULL</span>==b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>==a?b:a;</span><br><span class="line">        ListNode* head=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;val&gt;b-&gt;val)&#123;</span><br><span class="line">            head=b;</span><br><span class="line">            b=b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head=a;</span><br><span class="line">            a=a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tempNode=head;</span><br><span class="line">        <span class="keyword">while</span>(a&amp;&amp;b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;val&gt;b-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                tempNode-&gt;next=b;</span><br><span class="line">                b=b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tempNode-&gt;next=a;</span><br><span class="line">                a=a-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tempNode=tempNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a)</span><br><span class="line">            tempNode-&gt;next=a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempNode-&gt;next=b;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=(r+l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(r==l)</span><br><span class="line">            <span class="keyword">return</span> lists[r];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r&lt;l)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">mergeTwoList</span>(<span class="built_in">merge</span>(lists,l,m),<span class="built_in">merge</span>(lists,m+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="两两交换链表中的节点">3.4 两两交换链表中的节点</h3>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用双指针，前一指针比后一指针快一步，然后交换指向即可</span></span><br><span class="line">        <span class="comment">//为方便，在链表头部添加一节点pHead</span></span><br><span class="line">        ListNode* front=<span class="literal">NULL</span>,*back=<span class="literal">NULL</span>,*pHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        pHead-&gt;next=head;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        back=head;</span><br><span class="line">        front=head-&gt;next;</span><br><span class="line">        ListNode* ret=pHead;</span><br><span class="line">        <span class="keyword">while</span>(front!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            back-&gt;next=front-&gt;next;</span><br><span class="line">            front-&gt;next=back;</span><br><span class="line">            pHead-&gt;next=front;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            pHead=back;</span><br><span class="line">            <span class="keyword">if</span>(back-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                back=back-&gt;next;</span><br><span class="line">                front=back-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                front=<span class="literal">NULL</span>;</span><br><span class="line">                back=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="k个一组翻转链表">3.5 K个一组翻转链表</h3>
<p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针：前一个指针front比后一个指针快K-1</span></span><br><span class="line">        <span class="comment">//为方便，增加辅助头指针pHead</span></span><br><span class="line">        ListNode* front=<span class="literal">NULL</span>,*back=<span class="literal">NULL</span>,*pHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(),*ret=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        pHead-&gt;next=head;</span><br><span class="line">        front=back=head;</span><br><span class="line">        ret=pHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k&amp;&amp;front!=<span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">            front=front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(front!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;   <span class="comment">//记录下一组节点</span></span><br><span class="line">            ListNode* tmp_back=front-&gt;next;</span><br><span class="line">            ListNode* tmp_front=tmp_back;</span><br><span class="line">            <span class="comment">//pHead记录</span></span><br><span class="line">            pHead-&gt;next=front;</span><br><span class="line">            pHead=back;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">                <span class="comment">//记录下一个翻转节点</span></span><br><span class="line">                ListNode* tmp=back-&gt;next;</span><br><span class="line">                <span class="comment">//翻转</span></span><br><span class="line">                back-&gt;next=front-&gt;next;</span><br><span class="line">                front-&gt;next=back;</span><br><span class="line">                <span class="comment">//更新</span></span><br><span class="line">                back=tmp;</span><br><span class="line">                <span class="comment">//下一组更新</span></span><br><span class="line">                <span class="keyword">if</span>(tmp_front)</span><br><span class="line">                    tmp_front=tmp_front-&gt;next;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            back=tmp_back;</span><br><span class="line">            front=tmp_front;         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="环形链表ii">3.6 环形链表II</h3>
<p>给定一个链表的头节点<code>head</code>，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p><strong>分析：</strong> 假设链表有环，分为两部分<code>a</code>和<code>b</code>,<code>a</code>为无环长度，<code>b</code>为有环长度，使用快慢指针<code>fast、slow</code>进行遍历，快指针步长为<code>2</code>，慢指针步长为<code>1</code> - 那么当有环时，快慢指针必定会相遇，另快指针走过节点为<code>f</code>,慢指针为<code>s</code>，则第一次相遇后有<code>f=2s</code>，<code>f=s+nb</code>, - 所以<code>f=2nb</code>，此时另<code>slow</code>从头节点重写走，<code>fast</code>从<code>f</code>处变成慢指针走，当他们走<code>a</code>步时再次相遇，此时就是环的入口节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast=head,*slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow=head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字符串类">4. 字符串类</h2>
<p>字符串也是数组类型，因此与数组一样，类型繁多。</p>
<h3 id="n字形变换">4.1 N字形变换</h3>
<p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。如输入字符串为 <code>PAYPALISHIRING</code> 行数为 4 时，排列如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;PAYPALISHIRING&quot;</span>, numRows = <span class="number">4</span></span><br><span class="line">输出：<span class="string">&quot;PINALSIGYAHRPI&quot;</span></span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于numRows有这样的一个规律：</span></span><br><span class="line"><span class="comment">//按规定第一列取s的前numRows个字符，即i=0.....numRows</span></span><br><span class="line"><span class="comment">//对于i行后面的列每隔(numRows-1)*2+i取一个，直到(numrow-1)*2*j&gt;s.size()为止,j&gt;=1</span></span><br><span class="line"><span class="comment">//同时对于第i行，在取s[(numRow-1)*2*j+i]时，</span></span><br><span class="line"><span class="comment">//前面应该还有当(numRows-1)*2*j+i-2i!=(numRows-1)*2*(j-1)+i时添加一个字符为s[(numsRow-1)*2*j+i-2i]</span></span><br><span class="line"><span class="comment">//或者只需排除第一行和最后一行即可</span></span><br><span class="line"><span class="comment">//时间复杂度为O(N)，空间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="built_in">convert</span>(string s, <span class="type">int</span> numRows) &#123;</span><br><span class="line">        string ret=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numRows&amp;&amp;i&lt;s.<span class="built_in">size</span>();i++)  <span class="comment">//第i行存储</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret+=s[i];</span><br><span class="line">            <span class="type">int</span> gapDistance=(numRows<span class="number">-1</span>)*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;gapDistance*j-i&lt;s.<span class="built_in">size</span>();j++)<span class="comment">//寻找下一个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows<span class="number">-1</span>)             <span class="comment">//判断是不是第一行或者最后一行,不是则进入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret+=s[gapDistance*j-i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(gapDistance*j+i&lt;s.<span class="built_in">size</span>())</span><br><span class="line">                    ret+=s[gapDistance*j+i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="字符串最大公因子">4.2 字符串最大公因子</h3>
<blockquote>
<p>对于字符串<code>s</code> 和<code>t</code>，只有在<code>s = t + ... + t（</code>t 自身连接 1 次或多次）时，我们才认定 “t 能除尽 s”。 给定两个字符串 <code>str1</code> 和 <code>str2</code> 。返回 最长字符串<code>x</code>，要求满足<code>x</code> 能除尽 <code>str1</code> 且<code>x</code>能除尽<code>str2</code></p>
</blockquote>
<p><strong>思路：</strong> 给定了<code>str1</code>和<code>str2</code>,设其长度为<code>n</code>和<code>m</code>，这道题需要记住的两个性质</p>
<ul>
<li><p>如果存在一个符合要求的字符串<code>X</code>，那么也一定存在一个符合要求的字符串 <code>X'</code>，它的长度为 <code>str1</code> 和 <code>str2</code> 长度的最大公约数。</p></li>
<li><p>如果 <code>str1</code> 和 <code>str2</code> 拼接后等于 <code>str2</code>和 <code>str1</code> 拼接起来的字符串（注意拼接顺序不同），那么一定存在符合条件的字符串 X，<code>str1</code> 和 <code>str2</code> 由X拼接而成</p></li>
</ul>
<p>有了该性质以及方法二的性质，我们就可以先判<code>str1</code> 和 <code>str2</code>拼接后是否等于 <code>str2</code> 和<code>str1</code> 拼接起来的字符串，如果等于直接输出长度为 <code>gcd(len1,len2)</code>的前缀串即可，否则返回空串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">gcdOfStrings</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1+str2!=str2+str1) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">substr</span>(<span class="number">0</span>,__gcd(str1.<span class="built_in">size</span>(),str2.<span class="built_in">size</span>()));<span class="comment">//__gcd()是C++11自带的求最大公约数函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最长回文子串manacher算法解决">4.3 最长回文子串（Manacher算法解决）</h3>
<blockquote>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
</blockquote>
<blockquote>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
</blockquote>
<p>思路：使用<a target="_blank" rel="noopener" href="https://trluper.cn/2023/08/11/Manacher%E7%AE%97%E6%B3%95/">Manacher算法</a>以<span class="math inline">\(O(N)\)</span>时间复杂度解决 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">	string str=<span class="string">&quot;@&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">		str+=<span class="string">&quot;#&quot;</span>+s.<span class="built_in">substr</span>(i,<span class="number">1</span>);</span><br><span class="line">	str+=<span class="string">&quot;#%&quot;</span>;</span><br><span class="line">	n=str.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> r=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//构造L</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;r) L[i]=<span class="built_in">min</span>(L[(k*<span class="number">2</span>)-i],r-i);</span><br><span class="line">		<span class="keyword">else</span> L[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//执行暴力匹配</span></span><br><span class="line">		<span class="keyword">while</span>(str[i-L[i]<span class="number">-1</span>]==str[i+L[i]+<span class="number">1</span>]) ++L[i];</span><br><span class="line">		<span class="comment">//更新k,r</span></span><br><span class="line">		<span class="type">int</span> R=L[i]+i;</span><br><span class="line">		<span class="keyword">if</span>(R&gt;r)&#123;</span><br><span class="line">			r=R,k=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//找最长回文串</span></span><br><span class="line">	<span class="type">int</span> Max=<span class="number">0</span>,idx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(L[i]&gt;Max)&#123;</span><br><span class="line">			Max=L[i];</span><br><span class="line">			idx=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> start=(idx-Max)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">substr</span>(start,Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong><em>Manacher算法解决回文串一类题目，KMP算法解决字符串匹配一类题目，注意，要明白L数组和next数组的含义</em></strong></p>
</blockquote>
<h3 id="重复的子字符串">4.4 重复的子字符串</h3>
<blockquote>
<p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成</p>
</blockquote>
<p><strong>分析</strong>：果长度为n的字符串<code>s</code>是字符串 <code>t=s+s</code>的子串，并且<code>s</code>在<code>t</code>中的起始位置不为<code>0 或 n，那么可证明</code>s<code>由子串</code>s'`构成。那么这样就可以利用<a target="_blank" rel="noopener" href="https://trluper.cn/2023/08/06/KMP%E7%AE%97%E6%B3%95/">KMP算法</a>来解答此题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">KMP</span><span class="params">(string txt,string pat)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n=txt.<span class="built_in">size</span>(),m=pat.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">next</span>(m,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,now=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now&gt;<span class="number">0</span>&amp;&amp;pat[i]!=pat[now])&#123;</span><br><span class="line">                now=next[now<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pat[i]==pat[now]) ++now;</span><br><span class="line">            next[i]=now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> startIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//控制首尾不参与，因此i=1,i&lt;n-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&amp;&amp;txt[i]!=pat[j]) j=next[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(txt[i]==pat[j])&#123;</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">if</span>(j==m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">KMP</span>(s+s,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最小覆盖子串">4.5 最小覆盖子串</h3>
<blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</p>
</blockquote>
<p><strong>思路：</strong> 可尝试使用滑动窗口思路解决，先用哈希<code>Hash</code>记录<code>t</code>的字母出现次数，之后对<code>s</code>进行滑动窗口排查</p>
<ul>
<li><code>l,r</code>表示窗口的左右边界，该问题现在转化为求最满足题意得最小窗口</li>
<li>当<code>t</code>出现在窗口内，<code>++l</code></li>
<li>当<code>t</code>不在窗口内，<code>++r</code></li>
</ul>
<p>对于<code>t</code>是否出现在窗口，必须使用一个数据结构来记录当前窗口出现字母,在<code>right</code>右移的时候能够判断该字符是否是t当中的字符，并且判断加入这个字符后当前窗口是否满足<code>t</code>，满足则进入<code>left</code>右移；对于<code>left</code>右移，能够判断当前窗口移除该字符后，是否破坏满足条件，若破坏了就必须能够知道破坏后的窗口缺了多少个什么字符才能再次满足·</p>
<ul>
<li>使用哈希<code>need</code>记录<code>t</code>中各字符出现的次数。</li>
<li>使用<code>count</code>来指示当前窗口还有多少各字符为满足。<code>count==0</code>时说明满足</li>
<li>再使用一个哈希来<code>windows</code>来记录窗口中出现<code>t</code>中字符的数量，当<code>windows</code>于<code>need</code>一一对应时，则认为当前窗口满足了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希need记录所需字符及数量,windows记录当前窗口</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; windows;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span> c:t)</span><br><span class="line">            ++need[c];</span><br><span class="line">        <span class="type">int</span> startIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,minLen=INT_MAX,count=t.<span class="built_in">size</span>(),n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            <span class="type">char</span> c=s[right];</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(c)!=need.<span class="built_in">end</span>()&amp;&amp;need[c]&gt;(windows[c]++)) --count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//先记录这个满足串</span></span><br><span class="line">                <span class="type">int</span> len=right-left+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(minLen&gt;len)&#123;</span><br><span class="line">                    startIndex=left;</span><br><span class="line">                    minLen=len;</span><br><span class="line">                &#125;</span><br><span class="line">                c=s[left];</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(c)!=need.<span class="built_in">end</span>()&amp;&amp;need[c]&gt;=(windows[c]--)) ++count;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minLen&lt;INT_MAX) <span class="keyword">return</span> s.<span class="built_in">substr</span>(startIndex,minLen);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="双指针类">5. 双指针类</h2>
<h3 id="无重复字符的最长子串">5.1 无重复字符的最长子串</h3>
<p><strong>问题：</strong>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<blockquote>
<p>示例： 输入: s = &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用滑动窗口的思路，即双指针的应用，左指针first表示以该元素为起始点</span></span><br><span class="line">   <span class="comment">//右指针last表示[first,last)是以s[first]开头最长无重复子串，以first为起始</span></span><br><span class="line">   <span class="comment">//不断向右移动右指针，直到遇到重复的为止</span></span><br><span class="line">   <span class="comment">//用unordered_set记录来判断是否有重复元素</span></span><br><span class="line">   <span class="comment">//虽然是双循环，但是内部右指针不重置，移动次数为常数，因此时间复杂度为O(N)</span></span><br><span class="line">   <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">0</span>==len||<span class="number">1</span>==len)</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    <span class="type">int</span> last=<span class="number">0</span>,maxLen=<span class="number">1</span>;</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; hSet;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;len;first++)  <span class="comment">//左指针向前</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不是第一次进入循环，说明当前元素s[last]与hSet存在重复，不断去除前一个</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>!=first)</span><br><span class="line">            hSet.<span class="built_in">erase</span>(s[first<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//不断右移右指针，直到遇到重复的</span></span><br><span class="line">        <span class="keyword">while</span>(last&lt;len&amp;&amp;!hSet.<span class="built_in">count</span>(s[last]))</span><br><span class="line">        &#123;</span><br><span class="line">            hSet.<span class="built_in">insert</span>(s[last]);</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen=<span class="built_in">max</span>(maxLen,last-first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="盛最多水的容器">5.2 盛最多水的容器</h4>
<p><strong>问题</strong>：给定一个长度为<code>n</code>的整数数组<code>height</code>。有<code>n</code>条垂线，第<code>i</code>条线的两个端点是<code>(i, 0)</code>和<code>(i, height[i])</code>。找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//双指针，一头指向头，一个指向尾</span></span><br><span class="line">    <span class="comment">//原理不用多说，看代码即可知</span></span><br><span class="line">    <span class="comment">//复杂度O(N)</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> maxCap=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="built_in">Min</span>(height[left],height[right])*(right-left);</span><br><span class="line">        <span class="keyword">if</span>(maxCap&lt;tmp)</span><br><span class="line">            maxCap=tmp;</span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三数之和">5.3 三数之和</h3>
<p><strong>算法思路：</strong></p>
<ul>
<li>1、特判，对于数组长度<code>n</code>，如果数组为<code>null</code>或者数组长度小于<code>3</code>，返回<code>[]</code></li>
<li>2、对数组进行排序。</li>
<li>3、遍历排序后数组：
<ul>
<li>若<code>nums[i]&gt;0</code>：因为已经排序好，所以后面不可能有三个数加和等于0，直接返回结果。</li>
<li>对于重复元素：跳过，避免出现重复解</li>
<li>令左指针<code>L=i+1</code>，右指针<code>R=n-1</code>，当 <code>L&lt;R</code>时，执行循环：
<ul>
<li>当<code>nums[i]+nums[L]+nums[R]==0</code>，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解</li>
<li>若和大于0，说明<code>nums[R]</code>太大，<code>R</code>左移</li>
<li>若和小于0，说明<code>nums[L]</code>太小，<code>L</code>右移</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line"><span class="comment">/*方法一：转化为两数之和</span></span><br><span class="line"><span class="comment">*先将nums的元素拷贝一份到unordered_set处</span></span><br><span class="line"><span class="comment">*再将将nums内的数据两两求和存储回到tmp</span></span><br><span class="line"><span class="comment">*通过在set寻找是否有符合tmp的数据求得其解</span></span><br><span class="line"><span class="comment">*时间复杂度为O(N*N),空间复杂度为O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*方法二：双指针和排序</span></span><br><span class="line"><span class="comment">*先对数组nums进行升序排序，</span></span><br><span class="line"><span class="comment">*后依次从负值取一个元素作为第一个选取的值</span></span><br><span class="line"><span class="comment">*之后定义左右指针，从左指向右前进一位选取一个元素，这里选取了两个元素执行求和得target</span></span><br><span class="line"><span class="comment">*右指针向左移动若干个位置，寻找元素与target和为0得元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line"><span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; nums[i] &lt;= <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    left = i + <span class="number">1</span>;</span><br><span class="line">    right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[left]);</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="comment">//判断下一个值是否重复，是则跳过</span></span><br><span class="line">            <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">while</span> (right&gt;left&amp;&amp;nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                left++;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;len<span class="number">-1</span>&amp;&amp;nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">        i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最接近的三数之和">5.4 最接近的三数之和</h3>
<p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *使用三数之和的方法：</span></span><br><span class="line"><span class="comment">    *1、先对数组进行排序</span></span><br><span class="line"><span class="comment">    *2、之后想三数之和一样遍历排序后的数组：</span></span><br><span class="line"><span class="comment">    *时间复杂度为O(N*N)，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> ret=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> right=len<span class="number">-1</span>,left=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较ret是否要更新</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(target-(nums[i]+nums[left]+nums[right]))</span><br><span class="line">                    &lt;<span class="built_in">abs</span>(target-ret))</span><br><span class="line">                    ret=nums[i]+nums[left]+nums[right];</span><br><span class="line">            <span class="comment">//双指针应该向哪边移动</span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[i]+nums[left]+nums[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[i]+nums[left]+nums[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="四数之和">5.5 四数之和</h3>
<p>给你一个由 n 个整数组成的数组<code>nums</code>，和一个目标值<code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组<code>[nums[a], nums[b], nums[c], nums[d]]</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//解决方法同三数求和一样，使用排序+双指针方法</span></span><br><span class="line">        <span class="comment">//只不过此时多加了一层循环，则时间复杂度为O(N^3),</span></span><br><span class="line">        <span class="type">long</span> Target=target;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>;i++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>&amp;&amp;Target&lt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=i+<span class="number">3</span>;j--)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="type">int</span> left=i+<span class="number">1</span>,right=j<span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="type">long</span> result=(<span class="type">long</span>)nums[i]+(<span class="type">long</span>)nums[j]+</span><br><span class="line">					 			(<span class="type">long</span>)nums[left]+(<span class="type">long</span>)nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(Target&lt;result)</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(Target&gt;result)</span><br><span class="line">                        left++;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        ret.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(right&gt;left&amp;&amp;nums[right]==nums[right<span class="number">-1</span>])</span><br><span class="line">                            right--;</span><br><span class="line">                        <span class="keyword">while</span>(right&gt;left&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])</span><br><span class="line">                            left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//跳过重复</span></span><br><span class="line">                 <span class="keyword">while</span>(j&gt;=i+<span class="number">3</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])</span><br><span class="line">                    j--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//跳过重复</span></span><br><span class="line">             <span class="keyword">while</span>(i&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>&amp;&amp;nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="深度优先搜索类">6. 深度优先搜索类</h2>
<h3 id="括号组合">6.1 括号组合</h3>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*dfs思路:</span></span><br><span class="line"><span class="comment">*- 1、使用n1\n2记录&#x27;(&#x27;和&#x27;)&#x27;的剩余个数，初始均为n</span></span><br><span class="line"><span class="comment">*- 2、用一个整数k记录目前组合的字符串前面还有多少个&#x27;(&#x27;未形成组合，如&quot;(()&quot;前面还有一个&#x27;(&#x27;未形成组合</span></span><br><span class="line"><span class="comment">*- 3、递归条件：当前字符串前面没有&#x27;(&#x27;可组合只能进入&#x27;(&#x27;递归，前面有&#x27;(&#x27;可组合则&#x27;(&#x27;和&#x27;)&#x27;均可进入</span></span><br><span class="line"><span class="comment">*- 4、到达递归结束时直接将组合成的字符串压入vector即可，退出递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">dfsGP</span>(ret,s,n,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfsGP</span><span class="params">(vector&lt;string&gt;&amp;vec,string s,<span class="type">int</span> n1,<span class="type">int</span> n2,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n1==<span class="number">0</span>&amp;&amp;n2==<span class="number">0</span>)&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s+=<span class="string">&quot;(&quot;</span>;</span><br><span class="line">            <span class="built_in">dfsGP</span>(vec,s,n1<span class="number">-1</span>,n2,k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n1!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                string s1=s+<span class="string">&quot;(&quot;</span>;</span><br><span class="line">                <span class="built_in">dfsGP</span>(vec,s1,n1<span class="number">-1</span>,n2,k+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n2!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s+=<span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="built_in">dfsGP</span>(vec,s,n1,n2<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="组合总和">6.2 组合总和</h3>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p><code>candidates</code> 中的 同一个 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<ul>
<li>方法一：搜索回溯 思路与算法</li>
</ul>
<p><strong>对于这类寻找所有可行解的题，我们都可以尝试用「搜索回溯」的方法来解决。</strong></p>
<ul>
<li>回到本题，我们定义递归函数 <code>dfs(target,combine,idx)</code> 表示当前在 <code>candidates</code> 数组的第 <code>idx</code> 位，还剩<code>target</code> 要组合，已经组合的列表为 <code>combine</code>。</li>
<li>递归的终止条件为 <code>target≤0</code> 或者 <code>candidates</code> 数组被全部用完。</li>
<li>那么在当前的函数中，每次我们可以选择跳过不用第 <code>idx</code> 个数，即执行 <code>dfs(target,combine,idx+1)</code>。</li>
<li>也可以选择使用第<code>idx</code> 个数，即执行 <code>dfs(target−candidates[idx],combine,idx)</code>，注意到每个数字可以被无限制重复选取，因此搜索的下标仍为 <code>idx</code>。</li>
</ul>
<p>更形象化地说，如果我们将整个搜索过程用一个树来表达，即如下图呈现，每次的搜索都会延伸出两个分叉，直到递归的终止条件，这样我们就能不重复且不遗漏地找到所有可行解 <img src="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/39.png" width="600"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; combine, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(combine);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接跳过</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            combine.<span class="built_in">emplace_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; combine;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面算法没有用到剪枝，利用剪枝可以节省一些时间</p>
</blockquote>
<h3 id="全排列">6.3 全排列</h3>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure> 将题目给定的 <code>n</code> 个数的数组 <code>nums</code> 划分成左右两个部分，左边的表示已经填过的数，右边表示待填的数，我们在回溯的时候只要动态维护这个数组即可。</p>
<ul>
<li>具体来说，假设我们已经填到第 <code>first</code> 个位置，那么<code>nums</code>数组中 <code>[0,first−1]</code> 是已填过的数的集合，<code>[first,n−1]</code>是待填的数的集合。</li>
<li>我们肯定是尝试用 <code>[first,n−1]</code> 里的数去填第 <code>first</code> 个数，假设待填的数的下标为 <code>i</code>，那么填完以后我们将第 <code>i</code> 个数和第 <code>first</code> 个数交换，即能使得在填第 <code>first+1</code> 个数的时候 <code>nums</code> 数组的 <code>[0,first]</code> 部分为已填过的数，<code>[first+1,n−1]</code> 为待填的数，</li>
<li><strong>回溯的时候交换回来即能完成撤销操作。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; output, <span class="type">int</span> first, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了</span></span><br><span class="line">        <span class="keyword">if</span> (first == len) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(output);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = first; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="comment">// 动态维护数组</span></span><br><span class="line">            <span class="built_in">swap</span>(output[i], output[first]);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            <span class="built_in">backtrack</span>(res, output, first + <span class="number">1</span>, len);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            <span class="built_in">swap</span>(output[i], output[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">backtrack</span>(res, nums, <span class="number">0</span>, (<span class="type">int</span>)nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先搜索类">7. 广度优先搜索类</h2>
<h2 id="数学">8. 数学</h2>
<h3 id="下一个排列">8.1 下一个排列</h3>
<p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 arr 的排列：<code>[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code>。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是<code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code>，找出<code>nums</code> 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。 <img src="/2022/07/30/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/31.gif" width="700"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line"><span class="comment">/*双遍历：</span></span><br><span class="line"><span class="comment">*- 1、数组从后往前遍历，直到遇到第一个nums[i-1]&lt;nums[i],记录该index_1=i-1</span></span><br><span class="line"><span class="comment">*- 2、数组再次从后往前遍历，遇到第一个nums[j]&gt;nums[index],记录下标index_2=j</span></span><br><span class="line"><span class="comment">*- 3、交换nums[index_1]和nums[index_2]的值</span></span><br><span class="line"><span class="comment">*- 4、交换完成后，由上面的步骤一定可知道从[nums.begin()+index_1+1,nums.end()]一定是降序的，直接reverse该范围即可得到下一个子序列</span></span><br><span class="line"><span class="comment">*- 5、如果遍历完都不存在，就说明全部是逆序，直接reverse返回</span></span><br><span class="line"><span class="comment">*时间复杂度为O(N)，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index_1=<span class="number">-1</span>,index_2=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i<span class="number">-1</span>&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            index_1=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index_1==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;index_1;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;=nums[index_1])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                index_2=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[index_1]^=nums[index_2];</span><br><span class="line">            nums[index_2]^=nums[index_1];</span><br><span class="line">            nums[index_1]^=nums[index_2];</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+index_1+<span class="number">1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵">9. 矩阵</h2>
<h2 id="图类">10. 图类</h2>
<h3 id="拓扑排序课程表">10.1 拓扑排序：课程表</h3>
<p>你这个学期必须选修<code>numCourses</code> 门课程，记为<code> 0 </code>到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 必须 先学习课程 <code>bi</code></p>
<p><strong>解题思路：</strong></p>
<p>**拓扑排序，先对输入记录每门课程的入度，当入度为0时，说明这么课程已经完成了所有的预修课程，可以学习该课程 暴力的拓扑排序时间复杂度为O(n*n)，看测试用例大小不可接受**</p>
<ul>
<li>步骤1：由于课程<code>id</code>号为<code>(0~numCourses-1)</code>，使用数组<code>record[i]</code>记录第<code>i</code>门课需要预修的课程数，即入度</li>
<li>步骤2：使用<code>unordermap&lt;id(int),vector&lt;int&gt;&gt;</code>记录课程与课程间的关系</li>
<li>步骤3：遍历<code>record</code>得到入度为0，遍历得到<code>unordermap</code>中的值<code>vector&lt;int&gt;</code>遍历对<code>record</code>中对于入度--</li>
<li>重复上述步骤</li>
<li>上面在<code>record</code>寻找入度为<code>0</code>的点，时间复杂度最坏会达到<code>O(n)</code>,一共要进行<code>n</code>次，平均复杂度为<code>O(n*n)</code></li>
</ul>
<p><strong>优化思路：</strong> BFS思路，使用队列来使用递归</p>
<ul>
<li>为避免每次全表反复扫描寻找入度为0的点，我们使用队列来记录入度为0的点</li>
<li>当我们完成步骤1，即初始化完record后，遍历入度为0的节点入队列</li>
<li>在步骤3中，出队头，并更新record，对更新后入度为0的也入队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//入度数组和邻接表</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">record</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;  umap;</span><br><span class="line">        <span class="comment">//初始化record和umap</span></span><br><span class="line">        <span class="type">int</span> n=prerequisites.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            ++record[prerequisites[i][<span class="number">0</span>]];</span><br><span class="line">            umap[prerequisites[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立队列模拟bfs</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录可学习课程数目</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="comment">//更新umap</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp=umap[q.<span class="built_in">front</span>()];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> course:tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>((--record[course])==<span class="number">0</span>) q.<span class="built_in">push</span>(course);</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==numCourses) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="模拟">11. 模拟</h2>
<h3 id="字符串转整数">11.1 字符串转整数</h3>
<p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：</p>
<ul>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</li>
<li>返回整数作为最终结果。</li>
</ul>
<p><strong><em>注意：</em></strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 ' ' 。</li>
<li>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//易错点：</span></span><br><span class="line"><span class="comment">//        1、题目要求对于前面没遇到数字前，若为非空格非&#x27;-+&#x27;，则为非法输入，直接退出</span></span><br><span class="line"> <span class="comment">//       2、&#x27;-&#x27;或&#x27;+&#x27;号后只能是数字，不能为其他，否则直接退出循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> isFu=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> isfirst=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> Nodigital=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">long</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(isfirst&amp;&amp;Nodigital&amp;&amp;s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(isfirst&amp;&amp;Nodigital&amp;&amp;(<span class="string">&#x27;-&#x27;</span>==s[i]||<span class="string">&#x27;+&#x27;</span>==s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&#x27;-&#x27;</span>==s[i])</span><br><span class="line">                    isFu=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    isFu=<span class="literal">false</span>;</span><br><span class="line">                isfirst=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(isFu)</span><br><span class="line">                    <span class="keyword">if</span>(INT_MIN&gt;result*<span class="number">10</span>-tmp)&#123;</span><br><span class="line">                        result=INT_MIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        result=result*<span class="number">10</span>-tmp;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(INT_MAX&lt;result*<span class="number">10</span>+tmp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        result=INT_MAX;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        result=result*<span class="number">10</span>+tmp;</span><br><span class="line">                Nodigital=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指offer29.-顺时针打印矩阵">11.2 剑指offer29. 顺时针打印矩阵</h3>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>思路：首先从外圈向内圈进行打印，圈按顺时针方向，分别为从左向右，从上到下，从右到左，从下到上。用四个遍历分别记录上边界、下边界、左边界和右边界</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*首先从外圈向内圈进行打印，圈按顺时针方向，分别为从左向右，从上到下，从右到左，从下到上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回值</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ret;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">		<span class="comment">//下边界和右边界</span></span><br><span class="line">        <span class="type">int</span> _clo=matrix.<span class="built_in">size</span>()<span class="number">-1</span>,_row=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> N=matrix.<span class="built_in">size</span>()*matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">		<span class="comment">//上边界和左边界</span></span><br><span class="line">        <span class="type">int</span> clo=<span class="number">0</span>,row=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ret.<span class="built_in">size</span>()!=N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从左向右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=row;i&lt;=_row;++i)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(matrix[clo][i]);</span><br><span class="line">            <span class="comment">//从上到下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=clo+<span class="number">1</span>;j&lt;=_clo;++j)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(matrix[j][_row]);</span><br><span class="line">            <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=_row<span class="number">-1</span>;_clo&gt;clo&amp;&amp;i&gt;row;--i)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(matrix[_clo][i]);</span><br><span class="line">            <span class="comment">//从下到上</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=_clo;_row&gt;row&amp;&amp;j&gt;clo;--j)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(matrix[j][row]);</span><br><span class="line">            <span class="comment">//更新边界</span></span><br><span class="line">            --_clo;</span><br><span class="line">            --_row;</span><br><span class="line">            ++clo;</span><br><span class="line">            ++row;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="顺时针转90">11.3 顺时针转90°</h3>
<h3 id="包含min函数的栈">11.4 包含min函数的栈</h3>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="type">long</span> num_min;</span><br><span class="line">    stack&lt;<span class="type">long</span>&gt; stack_diff;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *压入：我们以差值的形式压入，即currValue-min，</span></span><br><span class="line"><span class="comment">        *- 为空时，直接设min=currValue,因此压入0</span></span><br><span class="line"><span class="comment">        *- 当差值&lt;0时，说明此时压入的值比之前最小值还小，因此要更新最小值，此时先压入currValue-max，之后</span></span><br><span class="line"><span class="comment">            更新min=currValue</span></span><br><span class="line"><span class="comment">        *- 当差值&gt;=0时，说明压入值比之前最小值大，不要更新，直接压入差值即可</span></span><br><span class="line"><span class="comment">        *取栈顶：</span></span><br><span class="line"><span class="comment">        *- 当stack[top]&gt;0，说明其不是最小值，要返回min+stack[top]</span></span><br><span class="line"><span class="comment">        *- 当stack[top]&lt;=0，说明此时栈顶是最小值，直接返回min即可</span></span><br><span class="line"><span class="comment">        *弹出：</span></span><br><span class="line"><span class="comment">        *- 当stack[top]&gt;0，说明其不是最小值，不用更新最小值，直接弹出pop即可</span></span><br><span class="line"><span class="comment">        *- 当stack[top]&lt;=0时，说明当前栈顶是最小值，弹出后要更新最小值，右上面推导知道，当前值currvalue是最小值,差值=currValue-min&lt;=0，那么弹出后的最小值是min=currValue-差值，即min-=stack[top]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(stack_diff.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            num_min = x;</span><br><span class="line">            stack_diff.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack_diff.<span class="built_in">push</span>((<span class="type">long</span>)x-num_min);</span><br><span class="line">        <span class="keyword">if</span>(x &lt; num_min)</span><br><span class="line">        &#123;</span><br><span class="line">            num_min = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每次pop都有更新现有栈的num_min</span></span><br><span class="line">        <span class="keyword">if</span>(stack_diff.<span class="built_in">top</span>() &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num_min -= stack_diff.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stack_diff.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack_diff.<span class="built_in">top</span>() &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> stack_diff.<span class="built_in">top</span>()+num_min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> num_min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num_min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="剑指offer59-ii.-队列的最大值">11.5 剑指offer59-II. 队列的最大值</h3>
<p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数<code>max_value、push_back</code> 和 <code>pop_front</code> 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
<p><strong>思路：</strong> - 使用两个队列来实现，一个是普通的先进先出队列q，另一个是双端队列d； - 主要是双端队列，它是单调递减形式，队头最是当前进队列数字的最大值，每次插入都会与队尾元素不断比较，如果<code>d.back()&lt;value</code>，则弹出，这就保证了<code>max_Value</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*使用两个队列来实现，一个是普通的先进先出队列q，另一个是双端队列d；</span></span><br><span class="line"><span class="comment">*其中：普通队列记录正常进出顺序，保证push_back和pop_front的功能，双端队列为单调减队列，它存储当前的最大值</span></span><br><span class="line"><span class="comment">*即在双端队列中，每次插入都会与队尾元素不断比较，如果d.back()&lt;value，则弹出，这就保证了max_Value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> d.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双端队列进行比较</span></span><br><span class="line">        <span class="keyword">while</span>(!d.<span class="built_in">empty</span>()&amp;&amp;d.<span class="built_in">back</span>()&lt;value)</span><br><span class="line">            d.<span class="built_in">pop_back</span>();</span><br><span class="line">        d.<span class="built_in">push_back</span>(value);</span><br><span class="line">        q.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ret=q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(ret==d.<span class="built_in">front</span>())</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="滑动窗口最大值">11.6 滑动窗口最大值</h3>
<p>给你一个整数数组<code>nums</code>，有一个大小为 <code>k</code>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code>个数字。滑动窗口每次只向右移动一位。<span class="math inline">\(1&lt;=k&lt;=nums.size()\)</span></p>
<ul>
<li>暴力解会超时，暴力复杂度为O(nk)</li>
<li>滑动窗口的滑动中，数字的进出很想队列的先进先出，因此可使用单调队列来优化时间复杂度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*单调队列实现，可以先看&quot;队列的最大值&quot;这一题</span></span><br><span class="line"><span class="comment">*使用普通队列去记录当前窗口的k个值，使用双端队列去单调记录当前窗口的最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">        q.<span class="built_in">push</span>(nums[<span class="number">0</span>]),d.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>);i&lt;k;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!d.<span class="built_in">empty</span>()&amp;&amp;d.<span class="built_in">back</span>()&lt;nums[i])</span><br><span class="line">                d.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            d.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(d.<span class="built_in">front</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(k);i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//弹出移动后不在窗口的值</span></span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">front</span>()==d.<span class="built_in">front</span>())</span><br><span class="line">                d.<span class="built_in">pop_front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//压入新值</span></span><br><span class="line">            <span class="keyword">while</span>(!d.<span class="built_in">empty</span>()&amp;&amp;d.<span class="built_in">back</span>()&lt;nums[i])</span><br><span class="line">                d.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            d.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            ret.<span class="built_in">push_back</span>(d.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配">11.7 正则表达式匹配</h3>
<p>请实现一个函数用来匹配包含<code>.</code>和<code>*</code>的正则表达式。模式中的字符<code>.</code>表示任意一个字符，而<code>*</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>aaa</code>与模式<code>a.a</code>和<code>ab*ac*a</code>匹配，但与<code>aa.a</code>和<code>ab*a</code>均不匹配。</p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 . 和 <code>*</code>，无连续的 <code>'*'</code>。</li>
</ul>
<h3 id="lru">11.8 LRU</h3>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。 实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 <code>LRU</code> 缓存</li>
<li><code>int get(int key)</code> 如果关键字<code>key</code> 存在于缓存中，则返回关键字的值，否则返回<code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值<code> value</code> ；如果不存在，则向缓存中插入该组<code> key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code>，则应该 逐出 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以<code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>思路</strong>：用双向链表和哈希定位实现，双向链表的目的就是实现逐出最久未使用的关键字</p>
<ul>
<li>按定义，最久未使用的关键字在链表尾部，</li>
<li>在更新中会把get</li>
<li>为了实现上述查找的O(1)时间复杂度，使用哈希来存储key-节点映射</li>
<li>为了能够快速定位头尾节点，使用额外的两个节点pHead、pBack作为头节点和尾部节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> key,val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* prior;</span><br><span class="line">    <span class="built_in">Node</span>():<span class="built_in">val</span>(<span class="number">-1</span>),<span class="built_in">next</span>(<span class="literal">NULL</span>),<span class="built_in">prior</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val):<span class="built_in">val</span>(_val),<span class="built_in">next</span>(<span class="literal">NULL</span>),<span class="built_in">prior</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val,Node* _next,Node* _prior):<span class="built_in">val</span>(_val),<span class="built_in">next</span>(_next),<span class="built_in">prior</span>(_prior)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,Node*&gt; LRU;</span><br><span class="line">    Node* pHead=<span class="literal">NULL</span>,*pBack=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> capacity=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity=capacity;</span><br><span class="line">        pHead=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        pBack=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        pBack-&gt;prior=pHead;</span><br><span class="line">        pHead-&gt;next=pBack;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!LRU[key])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* node=LRU[key];</span><br><span class="line">        <span class="built_in">moveToBegin</span>(node);</span><br><span class="line">        <span class="keyword">return</span> LRU[key]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LRU[key])<span class="comment">//存在则更新</span></span><br><span class="line">        &#123;</span><br><span class="line">            LRU[key]-&gt;val=value;</span><br><span class="line">            <span class="built_in">moveToBegin</span>(LRU[key]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(capacity&lt;=<span class="number">0</span>)&#123;<span class="comment">//不存在且容量已满，删除最后一个</span></span><br><span class="line">            <span class="built_in">removeLast</span>();</span><br><span class="line">            ++capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* newNode=<span class="keyword">new</span> <span class="built_in">Node</span>(value,pHead-&gt;next,pHead);</span><br><span class="line">        newNode-&gt;key=key;</span><br><span class="line">        pHead-&gt;next-&gt;prior=newNode;</span><br><span class="line">        pHead-&gt;next=newNode;</span><br><span class="line">        LRU[key]=newNode;</span><br><span class="line">        --capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新双向链表，实现LRU核心功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToBegin</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//更新节点处两边节点指向</span></span><br><span class="line">        node-&gt;prior-&gt;next=node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prior=node-&gt;prior;</span><br><span class="line">        <span class="comment">//将节点放置在头部</span></span><br><span class="line">        node-&gt;prior=pHead;</span><br><span class="line">        node-&gt;next=pHead-&gt;next;</span><br><span class="line">        pHead-&gt;next-&gt;prior=node;</span><br><span class="line">        pHead-&gt;next=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node* p=pBack-&gt;prior;</span><br><span class="line">        p-&gt;prior-&gt;next=pBack;</span><br><span class="line">        pBack-&gt;prior=p-&gt;prior;</span><br><span class="line">        LRU.<span class="built_in">erase</span>(p-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最小覆盖子串-1">11.9 最小覆盖子串</h3>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot;</p>
<p><strong>解题思路</strong>：</p>
<p>可尝试使用滑动窗口思路解决，先用哈希<code>Hash</code>记录<code>t</code>的字母出现次数，之后对<code>s</code>进行滑动窗口排查</p>
<ul>
<li><code>l,r</code>表示窗口的左右边界，该问题现在转化为求最满足题意得最小窗口</li>
<li>当<code>t</code>出现在窗口内，<code>++l</code></li>
<li>当<code>t</code>不在窗口内，<code>++r</code></li>
</ul>
<p>对于<code>t</code>是否出现在窗口，必须使用一个数据结构来记录当前窗口出现字母,在<code>right</code>右移的时候能够判断该字符是否是t当中的字符，并且判断加入这个字符后当前窗口是否满足<code>t</code>，满足则进入<code>left</code>右移；对于<code>left</code>右移，能够判断当前窗口移除该字符后，是否破坏满足条件，若破坏了就必须能够知道破坏后的窗口缺了多少个什么字符才能再次满足·</p>
<ul>
<li>使用哈希<code>need</code>记录<code>t</code>中各字符出现的次数。</li>
<li>使用<code>count</code>来指示当前窗口还有多少各字符为满足。<code>count==0</code>时说明满足</li>
<li>再使用一个哈希来<code>windows</code>来记录窗口中出现<code>t</code>中字符的数量，当<code>windows</code>于<code>need</code>一一对应时，则认为当前窗口满足了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希need记录所需字符及数量,windows记录当前窗口</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; windows;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span> c:t)</span><br><span class="line">            ++need[c];</span><br><span class="line">        <span class="type">int</span> startIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,minLen=INT_MAX,count=t.<span class="built_in">size</span>(),n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            <span class="type">char</span> c=s[right];</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(c)!=need.<span class="built_in">end</span>()&amp;&amp;need[c]&gt;(windows[c]++)) --count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//先记录这个满足串</span></span><br><span class="line">                <span class="type">int</span> len=right-left+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(minLen&gt;len)&#123;</span><br><span class="line">                    startIndex=left;</span><br><span class="line">                    minLen=len;</span><br><span class="line">                &#125;</span><br><span class="line">                c=s[left];</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">find</span>(c)!=need.<span class="built_in">end</span>()&amp;&amp;need[c]&gt;=(windows[c]--)) ++count;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minLen&lt;INT_MAX) <span class="keyword">return</span> s.<span class="built_in">substr</span>(startIndex,minLen);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>推荐：</strong>更巧妙的做法，优化了空间复杂度,也提升了速度，该解题思路来源力扣的<code>zrita</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">map</span><span class="params">(<span class="number">128</span>)</span></span>;   </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, need = t.<span class="built_in">size</span>(), minStart = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : t)    ++map[ch];      <span class="comment">//统计t中字符出现次数      </span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[s[right]] &gt; <span class="number">0</span>) --need;   <span class="comment">//窗口右移，每包含一个t中的字符，need-1</span></span><br><span class="line">            --map[s[right]];</span><br><span class="line">            <span class="keyword">while</span>(need == <span class="number">0</span>)    <span class="comment">//完全覆盖子串时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt; minLen)   <span class="comment">//此时字符被包含在[left,right)中</span></span><br><span class="line">                &#123;</span><br><span class="line">                    minStart = left;</span><br><span class="line">                    minLen = right - left + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(++map[s[left]] &gt; <span class="number">0</span>) ++need;  <span class="comment">//窗口左移</span></span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minLen != INT_MAX)   <span class="keyword">return</span> s.<span class="built_in">substr</span>(minStart, minLen);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="o1时间插入删除和随机获取元素">11.10 O(1)时间插入、删除和随机获取元素</h3>
<blockquote>
<p>实现<code>RandomizedSet</code> 类：</p>
</blockquote>
<blockquote>
<p><code>RandomizedSet()</code> 初始化<code>RandomizedSet</code>对象</p>
<p><code>bool insert(int val)</code> 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。</p>
<p><code>bool remove(int val)</code> 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。</p>
<p><code>int getRandom()</code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。</p>
<p>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1</p>
</blockquote>
<p><strong>分析：</strong> 因为题目多了一个随机获取元素。而要随机获取元素，那么只能是在项<code>vector</code>，数组<code>array</code>这类支持随机访问的数据结构上才能实现，但它们无法在<code>insert</code>和<code>remove</code>上做到<span class="math inline">\(O(1)\)</span>，要做到的话只能是在数组末尾才能达到<span class="math inline">\(O(1)\)</span>，而且还必须支持访问是<span class="math inline">\(O(1)\)</span>，要做到这点那么只能依赖哈希建立值与数组索引之间的映射关系</p>
<p>因此借助两个数据结构可完成，用<code>vector&lt;in&gt;hash</code>存储值，<code>unordered_map&lt;int,int&gt;hmap</code>来存储值与数组索引之间的映射关系：</p>
<ul>
<li><code>insert</code>:若插入，在<code>hmap</code>中建立值与索引关系</li>
<li><p><code>remove</code>:我们remove只在数组尾部进行，这样就避免了元素的移动。具体做法就是将<code>hash</code>的尾部元素复制到要删除的元素处，并以此旧的<code>hmap</code>映射关系，建立新的<code>hmap</code>映射关系，然后删除'hash`尾部元素。</p></li>
<li><p><code>getRandom</code>：直接在数组大小内取随机值返回即可</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//存储值</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="comment">//存储值和索引的映射，方便以O(1)形式在hash中找到</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hmap;</span><br><span class="line">    <span class="comment">//记录hash大小</span></span><br><span class="line">    <span class="type">int</span> lenght=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hmap.<span class="built_in">find</span>(val)!=hmap.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        hash.<span class="built_in">push_back</span>(val);</span><br><span class="line">        ++lenght;</span><br><span class="line">        hmap[val]=lenght<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hmap.<span class="built_in">find</span>(val)==hmap.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//获得hash最后一个元素值</span></span><br><span class="line">        <span class="type">int</span> last=hash[lenght<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//找到val元素所在hash的位置</span></span><br><span class="line">        <span class="type">int</span> index=hmap[val];</span><br><span class="line">        <span class="comment">//将末尾元素放入hash[index]</span></span><br><span class="line">        hash[index]=last;</span><br><span class="line">        <span class="comment">//建立新映射last-index</span></span><br><span class="line">        hmap[last]=index;</span><br><span class="line">        <span class="comment">//弹出最后一个元素</span></span><br><span class="line">        hash.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">//从hmap中删除val-index映射</span></span><br><span class="line">        hmap.<span class="built_in">erase</span>(val);</span><br><span class="line">        --lenght;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index=<span class="built_in">rand</span>()%lenght;</span><br><span class="line">        <span class="keyword">return</span> hash[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数组类型">12 数组类型</h2>
<p>数组一类的题目由于其所采用的数据结构为数组，因此其可考察的东西不是固定的，可以说什么方法的题目都可能涉及到数组，因此对于数组，应该多总结归纳，刷多了后，想到数组，出现在脑海的应该由：<strong>双指针、滑动窗户、动态规划、深度（递归）、前缀和、前缀差、二分查找、以及一些只针对题目的解法如数学、位运算</strong>等等，需要你对数组内的元素以及题目意思有比较深的理解。</p>
<h3 id="跳跃游戏55">12.1 跳跃游戏55</h3>
<p>给定一个非负整数数组<code>nums</code>，你最初位于数组的 第一个下标 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*方法一：</span></span><br><span class="line"><span class="comment">*回溯：dfs(nums,loc),loc为当前位置，step为当前位置的值即nums[loc],超时</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*方法二：O(n)算法</span></span><br><span class="line"><span class="comment">*发现：如果无法跳出当前可跳区间，那么可以认为无法达到最后一个下标，</span></span><br><span class="line"><span class="comment">举例：比如[3,2,1,0,4]，对应下标为[0,1,2,3,4]；</span></span><br><span class="line"><span class="comment">*刚开始对于下标0的3我们的可跳区间是下标[1,3]；对应数字是[2,1,0]；</span></span><br><span class="line"><span class="comment">*在该可跳区间中由于2+1=3；1+2=3；0+3=3，表示下一个可跳区间的最大下标是3，仍在当前的可跳区间，无法出去，</span></span><br><span class="line"><span class="comment">*那么即可认为无法到达最后一个下标</span></span><br><span class="line"><span class="comment">*思路：</span></span><br><span class="line"><span class="comment">* - 先排除一些特殊情况，当数组大小为0或1，必能达到；当数组大小&gt;1,当第一个数就是0不能达到</span></span><br><span class="line"><span class="comment">* - 我们定义beginOfJump和endOfJump，分别表示当前可跳区间的范围。</span></span><br><span class="line"><span class="comment">* - 为了确定下一个区间的最大下标，我们需要遍历[beginOfJump,endofJump]范围的数字，确定下一个区间最大下标nextMaxIndex</span></span><br><span class="line"><span class="comment">* -如果nextMaxIndex&gt;=nums.size()-1,肯定能够到达最后一个下标位置，之间返回true</span></span><br><span class="line"><span class="comment">* - 如果没有到达，且跳不出当前区间，无法到达，返回false</span></span><br><span class="line"><span class="comment">* - 如果没有到达，但能够跳出，进行下一个区间的遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">       return dfs(nums,0);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    bool dfs(vector&lt;int&gt;&amp;nums, int loc)&#123;</span></span><br><span class="line"><span class="comment">        if(loc&gt;=nums.size()-1)</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        else if(!nums[loc]&amp;&amp;loc&lt;nums.size()-1)</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=nums[loc];i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(dfs(nums,loc+i))</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()!=<span class="number">1</span>&amp;&amp;nums[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> beginOfJump=<span class="number">1</span>,endOfJump=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(beginOfJump&lt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历该可跳区间能确定的下一个区间范围</span></span><br><span class="line">            <span class="type">int</span> nextMaxIndex=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=beginOfJump;i&lt;=endOfJump;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp=i+nums[i];</span><br><span class="line">                <span class="comment">//若循环中就可达到，直接返回(剪枝)</span></span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;nextMaxIndex)</span><br><span class="line">                    nextMaxIndex=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否可跳出该区间，不可则说明不能到达</span></span><br><span class="line">            <span class="keyword">if</span>(nextMaxIndex&lt;=endOfJump)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//直接在下一区间判断</span></span><br><span class="line">            beginOfJump=endOfJump+<span class="number">1</span>;</span><br><span class="line">            endOfJump=nextMaxIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="合并区间56">12.2 合并区间56</h3>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p>思路：</p>
<ul>
<li>先对数组</li>
<li>然后判断：
<ul>
<li>首先返回数组为空时，只能选择<code>intervals</code>内的第1和第2个区间比较，若第2区间与第一区间有共同区间，则执行合并操作</li>
<li>若返回数组不为空，则先对返回数组的最后一个区间与<code>intervals</code>当前区间比较，看是否合并，合并的话执行合并操作；不合并则直接插入到返回数组即可</li>
</ul></li>
<li>合并操作：要判断是包含关系还是拼接关系
<ul>
<li>包含关系：即第一区间包含第二区间，则直接是第一区间不变即可</li>
<li>拼接关系：第一个区间的结尾替换为第二区间的结尾 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*排序+遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">if</span>(!ret.<span class="built_in">empty</span>()&amp;&amp;(*(ret.<span class="built_in">end</span>()<span class="number">-1</span>))[<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((*(ret.<span class="built_in">end</span>()<span class="number">-1</span>))[<span class="number">1</span>]&lt;intervals[i][<span class="number">1</span>])</span><br><span class="line">                    (*(ret.<span class="built_in">end</span>()<span class="number">-1</span>))[<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i+<span class="number">1</span>&lt;intervals.<span class="built_in">size</span>()&amp;&amp;intervals[i][<span class="number">1</span>]&gt;=intervals[i+<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(intervals[i][<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">//拼接关系</span></span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&lt;intervals[i+<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(intervals[i+<span class="number">1</span>][<span class="number">1</span>]); </span><br><span class="line">                <span class="comment">//包含关系</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(intervals[i][<span class="number">1</span>]);</span><br><span class="line">                ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">               ret.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="剑指offer45-把数组排成最小的数">12.3 剑指offer45 把数组排成最小的数</h3>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>思路：</p>
<ul>
<li>要自定义排序法则，将其排序成组成的数组是最小顺序</li>
<li>排序法则：从数组中任取两个数字字符串x和y，若x+y&gt;=y+x，则说明x&gt;=y；若x+y&lt;y+x，则x&lt;y</li>
<li>使用快排或者带谓词的内置函数，实现时间复杂度为O(nlogn)，最坏情况为O(n*n)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*这道题目是排序题，这不过需要自定义排序法则：</span></span><br><span class="line"><span class="comment">*可以发现从nums中任意取两个数字x和y,若x+y&gt;=y+x，说明x&gt;=y;若x+y&lt;y+x，说明x&lt;y</span></span><br><span class="line"><span class="comment">*使用自定义的快排或者带谓词的内置函数，实现时间复杂度为O(nlogn)，最坏情况为O(n)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">vec</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">            vec[i]=<span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">        <span class="built_in">quickSort</span>(vec,<span class="number">0</span>,vec.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:vec)</span><br><span class="line">            ret+=it;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;string&gt;&amp; vec,<span class="type">int</span> l,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=h)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//基准点为vec[l]</span></span><br><span class="line">        <span class="type">int</span> l_cursor=l,h_cursor=h;</span><br><span class="line">        <span class="keyword">while</span>(l_cursor&lt;h_cursor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(l_cursor&lt;=h&amp;&amp;vec[l_cursor]+vec[l]&lt;=vec[l]+vec[l_cursor])</span><br><span class="line">                ++l_cursor;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=h_cursor&amp;&amp;vec[h_cursor]+vec[l]&gt;vec[l]+vec[h_cursor])</span><br><span class="line">                --h_cursor;</span><br><span class="line">            <span class="keyword">if</span>(l_cursor&lt;h_cursor)</span><br><span class="line">                <span class="built_in">swap</span>(vec[l_cursor],vec[h_cursor]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放置基准点</span></span><br><span class="line">        <span class="built_in">swap</span>(vec[l],vec[h_cursor]);</span><br><span class="line">        <span class="built_in">quickSort</span>(vec,l,h_cursor<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(vec,h_cursor+<span class="number">1</span>,h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带谓词的内置函数</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](string&amp; x,string&amp; y)&#123;<span class="keyword">return</span> x+y&lt;y+x;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="剑指offer56-i.数组中数字出现的次数位运算">12.4 剑指offer56-I.数组中数字出现的次数（位运算）</h3>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是<code>O(n)</code>，空间复杂度是<code>O(1)</code>。</p>
<p>思路：有多种解法</p>
<p><strong>解法一</strong>：使用排序,时间复杂度为<code>O(nlogn)</code>，空间复杂度为<code>O(1)</code> <strong>解法二</strong>：使用哈希，时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(n)</code> <strong>解法三</strong>：其他数字出现了两次，则可说明当数组中只有一个数是出现一次时，数组所有元素异或后，会得到这个只出现一次的数字。此时时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code></p>
<p>对于解法三：</p>
<ul>
<li>现在是有两个出现一次的数字<code>x</code>和<code>y</code>，那么得到的结果就是<code>x^y</code></li>
<li>现在的重点是如何去划分两个数组使得其<code>x</code>,<code>y</code>各在这两个数组内
<ul>
<li><code>x^y</code>肯定存在位为<code>1</code>，表示<code>x</code>和<code>y</code>的不同点，现在我们要找到第一个<code>1</code>位</li>
<li>我们借助辅助变量<code>m=1</code>去寻找，没找到<code>m</code>就会左移一位，找到则得到最终的<code>m</code></li>
<li>之后用<code>m</code>与数组内的元素进行相<code>&amp;</code>，如果<code>num&amp;m</code>为真，划分到数组<code>1</code>执行异或，否则划分到数组<code>2</code>执行异或</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">            xy^=num;    </span><br><span class="line">        <span class="type">int</span> m=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(xy&amp;m))</span><br><span class="line">            m&lt;&lt;=<span class="number">1</span>;  </span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">            <span class="keyword">if</span>(num&amp;m)</span><br><span class="line">                x^=num; <span class="comment">//数组1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y^=num; <span class="comment">//数组2</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ret&#123;x,y&#125;;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>位运算总结：
<ul>
<li>x&amp;1：得到最底位是<code>0</code>还是<code>1</code>，与右移结合，可统计给定整数二进制形式<code>1</code>的个数</li>
<li>x^=y：得到无进位的和；检查x和y是否相同</li>
<li>x&amp;y：与<code>左移&lt;&lt;</code>结合得到进位</li>
</ul></li>
</ul>
<p>例如：不用加减乘除做加法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*                      ^   &amp;(进位)</span></span><br><span class="line"><span class="comment">* 1011  11       0  0   0   0       1011   1011    0110   0110    1000  1000   10000   10000</span></span><br><span class="line"><span class="comment">* 0111   7       0  1   1   0     &amp; 0111 ^ 0111  &amp; 1100 ^ 1100  &amp; 1010  1010  &amp; 0010 ^  0010</span></span><br><span class="line"><span class="comment">*10010  18       1  0   1   0       0011   1100    0100   1010    1000  0010   00000   10010</span></span><br><span class="line"><span class="comment">*                1  1   0   1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//进位</span></span><br><span class="line">            <span class="type">int</span> c=(<span class="type">unsigned</span> <span class="type">int</span>)(a&amp;b)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//当前</span></span><br><span class="line">            a^=b;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="剑指offer39.-数组中出现次数超过一半的数字">12.5 剑指offer39. 数组中出现次数超过一半的数字</h3>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。要求时间为O(n)，空间为O(1)</p>
<ul>
<li>解法：<strong>摩尔投票法，因为数字超过了一办，是大众数，那么可理解成数字不同的双方同归于尽，相同的则一起存活，用count取记录存活数量，res记录存的数字，最后活下来的一定是大众数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*解法一：排序，此时数字一定出现在中位数，取中位数即可，时间复杂度O(nlogn)，空间O(1)</span></span><br><span class="line"><span class="comment">*解法二：哈希，时间复杂度位O(n)，空间复杂度位O(n)</span></span><br><span class="line"><span class="comment">*解法三：摩尔投票法，因为数字超过了一办，是大众数，那么可理解成数字不同的双方同归于尽，相同的则一起存活，用count取记录存活数量，res记录存的数字，最后活下来的一定是大众数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>,res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>);i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                res=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res==nums[i]?++count:--count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="根据身高重建队列">12.6 根据身高重建队列</h3>
<p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第<code>i</code>个人的身高为<code>hi</code> ，前面 正好 有 <code>ki</code> 个身高大于或等于<code>hi</code> 的人。</p>
<p>请你重新构造并返回输入数组<code> people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
<p><strong>解法1：</strong></p>
<p><strong>思路：从头到尾构造该队列，每次从people中取出适合的人在该位置，适合的人确定算法如下，假设前面已有排好的x个人，x个人中已知最低身高是min,最高身高是max：</strong> - 先对数组按身高排序（剪枝操作，执行一次），这是因为当存在多个位次即<code>people[i][j]</code>满足需求时，个子矮的才是正确人选，这是因为如果个子高的在这个位置，个子矮的在后续位置无法满足,就比如<code>[5,0]</code>和<code>[7,0]</code>，若<code>[7,0]</code>在头，无论<code>[5,0]</code>在后面的哪个位置，其位次都不应是0，至少是1。 - 遍历数组，查看当前<code>people[i]</code>中的位次是否满足该位置，如果满足，则这个位置站的就是<code>people[i]</code>，否则取一下，反复执行直到满足 - 我们使用<code>map</code>来存储当前位置前出现比<code>map.first</code>高的人的个数 为避免重复，我们将已经拍好序的人升高赋值为<code>-1</code></p>
<p>上述时间复杂度是<code>O(nlogn)+O(n*n)=O(n*n)</code>,排序达到了剪枝效果，因此实际复杂度 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; record;</span><br><span class="line">        <span class="type">int</span> n=people.<span class="built_in">size</span>(),m=<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ret</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//对people按h排序</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            record.<span class="built_in">insert</span>(&#123;people[i][<span class="number">0</span>],<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;n)&#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="comment">//该people已经排序</span></span><br><span class="line">                <span class="keyword">if</span>(people[i][<span class="number">0</span>]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//判断该people是否符合条件</span></span><br><span class="line">                <span class="keyword">if</span>(people[i][<span class="number">1</span>]==record[people[i][<span class="number">0</span>]]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ret插入</span></span><br><span class="line">            ret[x][<span class="number">0</span>]=people[i][<span class="number">0</span>];</span><br><span class="line">            ret[x][<span class="number">1</span>]=people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//people标记已排序</span></span><br><span class="line">            people[i][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//更新record</span></span><br><span class="line">            <span class="keyword">auto</span> End = record.<span class="built_in">find</span>(ret[x][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">auto</span> it = record.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (it != End) &#123;</span><br><span class="line">                ++(it-&gt;second);</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">            ++(End-&gt;second);</span><br><span class="line">            ++x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法二（该题想要讲述的解法）：数对分别不同规则排序+插入</strong></p>
<p>思路：我们发现当我们对升高按<strong>低到高</strong>排序，，低身高的插入操作不会对高身高的人产生任何影响；反而高身高的人若插入在低身高的前面就会对低身高的产生影响。我们设人数为<code>n</code>，在进行排序后，它们的身高依次为<span class="math inline">\(h_0、h_1...h_n\)</span>。如果我们按照排完序后的顺序，依次将每个人放入队列中，那么当我们放入第<code>i</code>个人时:</p>
<ul>
<li>第<span class="math inline">\(1,...,i-1\)</span>个人已经在队列中被安排了位置，并且他们无论站在哪里，对第<span class="math inline">\(i\)</span>个人没有任何影响。</li>
<li>而<span class="math inline">\(i+1,...,n\)</span>个人还没有插入，但他们只要站在第<code>i</code>个人前面，就会对第<code>i</code>个人产生影响。</li>
</ul>
<p>因此对于第二种情况，我们需要为这种插入留空，我们根据<code>people[i][1]</code>决定留空多少个。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比如：[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span></span><br><span class="line"><span class="comment">排序：身高低到高，ki由高到低排序，得[[4,4],[5,2],[5,0],[6,1],[7,1],[7,0]]</span></span><br><span class="line"><span class="comment">插入：_ _ _ _ [4,4] _</span></span><br><span class="line"><span class="comment">	 _ _ [5,2] _ [4,4] _</span></span><br><span class="line"><span class="comment">	 [5,0] _ [5,2] _ [4,4] _</span></span><br><span class="line"><span class="comment">	 [5,0] _ [5,2] [6,1] [4,4] _</span></span><br><span class="line"><span class="comment">	 [5,0] _ [5,2] [6,1] [4,4] [7,1]</span></span><br><span class="line"><span class="comment">	 [5,0] [7,0] [5,2] [6,1] [4,4] [7,1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),[](vector&lt;<span class="type">int</span>&gt;&amp; u,vector&lt;<span class="type">int</span>&gt;&amp; v)&#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">0</span>]&lt;v[<span class="number">0</span>]||(u[<span class="number">0</span>]==v[<span class="number">0</span>]&amp;&amp;u[<span class="number">1</span>]&gt;v[<span class="number">1</span>]);&#125;);</span><br><span class="line">        <span class="type">int</span> n=people.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ret</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>,index=<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> k=people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n&amp;&amp;count&lt;=k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ret[j].<span class="built_in">empty</span>()) ++count;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; temp&#123;people[i][<span class="number">0</span>],people[i][<span class="number">1</span>]&#125;;</span><br><span class="line">            ret[index]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>总结：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。</strong></p>
<h3 id="除自身以外数组的乘积">12.7 除自身以外数组的乘积</h3>
<blockquote>
<p><strong>题目：</strong> 给你一个整数数组 <code>nums</code>，返回 数组<code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p>
</blockquote>
<blockquote>
<p>题目数据 保证 数组<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。</p>
</blockquote>
<blockquote>
<p><strong>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</strong></p>
</blockquote>
<p><strong>思路</strong>：类比于前后缀和和前后缀差，这里可以使用前缀乘积和后缀乘积解决该问题，定义<code>l[i]</code>和<code>r[i]</code>，</p>
<ul>
<li><code>l[i]</code>表示在<code>nums[i]</code>左边的所有元素乘积</li>
<li><code>r[i]</code>表述<code>nums[i]</code>右边的所有元素乘积</li>
<li>那么利润<code>l[i]</code>和<code>r[i]</code>就能得出<code>multi[i]=l[i]*r[i]</code></li>
</ul>
<p>算法的时间复杂度为<span class="math inline">\(O(n)\)</span>,空间复杂度为<span class="math inline">\(O(N)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">类比于前后缀和和前后缀差，这里可以使用前缀乘积和后缀乘积解决该问题，定义l[i]和r[i]，</span><br><span class="line">- l[i]表示在nums[i]左边的所有元素乘积</span><br><span class="line">- r[i]表述nums[i]右边的所有元素乘积</span><br><span class="line">- 那么利润l[i]和r[i]就能得出multi[i]=l[i]*r[i]</span><br><span class="line"></span><br><span class="line">算法的时间复杂度为<span class="built_in">O</span>(n),空间复杂度为<span class="built_in">O</span>(N)</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; <span class="built_in">productExceptSelf</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multi</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            l[i]=l[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">            r[n-i<span class="number">-1</span>]=r[n-i]*nums[n-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            multi[i]=l[i]*r[i];</span><br><span class="line">        <span class="keyword">return</span> multi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="section">12.8</h3>
<h2 id="分治和二分">13 分治和二分</h2>
<p>分治和二分法可以说是O(logn)时间复杂度的代名词，因此学会分治和二分法是必须的。运用分治的诸如归并排序、二分法如二分查找和查找第k大数字 ### 13.1 寻找两个正序数组的中位数 给定两个大小分别为<code>m</code>和<code>n</code>的正序（从小到大）数组 <code>nums1</code>和<code> nums2</code>。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为<code>O(log (m+n))</code>。</p>
<p><strong>解题思路：</strong>题目要求时间复杂度为<code>O(log (m+n))</code>,那么必然是使用二分法</p>
<p><strong>二分法：</strong> 使用类似于二分法的操作，计算出<code>nums1</code>和<code>nums2</code>的长度和<code>m+n</code>,那么可以肯定，当为奇数时，中位数所在位置为<code>(m+n)/2</code>;当偶数时中位数所在位置为<code>(m+n)/2</code>与<code>(m+n)/2-1</code>的均值；因此计算出<code>k=(m+n)/2</code>，表示第K大的数，当为奇数时，即得到第<code>k+1</code>大的数字即可；当为偶数是，得到第<code>k</code>大和<code>k+1</code>大数字的和平均</p>
<p><strong>我们可以通过一下适用于两个数组的二分法实现，构造一个新的辅助函数，该函数功能为得到第<code>k</code>大的数字</strong></p>
<ul>
<li>首先定义出起始位置<code>start1</code>和<code>start2</code></li>
<li>由于<code>m=k&gt;&gt;1</code>情况对某一数组而言存在越界情况，因此需取<code>min(len,start+m)</code>的较小值，由于数组下标从<code>0</code>开始，需<code>-1</code>，后得到<code>index1、index2</code></li>
<li>比较<code>nums1[index1]</code>与nums<code>[index2]</code>的大小
<ul>
<li>当<code>nums1[index1]&gt;=nums2[index2]</code>，那么就说明可以去除<code>nums2</code>数组中<code>[0,k/2]</code>范围的数字，更新k值和数组<code>nums1</code>的起始位置<code>start1</code></li>
<li>当<code>nums1[index1]&lt;nums2[index2]</code>，那么就说明可以去除<code>nums1</code>中的<code>[0,k/2]</code>，更新<code>k</code>值和<code>start2</code></li>
</ul></li>
<li><strong>退出条件：</strong>
<ul>
<li>当某一数组遍历完后，那么可知第k大数组必定在另一个数组，且<code>k\start</code>更新过，可以直接返回<code>nums[start+k-1]</code></li>
<li>当<code>k==1</code>，返回<code>min(nums1[start1],nums2[start2])</code></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=nums1.<span class="built_in">size</span>(),n=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>((m+n)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElems</span>(nums1,nums2,(m+n)/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElems</span>(nums1,nums2,(m+n)/<span class="number">2</span>)+<span class="built_in">getKthElems</span>(nums1,nums2,(m+n)/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到第K大数字</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getKthElems</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1,vector&lt;<span class="type">int</span>&gt;&amp; nums2,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">start1</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">start2</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">len1</span><span class="params">(nums1.size())</span>,<span class="title">len2</span><span class="params">(nums2.size())</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//边界情况可以退出</span></span><br><span class="line">            <span class="keyword">if</span>(start1&gt;=len1)</span><br><span class="line">                <span class="keyword">return</span> nums2[start2+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(start2&gt;=len2)</span><br><span class="line">                <span class="keyword">return</span> nums1[start1+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[start1],nums2[start2]);</span><br><span class="line">            <span class="comment">//进行更新k和start</span></span><br><span class="line">            <span class="type">int</span> m=k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> index1=<span class="built_in">min</span>(len1,m+start1)<span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> index2=<span class="built_in">min</span>(len2,m+start2)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums1[index1]&gt;=nums2[index2])</span><br><span class="line">            &#123;</span><br><span class="line">                k-=(index2-start2+<span class="number">1</span>);</span><br><span class="line">                start2=index2+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k-=(index1-start1+<span class="number">1</span>);</span><br><span class="line">                start1=index1+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数组中的第k个最大元素">13.2 数组中的第K个最大元素</h3>
<p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>思路：</strong>我们知道快速排序是以分治的思想来降低复杂度，其算法流程是</p>
<ul>
<li><strong>分解</strong>：将数组<span class="math inline">\(a[l...r]\)</span>划分成两个子数组<span class="math inline">\(a[l...q-1]、a[q+1...r]\)</span>,使得<span class="math inline">\(a[l...q-1]\)</span>中的元素小于等于<span class="math inline">\(a[q]\)</span>，且<span class="math inline">\(a[q]\)</span>小于等于<span class="math inline">\(a[q+1...r]\)</span>中的每一个元素。其中，计算下标q也是<strong>划分</strong>过程的一部分</li>
<li><strong>解决</strong>：通过递归调用快速排序，对于数组<span class="math inline">\(a[l...q-1]、a[q+1...r]\)</span>进行排序</li>
<li><strong>合并：</strong>因为子数组都是原址排序的，所以不需要进行合并操作，<span class="math inline">\(a[l...r]\)</span>已经有序</li>
<li>上文中提到的 「划分」 过程是：从子数组<span class="math inline">\(a[l...r]\)</span>中选择任意一个元素 <span class="math inline">\(x\)</span> 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， <span class="math inline">\(x\)</span> 的最终位置就是 <span class="math inline">\(q\)</span></li>
</ul>
<p><strong>可以发现每次划分后都会确定一个元素在数组中的位置，因此对于第k个最大元素，我们只需要关注该位置即可，对于区间有序性并不在乎。为避免最坏的时间复杂度，使用随机法取基准点</strong>，随机法能够避免最坏复杂度，</p>
<p>算法步骤：</p>
<ul>
<li>利用快速排序的方法，只确定数组中的第K个最大的元素。</li>
<li>为避免最坏情况，使用随机法规范</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">//选择快排</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">RandomPivot</span>(nums, l, r);</span><br><span class="line">        <span class="keyword">if</span> (index == k) <span class="keyword">return</span> nums[index];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> index &gt; k ? <span class="built_in">quickSelect</span>(nums, l, index - <span class="number">1</span>, k) : <span class="built_in">quickSelect</span>(nums, index + <span class="number">1</span>, r, k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机选择基准点</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">RandomPivot</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">swap</span>(nums[r], nums[index]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partirion</span>(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">partirion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = nums[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums.<span class="built_in">size</span>() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上题目均来自leetcode 题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/all/">leetcode</a></p>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="trluper 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="trluper 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" rel="prev" title="动态规划算法思想">
      <i class="fa fa-chevron-left"></i> 动态规划算法思想
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/30/MySQL/" rel="next" title="MySQL">
      MySQL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%B7%E9%A2%98%E8%A7%84%E5%88%92"><span class="nav-number">1.</span> <span class="nav-text">0. 刷题规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">1. 动态规划类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7dp"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 线性DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">2.1.1.</span> <span class="nav-text">打家劫舍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-1"><span class="nav-number">2.1.2.</span> <span class="nav-text">打家劫舍Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-2"><span class="nav-number">2.1.3.</span> <span class="nav-text">打家劫舍Ⅲ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C"><span class="nav-number">2.1.4.</span> <span class="nav-text">最大子数组的和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer-%E4%B8%91%E6%95%B0"><span class="nav-number">2.1.5.</span> <span class="nav-text">剑指offer 丑数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0"><span class="nav-number">2.1.6.</span> <span class="nav-text">n个骰子的点数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">2.1.7.</span> <span class="nav-text">单词拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">2.1.8.</span> <span class="nav-text">接雨水</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E4%B9%B0%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="nav-number">2.1.9.</span> <span class="nav-text">最佳买股票时机含冷冻期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="nav-number">2.1.10.</span> <span class="nav-text">最长递增序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90"><span class="nav-number">2.1.11.</span> <span class="nav-text">粉刷房子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4dp"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 区间DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">2.2.1.</span> <span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">2.2.2.</span> <span class="nav-text">最长回文子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">2.2.3.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">2.2.4.</span> <span class="nav-text">编辑距离</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.2.5.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85dp"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 背包DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E5%8E%8Bdp"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 状压DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%BD%99%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">2.5.</span> <span class="nav-text">1.5 剑指offer62 圆圈中最后剩余的数字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">2. 树类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#i-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">3.1.1.</span> <span class="nav-text">2.1.1 I-从上到下打印二叉树（层次遍历）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.1.3 树的子结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.1.3.</span> <span class="nav-text">2.1.4 树的镜像(翻转二叉树)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.1.4.</span> <span class="nav-text">2.1.5 重建二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.1.5.</span> <span class="nav-text">2.1.6 序列化二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.2.1 不同的二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2.2 二叉搜索树的最近公共祖先节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.2.3 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.2.4 二叉搜索树的后续遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E6%96%AD"><span class="nav-number">3.3.1.</span> <span class="nav-text">2.3.1 平衡二叉树判断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">3. 链表类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 两数相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 删除链表倒数第N个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 合并K个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">4.4.</span> <span class="nav-text">3.4 两两交换链表中的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">4.5.</span> <span class="nav-text">3.5 K个一组翻转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii"><span class="nav-number">4.6.</span> <span class="nav-text">3.6 环形链表II</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">4. 字符串类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#n%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 N字形变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 字符串最大公因子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2manacher%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 最长回文子串（Manacher算法解决）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.4.</span> <span class="nav-text">4.4 重复的子字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-number">5.5.</span> <span class="nav-text">4.5 最小覆盖子串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">5. 双指针类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 无重复字符的最长子串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">6.1.1.</span> <span class="nav-text">5.2 盛最多水的容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">6.2.</span> <span class="nav-text">5.3 三数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">6.3.</span> <span class="nav-text">5.4 最接近的三数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">6.4.</span> <span class="nav-text">5.5 四数之和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text">6. 深度优先搜索类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E7%BB%84%E5%90%88"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 括号组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 全排列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">7. 广度优先搜索类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6"><span class="nav-number">9.</span> <span class="nav-text">8. 数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">9.1.</span> <span class="nav-text">8.1 下一个排列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5"><span class="nav-number">10.</span> <span class="nav-text">9. 矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">10. 图类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="nav-number">11.1.</span> <span class="nav-text">10.1 拓扑排序：课程表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F"><span class="nav-number">12.</span> <span class="nav-text">11. 模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="nav-number">12.1.</span> <span class="nav-text">11.1 字符串转整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer29.-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">12.2.</span> <span class="nav-text">11.2 剑指offer29. 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E8%BD%AC90"><span class="nav-number">12.3.</span> <span class="nav-text">11.3 顺时针转90°</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">12.4.</span> <span class="nav-text">11.4 包含min函数的栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer59-ii.-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">12.5.</span> <span class="nav-text">11.5 剑指offer59-II. 队列的最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">12.6.</span> <span class="nav-text">11.6 滑动窗口最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">12.7.</span> <span class="nav-text">11.7 正则表达式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lru"><span class="nav-number">12.8.</span> <span class="nav-text">11.8 LRU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-1"><span class="nav-number">12.9.</span> <span class="nav-text">11.9 最小覆盖子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#o1%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="nav-number">12.10.</span> <span class="nav-text">11.10 O(1)时间插入、删除和随机获取元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.</span> <span class="nav-text">12 数组类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F55"><span class="nav-number">13.1.</span> <span class="nav-text">12.1 跳跃游戏55</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B456"><span class="nav-number">13.2.</span> <span class="nav-text">12.2 合并区间56</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="nav-number">13.3.</span> <span class="nav-text">12.3 剑指offer45 把数组排成最小的数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer56-i.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">13.4.</span> <span class="nav-text">12.4 剑指offer56-I.数组中数字出现的次数（位运算）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer39.-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">13.5.</span> <span class="nav-text">12.5 剑指offer39. 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">13.6.</span> <span class="nav-text">12.6 根据身高重建队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="nav-number">13.7.</span> <span class="nav-text">12.7 除自身以外数组的乘积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section"><span class="nav-number">13.8.</span> <span class="nav-text">12.8</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E5%92%8C%E4%BA%8C%E5%88%86"><span class="nav-number">14.</span> <span class="nav-text">13 分治和二分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">14.1.</span> <span class="nav-text">13.2 数组中的第K个最大元素</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:34</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
      <script type="text/javascript">
      function renderGitalk(){
        var gitalk = new Gitalk({
            owner: '',
            repo: '',
            clientID: '123fe329fdbb06b0f1d1',
            clientSecret: '40add829107b6e69f43274d3545ae71c988de8eb',
            admin: '',
            
            });
        gitalk.render('gitalk-container');
      }
      renderGitalk();
      </script>
    
 


<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>