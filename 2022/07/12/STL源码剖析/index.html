<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.STL概述 1.1 六大组件  容器：各种数据结构,如vector、list、deque、set、map等,用来存放数据 算法：各种常用的算法（冒泡，排序）,如sort、find、copy、for_each、search、erase 迭代器：扮演了容器与算法之间的胶合剂，是所谓的泛型指针 仿函数：行为类似函数，可作为算法的某种策略 适配器：一种用来修饰容器或者仿函数或迭代器接口的">
<meta property="og:type" content="article">
<meta property="og:title" content="STL源码剖析">
<meta property="og:url" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:description" content="1.STL概述 1.1 六大组件  容器：各种数据结构,如vector、list、deque、set、map等,用来存放数据 算法：各种常用的算法（冒泡，排序）,如sort、find、copy、for_each、search、erase 迭代器：扮演了容器与算法之间的胶合剂，是所谓的泛型指针 仿函数：行为类似函数，可作为算法的某种策略 适配器：一种用来修饰容器或者仿函数或迭代器接口的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/memorypool.png">
<meta property="og:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/iterator.png">
<meta property="og:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/deque.png">
<meta property="og:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dequemap.png">
<meta property="og:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dequeiterator.png">
<meta property="og:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/heapSort.gif">
<meta property="og:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/priorityqueue.png">
<meta property="og:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/rbtreeiterator.png">
<meta property="og:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/hashtablelist.png">
<meta property="og:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/quickSort.gif">
<meta property="article:published_time" content="2022-07-12T14:15:12.000Z">
<meta property="article:modified_time" content="2023-02-24T14:02:44.605Z">
<meta property="article:author" content="trluper">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/memorypool.png">

<link rel="canonical" href="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STL源码剖析 | Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STL源码剖析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-12 22:15:12" itemprop="dateCreated datePublished" datetime="2022-07-12T22:15:12+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-24 22:02:44" itemprop="dateModified" datetime="2023-02-24T22:02:44+08:00">2023-02-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>88k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:20</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="stl概述">1.STL概述</h4>
<h5 id="六大组件">1.1 六大组件</h5>
<ul>
<li>容器：各种数据结构,如<code>vector、list、deque、set、map</code>等,用来存放数据</li>
<li>算法：各种常用的算法（冒泡，排序）,如<code>sort、find、copy、for_each、search、erase</code></li>
<li>迭代器：扮演了容器与算法之间的胶合剂，是所谓的泛型指针</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理。注意一般都伴随着重新分配空间，那么原来的迭代器就会失效</li>
</ul>
<p>六大组件的交互关系是<code>Container</code>通过<code>Allocator</code>获得数据存储空间，<code>Alogrithm</code>通过<code>Iterator</code>存取<code>Container</code>的内容，<code>Functor</code>可以协助<code>Algorithm</code>完成不同的策略变化，<code>Adapter</code>可以修饰或套接<code>Functor</code>。本笔记将会以此对这六大组件进行介绍。</p>
<p>++说在前面：STL的实现版本由HP版本、PJ版本、RW版本、STLport版本和SGISTL版本等五个主要版本++</p>
<span id="more"></span>
<h4 id="空间配置器">2. 空间配置器</h4>
<p>在介绍STL的其他组件尤其是<code>container</code>组件之前，空间配置器是必须要先介绍的，因为容器内存空间的开辟需要由<code>allocator</code>去申请。allocator申请的空间是为构造原始的，<code>new</code>申请的空间是已构造的。在<code>gcc</code>中的容器使用了缺省的SGI版本的空间配置器：<code>class Alloc = alloc</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, **<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc**&gt;	<span class="comment">//默认使用了alloc</span></span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="comment">/*...实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="空间配置器的标准接口">2.1 空间配置器的标准接口</h5>
<p>allocator的必要接口（无论是哪个版本的STL）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员变量</span></span><br><span class="line">allocator::value_type;</span><br><span class="line">allocator::pointer;</span><br><span class="line">allocator::const_pointer;</span><br><span class="line">allocator::reference;</span><br><span class="line">allocator::const_reference;</span><br><span class="line">allocator::size_type;</span><br><span class="line">allocator::difference_type;</span><br><span class="line">allocator::rbind;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>();</span><br><span class="line">allocator::<span class="built_in">allocator</span>(<span class="type">const</span> allocator&amp;);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;allocator：：<span class="built_in">allocator</span>(<span class="type">const</span> allocator&lt;U&gt;&amp;);</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">allocator::~<span class="built_in">allocator</span>();</span><br><span class="line"><span class="comment">//返回某个对象的地址，等同于&amp;X</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::address</span><span class="params">(reference x)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//配置空间，n个足以存储U对象</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n,<span class="type">const</span> <span class="type">void</span>*=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//回收配置的空间,p为allocate返回的指针，n为allocate分配是指定的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::deallocate</span><span class="params">(pointer p,size_type n)</span></span>;</span><br><span class="line"><span class="comment">//对分配空间进行构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::construct</span><span class="params">(pointer,<span class="type">const</span> T&amp;x)</span></span>;</span><br><span class="line"><span class="comment">//对构造空间析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::destroy</span><span class="params">(pointer p)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="设计一个简单的空间配置器">2.1.1设计一个简单的空间配置器</h6>
<p>根据上述的接口，我们可以实现一个自己的、功能简单，接口不齐全的<code>allocator</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstddef&gt;</span>	<span class="comment">//ptrdiff_t,size_t类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myallocator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">inline</span> T* _allocate()（<span class="type">ptrdiff_t</span> size,T*)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//使用全局operator new ,相当于malloc</span></span><br><span class="line">		T* tmp=(T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size*<span class="built_in">sizeof</span>(T))));	<span class="comment">//调用全局重载运算符new</span></span><br><span class="line">		<span class="keyword">if</span>(tmp==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cerr&lt;&lt;<span class="string">&quot;out_of_memory&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _deallocate(T*buffer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//相当于free</span></span><br><span class="line">		::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _construct(T* p,<span class="type">const</span> U&amp; value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span>(p) <span class="built_in">U</span>(value);		<span class="comment">//placement new，相当于realloc，并进行构造</span></span><br><span class="line">	&#125;</span><br><span class="line">	/析构</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _destroy(T* ptr)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">allocator</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> T  value_type;</span><br><span class="line">		<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> T* const_pointer;</span><br><span class="line">		<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">		<span class="comment">//内嵌体</span></span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rebind</span>&#123;</span><br><span class="line">			<span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//函数</span></span><br><span class="line">		<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n,<span class="type">const</span> <span class="type">void</span>* hint=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> _allocate((difference_type)n,(pointer)hint);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">deallocte</span><span class="params">(pointer p,size_type n)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_deallocate(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_constrcut(p,value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			_destroy(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	<span class="comment">//end of namespace myallocator</span></span><br></pre></td></tr></table></figure></p>
<h5 id="sgi空间配置器">2.2 SGI空间配置器</h5>
<p>SGI版本的空间配置器与众不同，其名称是<code>alloc</code>而不是<code>allocator</code>。<code>alloc</code>不接受任何参数，即如果你的程序要采用SGI版本的配置器，则不能使用标准写法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::allocator&lt;<span class="type">int</span>&gt;&gt; iv;</span><br></pre></td></tr></table></figure> 而应当使用： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::alloc&gt; iv;</span><br></pre></td></tr></table></figure> 其实这个问题不会给我们带来困扰，在<code>GCC</code>中是使用缺省的空间配置器，我们可以不用显示的去指定，编译器默认采用SGI的这个版本。</p>
<p><strong><em>附</em></strong>：虽然SGI也提供了一个<code>aloocator</code>版本，但是不建议使用，因为效率不佳，因为它只是对<code>::operator new</code>和<code>::operator delete</code>做一个简单包装而已</p>
<h5 id="sgi的alloc">2.3 SGI的alloc</h5>
<p>我们知道<strong><code>new</code>算式包含两个步骤</strong>：一是调用<code>::operator new</code>配置内存；二是调用相应的构造函数构造对象内容。同样<strong><code>delete</code>算式也包含两个步骤</strong>：一是调用对象的析构函数析构；二是调用<code>::operator delete</code>释放内存</p>
<p>为了精密加工和效率的提升，STL的allocator把这两步操作区分开来，<strong>内存配置操作由<code>alloc::allocate()</code>负责，内存释放由<code>alloc::deallocate()</code>负责；而对象的构造和析构分别是由<code>::construct()</code>和<code>::destroy()</code>负责。</strong>STL的标准中规定配置器的定义位于<code>&lt;memory&gt;</code>中，对SGI版本来说<code>&lt;memory&gt;</code>内含有关键的两个文件，这两个文件实行上面的工作划分规则 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_alloc.h&gt;</span>		<span class="comment">//负责内存的配置和释放</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_construct.h&gt;</span>	<span class="comment">//负责构造和析构</span></span></span><br></pre></td></tr></table></figure> 在<code>&lt;stl_alloc.h&gt;</code>中定义了<strong>一、二级配置器</strong>，而在<code>&lt;stl_construct.h&gt;</code>定义了<code>construct()</code>和<code>destroy()</code>函数。</p>
<h5 id="alloc的stl_constuct">2.4 alloc的stl_constuct</h5>
<p>在<code>&lt;stl_construct.h&gt;</code>定义了多个重载的<code>construct()</code>和<code>destroy()</code>函数。这里介绍接受两个迭代器版本的<code>destroy()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator lasu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_destroy(first,last,<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个函数我们可以知道它会析构掉<code>[first,last)</code>范围内对象，<strong>如果是调用一些无关痛痒得析构函数，又万一这个范围很大的话效率会极低。因此<code>_destroy()</code>利用<code>value_type()</code>获得迭代器对象所指代得类型，在<code>_destroy</code>内部利用<code>_type_traits&lt;T&gt;</code>判断该类型得析构是否对内存空间无关痛痒，若是<code>_true_type</code>，则什么也不做就结束，若是<code>_false_type</code>则只能迭代去析构这个范围得对象。</strong></p>
<h5 id="空间配置stl_alloc">2.5 空间配置stl_alloc</h5>
<p>SGI内部是以<code>malloc()</code>和<code>free()</code>完成内存得配置与释放得。考虑到小型区块可能造成内存碎片得问题，SGI设计了双层配置器，<strong>第一级直接使用<code>molloc()</code>和<code>free()</code>,第二级则看情况采用不同策略分配：</strong></p>
<ul>
<li>当配置区块超过<code>128bytes</code>时，视为足够大，直接调用第一级得配置器</li>
<li>当配置区块小于<code>128bytes</code>时，视为小，便采用复杂的<code>memory pool</code>和自由链表管理配置</li>
</ul>
<p><strong>内存池<code>memory pool</code></strong>：内存池是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样，内存池允许在运行期以常数时间规划内存块，并且尽量避免了内存破碎的情况产生，使得内存分配的效率得到提升。</p>
<p><strong><em>注意：是只开放一级配置器还是同时开放二级，由<code>_USE_MALLOC</code>是否被定义而定，当被定义是，只开放第一级配置器，当未背定义时两级都开放。</em></strong></p>
<h6 id="一级配置器">2.5.1 一级配置器</h6>
<p>一级配置器是类名为<strong><code>template&lt;int inst&gt;class _malloc_alloc_template&#123;...&#125;</code></strong>的一个类，在<code>allocate()</code>内直接使用<code>malloc()</code>,在<code>deallocate()</code>直接使用<code>free()</code>。同时<strong>模拟<code>set_new_handler()</code>来处理内存不足的情况</strong>。奉上源码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_malloc_alloc_template</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//以下函数用来处理内存不足的情况</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span>*,<span class="type">size_t</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*_malloc_alloc_oom_handler)</span><span class="params">()</span></span>;	<span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//allocate分配</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">		<span class="type">void</span> *result=<span class="built_in">malloc</span>(n);		<span class="comment">//直接使用malloc分配</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==result)</span><br><span class="line">			result=<span class="built_in">oom_malloc</span>(n);	<span class="comment">//不断尝试</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p,<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//模拟set_new_hanlder，返回函数指针</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span><span class="params">(* set_malloc_hanlder(<span class="type">void</span>(*f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">void</span> (*old)=_malloc_alloc_oom_handler;</span><br><span class="line">		<span class="comment">//设置</span></span><br><span class="line">		_malloc_alloc_oom_handler=f;</span><br><span class="line">		<span class="keyword">return</span> (old);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数为纯虚函数，需要自己编写处理函数来不断尝试释放内存、申请内存</span></span><br><span class="line"><span class="built_in">void</span> (* _malloc_alloc_template&lt;inst&gt;::_malloc_alloc_oom_handler)()=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//malloc形式的不断尝试</span></span><br><span class="line"><span class="type">void</span> *_malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n)&#123;</span><br><span class="line">	<span class="built_in">void</span> (*my_malloc_hanlder)();	<span class="comment">//函数指针</span></span><br><span class="line">	<span class="type">void</span> *result;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;<span class="comment">//不断尝试释放，配置</span></span><br><span class="line">		my_malloc_hanlder=_malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0</span>==my_malloc_handler)</span><br><span class="line">			_ThROW_BAD_ALLOC;</span><br><span class="line">		(*my_malloc_handler)();<span class="comment">//调用释放</span></span><br><span class="line">		<span class="comment">//进行分配</span></span><br><span class="line">		result=<span class="built_in">malloc</span>(n);</span><br><span class="line">		<span class="comment">//分配成功直接返回</span></span><br><span class="line">		<span class="keyword">if</span>(result)</span><br><span class="line">			<span class="keyword">return</span>(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>查看上述的部分源代码可以知道</strong></p>
<ul>
<li>第一级空间分配器以<code>malloc()、free()、realloc()</code>等C函数执行内存配置，而不是采用<code>C++</code>的<code>::operator new</code>，<strong>因此无法使用C++的<code>new hanlder</code>机制，也就不能使用<code>set_new_hanlder()</code>,必须仿真一个类似该功能的<code>set_malloc_handler()</code></strong></li>
<li><code>allocate()</code>分配不成功后会改调用<code>oom_malloc()</code>不断尝试去释放分配，其中的<code>_malloc_alloc_oom_hanlder()</code>函数是要自己去编写指定的。如果你没有传入该函数，源码也未提供，默认为纯虚函数，则进入到<code>oom_hanlder()</code>判断后直接抛异常。</li>
</ul>
<h6 id="附加知识点new-handler机制">2.5.2 附加知识点：new handler机制</h6>
<p><code>new_handler</code>是一个void*类型的函数指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">　<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;	<span class="comment">//函数指针，只是起个名字new_handler=void*</span></span><br><span class="line"> <span class="comment">//new_handler是一个typedef后void*</span></span><br><span class="line">　<span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>new_handler</code>类型内的函数将在默认内存申请函数<code>operator new</code>和<code>operator new[]</code>申请内存失败时被调用;</li>
<li>默认情况下, 当内存不能够分配时, <code>new</code>操作将抛出一个<code>bad_alloc</code>的异常。 你可以改变这个默认操作, 通过<code>set_new_handler()</code>设置<code>new_handler</code>内的函数指针。当然 你可以使用<code>set_new_handler(0)</code>, 获得一个不抛出异常的<code>new</code>.</li>
</ul>
<p><strong>用户定义的my_handler应该可以做以下几件事之一:</strong></p>
<ul>
<li>释放内存, 产生更多可以用的内存</li>
<li>抛出bad_alloc异常(或bad_alloc派生类)</li>
<li>终止程序(比如调用abort或exit)</li>
</ul>
<h6 id="二级配置器">2.5.3 二级配置器</h6>
<p>二级配置器类名为<strong><code>template&lt;bool threads,int ints&gt;class _default_alloc_template&#123;...&#125;</code>：维护16个自由链表，负责16种小型区块内存池的次配置能力，内存池<code>memory pool</code>事先由<code>malloc</code>配置而得</strong>。为了方便管理，SGI的二级配置会主动将小额的内存需求上调至8的倍数，例如我们要求分配30bytes，那么二级配置器就会分配维护多个<code>32bytes</code>的内存块。第二级配置器多了许多机制，以避免太多的小额区块造成内存碎片，从而避免内存浪费和减轻配置负担，第二级配置的做法是：</p>
<ul>
<li>当配置区块超过<code>128bytes</code>时，视为足够大，直接调用第一级得配置器</li>
<li>当配置区块小于<code>128bytes</code>时，视为小，便采用复杂的<code>memory pool</code>管理配置，又称为次层配置。</li>
</ul>
<p><strong><code>memory pool</code>的想法是</strong>：预先配置一大块内存，一般来书为需求的2倍，并维护与之对应的自由链表<code>free list</code>。<strong>下次若有对应大小的内存需求，则直接从该链表拔出给它就行；如果客户端释还从该内存池种拔出的一部分内存，则由配置器回收到该内存池中</strong>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//free list的节点结构如下所示：节点使用union而不是struct，从而达到节省内存开销的目的。</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span>&#123;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;	<span class="comment">//未被使用时，由次指针维护</span></span><br><span class="line">	<span class="type">char</span> client_data[<span class="number">1</span>];	<span class="comment">//当内存被使用时，软件开发者使用这个，执行实际区块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>下面来介绍这种机制：</strong>从内存池中取空间给<code>free list</code>是<code>chunk_alloc()</code>函数得工作。</p>
<ul>
<li>如<code>chunk_alloc(32，20)</code>会根据<code>end_free-start_free</code>来判断内存池得水量是否充足，如果水量充足，则直接调出20个相应大小的内存区块给<code>free_list</code>；如果不充足则调用<code>malloc</code>分配至少40个<code>32bytes</code>的内存块，一个直接给客户端，19个给<code>free_list</code>维护，另外的给内存池</li>
<li>如果不够20个但至少能满足一个32bytes的内存块，也会拨出至少一个；</li>
<li>如果连一个区块都拨不出去，此时便会利用<code>malloc</code>从<code>heap</code>上配置内存，从内存中为内存池注入水源以应付需求，一般来说申请的内存是需求量的2倍。</li>
</ul>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/memorypool.png" width="700"></p>
<p>如上图：</p>
<ul>
<li><strong>假设程序一开始就调用<code>chunk_alloc(32,20)</code>,那么<code>malloc</code>就会配置40个<code>32bytes</code>的区块，其中第一个交出，另外19个交给<code>free_list[3]</code>维护，剩余20个交给内存池。</strong></li>
<li>接下来客户端再调用<code>chunk_alloc(64,20)</code>,此时很明显<code>free_list[7]</code>没有内存，必须向内存池请求支持，但内存池也只够10个64<code>bytes</code>的区块，那么就会交付这10，一个直接给客户端，另外9个由<code>free_list[7]</code>维护。此时内存池已经空了，</li>
<li>如果再调用<code>chunk_alloc(96,20)</code>,不仅<code>free_list[11]</code>没有内存，就连内存池也没有，那么就会调用<code>malloc</code>配置40+n个<code>96bytes</code>区块，其中第一个给客户端，19个给<code>free_list[11]</code>，另外的给内存池。</li>
<li>如果<code>malloc()</code>也无法分配内存，就会使用第一级配置，不断尝试去释放获取。</li>
</ul>
<h4 id="迭代器与traits编程技法">3. 迭代器与traits编程技法</h4>
<p><code>iterator</code>是指提供一种方法，使之能够依序巡防某个容器所含的各个元素，而又无需暴露该容器的内部表达式。STL通过泛型化将数据容器和算法分开，采用<code>iterator</code>将两者粘合起来，以<code>find</code>为例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(first!=last&amp;&amp;*first!=value)</span><br><span class="line">		++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 迭代器是一种行为类似指针的<strong>对象</strong>，而指针最常见的应用就是<strong>内容提取和成员访问</strong>，因此对于迭代器来说最重要的编程工作就是对<code>operator *、operator-&gt;、operator++</code>进行重载</p>
<h5 id="traits编程技法-stl源码的门钥">3.1 traits编程技法-STL源码的门钥</h5>
<h6 id="为什么要使用traits编程技法">3.1.1 为什么要使用traits编程技法</h6>
<p>迭代器一般都为模板，其所指对象的的型别，称为该迭代器的<code>value type</code>。模板函数虽然带有参数类型的推导，但却不是万能的：<strong>万一<code>value type</code>用于函数的反回值，毕竟template的参数推导机制只是适用于参数，无法推导返回值</strong>。<strong>我们可能可以在类内定义内嵌型别来解决，也可以使用<code>C++11</code>的的尾置返回类型</strong><code>remove_reference&lt;decltype(beg*)&gt;::type</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内嵌类型声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myiter</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;		<span class="comment">//内嵌型别声明</span></span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> I&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> I::value_type <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾置返回类型</span></span><br><span class="line"><span class="comment">//此例中我们通知编译器fcn2的返回类型与解引用beg的参数的结果类型相同</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(T beg,T end)</span>-&gt;<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上面这个程序看起来能够解决返回值问题，但是有一个问题就是我们<strong>不能为不是类类型的定义内嵌型别</strong>，比如<strong>指针</strong>就不行，但STL又必须接受原生指针作为一种迭代器。虽然采用模板的特例化可以解决问题，但是每有需要就要特例化一个模板就很麻烦，此时就得采用<code>traits</code>的偏特例化编程。(像<code>int*,double*</code>内置类型或者自动定义的类的指针就是原生指针)</p>
<h6 id="traits和偏特例化">3.1.2 traits和偏特例化</h6>
<p><code>traits</code>单词只是说明这个类能萃取到迭代器的特性，只是一个名字的作用，告诉编程人员注意对于这种类内部会对传入的参数进行取<code>value type</code>操作，说实在就是STL当中的规范协议。如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> itrator_traits&lt;I&gt;::<span class="built_in">value_type</span>(I iter)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果I内定义了自己的<code>value type</code>，那么就会在<code>iterator_traits</code>这种类内部有取<code>value type</code>操作。这里跟我们上面提到的内嵌型别说明是一样的。上面这个类只是起到中间转换的作用，这就<code>traits</code>的特定。</p>
<p>然后我们在去实现iterator_traits的一个特例化版本即传入指针形式的偏特化版本就能取得指针的类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的机制是当我们传入T*=int*时，因为int内有定义value_type那么就肯定能获得其类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 为啥还需要const版本，引用我们最终要获取时<code>I</code>的类型，而不是<code>const+类型</code>,试想当没有const版本，调用iterator_traits&lt;const int*&gt;会获取到<code>const int</code>而不是<code>int</code>。<strong>三个版本都是需要的，后面两个版本为解决原生指针无法获取类型而采用（应用偏特例化）</strong></p>
<p>总结：</p>
<ul>
<li>实现原生指针也能推导返回值类型就是要<code>traits</code>编程技法</li>
<li><code>traits</code>不是什么C++内部关键字，它只是对STL源码编写的一个规范</li>
<li><code>traits</code>编程技法主要应用于迭代器实现，迭代器就是行为像指针的类，保证我们在使用迭代器类的<code>operator*</code>后能返回迭代器所指的元素</li>
<li><code>traits</code>编程技法的实现原理就是对类模板的偏特例化（上面的二个篇特例化模板）</li>
</ul>
<h5 id="迭代器相应型别">3.2 迭代器相应型别</h5>
<p>更加迭代器使用<code>operator*</code>时所返回的类别，一般有<code>value type,difference type,pointer,reference,itrator category</code>这五种。因此我们在对<code>traits</code>类进行<code>typedef</code>时都应当指定，以便符号STL规范，即使自己编写的迭代器类也能与STL水乳交融。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::iterator_category	iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type 		    value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::difference_type 	difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer 			pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference 			reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="value_type">3.2.1 value_type</h6>
<p><code>value_type</code>就是迭代器所指对象的型别，任何一个打算与STL算法有完美搭配的class,都应当定义自己的<code>value_type</code>内嵌型别。</p>
<h6 id="difference_type">3.2.2 difference_type</h6>
<p><code>difference_type</code>用来表示两个迭代器的距离，因此也可以用来表示一个容器的最大容量。比如STL的<code>count</code>算法统计指定值出现次数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>,<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I*&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">count</span><span class="params">(I fist,I last,<span class="type">const</span> T&amp; value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;I*&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;first!=last;++first)</span><br><span class="line">		<span class="keyword">if</span>(*first==value)</span><br><span class="line">			++n;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="reference">3.2.3 reference</h6>
<p><code>reference_type</code>即我们熟知的C++当中的左值引用，这个类型允许我们通过迭代器来对容器内的元素做出改变。</p>
<h6 id="pointer">3.2.4 pointer</h6>
<p><code>pointer</code>是指指针，传回一个指针表示我们也可以通过迭代器对容器内的元素做改变。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="iterator_category">3.2.5 iterator_category</h6>
<p>这个型别是迭代器的类型型名，必须指定迭代器的分类如下： <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/iterator.png" width="300"> 我们在设计算法的时候，必须针对上图的某种迭代器提供一明确定义，比如有一个算法明确使用<code>ForwardIterator</code>，那就应当明确传递这种迭代器，虽然传递<code>RandomAccessIterator</code>和<code>BidirectionalIterator</code>也可以,但效率并不是最佳。</p>
<h5 id="iterator源代码展示">3.3.iterator源代码展示</h5>
<p>下面的源代码选自SGI版本的STL<code>&lt;stl_iterator.h&gt;</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ITERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ITERATOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//五种迭代器，作为标记型别（tag types）,不需要任何成员</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iteratoe_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为避免写代码时挂一漏万，自行开发的迭代器最好继承自下面这个 std::iterator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Category</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>=<span class="type">ptrdiff_t</span>,</span><br><span class="line">		<span class="keyword">class</span> Pointer=T*,<span class="keyword">class</span> Reference=T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//五种迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> input_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                   value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance            difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                  pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                  reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>                 reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                     value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance              difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                    pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                    reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance                    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;榨汁机&quot;traits</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type    difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer            pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference          reference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生指针（naive pointer）而设计的traits偏特性化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T*                          pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp;                          reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对Pointer-to-const而设计的traits偏特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T*                    pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T                     reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某迭代器iterator的类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">category</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器的value_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器的distance_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type*</span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="type">const</span> Iterator&amp; It)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//........................整组advance函数............................................</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数重载，使迭代器能在编译时期就确定调用哪个函数*/</span>  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为input_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_InputIter&amp; __i, _Distance __n, input_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (__n--) ++__i;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为bidirectional_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_BidirectionalIterator&amp; __i, _Distance __n,   </span><br><span class="line">                      bidirectional_iterator_tag) </span><br><span class="line">&#123;  </span><br><span class="line">  __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);  </span><br><span class="line">  <span class="keyword">if</span> (__n &gt;= <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">while</span> (__n--) ++__i;</span><br><span class="line">  <span class="keyword">else</span>  </span><br><span class="line">    <span class="keyword">while</span> (__n++) --__i;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*迭代器类型为random_access_iterator_tag的函数定义*/</span>  </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(_RandomAccessIterator&amp; __i, _Distance __n,   </span><br><span class="line">                      random_access_iterator_tag) </span><br><span class="line">&#123;  </span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);  </span><br><span class="line">  __i += __n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="comment">/*决定调用哪个函数，这是一个对外接口*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(_InputIterator&amp; __i, _Distance __n)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_InputIterator, _InputIterator);</span><br><span class="line">  __advance(__i, __n, <span class="built_in">iterator_category</span>(__i));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//............................整组distance函数........................................</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function">	<span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __distance(first, last,</span><br><span class="line">			std::iterator_traits&lt;InputIterator&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">	_distance(InputIterator first,InpuetIterator，input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">    	++first;</span><br><span class="line">		++n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIterator&gt;::difference_type </span><br><span class="line">        __distance(InputIterator first, InputIterator last, </span><br><span class="line">		std::random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的<code>advan</code>函数<strong><em>如果</em></strong>不加第三个参数，因为型别都未定，<strong>是实打实的<code>template</code>，不是重载函数，如下：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_II</span><span class="params">(InputIterator&amp; __i, _Distance __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectinalIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_BI</span><span class="params">(BidirectinalIterator&amp; __i, _Distance __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance_RI</span><span class="params">(RandomAccessIterator&amp; __i, _Distance __n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们调用的时候，如果选错使用<code>advance_II</code>来进行<code>advance_RI</code>的工作内容，则原本的O(1)时间复杂度就变成了O(n)，<strong>因此在源码中通过增加五个结构体，来给这些函数增加第三个确定的参数形成重载机制，在编译时能够使用重载确定调用哪一个版本，容错率高</strong>。<code>distance</code>函数也是这样的思想。这是一个值得借鉴的模板编写方式！</p>
<h4 id="序列式容器">4. 序列式容器</h4>
<p>序列式容器当中的元素都可序，但未必一定有序，全看编程者的操作。C++语言本身带有<code>array</code>，STL提供<code>vector、list、deque、stack、queue、priority_queue</code>等序列容器。由于<code>stack\queue</code>只是将<code>deque</code>改头换面而成，技术上被归为配接器。</p>
<h5 id="vector">4.1 vector</h5>
<p>在<code>vector</code>中最关键的在于器对大小的控制以及重新配置时数据的移动效率。这些在后面会介绍到，这里我们先对<code>vector</code>的源码进行简单介绍： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T			value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;		<span class="comment">//这个说明了迭代器就是普通指针</span></span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> 		size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> 	difference_type;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//Simple_alloc时SGI STL的空间配置器，</span></span><br><span class="line">	<span class="comment">//虽然vector使用了缺省的配置器,但Simple_alloc更方便以元素大小为配置单元</span></span><br><span class="line">	<span class="keyword">typedef</span> Simple_alloc&lt;value_type,Alloc&gt;data_allocator;</span><br><span class="line">	iterator start;						<span class="comment">//表示目前使用空间的头</span></span><br><span class="line">	iterator finissh;					<span class="comment">//表示目前使用空间的尾</span></span><br><span class="line">	iterator end_of_storage;			<span class="comment">//表示目前可用空间的尾</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_aux</span><span class="params">(iterator position,<span class="type">const</span> T&amp;x)</span></span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...<span class="comment">//一些操作接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 因为<code>vector</code>维护的一个连续空间，所有不论元素型别为哪一种，普通指针都可以作为<code>vector</code>的迭代器而满足所有必要条件，因为像<code>operator*,-&gt;,++,--,+,-,+=,-+</code>这些操作，普通的指针天生就具备。也就是说普通指针就是<code>RandomAccessIterator</code>，支持随机存取。</p>
<h6 id="扩容机制">4.1.1 扩容机制</h6>
<p>在不同的STL版本中，vector的扩容策略不相同，msvc编译器每次是以1.5倍且向下取整的策略进行扩容，gcc编译器则是SGI版本，每次以2.0倍的策略进行扩容。下图时MSVC中的扩容机制 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MSVC</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">34</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(n);</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;size:&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot;  capacity:&quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">size:<span class="number">1</span>  capacity:<span class="number">1</span></span><br><span class="line">size:<span class="number">2</span>  capacity:<span class="number">2</span></span><br><span class="line">size:<span class="number">3</span>  capacity:<span class="number">3</span></span><br><span class="line">size:<span class="number">4</span>  capacity:<span class="number">4</span></span><br><span class="line">size:<span class="number">5</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">6</span>  capacity:<span class="number">6</span></span><br><span class="line">size:<span class="number">7</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">8</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">9</span>  capacity:<span class="number">9</span></span><br><span class="line">size:<span class="number">10</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">11</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">12</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">13</span>  capacity:<span class="number">13</span></span><br><span class="line">size:<span class="number">14</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">15</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">16</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">17</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">18</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">19</span>  capacity:<span class="number">19</span></span><br><span class="line">size:<span class="number">20</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">21</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">22</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">23</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">24</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">25</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">26</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">27</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">28</span>  capacity:<span class="number">28</span></span><br><span class="line">size:<span class="number">29</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">30</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">31</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">32</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">33</span>  capacity:<span class="number">42</span></span><br><span class="line">size:<span class="number">34</span>  capacity:<span class="number">42</span></span><br></pre></td></tr></table></figure></p>
<p>所谓的动态增加，并不是在原空间之后接续新空间，因为无法保证原空间之后尚有可供配置的空间，二是以原来的2倍或1.5倍另外配置一块较大空间，然后将内容拷贝过来，然后才在原内容之后构造新元素，并释放原空间。因此对<code>vector</code>的任何操作若会影响到空间重新配置，指向<code>vector</code>的所有迭代器就都失效了。</p>
<h5 id="list">4.2 list</h5>
<p>相较于<code>vector</code>的连续线性空间，list就比较复杂，它的好处就是每次插入或删除元素，才配置或释放一个元素空间。<strong><code>list</code>是一个双向链表，它不再能够像<code>vector</code>一样以</strong>普通指针<strong>作为迭代器，因为其节点不保证再空间中连续存在，<code>list</code>迭代器必须有能指向<code>list</code>的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。</strong></p>
<h6 id="list的迭代器">4.2.1 list的迭代器</h6>
<p><strong><code>list</code>的迭代器的要求:</strong></p>
<ul>
<li>迭代器必须具备前移、后移的能力，因此对<code>list</code>提供的是<code>BidirectinalIterator</code></li>
<li>与vector不同，不论是何时的插入操作和删除操作、接合操作都不会造成原因的<code>list</code>迭代器失效</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	link_type node; <span class="comment">//迭代器内部需要一个普通指针，指向list的节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//constructor</span></span><br><span class="line">	__list_iterator(link_type x):<span class="built_in">node</span>(x)&#123;&#125;</span><br><span class="line">	__list_iterator()&#123;&#125;</span><br><span class="line">	__list_iterator(<span class="type">const</span> iterator&amp; x):<span class="built_in">node</span>(x.node)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node==x.node;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> node!=x.node;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以下对迭代器取值，取的是节点的数据值</span></span><br><span class="line">	reference <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对迭代器累加</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">		node=(link_type)((*node).next);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">		self tmp=*<span class="keyword">this</span>;</span><br><span class="line">		++*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对迭代器减1</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">		node=(link_type)((*node).prev);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">		self tmp=*<span class="keyword">this</span>;</span><br><span class="line">		--*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="list的数据结构">4.2.2 list的数据结构</h6>
<p><code>list</code>是一个<strong>双向环形链表</strong>，所有它只需要一个指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> _list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	link_type node;		<span class="comment">//只需一个指针</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="deque">4.3 deque</h5>
<p><strong><code>deque</code>是一种双向开口的连续线性空间，即指能在头尾两端都支持元素的插入和删除</strong> <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/deque.png" width="500"> <code>vector</code>虽然也能支持在头尾两端进行操作，但是效率奇差，无法接受，因为在头部的插入导致后面所有元素都要后移。而<code>deque</code>则不会：</p>
<ul>
<li><code>duque</code>允许时间复杂度<code>O(1)</code>对其头端进行元素的插入和移除，<code>vector</code>为<code>O(n)</code></li>
<li><code>deque</code>没有所谓的容量概念，因为它是动态地以连续空间组合而成，随时可以增加一段新的空间并链接起来，即不会发生如<code>vector</code>那样的空间重新配置机制</li>
<li>虽然<code>deque</code>也提供<code>RandomAccessIterator</code>，但它的迭代器并不是普通指针，其复杂度和<code>vector</code>不可同道里计，因此除非必要我们应该尽量选择<code>vector</code>而不是<code>deque</code>。</li>
<li>在对<code>deque</code>进行排序操作，为了最高效率，可将<code>deque</code>先完整复制到一个<code>vector</code>身上，将<code>vector</code>排序后再复制会<code>deque</code></li>
</ul>
<h6 id="deque的中控器">4.3.1 deque的中控器</h6>
<p><code>deque</code>是逻辑上是连续空间。<code>deque</code>系由一段一段的定量空间组成，一旦必要在<code>deque</code>的前端或尾增加空间，便配置一段定量连续空间，串接在整个<code>deque</code>的头端或尾端。因此对于<code>deque</code>容器来说必须维护其整体连续的假象，并提供随机存取接口，那么必须有中央控制器和复杂的迭代架构去实现。</p>
<p><strong><code>Deque</code>采取一块所谓的<code>map</code>(注意，不是STL的map容器)作为主控，这里所谓的<code>map</code>是一小块连续的内存空间，其中每一个元素(此处成为一个结点<code>node</code>)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是<code>deque</code>的存储空间的主体。</strong><code>SGI STL</code>允许我们指定缓冲区大小，默认使用<code>512bytes</code>(<code>map</code>其实就是二重指针<code>T**</code>) <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dequemap.png" width="500"></p>
<h6 id="deque的迭代器">4.3.2 deque的迭代器</h6>
<p>对于<code>deque</code>，维持其整体连续的假象，落在了迭代器的<code>operator++</code>和<code>operator--</code>两个重载运算符上。</p>
<ul>
<li>该迭代器必须能够指出分段连续空间在哪里</li>
<li>其次他必须能够判断自己是否已经处在其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃到下一个或上一个缓冲区。</li>
</ul>
<p>因此为了能够正确跳跃，<code>deque</code>必须随时掌握管控中心<code>map</code>。如下的实现方式可行: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">Ptr</span>,<span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span>&#123; <span class="comment">//为继承 std::iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;,T*,Bufsize&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,<span class="type">const</span> T&amp;,<span class="type">const</span> T*,Bufsize&gt; const_iterator;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> __deque_buf_size(Bufsize,<span class="built_in">sizeof</span>(T));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未继承std::iterator,所以必须自行撰写下述五个必要的迭代器相应型别</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref renference; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持与容器的联结</span></span><br><span class="line">    T* cur; <span class="comment">//此迭代器所指之缓冲区中的现行(current)元素</span></span><br><span class="line">    T* first; <span class="comment">//此迭代器所指之缓冲区中的头</span></span><br><span class="line">    T* last; <span class="comment">//此迭代器所指之缓冲区中的尾(含备用空间)</span></span><br><span class="line">    map_pointer node; <span class="comment">//指向管控中心</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n,<span class="type">size_t</span> sz)&#123;</span><br><span class="line">        <span class="keyword">return</span> n!=<span class="number">0</span>? n:(sz&lt;<span class="number">512</span>? <span class="built_in">size_t</span>(<span class="number">512</span>/sz):<span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    n!=0,返回n，表示buffer_size由	用户自定义</span></span><br><span class="line"><span class="comment">    n=0,表示buffer_size使用默认值，那么：</span></span><br><span class="line"><span class="comment">        sz&lt;512,传回512/sz;</span></span><br><span class="line"><span class="comment">        sz&gt;=512,传回1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/dequeiterator.png" width="700"> 如上图，假设我们产生一个元素类型未<code>int</code>,缓冲区为8的<code>deque</code>，经过增删操作后拥有20个元素。<strong><code>deque</code>类内的<code>start</code>和<code>finish</code>分别指向<code>deque</code>的第一个缓冲区和最后一个缓冲区，20/8=3，所以map拥有3个节点，且最后一个缓冲区还有插入元素的空间。</strong>三个指针<code>cur、first、last</code>分别如图所示，`cur·指向缓冲区的最后一个元素的下一个位置。</p>
<p>下面是deque几个重要操作： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span></span>&#123;</span><br><span class="line">	node=new_node;</span><br><span class="line">    first=*new_node;</span><br><span class="line">    last=first+<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">renference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> *cur;&#125;</span><br><span class="line"></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line"></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())*</span><br><span class="line">		(node-x.node<span class="number">-1</span>)+(cur-first)+(x.last-x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">    ++cur; <span class="comment">//切换下一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(cur==last)&#123; <span class="comment">//如果已达到所在缓冲区的尾端</span></span><br><span class="line">        <span class="built_in">set_node</span>(node+<span class="number">1</span>); <span class="comment">//利用set_node方法切换到下一个缓冲区</span></span><br><span class="line">        cur=first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>; <span class="comment">//调用operator++</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==first)&#123; <span class="comment">//如果达到缓冲区的头部</span></span><br><span class="line">        <span class="built_in">set_node</span>(node<span class="number">-1</span>); <span class="comment">//利用set_node方法切换到上一个缓冲区</span></span><br><span class="line">        cur=first;</span><br><span class="line">    &#125;</span><br><span class="line">    --cur;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>; <span class="comment">//调用operator--</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)&#123; <span class="comment">//实现随机存取、迭代器可以直接跳跃n个距离</span></span><br><span class="line">    difference_type offset=n+(cur-first);</span><br><span class="line">    <span class="keyword">if</span>(offset&gt;=<span class="number">0</span>&amp;&amp;offset&lt;<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) <span class="comment">//目标位置在统一缓冲区</span></span><br><span class="line">        cur+=n;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//目标位置不在统一缓冲区</span></span><br><span class="line">       		difference_type node_offset=offset&gt;<span class="number">0</span>?</span><br><span class="line">			offset/<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">				:-<span class="built_in">difference_type</span>((-offset<span class="number">-1</span>)/<span class="built_in">buffer_size</span>())<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">set_node</span>(node+node_offset); <span class="comment">//切换至正确的节点</span></span><br><span class="line">            cur=first+(offset-node_offset*<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()); <span class="comment">//切换至正确的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp+=n; <span class="comment">//调用operator+=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>+=-n;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self temp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp-=n; <span class="comment">//调用operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机存取第n个元素</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n)<span class="type">const</span> &#123;<span class="keyword">return</span> *(*<span class="keyword">this</span>+n);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> cur==x.cur;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;<span class="keyword">return</span> !(*<span class="keyword">this</span>==x);&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="built_in">return</span> (node==x.node)?(cur&lt;x.cur):(node&lt;x.node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="deque的数据结构">4.3.3 deque的数据结构</h6>
<p>deque除了维护<code>map</code>指针外，还必须维护<code>start、finish</code>两个迭代器，分别指向第一个缓冲区的第一个元素和最后一个缓冲区的额最后一个元素。此外，它当然也必须记住目前的map大小，因为一旦<code>map</code>所提供的节点不足，就必须重新配置更大的一块<code>map</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc,<span class="type">size_t</span> BufSiz=<span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T,T&amp;,T*,BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//元素的指针的指针</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start; <span class="comment">//表示第一个节点</span></span><br><span class="line">    iterator finish; <span class="comment">//表示最后一个节点</span></span><br><span class="line">    map_pointer map; <span class="comment">//指向map，map是块连续空间，其每个元素都是指针，指向一个节点</span></span><br><span class="line">    size_type map_size; <span class="comment">//map内有多个指针</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> finish;&#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n)&#123;</span><br><span class="line">        <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">//调用operator[]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *start;&#125; <span class="comment">//调用operator*</span></span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        iterator temp=finish;</span><br><span class="line">        --temp; <span class="comment">//调用operator--</span></span><br><span class="line">        <span class="keyword">return</span> *temp; <span class="comment">//调用operator*</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> finish-start;&#125; <span class="comment">//调用operator-</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> finish==start;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="heap">4.5. heap</h5>
<p><code>heap</code>不属于STL的容器组件，但我们有必要认识它的实现思想，它是实现<code>priority queue</code>的助手。<code>priority queue</code>允许用户以任何次序将元素存入容器中，但是取出时一定时从优先权最高的元素开始取。而堆正有这样的特性，适合作为<code>priority queue</code>的底层机制。</p>
<p>对于heap的虽然讲解的时候用的是<strong>完全二叉树</strong>的形式来讲解，但只是为了更直观的表达而已，一般来说实现都是采用数组的形式来实现的，同时为了达到空间可增长，采用<code>vector+heap算法</code>来实现堆。</p>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/heapSort.gif" width="500"></p>
<h6 id="push_heap算法">4.5.1 push_heap算法</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意，此函式被调用时，新元素已置于底部容器的最尾端</span></span><br><span class="line">    __push_heap_aux(first, last, <span class="built_in">distance_type</span>(first),<span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap_aux</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last, Distance*, T*)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>),<span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">    <span class="comment">// 以上系根据implicit representation heap的结构特性：新值必置于底部</span></span><br><span class="line">    <span class="comment">// 容器的最尾端，此即第一个洞号：(last-first)–1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 push_back()不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __push_heap(RandomAccessIterator first, Distance holeIndex,Distance topIndex, T value) </span><br><span class="line">&#123;</span><br><span class="line">    Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 找出父节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value) &#123;</span><br><span class="line">        <span class="comment">// 当尚未到达顶端，且父节点小于新值（于是不符合 heap 的次序特性）</span></span><br><span class="line">        <span class="comment">// 由于以㆖使用 operator&lt;，可知 STL heap 是一种 max-heap（大者为父）</span></span><br><span class="line">        *(first + holeIndex) = *(first + parent); <span class="comment">//令洞值为父值</span></span><br><span class="line">        holeIndex = parent; <span class="comment">// percolate up：调整洞号，向上提升至父节点</span></span><br><span class="line">        parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 新洞的父节点</span></span><br><span class="line">    &#125; <span class="comment">// 持续至顶端，或满足heap的次序特性为止</span></span><br><span class="line">    </span><br><span class="line">    *(first + holeIndex) = value; <span class="comment">//令洞值为新值，完成插入动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="pop_heap算法">4.5.2 pop_heap算法</h6>
<p><strong><code>pop_heap</code>算法思路如下：</strong></p>
<ul>
<li>1.把根节点元素取出，把最后一个节点的元素取出</li>
<li>2.将原根节点元素放在vector的最后一个节点处</li>
<li>3.将原先的最后一个节点的元素放置到原根节点处作为新根节点</li>
<li>4.将新根节点逐个与子节点比较，直到其值比子节点都大时，结束算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __pop_heap_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap_aux(RandomAccessIterator first,RandomAccessIterator last, T*) </span><br><span class="line">&#123;</span><br><span class="line">    __pop_heap(first, last<span class="number">-1</span>, last<span class="number">-1</span>, <span class="built_in">T</span>(*(last<span class="number">-1</span>)),</span><br><span class="line">    <span class="built_in">distance_type</span>(first));</span><br><span class="line">    <span class="comment">// 以上，根据 implicit representation heap 的次序特性，pop操作的结果</span></span><br><span class="line">    <span class="comment">// 应为底部容器的第一个元素。因此，首先设定欲调整值为尾值，然后将首值调至</span></span><br><span class="line">    <span class="comment">// 尾节点（所以以上将迭代器 result设为 last-1）。然后重整 [first, last-1)，</span></span><br><span class="line">    <span class="comment">// 使之重新成一个合格的 heap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 pop_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap(RandomAccessIterator first,</span><br><span class="line">        RandomAccessIterator last,</span><br><span class="line">        RandomAccessIterator result,</span><br><span class="line">        T value, Distance*) </span><br><span class="line">&#123;</span><br><span class="line">    *result = *first; <span class="comment">// 设定尾值为首值，于是尾值即为欲求结果，</span></span><br><span class="line">                      <span class="comment">// 可由客端稍后再以底层容器之 pop_back() 取出尾值</span></span><br><span class="line"> </span><br><span class="line">    __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">    <span class="comment">// 以上欲重新调整 heap，洞号为 0（亦即树根处），欲调整值为 value（原尾值）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="sort_heap算法">4.5.3 sort_heap算法</h6>
<p>既然每次<code>pop_heap</code>可获得<code>heap</code>之中键值最大的元素，如果持续对整个<code>heap</code>做<code>pop_heap</code>动作，每次将操作范围从后向前缩减一个元素（因为pop_heap会把键值最大的元素放在底部容器的最尾端），当整个程序执行完毕，我们便有了一个递增序列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [first,last) 排列为一个heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first,RandomAccessIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 make_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first,RandomAccessIterator last, T*,Distance*) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//如果长度为0或1，不必重新排列</span></span><br><span class="line"> </span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    <span class="comment">// 找出第一个需要重排的子树头部，以parent标示出。由于任何叶节点都不需执行</span></span><br><span class="line">    <span class="comment">// perlocate down，所以有以下计算。parent命名不佳，名为holeIndex 更好</span></span><br><span class="line">    Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 重排以 parent 为首的子树。len是为了让__adjust_heap() 判断操作范围</span></span><br><span class="line">        __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 走完根节点，就结束。</span></span><br><span class="line">        parent--; <span class="comment">// （即将重排之子树的）头部向前一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="priority_queue">4.6 priority_queue</h5>
<p><code>priority_queue</code>是一个拥有权值观念的<code>queue</code>。其内部的元素不再像<code>queue</code>依照被存入的次序排列，而是按照元素的权值排列，权值最高者，排在最前面。缺省情况下<code>proority_queue</code>利用一个<code>max-heap</code>和<code>vector</code>为底部容器。<code>priority_queue</code>没有迭代器(<code>queue</code>和<code>stack</code>也没有) <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/priorityqueue.png" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;,</span><br><span class="line">    <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line">    Compare comp; <span class="comment">// 元素大小比较标准</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : c(), comp(x) &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以下用到的 make_heap(), push_heap(), pop_heap()都是泛型算法</span></span><br><span class="line">    <span class="comment">// 注意，任一个建构式都立刻于底层容器内产生一个 implicit representation heap</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; x)</span><br><span class="line">        : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(),comp); &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last)</span><br><span class="line">        : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        __STL_TRY &#123;</span><br><span class="line">            <span class="comment">// push_heap是泛型算法，先利用底层容器的 push_back() 将新元素推入末端，再重排heap</span></span><br><span class="line">            c.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); <span class="comment">//push_heap是泛型算法</span></span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        __STL_TRY &#123;</span><br><span class="line">            <span class="comment">//pop_heap 是泛型算法，从 heap 内取出一个元素。它并不是真正将元素</span></span><br><span class="line">            <span class="comment">//弹出，而是重排 heap，然后再以底层容器的 pop_back() 取得被弹出的元素</span></span><br><span class="line">            <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">            c.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="关联式容器">5. 关联式容器</h4>
<p>标准的STL关联式容器分为<code>set</code>集合和<code>map</code>映射表两大类。以及两大衍生体<code>multiset</code>和<code>multimap</code>。这些容器的底层机制均与<code>RB-tree</code>完成。红黑树是一个独立容器，但不对外界使用。同时<code>SGI STL</code>还提供了一个不在标准规则之外的管理容器<code>hash_table</code>，以及以<code>hash_table</code>为底层机制完成的<code>hash_set、hash_map、hash_multiset、hash_multimap</code>。</p>
<p>所谓关联式容器类似于关联式数据库：每笔数据都有一个键值和一个实值，当元素插入到关联式容器时会按照键值大小以某种规则将这个元素放置于合适的位置，因此对于关联式容器没有<code>push_back、push_front、pop_back、pop_front</code>这样的行为。</p>
<h5 id="rb-tree">5.1 RB-tree</h5>
<p>关于红黑树的的定义和一些平衡原理见<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构篇</a>，这里列举一些<code>SGI STL</code>的<code>RB-tree</code>源码。</p>
<h6 id="rb-tree结构体">5.1.1 RB-tree结构体</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">RB树的节点结构:</span><br><span class="line"><span class="comment">//由于红黑树的各种操作常需要上溯其父级节点，因此特别安排一个parent指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;     <span class="comment">// 红色为0</span></span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">  color_type color;     <span class="comment">// 节点颜色，红色或黑色</span></span><br><span class="line">  base_ptr parent;      <span class="comment">// 该指针指向其父节点</span></span><br><span class="line">  base_ptr left;        <span class="comment">// 指向左节点</span></span><br><span class="line">  base_ptr right;       <span class="comment">// 指向右节点</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	 <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left; <span class="comment">//一直向左走，找到最小值</span></span><br><span class="line">	 <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right; <span class="comment">//一直向右走，找到最大值</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node</span> : <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;   <span class="comment">//节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="rb-tree迭代器">5.1.2 RB-tree迭代器</h6>
<p><code>RB-tree</code>的迭代器属于双向迭代器，但不具备随机定位的能力，与<code>list</code>较为相似，比较特殊的是他具有前进和后退的操作。<code>RB-tree</code>迭代器的<code>operator++</code>是调用了基层迭代器的<code>increment()</code>函数，其<code>operator--</code>调用<code>decrement()</code>函数。 <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/rbtreeiterator.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基层迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_tree_base_iterator</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	base_ptr node; <span class="comment">//用来与容器之间产生一个连接的关系</span></span><br><span class="line">	<span class="comment">//实现operator++</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(node-&gt;right != <span class="number">0</span>)&#123;</span><br><span class="line">	        <span class="comment">//状况1：右子结点存在，则当前可以看成是根节点,则找出右子树的最左结点</span></span><br><span class="line">	        node = node-&gt;right;</span><br><span class="line">	        <span class="keyword">while</span>(node-&gt;left != <span class="number">0</span>)</span><br><span class="line">	            node = node-&gt;left;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">	        <span class="comment">//状况2：没有右子节点,找出父节点</span></span><br><span class="line">			<span class="comment">//如果现行节点本身是个右子节点，就一直上溯，直到不为右子节点为止</span></span><br><span class="line">	        base_ptr y = node-&gt;parent;</span><br><span class="line">	        <span class="keyword">while</span>(y-&gt;right == node)&#123;</span><br><span class="line">	            node = y;</span><br><span class="line">	            y = y-&gt;parent;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">if</span>(node-&gt;right != y)</span><br><span class="line">	            <span class="comment">//状况3：如果当前的node不是根节点，则y即为所求</span></span><br><span class="line">	            node = y;</span><br><span class="line">	        <span class="comment">//状况4：如果当前的node是根节点，则node为所求</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//实现--</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(node-&gt;color == rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)</span><br><span class="line">	        <span class="comment">//状况1：如果当前结点是header结点，那么其前驱应该是mostright结点，也就是其右子结点</span></span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//状况2：也就是当前是根节点，那么其前驱应该是左子树中最右结点</span></span><br><span class="line">                base_ptr y = node-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(y-&gt;right != <span class="number">0</span>)</span><br><span class="line">                    y = y-&gt;right;</span><br><span class="line">                node = y;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//状况3：如果当前不是根节点，也没有左子节点，那么当前处于右子树的最左结点，要去找根节点</span></span><br><span class="line">                base_ptr y = node-&gt;parent;</span><br><span class="line">                <span class="keyword">while</span>(y-&gt;left == node)</span><br><span class="line">				&#123;</span><br><span class="line">                    node = y;</span><br><span class="line">                    y = y-&gt;parent;</span><br><span class="line">                &#125;</span><br><span class="line">                node = y;</span><br><span class="line">                <span class="comment">//如果当前处于root结点，y则为header结点，那么当前必定只有root一个结点</span></span><br><span class="line">                <span class="comment">//则可以得到node = header，y = root</span></span><br><span class="line">                <span class="comment">//最终得到node = y，不需要特殊处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正规迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value,<span class="keyword">typename</span> Ref,<span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_tree_iterator</span>:<span class="keyword">public</span> rb_tree_base_iterator&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,Value&amp;,Value*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,<span class="type">const</span> Value&amp;,<span class="type">const</span> Vallue*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_iterator&lt;Value,Ref,Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>(link_type x)&#123;node = x&#125;;</span><br><span class="line">	<span class="built_in">rb_tree_iterator</span>(<span class="type">const</span> iterator&amp; it)&#123;node = it.node&#125;;</span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="built_in">link_type</span>(node)-&gt;value_field;</span><br><span class="line">	&#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">	    <span class="built_in">increment</span>();</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    <span class="built_in">increment</span>();</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	    <span class="built_in">decrement</span>();</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--()&#123;</span><br><span class="line">	    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	    <span class="built_in">decrement</span>();</span><br><span class="line">	    <span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="rb-tree的数据结构">5.1.3 RB-tree的数据结构</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------------rb_tree类---------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rb_tree</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node,Alloc&gt;rb_tree_node_allocator;</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//没有迭代器iterator?不！会在后面声明</span></span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">link_type <span class="title">get_node</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">allocate</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span></span>&#123;<span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">deallocate</span>(p);&#125;</span><br><span class="line">    <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        link_type tmp = <span class="built_in">get_node</span>(); <span class="comment">//配置空间</span></span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            Chy::allocator&lt;Key&gt;::<span class="built_in">construct</span>(&amp;tmp-&gt;value_field,x);<span class="comment">//构造内容</span></span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(<span class="built_in">put_node</span>(tmp));</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span></span>&#123;<span class="comment">//复制一个节点的颜色和数值</span></span><br><span class="line">        link_type tmp = <span class="built_in">create_node</span>(x-&gt;value_field);</span><br><span class="line">        tmp-&gt;color = x-&gt;color;</span><br><span class="line">        tmp-&gt;left = <span class="number">0</span>;</span><br><span class="line">        tmp-&gt;right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span></span>&#123;</span><br><span class="line">        Chy::allocator&lt;Key&gt;::<span class="built_in">destroy</span>(&amp;p-&gt;value_field); <span class="comment">//析构内容</span></span><br><span class="line">        <span class="built_in">put_node</span>(p); <span class="comment">//释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//RB-tree只使用三笔数据表现</span></span><br><span class="line">    size_type node_count; <span class="comment">//追踪记录树的大小 (节点的数量)</span></span><br><span class="line">    link_type header;     <span class="comment">//实现上的小技巧</span></span><br><span class="line">    Compare key_compare;  <span class="comment">//节点之间的键值大小的比较准则. 应该会是一个function object</span></span><br><span class="line">    <span class="comment">//以下三个函数用于方便获取header的成员</span></span><br><span class="line">    <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;parent;&#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">left_most</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;left;&#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">right_most</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> (link_type&amp;)header-&gt;right;&#125;</span><br><span class="line">    <span class="comment">//以下六个函数用于方便获得节点x的成员</span></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;left;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;right;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span>(link_type&amp;)x-&gt;parent;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span> x-&gt;value_field;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x));&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span></span>&#123;<span class="keyword">return</span> (color_type&amp;) (x-&gt;color);&#125;</span><br><span class="line">    <span class="comment">//获取极大值和极小值 node class有实现此功能</span></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type,reference,pointer&gt;iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    iterator __insert(base_ptr x,base_ptr y,<span class="type">const</span> value_type&amp; v);</span><br><span class="line">    link_type __copy(link_type x,link_type p);</span><br><span class="line">    <span class="type">void</span> __erase(link_type x);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">            __erase(<span class="built_in">root</span>());</span><br><span class="line">            <span class="built_in">left_most</span>() = header;</span><br><span class="line">            <span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">right_most</span>() = header;</span><br><span class="line">            node_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        header = <span class="built_in">get_node</span>(); <span class="comment">//产生一个节点空间 令header指向它</span></span><br><span class="line">        <span class="built_in">color</span>(header) = __rb_tree_red;<span class="comment">//令header为红色 用于区分header和root,在iterator的operator++中</span></span><br><span class="line">        <span class="built_in">root</span>() == <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">left_most</span>() = header;   <span class="comment">//令header的左子节点等于自己</span></span><br><span class="line">        <span class="built_in">right_most</span>() = header;  <span class="comment">//令header的右子节点等于自己</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//allocation / deallocation</span></span><br><span class="line">    <span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">            : <span class="built_in">node_count</span>(<span class="number">0</span>),<span class="built_in">key_compare</span>(comp)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">rb_tree</span>()&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">put_node</span>(header);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp;<span class="keyword">operator</span>==(<span class="type">const</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;&amp;x);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> key_compare;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">left_most</span>();&#125; <span class="comment">//RB树的起头为最左(最小)节点处</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> header;&#125; <span class="comment">//RB树的终点为header所指处</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> node_count == <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> node_count;&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">size_type</span> (<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//insert/erase</span></span><br><span class="line">    <span class="comment">//将x插入到RB-Tree中 (保持节点的独一无二)</span></span><br><span class="line">    <span class="function">std::pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//将x插入到RB-Tree中 (允许节点数值重复)</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//寻找键值为k的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> value_type&amp; k)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------rb_tree类主要函数的实现--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新的数值 节点键值允许重复</span></span><br><span class="line"><span class="comment">//注意：返回的是一个RB-Tree的迭代器，指向的是新增的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//根节点开始</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;        <span class="comment">//根节点开始 从上往下寻找适当的插入节点</span></span><br><span class="line">        y = x;</span><br><span class="line">        <span class="comment">//如果当前根节点比 输入的v大，则转向左边，否则转向右边</span></span><br><span class="line">        x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x为新值插入点 y为插入点的父节点 v为新值</span></span><br><span class="line">    <span class="keyword">return</span> __insert(x,y,v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入新的数值 节点键值不允许重复</span></span><br><span class="line"><span class="comment">//注意：返回结果是pair类型，第一个元素是一个RB-Tree的迭代器，指向的是新增的节点；第二个参数表示插入成功与否</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">std::pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator,<span class="type">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//从根节点开始</span></span><br><span class="line">    <span class="type">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123; <span class="comment">//从根节点开始 往下寻找适当的插入点</span></span><br><span class="line">        y = x;</span><br><span class="line">        comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)); <span class="comment">//v键值小于目前节点的键值</span></span><br><span class="line">        x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x); <span class="comment">//遇&quot;大&quot;则向左 遇&quot;小&quot;则向右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//离开while循环之后 y所指的即 插入点之父节点（此时它必为叶子结点）</span></span><br><span class="line">    iterator j = <span class="built_in">iterator</span>(y); <span class="comment">//迭代器j指向插入点的父节点y</span></span><br><span class="line">    <span class="keyword">if</span> (comp)&#123;</span><br><span class="line">        <span class="comment">//如果while循环时候，判定comp的数值，如果comp为真(表示遇到大的元素，将插入左侧)</span></span><br><span class="line">        <span class="comment">//如果插入节点的父节点是最左侧的节点</span></span><br><span class="line">        <span class="comment">//x为插入点，y为插入节点的父节点，v表示新值</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">begin</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(__insert(x,y,v), <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//插入节点的父节点不是最左侧的节点</span></span><br><span class="line">            <span class="comment">//调整j 回头准备测试</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node),<span class="built_in">KeyOfValue</span>()(v)))&#123;</span><br><span class="line">            <span class="comment">//小于新值（表示遇到小的数值，将插在右侧）</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(__insert(x,y,v), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此 表示新值一定和树中的键值重复 就不应该插入新的数值</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//真正的插入执行程序 __insert()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::__insert(base_ptr x_, base_ptr y_, <span class="type">const</span> value_type &amp;v) &#123;</span><br><span class="line">    <span class="comment">//参数x_为新的插入点 参数y_为插入点的父节点 参数v为新值</span></span><br><span class="line">    link_type x = (link_type)x_;</span><br><span class="line">    link_type y = (link_type)y_;</span><br><span class="line">    link_type z ;</span><br><span class="line">    <span class="comment">//key_compare 是键值大小的比较准则，应该是一个function object</span></span><br><span class="line">    <span class="keyword">if</span> (y == header||x != <span class="number">0</span>||<span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v),<span class="built_in">key</span>(x)))&#123;</span><br><span class="line">        z = <span class="built_in">create_node</span>(v); <span class="comment">//产生一个新的节点</span></span><br><span class="line">        <span class="comment">//当y即为header的时候，leftmost = z;</span></span><br><span class="line">        <span class="keyword">if</span> (y == header)&#123;</span><br><span class="line">            <span class="built_in">root</span>() = z;</span><br><span class="line">            <span class="built_in">right_most</span>() = z;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">left_most</span>())&#123;</span><br><span class="line">            <span class="comment">//y为最左节点</span></span><br><span class="line">            <span class="comment">//维护leftmost() 使其永远指向最左节点</span></span><br><span class="line">            <span class="built_in">left_most</span>() = z;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            z = <span class="built_in">create_node</span>(v);<span class="comment">//产生一个新的节点</span></span><br><span class="line">            <span class="comment">//让新节成为插入点的父节点y的右子节点</span></span><br><span class="line">            <span class="built_in">right</span>(y) = z;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="built_in">right_most</span>())&#123; <span class="comment">//维护rightmost()让其永远指向最右的节点</span></span><br><span class="line">                <span class="built_in">right_most</span>() = z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">parent</span>(z) = y; <span class="comment">//设定新节点的父节点</span></span><br><span class="line">        <span class="built_in">left</span>(z) = <span class="number">0</span>; <span class="comment">//设定新节点的左子节点</span></span><br><span class="line">        <span class="built_in">right</span>(z) = <span class="number">0</span>; <span class="comment">//设定新节点的右子节点</span></span><br><span class="line">        <span class="comment">//修改颜色</span></span><br><span class="line">        <span class="comment">//参数一为新增节点 ；参数二 为root</span></span><br><span class="line">        __rb_tree_rebalance(z,header-&gt;parent);</span><br><span class="line">        ++node_count;</span><br><span class="line">        <span class="comment">//返回一个迭代器 指向新的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必须为红色，如果插入出父节点同样为红色，就需要进行树形旋转</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_rotate_left(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    <span class="comment">//x为旋转点</span></span><br><span class="line">    __rb_tree_node_base* y = x-&gt;right;<span class="comment">//令y为旋转点的右子节点</span></span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//回马枪设定父亲节点</span></span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="comment">//令y完全替代x的地位 (需要将x对其父节点的关系完全接收回来)</span></span><br><span class="line">    <span class="keyword">if</span> (x == root)&#123;</span><br><span class="line">        root = y; <span class="comment">//x为根节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;  <span class="comment">//x为其父节点的左子节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y; <span class="comment">//x为其父节点的右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必须为红色，如果插入出父节点同样为红色，就需要进行树形旋转</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_rotate_right(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    <span class="comment">//x为旋转点</span></span><br><span class="line">    __rb_tree_node_base* y = x-&gt;left; <span class="comment">//y为旋转点的左子节点</span></span><br><span class="line">    x-&gt;left = y-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;right != <span class="number">0</span>)&#123;</span><br><span class="line">        y-&gt;right-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="comment">//令y完全替代x的地位</span></span><br><span class="line">    <span class="keyword">if</span>(x == root)&#123;</span><br><span class="line">        root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//调整RB_tree 插入节点之后，需要进行调整(颜色/翻转)从而满足要求</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __rb_tree_balance(__rb_tree_node_base* x,__rb_tree_node_base*&amp; root)&#123;</span><br><span class="line">    x-&gt;color = __rb_tree_red; <span class="comment">//新节点的颜色必须是红色的</span></span><br><span class="line">    <span class="keyword">while</span>(x!=root &amp;&amp; x-&gt;parent-&gt;color == __rb_tree_red)&#123;</span><br><span class="line">        <span class="comment">//父节点为红色的</span></span><br><span class="line">        <span class="comment">//父节点为祖父节点的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left)&#123;</span><br><span class="line">            <span class="comment">//令y为伯父节点</span></span><br><span class="line">            __rb_tree_node_base* y = x-&gt;parent-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)&#123; <span class="comment">//伯父节点存在 且为红</span></span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//更改父节点的颜色为黑</span></span><br><span class="line">                y-&gt;color = __rb_tree_black;<span class="comment">//更改父节点的颜色为黑</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//更改祖父节点的颜色为红</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无伯父节点 或者伯父节点的颜色为黑</span></span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)&#123;</span><br><span class="line">                    <span class="comment">//新节点为父节点的右子节点</span></span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    <span class="comment">//第一次参数为左旋节点</span></span><br><span class="line">                    __rb_tree_rotate_left(x,root);</span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                <span class="comment">//第一次参数为右旋节点</span></span><br><span class="line">                __rb_tree_rotate_right(x-&gt;parent-&gt;parent,root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//父节点为祖父节点的右子节点</span></span><br><span class="line">            __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left; <span class="comment">//令y为伯父节点</span></span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red)&#123; <span class="comment">//存在伯父节点，且为红</span></span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//更改父节点为黑</span></span><br><span class="line">                y-&gt;color = __rb_tree_black;<span class="comment">//更改伯父节点为黑</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; <span class="comment">//更改祖父节点为红</span></span><br><span class="line">                x = x-&gt;parent-&gt;parent; <span class="comment">//准备继续往上层检查</span></span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无伯父节点 或者伯父节点 为黑</span></span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">                    <span class="comment">//新节点 为 父节点的左子节点</span></span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    __rb_tree_rotate_right(x,root); <span class="comment">//第一参数为右旋转点</span></span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                <span class="comment">//第一参数为左旋点</span></span><br><span class="line">                __rb_tree_rotate_left(x-&gt;parent-&gt;parent,root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//while结束</span></span><br><span class="line">    root-&gt;color = __rb_tree_black;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//元素查找程序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key,Value,KeyOfValue,Compare,Alloc&gt;::<span class="built_in">find</span>(<span class="type">const</span> value_type &amp;k) &#123;</span><br><span class="line">    link_type y = header; <span class="comment">//last node which is  not less than k</span></span><br><span class="line">    link_type x = <span class="built_in">root</span>(); <span class="comment">//current node</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//key_compare 是节点大小的比较准则 function object</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x),k))&#123;</span><br><span class="line">            <span class="comment">//进行到这里 表示x的数值大于k 。遇到大的数值向左走</span></span><br><span class="line">            y = x,x = <span class="built_in">left</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator j = <span class="built_in">iterator</span> (y);</span><br><span class="line">    <span class="keyword">return</span> (j == <span class="built_in">end</span>() || <span class="built_in">key_compare</span>(k,<span class="built_in">key</span>(j.node))) ? <span class="built_in">end</span>() : j;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/************************************************************************************************************************/</span></span><br><span class="line"><span class="comment">//注意：以下的identify定义于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">identify</span> : <span class="keyword">public</span> std::unary_function&lt;T,T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="set">5.2 set</h5>
<ul>
<li><code>set</code>的特性是 所有的元素会按照键值自动排序</li>
<li><code>set</code>的键值等同于实值</li>
<li><strong><code>set</code>不允许涵盖两个相同的键值</strong></li>
<li><strong>不可以通过迭代器修改<code>set</code>的元素数值，这会破坏元素的排列顺序。因此<code>set&lt;T&gt;::iterator</code>被定义为底层<code>RB-tree</code>的<code>const_iterator</code>,杜绝写入。也就是<code>set</code>的<code>iterators</code>是一种<code>const iterators</code></strong></li>
<li><code>set</code>类似<code>list</code>，当客户端对其进行元素的新增或者删除操作的时候，<strong>操作之前的迭代器不会失效，但是被操作的迭代器会失效</strong></li>
<li>STL提供了一组<code>set/multiset</code>的相关算法，包括交集<code>set_intersection</code><code>set_union</code><code>set_difference</code><code>set_symmetric_difference</code></li>
<li><code>set</code>利用<code>RB-tree</code>的排序机制，因此是基于红黑树进一步的函数封装</li>
</ul>
<h6 id="set源码">5.2.1 set源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> set&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">    <span class="comment">//注意key_compare 和 value_compre 使用同一个比较函数</span></span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,identify&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">    rep_type t; <span class="comment">//使用红黑树(RB-Tree)实现set</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">    <span class="comment">//set迭代器无法执行写入操作，因为set的元素有一定的次序安排，不允许用户在任意处进行写入操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_uterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    <span class="comment">//allocation/deallocation</span></span><br><span class="line">    <span class="comment">//set使用RB-Tree的insert_unique() 要求插入的元素都不可以重复</span></span><br><span class="line">    <span class="comment">//multiset 使用 insert_equal() 允许相同键值的存在</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">set</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(InputIterator first,InputIterator last)</span> : t(Compare())&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">set</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">set</span>(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x):<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">    set&lt;Key,Compare,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">        t = x.t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//set进行函数的包装</span></span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="comment">//需要注意 set使用的value_comp 事实上为RB-Tree的key_comp()</span></span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(set&lt;Key,Compare,Alloc&gt;&amp; x)</span></span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//insert / erase</span></span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;iterator,<span class="type">bool</span>&gt;pair_iterator_bool;</span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">        std::pair&lt;<span class="keyword">typename</span> rep_type::iterator,<span class="type">bool</span>&gt; p = t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(p.first,p.second);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position,<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>((rep_iterator&amp;)position,x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first,InputIterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        t.<span class="built_in">erase</span>((rep_iterator&amp;)position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">        t.<span class="built_in">erase</span>((rep_iterator&amp;)first,(rep_iterator&amp;)last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set operations</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">count</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    std::pair&lt;iterator,iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下的__STL_NULL_TMPL_ARGS 被定义为&lt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;,<span class="type">const</span> set&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> set&amp;,<span class="type">const</span> set&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> set&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="map">5.3 map</h5>
<ul>
<li>所有元素会根据元素的键值自动被排序</li>
<li>元素的类型是<code>pair</code>，同时拥有键值和实值；<code>map</code>不允许两个元素出现相同的键值</li>
<li>不可以修改<code>map</code>的键值 但是可以修改实值</li>
<li><code>map</code>基于红黑树实现对应的函数</li>
<li><code>map</code>和<code>set</code>一样，操作和删除操作时，操作之前的迭代器在操作之后依然有效</li>
</ul>
<h6 id="pair类型的定义">5.3.1 pair类型的定义</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    T1 first;    <span class="comment">//public</span></span><br><span class="line">    T2 second;  <span class="comment">//public</span></span><br><span class="line">    <span class="built_in">pair</span>():<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a,<span class="type">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="map源码">5.3.2 map源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>,<span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> map&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;<span class="comment">//键值型别</span></span><br><span class="line">    <span class="keyword">typedef</span> T data_type;<span class="comment">//数据(实值)型别</span></span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;<span class="type">const</span> Key,T&gt;value_type; <span class="comment">//元素型别(键值/实值)</span></span><br><span class="line">    <span class="comment">//键值比较函数</span></span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="comment">//以下定义一个functor 其作用就是调用&quot;元素比较函数&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">value_compare</span> : <span class="keyword">public</span> std::binary_function&lt;value_type,value_type,<span class="type">bool</span>&gt;&#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>&lt;Key,T,Compare,Alloc&gt;;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Compare comp;</span><br><span class="line">        <span class="built_in">value_compare</span>(Compare c):<span class="built_in">comp</span>(c)&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> value_type&amp; x,<span class="type">const</span> value_type&amp; y)</span><span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">comp</span>(x.first,y.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//定义表述型别 使用map元素的型别(pair)作为第一性别，作为红黑树节点的键值型别</span></span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type,value_type,_Select1st&lt;value_type&gt;,key_compare,Alloc&gt;rep_type;</span><br><span class="line">    rep_type t; <span class="comment">//使用红黑树(RB-Tree)实现map</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">    <span class="comment">//map迭代器无法执行写入操作，因为map的元素有一定的次序安排，不允许用户在任意处进行写入操作</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reverse_iterator reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    <span class="comment">//allocation/deallocation</span></span><br><span class="line">    <span class="comment">//map使用RB-Tree的insert_unique() 要求插入的元素都不可以重复</span></span><br><span class="line">    <span class="comment">//multimap 使用 insert_equal() 允许相同键值的存在</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">map</span>():<span class="built_in">t</span>(<span class="built_in">Compare</span>())&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">map</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">map</span><span class="params">(InputIterator first,InputIterator last)</span> : t(Compare())&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt;</span></span><br><span class="line"><span class="function">    <span class="title">map</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span></span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">map</span>(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x):<span class="built_in">t</span>(x.t)&#123;&#125;</span><br><span class="line">    map&lt;Key,Compare,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x)&#123;</span><br><span class="line">        t = x.t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//map进行函数的包装</span></span><br><span class="line">    <span class="comment">//accessors</span></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span><span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>();&#125;</span><br><span class="line">    <span class="comment">//需要注意 map使用的value_comp 事实上为RB-Tree的key_comp()</span></span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">value_compare</span>(t.<span class="built_in">key_comp</span>());&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span>  </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">end</span>();&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> t.<span class="built_in">rend</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">max_size</span>();&#125;</span><br><span class="line">    <span class="comment">//注意以下 下标操作符号</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k)&#123;</span><br><span class="line">        <span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k,<span class="built_in">T</span>()))).first)).second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(map&lt;Key,Compare,Alloc&gt;&amp; x)</span></span>&#123;t.<span class="built_in">swap</span>(x.t);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//insert / erase</span></span><br><span class="line"><span class="comment">//    typedef std::pair&lt;iterator,bool&gt;pair_iterator_bool;</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position,<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(position,x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first,InputIterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_unique</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(first,last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map operations</span></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">find</span>(x);&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> t.<span class="built_in">count</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp;x)</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);&#125;</span><br><span class="line">    std::pair&lt;iterator,iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    std::pair&lt;const_iterator,const_iterator&gt;<span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//以下的__STL_NULL_TMPL_ARGS 被定义为&lt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> map&amp;,<span class="type">const</span> map&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> map&amp;,<span class="type">const</span> map&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">Compare</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;x,<span class="type">const</span> map&lt;Key,Compare,Alloc&gt;&amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="multisetmap">5.3.3 multiset/map</h6>
<p><code>muiltiset\multimap</code>和它们对应的<code>set\map</code>特性完全相同，唯一不同点时<code>multi</code>允许键值重复，因此插入采用的时<code>RB-tree</code>的底层函数的<code>insert_equal()</code>而不是<code>insert_unique()</code>。</p>
<h5 id="hashtable">5.4 hashtable</h5>
<p>上面介绍的是以<code>RB-tree</code>为底层机制的容器，其在有序性和查找的性能(<code>logn</code>)上都不错。但还有一种在查找上的时间复杂度可在常数内完成的结构，那就是哈希表即：</p>
<ul>
<li>二叉搜索树具有对数平均时间的表现，<strong>但是这个需要满足的假设前提是输入的数据需要具备随机性</strong></li>
<li><code>hashtable</code>散列表这种结构在插入、删除、搜寻等操作层面上也具有常数平均时间的表现。<strong>而且不需要依赖元素的随机性，这种表现是以统计为基础的</strong></li>
</ul>
<p><strong>哈希表的特点：</strong></p>
<ul>
<li><code>hashtable</code>可提供对任何有名项的存取和删除操作</li>
<li>因为操作的对象是有名项，因此<code>hashtable</code>可以作为一种字典结构</li>
<li><strong>将一个元素映射成为一个 “大小可以接受的索引”简称为<code>hash function</code>散列函数</strong></li>
<li>考虑到元素的个数大于<code>array</code>的容量，<strong>可能有不同的元素被映射到相同的位置，简称为冲突</strong></li>
<li>解决冲突的方法有很多，线性探测、二次探测、<strong>开链</strong></li>
</ul>
<p>具体的hash思想可见<a target="_blank" rel="noopener" href="https://trluper.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">数据结构篇</a>，在<code>SGI STL</code>版本的<code>hash_table</code>使用的是<strong>开链法</strong>来解决哈希冲突,节点结构体如下： <img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/hashtablelist.png" width="500"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_node</span>&#123;</span><br><span class="line">    __hashtable_node* next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="hashtable的迭代器">5.4.1 hashtable的迭代器</h6>
<ul>
<li><code>hashable</code>迭代器维持着与整个<code>buckets vector</code>的关系，并记录目前所指的节点</li>
<li>前进操作是从目前节点出发前进一个位置，由于节点被安置于<code>list</code>内，使用<code>next</code>进行前进操作</li>
<li><strong>如果目前是<code>list</code>的尾端，则跳转至下一个<code>bucket</code>上，正是指向下一个<code>list</code>的头部</strong></li>
<li><strong><code>hashtable</code>的迭代器没有后退操作，<code>hashtable</code>没有定义所谓的逆向迭代器</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">ExtractKey</span>,<span class="keyword">class</span> <span class="title class_">EqualKey</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_iterator</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;hashtable;</span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_iterator&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;iterator;</span><br><span class="line"><span class="comment">//    typedef __hash_const   静态迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt;node;</span><br><span class="line">    <span class="keyword">typedef</span> std::forward_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> Value* pointer;</span><br><span class="line"></span><br><span class="line">    node* cur;<span class="comment">// 迭代器目前所指的节点</span></span><br><span class="line">    hashtable* ht;<span class="comment">//保持对容器的连接关系 (因为可能需要从bucket跳到bucket)</span></span><br><span class="line">    __hashtable_iterator(node*n,hashtable* tab):<span class="built_in">cur</span>(n),<span class="built_in">ht</span>(tab)&#123;&#125;</span><br><span class="line">    __hashtable_iterator()&#123;&#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> cur-&gt;val;&#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br><span class="line">    iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; it)<span class="type">const</span> &#123;<span class="keyword">return</span> cur == it.cur;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; it)<span class="type">const</span> &#123;<span class="keyword">return</span> cur != it.cur;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">HF</span>,<span class="keyword">class</span> <span class="title class_">ExK</span>,<span class="keyword">class</span> <span class="title class_">EqK</span>,<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;&amp;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="type">const</span> node* old = cur;</span><br><span class="line">    cur = cur-&gt;next; <span class="comment">//如果存在 就是他，否则进入以下的if流程</span></span><br><span class="line">    <span class="keyword">if</span> (!cur)&#123;</span><br><span class="line">        <span class="comment">//根据元素的数值，定位出下一个bucket，其起头处就是我们的目的地</span></span><br><span class="line">        size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cur = ht-&gt;buckets[bucket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>,<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">HF</span>,<span class="keyword">class</span> <span class="title class_">ExK</span>,<span class="keyword">class</span> <span class="title class_">EqK</span>,<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;</span><br><span class="line">__hashtable_iterator&lt;V,K,HF,ExK,EqK,A&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++<span class="keyword">this</span>; <span class="comment">//调用operator++</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="hashtable的数据结构">5.4.2 hashtable的数据结构</h6>
<ul>
<li><code>buckets</code>聚合体以<code>vector</code>完成，以利动态扩充</li>
<li><strong><code>&lt;stl_hash_fun.h&gt;</code>定义数个现成的<code>hash functions</code>全都是仿函数，<code>hash function</code>计算单元的位置，也就是元素对应的<code>bucket</code>的位置。具体调用的函数是<code>bkt_num()</code>,它调用<code>hash function</code>取得一个可以执行<code>modulus</code>(取模)运算的数值</strong>，以上的目的是出于 有些元素的型别是无法直接对其进行取模运算的，比如字符串类型 。</li>
<li>按照质数设计<code>vector</code>的大小，事先准备好<code>28</code>个质数，并设计一个函数用于查询最接近某数并大于某数的质数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Key:         节点的实值类型</span></span><br><span class="line"><span class="comment"> * Value:       节点的键值类型</span></span><br><span class="line"><span class="comment"> * HashFun:     hash function的函数型别</span></span><br><span class="line"><span class="comment"> * ExtractKey:  从节点中提取键值的方法 (函数或者仿函数)</span></span><br><span class="line"><span class="comment"> * EqualKey:    判断键值是否相同 (函数或者仿函数)</span></span><br><span class="line"><span class="comment"> * Alloc:       空间配置器 缺省使用 std::alloc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>,<span class="keyword">class</span> <span class="title class_">Key</span>,<span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">ExtractKey</span>,<span class="keyword">class</span> <span class="title class_">EqualKey</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> HashFcn hasher;    <span class="comment">//为template型别参数重新定义一个名称</span></span><br><span class="line">    <span class="keyword">typedef</span> EqualKey key_equal;<span class="comment">//为template型别参数重新定义一个名称</span></span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//以下三者都是function objects</span></span><br><span class="line">    <span class="comment">//&lt;stl_hash_fun.h&gt; 定义有数个标准型别(如 int、c-style、string等)的hasher</span></span><br><span class="line">    hasher hash;        <span class="comment">//散列函数</span></span><br><span class="line">    key_equal equals;   <span class="comment">//判断键值是否相等</span></span><br><span class="line">    ExtractKey get_key; <span class="comment">//从节点取出键值</span></span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt;node;</span><br><span class="line">    <span class="comment">//专属的节点配置器</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;node,Alloc&gt;node_allocator;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点的配置函数</span></span><br><span class="line">    <span class="function">node* <span class="title">new_node</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        node* n = node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">        n-&gt;next = <span class="number">0</span>;</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            Chy::allocator&lt;Key&gt;::<span class="built_in">construct</span>(&amp;n-&gt;val,obj);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(node_allocator::<span class="built_in">deallocate</span>(n);)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点释放函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delete_node</span><span class="params">(node* n)</span></span>&#123;</span><br><span class="line">        Chy::allocator&lt;Key&gt;::<span class="built_in">destroy</span>(n-&gt;val);</span><br><span class="line">        node_allocator::<span class="built_in">deallocate</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;node*,Alloc&gt;buckets;<span class="comment">//以vector完成桶的集合，其实值是一个node*</span></span><br><span class="line">    size_type num_elements;  <span class="comment">//node的个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bucket个数 即buckets vector的大小</span></span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buckets.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//注意假设 假设long至少有32bit</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">53</span>,         <span class="number">97</span>,         <span class="number">193</span>,       <span class="number">389</span>,       <span class="number">769</span>,</span><br><span class="line">        <span class="number">1543</span>,       <span class="number">3079</span>,       <span class="number">6151</span>,      <span class="number">12289</span>,     <span class="number">24593</span>,</span><br><span class="line">        <span class="number">49157</span>,      <span class="number">98317</span>,      <span class="number">196613</span>,    <span class="number">393241</span>,    <span class="number">786433</span>,</span><br><span class="line">        <span class="number">1572869</span>,    <span class="number">3145739</span>,    <span class="number">6291469</span>,   <span class="number">12582917</span>,  <span class="number">25165843</span>,</span><br><span class="line">        <span class="number">50331653</span>,   <span class="number">100663319</span>,  <span class="number">201326611</span>, <span class="number">402653189</span>, <span class="number">805306457</span>,</span><br><span class="line">        <span class="number">1610612741</span>, <span class="number">3221225473</span>, <span class="number">4294967291</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//找出上述28指数中，最接近并大于n的那个质数</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_next_prime(<span class="type">unsigned</span> <span class="type">long</span> n)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *first = __stl_prime_list;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *pos = std::<span class="built_in">lower_bound</span>(first,last,n);</span><br><span class="line">        <span class="comment">//使用lower_bound() 需要先进行排序</span></span><br><span class="line">        <span class="keyword">return</span> pos == last ? *(last<span class="number">-1</span>) : *pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//总共有多少个buckets。以下是hash_table的一个member function</span></span><br><span class="line">    <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">//其数值将为 4294967291</span></span><br><span class="line">        <span class="keyword">return</span> __stl_prime_list[__stl_num_primes - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">hashtable</span>(size_type n,<span class="type">const</span> HashFcn&amp; hf,<span class="type">const</span> EqualKey&amp; eql)</span><br><span class="line">    :<span class="built_in">hash</span>(hf),<span class="built_in">equals</span>(eql),<span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()),<span class="built_in">num_elements</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//例子：传入50 返回53</span></span><br><span class="line">        <span class="comment">//然后保留53个元素的空间 然后将其全部填充为0</span></span><br><span class="line">        <span class="type">const</span> size_type n_buckets = <span class="built_in">next_size</span>(n);</span><br><span class="line">        buckets.<span class="built_in">reserve</span>(n_buckets);</span><br><span class="line">        <span class="comment">//设定所有的buckets的初值为0(node*)</span></span><br><span class="line">        buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">begin</span>(),n_buckets,(node*)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//------------------------------bkt_num函数---------------------------</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//版本1：接受实值（value）和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj), n); <span class="comment">//调用版本4</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本2：只接受实值（value）</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj)); <span class="comment">//调用版本3</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本3，只接受键值</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(key, buckets.<span class="built_in">size</span>()); <span class="comment">//调用版本4</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//版本4：接受键值和buckets个数</span></span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % n; <span class="comment">//SGI的所有内建的hash()，在后面的hash functions中介绍</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//相关对应的函数</span></span><br><span class="line">    <span class="comment">//next_size()返回最接近n并大于n的质数</span></span><br><span class="line">    <span class="function">size_type <span class="title">next_size</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __stl_next_prime(n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;Value,Key,HashFcn,ExtractKey,EqualKey,Alloc&gt;iterator;</span><br><span class="line">    <span class="comment">//插入操作和表格重整</span></span><br><span class="line">    <span class="comment">//插入元素不允许重复</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type&amp; obj)&#123;</span><br><span class="line">        <span class="comment">//判断是否需要重建表格  如果需要就进行扩充</span></span><br><span class="line">        <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//函数判断是否需要重建表格 如果不需要立刻返回，如果需要 就重建表格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type num_elements_hint)</span></span>&#123;</span><br><span class="line">        <span class="comment">//表格重建与否的原则是：元素的个数(新增元素计入之后)和先前分配的bucket vector进行比较</span></span><br><span class="line">        <span class="comment">//如果前者的大于后者 就需要表格的重建</span></span><br><span class="line">        <span class="comment">//因此 bucket(list)的最大容量和buckets vector的大小相同</span></span><br><span class="line">        <span class="type">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (old_n &lt; num_elements_hint)&#123;</span><br><span class="line">            <span class="comment">//需要重新分配内存</span></span><br><span class="line">            <span class="comment">//计算下一个质数</span></span><br><span class="line">            <span class="type">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; old_n)&#123;</span><br><span class="line">                std::vector&lt;node*,Alloc&gt;<span class="built_in">tmp</span>(n,(node*)<span class="number">0</span>);</span><br><span class="line">                __STL_TRY&#123;</span><br><span class="line">                    <span class="comment">//处理每一个旧的bucket</span></span><br><span class="line">                    <span class="keyword">for</span> (size_type bucket=<span class="number">0</span>;bucket&lt;old_n;bucket++) &#123;</span><br><span class="line">                        <span class="comment">//指向节点所对应的的串行的起始节点</span></span><br><span class="line">                        node* first = buckets[bucket];</span><br><span class="line">                        <span class="comment">//处理每一个旧的bucket所含(串行)的每一个节点</span></span><br><span class="line">                        <span class="keyword">while</span>(first)&#123;</span><br><span class="line">                            <span class="comment">//串行节点还未结束</span></span><br><span class="line">                            <span class="comment">//找出节点落在哪一个新的bucket内部</span></span><br><span class="line">                            size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val,n);</span><br><span class="line">                            <span class="comment">//以下四个操作颇为巧妙</span></span><br><span class="line">                            <span class="comment">//(1)令旧bucket指向其所对应的串行的下一个节点(以便迭代处理)</span></span><br><span class="line">                            buckets[bucket] = first-&gt;next;</span><br><span class="line">                            <span class="comment">//(2)(3)将当前节点插入到新的bucket内部，成为其对应串行的第一个节点</span></span><br><span class="line">                            first-&gt;next = tmp[new_bucket];</span><br><span class="line">                            tmp[new_bucket] = first;</span><br><span class="line">                            <span class="comment">//(4)回到旧的bucket所指向的待处理的串行，准备处理下一个节点</span></span><br><span class="line">                            first = buckets[bucket];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//对调新旧两个buckets</span></span><br><span class="line">                    <span class="comment">//离开的时候会释放tmp的内存</span></span><br><span class="line">                    buckets.<span class="built_in">swap</span>(tmp);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要重建表格的情况下插入新的节点 键值不允许重复</span></span><br><span class="line">    std::pair&lt;iterator,<span class="type">bool</span>&gt;<span class="built_in">insert_unique_noresize</span>(<span class="type">const</span> value_type&amp; obj)&#123;</span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj) ;<span class="comment">//决定obj应该位于 第n n bucket</span></span><br><span class="line">        node* first = buckets[n]; <span class="comment">//令first指向bucket对应的串行头部</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果Buckets[n]已经被占用 此时first不再是0 于是进入以下循环</span></span><br><span class="line">        <span class="comment">//走过bucket所对应的整个链表</span></span><br><span class="line">        <span class="keyword">for</span> (node* cur = first;cur;cur = cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val)),<span class="built_in">get_key</span>(obj))&#123;</span><br><span class="line">                <span class="comment">//如果发现和链表中的某个键值是相同的 就不插入 立刻返回</span></span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//离开上述循环(或者根本没有进入循环的时候)first指向bucket的所指链表的头部节点</span></span><br><span class="line">            node* tmp = <span class="built_in">new_node</span>(obj); <span class="comment">//产生新的节点</span></span><br><span class="line">            tmp-&gt;next = first;</span><br><span class="line">            buckets[n] = tmp; <span class="comment">//令新的节点成为链表的第一个节点</span></span><br><span class="line">            ++num_elements;   <span class="comment">//节点的个数累加</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator,<span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(tmp,<span class="keyword">this</span>),<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//客户端执行的是另外一种节点的插入行为(不再是insert_unique 而是insert_equal)</span></span><br><span class="line">    <span class="comment">//插入元素 允许重复</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否需要重建表格 如果需要就进行扩充</span></span><br><span class="line">        <span class="built_in">resize</span>(num_elements+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在不需要重建表格的情况下 插入新的节点，键值是允许重复的</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj); <span class="comment">//决定obj应该位于第 n bucket</span></span><br><span class="line">        node* first = buckets[n];<span class="comment">//令first指向的bucket对应的链表的头部</span></span><br><span class="line">        <span class="comment">//如果bucket[n]已经被占用，此时的first不为0，进入循环</span></span><br><span class="line">        <span class="comment">//遍历整个链表</span></span><br><span class="line">        <span class="keyword">for</span>(node* cur = first;cur;cur = cur-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val),<span class="built_in">get_key</span>(obj)))&#123;</span><br><span class="line">                <span class="comment">//如果发现与链表中的某个键值相同，就马上插入，然后返回</span></span><br><span class="line">                node* tmp = <span class="built_in">new_node</span>(obj);  <span class="comment">//产生新的节点</span></span><br><span class="line">                tmp-&gt;next = cur-&gt;next;<span class="comment">//新节点插入目前的位置</span></span><br><span class="line">                cur-&gt;next = tmp;</span><br><span class="line">                ++num_elements;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">iterator</span> (tmp, <span class="keyword">this</span>); <span class="comment">//返回一个迭代器 指向新增的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行到这个时候 表示没有发现重复的数值</span></span><br><span class="line">            node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">            tmp-&gt;next = first;</span><br><span class="line">            buckets[n] = tmp;</span><br><span class="line">            ++num_elements;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//针对每一个bucket</span></span><br><span class="line">        <span class="keyword">for</span>(size_type i = <span class="number">0</span>;i &lt; buckets.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            node * cur = buckets[i];</span><br><span class="line">            <span class="comment">//删除bucket list中的每一个节点</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="number">0</span>)&#123;</span><br><span class="line">                node* next = cur-&gt;next;</span><br><span class="line">                <span class="built_in">delete_node</span>(cur);</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            buckets[i] = <span class="number">0</span>; <span class="comment">//令buckets内容为null</span></span><br><span class="line">        &#125;</span><br><span class="line">        num_elements = <span class="number">0</span>; <span class="comment">//令总的节点的个数为0</span></span><br><span class="line">        <span class="comment">//需要注意 buckets vector并没有释放空间，仍然保存先前的大小</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy_from</span><span class="params">(<span class="type">const</span> hashtable&amp; ht)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先清除己方的buckets vector，此操作是调用vector::clear() 造成所有的元素都为0</span></span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">//为己方的buckets vector保留空间，使与对方相同</span></span><br><span class="line">        <span class="comment">//如果己方的空间大于对方 就不需要改变；如果己方的空间小于对方 就会增大</span></span><br><span class="line">        buckets.<span class="built_in">reserve</span>(ht.buckets.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//从己方的buckets vector尾端开始，插入n个元素，其数值为 null 指针</span></span><br><span class="line">        <span class="comment">//注意此时buckets vector为空，所谓的尾端就是起头处</span></span><br><span class="line">        buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(),ht.buckets.<span class="built_in">size</span>(),(node*)<span class="number">0</span>);</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            <span class="comment">//针对buckets vector</span></span><br><span class="line">            <span class="keyword">for</span> (size_type i = <span class="number">0</span>;i&lt;ht.buckets.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">                <span class="comment">//复制vector的每一个元素(是一个指针，指向hashtable节点)</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="type">const</span> node* cur = ht.buckets[i])&#123;</span><br><span class="line">                    node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">                    buckets[i] = copy;</span><br><span class="line">                    <span class="comment">//针对同一个 buckets list 复制每一个节点</span></span><br><span class="line">                    <span class="keyword">for</span> (node* next = cur-&gt;next;next ; cur = next,next = cur-&gt;next) &#123;</span><br><span class="line">                        copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">                        copy = copy-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新登录的节点的个数(hashtable的大小)</span></span><br><span class="line">            num_elements = ht.num_elements;</span><br><span class="line">        &#125;;</span><br><span class="line">        __STL_UNWIND(<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>STL中哈希表一般不要外部使用，它是实现<code>hash_map</code>和<code>hash_set</code>的底层机制，编程者可以使用它们。</p>
<h5 id="hash_set">5.5 hash_set</h5>
<p>同set一样，单独以键存储。<code>hash_set</code>是以<code>hashtable</code>为底层机制，因此存储数无序的，而<code>set</code>有序。同时其所供应的接口大部分都是转调用<code>hashtable</code>的函数。<code>hash_set</code>的使用方式与<code>set</code>差不多一样.</p>
<h6 id="hash_set源码">5.5.1 hash_set源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_INTERNAL_HASH_SET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SGI_STL_INTERNAL_HASH_SET_H</span></span><br><span class="line"></span><br><span class="line">__STL_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> set woff 1174</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Value&gt;,</span><br><span class="line">          <span class="keyword">class</span> EqualKey = equal_to&lt;Value&gt;,</span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> EqualKey, <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> hash_set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;Value, Value, HashFcn, identity&lt;Value&gt;, </span><br><span class="line">                    EqualKey, Alloc&gt; ht;</span><br><span class="line">  ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equal key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hash_set</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hash_set</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equal()) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_set</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_set</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_set&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_set&amp;,</span><br><span class="line">                                               <span class="type">const</span> hash_set&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique</span>(obj);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span> </span>&#123;</span><br><span class="line">    rep.<span class="built_in">insert_unique</span>(f,l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator f, const_iterator l)</span> </span>&#123;rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="type">bool</span>&gt; p = rep.<span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="hash_map">5.6 hash_map</h5>
<p>同map一样以键值对形式存储，但其底层机制为<code>hashtable</code>，因此大部分情况支持常数时间复杂度访问，存储是无序的。使用方式与<code>map</code>相差不大</p>
<h6 id="hash_map源码">5.6.1 hash_map源码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) &amp;&amp; (_MIPS_SIM != _MIPS_SIM_ABI32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> set woff 1174</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span> = hash&lt;Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> EqualKey = equal_to&lt;Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> HashFcn, <span class="keyword">class</span> EqualKey, </span><br><span class="line">          <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> hash_map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;pair&lt;<span class="type">const</span> Key, T&gt;, Key, HashFcn,</span><br><span class="line">                    select1st&lt;pair&lt;<span class="type">const</span> Key, T&gt; &gt;, EqualKey, Alloc&gt; ht;</span><br><span class="line">  ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">  <span class="keyword">typedef</span> T data_type;</span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equal key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::iterator iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">hash_map</span>() : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hash_map</span><span class="params">(size_type n)</span> : rep(n, hasher(), key_equal()) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf) : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="built_in">hash_map</span>(InputIterator f, InputIterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l)</span><br><span class="line">    : <span class="built_in">rep</span>(<span class="number">100</span>, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n)</span><br><span class="line">    : <span class="built_in">rep</span>(n, <span class="built_in">hasher</span>(), <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, <span class="built_in">key_equal</span>()) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line">  <span class="built_in">hash_map</span>(const_iterator f, const_iterator l, size_type n,</span><br><span class="line">           <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">    : <span class="built_in">rep</span>(n, hf, eql) &#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hash_map&amp; hs)</span> </span>&#123; rep.<span class="built_in">swap</span>(hs.rep); &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span></span><br><span class="line">  <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> hash_map&amp;, <span class="type">const</span> hash_map&amp;);</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(obj); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator f, InputIterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f,l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type* f, <span class="type">const</span> value_type* l)</span> </span>&#123;</span><br><span class="line">    rep.<span class="built_in">insert_unique</span>(f,l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(const_iterator f, const_iterator l)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(f, l); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique_noresize</span>(obj); &#125;    </span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; key) &#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">find_or_insert</span>(<span class="built_in">value_type</span>(key, <span class="built_in">T</span>())).second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">count</span>(key); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line">  <span class="function">pair&lt;const_iterator, const_iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">equal_range</span>(key); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;<span class="keyword">return</span> rep.<span class="built_in">erase</span>(key); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.<span class="built_in">erase</span>(f, l); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="各个容器的适用场景">6. 各个容器的适用场景</h4>
<ul>
<li>1）<code>vector</code>的使用场景：只查看，而不频繁插入删除的，因为频繁插入删除会造成内存的不断搬家和删除。使用场景比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录。</li>
<li>2）<code>deque</code>的使用场景：比如排队购票系统，对排队者的存储可以采用<code>deque</code>，支持头端的快速移除，尾端的快速添加。如果采用<code>vector</code>，则头端移除时会移动大量的数据，速度慢。<code>vector</code>与<code>deque</code>的比较：
<ul>
<li>一：<code>vector.at()</code>比<code>deque.at()</code>效率高，比如<code>vector.at(0)</code>是固定的，<code>deque</code>的开始位置却是不固定的。</li>
<li>二：如果有大量释放操作的话，<code>vector</code>花的时间更少，这跟二者的内部实现有关。</li>
<li>三：<code>deque</code>支持头部的快速插入与快速移除，这是<code>deque</code>的优点。</li>
</ul></li>
<li><code>list</code>的使用场景：频繁的插入删除的场景，这时也可以使用queue和deque。使用场景比如公交车乘客的存储，随时可能有乘客上下车，支持频繁的不确实位置元素的移除插入删除。</li>
<li><code>set</code>的使用场景：大部分负责查找内容且要求有序的情况下。使用场景比如对游戏中个人得分历史记录的存储，存储要求从高分到低分的顺序排列。</li>
<li><code>map</code>的使用场景：对查找有较高的要求，使用场景比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。红黑树的查找效率，这时就体现出来了。</li>
</ul>
<h4 id="算法">7. 算法</h4>
<h5 id="stl算法分类">7.1 STL算法分类</h5>
<h6 id="质变和非质变">7.1.1 质变和非质变</h6>
<ul>
<li><strong>质变算法：</strong>是指运算过程中会更改区间内的元素的内容</li>
<li><strong>非质变算法：</strong>是指运算过程中不会更改区间内的元素内容</li>
</ul>
<h6 id="stl算法的一般形式">7.1.2 STL算法的一般形式</h6>
<p><strong>大多数算法有下列4中形式：</strong></p>
<ul>
<li><code>alg(first,last,other args);</code></li>
<li><code>alg(first,last,dest,other args);</code></li>
<li><code>alg(first,last,first2,other args);</code></li>
<li><code>alg(first,last,first2,lasst2,other args);</code></li>
</ul>
<p><strong>更一般的说法是：</strong></p>
<ul>
<li><strong>所有泛型算法的前两个参数一定是一对迭代器，通常为<code>first</code>和<code>last</code>,范围为<code>[first,last)</code></strong></li>
<li><strong>许多STL算法不止只支持一个版本，可接受仿函数<code>_if</code>结尾，如<code>find()</code>函数支持传入谓词或仿函数的<code>find_if()</code>版本</strong></li>
<li>质变算法通常会有至少提供两个版本，一个是就地进行改变操作对象的版本，<strong>另一个是<code>_copy</code>版本，拷贝一份副本，在副本上改变，如<code>replace()</code>函数就有<code>replace_copy()</code>版本</strong></li>
<li>所有的数值算法实现都在<code>&lt;stl_numeric.h&gt;，用户使用时可包含</code>#include<numeric>`调用</numeric></li>
<li>其他算法实现于<code>&lt;stl_algo.h&gt;\&lt;stl_algobase.h&gt;</code>，用户使用可通过包含<code>#include&lt;algorithm&gt;</code>调用</li>
</ul>
<h6 id="算法总览">7.1.3 算法总览</h6>
<table>
<thead>
<tr class="header">
<th>算法名称</th>
<th>算法用途</th>
<th style="text-align: center;">质变？</th>
<th>所在文件</th>
<th style="text-align: center;">所属作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>accumulate</code></td>
<td>元素求和</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_numeric.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="even">
<td><code>adjacent_difference</code></td>
<td>相邻元素差额</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_numeric.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td><code>adjacent_find</code></td>
<td>查找相邻重复(或符合条件)的元素</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>binary_search</code></td>
<td>二分查找</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>copy</code></td>
<td>复制</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="even">
<td><code>copy_backward</code></td>
<td>逆向复制</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="odd">
<td><code>copy_n</code></td>
<td>复制n个元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">拷贝</td>
</tr>
<tr class="even">
<td><code>count</code></td>
<td>计数</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>count_if</code></td>
<td>在特定传入的谓词或仿函数条件下计数</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>equal</code></td>
<td>判断两个区间相等与否</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">关系</td>
</tr>
<tr class="odd">
<td><code>equal_range</code></td>
<td>在有序区间寻找某值，返回一个区间</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">关系</td>
</tr>
<tr class="even">
<td><code>fill</code></td>
<td>该填元素值</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>fill_n</code></td>
<td>该填元素值，n次</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>find</code></td>
<td>循序查找</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>find_if</code></td>
<td>查找符合条件的元素</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>find_end</code></td>
<td>查找某个子序列的最后一次出现点</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>find_first_of</code></td>
<td>查找某些元素首次出现点</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>for_each</code></td>
<td>对区间的每一个元素施行某操作</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>generate</code></td>
<td>以特定操作的运算结果填充特定区间内的元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>inner_product</code></td>
<td>内积</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">算术</td>
</tr>
<tr class="odd">
<td><code>iter_swap</code></td>
<td>元素互换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td><code>lower_bound</code></td>
<td>返回有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>max</code></td>
<td>最大值</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>max_element</code></td>
<td>最大值所在位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>min</code></td>
<td>最小值</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>min_element</code></td>
<td>最小值所在位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>merge</code></td>
<td>合并两个序列</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>inplace_merge</code></td>
<td>合并且就地替换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="odd">
<td><code>random_shuffle</code></td>
<td>随机重排元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">生成</td>
</tr>
<tr class="even">
<td><code>remove</code></td>
<td>删除某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="odd">
<td><code>remove_copy</code></td>
<td>删除某类元素并将结果存储都另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="even">
<td><code>remove_if</code></td>
<td>有条件的删除某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="odd">
<td><code>remove_copy_if</code></td>
<td>有条件的删除某类元素，并将结果存储到另外一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">删除</td>
</tr>
<tr class="even">
<td><code>replace</code></td>
<td>替换某类元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="odd">
<td><code>replace_copy</code></td>
<td>替换某类元素，并将结果存储到另一个元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="even">
<td><code>replace_if</code></td>
<td>有条件的替换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="odd">
<td><code>replace_copy_if</code></td>
<td>有条件的替换，并将结果存储都另一个容q器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">替换</td>
</tr>
<tr class="even">
<td><code>reverse</code></td>
<td>反转</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="odd">
<td><code>reverse_copy</code></td>
<td>反转并把结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">反转</td>
</tr>
<tr class="even">
<td><code>rotate</code></td>
<td>旋转</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">旋转</td>
</tr>
<tr class="odd">
<td><code>rotate_copy</code></td>
<td>旋转，并把结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;sta_algo.h&gt;</code></td>
<td style="text-align: center;">旋转</td>
</tr>
<tr class="even">
<td><code>search</code></td>
<td>查找某个子序列</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="odd">
<td><code>search_n</code></td>
<td>查找连续发生n次的某个子序列</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>sort</code></td>
<td>排序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">排序</td>
</tr>
<tr class="odd">
<td><code>stable_sort</code></td>
<td>排序并保持等值元素的相对次序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">排序</td>
</tr>
<tr class="even">
<td><code>stable_partition</code></td>
<td>分割并保存元素的相对次序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">分割</td>
</tr>
<tr class="odd">
<td><code>swap</code></td>
<td>交换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algobase.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="even">
<td><code>swap_ranges</code></td>
<td>指定区间的交换</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">交换</td>
</tr>
<tr class="odd">
<td><code>unique</code></td>
<td>去重</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">去重</td>
</tr>
<tr class="even">
<td><code>unique_copy</code></td>
<td>去重后的结果存储到另一个容器</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">去重</td>
</tr>
<tr class="odd">
<td><code>upper_bound</code></td>
<td>返回有序序列范围内的可以插入指定值而不破坏容器顺序的最后位置</td>
<td style="text-align: center;">否</td>
<td><code>&lt;stl_algo.h&gt;</code></td>
<td style="text-align: center;">查找</td>
</tr>
<tr class="even">
<td><code>make_heap</code></td>
<td>创建一个堆</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="odd">
<td><code>pop_heap</code></td>
<td>从堆取元素</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="even">
<td><code>push_heap</code></td>
<td>将元素插入堆</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
<tr class="odd">
<td><code>sort_heap</code></td>
<td>堆heap排序</td>
<td style="text-align: center;">是</td>
<td><code>&lt;stl_heap.h&gt;</code></td>
<td style="text-align: center;">堆</td>
</tr>
</tbody>
</table>
<h5 id="sort">7.2 sort</h5>
<h6 id="适用容器">7.2.1 适用容器</h6>
<p><code>sort()</code>算法是最复杂堆庞大的一个，<strong>这个算法接受两个<code>RandomAccessIterator</code>迭代器，然后将区间内的元素由小到大重新排列</strong>。第二个版本则允许用户传入<strong>谓词或者仿函数</strong>作为排序条件，指定按什么规则排序。适用<code>sort</code>算法的容器有<code>vecror\deque</code>。</p>
<p><strong><em>附</em></strong>：因为关联容器的底层机制，根本不需要<code>sort</code>排序，<code>stack\queue\priority_queue</code>对进出的机制也要求不需排序，而<code>list</code>的迭代器为<code>BidirectinalIterator</code>不适用。</p>
<h6 id="sort实现的原理">7.2.2 sort实现的原理</h6>
<p>早期的STL <code>sort()</code>算法都是采用<strong>快排</strong>来实现，对于快排平均的时间复杂度为<code>O(NlogN)</code>,但是最坏的情况却会达到<code>O(N*N)</code>，<strong>因此现今的<code>STL SGI</code>改用<code>IntroSort</code>即内观排序算法，极其类似于<code>median-three QuickSort</code>三数取中快速排序算法。这种算法即使在最坏的情况下推进到<code>O(NlogN)</code>。</strong>快排的最坏情况的发生与快速排序中基准点的选择是有重大的关系，当出现下面两种情况时性能最差:</p>
<ul>
<li>在分解时每次选取的基准点为最小元素</li>
<li>在分解时每次选取的基准点为最大元素</li>
</ul>
<p><strong>快排的过程：</strong></p>
<ul>
<li>如果序列中的元素个数为0或1，结束</li>
<li>取序列中的任何一个元素，一般会取该段序列的头或者尾元素作为基准点<code>pivot</code></li>
<li>将序列分类<code>L\R</code>两段子序列，使L内的每一个元素都小于或等于基准点，R内的每一个元素都大于等于基准点</li>
<li>对<code>L\R</code>递归执行<code>QuickSort</code>,重复上述操作</li>
</ul>
<p><img src="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/quickSort.gif" width="600"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写自己的quickSort,没有优化，遇到最坏情况的时间复杂度会变成O(N*N)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--;</span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="三点取中优化方案">7.2.3 三点取中优化方案</h6>
<p>为了避免快排出现上述所说的最坏情况，选择哪一个元素作为基准点是关键，<strong>在快排过程中采用三点取中间值的优化方案。三数取中<code>median-of-three</code>指的是在挑选基准元素时，不是简单的选择数组中的第一个元素或最后一个，而是选取某三个元素，常选头、尾和中央三个元素，并且适用三个元素之中的中位数作为基准元素进行划分</strong>。这样即使在最坏的情况下将时间复杂度推进到<code>O(NlogN)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化后的快排代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> first, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">medianOfThree</span>(a, first, (first + last) / <span class="number">2</span>, last);</span><br><span class="line">    <span class="type">int</span> leftCursor = first, rightCursor = last;</span><br><span class="line">    <span class="type">int</span> pivot = a[first];</span><br><span class="line">    <span class="keyword">while</span> (leftCursor &lt; rightCursor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (rightCursor&gt;first&amp;&amp;a[rightCursor] &gt; pivot )</span><br><span class="line">            rightCursor--; </span><br><span class="line">        <span class="keyword">while</span> (leftCursor&lt;last&amp;&amp;a[leftCursor] &lt;= pivot)</span><br><span class="line">            leftCursor++;</span><br><span class="line">        <span class="keyword">if</span> (leftCursor &gt;= rightCursor)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[leftCursor], a[rightCursor]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放置基准点</span></span><br><span class="line">    a[first] = a[rightCursor];</span><br><span class="line">    a[rightCursor] = pivot;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, first, rightCursor - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, rightCursor+<span class="number">1</span> , last);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cap, <span class="type">int</span> first, <span class="type">int</span> mid, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cap[first] &lt; cap[mid])</span><br><span class="line">        <span class="keyword">if</span> (cap[first] &gt;= cap[last])	<span class="comment">//last=&lt;first&lt;mid</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&lt;mid&lt;last</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[mid];</span><br><span class="line">            cap[mid] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>						<span class="comment">// first&lt;last&lt;=mid</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = cap[last];</span><br><span class="line">            cap[last] = cap[first];</span><br><span class="line">            cap[first] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[first] &lt; cap[last])	<span class="comment">//last&gt;first&gt;=mid</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cap[mid] &lt; cap[last])		<span class="comment">//first&gt;=mid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[last];</span><br><span class="line">        cap[last] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = cap[mid];</span><br><span class="line">        cap[mid] = cap[first];</span><br><span class="line">        cap[first] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数值算法">7.3 数值算法</h5>
<p>数值算法都在头文件<code>&lt;numeric&gt;</code>中，实现于<code>&lt;stl_numeric.h&gt;。 ###### 7.3.1 accumulate</code>accumulate`算法用来计算指定区间的和，需要提供额外参数指定累加到哪一个初始值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init)</span></span>;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T，<span class="keyword">class</span> BinaryOperation &gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init,</span></span></span><br><span class="line"><span class="params"><span class="function">	BinaryOperation binary_op)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="power">7.3.2 power</h6>
<p>计算某数的n次方幂，该算法四<code>SGI</code>版本特有算法。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Integer&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">power</span><span class="params">(T x,Integer n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="adjacent_difference">7.3.3 adjacent_difference</h6>
<p>算法<code>adjacent_difference</code>用来计算[first,last)中相邻元素的差额，即它会将<code>*first</code>赋值给<code>*result</code>，并针对[first,last)内的每个迭代器<code>i</code>,进行<code>*i-*(i-1)</code>，然后赋值给<code>*++result</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InpueIterator,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="基本算法">7.4 基本算法</h5>
<p>对于SGI版本,它会把常用的一些算法定义在<code>&lt;stl_algobase.h&gt;</code>,使用时包含<code>&lt;algorithm&gt;</code>即可。</p>
<h5 id="equal">7.4.1 equal</h5>
<p>如果两个序列在<code>[first,lasst)</code>区间内相等，<code>equal</code>会返回<code>true</code>。如果第二序列元素多，则剩余元素不考虑，一般调用前要先保证元素个数一样。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator1,<span class="keyword">class</span> InputIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(InpueIterator1 first1,InpueIterator1 last1,InpueIterator1 first2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="fill">7.4.2 fill</h6>
<p>将<code>[first,last)</code>内的元素该填新值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(ForwardIterator first,ForwardIterator last,<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">###### <span class="number">7.4</span><span class="number">.3</span> fill_n</span><br><span class="line">将`[first,last)`的前n个改填新值，返回的迭代器指向被填入的最后一个元素的下一个位置。</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> OutputIterator,<span class="keyword">class</span> Size,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">fill_n</span><span class="params">(OutputIterator first,Size n,<span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="iter_swap">7.4.4 iter_swap</h6>
<p>该算法将两个<code>ForwardIterator</code>所指对象对调。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1,calss ForwardIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator a,ForwardIterator2 b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="copy">7.4.5 copy</h6>
<ul>
<li><code>copy()</code>算法是最最最常用的一个算法，</li>
<li><code>copy()</code>算法将输入区间的<code>[first,last)</code>的元素复制到目标区间<code>[result,result+(last-first))</code>中，执行完后返回一个迭代器，指向<code>result+(last-first)</code>。</li>
<li><code>copy</code>函数对参数非常宽松，对输入区间只需由<code>InputIterator</code>构成即可，输出区间尾<code>OutputIterator</code>构成即可，即意味着可以将任何容器的任何一段内容复制带任何容器的任何一段上，当然这些容器要由对应的迭代器。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InpueIterator,<span class="keyword">class</span> OutputIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(InputIterator first,InputIterator last,OutputIterator result)</span></span></span><br></pre></td></tr></table></figure>
<h6 id="copy_backward">7.4.6 copy_backward</h6>
<p>与<code>copy</code>非常相似，只不过<code>copy_backward</code>是以逆行方向复制到<code>result</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterator1,<span class="keyword">class</span> BidirectionalIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(BidirectionalIterator1 first,</span></span></span><br><span class="line"><span class="params"><span class="function">	BidirectionalIterator1,BidirectionalIterator2 result)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="其他算法">7.5 其他算法</h5>
<p>定义与<code>&lt;stl_algo.h&gt;</code>内地算法</p>
<h6 id="adjacent_find">7.5.1 adjacent_find</h6>
<p>该算法找出第一组满足条件的相邻元素，这里所谓的条件，在版本一中是指<strong>两元素相等</strong>，在版本二中允许用户指定一个二元为谓词运算，两操作数是相邻第一个元素和第二个元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first,ForwardIterator last)</span></span>;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator,<span class="keyword">class</span> BinaryPredicate&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator last,BinaryPredicate binary_pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find">7.5.2 find</h6>
<p>在<code>[first,lasy)</code>找出第一个符合匹配条件的元素，返回该元素所在位置的迭代器，未找到则返回<code>last</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_if">7.5.3 find_if</h6>
<p>传入一原谓词，根据指定的条件<code>pred</code>元素条件查找，返回该元素所在位置的迭代器，未找到则返回<code>last</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> predicate&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,predicate pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_end">7.5.4 find_end</h6>
<p>在序列一的<code>[first1,last1)</code>区间中，查找序列二<code>[first2,last2)</code>最后一次出现点，如果不存在，则返回<code>last1</code>。由两个版本，版本一默认使用<code>==</code>,版本二允许用户传入二元运算谓词。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator1,<span class="keyword">class</span> ForwardIterator2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIterator</span><span class="params">(ForwardIterator1 first1,ForwardIterator1 last1</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator2 first2,ForwardIterator2 last2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="find_first_of">7.5.5 find_first_of</h6>
<p>本算法以<code>[first2,last2)</code>区间内的元素作为查找目标，寻找它们在<code>[first1,last1)</code>第一次出现的位置，<strong>只要<code>[first2,last2)</code>任何一个元素第一次出现在<code>[first1,last1)</code>就返回</strong>。两个版本，一个默认使用<code>==</code>,一个允许用户指定二元谓词传入 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator,<span class="keyword">class</span> ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIterator</span><span class="params">(InputIterator first1,InputIterator last1</span></span></span><br><span class="line"><span class="params"><span class="function">	ForwardIterator2 first2,ForwardIterator2 last2)</span></span>;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="trluper 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="trluper 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/STL/" rel="tag"># STL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/" rel="prev" title="数据结构(C++实现)">
      <i class="fa fa-chevron-left"></i> 数据结构(C++实现)
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/13/ubuntu%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" rel="next" title="ubuntu使用手册">
      ubuntu使用手册 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#stl%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1.STL概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 六大组件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">2. 空间配置器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 空间配置器的标准接口</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1设计一个简单的空间配置器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sgi%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 SGI空间配置器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sgi%E7%9A%84alloc"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 SGI的alloc</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#alloc%E7%9A%84stl_constuct"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 alloc的stl_constuct</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AEstl_alloc"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 空间配置stl_alloc</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1 一级配置器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E7%9F%A5%E8%AF%86%E7%82%B9new-handler%E6%9C%BA%E5%88%B6"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2 附加知识点：new handler机制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.5.3 二级配置器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">3. 迭代器与traits编程技法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95-stl%E6%BA%90%E7%A0%81%E7%9A%84%E9%97%A8%E9%92%A5"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 traits编程技法-STL源码的门钥</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 为什么要使用traits编程技法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#traits%E5%92%8C%E5%81%8F%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 traits和偏特例化</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E5%9E%8B%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 迭代器相应型别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#value_type"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 value_type</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#difference_type"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 difference_type</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#reference"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 reference</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#pointer"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.4 pointer</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#iterator_category"><span class="nav-number">3.2.5.</span> <span class="nav-text">3.2.5 iterator_category</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iterator%E6%BA%90%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA"><span class="nav-number">3.3.</span> <span class="nav-text">3.3.iterator源代码展示</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">4. 序列式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#vector"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 vector</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 扩容机制</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#list"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 list</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 list的迭代器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#list%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 list的数据结构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#deque"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 deque</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#deque%E7%9A%84%E4%B8%AD%E6%8E%A7%E5%99%A8"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 deque的中控器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#deque%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 deque的迭代器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#deque%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3 deque的数据结构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#heap"><span class="nav-number">4.4.</span> <span class="nav-text">4.5. heap</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#push_heap%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.5.1 push_heap算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#pop_heap%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.5.2 pop_heap算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sort_heap%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.3.</span> <span class="nav-text">4.5.3 sort_heap算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#priority_queue"><span class="nav-number">4.5.</span> <span class="nav-text">4.6 priority_queue</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">5. 关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#rb-tree"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 RB-tree</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#rb-tree%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 RB-tree结构体</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#rb-tree%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 RB-tree迭代器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#rb-tree%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.3.</span> <span class="nav-text">5.1.3 RB-tree的数据结构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#set"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 set</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#set%E6%BA%90%E7%A0%81"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 set源码</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 map</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#pair%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 pair类型的定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#map%E6%BA%90%E7%A0%81"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 map源码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#multisetmap"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3 multiset&#x2F;map</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashtable"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 hashtable</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#hashtable%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1 hashtable的迭代器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#hashtable%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.4.2 hashtable的数据结构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hash_set"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 hash_set</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#hash_set%E6%BA%90%E7%A0%81"><span class="nav-number">5.5.1.</span> <span class="nav-text">5.5.1 hash_set源码</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hash_map"><span class="nav-number">5.6.</span> <span class="nav-text">5.6 hash_map</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#hash_map%E6%BA%90%E7%A0%81"><span class="nav-number">5.6.1.</span> <span class="nav-text">5.6.1 hash_map源码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.</span> <span class="nav-text">6. 各个容器的适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">7. 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#stl%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 STL算法分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B4%A8%E5%8F%98%E5%92%8C%E9%9D%9E%E8%B4%A8%E5%8F%98"><span class="nav-number">7.1.1.</span> <span class="nav-text">7.1.1 质变和非质变</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#stl%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F"><span class="nav-number">7.1.2.</span> <span class="nav-text">7.1.2 STL算法的一般形式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88"><span class="nav-number">7.1.3.</span> <span class="nav-text">7.1.3 算法总览</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sort"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 sort</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">7.2.1.</span> <span class="nav-text">7.2.1 适用容器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sort%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">7.2.2.</span> <span class="nav-text">7.2.2 sort实现的原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%89%E7%82%B9%E5%8F%96%E4%B8%AD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="nav-number">7.2.3.</span> <span class="nav-text">7.2.3 三点取中优化方案</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 数值算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#power"><span class="nav-number">7.3.1.</span> <span class="nav-text">7.3.2 power</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#adjacent_difference"><span class="nav-number">7.3.2.</span> <span class="nav-text">7.3.3 adjacent_difference</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 基本算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#equal"><span class="nav-number">7.5.</span> <span class="nav-text">7.4.1 equal</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#fill"><span class="nav-number">7.5.1.</span> <span class="nav-text">7.4.2 fill</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#iter_swap"><span class="nav-number">7.5.2.</span> <span class="nav-text">7.4.4 iter_swap</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#copy"><span class="nav-number">7.5.3.</span> <span class="nav-text">7.4.5 copy</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#copy_backward"><span class="nav-number">7.5.4.</span> <span class="nav-text">7.4.6 copy_backward</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95"><span class="nav-number">7.6.</span> <span class="nav-text">7.5 其他算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#adjacent_find"><span class="nav-number">7.6.1.</span> <span class="nav-text">7.5.1 adjacent_find</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#find"><span class="nav-number">7.6.2.</span> <span class="nav-text">7.5.2 find</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#find_if"><span class="nav-number">7.6.3.</span> <span class="nav-text">7.5.3 find_if</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#find_end"><span class="nav-number">7.6.4.</span> <span class="nav-text">7.5.4 find_end</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#find_first_of"><span class="nav-number">7.6.5.</span> <span class="nav-text">7.5.5 find_first_of</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">827k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:32</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
      <script type="text/javascript">
      function renderGitalk(){
        var gitalk = new Gitalk({
            owner: '',
            repo: '',
            clientID: '123fe329fdbb06b0f1d1',
            clientSecret: '40add829107b6e69f43274d3545ae71c988de8eb',
            admin: '',
            
            });
        gitalk.render('gitalk-container');
      }
      renderGitalk();
      </script>
    
 


</body>
</html>
