<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.说在前面 c++支持两种类--抽象类和具体类。一个抽象类包含着没有实现代码的成员函数（纯虚函数）。具体了类没有纯虚函数。只有具体类才可以实例化（但抽象类实例化指针和引用是运行的），即只能对具体类建立实例或对象。 在这里主要讲解各种数据结构的思想，列举抽象类接口和实现一部分具体类的接口功能。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构(C++实现)">
<meta property="og:url" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:description" content="1.说在前面 c++支持两种类--抽象类和具体类。一个抽象类包含着没有实现代码的成员函数（纯虚函数）。具体了类没有纯虚函数。只有具体类才可以实例化（但抽象类实例化指针和引用是运行的），即只能对具体类建立实例或对象。 在这里主要讲解各种数据结构的思想，列举抽象类接口和实现一部分具体类的接口功能。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/simplelist.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/shuangList.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/jishusort.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/stack.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/kuohao.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/listqueue.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/jiaqueque.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/xunqueue.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/skiplist.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/skiplist.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/binaryTree.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/arrayTree.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/listTree.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/preOrder.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/inOrder.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/postOrder.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/level.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/heapSort.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/heap.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/search.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/insert.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/one.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/two.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/three.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/balanceTree.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/compare.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/Aisnot.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/four.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rightxuan.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rightxuan.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/leftxuan.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/lr.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rl.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rl.gif">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/blackRed.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/brxuan.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/graph.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/linList.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/D.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/D2.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/F.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/F2.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/F3.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/topoSort.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/prim.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/kelusika.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTree.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeInsert.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeDeleteLeaf.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeDeleteNotLeaf.png">
<meta property="og:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeadd.png">
<meta property="article:published_time" content="2022-07-12T14:05:56.000Z">
<meta property="article:modified_time" content="2023-02-24T14:05:41.616Z">
<meta property="article:author" content="trluper">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/simplelist.png">

<link rel="canonical" href="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构(C++实现) | Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构(C++实现)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-12 22:05:56" itemprop="dateCreated datePublished" datetime="2022-07-12T22:05:56+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-24 22:05:41" itemprop="dateModified" datetime="2023-02-24T22:05:41+08:00">2023-02-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>56k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>50 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="说在前面">1.说在前面</h4>
<p>c++支持两种类--<strong>抽象类和具体类</strong>。一个抽象类包含着没有实现代码的成员函数（纯虚函数）。具体了类没有纯虚函数。只有具体类才可以实例化（但抽象类实例化指针和引用是运行的），即只能对具体类建立实例或对象。</p>
<p><strong>在这里主要讲解各种数据结构的思想，列举抽象类接口和实现一部分具体类的接口功能。</strong></p>
<span id="more"></span>
<h4 id="数组">2. 数组</h4>
<h5 id="数组介绍">2.1 数组介绍</h5>
<p>数组是有序表的一种，其内存是在物理上是连续的，对于这种数据结构而言，其优缺点如下： <strong>优点</strong>：</p>
<ul>
<li>支持下标访问随机访问，访问指定位置快时间复杂读为<code>O(1)</code></li>
<li>没有额外的存储空间来存储指针之类的</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>对于插入操作比较麻烦，需要将插入位置后的元素后移一位，造成最坏情况下时间复杂度为O(n)</li>
<li>同时分配的内存是连续，一次性分配，若元素装满后还想插入元素，则需要另外开辟，将原来的元素拷贝过去再插入，造成效率低下。</li>
</ul>
<p>对于数组，不建议自己去写一个类实现，而是使用STL中带有的<code>vetcor</code>，这款容器能实现按1.5或2倍扩容机制增长，且支持迭代器，是C++开发中最长用到的功能齐全的容器。</p>
<h5 id="实现">2.2 实现</h5>
<h6 id="linerlist抽象类">2.2.1 linerList抽象类</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">linearList</span></span><br><span class="line">&#123;		<span class="comment">//抽象类ADT</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">linearList</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> tehIndex)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span>  T&amp;  <span class="keyword">operator</span>[](<span class="type">int</span> theIndex)=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T&amp; elements)</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> theIndex)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> theIndex, <span class="type">const</span> T&amp; theInserElement)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">output</span><span class="params">(std::ostream&amp; os)</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="c实现">2.2.2 C++实现</h6>
<p>在线性表的数组描述中，我们用<strong>一维动态分配的数组<code>element</code></strong>，变量<code>lsitsize</code>表示当前存储的线性表元素个数，用<code>arrayLength</code>表示线性表容量。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">arrayList</span> :<span class="keyword">public</span> linearList&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">arrayList</span>(<span class="type">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">arrayList</span>(<span class="type">const</span> arrayList&lt;T&gt;&amp;);</span><br><span class="line">	~<span class="built_in">arrayList</span>() &#123; <span class="keyword">delete</span>[]element; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> listsize == <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> listsize; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> arrayLength; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> )</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> theIndex)<span class="type">const</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T&amp; element)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> theIndex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> theIndex, <span class="type">const</span> T&amp; theInserElement)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">output</span><span class="params">(std::ostream&amp; os)</span><span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">checkIndex</span><span class="params">(<span class="type">const</span> <span class="type">int</span> indexOf)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">//std::shared_ptr&lt;T[]，end_connection&gt; elememt;	</span></span><br><span class="line">	<span class="comment">//不建议使用智能指针形式的动态数组，</span></span><br><span class="line">	<span class="comment">//因为析构函数使用的是默认delete,而不是delete[],</span></span><br><span class="line">	<span class="comment">//若要使用则应该定义自己得删除器</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increaseLength</span><span class="params">(T*&amp; , <span class="type">int</span> , <span class="type">int</span>)</span></span>;<span class="comment">//扩容操作</span></span><br><span class="line">	T* element;</span><br><span class="line">	std::<span class="type">size_t</span> listsize;</span><br><span class="line">	std::<span class="type">size_t</span> arrayLength;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素，后面的元素向前移动一位</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; arrayLisst&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">int</span> index)&#123;</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;下标访问越界&quot;</span>);</span><br><span class="line">	<span class="built_in">copy</span>(element+index+<span class="number">1</span>,element+listsize,element+index);</span><br><span class="line">	element[--listsize].~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="c实现-1">2.2.3 C实现</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C版本</span></span><br><span class="line"><span class="comment">//结构体定义：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span>	<span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType	*elem;</span><br><span class="line">	<span class="type">int</span>	length;</span><br><span class="line">	<span class="type">int</span>	listsize;</span><br><span class="line"></span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//创建一个顺序表：</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="comment">//分配动态内存，malloc函数返回一个void*的指针，强制转换为ElemType*。</span></span><br><span class="line">	L.elem=(ElemType*）<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="built_in">seziof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span>(!L.elem)<span class="built_in">exit</span>(OVERFLOW);		<span class="comment">//分配内存失败。</span></span><br><span class="line">	L.length=<span class="number">0</span>;					<span class="comment">//初始化为0</span></span><br><span class="line">	L.listsize=LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入前，要把插入的位置后面的元素后移，也就是要先判断插入前的内存是否足够元素插入，</span></span><br><span class="line"><span class="comment">//若不足够，则需要扩容。在进行元素后移，元素插入。其时间复杂度为O(n)</span></span><br><span class="line">Status <span class="built_in">Insert_List</span>(SqList &amp;L，<span class="type">int</span> i,ElemType	e)	<span class="comment">//i为插入的位置，e为要插入的元素</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>&amp;&amp;i&gt;L.length+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;=L.listsize)</span><br><span class="line">	&#123;</span><br><span class="line">		ElemType *newbase=(ElemType*)<span class="built_in">realloc</span>(L.elem,LISTINCREMENT*<span class="built_in">seziof</span>(ElemType));</span><br><span class="line">		<span class="keyword">if</span>(!L.elem)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		L.elem=newbase;</span><br><span class="line">		L.listsize+=LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	ElemType *q=&amp;(L.elem[i<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(Elemtype *p=&amp;(L.elem[length<span class="number">-1</span>];q&gt;=p;p--)</span><br><span class="line">		*(p+<span class="number">1</span>）=*p;</span><br><span class="line">	*q=e;</span><br><span class="line">	++L.length;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作，O(n)</span></span><br><span class="line">Status <span class="built_in">Delet_List</span>(SqList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">	ElemType *q=&amp;((L-&gt;Elem)[i<span class="number">-1</span>]);</span><br><span class="line">	e=*q;</span><br><span class="line">	q+=<span class="number">1</span>;</span><br><span class="line">	ElemType *p=&amp;(L.elme[length<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(q;q&lt;=p;q++)</span><br><span class="line">		*(q<span class="number">-1</span>)=*q;</span><br><span class="line">	L.length-=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//取值操作</span></span><br><span class="line">Status <span class="built_in">GetElem_List</span>(SqList L,<span class="type">int</span> i, ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>&amp;&amp;i&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		e=L.elem[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作</span></span><br><span class="line">Status <span class="built_in">LocateElem_List</span>(SqList L,ElemType e,Status （*compare)(ElemType,ElemType))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>	i=<span class="number">1</span>;</span><br><span class="line">	ElemType *p=l.elem;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=L.length&amp;&amp;<span class="built_in">compare</span>(*p++,e))<span class="comment">//回调函数</span></span><br><span class="line">		i++;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=L.length)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">MergeList</span>(SqList La,SqList Lb,SqList &amp;Lc)</span><br><span class="line">&#123;</span><br><span class="line">	ElemType* pa=La.elem;</span><br><span class="line">	ElemType* pb=Lb.elem;</span><br><span class="line">	ElemType* pa_last=pa+La.length<span class="number">-1</span>;</span><br><span class="line">	ElemType* pb_last=pb+Lb.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	Lc.listsize=La.length+Lb.length;</span><br><span class="line">	Lc.elem=(ElemType*)<span class="built_in">malloc</span>(Lc.listsize*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">	ElemType* pc=Lc-&gt;elem;</span><br><span class="line">	<span class="keyword">if</span>(Lc.elem==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(pa&lt;=pa_last&amp;&amp;pb&lt;=pb_last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*pa&lt;=*pb)</span><br><span class="line">		*pc++=*pa++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		*pc++=*pb++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pa&lt;=pa_last)</span><br><span class="line">		*pc++=*pa++;</span><br><span class="line">	<span class="keyword">while</span>(pb&lt;=pb_last)</span><br><span class="line">		*pc++=*pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表">3. 链表</h4>
<h5 id="单链表介绍">3.1 单链表介绍</h5>
<p>链表克服了数组插入删除时的元素移动步骤，但是代价是牺牲一定的内存来存储指针，其优缺点如下 <strong>优点：</strong></p>
<ul>
<li>链表通过指针来指向下一个元素，带来的好处是插入删除无须移动插入位置后的元素的元素，也不必前移删除位置后的元素，只需要将指针指向后方元素即可。</li>
<li>通过指针来指向下一个元素，这就意味着我们不必像数组那样分配严格物理意义上的联系内存，即使内存不连续，也能成功访问。只有在需要的时候才去创建空间。大小不固定，拓展很灵活。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>因为内存是不联系的，那么链表不支持随机访问，如果访问链表中指定位置节点，只能从头或者尾部进行遍历。</li>
<li>因为除了存储数据，还有存储相应的指针，同一长度的数组和链表，链表会造成内存的消耗多</li>
</ul>
<p><img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/simplelist.png" width="600"></p>
<h5 id="实现-1">3.2 实现</h5>
<h6 id="c实现-2">3.2.1 C++实现</h6>
<p><strong>1.存储结构以及类整体声明及定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++实现</span></span><br><span class="line"><span class="comment">//结构类,其思想同c的数据就跟链表一样，只不过在类内其增加构造函数：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chainNode</span>&#123;</span><br><span class="line">	T element;</span><br><span class="line">	chainNode *next;</span><br><span class="line">	<span class="built_in">chainNode</span>(<span class="type">const</span> T&amp; element)</span><br><span class="line">		&#123;<span class="keyword">this</span>-&gt;element=element;&#125;</span><br><span class="line">	<span class="built_in">chainNode</span>(<span class="type">const</span> T&amp; element,chainNode&lt;T&gt; *next)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;element=element;</span><br><span class="line">		<span class="keyword">this</span>-&gt;next=next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对象类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chain</span>:<span class="keyword">public</span> linearList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">chain</span>(<span class="type">int</span> initialCapacity=<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">chain</span>(<span class="type">const</span> chain&lt;T&gt;&amp;);</span><br><span class="line">	~<span class="built_in">chain</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> listSize==<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> listSize;&#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">get</span><span class="params">(<span class="type">int</span> theIndex)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> theIndex)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> theIndex,<span class="type">const</span> T&amp; theElement)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(ostream&amp; os)</span><span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">checkIndex</span><span class="params">(<span class="type">int</span> theIndex)</span><span class="type">const</span></span>;</span><br><span class="line">	chainNode&lt;T&gt;* firstNode;</span><br><span class="line">	<span class="type">int</span> listSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2. 构造函数和拷贝构造函数</strong></p>
<p>为了创建一个空链表，只需令第一个<code>firstNode</code>的值为<code>NULL</code>，链表不需要预先分配堆空间，它是随用随建立的一个形式。不过为了与<code>arrayList</code>相容，构造函数还是具有一个表示初始容量的形参<code>initialCapacity</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">chain&lt;T&gt;::<span class="built_in">chain</span>(<span class="type">int</span> initialCapacity)&#123;</span><br><span class="line">	<span class="keyword">if</span>(initialCapacity&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;The capacity is wrong&quot;</span>);</span><br><span class="line">	firstNode=<span class="literal">NULL</span>;</span><br><span class="line">	listSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">chain&lt;T&gt;::<span class="built_in">chain</span>(<span class="type">const</span> chain&lt;T&gt;&amp; theList)&#123;</span><br><span class="line">	listSize=theList.listSize;</span><br><span class="line">	<span class="keyword">if</span>(listSize==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		firstNode=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	chainNode&lt;T&gt; *sourceNode=theList.firstNode;		<span class="comment">//使用拷贝构造函数,深拷贝</span></span><br><span class="line">	firstNode=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(sourcNode-&gt;element);</span><br><span class="line">	sourceNode=sourceNode-&gt;next;</span><br><span class="line">	chainNode&lt;T&gt; *intermediateValue=firstNode;</span><br><span class="line">	<span class="keyword">while</span>(sourceNode!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		intermediateValue=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(sourceNode-&gt;element);</span><br><span class="line">		sourceNode=sourceNode-&gt;next;</span><br><span class="line">		intermediate=intermediate-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	intermediate-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">chain&lt;T&gt;::~<span class="built_in">chain</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(firstNode!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		chianNode&lt;T&gt; *nextNode=firstNode-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> firstNode;</span><br><span class="line">		firstNode=nextNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. get函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; chain&lt;T&gt;::<span class="built_in">get</span>(<span class="type">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">checkIndex</span>(theIndex);</span><br><span class="line">	chainNode&lt;T&gt; *targetNode=firstNode;</span><br><span class="line">	<span class="keyword">while</span>(theIndex&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNode=targetNode-&gt;next;</span><br><span class="line">		theIndex--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> targetNode-&gt;element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.插入函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> chain&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">int</span> theIndex,<span class="type">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">checkIndex</span>(theIndex);</span><br><span class="line">	chainNode&lt;T&gt; *newNode=<span class="keyword">new</span> <span class="built_in">chainNode</span>&lt;T&gt;(the Element);</span><br><span class="line">	<span class="keyword">if</span>(theIndex==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		newNode-&gt;next=firstNode;</span><br><span class="line">		firstNode=newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		chainNode&lt;T&gt; *insertLocation=firstNode;</span><br><span class="line">		<span class="keyword">while</span>(theIndex&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			insertLocation=inserLocation-&gt;next;</span><br><span class="line">			theIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		newNode-&gt;next=inserLocation-&gt;next;</span><br><span class="line">		inserLocation-&gt;next=newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	++listSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>5. 删除函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> chain&lt;T&gt;::<span class="built_in">erase</span>(<span class="type">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">checkIndex</span>(theIndex);</span><br><span class="line">	chainNode&lt;T&gt;* eraseNode;</span><br><span class="line">	<span class="keyword">if</span>(theIndex==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		eraseNode=fiirstNode;</span><br><span class="line">		firstNode=eraseNode-&gt;next;</span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		chianNode&lt;T&gt; *frontNode=firstNode;</span><br><span class="line">		<span class="keyword">while</span>(theIndex&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			frontNode=frontNode-&gt;next;</span><br><span class="line">			theIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		eraseNode=frontNode-&gt;next;</span><br><span class="line">		frontNode-&gt;next=eraseNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> eraseNode;</span><br><span class="line">	listSize--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 除单链表外还有:</p>
<ul>
<li>循环链表：我们可以采用两个措施使链表的应用代码简洁高效：①把链表描述成一个单向循环链表。②在链表的前面加一个头结点。</li>
<li>双向链表：即有指向后继的指针，又有指向前驱的指针。</li>
</ul>
<p>这里不再介绍这两个，因为实现跟单链表相似，无非就是加了指针指向。</p>
<h6 id="c实现-3">3.2.2 C实现</h6>
<p><strong>1. 存储结构以及实现结构体</strong></p>
<p><code>LinkList、next</code>是指向结构的指针,用间接访问<code>-&gt;</code>符号。其中<code>LinkList</code>是链表的头指针，若<code>LinkList==NULL</code>(为空指针）,则表示链表为空。有时候我们会把头指针指向的是一个头结点（其数据域不存储任何东西或者存储链表长度等附加信息）,指针域<code>next</code>指向下一个结构。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c版本</span></span><br><span class="line"><span class="comment">//单链表的存储结构设置：</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 建立单链表：这个算法是从尾到表头进行建立的（当然也可以从表头到表尾）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatLinkList</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 L=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">	<span class="comment">//L=(LinkList)malloc(sizeof(LNode));</span></span><br><span class="line">	L-&gt;next==<span class="literal">NULL</span>;		<span class="comment">//建立一带头结点的单链表</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		LNode* p=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">		p-&gt;data=<span class="built_in">scanf</span>();</span><br><span class="line">		p-&gt;next=L-&gt;next;</span><br><span class="line">		L-&gt;next=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 插入操作：从头指针开始达到指定的位置，创建新节点（结构），插入。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">InsertElem</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNoed *p=L-&gt;next;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	s=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));		<span class="comment">//为新结构体分配动态内存</span></span><br><span class="line">	<span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 删除操作：从头指针开始达到指定的位置，改变next指针的指向，释放（free)要删除的结构（节点）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status  <span class="title">DeleteElem</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	LNode *q=p+<span class="number">1</span>;</span><br><span class="line">	p-&gt;next=q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 查找操作：与顺序表一样，应用回调函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(LinkList L,EemType e,<span class="type">int</span> (*compare)(ElemType,ElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=L-next;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="built_in">compare</span>(p-&gt;data,e)))</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="双向链表介绍">3.3 双向链表介绍</h5>
<p>链表的每一个节点给中既有指向下一个结点的指针，也有指向上一个结点的指针，可以快速的找到当前节点的前一个节点，适用于需要双向查找节点值的情况。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/shuangList.png" width="600"> <strong>双链表相对于单链表的优点：</strong></p>
<ul>
<li><strong>删除单链表中的某个节点时，一定要得到待删除节点的前驱，得到其前驱的方法一般是在定位待删除节点的时候一路保存当前节点的前驱</strong>，这样指针的总的的移动操作为2n次，如果是用双链表，就不需要去定位前驱，所以指针的总的的移动操作为n次。</li>
<li><strong>查找时也是一样的，可以用二分法的思路，从头节点向后和尾节点向前同时进行，这样效率也可以提高一倍。</strong></li>
</ul>
<p>但是市场上对于单链表的使用要超过双链表,，因为从存储结构来看，每一个双链表的节点都比单链表的节点多一个指针，如果长度是<code>n</code>，就需要<code>n*lenght</code>（32位是4字节，64位是8字节）的空间，这在一些追求时间效率不高的应用下就不适用了，因为他占的空间大于单链表的<code>1/3</code>，所以设计者就会一时间换空间。</p>
<h5 id="应用">3.4 应用</h5>
<h6 id="箱子排序链表形式">3.4.1 箱子排序(链表形式)</h6>
<p><strong>1. 箱子排序的原理</strong></p>
<p>对于链表因为若用冒泡选择排序，我们时间复制度是为<code>O(n*n)</code>。采用箱子排序会更快，时间复杂度为<code>O(n)</code>。<strong>所谓的箱子排序就是将值相同的节点放到一个箱子内，然后再将排好序的箱子内的链表串接起来形参有序链表。</strong>事先分好各个箱子大小。每一个箱子都是一个链表。一个箱子的节点数目介于<code>0~n</code>之间。它要做的是：</p>
<ul>
<li>逐个删除输入链表，把删除的节点分配到相应的箱子里；</li>
<li>把每一个箱子中的节点连接起来，使其成为一个有序链表；</li>
</ul>
<p><strong><em>注意</em></strong>：箱子排序适用于对有大量重复的数据进行排序，并且数据范围不大。不然试想一下假设有0~10000范围的数据，这个时候我们就得分好并管理10000个箱子，这是很麻烦的。</p>
<p><strong>2. 下面以学生的划分6个优秀等级作为例子</strong></p>
<p>学生结构包含：学生姓名，学生优秀等级。用大小为6的vector<studentStruct>表示分配了6个箱子。代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(2n)</span></span><br><span class="line"><span class="comment">//学生结构类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">studentStruct</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//等级为0，1，2，3，4，5</span></span><br><span class="line">	<span class="type">int</span> rank;		<span class="comment">//方便访问测试，直接将成员变量设为public</span></span><br><span class="line">	string name;</span><br><span class="line">	studentStruct* next;</span><br><span class="line">	<span class="built_in">studentStruct</span>():<span class="built_in">rank</span>(<span class="number">-1</span>),<span class="built_in">name</span>(<span class="string">&quot;&quot;</span>),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">studentStruct</span>(<span class="type">int</span> _rank,string _name):<span class="built_in">rank</span>(_rank),<span class="built_in">name</span>(_name),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">studentStruct</span>(<span class="type">const</span> stduentStrcut&amp; s):<span class="built_in">rank</span>(s.rank),<span class="built_in">name</span>(s.name),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	studentStruct&amp; <span class="keyword">operator</span>=(<span class="type">const</span> studentStruct* s)&#123;</span><br><span class="line">		name=s.name;</span><br><span class="line">		rank=s.rank;</span><br><span class="line">		next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">studentStruct</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箱子排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">boxSort</span><span class="params">(T* head)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//初始化六个空的节点，标识为-1</span></span><br><span class="line">	<span class="function">vector&lt;T*&gt; <span class="title">vec</span><span class="params">(<span class="number">6</span>)</span></span>;		<span class="comment">//当前索引的第一个位置</span></span><br><span class="line">	<span class="function">vector&lt;T*&gt; <span class="title">lastNode</span><span class="params">(<span class="number">6</span>)</span></span>;	<span class="comment">//记录当前索引最后一个节点的位置</span></span><br><span class="line">	<span class="comment">//遍历传入的链表，将学生节点分好箱子</span></span><br><span class="line">	<span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="type">int</span> index = head-&gt;rank % <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">if</span> (vec[index] == <span class="literal">NULL</span>) &#123;<span class="comment">//该位置为空，直接存入</span></span><br><span class="line">			vec[index] = head;</span><br><span class="line">			lastNode[index] = head;	<span class="comment">//刚存入的就是最后一个节点</span></span><br><span class="line">			head = head-&gt;next;</span><br><span class="line">			lastNode[index]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			T* tempNode = head-&gt;next;</span><br><span class="line">			head-&gt;next = lastNode[index]-&gt;next;		<span class="comment">//置NULL</span></span><br><span class="line">			lastNode[index]-&gt;next = head;</span><br><span class="line">			lastNode[index] = head;</span><br><span class="line">			head = tempNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将vector内的各个分散链表串接起来,未使用lastNode版本</span></span><br><span class="line">	T* endNext = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (endNext != <span class="literal">NULL</span>)<span class="comment">//不是第一次进入循环，进行连接</span></span><br><span class="line">			endNext-&gt;next = *it;</span><br><span class="line">		endNext = *it;</span><br><span class="line">		<span class="keyword">while</span> (endNext != <span class="literal">NULL</span> &amp;&amp; endNext-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//endNext!=NULL是防止该所谓位置无值，endNext是索引有值遍历到最后一个</span></span><br><span class="line">			endNext = endNext-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*，将vector内的各个分散链表串接起来，使用lastNode版本 */</span></span><br><span class="line">	T* first=<span class="literal">NULL</span>,*last=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	for(auto i=0;i&lt;lastNode.size();i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		if(last==NULL)&#123;</span></span><br><span class="line"><span class="comment">			last=lastNode[i];</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else if(last!=NULL&amp;&amp;lastNode[i]!=NULL)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			last-&gt;next=vec[i];</span></span><br><span class="line"><span class="comment">			last=lastNode[i];</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></studentStruct></p>
<h6 id="基数排序数组形式">3.4.2 基数排序（数组形式）</h6>
<p>对于上面的箱子排序，对于数据范围很大的数据很难有实践意义，<strong>基数排序</strong>为克服这一点而出现的。基数排序排序主要通过将数字分解进行排序，如三位数的925，技术排序可通过十进制分解，将925分解成9、2、5三个数，然后依次以个位、十位、百位进行排序。<strong>在这个过程中，因为数字只有0~9,所有仅仅需要10个桶就，然后调用三次箱子排序即可</strong>，时间复杂度为O(n<em>m) <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/jishusort.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">potencySort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> num)</span> </span>&#123;	<span class="comment">//num指示按哪位排序</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">tempVec</span>(<span class="number">10</span>);		<span class="comment">//二维数组，内部vector的大小看数据量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> index = vec[i] / num % <span class="number">10</span>;</span><br><span class="line">		tempVec[index].<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	vec.<span class="built_in">clear</span>();		<span class="comment">//清除里面的数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)		<span class="comment">//放回vec</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = tempVec[i].<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">while</span> (it != tempVec[i].<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">			++it;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </em><strong>注意：适用数据重复比较平均的时候，若是全部数据都在一个桶内，则会导致二维数组空间浪费</strong><em>。假设有10000000万数据排序，分配500万，则10</em>500*4=2亿字节，则需要190M内存，因此数据若是分配的比较均匀，则秩序分配200万，需要内存76M就足够了</p>
<h6 id="并查集">3.4.3 并查集</h6>
<p>要知道什么是<strong>并查集</strong>，就要先知道什么是<strong>等价类</strong>。所谓的<strong>等价类</strong>就是指再一个给的n元素的集合R中有两两配对的等价关系且已经是等价关系的最大<strong>集合</strong>（等价类是集合），<strong>如<code>n=14.R=&#123;(1,11),(7,11),(2,12),(12,8),(11,12),(3,13),(13,14)&#125;</code>,如果<code>(a,b)∈R</code>则<code>a,b</code>两个类是等价的，且不能在外部找到其他等价关系。</strong>等价具有自反性、对称性、传递性。即：</p>
<ul>
<li>若<code>a∈R</code>，则<code>(a,a)</code>必属于R，自反性</li>
<li>若<code>(a,b)∈R</code>，则必有<code>(b,a)∈R</code>，对称性</li>
<li>若<code>(a,b)∈R，(b,c)∈R</code>，则<code>(a,c)∈R</code>，传递性</li>
</ul>
<p>等价类分为<strong>离线等价类</strong>和<strong>在线等价类</strong>。在线等价类又称为<strong>并查集</strong></p>
<ul>
<li>离线等价类：n和R已知，确定了所有的等价类关系，且每个元素只能属于一个等价类，即只能在一个集合R</li>
<li><p><strong>在线等价类（并查集）</strong>：初始又n个元素，每个元素刚开始都属于一个独立的等价类。需要执行以下的步骤：</p></li>
<li><code>conbine(a,b)</code>,把包含a和b的等价类合并成一个等价类</li>
<li><p><code>find(theElement)</code>,确定元素在哪一个等价类，目的是对给定的两个元素，确定是否属于同一个类，对同一类元素返回相同结果，否则返回不同结果</p></li>
</ul>
<p><strong>经典的机器调度和布线问题，后续树会讲到</strong></p>
<h4 id="栈">4. 栈</h4>
<h5 id="栈的介绍">4.1 栈的介绍</h5>
<p>栈是一种重要的线性结构，通常称，<strong>栈和队列是限定插入和删除只能在表的“端点”进行操作的线性表。</strong></p>
<ul>
<li>栈的元素必须<code>“后进先出LIFO“</code>。</li>
<li>栈的操作只能在这个线性表的表尾进行。</li>
<li>对于栈来说，这个表尾称为栈的栈顶（top），相应的表头称为栈底（bottom）。</li>
<li>因为栈的本质是一个线性表，线性表有两种存储形式，那么栈也有分为栈的顺序存储结构和栈的链式存储结构。</li>
<li>最开始栈中不含有任何数据，叫做空栈，此时栈顶就是栈底。然后数据从栈顶进入，栈顶栈底分离，整个栈的当前容量变大。数据出栈时从栈顶弹出，栈顶下移，整个栈的当前容量变小。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/stack.gif" width="500"></li>
</ul>
<h5 id="实现-2">4.2 实现</h5>
<p>栈的<strong>顺序存储结构</strong>是利用一组<strong>地址连续的存储单元</strong>依次存放自栈底到栈顶的数据元素，同时附设指针<code>top</code>指示栈顶元素在顺序栈中的位置，先为栈分配一个合理的容量，在应用过程中，当栈的空间不够时再逐渐扩大。</p>
<p>按设定的的初始分量进行第一次存储分配，<code>base</code>可称为栈底指针，在顺序栈中，它始终指向栈底位置。若为<code>base</code>的值为<code>NULL</code>，则表明<strong>栈结构不存在</strong>。<code>top</code>为栈顶指针，其初值指向栈底，既<code>top=base</code>作为<strong>栈空</strong>的标记，每当压入心得栈顶元素时，栈顶<code>top+1</code>，删除<code>-1</code>.因此非空栈的栈顶指针始终在栈顶元素的下一个位置上</p>
<h6 id="c实现-4">4.2.1 C++实现</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Stack</span>();</span><br><span class="line">	<span class="built_in">stack</span>(<span class="type">int</span> cap):<span class="built_in">capacity</span>(cap),<span class="built_in">elements</span>(<span class="keyword">new</span> T[capacity])&#123;&#125;</span><br><span class="line">	<span class="built_in">Stack</span>(<span class="type">const</span> Stack&amp;);</span><br><span class="line">	Stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Stack&amp;);</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Stack</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">capacity</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">increaseCapaciyu</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="type">int</span> base=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> capacity=<span class="number">10</span>;</span><br><span class="line">	T* elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="c实现-5">4.2.2 C实现</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序栈的存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  STACKINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType *base;</span><br><span class="line">	ElemType  *top;</span><br><span class="line">	<span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个顺序栈：注意此时top=base;</span></span><br><span class="line"><span class="function">status <span class="title">InitialStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//构造一个空栈</span></span><br><span class="line">	s.base=(ElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span>（S.base==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stackszie=STACK_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶元素：先判断栈不空</span></span><br><span class="line"><span class="function">status <span class="title">GetTopElem</span><span class="params">(SqStack S,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//取栈顶元素</span></span><br><span class="line">	<span class="keyword">if</span>(S.base==S.top)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	e=*(S.top<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素：判断当前的容量是否足够吗、不够则增加，再插入</span></span><br><span class="line"><span class="function">status 	<span class="title">PushElem</span><span class="params">(SqStack &amp;S,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//插入栈顶元素</span></span><br><span class="line">	<span class="type">int</span> length=(S.top-S.base)/<span class="built_in">sizeof</span>(ElemType);</span><br><span class="line">	<span class="keyword">if</span>(length&gt;=S.stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		ElemType *newbase=(ElemType*)<span class="built_in">realloc</span></span><br><span class="line">			(S.base,(S.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">		<span class="keyword">if</span>(newbase==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		S.base=newbase;</span><br><span class="line">		S.top=S.base+S.stacksize;</span><br><span class="line">		S.stacksize+=STACKINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++=e;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素：</span></span><br><span class="line"><span class="function">Status <span class="title">pop</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	e=*--S.top;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="应用-1">4.3 应用</h5>
<p>栈的能应用于各式各样的后进先出的地方，比如表达式括号匹配，四则运算、迷宫问题等。</p>
<h6 id="健壮四则运算">4.3.1 健壮四则运算</h6>
<p><strong>我的思路：</strong></p>
<ul>
<li>1、把输入的式子中其它<code>&#123;&#125;[]</code>转化为<code>()</code>的形式</li>
<li>2、输入的式子可能有负值，将其转化为减法运算，既前面加0</li>
<li>3、对于<code>(</code>和空运算符栈情况下，运算符直接入栈</li>
<li>4、数字判断长度后，转化为int入栈</li>
<li>5、对于<code>* /</code>，运算符栈顶元素若是同级，则栈顶元素出栈运算，这样避免同出现<code>8/2/2=8</code>的情况</li>
<li>6、对于<code>+ -</code>同级或高级的栈顶运算符也要出栈运算，注意<code>2-2*3+2</code>的特殊情况处理，代码129-142就是处理这种情况。</li>
<li>7、对于)，则直接出栈运算直到(即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">change_bracket</span><span class="params">(string&amp; str)</span></span>;    <span class="comment">//改变&#x27;&#123;&#x27;[&#x27;为&#x27;(&#x27;,改&#x27;]&#x27;,&#x27;&#125;&#x27;为&#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">addZero</span><span class="params">(string&amp; str)</span></span>;    <span class="comment">//判断表达式的是否为有负值，有则前面加0,改为减法</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">handler</span><span class="params">(string&amp; str)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">caculate</span><span class="params">(<span class="type">char</span> s, <span class="type">int</span> a, <span class="type">int</span> b)</span></span>;    <span class="comment">//进行计算</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line">    <span class="built_in">change_bracket</span>(input);</span><br><span class="line">    <span class="built_in">addZero</span>(input);</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">handler</span>(input);</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_bracket</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;&#123;&#x27;</span> || *it == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            *it = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;&#125;&#x27;</span> || *it == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            *it = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addZero</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*str.<span class="built_in">begin</span>() == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>(), <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m = str.<span class="built_in">begin</span>() + <span class="number">1</span>; m != str.<span class="built_in">end</span>(); m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (((*m == <span class="string">&#x27;-&#x27;</span> &amp;&amp; *(m - <span class="number">1</span>) &lt; <span class="string">&#x27;0&#x27;</span>) || (*m == <span class="string">&#x27;-&#x27;</span> &amp;&amp; *(m - <span class="number">1</span>) &gt; <span class="string">&#x27;9&#x27;</span>))&amp;&amp;*(m<span class="number">-1</span>)!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            m = str.<span class="built_in">insert</span>(m, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">caculate</span><span class="params">(<span class="type">char</span> s, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (s)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        c = a * b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        c = a / b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        c = a + b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        c = a - b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">handler</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; in_num;      <span class="comment">//数字栈</span></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; in_char;    <span class="comment">//运算符栈</span></span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">        &#123;<span class="comment">//处理数字</span></span><br><span class="line">            <span class="type">int</span> j = i, num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; str.<span class="built_in">length</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[i + <span class="number">1</span>]))</span><br><span class="line">             &#123;  i++;		&#125;</span><br><span class="line">            <span class="comment">//拷贝子串数字</span></span><br><span class="line">            string str_num = str.<span class="built_in">substr</span>(j, i - j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; str_num.<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;<span class="comment">//转为数字</span></span><br><span class="line">                num = num * <span class="number">10</span> + str_num[k] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//压入数字栈</span></span><br><span class="line">            in_num.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理(，空运算符栈，直接压入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;(&#x27;</span> || in_char.<span class="built_in">empty</span>())</span><br><span class="line">            in_char.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        <span class="comment">//处理*,/，既同级的直接前一个先算</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>() &amp;&amp; (tmp == <span class="string">&#x27;/&#x27;</span> || tmp == <span class="string">&#x27;*&#x27;</span>))<span class="comment">//要弹出/进行计算</span></span><br><span class="line">            &#123;</span><br><span class="line">                b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                in_char.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            in_char.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理+ -</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//同理，同级和高级的先处理</span></span><br><span class="line">            tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>() &amp;&amp; (tmp == <span class="string">&#x27;+&#x27;</span> || tmp == <span class="string">&#x27;-&#x27;</span> || tmp==<span class="string">&#x27;*&#x27;</span> ||tmp==<span class="string">&#x27;/&#x27;</span> ))</span><br><span class="line">            &#123;</span><br><span class="line">                b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                in_char.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (tmp == <span class="string">&#x27;+&#x27;</span> || tmp == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                    in_num.<span class="built_in">pop</span>();</span><br><span class="line">                    a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                    in_num.<span class="built_in">pop</span>();</span><br><span class="line">                    in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                    in_char.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            in_char.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                a = in_num.<span class="built_in">top</span>();</span><br><span class="line">                in_num.<span class="built_in">pop</span>();</span><br><span class="line">                in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">                in_char.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//更新tmp</span></span><br><span class="line">                tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出(</span></span><br><span class="line">            in_char.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!in_char.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = in_char.<span class="built_in">top</span>();</span><br><span class="line">        b = in_num.<span class="built_in">top</span>();</span><br><span class="line">        in_num.<span class="built_in">pop</span>();</span><br><span class="line">        a = in_num.<span class="built_in">top</span>();</span><br><span class="line">        in_num.<span class="built_in">pop</span>();</span><br><span class="line">        in_num.<span class="built_in">push</span>(<span class="built_in">caculate</span>(tmp, a, b));</span><br><span class="line">        in_char.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in_num.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="括号匹配">4.3.2 括号匹配</h6>
<p>给的一个括号字符串，判断这个字符串是否有效即括号是否匹配。有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/kuohao.gif" width="200"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketsOK</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	stack&lt;<span class="type">char</span>&gt; in_char;</span><br><span class="line">	<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (it != s.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">&#x27;(&#x27;</span> || *it == <span class="string">&#x27;&#123;&#x27;</span> || *it == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">			in_char.<span class="built_in">push</span>(*it);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="type">char</span> c = in_char.<span class="built_in">top</span>();</span><br><span class="line">			in_char.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> &amp;&amp; (c + <span class="number">1</span>) != *it)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &amp;&amp; (c + <span class="number">2</span>) != *it)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!in_char.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="队列">5. 队列</h4>
<p><strong>队列是一先进先出的线性结构，允许插入的一端叫做队尾，允许删除的一端叫队头。</strong></p>
<h5 id="链队列">5.1 链队列</h5>
<p>一个链队列需要两个分别<strong>指示队头和队尾的指针（头指针和尾指针）</strong>才能唯一确定。和线性表的单链表一样，为操作方便，也给队列添加一头结点，并令头指针指向头结点。所以空队列的判决条件为头指针和尾指针均指在头结点。链队列的操作为单链表插入和删除操作的特殊情况，只需修改尾指针和头指针即可。读取时的时间复杂度为O(1)。插入、删除时的时间复杂度为O(1)。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/listqueue.png" width="500"> <strong>优点：</strong></p>
<ul>
<li>相比普通的队列，元素出队时无需移动大量元素，只需移动头指针。</li>
<li>可动态分配空间，不需要预先分配大量存储空间。</li>
<li>适合处理用户排队等待的情况。</li>
</ul>
<p><strong>缺点：</strong> -- 需要为表中的逻辑关系增加额外的存储空间。</p>
<h5 id="循环队列">5.2 循环队列</h5>
<p>在循环队列中，空队特征是front = rear, 队满时也会有front = rear; 判断条件将出现二义性（到底是空还是满？） <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/jiaqueque.png" width="500"> <strong>解决方案有三种：</strong></p>
<ul>
<li><ol type="1">
<li>加设标志位，让删除动作使其为1，插入动作使其为0， 则可识别当前front == rear;</li>
</ol></li>
<li><ol start="2" type="1">
<li>使用一个计数器记录队列中元素个数（即队列长度）</li>
</ol></li>
<li><ol start="3" type="1">
<li>人为浪费一个单元，令队满特征为 front = (rear +1)%N---空闲单元法</li>
</ol></li>
</ul>
<p><strong>这里采用空闲单元法解决二义性问题。</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/xunqueue.gif" width="500"></p>
<h5 id="实现-3">5.3 实现</h5>
<p>这里我们均采用C来实现链队列和循环队列</p>
<h6 id="链队列实现">5.3.1 链队列实现</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链队列的存储结构：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">QNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType	data;</span><br><span class="line">	<span class="keyword">struct</span>  <span class="title class_">QNode</span>  *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	QueuePtr front;	<span class="comment">//队头指针（指向头结点）</span></span><br><span class="line">	QueuePtr  rear;	<span class="comment">//队尾指针（指向尾结点）</span></span><br><span class="line">&#125;LinkQueue</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链队列：</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//构造一空队列</span></span><br><span class="line">	Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">	Q.front=Q.rear;	<span class="comment">//队头队尾指针均指向头结点。</span></span><br><span class="line">	<span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列：</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(Q.front!=<span class="literal">NULL</span>)&#123;		<span class="comment">//从队头开始一步步free队头</span></span><br><span class="line">		Q.rear=Q.front-&gt;next;     <span class="comment">//队尾移至队头结点的下一个结点（结构体）</span></span><br><span class="line">		<span class="built_in">free</span>(Q.front);			<span class="comment">//释放动态内存</span></span><br><span class="line">		Q.front=Q.rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入操作：从队尾插入</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QNode *p=(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">	<span class="comment">//QNode *p=(QNode*)malloc(sizeof(QNode));</span></span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	p-&gt;data=e;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q.rear-&gt;next=p;</span><br><span class="line">	Q.rear=p;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function">Status <span class="title">DeletQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)<span class="keyword">return</span> ERROR;</span><br><span class="line">	QNode *p=Q.front-&gt;next;</span><br><span class="line">	e=p-&gt;data;</span><br><span class="line">	Q.front-&gt;next=p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==p)<span class="comment">//判断是否为空了，若空了，则队头和队尾指向头结点（相等）。</span></span><br><span class="line">		Q.rear=Q.front;</span><br><span class="line">	<span class="built_in">free</span>(p)</span><br><span class="line">	<span class="keyword">return</span> OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="跳表和哈希散列">6. 跳表和哈希散列</h4>
<p>有序链表、有序数组、跳表和哈希表的渐进性能如下：</p>
<table>
<thead>
<tr class="header">
<th>数据结构</th>
<th>最坏情况</th>
<th>平均情况</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>有序数组</td>
<td>查找<code>O(lngn)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(lngn)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
</tr>
<tr class="even">
<td>有序链表</td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
</tr>
<tr class="odd">
<td>跳表</td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(logn)</code>、插入<code>O(logn)</code>、删除<code>O(logn)</code></td>
</tr>
<tr class="even">
<td>哈希表</td>
<td>查找<code>O(n)</code>、插入<code>O(n)</code>、删除<code>O(n)</code></td>
<td>查找<code>O(1)</code>、插入<code>O(1)</code>、删除<code>O(1)</code></td>
</tr>
</tbody>
</table>
<p>在C+的STL中适用了哈希散列的容器有：<code>unordered_map、unordered_set、hash_map、hash_multimap、hash_multiset、hash_set</code></p>
<h5 id="跳表">6.1 跳表</h5>
<p>对于有序数组，我们进行二分查找所需要的时间为<code>O(logn)</code>。但是在有序链表上仍然需要的时间为<code>O(n)</code>，<strong>为了提高有序链表的查找性能，可以在全部或者部分节点增加额外的指针，在查找时，通过这些指针，可以跳过链表的若干个点，不必查看所有节点来寻找</strong> <strong>调表</strong>采用<strong>随机技术</strong>来决定链表的哪些节点应增加额外的指针，以及增加多少个指针，基于这种技术，跳表的查找、插入、删除的<strong>平均时间复杂度为<code>O(logn)</code></strong>,最坏情况为<code>O(n)</code>. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构skipNOde</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">skipNode</span>&#123;</span><br><span class="line">	K element;</span><br><span class="line">	skipNode&lt;K&gt; **next;			<span class="comment">//指针数组</span></span><br><span class="line">	<span class="built_in">skipNode</span>(<span class="type">const</span> K&amp; ele,<span class="type">int</span> size):</span><br><span class="line">		<span class="built_in">element</span>(ele)&#123;next=<span class="keyword">new</span> skipNode&lt;K&gt;* [size];&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体的指针域有next数组统一管理，next[i]表示i级链表的指针，元素存储在element内</span></span><br></pre></td></tr></table></figure></p>
<h6 id="实现原理">6.1.1 实现原理</h6>
<p>在一个用有序链表中查找指定值，至多需要N次值的比较。如果链表的中部节点加一个指针，则比较次数可以减少到<code>N/2+1</code>。这个时候我们在查找一个数时，首先是与中部的这个节点进行值比较，如果查找的数对关键字小，则只在左半部分继续查找，若大，则在右半部分查找。如下图所示: <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/skiplist.gif" width="500"> 上图非常形象的展现了跳表的查找操作：如果跳表有多级索引，如图建立了一级索引，则从一级索引出发.</p>
<p><strong>1. 索引级数的分配</strong></p>
<ul>
<li>在跳表中对<code>n</code>个元素而言，以均等分<code>p=0.5</code>,则最多可有链表级数为<code>maxLevel=logn-1</code>。</li>
<li>对于第<code>i</code>级链表，每<code>2^i</code>个元素取一个进行连接 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/skiplist.png" width="500"></li>
</ul>
<p><strong>2. 插入和删除</strong></p>
<p>在插入和删除的时候，如果要保持索引级数分配的规则结构，要耗时<code>O(n)</code>，我们指定i级链表有<code>n/(2^i)</code>个元素，在插入的时候新数据属于<code>i</code>级链表的概率为<code>1/(2^i)</code>。</p>
<p><strong>插入步骤：</strong></p>
<ul>
<li>进行查找<code>O(logn)</code>，找到要插入的位置</li>
<li>插入时，要为新数据分配一个级，分配过程就是我们之前说的<strong>随机数生成器</strong>完成（随机数只是尽可能的维护这种结构规则，不是严格意义上的）</li>
<li>当新数据插入<code>i</code>级链表的时候，只会对<code>0~i</code>级链表产生影响，因此要记住这些链表的前驱</li>
<li>然后只需对next[0~i]进行重新next指针指向</li>
</ul>
<p>对于删除，我们无法控制结构即没有生成随机数操作来中和，<strong>删除操作：</strong></p>
<ul>
<li>要删除指定节点，就必须先找到该节点所在处</li>
<li>知道节点的所找链表级数<code>i</code>，则只会影响<code>0~i</code>级的链表</li>
<li>对<code>0~i</code>级进行<code>next</code>指针重指向</li>
</ul>
<p><strong>为什么插入要随机数：</strong>试想一下，如果插入一直指定一个级数去插入，那么极端情况下将会使跳表退化成单链表，也就失去了跳表的作用，作为一种动态数据结构，我们需要某种手段来维护级数与元素个数之间的平衡。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> skipList&lt;T&gt;::<span class="built_in">level</span>()<span class="type">const</span>&#123;</span><br><span class="line">	<span class="comment">//返回一个链表级数随机数</span></span><br><span class="line">	<span class="type">int</span> lev=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">rand</span>()&lt;=cutoff)</span><br><span class="line">		lev++;</span><br><span class="line">	<span class="keyword">return</span> (lev&lt;maxLevel)?lev:maxLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="哈希表散列表">6.2 哈希表（散列表）</h5>
<p><strong>哈希表就是根据设定的哈希函数和处理冲突的方法将关键字映射到一个有限的连续的地址集（哈希数组）</strong>。当关键字的范围太大，不能用理想方法表示时，可以采用并不理想的哈希表和哈希函数：哈希表的位置的数量比关键字少，哈希函数把若干个不同关键字映射到哈希表的同一个位置（哈希表的每一个位置叫一个桶），桶的数量等于哈希表的长度。</p>
<p>构造哈希表，最常遇到的问题无非就是：</p>
<ul>
<li><strong>冲突</strong>：当两个不同关键字经哈希函数计算后的桶相同时，冲突就发生了。但这对于一个桶可以容纳多个数对的桶来说，并没有什么影响</li>
<li><strong>溢出</strong>：桶没有位置可以存储新的数对，就会溢出</li>
</ul>
<h6 id="实现原理-1">6.2.1 实现原理</h6>
<p><strong>哈希表的建立会适用特定的哈希函数将关键字进行计算转化生成我们访问的下标</strong>，这样就能够建立起<strong>访问、插入、删除</strong>的<code>O(1)</code>操作。因此最重要的是哈希函数的选择和对下标的实现。构造哈希函数的原则是：</p>
<ul>
<li><strong>①函数本身便于计算；</strong></li>
<li><strong>②计算出来的地址分布均匀，即对任一关键字k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突。</strong></li>
</ul>
<p>以下是对哈希函数的常用思想：</p>
<ul>
<li><strong>直接定址法</strong>：<strong>取关键字某个线性函数值为哈希地址</strong>，即<code>H(key)=a*key+b</code></li>
<li><strong>数字分析法</strong>：<strong>前提关键字都是知道的，在此基础上分析数据，依数据选择取哪些位作为<code>key</code>值</strong>。例子：比如现有<code>80</code>个<code>8</code>位的十进制数，只能分配长为<code>100</code>的哈希表供你使用，此时就要依据这<code>8</code>位中哪些位取值分散而从中选取2位为哈希地址来尽可能避免冲突。</li>
<li><strong>平方取中法</strong>：<strong>取关键字平方后的中间几位为哈希地址</strong>，平方取中法比较适用于不清楚关键字的分布，且位数也不是很大的情况。</li>
<li><strong>折叠法</strong>：<strong>将关键字分成位数相同的几部分（最后一部分的位数可以不同），然后取这些部分叠加和作为哈希地址</strong>。折叠法比较适用于不清楚关键字的分布，但是关键字位数较多 的情况</li>
<li><strong>除留余数法</strong>：<strong>取关键字被某个不大于哈希表长m的数<code>p</code>除后所得余数为哈希地址</strong>，即<code>h（k）=k  %  p</code> ，其中<code>%</code>为模p取余运算。一般<code>p</code>选为质数</li>
<li><strong>位与法</strong>：哈希数组的长度一般选择2的幂，在C/C++中位运算相对较为高效，选择2的幂作为数组长度，可以将取模运算转换成<strong>二进制位与</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//专业版hash&lt;string&gt;</span></span><br><span class="line"><span class="comment">//将string关键字转换为size_t的整型哈希值</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash</span>&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string thekey)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> hashValue=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> length=(<span class="type">int</span>) theKey.<span class="built_in">length</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">			hashValue=<span class="number">5</span>*hashValue+thekey.<span class="built_in">at</span>(i);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_t</span>(hashValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="解决hash冲突方案">6.2.2 解决hash冲突方案</h6>
<ul>
<li><strong>开放定址法</strong>: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</li>
<li><strong>再哈希法</strong>：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。</li>
<li><strong>链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中</strong></li>
<li><strong>建立公共溢出区</strong>：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。</li>
</ul>
<h4 id="二叉树">7. 二叉树</h4>
<h5 id="树的概念">7.1 树的概念</h5>
<p>树型结构是一类重要的非线性结构。树（Tree)是n个结点的有限集，在任一非空树中：</p>
<ul>
<li>有且只有一个特定的称为根（Root)的结点，没有前驱的结点称为根结点。</li>
<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、T3.....Tm，每一个集合本身又是一颗树，并且称为根Root的子树。</li>
<li>每一个非根结点有且只有一个父结点；</li>
</ul>
<p><strong>基本术语</strong>：</p>
<ul>
<li><strong>节点的度：一个节点含有的子树的个数称为该节点的度</strong></li>
<li><strong>叶子：度为0的节点</strong></li>
<li><strong>非终端节点或分支节点</strong>：度不为零的节点；</li>
<li><strong>树的度</strong>：树内所有节点的度的最大值；</li>
<li><strong>双亲节点或父节点</strong>：若一个结点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点或子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li><strong>堂兄弟节点</strong>：双亲在同一层的节点互为堂兄弟；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙；</li>
<li><strong>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</strong></li>
<li><strong>树的高度或深度：树中节点的最大层次；</strong></li>
<li>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
<li><strong>有序树/无序树：如果将树中节点的各个子树看成从左到右是有次序的，则称该树为有序树，否则为无序树；</strong></li>
</ul>
<h5 id="二叉树-1">7.2 二叉树</h5>
<p>二叉树是另一种树型结构，它的特定是每个结点至多只有两棵子树。且二叉树的子树有左右之分，其次序不能任意颠倒。也可为空树。<strong>二叉树和树的根本区别是：</strong></p>
<ul>
<li>二叉树的每个元素恰好有两颗子树。而树可有任意数量的子树</li>
<li>在二叉树中，每个元素的子树都是有序的，即左子树和右子数之分。而树的子树是无序的</li>
<li>二叉树可以为空。而树不能为空</li>
</ul>
<h5 id="二叉树特性">7.3 二叉树特性</h5>
<p>二叉树具有较多的特性，使用也比较广泛：</p>
<ul>
<li><strong>在二叉树的第<code>i</code>层上至多有<code>2^(i-1)</code>个结点<code>i&gt;=1</code>;</strong></li>
<li>深度为K的二叉树至多有<code>2^(k)-1</code>个结点<code>K&gt;=1</code>;</li>
<li><strong>对任何一颗二叉树<code>T</code>，如果其终端结点数为<code>n0</code>，度为2的结点数为<code>n2</code>，则<code>n0=n2+1</code>;</strong></li>
<li>具有n个结点的完全二叉树的深度为<code>L[log2(n)]+1</code>;<code>(L[X]表示取不大于X的最大整数）</code></li>
<li><strong>如果对一颗有<code>n</code>个结点的完全二叉树（深度为<code>L[log2(n)]+1</code>）的结点按层序编号（从第一层到<code>L[log2(n)]+1</code>层，每层从左到右），则对任一结点<code>i(1&lt;=i&lt;=n)</code>,，有：</strong></li>
<li>①<code>i=1</code>，则结点<code>i</code>是二叉树的根，无双亲；<code>i&gt;1</code>,则其双亲时结点<code>[i/2]</code></li>
<li>②如果<code>2i&gt;n</code>，则结点<code>i</code>无左孩子，否则其左孩子为<code>2i</code></li>
<li>③如果<code>2i+1&gt;n</code>，则结点无右孩子，否则其右孩子为<code>2i+1</code></li>
</ul>
<p><strong>满二叉树和完全为叉树</strong>： <strong>满二叉树：</strong>当高度为<code>h</code>的二叉树恰好有<code>2^h-1</code>个元素时，为满二叉树 <strong>完全二叉树：</strong>最后一层的叶子只能空右左节点，不能有右节点而没有左节点,下图为完全被二叉树 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/binaryTree.png" width="400"></p>
<h5 id="二叉树的存储结构">7.4 二叉树的存储结构</h5>
<p>二叉树的存储结构一般有顺序存储和链式存储。顺序存储也成为数组形式的描述，而链式存储是二叉树最常用的存储结构，它是用两个左右孩子指针指向其左右孩子节点。</p>
<h6 id="顺序存储">7.4.1 顺序存储</h6>
<p>顺序存储就是用一组地址连续的存储单元依次至上而下、从左到右存储完全二叉树的节点元素，所以顺序存储结构仅适用于完全二叉树和满二叉树（否则会造成空间浪费）。二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。如上图的完全二叉树在数组形式的存储如下： <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/arrayTree.png" width="400"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> ElemType sqBiTree[MAX_TREE_SIZE];</span><br><span class="line">sqBiTree bt;</span><br></pre></td></tr></table></figure></p>
<h6 id="链式存储结构">7.4.2 链式存储结构</h6>
<p>既然顺序存储不能满足二叉树的存储需求，那么考虑采用链式存储。由二叉树定义可知，二叉树的每个结点最多有两个孩子。因此，可以将结点数据结构定义为一个数据和两个指针域。表示方式如图 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/listTree.png" width="300"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> stuct BiTNode&#123;</span><br><span class="line">TElemType data;</span><br><span class="line">strcut BiTNode *lchild,*rchlid;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></p>
<h5 id="实现-4">7.5 实现</h5>
<p>对于二叉树的实现这里主要讲解C++语言的实现</p>
<h6 id="结构体和实现类">7.5.1 结构体和实现类</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点类，用于构建树中的节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTreeNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T data;</span><br><span class="line">	binaryTreeNode&lt;T&gt;* lchid,* rchild;</span><br><span class="line">	<span class="built_in">binaryTreeNode</span>() :<span class="built_in">lchild</span>(<span class="literal">NULL</span>),<span class="built_in">rchild</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTreeNode</span>(<span class="type">const</span> T&amp; _data) :<span class="built_in">data</span>(_data),<span class="built_in">lchild</span>(<span class="literal">NULL</span>),<span class="built_in">rchild</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTreeNode</span>(<span class="type">const</span> T&amp; _data,binaryTreeNode&lt;T&gt;* left,binaryTreeNode&lt;T&gt;* right) :</span><br><span class="line">		<span class="built_in">data</span>(_data),<span class="built_in">lchild</span>(left),<span class="built_in">rchild</span>(right) &#123;&#125;</span><br><span class="line">	~<span class="built_in">binaryTreeNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">binaryTree</span>() :<span class="built_in">size</span>(<span class="number">1</span>), <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">binaryTreeNode</span>&lt;T&gt;()) &#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTree</span>(<span class="type">const</span> T&amp; _data):<span class="built_in">size</span>(<span class="number">1</span>),<span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">binaryTreeNode</span>&lt;T&gt;(_data))&#123;&#125;</span><br><span class="line">	<span class="built_in">binaryTree</span>(binaryTreeNode&lt;T&gt;* node) :<span class="built_in">size</span>(<span class="number">1</span>), <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">binaryTreeNode</span>&lt;T&gt;(node-&gt;data, node-&gt;lchid, node-&gt;rchild)) &#123;&#125;</span><br><span class="line">	~<span class="built_in">binaryTree</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">binaryTreeNode&lt;T&gt;* <span class="title">getRoot</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTree&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">leveltOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">indsert</span><span class="params">(binaryTreeNode&lt;T&gt;* insert_Node)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">del</span><span class="params">(<span class="type">int</span> index)</span></span>;						<span class="comment">//使用层次遍历定位</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::<span class="type">size_t</span> <span class="title">height</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::<span class="type">size_t</span> size;</span><br><span class="line">	binaryTreeNode&lt;T&gt;* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="前序遍历">7.5.2 前序遍历</h6>
<p>前序遍历是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/preOrder.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Node==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(Node-&gt;data);</span><br><span class="line">	<span class="built_in">preOrder</span>(vec,Node-&gt;lchild);</span><br><span class="line">	<span class="built_in">preOrder</span>(vec,Node-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归版本,使用栈这个辅助数据结构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	stack&lt;binaryTreeNode&lt;T&gt;*&gt; _sta;</span><br><span class="line">	<span class="keyword">if</span>(Node!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">auto</span> p=Node;</span><br><span class="line">		<span class="keyword">while</span>(!_sta.<span class="built_in">empty</span>()||p!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">				vec.<span class="built_in">push_back</span>(p-&gt;data);</span><br><span class="line">				_sta.<span class="built_in">push</span>(p);</span><br><span class="line">				p=p-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!_sta.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				p=_sta.<span class="built_in">top</span>();</span><br><span class="line">				_sta.<span class="built_in">pop</span>();</span><br><span class="line">				p=p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="中序遍历">7.5.3 中序遍历</h6>
<p>中序遍历就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/inOrder.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTree&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Node==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inOrder</span>(vec,Node-&gt;lchild);</span><br><span class="line">	vec.<span class="built_in">push_back</span>(Node-&gt;data);</span><br><span class="line">	<span class="built_in">inOrder</span>(vec,Node-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 非递归使用栈结构进行辅助 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">binaryTree&lt;T&gt; *<span class="title">GoFarLeft</span><span class="params">(binaryTree&lt;T&gt;* t,stack&lt;binaryTreeNode&lt;T&gt;*&gt; &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//找到t树的最左孩子的指针，用指针返回，同时压栈所有遍历过的最左指针</span></span><br><span class="line">	<span class="keyword">if</span>(!t)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(t-&gt;lchild)&#123;</span><br><span class="line">		S.<span class="built_in">push</span>(t);</span><br><span class="line">		t=t-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec,binaryTree&lt;T&gt;*	root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;binaryTreeNode&lt;T&gt;*&gt; _sta</span><br><span class="line">	aotu t=<span class="built_in">GoFarLeft</span>(root,_sta);</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(t-&gt;data);</span><br><span class="line">		<span class="keyword">if</span>(t-&gt;rchild)</span><br><span class="line">			t=<span class="built_in">GoFarLeft</span>(t-&gt;rchild,_sta);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!_sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			t=_sta.<span class="built_in">top</span>();</span><br><span class="line">			_sta.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="后序遍历">7.5.4 后序遍历</h6>
<p>后序遍历就是从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/postOrder.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(std::vector&lt;T&gt;&amp; vec, binaryTreeNode&lt;T&gt;* Node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Node==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">postOrder</span>(vec,Node-&gt;lchild);</span><br><span class="line">	<span class="built_in">postOrder</span>(vec,Node-&gt;rchild);</span><br><span class="line">	vec.<span class="built_in">push_back</span>(Node-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 后序遍历的非递归算法，同样采用栈数据结构辅助 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strcut TreeNode &#123;</span></span><br><span class="line"><span class="comment">//  ElemType data;</span></span><br><span class="line"><span class="comment">//  TreeNode *left, *right;</span></span><br><span class="line"><span class="comment">//  TreeNode() &#123;</span></span><br><span class="line"><span class="comment">//      left = right = NULL;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(vector&lt;T&gt;&amp; vec,binaryTreeNode&lt;T&gt; *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *p = root, *r = <span class="literal">NULL</span>;</span><br><span class="line">    stack&lt;binaryTreeNode&lt;T&gt;*&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (p || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;<span class="comment">//走到最左边</span></span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild &amp;&amp; p-&gt;rchild != r)<span class="comment">//右子树存在，未被访问</span></span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(p-&gt;data)</span><br><span class="line">                r = p;<span class="comment">//记录最近访问过的节点</span></span><br><span class="line">                p = <span class="literal">NULL</span>;<span class="comment">//节点访问完后，重置p指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="层次遍历">7.5.5 层次遍历</h6>
<p>层次遍历中一般使用<strong>队列</strong>作为辅助工具，将根节点压入后，访问其左右孩子节点并压入，然后根节点出队列，依据队列的先进先出，再访问根节点的左孩子节点的孩子节点并压入，然后是根节点的右孩子节点的孩子节点压入，以此递推下去。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/level.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">level</span><span class="params">(vector&lt;T&gt;&amp; vec,binaryTreeNode&lt;T&gt; *root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		queue&lt;binaryTreeNode&lt;T&gt;*&gt; _que;</span><br><span class="line">		_que.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span>(!_que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="keyword">auto</span> t=_que.<span class="built_in">front</span>();</span><br><span class="line">			_que.<span class="built_in">pop</span>();</span><br><span class="line">			vec.<span class="built_in">push_back</span>(t-&gt;data);</span><br><span class="line">			<span class="keyword">if</span>(t-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">				_que.<span class="built_in">push</span>(t-&gt;lchild);</span><br><span class="line">			<span class="keyword">if</span>(t-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">				_que.<span class="built_in">push</span>(t-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="求树的深度">7.5.6 求树的深度</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">height</span><span class="params">(binaTreeNode&lt;T&gt;* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> hl=<span class="built_in">heught</span>(root-&gt;lchild);</span><br><span class="line">	<span class="type">size_t</span> hr=<span class="built_in">height</span>(root-&gt;rchild);</span><br><span class="line">	<span class="keyword">if</span>(hl&gt;hr)</span><br><span class="line">		<span class="keyword">return</span> hl++;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> hr++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="应用-2">7.6 应用</h5>
<h6 id="并查集-1">7.6.1 并查集</h6>
<p>在介绍链表时侯我们将来并查集的概念，知道<strong>在线等价类</strong>就是并查集。但是使用链表解决并查集不是最优解，这里我们介绍树来解决并查集问题。在在线等价类的问题当中，初始时有n个元素，每个元素都属于一个独立的等价类。需要执行以下的操作:</p>
<ul>
<li>①<code>conbine(a,b)</code>,把包含a,b的等价类合并为一个等价类</li>
<li>②<code>find(Element)</code>,确定元素<code>Element</code>在哪一个类，目的是对给定的两个元素，确定是否属于同一个类（同类，返回相同结果，否则不同）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">combine</span>(a,b)</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">classA=<span class="built_in">find</span>(a);</span><br><span class="line">classB=<span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span>(classA!=classB)</span><br><span class="line"><span class="built_in">unite</span>(classA,classB);</span><br></pre></td></tr></table></figure>
<p>并查集问题的求解策略：<strong>把每一个集合表示为一棵树。</strong></p>
<ul>
<li><strong>在查找时</strong>：把根元素作为集合标识符，因此find(a)返回的会是根元素。当且仅当a和b属于同一集合，<code>find(a)==find(b)</code>为真.</li>
<li><strong>在合并时</strong>：假设调用语句<code>unite(classA,classB)</code>,<code>classA</code>和<code>classB</code>分别是不同集合的根，为了把两集合合并，得让一颗树成为另一颗树的子树。<strong>合并采用重量规则：若根为i的树的结点数少于根为j的树的节点数，则将j作为i的父节点。否则，将i作为j的父节点。</strong></li>
</ul>
<p><strong>1. 重量规则使用的结构（顺序结构）</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重量规则使用的结构（顺序结构）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unionFindNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElementType data;</span><br><span class="line">	<span class="type">int</span> parent;	<span class="comment">///root为true时，表示树的重量，false时，为夫节点的指针(索引)</span></span><br><span class="line">	<span class="type">bool</span> root;</span><br><span class="line">	<span class="built_in">unionFindNode</span>()&#123;parent=<span class="number">1</span>;root=ture;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong>节点点内数字是<code>parent</code>的值,节点外的数字是该节点的索引，索引也同时是该节点所表示的元素，即中间的节点的元素值是下面一个节点的<code>parent</code>值（下面的<code>find</code>函数就说明了这一点）</p>
<p><strong>2. 构建重量规则的树（该树使用顺序结构的形式）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">int</span> numberOfElements)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//初始化numberiOfElements课树，每棵树包含一个元素</span></span><br><span class="line">	unionFindNode node=<span class="keyword">new</span> unionFindNode[unmberOfElements+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 查找</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回元素所在树的根</span></span><br><span class="line"><span class="comment">//theRoot是要返回的根，同时紧缩根到下标为index的节点路径上的节点到根的路径长度</span></span><br><span class="line">	<span class="type">int</span> theRoot=index;</span><br><span class="line">	<span class="keyword">while</span>(!node[theRoot].root)</span><br><span class="line">		theRoot=node[theRoot].parent;</span><br><span class="line">	<span class="type">int</span> currentNode=index;</span><br><span class="line">	<span class="keyword">while</span>(currentNode!=theRoot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> parentNode=node[currentNode].parent;</span><br><span class="line">		node[currentNode].parent=theRoot;</span><br><span class="line">		currentNode=parentNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> theRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 合并</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> rootA,<span class="type">int</span> rootB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node[rooaA].parent&lt;node[rootB].parent)</span><br><span class="line">	&#123;</span><br><span class="line">		node[rootB].parent+=node[rootA].parent;</span><br><span class="line">		node[rootA].root=<span class="literal">false</span>;</span><br><span class="line">		node[rootA].parent=rootB;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node[rootA].parent+=node[rootB].parent;</span><br><span class="line">		node[rootB].root=<span class="literal">false</span>;</span><br><span class="line">		node[rootB].parent=rootA;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="二叉树的右视图">7.6.2 二叉树的右视图</h6>
<h6 id="完全二叉树">7.6.3 完全二叉树</h6>
<h6 id="对称二叉树">7.6.4 对称二叉树</h6>
<h6 id="平衡二叉树">7.6.5 平衡二叉树</h6>
<h6 id="二叉树剪枝">7.6.6 二叉树剪枝</h6>
<h4 id="堆">8. 堆</h4>
<ul>
<li><strong>大根树/小根树</strong>：定义是指它的每个节点都大于/小于或等于其子节点的值。</li>
<li>大根堆/小根堆：一个大根堆/小根堆既是大根树/小根树，也是完全二叉树</li>
</ul>
<p>下图演示的堆的初始化和删除根节点的动态演示： <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/heapSort.gif" width="500"></p>
<h5 id="堆的操作">8.1 堆的操作</h5>
<h6 id="堆的插入">8.1.1 堆的插入</h6>
<p>因为<strong>堆是完全二叉树，所以当加入一个元素形时，必须维持该堆仍为完全二叉树</strong>，即该新节点位置由此定下了。接着元素插入要依据原来是大根堆还是小根堆（即不能破环该堆的性质）。把插入的元素，沿着从新节点到根节点的路径，执行一趟冒泡操作，将新元素与其夫节点的元素比较交换，直到后者大于前者（大根堆为例）。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该方法通过查询当前堆的大小和元素比较定位插入点，进行大根堆完全二叉树形式插入即`/2`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> currentNode=++heapsize;</span><br><span class="line">	<span class="comment">//通过比较寻找插入点，比插入值小的元素下沉</span></span><br><span class="line">	<span class="keyword">while</span>(currentNode!=<span class="number">1</span>&amp;&amp;heap[currentNode/<span class="number">2</span>]&lt;theElement)</span><br><span class="line">	&#123;</span><br><span class="line">		heap[currentNode]=heap[currentNode/<span class="number">2</span>];</span><br><span class="line">		currentNode/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入新值</span></span><br><span class="line">	heap[currenNode]=theElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="堆的删除">8.1.2 堆的删除</h6>
<p><strong>在大根堆中删除一个元素，其实就是删除根节点的元素</strong>。此时就需要重新组织，以便保持性质不变 。其策略是，从删除的位置开始为一个树,向下找，找到该树的最后一个叶子节点，删除该节点但保存元素到临时量；然后比较删除（这个删除只是指元素替换了，而不是前面那个销毁删除）节点的左右孩子，将大的放到该根节点；这时因为大孩子的被放到根节点而成为了空(没有元素），此时我们像之前一样比较该结点的左右孩子，将大的放到该结点，以此类推……，直到最后一个叶子我们与之前中间量保存的元素比较，完成删除排序，如下图所示（小根堆）： <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/heap.png" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">templaet&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(heapsize==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	heap[<span class="number">1</span>].~<span class="built_in">T</span>();		<span class="comment">//销毁根节点元素</span></span><br><span class="line">	T lastElement=heap[heapsize];	<span class="comment">//最后一个元素保存到临时变量</span></span><br><span class="line">	heap[heapsize--].~<span class="built_in">T</span>();			<span class="comment">//销毁最后一个元素</span></span><br><span class="line">	<span class="type">int</span> currentNode=<span class="number">1</span>,child=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(child&lt;heapsize)</span><br><span class="line">	&#123;	<span class="comment">//元素进行上升</span></span><br><span class="line">		<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">			child++;</span><br><span class="line">		<span class="comment">//判断lastElement是否可以放在heap[child]上</span></span><br><span class="line">		<span class="keyword">if</span>(lastElement&gt;=heap[child])	<span class="comment">//可以就直接退出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		heap[currentNode]=heap[child];</span><br><span class="line">		currentNode=child;</span><br><span class="line">		child*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[currentNode]=lastElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong><em>附：</em></strong>若是指定位置或元素删除，也是一样的方法，先遍历定位要删除的元素，将其销毁，它的消耗只会影响到它的子树，而不会向上影响，因此只需要将子树的元素比较大小然后抬升即可，方法同删除根节点是一模一样的</p>
<h6 id="堆的初始化">8.1.3 堆的初始化</h6>
<p>初始化：当堆刚开始时就要有n个元素，我们就要构建非空堆，我们需要在堆中执行n次插入操作。先将元素按层次插入，取位置在i=n/2的元素，如果以这个元素为根的子树是大根堆则不做操作，如果不是大根堆则从该节点开始的树进行检测替换，依次检查i-1,i-2……1 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(T *theHeap,std::<span class="type">size_t</span> _heapsize)</span></span>&#123;</span><br><span class="line">	<span class="keyword">delete</span>[]heap;</span><br><span class="line">	heap =theheap;</span><br><span class="line">	heapsize=_heapsize;</span><br><span class="line">	<span class="comment">//从下往上进行堆化，即从heapsize/2开始，直到root=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> root=heapsize/<span class="number">2</span>;root&gt;=<span class="number">1</span>;root--)</span><br><span class="line">	&#123;</span><br><span class="line">		T rootElement=heap[root];</span><br><span class="line">		<span class="type">int</span> child=<span class="number">2</span>*root;</span><br><span class="line">		<span class="keyword">while</span>(child&lt;=heapsize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(child&lt;heapsize&amp;&amp;heap[child]&lt;heap[child+<span class="number">1</span>])</span><br><span class="line">				child++;</span><br><span class="line">			<span class="keyword">if</span>(rootElement&gt;=heap[child])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			heap[child/<span class="number">2</span>]=heap[child];</span><br><span class="line">			child*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[child/<span class="number">2</span>]=rootElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉搜索树">9. 二叉搜索树</h4>
<p>主要有二叉搜索树和索引二叉搜索树。二叉搜索树的查找、插入和删除操作的所需平均时间为O(log2n),最坏的情况为O(n)。对于给定一个关键字，使用二叉搜索树，可以在O(n)时间内，找到最接近它的关键字。二叉搜索树是一颗二叉树，可能为空，一颗非空的二叉搜索树满足以下特点：</p>
<ul>
<li>每个元素有一个关键字，并且任意两个元素的关键字都不同（有重复值的二叉搜索树除外），<strong>因此所有的关键字都是唯一的</strong></li>
<li><strong>在根节点的左子树中，元素的关键字(如果有的话）都小于根节点关键字</strong></li>
<li><strong>在根节点的右子树中，元素的关键字都大于根节点的关键字</strong></li>
<li>根节点的左右子树也都是二叉树</li>
</ul>
<h5 id="实现-5">9.1 实现</h5>
<h6 id="搜索">9.1.1 搜索</h6>
<p>要查找关键字为<code>theKey</code>的元素，先从根查找，如果根为空，则搜索树为空的；若不为空，则将<code>theKey</code>与根关键字比较大小，由二叉树搜索树的性质知，比根的大，则向右子数查找，若小，则向左子树查找，依次类推，直到找到或者到<code>NULL</code>为止。如下图查找<code>5</code> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/search.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">pair&lt;<span class="type">const</span> K,E&gt;*binarySearchTree&lt;K,E&gt;::<span class="built_in">find</span>(<span class="type">const</span> K&amp; theKey,</span><br><span class="line">	binaryTreeNode&lt;<span class="type">const</span>  K,E&gt;*p)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(theKey&lt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(theKey&lt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;rightChild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> &amp;p-&gt;element;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="插入">9.1.2 插入</h6>
<p>重复的关键字进行值更新，从根节点开始比较，直到遇到相同的关键或<code>NULL</code> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/insert.gif" width="500"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="type">void</span> binarySearchTree&lt;K,E&gt;::<span class="built_in">insert</span>(<span class="type">const</span> pair&lt;<span class="type">const</span> K,E&gt;&amp;</span><br><span class="line">thePair,binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt; *p)</span><br><span class="line">&#123;</span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt; *pp=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pp=p;</span><br><span class="line">		<span class="keyword">if</span>(thePair.first&lt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(thePair.first&gt;p-&gt;element.first)</span><br><span class="line">			p=p-&gt;rightChild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;element.second=thePair.second;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt; *newNode</span><br><span class="line">		=<span class="keyword">new</span> binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;(thePair);</span><br><span class="line">	<span class="keyword">if</span>(rootNode==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode=newNode;</span><br><span class="line">		rootNode-&gt;leftChild=rootNode-&gt;rightChild=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(pp-&gt;element.first&lt;thePair.first)</span><br><span class="line">		pp-&gt;rightChild=newNode;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		pp-&gt;leftChild=newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	stSize++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从上面的程序来看，二叉搜索树如果不添平衡操作容易退化成单链表，那么这是就会造成结构的失效，下一节我们会介绍一个平衡的办法。</p>
<h6 id="删除">9.1.3 删除</h6>
<p>假设要删除接节点<code>p</code>，我们要考虑三种情况：<strong>①<code>p</code>是叶子；②<code>p</code>只有一颗非空子树；③<code>p</code>有两颗非空子树</strong></p>
<ul>
<li>第一种情况非常好做，只有释放叶子节点的空间即可，若是根节点，置为<code>NULL</code> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/one.gif" width="500"></li>
<li>第二种情况也较为简单 ，如果<code>p</code>是根节点，则<code>p</code>的唯一子树的根节点成为新的搜索树的根节点。若<code>p</code>有父节点<code>pp</code>，则修改<code>pp</code>的指针域，使它指向<code>p</code>的唯一孩子，然后释放节点<code>p</code> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/two.gif" width="500"></li>
<li>第三种情况较复杂，我们先将该节点的元素替换为它左子树的最大元素（或者右子树的最小的一个元素）。然后把替换的节点删除，该删除的结点如果有左子树，则该左子树变为该结点的双亲的右子树（或者删除的结点如果有右子树，则该右子树变为该结点的双亲的左子树） <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/three.gif" width="500"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line"><span class="type">void</span> binarySearchTree&lt;K,E&gt;::<span class="built_in">erase</span>(<span class="type">const</span> K&amp; theKey)</span><br><span class="line">&#123;</span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;* p=rootNode,*pp=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p.element.first!=theKey)</span><br><span class="line">	&#123;											<span class="comment">//定位关键值相等的节点</span></span><br><span class="line">		pp=p;</span><br><span class="line">		<span class="keyword">if</span>(p.element.first&lt;theKey)<span class="number">8</span> </span><br><span class="line">		p=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		p=p-&gt;rightChild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)	<span class="comment">//不存在</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;leftChild!=<span class="literal">NULL</span>&amp;&amp;p-&gt;rightChild!=<span class="literal">NULL</span>)		<span class="comment">//第三种情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;* theMaxNode=p-&gt;leftNode,*s=p;</span><br><span class="line">		<span class="keyword">while</span>(theMaxNode-&gt;rightChild!=<span class="literal">NULL</span>)	<span class="comment">//寻找左子树最大值进行替换</span></span><br><span class="line">		&#123;</span><br><span class="line">			s=theMaxNode;</span><br><span class="line">			theMaxNode=theMaxNode-&gt;rightChild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//p-&gt;element=theMaxNode-&gt;element;  无法这样移动，因为key是常量</span></span><br><span class="line">		binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;* q=<span class="keyword">new</span> binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;</span><br><span class="line">			(theMaxNode-&gt;element,p-&gt;leftChild,p-&gt;rightChild);		<span class="comment">//这样移动合法</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pp==<span class="literal">NULL</span>)		<span class="comment">//即删除的是根节点的情况</span></span><br><span class="line">			rootNode=q;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p==pp-&gt;leftNode)		<span class="comment">//不是根节点，判断p是pp的左树还是右树</span></span><br><span class="line">			pp-&gt;leftChild=q;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pp-&gt;rightChild=q;</span><br><span class="line">		<span class="keyword">if</span>(s==p) q-&gt;leftChild=theMaxNode-&gt;leftChild;</span><br><span class="line">			<span class="keyword">delete</span> p;</span><br><span class="line">		p=s						<span class="comment">//为简化下面判断if(p-&gt;leftChild!=NULL)语句</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	binaryTreeNode&lt;pair&lt;<span class="type">const</span> K,E&gt;&gt;*c;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;leftChild!=<span class="literal">NULL</span>)</span><br><span class="line">		c=p-&gt;leftChild;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		c=p-&gt;rightChild;</span><br><span class="line">	<span class="comment">//删除p</span></span><br><span class="line">	<span class="keyword">if</span>(p==rootNode)</span><br><span class="line">		rootNode=c;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p==pp-&gt;leftChild)</span><br><span class="line">			pp-&gt;leftChild=c;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			pp-&gt;rightChild=c;</span><br><span class="line">	&#125;</span><br><span class="line">	stSize--;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="平衡二叉搜索树avl">10. 平衡二叉搜索树AVL</h4>
<p>如果搜索树的高度总是<code>O(logn)</code>，我们能保证查找、插入、删除的时间为<code>O(logn)</code>。最坏情况下的高度为O(logn)的树为<strong>平衡树（balanced tree)</strong>。<strong>但是正如上面搜索树所讲的，在大量的插入后搜索树极其容易不平衡导致元素大量在一个分支上，退化成链表，这时候查找、插入、删除的时间复杂的就不为<code>O(logn)</code></strong>。平衡二叉搜索树就是为解决这个问题而得出的数据结构。</p>
<h5 id="平衡二叉搜索树的定义">10.1 平衡二叉搜索树的定义</h5>
<p>一颗空的二叉树是AVL树；如果T是一颗非空的二叉树，<code>T1</code>和<code>T2</code>分别是其左子树和右子数，那么当<code>T</code>满足以下条件时，<code>T</code>是一颗AVL树：</p>
<ul>
<li>①<code>T1</code>和<code>T2</code>是AVL树；</li>
<li>②<code>|hl-hr|≤1</code>，其中<code>hl</code>和<code>hr</code>分别是<code>Tl</code>和<code>TR</code>的高。</li>
</ul>
<p>一颗AVL搜索树既是二叉搜索树，也是AVL树。如果用AVL搜索树来描述字典，并在对数级时间内完成每一种字典操作，那么，我们必须确定AVL树的下列特征：</p>
<ul>
<li><strong>一颗<code>n</code>个元素的AVL树，其高度是<code>O(logn)</code></strong></li>
<li>对于每一个<code>n.n≥0</code>，都存在一颗AVL树</li>
<li>对一颗<code>n</code>元素的AVL搜索树，在<code>O(高度)=O(logn)</code>的时间内可以实现查找</li>
<li><strong>将一个新元素插入一颗<code>n</code>元素AVL搜索树种，可以得到一颗<code>n+1</code>元素的AVL树，且插入用时为<code>O(logn)</code></strong></li>
<li><strong>一个元素从一颗<code>n</code>元素的AVL搜索树删除，可以得到一颗<code>n-1</code>的AVL搜索树，而且用时为<code>O(logn)</code></strong></li>
</ul>
<p><strong>AVL树的描述：</strong>AVL树一般用链表进行描述，为简化插入和删除操作，我们为每一个节点添加一个平衡因子<code>bf</code>，假设x的左子树高度为<code>hl</code>,右子树高度为<code>hr</code>，节点<code>x</code>的平衡因子<code>bf(x)</code>定义为：</p>
<ul>
<li><code>bf(x)=hl-hr</code></li>
<li><code>bf(x)</code>取值只能为<code>0，-1，1</code></li>
</ul>
<p><img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/balanceTree.png" width="500"></p>
<p>这里主要讲解平衡二叉搜索树的搜索、插入和删除操作。</p>
<h5 id="搜索-1">10.2 搜索</h5>
<p>同二叉搜索树一样的操作，<code>n</code>元素的AVL树的高度是<code>O(logn)</code>，所以搜索时间为<code>O(logn)</code>。要查找关键字为theKey的元素，先从根查找，如果根为空，则搜索树为空的；若不为空，则将theKey与根关键字比较大小，由二叉树搜索树的性质知，比根的大，则向右子数查找，若小，则向左子树查找，依次类推，直到找到或者到<code>NULL</code>为止。如下图查找<code>5</code>。实现略</p>
<h5 id="插入操作">10.3 插入操作</h5>
<p>AVL树因为要保证每个结点的平衡因子要时时刻刻都符合要求，则树中每插入一个结点，都可能引起平衡被打破，所以每次插入一个结点，<strong>都要从插入的结点往上进行检查是否有哪个结点需要调整。要在插入新结点后进行平衡检查，则需要把插入结点的插入过程的下行路线上的每一个结点都依次记录下来，这个可以借助于栈来实现，在查找插入位置的过程，把每一个结点指针放入栈中</strong>．</p>
<h6 id="插入的具体步骤">10.3.1 插入的具体步骤</h6>
<ul>
<li><strong>第一步：</strong>从根结点开始，首先查找要插入的位置。如果结点值相等则更新，如果小于则向左走，如果大于则向右走，把这个过程中的每一个结点都放入一个栈中，这样直到到达叶子结点，即找到了插入的位置．然后<code>new</code>出来一个结点进行插入</li>
<li><strong>第二部</strong>：插入完成以后进行平衡调整。取出栈中的元素进行检查：插入的结点对于取出的结点如果是左边插入，则平衡因子<code>+１</code>，如果右边插入则平衡因子<code>-１</code>．</li>
<li><strong>第三步1</strong>：如果加减<code>１</code>以后平衡因子是<code>０</code>，即意味着插入节点之前平衡因子只能是<code>±１</code>，插入该节点以后，该子树的左右子树高度相等，因此并不改变该子树的高度，也就并不影响整棵树的高度，所以树是平衡的，不需要<strong>第三步2</strong>：调整，调整结束<code>break</code> ；</li>
<li><p>如果插入后平衡因子是<code>+1</code>或者<code>-1</code>，则意味着该节点所在的子树的高度发生变化（因为在此之前该节点的平衡因子只能是０），所以以该节点为root的子树的高度一定是增加了，所以要向上继续检查是否有哪个节点的平衡因子因为插入了一个节点平衡因子变为<code>±２</code>，所以继续取出stack中的下一个节点进行上述同样的检查</p></li>
<li><strong>第四步</strong>：如果平衡因子是正负２，则平衡打破，需要进行调整，下面详述调整过程：
<ul>
<li>１．<code>bf=-2</code>: 如果该节点的孩子节点平衡因子是负值：则对该节点进行一次左旋转即调整完成；如该该节点的孩子节点的平衡因子是正值：则需要进行先左后右旋转．</li>
<li>２．<code>bf=+2:</code>如果该孩子节点<code>bf</code>是正值：则对该节点进行一次右旋转即可；如果孩子节点<code>bf</code>是负值：则对该节点进行先右后左旋转即可．</li>
</ul></li>
</ul>
<p>调整平衡完成以后需要将该子树的新根节点挂到之前的根节点下面．以上即整个插入过程．</p>
<h6 id="失衡的情况">10.3.2 失衡的情况</h6>
<p>如果按二叉搜索树的插入算法会影响AVL树将不在是AVL树。如下图按二叉搜索树的方式将32插入VAL搜索树而导致失衡 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/compare.png" width="500"> 因此，插入操作必须维护各节点的<code>|bf|≤1</code>。<strong>插入破环原AVL搜索二叉树结构是以下情形：</strong></p>
<ul>
<li>在不平衡树中，平衡因子的值限于<code>2，1，0，-1，-2</code></li>
<li>平衡因子为<code>2</code>的节点插入前平衡因子为<code>1</code>，同样<code>-2</code>的插入前为<code>-1</code></li>
<li><strong>只有从根到新插入节点路径上的节点，其平衡因子在插入后会改变</strong></li>
<li><strong>假设<code>A</code>是离新插入节点最近的</strong>祖先<strong>，且平衡因子是<code>-2</code>或<code>2</code>（在上面的图中A是关键字为40的节点），在插入前，从<code>A</code>到新插入节点的路径上，所有节点的平衡因子都是0</strong></li>
</ul>
<p>对于平衡与失衡的判断存在与否，主要就是看<code>A</code>这一节点存不存在，即平衡因子变为<code>2</code>或<code>-2</code>的最近祖先节点存在与否：</p>
<p><strong><code>A</code>节点不存在</strong>：那么从根节点至新插入节点的途中，所有节点在插入前的平衡因子都为<code>0</code>或者为-1但插入左则或者为1但插入右侧，由于插入操作平衡因子增减0或1，所以从根节点到插入新节点的途径的节点平衡因子可能改变，但树的平衡不会改变。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/Aisnot.png" width="500"></p>
<h6 id="失衡的种类">10.3.3 失衡的种类</h6>
<p><strong><code>A</code>节点存在</strong>：就出现平衡因子<code>|bf|=2</code>的情况，破坏了平衡，此时就需要进行平衡操作。其不平衡的情况有两类</p>
<ul>
<li><code>L</code>型不平衡,新插入的节点在A的左子树中</li>
<li><code>R</code>型不平衡,新插入的节点在A的右子树中</li>
</ul>
<p>同时，从根到新插入节点的路径上，根据A的孙节点情况，还可在细分（包含新节点的A的子树高度至少为2，因为有定义知A的平衡因子为2或-2,A才存在孙节点），此时细分为<code>LL,LR,RL,RR</code>。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/four.png" width="500"></p>
<ul>
<li><ol type="1">
<li><code>6</code>节点的左子树<code>3</code>节点高度比右子树<code>7</code>节点<strong>大<code>2</code></strong>，左子树<code>3</code>节点的左子树<code>1</code>节点高度<strong>大于</strong>右子树<code>4</code>节点，这种情况成为左左<code>LL</code>(左孩子的左子树深度大)。</li>
</ol></li>
<li><ol start="2" type="1">
<li><code>6</code>节点的左子树<code>2</code>节点高度比右子树<code>7</code>节点<strong>大<code>2</code></strong>，左子树<code>2</code>节点的左子树<code>1</code>节点高度<strong>小于</strong>右子树<code>4</code>节点，这种情况成为左右<code>LR</code>。</li>
</ol></li>
<li><ol start="3" type="1">
<li><code>2</code>节点的左子树<code>1</code>节点高度比右子树<code>5</code>节点<strong>小<code>2</code></strong>，右子树<code>5</code>节点的左子树<code>3</code>节点高度<strong>大于</strong>右子树<code>6</code>节点，这种情况成为右左<code>RL</code>。</li>
</ol></li>
<li><ol start="4" type="1">
<li><code>2</code>节点的左子树<code>1</code>节点高度比右子树<code>4</code>节点<strong>小<code>2</code></strong>，右子树<code>4</code>节点的左子树<code>3</code>节点高度<strong>小于</strong>右子树<code>6</code>节点，这种情况成为右右<code>RR</code>。</li>
</ol></li>
</ul>
<h6 id="ll型平衡操作">10.3.4 LL型平衡操作</h6>
<p><strong>右旋：</strong>在最小平衡子树根节点平衡因子&gt;=2且在根节点的左孩子的左孩子插入元素即<code>LL</code>，要进行右旋 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rightxuan.gif" width="500"> 右旋如上所示，绕<code>|bf|=2</code>的节点（以下统称为<code>root</code>）进行旋转，根节点的左孩子成为新的根节点，而原来的<code>root</code>成为其右孩子，同时若新的根节点原来的右子树成为<code>root</code>的左子树,如下 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rightxuan.png" width="500"></p>
<h6 id="rr型平衡操作">10.3.5 RR型平衡操作</h6>
<p>在最小平衡子树根节点<code>bf&gt;=-2</code>且在根节点的右孩子的右孩子插入元素，进行<strong>左旋。</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/leftxuan.gif" width="500"> 其动作与<code>LL</code>一样，只不过方向相反。</p>
<h6 id="lr型平衡操作">10.3.6 LR型平衡操作</h6>
<p>在最小平衡子树根节点<code>80</code>的左孩子<code>50</code>的右孩子<code>70</code>的子节点插入新元素，先绕根节点的左孩子节点<code>50</code>右旋，再围根节点<code>80</code>左旋 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/lr.png" width="600"></p>
<h6 id="rl型平衡操作">10.3.7 RL型平衡操作</h6>
<p>最小平衡子树根节点<code>80</code>的右孩子<code>100</code>的左孩子<code>90</code>的子节点<code>95</code>插入新元素，先绕根节点的右孩子节点<code>100</code>右旋，再围根节点<code>80</code>左旋 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rl.png" width="600"> 其动态展示如下： <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/rl.gif" width="500"></p>
<h5 id="删除操作">10.4 删除操作</h5>
<h6 id="删除节点">10.4.1 删除节点</h6>
<p>执行二叉搜索树得删除操作，AVL树删除节点，首先查找要删除的节点，找到以后，要删除的节点分为两种情况：</p>
<ul>
<li>１.要删除的节点左右两个孩子都存在，直接删除不方便，则在右子树中查找最小的节点，将其值替换为要删除的节点的值，因为右子树的最小节点必然没有左孩子，即只有一个孩子．然后问题转化为删除这个右子树中最小的节点．（或者也可以将问题转化为删除左子树里最大的节点）</li>
<li>２.要删除的孩子节点只有一个孩子节点，则直接将仅有的一个孩子节点提上来即可．</li>
</ul>
<h6 id="平衡性检查">10.4.2 平衡性检查</h6>
<p>删除以后将进行从删除节点向上进行平衡性的检查。<strong>在查找要删除的节点的过程中，将经过的路径上的节点位置全部存放到一个<code>stack</code></strong>。在平衡型检查过程种取出栈顶元素<code>pr</code>并弹出栈顶元素，如果删除的节点<code>pr</code>的<code>key</code>值比该节点的<code>key</code>值小,则必定是左树删除则<code>pr-&gt;bf-1</code>了，否则<code>pr-&gt;bf+1</code>。会造成以下三种情况：</p>
<ul>
<li>１．删除后如果<code>|pr-&gt;bf|=1</code>：则在删除节点之前<code>pr-&gt;bf０</code>，即左右平衡，<strong>删除了以后左树或者右树少了一个节点，但<code>pr</code>这个子树的高度并没发生变化．对与pr的上面的所有节点而言树高并没有发生变化，所以调整完成．</strong></li>
<li>２．如果删除后|pr-&gt;bf|=０<code>,则在删除之前平衡因子是</code>±１<code>，现在删除节点以后变为</code>０<code>，则</code>pr<code>子树的高度减</code>１`（发生了变化，影响到了上面的节点），则要向上（出栈）继续检查，</li>
<li>３．如果删除后造成<code>|pr-&gt;bf|==２</code>,则平衡打破，进行平衡调整.</li>
</ul>
<h4 id="红黑树">11. 红黑树</h4>
<p>平衡索引二叉树是高度平衡的二叉树，频繁的插入和删除，会引起频繁的<code>rebalance</code>,导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转的数据结构，所以红黑树在查找，插入删除的性能都是接近<code>O(logn)</code>,且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RB树的节点结构:</span><br><span class="line"><span class="comment">//由于红黑树的各种操作常需要上溯其父级节点，因此特别安排一个parent指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> _rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> _rb_tree_color_type _rb_tree_red=<span class="literal">false</span>;	<span class="comment">//红色为0</span></span><br><span class="line"><span class="type">const</span> _rb_tree_color_type _rb_tree_black=<span class="literal">true</span>;	<span class="comment">//黑色为1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_color_type	 color_type;</span><br><span class="line">	<span class="keyword">typedef</span> _rb_tree_node_base*	 base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span>				 value_type;</span><br><span class="line">	</span><br><span class="line">	color_type color;		<span class="comment">//结点颜色</span></span><br><span class="line">	base_ptr parent;		<span class="comment">//父节点指针</span></span><br><span class="line">	base_ptr left;</span><br><span class="line">	base_ptr right;</span><br><span class="line">	value_type value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="红黑树特点">11.1 红黑树特点</h5>
<p><strong>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍</strong>，因此，红黑树是一种<strong>弱平衡二叉树</strong>，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。红黑树具有以下的性质：</p>
<ul>
<li>每个节点非红即黑</li>
<li><strong><code>RB1</code>：根节点是黑的;</strong></li>
<li><strong><code>RB1</code>：每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</strong></li>
<li><strong><code>RB2</code>：</strong>如果一个节点是红色的，则它的子节点必须是黑色的，即红节点不能连续**</li>
<li><strong><code>RB3</code>：</strong>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</li>
</ul>
<p><strong>一个节点的阶</strong>是指从该节点到一外部节点路径上黑色指针的数量，定理：</p>
<ul>
<li>设根到外部节点的路径长度length是该路径上的指针数量。如果P和Q是红-黑树中的两条从根至外部节点的路径，那么<code>length(P)≤2length(Q)</code></li>
<li>令<code>h</code>是一颗红-黑树的高度（不包括外部节点），<code>n</code>是树的内部节点数量，而<code>r</code>是根节点的阶，则有:
<ul>
<li>①<code>h≤2r</code></li>
<li>②<code>n≥2^r-1</code></li>
<li>③<code>h≤2log2(n+1)</code></li>
</ul></li>
</ul>
<h5 id="红黑树操作">11.2 红黑树操作</h5>
<ul>
<li><strong>搜索：</strong>使用普通的二叉搜索树的搜索代码。对红黑树来说，时间复杂度为<code>O(logn)</code>。比较而言，二叉搜索树、AVL、红黑树搜索都使用相同代码，而且在最坏的情况下AVL树的高度是最小的，所以在搜索为主的应用中，avl是最优的。</li>
<li><strong>插入：</strong>红黑树的插入使用的是普通二叉搜索树插入算法，对插入的元素，需要上色。如果插入前树是空的，那么新节点是根节点，颜色应是黑色。</li>
</ul>
<p><strong>对红黑树的插入删除要维护其原本的性质：</strong>假设插入前的树是非空的，如果新节点的颜色是黑色，那么从根到外部节点路径上，将有一个特殊的黑色节点作为新节点的孩子。如果新节点是红色，那么可能出现两个连续的红色节点。所以把新节点赋为黑色肯定不符合<code>RB3</code>，而把新节点赋为红色虽然一定符合<code>RB3</code>,但可能违反了<code>RB2</code>。对红黑树的插入删除要维护其原本的性质。</p>
<h6 id="赋为红色而造成的不平衡类型">11.2.1 赋为红色而造成的不平衡类型</h6>
<p>如果是新节点赋为红色而造成<code>RB2</code>规则被破坏，我们就说树的平衡杯破坏了。<strong>此时平衡破坏则必有有两连续红色节点，一个是新节点<code>u</code>,一个是其父结点<code>pu</code>。而此时祖父节点<code>gu</code>一定是黑色的</strong>。有以下情况</p>
<ul>
<li>当<code>pu</code>是<code>gu</code>的左孩子，<code>u</code>也是<code>pu</code>的左孩子时且<code>gu</code>的另一个孩子（右孩子）是黑色的（为外部节点），该不平衡类型为<code>LLb</code>类型。</li>
<li>当<code>pu</code>是<code>gu</code>的左孩子，<code>u</code>是<code>pu</code>的左孩子时且<code>gu</code>的另一个孩子（右孩子）是红色的（不是外部节点），该不平衡类型为<code>LLr</code>类型。</li>
</ul>
<p>依次类推出<code>LRb、LRr、RRb、RRr、RLb、RLr</code></p>
<p><strong>平衡方法；</strong></p>
<ul>
<li><p><code>XYr</code>型的不平衡<strong>可以通过改变颜色来处理</strong>：将<code>pu</code>节点变为黑色，对于LLr和LRr的<code>gu</code>的右孩子要由红色变为黑色，另外如果gu不是根则改为红色，如果是根节点则保持gu为黑色不变；<strong>因为<code>gu</code>由黑变红的情况可能导致上一层平衡破坏，如果破坏了（即原<code>gu</code>与<code>gu</code>父结点都为红）此时将<code>gu</code>变为<code>u</code>,<code>gu</code>父结点变为<code>pu</code>,<code>gu</code>祖父节点为<code>gu</code>,分析是<code>XYr</code>类型还是<code>XYb</code>类型，继续恢复平衡操作。</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/blackRed.png" width="600"></p></li>
<li><p>XYb型则需要旋转。插入后依次旋转足以保持平衡。<strong>该旋转的改变同AVL相似</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/brxuan.png" width="600"></p></li>
</ul>
<p><strong><em>附：</em></strong>对于删除操作，首先使用二叉搜索树的删除算法。然后进行颜色变动，需要的话还要进行一次旋转。 - 删除红色节点，不会影响规则，只需将相应的需要变色的指针变色即可。 - 删除黑色节点，会影响RB3（不是根节点时）。使用该删除算法，不会违反除RB3外的其它红黑树规则。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cy973071263/article/details/122543826">红黑树详解</a></p>
<h4 id="图">12. 图</h4>
<p><strong>图是一个用线或边连接在一起的节点(顶点）的集合。严格地说图是有限集<code>V</code>和<code>E</code>的有序对<code>G=(V,E)</code>。<code>V</code>中的元素为顶点，<code>E</code>为边。</strong>对于图我们需要先了解以下预备知识：</p>
<ul>
<li>图的术语：顶点、边、邻接、关联、度、回路、路径、连通构件、<strong>生成树</strong></li>
<li>图的类型：无向图、有向图和加权图</li>
<li>常用描述方法：邻接矩阵、<strong>矩阵邻接表和邻接链表</strong></li>
<li><strong>图的标准搜索方法：广度优先搜索和深度优先搜索</strong></li>
<li>图的算法：寻找图的路径、寻找无向图的联通构件、<strong>寻找连通无向图的生成树</strong></li>
</ul>
<h5 id="图的基本概念">12.1 图的基本概念</h5>
<ul>
<li>每一条边连接两个顶定，用元组<code>(i,j)</code>表示，<code>i\j</code>表示连接的顶点。带方向的叫有向边，不带方向叫无向边。</li>
<li>当且仅当<code>(i,j)</code>是图的边，称顶定<code>i</code>和<code>j</code>是<strong>邻接</strong>的。边<code>(i,j)</code>关联</li>
<li>如果图的所以边都是无向的，则称图为无向图；都是有向的为有向图</li>
<li>一个图不能有重复的边，即任意两个顶点，在无向图只有一条边，有向图是<code>i</code>到<code>j</code>即<code>(i,j)</code>,<code>j</code>到<code>i</code>即<code>(j,i)</code>各一条</li>
<li>为每条边赋予值，成为权。此时成为加权有向图和加权无向图</li>
<li>简单路径：除最后一个和第一个顶点之外，其余所有顶点都要求不同（如521，525）</li>
<li><strong>环路：一条始点和终点相同的简单路径</strong></li>
<li><strong>连通：图的每一对顶点之间都有一条路径</strong></li>
<li><strong>生成树：没有环路的连通无向图是一颗树。一个G的子图，包含G的所有顶点，且为一棵树，则称为G的生成树</strong></li>
<li>二分图：顶点被分为两个子集A，每条边都有一个顶点在A，另一个在B</li>
<li><strong>度：一个顶点相关联的边数</strong></li>
</ul>
<h5 id="无权图的描述">12.2 无权图的描述</h5>
<p>无向图最常用的描述方法都是基于邻接的方式，如<strong>邻接矩阵、邻接链表和邻接数组</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">graph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">graph</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">numberOfVertices</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;	<span class="comment">//顶点数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">numberofEdge</span><span class="params">()</span><span class="type">const</span></span>=<span class="number">0</span>;		<span class="comment">//边数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">exitsEdge</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span>)</span><span class="type">const</span></span>=<span class="number">0</span>;	<span class="comment">//判断两顶点是否关联</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">insertEdg</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>=<span class="number">0</span>;			<span class="comment">//添加边</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eraseEdge</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>=<span class="number">0</span>;			<span class="comment">//删除边</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">degree</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>=<span class="number">0</span>;			<span class="comment">//指定顶点的度</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">inDegree</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> </span>=<span class="number">0</span>;			<span class="comment">//入度</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">outDegree</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>=<span class="number">0</span>;			<span class="comment">//出度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/graph.png" width="200"></p>
<h6 id="邻接矩阵">12.2.1 邻接矩阵</h6>
<p>一个<code>n</code>顶点图<code>G=(V,E)</code>的邻接矩阵是一个<code>n*n</code>矩阵，其中每个元素是<code>0</code>或<code>1</code>（对角线上的元素都为0，因为没有自连边）。将矩阵映射到一个<code>n*n</code>布尔型二维数组进行存储。因为无向图的邻接矩阵是对称的即<code>A(i,j)=A(j,i)</code>，所以只需存储上三角或下三角元素。因为采用布尔类型1字节，所以共用了<code>n^2</code>字节。</p>
<ul>
<li><strong>优势：</strong>因为无向图的邻接矩阵是对称的即<code>A(i,j)=A(j,i)</code>，所以只需存储上三角或下三角元素。无向图的度为所在行（或列）的元素和。同时对于有向图，出度为该行的元素和，入度为该列的元素和</li>
<li><strong>缺点：</strong>内存空间浪费</li>
</ul>
<h6 id="邻接链表">12.2.2 邻接链表</h6>
<p><strong>一个顶点<code>i</code>的邻接表是一个线性表，它包含了所有邻接i的顶点。在一个图的邻接表中，图的每一个顶点都有一个邻接表。当邻接表用链表表示时，就是邻接链表</strong>。 我们可使用类型为链表的数组<code>aList</code>来描述所有邻接表（指针数组）。<code>aList[i]-&gt;next</code>指向顶点<code>i</code>的邻接表的第一个顶点的数组下标索引<code>index</code>，通过访问<code>aList[index]</code>得到该点的邻接表，<code>(i,index)</code>是图的一条边。。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/linList.png" width="500"></p>
<p>一个指针和一个整数需要4字节的存储空间，顶点需要<code>8(n+1)</code>(为了数组下标对应，不使用下标0的空间，所以<code>n+1</code>)字节存储<code>n+1</code>个<code>next</code>指针和<code>index</code>域。</p>
<h6 id="邻接数组">12.2.3 邻接数组</h6>
<p>在邻接数组中同邻接链表相似，只不过每一个邻接表用一个<strong>数组线性表如vector</strong>而非链表来描述。</p>
<h5 id="链表类的实现">12.3 链表类的实现</h5>
<p>下面的程序给出了邻接链表的的数据成员和一些实现方法，仅供参考，构造函数的时间复杂度为<code>O(n)</code>，方法<code>existsEdgr(i,j)</code>的时间复杂度为<code>O(d^out)</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">linkedDigraph</span>:<span class="keyword">public</span> graph&lt;<span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> n;		<span class="comment">//顶点数</span></span><br><span class="line">	<span class="type">int</span> e;		<span class="comment">//边数</span></span><br><span class="line">	vector&lt;List&gt; vlist;	<span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">linkedDigraph</span>(<span class="type">int</span> numberOfv=<span class="number">0</span>)</span><br><span class="line">	&#123;	<span class="comment">//构造函数</span></span><br><span class="line">		<span class="keyword">if</span>(numberOfv&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">illegalParameterValue</span>(<span class="string">&quot;Number of vertices must be &gt;=0)</span></span><br><span class="line"><span class="string">		n=numberOfv;</span></span><br><span class="line"><span class="string">		e=0;</span></span><br><span class="line"><span class="string">		aList=new graphChain&lt;int&gt;[n+1];</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//析构函数</span></span><br><span class="line"><span class="string">	~linkedDigraph()&#123;delete[] aList;&#125;</span></span><br><span class="line"><span class="string">	//边是否存在</span></span><br><span class="line"><span class="string">	bool existsEdge(int i,int j)const</span></span><br><span class="line"><span class="string">	&#123;//当且仅当(i,j)时返回treu</span></span><br><span class="line"><span class="string">		if(i&lt;1||j&lt;1||i&gt;n||j&gt;n||vList[i].indexOf(j)==-1)</span></span><br><span class="line"><span class="string">			return false;</span></span><br><span class="line"><span class="string">		else</span></span><br><span class="line"><span class="string">			return true;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	//插入边</span></span><br><span class="line"><span class="string">	void insertEdge(int i，int j)</span></span><br><span class="line"><span class="string">	&#123;</span></span><br><span class="line"><span class="string">		if(aLsit[i].indexOf(j)==-1)</span></span><br><span class="line"><span class="string">		&#123;</span></span><br><span class="line"><span class="string">			//新边</span></span><br><span class="line"><span class="string">			aList[i].Insert(j);</span></span><br><span class="line"><span class="string">			aList[j].Insert(i);</span></span><br><span class="line"><span class="string">			e++;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;；</span></span><br></pre></td></tr></table></figure></p>
<h5 id="图的遍历">12.4 图的遍历</h5>
<p>图的遍历有<strong>广度优先搜索(BFS)</strong>和<strong>深度优先搜索(DFS)</strong>两种</p>
<h6 id="广度优先搜索bfs">12.4.1 广度优先搜索(BFS)</h6>
<p>广度优先搜索(BFS),从一个顶点开始，搜索该顶点所有可到达顶点的，新顶点再重复搜索可到达的顶点的方法(已到达的标记为已达，避免重复到达记录，因为顶点是<code>1~n</code>,可使用<code>record[u]=0</code>(未到达)/<code>lable</code>(已到达),<code>u</code>为<code>1~n</code>）。<strong>这种搜索性质可使用队列实现</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">arrayQueue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	reach[v]=label;</span><br><span class="line">	q.<span class="built_in">push</span>(v);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> w=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vertexIterator&lt;T&gt;*iw=<span class="built_in">iterator</span>(w);</span><br><span class="line">		<span class="type">int</span> u;</span><br><span class="line">		<span class="keyword">while</span>((u=iw-&gt;<span class="built_in">next</span>())!=<span class="number">0</span>)	<span class="comment">//u的相邻点，无则返回0</span></span><br><span class="line">			<span class="keyword">if</span>(reach[u]==<span class="number">0</span>)		<span class="comment">//相邻点是没有到达过的</span></span><br><span class="line">			&#123;</span><br><span class="line">				q.<span class="built_in">push</span>(u);</span><br><span class="line">				reach[u]=label;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">delete</span> iw;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="深度优先搜索dfs">12.4.2 深度优先搜索(DFS)</h6>
<p>深度优先搜索(DFS).从一个顶点<code>v</code>出发，首先将v标记为已到达，后选择一个邻接于<code>v</code>的尚未到达的顶点<code>u</code>。<code>u</code>再重复上述操作，直到新<code>u</code>不存在，即无法找到<code>u</code>。---&gt;<strong>一次搜一个/递归/或栈来实现</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> reach[],<span class="type">int</span> label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	graph&lt;T&gt;::reach=reach;</span><br><span class="line">	graph&lt;T&gt;::label=label;</span><br><span class="line">	<span class="built_in">rDfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rDfs</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//递归</span></span><br><span class="line">	<span class="built_in">reach</span>(v)=label;</span><br><span class="line">	vertexIterator&lt;T&gt;*iv=<span class="built_in">iterator</span>(v);</span><br><span class="line">	<span class="type">int</span> u;</span><br><span class="line">	<span class="keyword">while</span>((u=iv-&gt;<span class="built_in">next</span>())!=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span>(reach[u]==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">rDfs</span>(u);</span><br><span class="line">	<span class="keyword">delete</span> iv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="图的应用">12.5 图的应用</h5>
<h6 id="最短路径">12.5.1 最短路径</h6>
<p>主要讨论带权有向图，将路径上的第一个顶点称为源点，最后一个顶点为终点。</p>
<p><strong>1. 迪杰斯特拉算法</strong></p>
<p><strong>迪杰斯特拉算法是求从某个源点到其余各顶点的最短路径</strong>的算法。该算法思想是<strong>按路径长度递增的次序产生一个最短路径</strong>。描述要借助两个集合<code>S、U</code></p>
<ul>
<li><ol type="1">
<li>初始时，<code>S</code>只包含起点<code>s</code>；<code>U</code>包含除<code>s</code>外的其他顶点，且<code>U</code>中顶点的距离为<strong>起点s到该顶点的距离</strong>(例如，<code>U</code>中顶点<code>v</code>的距离为<code>(s,v)</code>的长度，如果<code>s</code>和<code>v</code>不相邻，则<code>v</code>的距离为<code>∞</code>]。</li>
</ol></li>
<li><ol start="2" type="1">
<li>从U中选出<strong>距离最短的顶点k</strong>，并将顶点k加入<code>S</code>中；同时，从<code>U</code>中移除顶点k。</li>
</ol></li>
<li><ol start="3" type="1">
<li>更新<code>U</code>中各个顶点到起点<code>s</code>的距离。这是由于上一步中确定了<code>k</code>是求出最短路径的顶点，从而可以利用<code>k</code>来更新其它顶点的距离；例如，<code>l(sv)&gt;l(sk)+l(kv)</code>,那么就得用<code>l(sk)+l(kv)</code>替换<code>l(sv)</code></li>
</ol></li>
<li><ol start="4" type="1">
<li>重复步骤(2)和(3)，直到遍历完所有顶点。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/D.png" width="350"> <strong>如下所示解法：</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/D2.png" width="500"></li>
</ol></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//D算法最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec, map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; w, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//该集合指示未进行迭代的顶点</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; notDofVertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (i != V)</span><br><span class="line">            notDofVertices.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="type">int</span> currentVertice = V; <span class="comment">//记录迭代的顶点</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">2048</span><span class="number">-1</span>;	<span class="comment">//2048表示∞</span></span><br><span class="line">    <span class="keyword">while</span> (!notDofVertices.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//确定点V到点notDofVertices[index]最短路径min，确定顶点index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; notDofVertices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[currentVertice][notDofVertices[i]]&gt; min)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                index = notDofVertices[i];</span><br><span class="line">                min = vec[currentVertice][index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先保存一些原来的顶点</span></span><br><span class="line">        <span class="type">int</span> originV = currentVertice;</span><br><span class="line">        <span class="comment">//下一次迭代要遍历的顶点</span></span><br><span class="line">        currentVertice = index;</span><br><span class="line">        <span class="comment">//从notDofVertices删除顶点index</span></span><br><span class="line">        <span class="keyword">auto</span> t = <span class="built_in">find</span>(notDofVertices.<span class="built_in">begin</span>(), notDofVertices.<span class="built_in">end</span>(),index);</span><br><span class="line">        notDofVertices.<span class="built_in">erase</span>(t, t + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//点放入w</span></span><br><span class="line">        w[index] = min;</span><br><span class="line">        <span class="comment">//更新vec</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; notDofVertices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            index = notDofVertices[i];</span><br><span class="line">            vec[currentVertice][index] = vec[originV][index] &lt;= vec[currentVertice][index] + min?</span><br><span class="line">                vec[originV][index] : vec[currentVertice][index] + min;</span><br><span class="line">        &#125;</span><br><span class="line">        min = <span class="number">2048</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用int main()&#123;</span></span><br><span class="line">	 vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec&#123; &#123;<span class="number">2048</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2048</span>,<span class="number">2048</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2</span>,<span class="number">2048</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2048</span>,<span class="number">2048</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2048</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2048</span>,<span class="number">1</span>,<span class="number">2048</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2048</span>,<span class="number">2048</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2048</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2048</span>,<span class="number">2048</span>,<span class="number">5</span>,<span class="number">2048</span>,<span class="number">2</span>,<span class="number">2048</span>&#125; &#125;;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mymap;</span><br><span class="line">    <span class="built_in">dijkstra</span>(vec, mymap, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 弗洛伊德算法</strong></p>
<p><strong>弗洛伊德算法是求每一对顶点之间的最短路径</strong>，其实调用<code>n</code>次<code>dijkstra</code>函数也能求出每一对顶点之间的最短路径，时间复杂度为<code>O(n*n*n)</code>。但是在这里我们介绍比较简洁的<code>Floyd</code>算法。<code>Floyd</code>算法的<strong>基本思想,可以将问题分解:</strong></p>
<ul>
<li><strong>第一先找出最短的距离</strong></li>
<li><strong>第二再考虑如何找出对应的行进路线。</strong></li>
</ul>
<p>如何找出最短路径呢，这里还是用到<strong>动态规划的知识</strong>，对于任何一个城市而言，<code>i</code>到<code>j</code>的最短距离不外乎存在<code>i</code>到<code>j</code>之间经过<code>k</code>和不经过<code>k</code>两种可能，所以可以令<code>k=1，2，3，...，n</code>(n是城市的数目)，<strong>在检查<code>d(ij)</code>与<code>d(ik)+d(kj)</code>的值；在此<code>d(ik)</code>与<code>d(kj)</code>分别是目前为止所知道的<code>i</code>到<code>k</code>与<code>k</code>到<code>j</code>的最短距离，因此<code>d(ik)+d(kj)</code>就是<code>i</code>到<code>j</code>经过<code>k</code>的最短距离</strong>。所以，若有<code>d(ij)&gt;d(ik)+d(kj)</code>，就表示从<code>i</code>出发经过<code>k</code>再到<code>j</code>的距离要比原来的<code>i</code>到<code>j</code>距离短，自然把<code>i</code>到<code>j</code>的<code>d(ij)</code>重写为<code>d(ik)+d(kj)</code>，<strong>每当一个k查完了，<code>d(ij)</code>就是目前的<code>i</code>到<code>j</code>的最短距离。重复这一过程，最后当查完所有的<code>k</code>时，<code>d(ij)</code>里面存放的就是i到j之间的最短距离了。</strong></p>
<p><strong>实现过程：</strong></p>
<ul>
<li>写出图的初始距离矩阵<code>W0</code>和初始路由矩阵<code>R0</code></li>
</ul>
<p><span class="math display">\[
W^0=
\begin{cases}
d_{ij}，当v_i与v_j间有边时\\
∞，当v_i与v_j间无边时\\
0，i=j
\end{cases}
\]</span> <span class="math display">\[
R^0=
\begin{cases}
j，当W^0&lt;∞，i→j前次经过的中间点\\
0，W^0=∞或i=j
\end{cases}
\]</span></p>
<ul>
<li>依次将G中的各节点<code>K</code>作为中间节点，求<code>Wij</code>的最短路径,<code>k=1,2,3...n</code>。当节点<code>K</code>为中间节点时,要更新矩阵：</li>
</ul>
<p><span class="math display">\[
W^K=
\begin{cases}
min(W^{K-1}_{ij},W^{k-1}_{ik}+W^{k-1}_{kj})
\end{cases}
\]</span> <span class="math display">\[
R^k_{ij}=
\begin{cases}
k，,W^{k-1}_{ik}+W^{k-1}_{kj}时进行更新\\
r^{k-1}_{ij}，不更新
\end{cases}
\]</span></p>
<ul>
<li>当<code>k=n</code>时，得到的W矩阵即为各顶点间的最短距离，<code>R</code>为路径选择 <strong>如下的例题：</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/F.png" width="200"> 由<code>R0</code>知道经过V1作为中间节点可得<code>W1</code>和<code>R1</code>： <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/F2.png" width="600"> 再由<code>R1</code>知道经过<code>V2</code>可得<code>W2</code>和<code>R2</code> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/F3.png" width="600"></li>
</ul>
<p><strong>经过上面的两个图可以知道，我们对矩阵的改变其实只用看当前节点所在的行和列，有数字时可能会发生改变，此时进行<code>d(ij)</code>与<code>d(ik)+d(kj)</code>的比较看是否要更新。</strong></p>
<h6 id="拓扑排序">12.5.2 拓扑排序</h6>
<p>当且仅当一个有向图为有向无环图<code>DAG，directed acyclic graph</code>时，才能得到对应于该图的拓扑排序。每个有向无环图都至少存在一种拓扑排序。<strong>一般来说拓扑排序主要应用于判断有向图是否有环</strong>。</p>
<p><strong>实现：</strong>对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则必无环。一般采用邻接表，每个头节点增加一存储入度的数据域。一般为避免重复检测入度为0的点，可设一栈或队列暂存入度为0的点，也可以设置标志位<code>isnotPutInSet</code></p>
<ul>
<li>在有向图中选择一个没有前驱即入度为<code>0</code>的顶点输出之</li>
<li>从图中删除该顶点和所有以他为头的弧，并且相应的尾顶点<code>入度-1</code></li>
<li>重复上述两步直至无法输出</li>
<li>若此时输出的顶点数小于有向图的定点数，则说明有向图中存在回路，否则输出的顶点的顺序即为一个拓扑序列</li>
</ul>
<p><img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/topoSort.png" width="300"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(n*n)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">graph</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> indegree;</span><br><span class="line">    <span class="type">int</span> numberofVertices;</span><br><span class="line">    <span class="built_in">graph</span>(<span class="type">int</span> _in, <span class="type">int</span> vertices) :<span class="built_in">indegree</span>(_in), <span class="built_in">numberofVertices</span>(vertices) &#123;&#125;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; linkV;</span><br><span class="line">    <span class="type">bool</span> isnotPutInSet = <span class="literal">true</span>;</span><br><span class="line">    ~<span class="built_in">graph</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topoSort</span><span class="params">(vector&lt;graph&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; zeroIndegreeVertices;</span><br><span class="line">   <span class="comment">// int Size = vec.size();</span></span><br><span class="line">    <span class="comment">//int count = 0;</span></span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (it != vec.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;indegree == <span class="number">0</span> &amp;&amp; it-&gt;isnotPutInSet)</span><br><span class="line">        &#123;</span><br><span class="line">            zeroIndegreeVertices.<span class="built_in">insert</span>(it-&gt;numberofVertices);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = it-&gt;linkV.<span class="built_in">begin</span>(); iter != it-&gt;linkV.<span class="built_in">end</span>(); iter++)</span><br><span class="line">            &#123;</span><br><span class="line">                --vec[*iter<span class="number">-1</span>].indegree;</span><br><span class="line">            &#125;</span><br><span class="line">            it-&gt;isnotPutInSet = <span class="literal">false</span>;</span><br><span class="line">            it = vec.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() == zeroIndegreeVertices.<span class="built_in">size</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;该图无环路&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;该图有环路&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调试</span></span><br><span class="line">	vector&lt;graph&gt; gvec;</span><br><span class="line">    <span class="function">graph <span class="title">v1</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    v1.linkV.<span class="built_in">insert</span>(&#123; <span class="number">2</span>,<span class="number">4</span> &#125;);</span><br><span class="line">    <span class="function">graph <span class="title">v2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    v2.linkV.<span class="built_in">insert</span>(&#123; <span class="number">3</span>,<span class="number">4</span> &#125;);</span><br><span class="line">    <span class="function">graph <span class="title">v3</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">graph <span class="title">v4</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    v4.linkV.<span class="built_in">insert</span>(&#123; <span class="number">3</span> &#125;);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    gvec.<span class="built_in">push_back</span>(v4);</span><br><span class="line">    <span class="built_in">topoSort</span>(gvec);</span><br></pre></td></tr></table></figure></p>
<h6 id="最小生成树">12.5.3 最小生成树</h6>
<p>最小代价生成树即指对带权无向图包含所有<code>n</code>个顶点和<code>n-1</code>条边，联通所有结点后代价最小的树。假设<code>N =(V，&#123; E &#125;)</code>是一个连通网，<code>U</code>是顶点集<code>V</code>的一个非空子集。若<code>(u , v)</code>是一条具有最小权值（代价）的边，其中<code>u∈U</code>， <code>v∈(V - U)</code>，则必存在一棵包含边（u，v）的最小生成树。最小生成树的算法有<strong>普里姆算法和克鲁斯卡尔算法。</strong></p>
<p><strong>1. 普里姆(prim)算法</strong></p>
<p><strong>算法思路：</strong>首先就是从图中的一个起点<code>a</code>开始，把<code>a</code>加入<code>U</code>集合，然后，寻找从与<code>a</code>有关联的边中，权重最小的那条边并且该边的终点<code>b</code>在顶点集合：<code>(V-U)</code>中，我们也把<code>b</code>加入到集合<code>U</code>中，并且输出边<code>(a，b)</code>的信息，这样我们的集合U就有：<code>&#123;a,b&#125;</code>，然后，我们寻找与<code>a</code>关联和<code>b</code>关联的边中，权重最小的那条边并且该边的终点在集合：<code>(V-U)</code>中，我们把<code>c</code>加入到集合<code>U</code>中，并且输出对应的那条边的信息，这样我们的集合U就有：<code>&#123;a,b,c&#125;</code>这三个元素了，依次类推，直到所有顶点都加入到了集合<code>U</code>。其实就是<strong>贪心算法</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/prim.png" width="600"> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用邻接矩阵结构，复杂度为O(n*n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ve;     <span class="comment">//U集合记录顶点，</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; reachV;    <span class="comment">//记录已到达过的顶点</span></span><br><span class="line">    ve.<span class="built_in">push_back</span>(<span class="number">0</span>);    <span class="comment">//直接将V0加入集合U</span></span><br><span class="line">    reachV.<span class="built_in">insert</span>(<span class="number">0</span>);   <span class="comment">//0已到达过</span></span><br><span class="line">    <span class="keyword">while</span> (ve.<span class="built_in">size</span>() != vec.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX;</span><br><span class="line">        <span class="type">int</span> sourceV = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> toVertice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ve.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> vertice = ve[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vec[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &lt; vec[vertice][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;   <span class="comment">//若当前记录的的min权值大于当前两节点边的权值，进行更新</span></span><br><span class="line">                    <span class="keyword">if</span> (reachV.<span class="built_in">find</span>(j)==reachV.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        min = vec[vertice][j];</span><br><span class="line">                        toVertice = j;</span><br><span class="line">                        sourceV = vertice;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ve.<span class="built_in">push_back</span>(toVertice);</span><br><span class="line">        reachV.<span class="built_in">insert</span>(toVertice);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;V&quot;</span>&lt;&lt;sourceV+<span class="number">1</span> &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; <span class="string">&quot;V&quot;</span></span><br><span class="line">			&lt;&lt; toVertice+<span class="number">1</span> &lt;&lt; <span class="string">&quot; 权值:&quot;</span> &lt;&lt; min &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vec&#123; &#123;INT_MAX,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,INT_MAX,INT_MAX&#125;,</span><br><span class="line">                            &#123;<span class="number">6</span>,INT_MAX,<span class="number">5</span>,INT_MAX,<span class="number">3</span>,INT_MAX&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>,<span class="number">5</span>,INT_MAX,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>,INT_MAX,<span class="number">5</span>,INT_MAX,INT_MAX,<span class="number">2</span>&#125;,</span><br><span class="line">                            &#123;INT_MAX,<span class="number">3</span>,<span class="number">6</span>,INT_MAX,INT_MAX,<span class="number">6</span>&#125;,</span><br><span class="line">                            &#123;INT_MAX,INT_MAX,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,INT_MAX&#125; &#125;;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> it : vec) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">auto</span> i : it)</span><br><span class="line">               <span class="keyword">if</span> (i == INT_MAX)</span><br><span class="line">                   cout &lt;&lt; <span class="string">&quot;∞ &quot;</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">           cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">prim</span>(vec);</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 克鲁斯卡算法</strong></p>
<p>算法思路：</p>
<ul>
<li>（1）将图中的所有边都去掉。</li>
<li>（2）将边按权值从小到大的顺序添加到图中，保证添加的过程中不会形成环</li>
<li>（3）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/kelusika.png" width="700"></li>
</ul>
<h4 id="b-tree">13. B-Tree</h4>
<p>对存储在磁盘上的数据，<code>B-Tree</code>是一种适合索引方法的数据结构。</p>
<h5 id="b-tree的特点">13.1 B-Tree的特点</h5>
<p><code>B-Tree</code>也称B树是一种平衡的多路查找树。一颗3阶的B树，其内部节点必须有2~3个孩子。因此可知道一颗m阶B树（空树/m叉树），必须满足以下特性：</p>
<ul>
<li><strong>树中每个结点至多有<code>m</code>棵子树，即至多含有<code>m-1</code>个关键字</strong></li>
<li><strong>若根结点不是叶子结点，则至少有两棵子树</strong></li>
<li>除根之外的所有非终端结点至少有<code>[m/2]</code>棵子树，<code>[]</code>表示向上取整。</li>
<li>所有非终端结点包含下列信息数据<code>n,P0,K1,P1,K2......Kn,Pn</code>;其中<code>Kn</code>为关键字，<code>Pn</code>为指向下面子树根节点的指针。他有：
<ul>
<li>①当<code>i&lt;j</code>时，<code>Ki&lt;Kj</code>；</li>
<li>②当<code>i&lt;j</code>时，对于指针<code>Pi</code>指向的子树根节点的关键子都必须小于<code>Kj</code>，而当<code>i&gt;j</code>时必须<code>Pi</code>所指子树根节点的关键子都必须大于<code>Kj</code>（即从小到大）；</li>
<li>③关键子个数<code>[m/2]-1≤n≤m-1</code></li>
</ul></li>
<li><strong>所有叶子结点都在同一层</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTree.png" width="600"></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> m 3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span>&#123;</span><br><span class="line"><span class="type">int</span> keyNum;						<span class="comment">//该节点关键字数量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span> *parent;			<span class="comment">//指向父亲结点</span></span><br><span class="line">KeyTyep	key[m+<span class="number">1</span>];				    <span class="comment">//关键字大小，0号单元未使用</span></span><br><span class="line"><span class="keyword">struct</span>	<span class="title class_">BTNode</span>	*ptr[m+<span class="number">1</span>];		<span class="comment">//指向子树的指针，0号单元未使用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>	*recptr[m+<span class="number">1</span>]；			<span class="comment">//指向该关键字的数据域</span></span><br><span class="line">&#125;BTNode,*BTree;</span><br></pre></td></tr></table></figure>
<h5 id="b-tree的高">13.2 B-Tree的高</h5>
<p>对于B-Tree的定理有：设T为一颗高度为<code>h</code>的<code>m</code>阶B-Tree，n为T的元素个数，<code>d=[m/2]</code>,则有：</p>
<ul>
<li><span class="math inline">\(2d^{h-1}≤n≤m^k-1\)</span></li>
<li><span class="math inline">\(log_m{n+1}≤h≤log_d \frac{n+1}2+1\)</span></li>
</ul>
<p>则有上面的公式可以知道，一颗高度为5的200阶B-Tree至少有<span class="math inline">\(2*10^8-1\)</span>个元素。这种高度低且一个节点有多个元素的结构很符合磁盘的一次性存储与取出大小适当数据量。</p>
<h5 id="b-tree的操作">13.3 B-Tree的操作</h5>
<h6 id="b-tree的搜索">13.3.1 B-Tree的搜索</h6>
<p>B-Tree的搜索算法与m叉搜索树的搜索算法相同。在搜索过程中，从根部至外部节点路径上的所有内部节点通过比较关键子大小选择以哪条路径行进，直到相等或者到<code>NULL</code>，因此，磁盘访问次数最多是<code>h</code></p>
<h6 id="b-tree的插入">13.3.2 B-Tree的插入</h6>
<p>对于B-Tree的插入，首先经过关键字搜索比较找到插入的节点，之后有如下法则</p>
<ul>
<li>为空时直接插入到根节点记录</li>
<li>插入的节点为不饱和节点，则直接插入，不必做其他操作</li>
<li><strong>如果插入的时饱和节点，则先插入，然后取中上升，其余的进行分裂</strong> <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeInsert.png" width="600"></li>
</ul>
<h6 id="b-tree的删除">13.3.3 B-Tree的删除</h6>
<p>B-Tree的删除会破坏规则：每个非终端节点至少含有<code>[m/2]</code>棵子树，即每个非终端节点的要有<code>[m/2]-1</code>个关键字；或者破坏了指针指向。因此为恢复该规则进行操作有：</p>
<p><strong>删除叶子关键字：</strong></p>
<ul>
<li>若该叶子节点删除该关键字后，仍满足关键字数量范围，直接删除</li>
<li>若叶子结点删除该关键字后，不满足关键字数量范围，但兄弟结点关键字＞<code>[m/2]-1</code>,兄弟借（途经父亲）</li>
<li>若叶子结点删除该关键字后，不满足关键字数量范围，且兄弟结点关键字=<code>[m/2]-1</code>,向父借，拖父下水 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeDeleteLeaf.png" width="500"></li>
</ul>
<p><strong>删除非叶子关键字</strong>:</p>
<ul>
<li>向该节点要删除的关键字的左子树最大关键字或右子树最小关键字借。</li>
<li>题目已规定要向谁借，但借完不符合要求，但此时兄弟可借，直接借兄弟的</li>
<li>借完不和，兄也不可借，兄弟合并 <img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeDeleteNotLeaf.png" width="700"></li>
</ul>
<h4 id="b树">14. B+树</h4>
<h5 id="b树与b树的不同点">14.1 B+树与B树的不同点</h5>
<p><strong>B+树是应文件系统所需而出的一种B-树的变型树</strong>。一棵m阶的B+树和m阶的B-树的差异在于：</p>
<ul>
<li><p><strong>非叶子结点的子树指针与关键字个数相同或者子树指针数=关键字个数+1</strong>；</p></li>
<li><p><strong>非叶结点仅具有索引下一层作用，不存储数据的指针，跟记录有关的信息均存放在叶结点中</strong>。</p></li>
<li><p>非叶子结点的子树指针<code>P[i]</code>，指向关键字值属于<code>[K[i], K[i+1])</code>的子树（B树是开区间）；</p></li>
<li><p><strong>为所有叶子结点增加一个链指针；树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</strong></p></li>
<li><p><strong>所有关键字具体数据或者数据“地址”只存储在叶子结点。</strong></p></li>
</ul>
<p><img src="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/BTreeadd.png" width="700"></p>
<p><strong><em>注意：说到B+Tree的叶子节点，必须区分MySQL中的聚簇索引和非聚簇索引（二级索引），在聚簇索引的叶子节点存储的是完整的行数据，而二级索引叶子节点存储的是数据<code>行指针</code>,这里的<code>行指针</code>的实质是叶子节点保存只是行的主键值，因此非聚簇索引必须还要在聚簇索引结构上进行查找，这也是为什么它被称为二级索引</em></strong></p>
<h5 id="为什么b树更适合做索引">14.2 为什么B+树更适合做索引</h5>
<p><strong>我们先分析B+d与众不同的特点：</strong></p>
<ul>
<li>第一个就是B+树在B树的基础之上最重要的改进就是非叶子结点只存储关键字和下一层的索引，不存储Data域，只在叶子结点存储Data域；</li>
<li>第二点就是所有叶子结点增加一个链指针，使所有叶结点构成一个有序链表，因此当我们需要有序遍历所有关键字时，直接从最小关键字的叶子结点开始遍历即可。</li>
</ul>
<h6 id="非叶子结点不存储data域的好处">14.2.1非叶子结点不存储Data域的好处</h6>
<ul>
<li><p><strong>每一个结点可以存放更多的关键字和下一层的索引。数据库是存储在磁盘上的，我们读取数据是从磁盘读取到内存中，我们在进行磁盘预读取时，是以块的单位进行数据读取，我们在检索B/B+树的结点时，每次以块为单位将一个结点读取到内存中，若一块磁盘包含了树结点以外的数据，就造成了浪费，因此我们需要使每一个结点的数据大小正好或者接近一块磁盘的大小</strong>。于是我们在构建B+/B树时，树的阶数其实就取决于一块磁盘中能容纳多少个关键字以及相关的索引和Data域。<strong>B+树的非叶子结点不存储Data域，因此它可以存储更多个关键字和下一层索引，因此B+树会比B树更宽胖</strong>。若我需要查找的关键字正好在叶子结点，B+树所进行的I/O次数更少,因为途中经过每一层，我们都需要进行一次I/O读取一个结点，B+树会更矮，途径的层数会更少。</p></li>
<li><p>使得B+树查询速度更稳定，B+树所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p></li>
</ul>
<h6 id="所有叶结点构成一个有序链表的好处">14.2.2所有叶结点构成一个有序链表的好处</h6>
<ul>
<li><p><strong>B+树便于区间查找（这点才是B+树作为索引的关键）</strong>，我们进行数据库查询大多为区间查询，B+树天然具备排序功能，B+树所有的叶子结点构成了一个有序链表，在查询大小区间的数据时候更方便，B+树查询，只需通过头结点往下找到第一个叶子结点，然后在叶子结点的链表上就行遍历即可完成区间查询，而B树的关键字大小相邻近的结点可能隔得很远，要想进行区间查询需要不停的进行中序遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p></li>
<li><p>B+树全结点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要进行中序遍历，这有利于数据库做全表扫描。</p></li>
</ul>
<p><strong>总结B+树优点(选择B+树作为索引的原因)</strong></p>
<ul>
<li>因为没有非叶子节点没有存储数据，因此单一非叶子结点能存储更多的关键字索引</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；</li>
<li>所有叶子节点形成有序链表，便于范围查询以及全结点遍历更快。</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="trluper 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="trluper 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E6%9D%BF/" rel="prev" title="C++面向对象&模板">
      <i class="fa fa-chevron-left"></i> C++面向对象&模板
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/12/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" rel="next" title="STL源码剖析">
      STL源码剖析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>
    

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.</span> <span class="nav-text">1.说在前面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">2. 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 数组介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#linerlist%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 linerList抽象类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 C++实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 C实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">3. 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 单链表介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 C++实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 C实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 双向链表介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%B1%E5%AD%90%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1 箱子排序(链表形式)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2 基数排序（数组形式）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.4.3 并查集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">4.</span> <span class="nav-text">4. 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 栈的介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 C++实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c%E5%AE%9E%E7%8E%B0-5"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 C实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8-1"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%81%A5%E5%A3%AE%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 健壮四则运算</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 括号匹配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">5. 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E5%88%97"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 链队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 循环队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 链队列实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E5%92%8C%E5%93%88%E5%B8%8C%E6%95%A3%E5%88%97"><span class="nav-number">6.</span> <span class="nav-text">6. 跳表和哈希散列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 跳表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 实现原理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 哈希表（散列表）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 实现原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E6%96%B9%E6%A1%88"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 解决hash冲突方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">7. 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 树的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%89%B9%E6%80%A7"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 二叉树特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">7.4.1.</span> <span class="nav-text">7.4.1 顺序存储</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">7.4.2.</span> <span class="nav-text">7.4.2 链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">7.5.</span> <span class="nav-text">7.5 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">7.5.1.</span> <span class="nav-text">7.5.1 结构体和实现类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.5.2.</span> <span class="nav-text">7.5.2 前序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.5.3.</span> <span class="nav-text">7.5.3 中序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.5.4.</span> <span class="nav-text">7.5.4 后序遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">7.5.5.</span> <span class="nav-text">7.5.5 层次遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B1%82%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-number">7.5.6.</span> <span class="nav-text">7.5.6 求树的深度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8-2"><span class="nav-number">7.6.</span> <span class="nav-text">7.6 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="nav-number">7.6.1.</span> <span class="nav-text">7.6.1 并查集</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">7.6.2.</span> <span class="nav-text">7.6.2 二叉树的右视图</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.6.3.</span> <span class="nav-text">7.6.3 完全二叉树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.6.4.</span> <span class="nav-text">7.6.4 对称二叉树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.6.5.</span> <span class="nav-text">7.6.5 平衡二叉树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D"><span class="nav-number">7.6.6.</span> <span class="nav-text">7.6.6 二叉树剪枝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">8.</span> <span class="nav-text">8. 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 堆的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5"><span class="nav-number">8.1.1.</span> <span class="nav-text">8.1.1 堆的插入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">8.1.2.</span> <span class="nav-text">8.1.2 堆的删除</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.1.3.</span> <span class="nav-text">8.1.3 堆的初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">9.</span> <span class="nav-text">9. 二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="nav-number">9.1.</span> <span class="nav-text">9.1 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2"><span class="nav-number">9.1.1.</span> <span class="nav-text">9.1.1 搜索</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-number">9.1.2.</span> <span class="nav-text">9.1.2 插入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">9.1.3.</span> <span class="nav-text">9.1.3 删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91avl"><span class="nav-number">10.</span> <span class="nav-text">10. 平衡二叉搜索树AVL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">10.1.</span> <span class="nav-text">10.1 平衡二叉搜索树的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2-1"><span class="nav-number">10.2.</span> <span class="nav-text">10.2 搜索</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">10.3.</span> <span class="nav-text">10.3 插入操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="nav-number">10.3.1.</span> <span class="nav-text">10.3.1 插入的具体步骤</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%B1%E8%A1%A1%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">10.3.2.</span> <span class="nav-text">10.3.2 失衡的情况</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%B1%E8%A1%A1%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">10.3.3.</span> <span class="nav-text">10.3.3 失衡的种类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ll%E5%9E%8B%E5%B9%B3%E8%A1%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">10.3.4.</span> <span class="nav-text">10.3.4 LL型平衡操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#rr%E5%9E%8B%E5%B9%B3%E8%A1%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">10.3.5.</span> <span class="nav-text">10.3.5 RR型平衡操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#lr%E5%9E%8B%E5%B9%B3%E8%A1%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">10.3.6.</span> <span class="nav-text">10.3.6 LR型平衡操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#rl%E5%9E%8B%E5%B9%B3%E8%A1%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">10.3.7.</span> <span class="nav-text">10.3.7 RL型平衡操作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">10.4.</span> <span class="nav-text">10.4 删除操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="nav-number">10.4.1.</span> <span class="nav-text">10.4.1 删除节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="nav-number">10.4.2.</span> <span class="nav-text">10.4.2 平衡性检查</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">11.</span> <span class="nav-text">11. 红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%89%B9%E7%82%B9"><span class="nav-number">11.1.</span> <span class="nav-text">11.1 红黑树特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%93%8D%E4%BD%9C"><span class="nav-number">11.2.</span> <span class="nav-text">11.2 红黑树操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B5%8B%E4%B8%BA%E7%BA%A2%E8%89%B2%E8%80%8C%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%B1%BB%E5%9E%8B"><span class="nav-number">11.2.1.</span> <span class="nav-text">11.2.1 赋为红色而造成的不平衡类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">12.</span> <span class="nav-text">12. 图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">12.1.</span> <span class="nav-text">12.1 图的基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">12.2.</span> <span class="nav-text">12.2 无权图的描述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">12.2.1.</span> <span class="nav-text">12.2.1 邻接矩阵</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E9%93%BE%E8%A1%A8"><span class="nav-number">12.2.2.</span> <span class="nav-text">12.2.2 邻接链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E6%95%B0%E7%BB%84"><span class="nav-number">12.2.3.</span> <span class="nav-text">12.2.3 邻接数组</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">12.3.</span> <span class="nav-text">12.3 链表类的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">12.4.</span> <span class="nav-text">12.4 图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs"><span class="nav-number">12.4.1.</span> <span class="nav-text">12.4.1 广度优先搜索(BFS)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2dfs"><span class="nav-number">12.4.2.</span> <span class="nav-text">12.4.2 深度优先搜索(DFS)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">12.5.</span> <span class="nav-text">12.5 图的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">12.5.1.</span> <span class="nav-text">12.5.1 最短路径</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">12.5.2.</span> <span class="nav-text">12.5.2 拓扑排序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">12.5.3.</span> <span class="nav-text">12.5.3 最小生成树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-tree"><span class="nav-number">13.</span> <span class="nav-text">13. B-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#b-tree%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">13.1.</span> <span class="nav-text">13.1 B-Tree的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-tree%E7%9A%84%E9%AB%98"><span class="nav-number">13.2.</span> <span class="nav-text">13.2 B-Tree的高</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-tree%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">13.3.</span> <span class="nav-text">13.3 B-Tree的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#b-tree%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-number">13.3.1.</span> <span class="nav-text">13.3.1 B-Tree的搜索</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-tree%E7%9A%84%E6%8F%92%E5%85%A5"><span class="nav-number">13.3.2.</span> <span class="nav-text">13.3.2 B-Tree的插入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-tree%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">13.3.3.</span> <span class="nav-text">13.3.3 B-Tree的删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b%E6%A0%91"><span class="nav-number">14.</span> <span class="nav-text">14. B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#b%E6%A0%91%E4%B8%8Eb%E6%A0%91%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="nav-number">14.1.</span> <span class="nav-text">14.1 B+树与B树的不同点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88b%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%81%9A%E7%B4%A2%E5%BC%95"><span class="nav-number">14.2.</span> <span class="nav-text">14.2 为什么B+树更适合做索引</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%9E%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E4%B8%8D%E5%AD%98%E5%82%A8data%E5%9F%9F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">14.2.1.</span> <span class="nav-text">14.2.1非叶子结点不存储Data域的好处</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E5%8F%B6%E7%BB%93%E7%82%B9%E6%9E%84%E6%88%90%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">14.2.2.</span> <span class="nav-text">14.2.2所有叶结点构成一个有序链表的好处</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">648k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:49</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="">

<script>
  NexT.utils.getScript('', () => {
    var gitalk = new Gitalk({
      clientID: '123fe329fdbb06b0f1d1',
      clientSecret: '40add829107b6e69f43274d3545ae71c988de8eb',
      repo: 'trluper.github.io',
      owner: 'trluper',
      admin: ['trluper'],
      id: 'a6e4607a6006e3c29b591429f39b48a9',
        language: '',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

</body>
</html>
