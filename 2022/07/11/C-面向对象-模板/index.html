<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 面向对象程序设计 面向对象程序设计的核心思想是数据抽象、继承和动态绑定。通过数据抽象，我们可以将类的接口与实现相分离；使用继承。可以使用相似的类型对其关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别。  1）继承：根部类为基类（相似于java的父类），其他继承于基类的类为派生类。 2）虚函数：某些函数，基类希望它的派生类各自定义适合其自生的函数 3）动态绑定：能使用同一代">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面向对象&amp;模板">
<meta property="og:url" content="https://example.com/2022/07/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E6%9D%BF/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:description" content="1. 面向对象程序设计 面向对象程序设计的核心思想是数据抽象、继承和动态绑定。通过数据抽象，我们可以将类的接口与实现相分离；使用继承。可以使用相似的类型对其关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别。  1）继承：根部类为基类（相似于java的父类），其他继承于基类的类为派生类。 2）虚函数：某些函数，基类希望它的派生类各自定义适合其自生的函数 3）动态绑定：能使用同一代">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-11T13:49:55.000Z">
<meta property="article:modified_time" content="2023-03-06T11:07:29.830Z">
<meta property="article:author" content="trluper">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/07/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E6%9D%BF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++面向对象&模板 | Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/07/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++面向对象&模板
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-11 21:49:55" itemprop="dateCreated datePublished" datetime="2022-07-11T21:49:55+08:00">2022-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-06 19:07:29" itemprop="dateModified" datetime="2023-03-06T19:07:29+08:00">2023-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="面向对象程序设计">1. 面向对象程序设计</h3>
<p>面向对象程序设计的核心思想是<strong>数据抽象、继承和动态绑定</strong>。通过数据抽象，我们可以将类的接口与实现相分离；使用继承。可以使用相似的类型对其关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别。</p>
<ul>
<li>1）继承：根部类为基类（相似于java的父类），其他继承于基类的类为派生类。</li>
<li>2）虚函数：某些函数，基类希望它的派生类各自定义适合其自生的函数</li>
<li>3）动态绑定：能使用同一代码分别处理基类和派生类。如虚函数运行版本由实参决定。</li>
</ul>
<h4 id="定义基类">1.1 定义基类</h4>
<ul>
<li>作为继承关系中根结点的类<strong>通常有定义了一个虚析构函数</strong>。</li>
<li>基类中的成员函数分为两种：<strong>一是派生类要进行重写覆盖的函数，称为虚函数</strong>；<strong>二是希望直接继承而不改变的函数</strong>。当我们使用指针或引用调用虚函数时，该调用将被<strong>动态绑定</strong>。</li>
<li>基类通过在其成员函数的声明语句之前加上关键字<code>virtual</code>使得函数执行<strong>动态绑定</strong>。其只能出现在类内部声明或定义中。</li>
<li>派生类可以继承定义在基类中的成员，但是派生类的的成员函数不一定有权访问从基类继承而来的成员。派生类能访问公有成员，但不能访问私有成员。为解决这一问题，引入了新访问运算符：<code>protected</code>(派生类有权访问，禁止用户访问）</li>
</ul>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;		<span class="comment">//定义基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Quote</span>(<span class="type">const</span> Quote&amp; q):<span class="built_in">bookNo</span>(q.bookNo),<span class="built_in">price</span>(q.price)&#123;&#125;</span><br><span class="line">	<span class="built_in">Quote</span>(<span class="type">const</span> string&amp; _book,<span class="type">const</span> <span class="type">double</span> _price):<span class="built_in">bookNo</span>(_book),<span class="built_in">price</span>(_price)&#123;&#125;</span><br><span class="line">	<span class="function">string <span class="title">isbn</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> n*price;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string bookNo;		<span class="comment">//派生类无权访问</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">double</span> price=<span class="number">0</span>;		<span class="comment">//派生类可访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义派生类">1.2 定义派生类</h4>
<p>派生类需要使用类派生列表来指出它是从哪个基类继承而来的，每个基类前面可以有三种访问说明符<code>public、private、protected</code>中的一个。<strong>派生类需要将继承来的成员函数需要覆盖的进行重新声明。如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分，也能将公有类型的对象绑定到基类的引用或者指针上。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_Book</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="built_in">Bulk_Book</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Bulk_Book</span>(<span class="type">const</span> Bulk_Book&amp; bb):<span class="built_in">Quote</span>(bb.<span class="built_in">isbn</span>(),bb.price),</span><br><span class="line">			<span class="built_in">min_qty</span>(bb.<span class="built_in">getMin_qty</span>()),<span class="built_in">discount</span>(bb.<span class="built_in">getDiscount</span>())&#123;&#125;</span><br><span class="line">	<span class="built_in">Bulk_Book</span>(<span class="type">const</span> string&amp; _book,<span class="type">double</span> p,<span class="type">size_t</span> qty,<span class="type">double</span> disc):<span class="built_in">Quote</span>(_book,p),<span class="built_in">min_qyt</span>(qyt),<span class="built_in">discount</span>(disc)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span> n)</span><span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;min_qyt)</span><br><span class="line">			<span class="keyword">return</span> n*price*discount;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> n*price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">getMin_qty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> min_qty;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">getDiscpunt</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> discount;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Bulk_Book</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">size_t</span> min_qty=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> discount=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>派生类经常(但不总是)覆盖虚函数，派生类如果没有覆盖虚函数，则会直接继承其在基类中的版本。</li>
<li>派生类可以在它要覆盖的函数前面使用<code>virtual</code>,但不是非得这样做。C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数，既添加一个<code>override</code>。</li>
<li><strong>因为派生类对象中含有与基类对应得组成部分，所以我们能把派生类对象当成基类对象来使用（java的多态），同时也可把基类的指针或引用绑定到派生类对象得基类部分上。这种转换被称为派生类到基类的转换</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;			<span class="comment">//基类对象</span></span><br><span class="line">Bulk_Book bulk;		<span class="comment">//派生类对象</span></span><br><span class="line">Quote *p=&amp;item;		<span class="comment">//基类指针绑定带基类对象</span></span><br><span class="line">p=&amp;bulk;			<span class="comment">//基类指针也可绑定到派生类对象，反之不行（不安全）</span></span><br><span class="line">Quote &amp;r=bulk;		<span class="comment">//基类引用绑定带派生类上</span></span><br></pre></td></tr></table></figure>
<h5 id="派生类构造函数">1.2.1 派生类构造函数</h5>
<p><strong>派生类需要用基类的构造函数来初始化,每个类控制它自己的成员初始化过程</strong>。基类部分和自己的数据成员都在构造函数初始化阶段执行初始化操作，只不过由基类构造函数来初始化Bulk_quote的基类部分 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Bulk_Book</span>(<span class="type">const</span> Bulk_Book&amp; bb):<span class="built_in">Quote</span>(bb.<span class="built_in">isbn</span>(),bb.price),</span><br><span class="line">			<span class="built_in">min_qty</span>(bb.<span class="built_in">getMin_qty</span>()),<span class="built_in">discount</span>(bb.<span class="built_in">getDiscount</span>())&#123;&#125;</span><br><span class="line"><span class="built_in">Bulk_Book</span>(<span class="type">const</span> string&amp; _book,<span class="type">double</span> p,<span class="type">size_t</span> qty,<span class="type">double</span> disc):<span class="built_in">Quote</span>(_book,p),<span class="built_in">min_qyt</span>(qyt),<span class="built_in">discount</span>(disc)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="派生类使用基类成员">1.2.2 派生类使用基类成员</h5>
<p>派生类<strong>可以访问由基类继承来的的公有成员和受保护成员</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span> n)</span><span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;min_qyt)</span><br><span class="line">			<span class="keyword">return</span> n*price*discount;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> n*price;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="继承与静态成员">1.2.3 继承与静态成员</h5>
<p><strong>如果基类定义了一个静态成员，则在整个继承体系中都只存在该成员的唯一定义</strong>，无论从基类中派生出多少个类，<strong>对每个静态成员来说都只存在唯一的实例,属于一个类</strong>。静态成员遵循同样的访问控制规则，<strong>如果基类中成员private，派生类无权访问（只能由接口访问、或将该派生类声明为友元）</strong>，如果可访问，那么可通过基类或者派生类使用它。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">statmen</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::f</span><span class="params">(<span class="type">const</span> Derived &amp;s)</span></span>&#123;</span><br><span class="line">	Base::<span class="built_in">statmen</span>();		<span class="comment">//Base定义了statmen</span></span><br><span class="line">	Derived::<span class="built_in">statmen</span>();	<span class="comment">//Derived继承了statmen</span></span><br><span class="line">	s.<span class="built_in">statmen</span>();			<span class="comment">//通过Derived对象调用</span></span><br><span class="line">	<span class="built_in">statmen</span>();			<span class="comment">//通过this对象调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>其他规则：</strong></p>
<ul>
<li><strong>如果想将某个类用作基类，那么这个类必须已经定义而非仅仅声明，因为派生类要使用基类当中的成员，另外，这个规定隐含表示了：一个类不能派生它本身。</strong></li>
<li>一个类可以同时是基类和派生类。</li>
<li>可以通过<code>class Base final &#123;&#125;;</code>来阻止其他类来继承该类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Base是D1的直接基类，是D2的间接基类（D1既是派生类又是基类）。</span></span><br><span class="line"><span class="comment">//最终的派生链末端的类会包含直接基类的子对象以及每个间接基类的子对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>:<span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>:<span class="keyword">public</span> D1&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="类型转换与继承">1.3 类型转换与继承</h4>
<ul>
<li><p><strong>存在继承关系，我们可以将一个基类的引用或者指针绑定到派生类对象上</strong>。<strong><em>当使用存在继承关系的类型时，需将静态类型与动态类型区分开来：表达式的静态类型在编译时总是已知的，是变量声明时的类型或表达式生成的类型；动态类型是变量或者表达式表示的内存中对象的类型。但如果表达式既不是引用也不是指针，那么静态类型永远与动态类型一致。</em></strong></p></li>
<li><strong>不存在从基类向派生类的隐式类型转换(不安全)</strong>。
<ul>
<li><p>每个派生类对象包含一个基类部分，才能实现派生类向基类的隐式转换，所以一个基类不能隐式地转换为派生类： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_Book&amp; bulkr=base;		<span class="comment">//错误</span></span><br><span class="line">Bulk_Book* bulkp=&amp;base;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>另外一个特殊的是即使一个基类指针绑定在派生类对象上，我们也不能执行基类向派生类的转换，因为编译器判断的是指针或者引用的静态类型： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_Book bulk;</span><br><span class="line">Quote *itemp=&amp;bulk;		<span class="comment">//正确</span></span><br><span class="line">Bulk_Book *bulkp=itemp;	<span class="comment">//错误，不允许</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>对象之间不存在类型转换。派生类向基类的自动类型转换只针对指针或者引用</strong>，我们初始化或者赋值一个类类型的对象，实际上是在调用某个函数，这些函数可以接受一个引用作为参数，允许我们向基类形参传递一个派生类的对象，但又由于这些不是虚函数，显然这些函数只能处理基类的对象，派生类自有的成员被切掉了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为拷贝和赋值的参数为const Quote&amp;的引用类型</span></span><br><span class="line">Bulk_Book bulk;		<span class="comment">//派生类对象</span></span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;	<span class="comment">//允许，只不过在Bulk_Book上新增的被切掉</span></span><br><span class="line">item=bulk;			<span class="comment">//允许</span></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h4 id="虚函数">1.4 虚函数</h4>
<p><strong>当我们使用基类的引用或指针调用虚函数时会执行动态绑定(直到运行时，我们才会知道调用的是哪个版本---动态类型）。</strong></p>
<p><strong>1. 某个虚函数(参数）通过指针或者引用调用时，直到运行时才能确定调用哪个版本的函数，被调用的是与指针或者引用的动态类型匹配的哪个，需要注意的是只有通过指针或者引用调用虚函数才会发生动态绑定。通过对象调用的虚函数版本在编译时确定。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,<span class="type">const</span> Quote &amp;items,<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">//根据传入的items调用net_price,允许时才知道时基类的net_price还是派生类的</span></span><br><span class="line">	<span class="type">double</span> ret= items.<span class="built_in">net_price</span>(n);</span><br><span class="line">	os&lt;&lt;<span class="string">&quot;isbn:&quot;</span>&lt;&lt;items.<span class="built_in">isbn</span>()&lt;&lt;<span class="string">&quot; sold_num:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; total_price:&quot;</span>&lt;&lt;ret&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function">Quote <span class="title">base</span><span class="params">(<span class="string">&quot;0-2121-755&quot;</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout,base,<span class="number">10</span>);		<span class="comment">//item引用调用的是quote版本的net_price</span></span><br><span class="line"><span class="function">Bulk_quote <span class="title">bu_base</span><span class="params">(<span class="string">&quot;021-1141-143&quot;</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">0.9</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout,bu_base,<span class="number">10</span>);	<span class="comment">//item引用调用的是Bulk_quote版本的net_price</span></span><br></pre></td></tr></table></figure> <strong><em>注意：既当且仅当对通过引用或者指针调用虚函数时，才会出现运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同（这时支持多态性的根本所在）。</em></strong></p>
<p><strong>2. 一旦某个函数被声明为虚函数，则在所有派生类中都是虚函数（可加virtual也可不加），覆盖的版本形参类型、返回类型必须一致，(但如果返回的是类的引用或者指针时，可以不一样,但须保证基类和派生类的类型是可转换的，这将在后面简述：注意处)</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> )</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> B&amp; <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>;		<span class="comment">//可覆盖，但是不能加override</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span><span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="comment">//void f2(int)override;	//错误，参数不一样</span></span><br><span class="line">	<span class="function">D1&amp; <span class="title">f3</span><span class="params">()</span><span class="keyword">override</span></span>;		<span class="comment">//正确</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.final和override说名符：</strong>c++新标准中的<code>override</code>是为了说明派生类的中的虚函数，能让编译器为程序员发现一些错误：如参数并不匹配，返回类型不一致等，同时也让编译者知道它是一个（基类虚函数）到派生类重写的虚函数。<strong>函数被指定为<code>final</code>,则之后任何尝试覆盖该函数的操作都将引发错误</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span><span class="type">const</span> <span class="keyword">final</span></span>;		<span class="comment">//不允许后续的其他继承类覆盖</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.虚函数运行默认实参</strong>：虚函数也可以有默认实参，但是实参值由该次调用的<strong>静态类型决定</strong>，也就是如果通过基类的引用或指针调用虚函数，则使用基类虚函数定义的默认实参，不管动态类型如何。<strong>因此虚函数如果使用实参，最好基类和派生类的中定义的默认实参是一致的。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">int</span> b=<span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a=<span class="number">1</span>,<span class="type">int</span> b=<span class="number">4</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">B b;</span><br><span class="line">A *P=&amp;B;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();		<span class="comment">//调用B中的f，但是传入参数为A的默认参数，即B::f(0,3);</span></span><br></pre></td></tr></table></figure></p>
<p><strong>5. 回避虚函数的动态绑定机制：</strong>有些情况下希望强制执行虚函数的某个特定版本，可以使用作用域运算符，强制调用某个派生类或者基类的虚函数。如上述的<code>item</code>,如果是要<code>Quote</code>的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doeble ret=item.Queto::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="抽象基类">1.5 抽象基类</h4>
<p>含有<strong>纯虚函数</strong>的类是抽象基类。纯虚函数无需定义，通过在函数声明语句的分号之前书写=0就可以将一个虚函数说明为纯虚函数，它告诉用户该函数对于该类没有实际意义。不能在类的内部为一个=0的函数提供函数体。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Disc_quote</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Disc_quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Dis_quote</span>(<span class="type">const</span> string&amp; book,<span class="type">double</span> price,std::<span class="type">size_t</span> qty,<span class="type">double</span> disc):</span><br><span class="line">	<span class="built_in">Queto</span>(book,price),<span class="built_in">quantity</span>(qty),<span class="built_in">discount</span>(disc)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">net_prince</span><span class="params">(std::<span class="type">size_t</span> n)</span></span>=<span class="number">0</span>;		<span class="comment">//纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std:<span class="type">size_t</span> quantity=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> discount=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 这种抽象基类负责定义接口，后续的其他类可以覆盖该接口。<strong>我们不能实例化一个抽象基类的对象，但可以定义它的派生类（前提是该派生类覆盖定义了该纯虚函数）</strong>。</p>
<p>这个时候我们讲<code>Bulk_queto</code>直接继承与<code>Disc_quote</code>,而不是<code>Quot</code>e,值得一提的是，派生类构造函数只初始化它的直接基类： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> :<span class="keyword">public</span> Disc_quote</span><br><span class="line">&#123;	<span class="comment">//继承了isbn,prince,bookNo</span></span><br><span class="line">	<span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">		:<span class="built_in">Disc_quote</span>(book,p,qty,disc) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span><span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="访问控制与继承">1.6 访问控制与继承</h5>
<p>每个类分别控制自己成员的初始化过程和成员可访问特性</p>
<h5 id="protected">1.6.1 protected</h5>
<p><code>protected</code>受保护的成员，对类用户来说是不可访问的，对于派生类和友元来说是可访问的。派生类的成员或者友元只能通过派生类对象来访问基类的受保护成员！ <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;		<span class="comment">//能访问Sneaky::port_mem</span></span><br><span class="line">	<span class="comment">//friend void clobber(Base&amp;);			//不能访问Base::port_,e,</span></span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp; s)</span></span>&#123;s.j=s.port_mem=<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure> 为什么第二条<code>friend void clobber(Base&amp;)</code>；是不允许的，<strong>因为<code>void clobber(Base&amp;)</code>；不是<code>Base</code>类的友员</strong>，试想一下如果这种方法可行，那么就意味着用户可以自己制作一个派生类，此时就很容易规避了protected不能被用户访问的特性，这是一个弊端，所以说派生类的成员或者友元只能通过派生类对象来访问继承自基类的受保护成员！</p>
<h5 id="公有私有和受保护继承">1.6.2 公有、私有和受保护继承</h5>
<p>类对其继承而来的成员的访问权限收到两个因素影响：<strong>一是基类中该成员的访问说明符；二是派生类的派生列表中的说明符。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> port_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 如果继承是<code>public</code>的，则尊循原来的访问说明符，如果继承是<code>private</code>的，则所有继承成员都是私有的，如果继承是受保护的，则继承的公有成员都是受保护的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pub_exam</span>:<span class="keyword">public</span>  Base&#123;</span><br><span class="line"><span class="comment">//成员性质保持不变</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> port_mem;&#125;	<span class="comment">//可被访问</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> priv_mem;&#125;	<span class="comment">//错误，private不可访问（可用基类接口、或声明为友员）</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">priv_exam</span>:<span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="comment">//private只是不会影响派生类对基类的原有访问。</span></span><br><span class="line"><span class="comment">//该继承类的成员都是private</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> port_mem;&#125;	<span class="comment">//可被访问</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> priv_mem;&#125;	<span class="comment">//错误，private不可访问（可用基类接口、或声明为友员）</span></span><br><span class="line">&#125;；</span><br><span class="line">使用：</span><br><span class="line">pub_exam d1;</span><br><span class="line">priv_exam d2;</span><br><span class="line">d1.<span class="built_in">pub_mem</span>();		<span class="comment">//正确，该函数再派生类中是public</span></span><br><span class="line">d2.<span class="built_in">pub_mem</span>();		<span class="comment">//错误，该函数再派生类中是private</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以派生访问说明符对于派生类的成员能否访问其直接基类的成员没什么影响，</span></span><br><span class="line"><span class="comment">//只是影响派生类用户对于基类成员的访问权限。同时也可控制继承自派生类的新类的访问权限。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ds</span>:<span class="keyword">public</span> pub_exam&#123;</span><br><span class="line"><span class="comment">//成员性质不变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">as</span>:<span class="keyword">public</span> priv_exam&#123;</span><br><span class="line"><span class="comment">//都是private,无法直接访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意：</em></strong></p>
<ul>
<li><strong>当派生类公有继承基类时，用户代码才能实现派生类向基类的转换，否则不能；</strong></li>
<li>无论什么方式继承，派生类的成员函数和友元都可以使用派生类向基类的转换；</li>
<li>如果D是公有或者受保护继承B，则D的派生类的成员和友元可以使用向基类B的类型转换，否则不能</li>
</ul>
<h5 id="友员和继承">1.6.3 友员和继承</h5>
<p>就如友员关系无法传递一样，友员关系同样无法被继承。既基类的友员再访问派生类成员时不具有特殊性，同理派生类的友员也不买随意访问基类成员。</p>
<h5 id="改变个别成员的可访问性">1.6.4 改变个别成员的可访问性</h5>
<p>当需要改变派生类继承的某个名字的访问级别，通过使用using声明： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">private</span> Base&#123;		<span class="comment">//private继承，则默认下的继承类成员为私有</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	usnig Base::size;		<span class="comment">//保持与Base基类一样的public</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::n;			<span class="comment">//保持与基类一样的protected</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="继承中类的作用域">1.7 继承中类的作用域</h4>
<p>每个类都有自己的作用域，在这个域中我们声明和定义类的成员。<strong>当存在继承时，派生类的作用域嵌套在其基类作用域之内。如果有多次继承，则一环一环嵌套下去。</strong></p>
<h5 id="编译时进行名字查找">1.7.1 编译时进行名字查找</h5>
<p><strong>一个对象、引用和指针的静态类型决定了该对象的哪些成员是可见的，我们使用哪些成员仍然是由静态成员类型所决定的</strong>：如我们在上面的Disc_quote添加一新成员： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Disc_quote</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::pair&lt;<span class="type">size_t</span>,<span class="type">double</span>&gt; <span class="title">discount_policy</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;quanlity,discount&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用：Quote不包含有新成员;而Bulk_quote继承自Disc_quote</span></span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Bulk_quote* blukp=&amp;bulk;			<span class="comment">//静态类型于动态类型一致</span></span><br><span class="line">Quote* itemp=&amp;bulk;					<span class="comment">//基类指针指向派生类对象，即静态与动态不一致</span></span><br><span class="line">bulkp-&gt;<span class="built_in">discount_policy</span>();			<span class="comment">//正确</span></span><br><span class="line">itemp-&gt;<span class="built_in">discount_policy</span>();			<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p>
<h5 id="名字冲突与继承">1.7.2 名字冲突与继承</h5>
<p>与其他作用域一样，派生类也能重用定义在其直接或间接基类中的名字，此时定义在内存作用域的名字将会隐藏定义在外层（即基类）的名字: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">punlic:</span><br><span class="line">	<span class="built_in">A</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getMem</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> mem;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getMem</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> mem;&#125;		<span class="comment">//隐藏了基类中的getMem</span></span><br><span class="line">	<span class="comment">//那么我们在需要被隐藏成员时，可以通过**使用域作用运算符**获取：</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get_A_mem</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> A::mem&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mem;		<span class="comment">//隐藏了基类中的mem</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>理解c++继承中函数解析过程：假定我们调用<code>p-&gt;getMem()</code>或者<code>obj.getMem()</code>,则以此执行下面四个步骤:</strong></p>
<blockquote>
<ol type="1">
<li>首先确定<code>p</code>或<code>obj</code>的静态类型。因为我们调用的是一个成员，所有它们必定是类类型</li>
<li>在<code>p</code>或<code>obj</code>的静态类型对应的类中寻找<code>getMem</code>成员，如果找不到则以此在它的基类中寻找，直到继承链的顶端。若到顶端都没找到，则编译器报错。</li>
<li>一旦找到了<code>getMmem</code>，就进行常规的类型检查（参数个数和类型）以确认找到的<code>getMem</code>，对于本次调用是否合法。</li>
<li>假设调用合法，则编译器将根据调用是否是虚函数而产生不同代码：如果<code>getMem</code>是虚函数且我们是通过引用或指针形式进行调用，则编译器产生的代码将在运行时确定到底是运行该虚函数的哪一个版本。反之，则常规调用函数</li>
</ol>
</blockquote>
<h5 id="名字查找先于类型检查">1.7.3 名字查找先于类型检查</h5>
<p>声明在内层作用域中的函数不会重载声明在外层作用域的函数。因此派生类的成员也不会重载基类中的成员，而是隐藏掉外层作用域成员。所以下面的调用是错误的: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">memfcn</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">B d;</span><br><span class="line">A c;</span><br><span class="line">c.<span class="built_in">memfvn</span>();		<span class="comment">//正确</span></span><br><span class="line">d.<span class="built_in">memfcn</span>(<span class="number">10</span>);	<span class="comment">//正确</span></span><br><span class="line">d.<span class="built_in">memfcn</span>();		<span class="comment">//错误，参数列表为空的memcn被隐藏了</span></span><br><span class="line">d.A::<span class="built_in">memfcn</span>();	<span class="comment">//正确，通过作用域访问</span></span><br></pre></td></tr></table></figure></p>
<h5 id="虚函数与作用域">1.7.4 虚函数与作用域</h5>
<p>现<strong>在我们应该能够理解为什么虚函数必须要有相同的形参列表。因为假如不同,就会被隐藏，我们就无法通过基类引用或指针调用派生类的虚函数了</strong>，而是通过作用域运算符<code>::</code>访问，这就失去了多态这个重要性质。</p>
<h4 id="构造函数与拷贝控制">1.8 构造函数与拷贝控制</h4>
<p>继承体系中的类也需要控制当其对象执行一系列操作时发生什么样的行为。</p>
<h5 id="虚析构函数">1.8.1 虚析构函数</h5>
<p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个<strong>虚析构函数</strong>，这样我们就能动态分配继承体系中的对象了：<strong>假如当我们要<code>delete</code>一个动态<code>Quote*</code>指针时，该指针实际可能是<code>Bulk_quote</code>类型的对象。那么此时编译器就必须清楚它应该执行的是<code>Bulk_quote</code>的析构函数，所以应该在基类定义一个虚析构函数</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 之前我们介绍过一条经验准则<strong>：若一个类有析构函数，则必应当需要拷贝和赋值操作。</strong>一般基类的析构函数并不需要遵循这条经验准则，这是一个重要例外。同时虚析构函数会阻止类合成移动操作。</p>
<h5 id="基类合成拷贝控制与继承">1.8.2 基类合成拷贝控制与继承</h5>
<p>基类或者派生类的合成拷贝控制成员的行为与其他类似：</p>
<ul>
<li><strong>合成派生类默认构造函数运行了直接基类的默认构造函数，直接基类又运行了间接基类的构造函数</strong>（如上面的<code>Quote、Disc_quote、Bulk_quote</code>的构造函数）,<strong>顺序时会先先执行基类的默认构造函数，再执行派生类构造函数</strong></li>
<li>在上文继承体系中所有类都使用合成的析构函数，派生类隐式使用，基类显式使用，<strong>派生类的析构函数释放成员，销毁直接基类</strong></li>
</ul>
<p><strong>1. 派生类中删除的拷贝控制与基类的关系：</strong></p>
<ul>
<li><strong>如果基类的默认构造函数、拷贝控制成员、析构函数是删除或者不可访问，则派生类中对应的成员也是删除的，因为没办法执行对基类的操作；</strong></li>
<li><strong>如果基类的析构函数是删除的，则派生类拷贝控制成员和移动构造函数是删除的，因为没法销毁基类对象</strong></li>
<li>编译器不会合成删除掉的移动操作。如果基类的移动操作是删除的，则派生类当中的也是删除的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">const</span> B&amp;)=<span class="keyword">delete</span>;	<span class="comment">//拷贝构造是删除的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">D d;		<span class="comment">//正确，使用合成的默认构造哈桑农户</span></span><br><span class="line"><span class="function">D <span class="title">d1</span><span class="params">(d)</span></span>;	<span class="comment">//错误，基类的拷贝构造函数时删除的，那么派生类的拷贝构造也被删除了</span></span><br><span class="line"><span class="function">D <span class="title">d3</span><span class="params">(std::move(d))</span></span>;	<span class="comment">//错误，编译器不会合成删除掉移动操作，会隐式调用拷贝构造，但它也被删除，</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 移动操作与继承</strong></p>
<p><strong>多数基类定义一个虚析构函数，因此默认下基类不含合成的移动操作，这导致派生类也没有移动操作</strong>（没有移动操作，但使用的时候用到移动操会默认使用拷贝构造函数）。当确实需要移动操作时应在基类中定义，并同时定义拷贝操作 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Quote</span>(<span class="type">const</span> Quote&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Quote</span>(Quote&amp;&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Quote&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp;)=<span class="keyword">default</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="派生类的拷贝控制成员">1.8.3 派生类的拷贝控制成员</h5>
<p>正如派生类构造函数一样要初始化基类部分的成员，<strong>派生类的拷贝控制成员不仅拷贝自身成员，也负责了拷贝基类部分的成员。</strong> <strong>1. 当为派生类定义拷贝或移动构造函数时，我们通常使用对应得函数初始化对象得基类部分。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">calss base&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">D</span>(<span class="type">const</span> D&amp; d):<span class="built_in">Base</span>(d)&#123;&#125;</span><br><span class="line">	<span class="built_in">D</span>(D&amp;&amp; d):<span class="built_in">Base</span>(std::<span class="built_in">move</span>(d))&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 派生类赋值运算符,与拷贝和移动构造函数一样，派生类赋值运算符也必须显式地为其基类部分赋值。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">calss base&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">D</span>(<span class="type">const</span> D&amp; d):<span class="built_in">Base</span>(d)&#123;&#125;</span><br><span class="line">	<span class="built_in">D</span>(D&amp;&amp; d):<span class="built_in">Base</span>(std::<span class="built_in">move</span>(d))&#123;&#125;</span><br><span class="line">	D&amp; <span class="keyword">operator</span>=(<span class="type">const</span> D&amp; d)&#123;</span><br><span class="line">		Base::<span class="keyword">operator</span>=(d);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 继承的构造函数.在c++新标准中，允许派生类能够直接用基类定义的构造函数,但不能继承默认构造函数和拷贝，移动构造函数，如果不定义，编译器负责合成。</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>:<span class="keyword">public</span> Disc_qupte&#123;</span><br><span class="line">	<span class="keyword">using</span> Disc_quote::Disc_quote;		<span class="comment">//继承Disc_Quot的构造函数</span></span><br><span class="line">	<span class="function"><span class="type">double</span> 	<span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span><span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <strong>using（起到注明作用，提示用户有继承构造函数）作用于编译器时令其产生代码</strong>，对于基类的每个构造函数，派生类都生成一个形参列表完全对应的：</p>
<ul>
<li>构造函数的<code>using</code>不会改变构造函数的访问级别；</li>
<li><strong>当基类构造函数含有默认实参，实参不会被继承，而是生成一个形参列表中除去默认实参的构造函数</strong>（例如，若基类有一个接受两个形参的构造函数，其中第二个有默认实参，则派生类将获得两个构造函数：一个是构造函数接受两个形参，另一个只接受一个形参，该形参是没有默认实参的那个）。P558 ；</li>
<li>如果派生类定义了与基类构造函数形参相同的构造函数，则不会继承该构造函数，而是替换</li>
</ul>
<h4 id="单例模式">1.9 单例模式</h4>
<p><strong>定义：单例模式是一个类只能实例化一个对象,实现单例模式的思路:</strong></p>
<ul>
<li>1）.把无参构造函数和拷贝构造函数私有化</li>
<li>2）.定义一个类内的类静态成员指针</li>
<li>3）在类外初始化时，<code>new</code>一个对象</li>
<li>4）把指针的权限设置为私有，然后提供一个静态成员函数让外面获取这个指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Maker</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.把构造函数私有化</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Maker</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Maker</span>(<span class="type">const</span> Maker &amp;m)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员函数，访问静态成员变量</span></span><br><span class="line">	<span class="comment">//4.把指针的权限设置为私有，然后提供一个静态成员函数让外面获取这个指针</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Maker* <span class="title">getMaker</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pMaker;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//2.定义一个类内的静态成员指针</span></span><br><span class="line">	<span class="type">static</span> Maker *pMaker;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//3.在类外初始化时，new一个对象</span></span><br><span class="line">Maker *Maker::pMaker = <span class="keyword">new</span> Maker;<span class="comment">//这里可以new是因为在Maker::作用域，编译器把它当成在类内</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Maker *m = Maker::<span class="built_in">getMaker</span>();</span><br><span class="line">	Maker *m2 = Maker::<span class="built_in">getMaker</span>();		<span class="comment">//m和m2是同一对象</span></span><br><span class="line">	<span class="comment">//Maker m3 = *m;//调用拷贝构造，这里会产生新对象，所以要把拷贝构造也私有化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板与泛型编程">2. 模板与泛型编程</h3>
<p>面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况，不同之处在于：<strong>OOP能处理类型在程序运行之前都未知的情况；而泛型编程，在编译时就能知道类型。之前介绍过的容器、迭代器和泛型算法都是泛型编程的例子</strong></p>
<p><strong><em>必须知道的原理</em></strong>：<strong>模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义</strong>，这个过程叫做<strong>模板实例化</strong>。编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。即模板类在没有调用之前是不会生成代码的。 <strong><em>注意：</em></strong>要区分类实例化和模板实例化，类实例即为创建对象，模板实例化为定义一个实例类</p>
<h4 id="函数模板">2.1 函数模板</h4>
<p>一个函数模板就是一个公式，可以用来针对特定类型的函数版本。比如我们定义一个比较函数模板： <strong>1. 定义函数模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">int</span>  <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;v1,<span class="type">const</span> T&amp; v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v1&lt;v2) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v1&gt;v2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板定义以关键字<code>template</code>开始，后跟一模板参数类型列表（由逗号分隔的一个或多个模板参数，由&lt;&gt;括起）。 当我们使用模板时，显式或隐式的指定模板实参，将其绑定到模板参数上。</p>
<p><strong>2.模板实例</strong></p>
<p>我们调用该模板时候编译器就会根据我们提供的实参来实例化一个特定版本的函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;&lt;endl;		<span class="comment">//实例化了一int compare(const int&amp; v1,const int&amp; v2)函数</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3.模板类型参数</strong></p>
<p>上面自定义的模板函数有模板参数列表,<strong>这些参数可以指定函数参数列表、返回类型、函数体内的变量声明和类型转换</strong>，其内的类型参数前必须使用<code>class</code>或者<code>typename</code>,在这里两个的含义完全相同。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">class</span> U&gt; <span class="title">T</span><span class="params">(<span class="type">const</span> T&amp; v1,<span class="type">const</span> U&amp; v2)</span></span>&#123;</span><br><span class="line">	T tep=v1;</span><br><span class="line">	U up=v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. 非类型模板参数</strong></p>
<p>除了定义模板类型参数，还可以定义<strong>非类型模板参数</strong>。<strong>非类型参数表示一个值而非一个类型，通过一个特定的类型名而不是关键字<code>typename</code>、<code>class</code>来指定非类型参数</strong>。例如：编写一个<code>compare</code>版本处理字符串字面常量，这种字面常量是<code>const char</code>数组：（因为数组是无法拷贝的，所以采用引用），该非类型模板定义了两个非类型参数，第一个将要表示第一个数组长度，第二个表示第二个数组长度: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非类型模板参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N,<span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N],<span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>当非类型模板被实例化时，非类型参数被一个用户提供的或编译器推断的值所替代。这些值必须是常量表达式，绑定到指针或引用的非类型实参必须具有静态生存周期（static)</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;Hi&quot;</span>,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//编译器会将字面常量大小代替`N\M`，从而实例模板。</span></span><br><span class="line"><span class="comment">//编译器会在字符串字面常量末尾插入一个空字符作为终结符，所以编译器实例的版本是：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[<span class="number">3</span>],<span class="type">const</span> <span class="type">char</span> (&amp;p2)[<span class="number">6</span>])</span></span>;</span><br></pre></td></tr></table></figure> <strong><em>注意：</em></strong>一个非类型参数可以是整型、指向对象或函数的指针或者左值引用。</p>
<h4 id="类模板">2.2 类模板</h4>
<p>函数模板不同的是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后面的&lt;&gt;中提供额外信息----作为类模板参数的实参</p>
<ul>
<li><p><strong>类模板中的声明和实现必须放在同一头文件</strong>，因为链接器（linker）会找不到实例化的函数模板的入口地址。链接器之所以会去找这个函数入口，是因为编译器（compiler）告诉他这里有一个函数入口。“因为C++标准明确表示，当一个模板不被用到的时侯它就不该被实例化出来”。模板分离编译（分别放在.h和.cpp中），VS会报错：<code>error LNK2001: unresolved external symbol</code>。没有报错的，要么是没有使用这个模板，要么是在实现的.cpp文件中有实际使用。</p>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/bichenggui/article/details/4207084">c++编译器为什么不支持模板的分离式编译</a></li>
<li>C++支持<strong>类模板虚函数</strong>，但是不支持<strong>模板虚函数</strong>
<ul>
<li>①这是由C++多态的实现机制决定的：**每个有虚函数的类都拥有一张虚函数表(虚函数表的大小取决于类内有多少个虚函数，比如有N个，就是4*N)，虚函数表内存储着指向各自的虚函数入口地址；当我们实例化一个类的对象时，就会对该对象生成一个虚表指针，指向这个类的虚函数表，这样我们就能够知道在继承中子类调用子类的虚函数，而不是父类的虚函数。**</li>
<li>②我们知道类模板不是类的实例化，模板类只要在我们显示定义类时，才会实例化一个类。</li>
<li>因此知道上面的①②点，很容易知道为什么。因为类模板不是实例化类，那么当然就不会有虚函数表，它的虚函数表只要在类实例化后才生成，并不会冲突，因此类模板可以有虚函数；但是，当我们在一个实例化类定义一个模板函数是不可行的，因为编译器在编译的时候就得确定虚函数表的大小，而模板函数只又在实例化后才会生成一个真正的函数。</li>
</ul></li>
</ul>
<h5 id="定义类模板">2.2.1 定义类模板</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">BlobPtr</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;		<span class="comment">//value_type=T</span></span><br><span class="line">	<span class="comment">//typename 告诉编译器size_type是个类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BlobPtr</span>&lt;T&gt;;		<span class="comment">//类BlobPtr&lt;T&gt;为友员</span></span><br><span class="line">	<span class="built_in">Blob</span>() :<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;()) &#123;<span class="built_in">addStatic</span>();&#125;	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il) :<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)) </span><br><span class="line">		&#123;<span class="built_in">addStatic</span>();&#125;	<span class="comment">//含参构造函数</span></span><br><span class="line">	~<span class="built_in">Blob</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">Size</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;					<span class="comment">//元素数量</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>(); &#125;						<span class="comment">//判空</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T&amp; e)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(e); &#125;				<span class="comment">//尾部添加</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T&amp;&amp; e)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(e)); &#125;	<span class="comment">//右值引用尾部添加</span></span><br><span class="line">	<span class="comment">//静态接口</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addStatic</span><span class="params">()</span> </span>&#123; count_object++; &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">getStatic</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count_object; &#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">Pop_back</span><span class="params">()</span></span>;													<span class="comment">//删除尾部元素</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">Back</span><span class="params">()</span></span>;														<span class="comment">//取尾部元素</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">Front</span><span class="params">()</span></span>;														<span class="comment">//取头部元素</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);									<span class="comment">//下标访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string&amp; msg)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="type">static</span> count_object=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">void</span>  Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="type">const</span> string&amp; msg)<span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= <span class="built_in">Size</span>() || i &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="built_in">Pop_back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>	data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="built_in">Back</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="built_in">Front</span>() &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;front on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> data-&gt;<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;[] on empty vector&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (*data)[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">size_t</span> Blob&lt;T&gt;::count_object = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该类通过弱引用智能指针控制Blob的shared_ptr指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">M</span>&gt;<span class="keyword">class</span> <span class="title class_">BlobPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BlobPtr</span>() :<span class="built_in">current_location</span>(<span class="number">0</span>) &#123;  &#125;</span><br><span class="line">	<span class="built_in">BlobPtr</span>(Blob&lt;M&gt;&amp; a, <span class="type">size_t</span> si = <span class="number">0</span>) :<span class="built_in">wptr</span>(a.data), <span class="built_in">current_location</span>(si) &#123;  &#125;</span><br><span class="line">	M&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">auto</span> p = <span class="built_in">check</span>(current_location, <span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (*p)[current_location];</span><br><span class="line">	&#125;</span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		++current_location;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BlobPtr&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">		--current_location;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setWptr</span><span class="params">(Blob&lt;M&gt;&amp; a)</span> </span>&#123; wptr = a.data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;vector&lt;M&gt;&gt; <span class="built_in">check</span>(std::<span class="type">size_t</span>, <span class="type">const</span> string&amp;)<span class="type">const</span>;</span><br><span class="line">	std::weak_ptr&lt;vector&lt;M&gt;&gt; wptr;</span><br><span class="line">	<span class="type">size_t</span> current_location;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">M</span>&gt; <span class="keyword">inline</span> std::shared_ptr&lt;vector&lt;M&gt;&gt; BlobPtr&lt;M&gt;::</span><br><span class="line"><span class="built_in">check</span>(std::<span class="type">size_t</span> i, <span class="type">const</span> string&amp; msg)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!wptr.<span class="built_in">expired</span>()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> q = wptr.<span class="built_in">lock</span>();</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= q-&gt;<span class="built_in">size</span>())</span><br><span class="line">			<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">		<span class="keyword">return</span> q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用示例</span></span><br><span class="line">Blob&lt;string&gt; blob;</span><br><span class="line">Blob&lt;string&gt; blob2;</span><br><span class="line">Blob&lt;<span class="type">int</span>&gt;blob3;</span><br><span class="line">cout &lt;&lt; blob.<span class="built_in">getStatic</span>()&lt;&lt;blob3.<span class="built_in">getStatic</span>() &lt;&lt; endl;	<span class="comment">//2 1</span></span><br><span class="line">blob.<span class="built_in">Push_back</span>(<span class="string">&quot;trluper&quot;</span>);</span><br><span class="line">blob.<span class="built_in">Push_back</span>(<span class="string">&quot;github&quot;</span>);</span><br><span class="line">BlobPtr&lt;string&gt; bp;</span><br><span class="line">bp.<span class="built_in">setWptr</span>(blob);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!blob.<span class="built_in">Empty</span>()) &#123;</span><br><span class="line">	string s = blob.<span class="built_in">Front</span>();</span><br><span class="line">	s = blob.<span class="built_in">Back</span>();</span><br><span class="line">	++bp;</span><br><span class="line">	s = *bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从上面一个完整的类模板可以看到：</strong></p>
<ul>
<li><strong>类模板的成员函数可定义在类内也可在类外，类内定义的成员函数默认内联（inline)</strong>。类模板成员函数具有和模板相同的模板参数。因此，<strong>在类外定义成员函数必须以关键字<code>template</code>关键字开始，后接类模板参数列表</strong>：<code>template&lt;class T&gt;</code></li>
<li><code>inline</code>关键字放在模板之后，函数之前即可</li>
<li>我们使用一个类模板类型必须提供模板参数。但有一个例外：在模板类内作用域可以直接使用模板名而不需要要提供参数<code>&lt;T&gt;</code>，但在类外定义的时候需要提供参数<code>&lt;T&gt;</code></li>
<li>在函数体内，我们进入了类作用域，所以可以不用再提供模板参数。</li>
<li><strong>模板和非模板友类：如果一类模板包含了一个非类模板友元，则友元被授权可以访问所有模板实例；如果是包含模板友元，类可以授权给所有友元模板实例，也可以只授权特定实例：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">C2</span>&#123;</span><br><span class="line">	<span class="comment">//只要pal和C2的实例类型是一致的，那么实例化后的pal就是它的友类,</span></span><br><span class="line">	<span class="comment">//跟friend class BlobPtr&lt;T&gt;;一样</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">pal</span>&lt;T&gt;;</span><br><span class="line">	<span class="comment">//pal2的所有实例都是C2的友类，不管类型是否一样</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">x</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">pal2</span>;</span><br><span class="line">	<span class="comment">//对于非模板类，时C2所有实例的友类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">pal3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="类模板的静态成员">2.2.2 类模板的静态成员</h5>
<ul>
<li>对于任意给定的模板参数<code>X</code>，其都有<code>count_object、getStatic、addStatic</code>成员，所有的<code>foo&lt;x&gt;</code>类型对象都共享相同的<code>count_object、getStatic、addStatic</code>。注意时相同的类型参数<code>X</code>情况下共享，不同类型各自拥有</li>
<li>类外初始化要加上<code>tempalte&lt;class T&gt;</code>,如<code>template&lt;class T&gt;size_t Blob&lt;T&gt;::count_object = 0;</code></li>
<li>可以使用实例类访问<code>Blob&lt;String&gt;::getStatic()</code>，也可以使用实例化的对象访问<code>blob.getStatic()</code></li>
</ul>
<h4 id="模板参数">2.3 模板参数</h4>
<p>摸版参数（如上面一直用到的<code>T</code>）遵循普通作用域规则，一个模板参数的可用范围是其声明之后至模板声明或定义结束之前。它也会隐藏外层作用域中声明的相同的名字。</p>
<ul>
<li>模板声明需要包含模板参数，如：<code>template &lt;typename T&gt;int compare(const T&amp;, const T&amp;);</code></li>
<li>由于我们通过作用域运算符来访问静态成员和类型成员，但是在模板中，编译器无法区分访问的是类型还是静态成员。如<code>T::size_type *p</code>;到底是定义<code>p</code>变量还是将<code>size_type</code>这个静态成员与<code>p</code>相乘。为了区分，<strong>编译器是认为在模板中通过作用域访问的是变量。所以必须通过关键字<code>typename</code>来告诉编译器现在使用的是个类型</strong>，如前面类模板中的<code>typedef typename std::vector&lt;T&gt;::size_type size_type;</code></li>
</ul>
<p><strong>1. 默认模板实参</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tempalte&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">F</span>=less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b,F f=<span class="built_in">F</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(a,b))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(b,a))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为模板参数提供了<strong>默认实参</strong>，<strong>指出<code>compare</code>默认将使用标准库的<code>less</code>函数对象类，但用户调用该函数时可以提供自己的比较操作，但该操作接受的实参类型应当与<code>compare</code>的前两个类型兼容。</strong>对于一个模板参数，只有当它右侧所有参数都有默认实参时，它才可以有默认实参</p>
<p>如果一个类模板为其所有模板参数提供了默认实参，<strong>且希望使用默认实参，那么就必须在模板名后跟一个空尖括号</strong>。用int实例化的average_precision模板名后跟的是尖括号。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt;<span class="keyword">class</span> Numbers&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Numbers&lt;doubel&gt; los;</span><br><span class="line">Numebers&lt;&gt;average_precision;		<span class="comment">//使用默认实参</span></span><br></pre></td></tr></table></figure></p>
<h4 id="控制实例化">2.4 控制实例化</h4>
<p>当多个或多个独立的编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件就都会有该模板的一个实例类。在多个文件<strong>实例化相同模板类的额外开销可能非常严重</strong>。我们可以通过<strong>显式实例化来避免这种开销</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;	<span class="comment">//声明</span></span><br></pre></td></tr></table></figure> <strong><code>declaration</code>是一个类或函数的声明，其中所有模板参数已被替换为实参</strong>。遇到<code>extern</code>模板声明，编译不会在本文件中生成实例化代码，而是去别处寻找。声明必须出现在使用实例化版本的代码，否则会自动实例化，对于一个给定的实例化版本，可能有多个<code>extern</code>声明但只有一个定义。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern声明，那么接下来实例化一个对应对象和函数并不会在本文件生成一个实例化类和函数</span></span><br><span class="line"><span class="comment">//简而言之，就是我这些类型的类和函数在别的地方定义，在这只是调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">int</span> <span class="title">conpare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;,<span class="type">const</span> <span class="type">int</span> &amp;)</span></span>;</span><br><span class="line">Blob&lt;String&gt; sa1,sa2;</span><br><span class="line"><span class="comment">//下面会在本文件生成一个int类型的实例化类（你看不到，但是编译器生成知道）</span></span><br><span class="line">Blob&lt;<span class="type">int</span>&gt; a1&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">Blob&lt;<span class="type">int</span>&gt; <span class="title">a2</span><span class="params">(a1)</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="模板参数和返回值的推断">2.5 模板参数和返回值的推断</h4>
<p>从<strong>函数实参来确定模板实参的过程称为模板实参推断</strong>，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参生成的函数版本，与给定的函数调用最为匹配。</p>
<h5 id="类型转换与模板类型参数">2.5.1 类型转换与模板类型参数</h5>
<ul>
<li><strong>模板函数对const的转换要求很低</strong>。向函数模板传递参数时允许<code>const</code>转换：可以将<code>非const对象</code>的引用（或指针）传递给一个<code>const</code>引用（或指针）形参,也可以将<code>const</code>传递给<code>非const</code>，只不过const会被忽略</li>
<li>数组或函数指针转换，如果函数形参不是引用类型，数组实参转换为指向数组首元素的指针，函数实参转换为指向该函数的指针</li>
<li><strong>其他算术类型转换、派生类到基类的转换</strong>不能应用于函数模板。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">fobj</span><span class="params">(T,T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; T <span class="title">fref</span><span class="params">(<span class="type">const</span> T&amp;,<span class="type">const</span>&amp; T)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">s2</span><span class="params">(<span class="string">&quot;another value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1,s2);		<span class="comment">//调用fobj(string,string),const会被忽略</span></span><br><span class="line"><span class="built_in">fref</span>(s1,s2);		<span class="comment">//调用fref(const string&amp;,const string&amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a,b);			<span class="comment">//调用fobj(int*,int*)</span></span><br><span class="line"><span class="built_in">fobj</span>(a,b)/			<span class="comment">//错误，数字类型不能与引用匹配</span></span><br></pre></td></tr></table></figure>
<h5 id="函数模板必需显示实参情况">2.5.2 函数模板必需显示实参情况</h5>
<p>某些情况，编译器无法推断类型，我们希望用户指定<code>template &lt;typename T1, typename T2, typename T3&gt; T1 sum(T2, T3)</code>; 每次调用sum时调用者必须为<code>T1</code>提供一个显式模板实参(因为我们在实例化这个模板函数时，提供的实参只是<code>T2、T3</code>的，<strong>编译器能推断它们的类型，但无法推断T1的</strong>. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val3 = <span class="built_in">sum</span>&lt;<span class="type">long</span>  <span class="type">long</span>&gt;(i,lng);	<span class="comment">//此时T1是long long型的，</span></span><br></pre></td></tr></table></figure></p>
<h5 id="尾置返回类型与转换">2.5.3 尾置返回类型与转换</h5>
<p><strong>有时需返回一个元素的值，但是迭代器操作只能生成元素的引用而不是元素</strong>。为了获得元素类型，可以使用标准库的类型转换：<code>remove_reference&lt;int&amp;&gt;</code>则它的<code>type</code>成员会是<code>int</code> 。更一般地<code>remove_reference&lt;decltype(beg*)&gt;::type</code> 将获得beg引用元素的类型，组合使用<code>remove_reference</code>尾置返回和<code>decltyp</code>e，就可以在函数中返回元素值的拷贝: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此例中我们通知编译器fcn2的返回类型与解引用beg的参数的结果类型相同</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(T beg,T end)</span>-&gt;<span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于下面这个，但是不能用，因为此时*beg标识符未定义，只能后置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">typename remove_reference&lt;decltype(*beg)&gt;::type fcn(T beg,T end)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	return *beg;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>type</code>是一个类的成员，所以必须在返回类型的声明中用<code>typename</code>显式告知编译器返回的是一个类型。</li>
<li><code>decltype</code>关键字，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值</li>
</ul>
<h5 id="模板函数的例外规则即对称对move的支持">2.5.4 模板函数的例外规则（即对称）对move的支持</h5>
<p><strong>模板库例外规则支持move标准库的正确工作：</strong> - 第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值<code>i</code>传递给函数的右值引用参数，且此右值引用为模板参数类型<code>T&amp;&amp;</code>时，编译器推断模板类型参数为实参的左值引用类型（<strong>即右值引用的这种函数模板支持传入左值</strong>） - 在第一例外规则的基础上，第二个例外绑定规则：如果我们间接创建一个引用的引用（实参传入形参），则这些引用形成“折叠”：在所有情况下（除一个例外），引用会折叠成一个普通左值引用类型： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="title">func</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="comment">//实参传入为左值引用X&amp;</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; m=i;</span><br><span class="line"><span class="type">int</span>&amp;&amp; a=<span class="built_in">move</span>(i);</span><br><span class="line"><span class="built_in">func</span>(i);		<span class="comment">//传入左值i,则int&amp;和int&amp;&amp;折叠成int&amp;</span></span><br><span class="line"><span class="built_in">func</span>(a);		<span class="comment">//传入右值a,则int&amp;&amp;和int&amp;&amp;折叠成int&amp;&amp;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>即函数参数时<code>T&amp;&amp;</code>，就意味着我们既可以传递给move一个右值，也可以是左值</strong>，下面以<code>move</code>函数源码为例子探索模板函数的该原理：</p>
<ul>
<li><code>std::move(string(&quot;byte&quot;))</code>向<code>move</code>传递的是一个<strong>右值</strong>，推断出的<code>T</code>的类型为<code>string</code>因此将模板实例化，<code>type</code>类型为<code>string</code>, <code>t</code>的类型为<code>string&amp;&amp;</code>，move的返回类型为<code>string&amp;&amp;</code>,函数体返回<code>static_cast&lt;string&amp;&amp;&gt; (t)</code> 然而<code>t</code>的类型已经是<code>string&amp;&amp;</code>所以类型转换什么都不做，因此调用结果就是右值引用。</li>
<li>如果向<code>move</code>传递一个左值，推断出T类型为<code>string&amp;</code> ,<code>remove_reference</code>用<code>string&amp;</code>进行实例化，故其<code>type</code>成员为<code>string</code>，返回类型<code>string&amp;&amp;</code>,<code>t</code>实例化为<code>string&amp;</code>,<code>string&amp; string&amp;&amp;</code>折叠为<code>string&amp;</code> 故,<code>string&amp;&amp; move(string&amp; t)</code>这也正是我们希望的：将一个右值引用绑定到一个左值，返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code></li>
<li>通常情况下，<code>static_cast</code>只能用于合法的类型转换，但是针对右值引用，可以显式地将左值转换为右值引用，而对于操作右值的代码来说，将右值绑定到左值特性允许它们截断左值，尽管编译器允许这种用法，但是要求我们<code>static_cast</code>以防止意外地转换。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;<span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载与模板">2.6 重载与模板</h4>
<p><strong>函数模板可以被另一个模板或一个普通非模板函数重载</strong>，名字相同的函数必须有不同数量或类型的参数。<strong>匹配规则：</strong></p>
<ul>
<li>和往常一样，如果恰有一个函数提供比任何其他函数更好的匹配，则选择此函数，但是，如果有多个函数提供同样好的匹配，则：</li>
<li>如果同样好的函数中只有一个是非模板函数，则选在此函数</li>
<li>如果同样好的函数中没有非模板，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板，否则，此调用有歧义</li>
</ul>
<p><strong><em>注意：</em></strong>在定义任何函数之前，记得声明所有重载的函数版本，这样就不必担心编译器由于未遇到希望调用的函数而实例化一个并非你所需的版本</p>
<h4 id="可变参数模板">2.7 可变参数模板</h4>
<p><strong>可变参数模板，即一个接受可变数目参数的模板函数或模板类</strong>。可变数目的参数被称为<strong>参数包</strong>，存在两种参数包，一是模板参数包，表示零个或多个模板参数；二是函数参数包，表示零个或多个函数参数。通过用一个省略号来指出一个模板参数或函数参数表示一个包:</p>
<ul>
<li><code>class…</code> 或<code>typename…</code>指出接下来表示零个或多个类型的列表；</li>
<li>一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表</li>
<li>在一个函数参数列表中，如果一个参数的类型是模板参数包，则此参数也是一个函数参数包</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args 是一个模板参数包；rest 是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args 表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest 表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp; ... rest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="type">double</span> d = <span class="number">3.14</span>; string s = <span class="string">&quot;how now brown cow&quot;</span>;</span><br><span class="line"><span class="built_in">foo</span>(i, s, <span class="number">42</span>, d);	<span class="comment">//相当于void foo(const int&amp;, const string&amp;, const int&amp;, const double&amp;);</span></span><br><span class="line"><span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);	<span class="comment">//相当于void foo(const string&amp;， const int&amp;, const char[3]&amp;);</span></span><br><span class="line"><span class="built_in">foo</span>(d, s);			<span class="comment">//相当于void foo(const double&amp;, const string&amp;);</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>);			<span class="comment">//相当于void foo(const char[3]&amp;);</span></span><br></pre></td></tr></table></figure>
<h5 id="sizeof运算符">2.7.1 sizeof…运算符</h5>
<p>当想要知道包中有多少元素时，可以使用 sizeof… 运算符，其返回一个常量表达式，且不会对其实参求值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Args&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(Args...args)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; endl;	<span class="comment">//类型参数的数目</span></span><br><span class="line">	cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;	<span class="comment">//函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="编写可变参数函数模板">2.7.2 编写可变参数函数模板</h5>
<ul>
<li>可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身</li>
<li>为了终止递归，还需要定义一个非可变参数的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来终止递归并打印最后一个元素的函数，其实可变参数模板也能匹配，但是非可变模板更特例化，因此编译器会选择非可变参数版本</span></span><br><span class="line"><span class="comment">//此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包中除了最后一个元素之外的其他元素都会调用这个版本的 print</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;...rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;			  <span class="comment">//打印第一个实参</span></span><br><span class="line">	<span class="comment">//递归调用，打印其他实参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);<span class="comment">//递归传参时，rest 的第一个参数赋给形参的 const T&amp; t，剩下的参数继续以参数包 rest 存在，并继续递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到了一个专业化名词<strong>包扩展</strong>，即是指可变参数函数模版在一次次<strong>调归后对模板参数包和函数参数包的展开</strong>，下列代码是对上述的解释： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;...rest)</span>	<span class="comment">//扩展Args，为print生成函数参数列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);								<span class="comment">//扩展rest，为print递归调用生成实参列表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于Args的扩展</span></span><br><span class="line"><span class="built_in">print</span>(cout, i, s, <span class="number">42</span>);	<span class="comment">//包中有两个参数</span></span><br><span class="line"><span class="comment">//实例化为ostream&amp; print(ostream&amp;, const int&amp;, const string&amp;, const int&amp;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于第二个扩展，发生在对print的递归调用中</span></span><br><span class="line"><span class="comment">//模式是函数参数包的名字（即rest），此模式扩展出一个由包中元素组成的、逗号分隔的列表，因此等价于</span></span><br><span class="line"><span class="built_in">print</span>(os, s, <span class="number">42</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="函数模板特例化">2.8 函数模板特例化</h4>
<p>在某些情况下，通用模板的定义对特定类型是不适合的，但通用定义又可能编译失败或做得不正确。因此，有时可以利用特定知识编写更高效的代码，而非从通用模板实例化，因此当不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本。</p>
<p><strong><em>注意</em></strong>函数模板只有全特例化，不存在偏特化，你认为的偏特化只是重载函数模板</p>
<h5 id="定义函数模板特例化">2.8.1 定义函数模板特例化</h5>
<ul>
<li>当特例化一个函数模板时，<strong>必须为原模板中的每一个模板参数提供实参</strong>。</li>
<li>为了指出正在实例化一个模板，应该使用关键字<code>template&lt;&gt;</code>,指出将为原模板所有模板参数提供实参</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;	<span class="comment">//声明放前面</span></span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; p1, <span class="type">const</span> T&amp; p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compare 的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p1, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;typname T&gt;<span class="function"><span class="type">int</span> <span class="title">campare</span><span class="params">(<span class="type">const</span> T* p1,<span class="type">const</span> T* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(*p1,*p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="函数重载与模板特例化">2.8.2 函数重载与模板特例化</h5>
<ul>
<li>当定义函数模板的特例化版本时，本质上是接管了编译器的工作，为原模板的一个特殊实例提供了定义</li>
<li>特例化的本质是实例化一个模板，而非重载，因此特例化影响象函数匹配</li>
<li>为了特例化一个模板，原模板的声明必须在作用域中，而且，在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中</li>
<li>模板及其特例化版本应该声明在同一个头文件中，所有同名模板的声明应该放在前面，然后是这些模板的特例化版本</li>
</ul>
<h4 id="类模板部分特例化">2.9 类模板部分特例化</h4>
<ul>
<li>与函数模板不同，<strong>类模板的特例化不必为所有模板参数提供实参，可以只指定一部分而非所有模板参数</strong>，或是参数的一部分而非全部特性,即类模板支持偏特化。</li>
<li>我们只能部分特例化类模板，而不能部分特例化函数模板，函数模板不支持偏特化</li>
<li><strong>我们可以只特例化特定成员函数而不是特例化整个类模板</strong></li>
<li><strong>类模板即可以全特化，也可以偏特化</strong></li>
</ul>
<h6 id="类全特化">2.9.1 类全特化</h6>
<p>类模板全特化比较好理解，跟函数模板一样，全特化已经是一个类实例了，当编译器匹配时会优先匹配参数一致的实例 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">	<span class="built_in">Foo</span>(<span class="type">const</span> T &amp;t ): <span class="built_in">mem</span>(t)&#123; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">	T mem;</span><br><span class="line">	<span class="comment">//Foo的其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全特化类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">struct</span> <span class="title class_">Foo</span>(string*)</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;	<span class="comment">//实例化Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();		<span class="comment">//实例化Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo fi;			<span class="comment">//调用全特化实例化Foo&lt;string*&gt;::Foo()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();		<span class="comment">//使用全特化的类</span></span><br></pre></td></tr></table></figure></p>
<h5 id="类偏特化">2.9.2 类偏特化</h5>
<p>对类模板我们可以进行偏特化，比如下面这个类 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;      <span class="comment">// 普通类模板，有两个模板参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定一部分参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;　　　         <span class="comment">// 偏特化版本，指定其中一个参数，即指定了部分类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&lt;<span class="type">int</span> , T2&gt; &#123; ..... &#125;;　　<span class="comment">// 当实例化时的第一个参数为int 则会优先调用这个版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者只特化里面的函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;			<span class="comment">//正在特例化一个函数成员模板</span></span><br><span class="line"><span class="type">void</span> B&lt;<span class="type">int</span>&gt;::Bar	<span class="comment">//正在特例化B&lt;int&gt;的成员Bar</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//进行应用于int的特例化处理</span></span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">还有一种更为重要的特例化形式，在traits编程技法中会用到，以达到完美解决对于原生指针无法进行返回值说明的问题（详间STL源码剖析中的迭代器部分）</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;　　　<span class="comment">//这个偏特化版本只接收指针类型的模板实参 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&lt;T*&gt; &#123; ..... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&lt;T&amp;&gt; &#123; ..... &#125;;     <span class="comment">// 这个偏特化版本只接受引用类型的模板实参</span></span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="trluper 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="trluper 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/" rel="prev" title="c++基础">
      <i class="fa fa-chevron-left"></i> c++基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-%E5%AE%9E%E7%8E%B0/" rel="next" title="数据结构(C++实现)">
      数据结构(C++实现) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">1. 面向对象程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 定义基类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 定义派生类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 派生类构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 派生类使用基类成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 继承与静态成员</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 类型转换与继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 抽象基类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.6 访问控制与继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#protected"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.6.1 protected</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AC%E6%9C%89%E7%A7%81%E6%9C%89%E5%92%8C%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.6.2 公有、私有和受保护继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8B%E5%91%98%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.4.</span> <span class="nav-text">1.6.3 友员和继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E4%B8%AA%E5%88%AB%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="nav-number">1.5.5.</span> <span class="nav-text">1.6.4 改变个别成员的可访问性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.6.</span> <span class="nav-text">1.7 继承中类的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.7.1 编译时进行名字查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8D%E5%AD%97%E5%86%B2%E7%AA%81%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.7.2 名字冲突与继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E5%85%88%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.7.3 名字查找先于类型检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.6.4.</span> <span class="nav-text">1.7.4 虚函数与作用域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="nav-number">1.7.</span> <span class="nav-text">1.8 构造函数与拷贝控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.8.1 虚析构函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.7.2.</span> <span class="nav-text">1.8.2 基类合成拷贝控制与继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98"><span class="nav-number">1.7.3.</span> <span class="nav-text">1.8.3 派生类的拷贝控制成员</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.</span> <span class="nav-text">1.9 单例模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">2. 模板与泛型编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 函数模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 定义类模板</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 类模板的静态成员</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 模板参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 控制实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%8E%A8%E6%96%AD"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 模板参数和返回值的推断</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1 类型转换与模板类型参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%BF%85%E9%9C%80%E6%98%BE%E7%A4%BA%E5%AE%9E%E5%8F%82%E6%83%85%E5%86%B5"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2 函数模板必需显示实参情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.5.3 尾置返回类型与转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E4%BE%8B%E5%A4%96%E8%A7%84%E5%88%99%E5%8D%B3%E5%AF%B9%E7%A7%B0%E5%AF%B9move%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">2.5.4.</span> <span class="nav-text">2.5.4 模板函数的例外规则（即对称）对move的支持</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 重载与模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 可变参数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.7.1.</span> <span class="nav-text">2.7.1 sizeof…运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.7.2.</span> <span class="nav-text">2.7.2 编写可变参数函数模板</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 函数模板特例化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">2.8.1.</span> <span class="nav-text">2.8.1 定义函数模板特例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">2.8.2.</span> <span class="nav-text">2.8.2 函数重载与模板特例化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E9%83%A8%E5%88%86%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 类模板部分特例化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B1%BB%E5%85%A8%E7%89%B9%E5%8C%96"><span class="nav-number">2.9.0.1.</span> <span class="nav-text">2.9.1 类全特化</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%81%8F%E7%89%B9%E5%8C%96"><span class="nav-number">2.9.1.</span> <span class="nav-text">2.9.2 类偏特化</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">872k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:13</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
      <script type="text/javascript">
      function renderGitalk(){
        var gitalk = new Gitalk({
            owner: '',
            repo: '',
            clientID: '123fe329fdbb06b0f1d1',
            clientSecret: '40add829107b6e69f43274d3545ae71c988de8eb',
            admin: '',
            
            });
        gitalk.render('gitalk-container');
      }
      renderGitalk();
      </script>
    
 


<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>