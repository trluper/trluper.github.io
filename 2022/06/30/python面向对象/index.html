<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_1.png">
  <link rel="mask-icon" href="/images/logo_1.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 面向对象 1.1 类对象提供的默认行为 在python的面向对象模型种，要分清类对象和实例对象。类对象就是class定义了一个类只会，该类提供些行为就是类对象.而实例对象就是该类的实例。每次调用类，就会生成一个实例。 类对象提供的默认行为：  class语句创建类对象并将其赋值给变量名。就像def一样，class语句也是可执行语句，执行时会产生类对象，并赋值变量名 class语句的">
<meta property="og:type" content="article">
<meta property="og:title" content="python面向对象">
<meta property="og:url" content="http://example.com/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="Trluper">
<meta property="og:description" content="1. 面向对象 1.1 类对象提供的默认行为 在python的面向对象模型种，要分清类对象和实例对象。类对象就是class定义了一个类只会，该类提供些行为就是类对象.而实例对象就是该类的实例。每次调用类，就会生成一个实例。 类对象提供的默认行为：  class语句创建类对象并将其赋值给变量名。就像def一样，class语句也是可执行语句，执行时会产生类对象，并赋值变量名 class语句的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/lengxing.png">
<meta property="article:published_time" content="2022-06-30T10:24:44.000Z">
<meta property="article:modified_time" content="2023-02-24T14:01:59.539Z">
<meta property="article:author" content="trluper">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/lengxing.png">

<link rel="canonical" href="http://example.com/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>python面向对象 | Trluper</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Trluper</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/trluper" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trluper">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Trluper">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python面向对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 18:24:44" itemprop="dateCreated datePublished" datetime="2022-06-30T18:24:44+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-24 22:01:59" itemprop="dateModified" datetime="2023-02-24T22:01:59+08:00">2023-02-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="面向对象">1. 面向对象</h4>
<h5 id="类对象提供的默认行为">1.1 类对象提供的默认行为</h5>
<p>在python的面向对象模型种，要分清<strong>类对象</strong>和<strong>实例对象</strong>。类对象就是<code>class</code>定义了一个类只会，该类提供些行为就是类对象.而实例对象就是该类的实例。每次调用类，就会生成一个实例。 类对象提供的默认行为：</p>
<ul>
<li><code>class</code>语句创建类对象并将其赋值给变量名。就像<code>def</code>一样，class语句也是可执行语句，执行时会产生类对象，并赋值变量名</li>
<li>class语句的赋值语句会创建类属性，像模块文件一样，class语句内的顶层的赋值语句（不在<code>def</code>内）会成为类对象的属性。</li>
<li>类属性提供对象的状态（变量）和行为（函数）</li>
<li>类仍然时模块内的属性。当<code>class</code>执行时，只是赋值语句而已，赋值了一个类对象</li>
</ul>
<span id="more"></span>
<h5 id="实例对象是具体对象">1.2 实例对象是具体对象</h5>
<p>每当调用类对象时，就会生成示例对象：</p>
<ul>
<li>调用类对象会创建新的实例对象</li>
<li>每个示例对象有类的属性并且有自己的命名空间</li>
<li><strong><em>在方法内对self属性做赋值会产生每个实例自己的属性</em></strong>：在类函数内，第一个参数总是接受方法调用的隐形主体，通常用<code>self</code>会引用正处理的实例对象（相当于C/C++的<code>this指针</code>)。对<code>self</code>的属性做赋值运算，会创建或修改实例内的数据，而不是类的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">firstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.data=value;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data);</span><br><span class="line">    data=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">s=firstClass();</span><br><span class="line">s.printdata();	<span class="comment">#0</span></span><br><span class="line">s.setdata(<span class="number">10</span>);</span><br><span class="line">s.printdata();	<span class="comment">#10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>self</code>会自动引用正在处理的示例对象，所以赋值语句会把值村储到实例的命名空间。因为<strong>类对象</strong>会产生多个实例，函数必须经过<code>self</code>参数才能识别获取正在处理的实例（就看出时c/c++中隐藏的<code>this指针</code>就行了)</p>
<h5 id="继承">1.3 继承</h5>
<p>面向对象的一大特性就是继承，以下时python中继承的核心观点：</p>
<ul>
<li>父类列在类开头的括号处</li>
<li>子类从父类中继承了函数和属性</li>
<li>实例会继承所有可读取类的属性：每个实例会从创建它的类中获取变量名，此外还有该类的父类</li>
<li>每个<code>object.attribute</code>都会开启新的独立搜索：python会对每个属性取出表达式进行对类树的独立搜索，包括self</li>
<li>一般来说逻辑的修改都是通过继承的子类修改，而不是直接修改父类</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">secondClass</span>(<span class="title class_ inherited__">firstClass</span>):</span><br><span class="line">	data=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;这是第二个类&quot;</span>，sefl.data);</span><br><span class="line"></span><br><span class="line">a=secondClass();</span><br><span class="line">a.setdata(<span class="number">20</span>)</span><br><span class="line">a.printdata();		<span class="comment">#这是第二个类 20</span></span><br></pre></td></tr></table></figure>
<p>子类对属性的搜索会从下往上，即从子类到父类，直到所找属性名首次出现为止。上面的<code>printdata</code>函数覆盖了父类的<code>printdata</code>函数，这中覆盖叫做<code>重载</code>。</p>
<h5 id="类的运算符重载初识">1.4 类的运算符重载初识</h5>
<p><strong>运算符重载</strong>就是让类写成的对象可以截获并响应内置类型上的运算，如加法、切片和打印等等，在这里我们只是片面性的列举了一些重载以做了解，更加具体的将在后面介绍。运算符重载的主要注意点：</p>
<ul>
<li>运算符重载的命名方式为<code>__x__</code></li>
<li>当实例出现内置运算时，这类方法会自动调用。比如实例有<code>__add__</code>方法，当对象出现<code>+</code>表达式时，该方法就会调用</li>
<li>类可覆盖多数内置类型运算</li>
<li>运算符重载让类变得更趋像python的对象模型</li>
</ul>
<p><strong><em>注意</em></strong>：我们必须关心一个方法，那就是<code>__init__</code>方法，也称为<strong>构造函数</strong>,它用于初始化对象的状态的，<strong><em><code>__init__</code>和<code>self</code>是我们理解python面向对象特性的关键</em></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdClass</span>(<span class="title class_ inherited__">secondClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.data=value;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> ThirdClass(self.data+other);</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[ThirdClass:%s]&#x27;</span>% self.data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printdata</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是ThirdClass&quot;</span>,self.data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=ThirdClass(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">a.printdata();</span><br><span class="line">a=a+<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">a.printdata();</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是ThirdClass abc</span><br><span class="line">这是ThirdClass abc123</span><br><span class="line">[ThirdClass:abc123]</span><br></pre></td></tr></table></figure> 从上面可以知道几点：</p>
<ol type="1">
<li><code>ThirdClass</code>调用传入一个参数，这是传给<code>__init__</code>构造函数的参数，即在在构建实例时自动调用<code>__init__</code>构造函数来初始化属性</li>
<li>有<code>__add__</code>函数后，即<code>+</code>运算符重载，<code>ThirdClass</code>的实例对象就可出现在<code>+</code>处，对与<code>+</code>，它把左侧的对象传给<code>self</code>，右侧的给<code>other</code>。执行完后，<strong>对于<code>__add__</code>来说要返回一个新的对象实例</strong></li>
<li>重载了<code>__str__</code>方法后，可以直接调用<code>print</code>打印对象</li>
</ol>
<h5 id="以实例介绍类的细节">1.5 以实例介绍类的细节</h5>
<h6 id="person和manager">1.5.1 person和manager</h6>
<p>在本节，将会两个类<code>person</code>和<code>manager</code>来介绍类实现的一些细节。顺带一提oython的%字符串格式为<code>&quot;%s,%d&quot; %(&quot;2222&quot;,10)</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,job=<span class="literal">None</span>,pay=<span class="number">0</span></span>):</span><br><span class="line">		self.name=name;</span><br><span class="line">		self.job=jon;</span><br><span class="line">		self.pay=pay;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span>  self.name.split()[-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self,percent</span>):</span><br><span class="line">		self.pay=<span class="built_in">int</span>(self.pay*(<span class="number">1</span>+percent))</span><br><span class="line">	<span class="comment">#print重载</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;[Person:%s,%s]&#x27;</span> % (self.name,self.pay)</span><br><span class="line"><span class="comment">#manager类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">	<span class="comment">#定制自己的构造函数，使用父类（超类）的构造函数构造</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,pay</span>):</span><br><span class="line">		self.person=Person.__init__(self,name,<span class="string">&#x27;mgr&#x27;</span>,pay);</span><br><span class="line">	<span class="comment">#重载函数，内部仍然使用超类的函数</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self,percent,bonus=<span class="number">1.0</span></span>):</span><br><span class="line">		person.giveRaise(self,percent+bonus);</span><br><span class="line">	<span class="comment">#改进点：</span></span><br><span class="line">	<span class="comment">#1. 使用内置的`Instance.__class__.__name__`,避免重复修改前部分的名称</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span><span class="string">&#x27;[%s:%s,%s]&#x27;</span> % (self.__class__.__name__,self.name,self.pay)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="对象持久化">1.5.2 对象持久化</h6>
<p>在上面我们创建的不是真正的数据库记录，如果关闭python，实例也将消失，因为它们是内存中的临时对象，这时可以使用python中<code>对象持久化</code>的功能，让对象在退出程序时依然存在。<strong>对象持久化</strong>通过3个标准库模块实现：</p>
<ul>
<li><code>pickle</code>:任意python对象和字节串之间的转化</li>
<li><code>dbm</code>：实现一个可通过键访问的文件系统，以存储字符串</li>
<li><code>shelve</code>:使用上面两个模块按照键把python对象存储到一个文件</li>
</ul>
<p>即<code>shelve</code>通过使用<code>pickle</code>将对象转为字符串，然后存储到一个<code>dbm</code>文件中键值对下，<code>shelve</code>通过键获取<code>pinkle</code>化的字符串，并用<code>pickle</code>在内存中重新创建最初对象。<code>shelve</code>就像字典一样，但是<code>shelve</code>一开始必须打开，并且在修改后关闭它 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">a=Person(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">b=Manager(<span class="string">&quot;小路&quot;</span>，<span class="number">1000</span>)</span><br><span class="line">db=shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">object</span> <span class="keyword">in</span>(a,b)</span><br><span class="line">	db[objecct.name]=<span class="built_in">object</span></span><br><span class="line">db.close();</span><br></pre></td></tr></table></figure> 此时，当前目录下会生成一个或多个名为<code>persondb</code>的文件</p>
<h5 id="抽象类">1.6 抽象类</h5>
<p>抽象类只是实现给继承者的一些接口，继承者类将接口实现什么功能完全由继承类决定，因此抽象接口类不能产生实例,只要类中有一个抽象方法，我们就不能创建该类的实例对象。在python3中，在<code>class</code>的头部使用一个关键字参数，以及特殊的<strong><span class="citation" data-cites="装饰器">@装饰器</span></strong>语法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCmeta,abstractmethod</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>(metaclass=ABCmeta):</span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">method_1</span>(<span class="params">self,*args</span>):</span><br><span class="line">		<span class="keyword">pass</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="命名空间">1.7 命名空间</h5>
<p>我们知道点号和无点号的变量名，会用不同方式进行访问，还有一些作用域是用于对对象命名空间做初始而设定的（如模块和类），总结如下：</p>
<ul>
<li>无点号运算的变量民与作用域相对应（如普通的全局和局部赋值）</li>
<li>点号的属性名<code>object.x</code>使用的是对象的命名空间</li>
<li>有些作用域会对对象的命名空间初始化（模块和类）</li>
</ul>
<h5 id="运算符重载详解">1.8 运算符重载详解</h5>
<p>运算符重载是意味着给自定义类增加操作，在类方法中拦截内置操作，当类的实例出现内置操作时，python自动调用你的方法。以下时常见的运算符重载方法：</p>
<table>
<thead>
<tr class="header">
<th>运算符重载函数名</th>
<th>重载功能</th>
<th>调用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__init__</code></td>
<td>构造函数</td>
<td>实例创建时自动调用</td>
</tr>
<tr class="even">
<td><code>__del__</code></td>
<td>析构函数</td>
<td>实例对象回收时自动调用</td>
</tr>
<tr class="odd">
<td><code>__add__</code></td>
<td>运算符<code>+</code></td>
<td>如果没有<code>__iadd__</code>，<code>X+Y,X+=Y</code>时会调用</td>
</tr>
<tr class="even">
<td><code>__sub__</code></td>
<td>运算符<code>-</code></td>
<td><code>X-Y,X-=Y</code>调用</td>
</tr>
<tr class="odd">
<td><code>__repr__,__str__</code></td>
<td>打印，转换</td>
<td><code>print(x),repr(x),str(x)</code></td>
</tr>
<tr class="even">
<td><code>__call__</code></td>
<td>函数调用</td>
<td><code>X(*args,**dargs)</code></td>
</tr>
<tr class="odd">
<td><code>__getattr__</code></td>
<td>点号运算</td>
<td><code>X.undefined</code></td>
</tr>
<tr class="even">
<td><code>__setattr__</code></td>
<td>属性赋值语句</td>
<td><code>X.attribute=value</code></td>
</tr>
<tr class="odd">
<td><code>__delattr__</code></td>
<td>属性删除</td>
<td><code>del X.attribute</code></td>
</tr>
<tr class="even">
<td><code>__getattribute__</code></td>
<td>属性获取</td>
<td><code>X.attribute</code></td>
</tr>
<tr class="odd">
<td><code>__getitem__</code></td>
<td>索引运算</td>
<td><code>x[key],x[i:j]</code></td>
</tr>
<tr class="even">
<td><code>__setitem__</code></td>
<td>索引赋值语句</td>
<td><code>x[key]=value,x[i:j]=sequance</code></td>
</tr>
<tr class="odd">
<td><code>__delitem__</code></td>
<td>索引和分片删除</td>
<td><code>del x[key],del x[i:j]</code></td>
</tr>
<tr class="even">
<td><code>__iter__</code>,<code>__next___</code></td>
<td>迭代环境</td>
<td><code>i=iter(x),next(i)</code></td>
</tr>
<tr class="odd">
<td><code>__len__</code></td>
<td>长度</td>
<td>如果没有<code>__bool__</code>，直接<code>len(x)</code></td>
</tr>
<tr class="even">
<td><code>__bool__</code></td>
<td>布尔测试</td>
<td><code>bool(x)</code></td>
</tr>
<tr class="odd">
<td><code>__lt__</code>,<code>__gt__</code></td>
<td>比较</td>
<td>从左到右以此为<code>&lt;,&gt;</code></td>
</tr>
<tr class="even">
<td><code>__le__</code>,<code>__ge__</code></td>
<td>比较</td>
<td><code>&lt;=,&gt;=</code></td>
</tr>
<tr class="odd">
<td><code>__eq__</code>,<code>__ne__</code></td>
<td>比较</td>
<td><code>==,!=</code></td>
</tr>
<tr class="even">
<td><code>__contains__</code></td>
<td>成员关系测试</td>
<td><code>item in X</code></td>
</tr>
</tbody>
</table>
<p>由上面可知，运算符的重载前后都有两个下划线标识，以区分其他变量名函数。</p>
<h6 id="索引和分片__getitem__">1.8.1 索引和分片<code>__getitem__</code></h6>
<p>如果类中定义或者继承了该运算符，则对于实例的索引运算，会自动调用<code>__getitem__</code>,会把实例传递给第一个参数，方括号内的值则传递给后面的一个参数，<code>__setitem__</code>则加了一个值value参数。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">operatorOverload</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		self.L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,index</span>):</span><br><span class="line">		<span class="keyword">return</span> self.L[index];</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,index,value</span>):</span><br><span class="line">		self.L[index]=value;</span><br><span class="line">x=operatorOverload();</span><br><span class="line"><span class="comment">#索引操作</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">2</span>]);	<span class="comment">#9</span></span><br><span class="line"><span class="built_in">print</span>(x.L);		<span class="comment">#[1,2,3,4]</span></span><br><span class="line"><span class="comment">#分片操作</span></span><br><span class="line"><span class="built_in">print</span>(x[::<span class="number">2</span>])	<span class="comment">#[1,3]</span></span><br><span class="line"><span class="comment">#赋值</span></span><br><span class="line">x[::<span class="number">2</span>]=[<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="built_in">print</span>(x[:])</span><br></pre></td></tr></table></figure></p>
<h6 id="索引迭代__iter__">1.8.2 索引迭代<code>__iter__</code></h6>
<p><code>__getitem__</code>有一个买一送一的情况，该重载不仅仅支持上面所讲的<strong>索引和分片功能</strong>,同时支持了<code>for</code>循环的迭代，<strong>当类中未定义<code>__iter__</code>时，即<code>for</code>循环每次循环时都会调用类的<code>__getitem__</code></strong>。其实不仅仅指<code>for</code>循环会调用，其他的迭代环境，如<code>in成员测试，列表解析,内置函数map，列表和元组赋值运算以及类型构造方法</code>也会自动调用该方法，只有类中没有<code>__iter__</code>. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> x:	<span class="comment">#调用了__getitem__</span></span><br><span class="line">	<span class="built_in">print</span>(item,end=<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h6 id="迭代器对象">1.8.3 迭代器对象</h6>
<p>尽管上面说的<code>__getitem__</code>支持迭代，但是它只是一直附加方法，真正的迭代还是要习惯用<code>__iter__</code>来获取迭代器，调用<code>__next__</code>访问，直到碰见异常<code>StopIteration</code>。python环境中所有迭代环境都是先尝试<code>__iter__</code>方法，然后再试<code>__getitem__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IterTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> self.start==self.end:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration;</span><br><span class="line">		self.start+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> self.start**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">m=IterTest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">q=<span class="built_in">iter</span>(m);</span><br><span class="line"><span class="built_in">print</span>(q);		<span class="comment">#&lt;__main__.IterTest object at 0x00000168A41CDFF0&gt;</span></span><br><span class="line"><span class="comment">#print(next(q))	#1</span></span><br><span class="line">L=<span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">	L.append(x);</span><br><span class="line"><span class="built_in">print</span>(L);		<span class="comment">#[1, 4, 9, 16, 25]，当print(next(q))未注释，输出为[4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<p>上面可以看到，迭代器对象就是实例<code>self</code>，这是因为<code>__next__</code>使类方法。且上面定义的迭代器使像<strong>生成器函数和表达式、<code>map</code>和<code>zip</code>内置函数</strong>一样的单迭代对象，要达到多个迭代器的效果，<code>__iter__</code>只需替迭代器定义新的状态对象，而不是返回<code>self</code>，带来的消耗是要创建多个迭代对象: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NextTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span> self.start==self.end:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration;</span><br><span class="line">		self.start+=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> self.start**<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IterTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,start,end</span>):</span><br><span class="line">		self.start=start;</span><br><span class="line">		self.end=end;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> NextTest(self.start,self.end);</span><br><span class="line"></span><br><span class="line">m=IterTest(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">q=<span class="built_in">iter</span>(m);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(q));		<span class="comment">#1</span></span><br><span class="line">L=<span class="built_in">list</span>();</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> m:</span><br><span class="line">	L.append(x);</span><br><span class="line"><span class="built_in">print</span>(L);			<span class="comment">#[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure></p>
<h6 id="成员关系">1.8.4 成员关系</h6>
<p>再迭代领域，类通常把<code>in</code>成员关系运算符实现为一个迭代，使用<code>__iter__</code>或着<code>__getitem__</code>。要支持更加特定的成员关系，类可能要编写一个<code>__contains__</code>方法，出现是，方法优先级是<code>contains&gt;iter&gt;getitem</code>。<code>__contains__</code>方法应该把成员关系定义为对一个<strong>映射</strong>应用键，用于序列的搜索 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ContainsTest</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.data=value;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self,x</span>):</span><br><span class="line">		<span class="keyword">return</span> x <span class="keyword">in</span> self.data;</span><br><span class="line"></span><br><span class="line">m=ContainsTest([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Contains:&quot;</span>,<span class="number">3</span> <span class="keyword">in</span> m,end=<span class="string">&#x27; &#x27;</span>);		<span class="comment">#Contains: True</span></span><br></pre></td></tr></table></figure></p>
<h6 id="属性引用">1.8.5 属性引用</h6>
<p><code>__getattr__</code>方法是拦截属性点号运算，当通过对未定义（不存在）属性名称和实例进行点号运算时，就会用属性名称作为字符串调用这个方法，如果可以通过继承找到属性就不会调用这个方法。因此，<code>__getattr__</code>可以作为钩子通过这种方式响应属性请求： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">empty</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">___getattr__</span>(<span class="params">self,attrname</span>):</span><br><span class="line">		<span class="keyword">if</span> attrname=<span class="string">&quot;age&quot;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> AttributeError,attrname</span><br><span class="line"></span><br><span class="line">x=empty();</span><br><span class="line">x.age		<span class="comment">#40</span></span><br><span class="line">x.name		<span class="comment">#AttributeError:name</span></span><br></pre></td></tr></table></figure> <code>__setattr__</code>会拦截所有属性的赋值语句,因此如果定义了这个方法要小心。除此之外，因为它对任何赋值语句都会拦截，即使是在<code>__setattr__</code>内也不例外，为防止无限递归，要使用该方法，必须通过<strong>属性字典</strong>做索引来赋值任何实例属性<code>self.__dict__[attr]=value;</code>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self,attrname,value</span>):</span><br><span class="line">		<span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">			self.__dict__[attr]=value;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">raise</span> AttriubteError, attrname+<span class="string">&#x27;nor allowed&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h6 id="call表达式">1.8.6 call表达式</h6>
<p>当调用实例时，使用<code>__call__</code>。如果定义该方法，python1就会为实例应用函数调用表达式运行<code>__call__</code>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,*args,**agrv</span>):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;called:&#x27;</span>,args,argv);</span><br><span class="line">c=Test();</span><br><span class="line">c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,x=<span class="number">4</span>,y=<span class="number">5</span>);	<span class="comment">#called:(1,2,3)&#123;&#x27;x&#x27;=4,&#x27;y&#x27;=5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="布尔测试">1.8.7 布尔测试</h6>
<p>python首先尝试<code>__bool__</code>来直接获取一个<code>bool</code>值，如果没有该方法，就尝试<code>__len__</code>，根据对象的长度确定一个真值。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.data=value;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">if</span>(self.data!=<span class="literal">None</span>):</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span>;</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span>;</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(self.data);</span><br><span class="line">x=Truth(<span class="string">&quot;12314&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;bool yes!&#x27;</span>);	<span class="comment">#bool yes!</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(x):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;len yes!&#x27;</span>);	<span class="comment">#len yes!</span></span><br></pre></td></tr></table></figure></p>
<h6 id="迭代环境__next__和__iter__">1.8.8 迭代环境<code>__next__</code>和<code>__iter__</code></h6>
<p>python对于创建得类允许自定义迭代环境，如果用户需要定义迭代环境，必须 - 实现<code>__iter__</code>和<code>__next__</code>函数， - 同时在<code>__next__</code>函数中指定迭代退出环境,一般为产生一个异常<code>raise</code> - 在迭代中<code>__next__</code>中实现迭代对象，返回该对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __iter__(self):</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">def __next__(self):</span><br><span class="line">    <span class="keyword">if</span> self.Next is None:</span><br><span class="line">        raise StopIteration</span><br><span class="line">    self.currentNode=self.Next</span><br><span class="line">    self.Next=self.Next.next</span><br><span class="line">    <span class="keyword">return</span> self.currentNode</span><br></pre></td></tr></table></figure>
<h6 id="section">1.8.9</h6>
<h5 id="类的设计">1.9 类的设计</h5>
<p>无论是哪门语言，对于OOP，其重要的三个面向对象特性：继承、多态、封装。在python，这三个特性作用也是一样：</p>
<ul>
<li>继承：提高代码的复用性</li>
<li>多态：提高程序的可扩展性和可维护性</li>
<li>封装：方法和运算符实现行为，数据隐藏是一种惯例，以此提高程序安全性</li>
</ul>
<h6 id="封装">1.9.1 封装</h6>
<p>封装提高程序的安全性。将数据（属性）和行为（方法）包装到类对象中，在方法内部对属性进行操作，在类对象的外部调用方法，这样无需关心方法内部的具体实现细节，从而隔离了复杂度；在python中没有专门的修饰符用于属性的私有，如果该属性不希望在类对象外部被访问，前边使用两个<code>_</code>修饰 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.__age=age  <span class="comment">#年龄不希望在类的外部被使用，所以加了两个__</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.__age)</span><br><span class="line">stu1=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">stu1.show()</span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br><span class="line"><span class="comment">#print(stu1.__age)   #这句话会报错，因为__age不希望在类外面使用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;如果想在类之外使用，可以用_类名__实例属性来用&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(stu1._Student__age)</span><br></pre></td></tr></table></figure></p>
<h6 id="继承-1">1.9.2 继承</h6>
<p>在python中，如果一个类没有继承任何类，则默认继承object。python支持多继承，<strong>定义子类时，必须在其构造函数中调用父类的构造函数</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,stu_num</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.stu_num=stu_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,teachofyear</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.teachofyear=teachofyear</span><br><span class="line"></span><br><span class="line">stu=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>,<span class="number">1001</span>)</span><br><span class="line">teach=Teacher(<span class="string">&#x27;李四&#x27;</span>,<span class="number">40</span>,<span class="number">20</span>)</span><br><span class="line">stu.info()</span><br><span class="line">teach.info()</span><br></pre></td></tr></table></figure> 如上，如果子类对继承父类中的某个属性或方法不满意，可以在子类中对其（方法体）进行重新编写.<strong>子类重写后的方法中可以通过<code>super().xxx()</code>调用父类中被重写的方法</strong>。</p>
<p>另外一点，在python中object类是所有类的父类，因此所有类都有object类的属性和方法。有内置函数dir()可以查看指定对象所有属性。object还有有一个<code>__str__()</code>方法，用于返回一个对于“对象的描述”，对应于内置函数<code>str()</code>经常用于<code>print()</code>方法，帮我们查看对象的信息，所以我们经常会对<code>__str__()</code>进行重写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我的名字是&#123;0&#125;,今年&#123;1&#125;岁&#x27;</span>.<span class="built_in">format</span>(self.name,self.age)</span><br><span class="line">stu=Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(stu))</span><br><span class="line"><span class="built_in">print</span>(stu)  <span class="comment">#默认会调用__str__()这样的方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(stu))</span><br></pre></td></tr></table></figure>
<h6 id="多态">1.9.3 多态</h6>
<p>多态就是“具有多种形态”,它指的是：即便不知道一个变量所引用的对象到底是 什么类型，仍然可以通过这个变量调用方法，在运行过程中根据变量所引用对象的类型， 动态决定调用哪个对象中的方法。实现多态必须有的三个条件：</p>
<ul>
<li>继承</li>
<li>方法重写</li>
<li>父类引用指向子类对象 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动物会吃&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;狗吃骨头&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猫吃鱼&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;人吃五谷杂粮&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.eat()</span><br><span class="line">fun(Cat())</span><br><span class="line">fun(Dog())</span><br><span class="line">fun(Animal())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;——————————&#x27;</span>)</span><br><span class="line">fun(Person())</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="类的浅拷贝和深拷贝">1.9.4 类的浅拷贝和深拷贝</h6>
<ul>
<li><strong>变量的赋值操作</strong>：只是形成两个变量，实际上还是指向同一个对象</li>
<li><strong>浅拷贝</strong>：python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，源对象与拷贝对象会引用同一个子对象</li>
<li><strong>深拷贝</strong>：使用copy模块的<code>deepcopy</code>函数，递归拷贝对象中包含的子对象，源对象和拷贝 对象所有的子对象也不相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Disk</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,cpu,disk</span>):</span><br><span class="line">        self.cpu=cpu</span><br><span class="line">        self.disk=disk</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.变量的赋值</span></span><br><span class="line">cpu1=CPU()</span><br><span class="line">cpu2=cpu1</span><br><span class="line"><span class="built_in">print</span>(cpu1)</span><br><span class="line"><span class="built_in">print</span>(cpu2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.类的浅深拷贝</span></span><br><span class="line">disk=Disk() <span class="comment">#创建一个硬盘类的对象</span></span><br><span class="line"><span class="built_in">print</span>(disk)</span><br><span class="line">computer=Computer(cpu1,disk)    <span class="comment">#创建一个计算机类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#浅拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">computer2=copy.copy(computer)</span><br><span class="line"><span class="built_in">print</span>(computer,computer.cpu,computer.disk)</span><br><span class="line"><span class="built_in">print</span>(computer2,computer2.cpu,computer2.disk)</span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝</span></span><br><span class="line">computer3=copy.deepcopy(computer)</span><br><span class="line"><span class="built_in">print</span>(computer,computer.cpu,computer.disk)</span><br><span class="line"><span class="built_in">print</span>(computer3,computer3.cpu,computer3.disk)</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//赋值就是简单的变量引用同一个对象</span><br><span class="line">&lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt;</span><br><span class="line">&lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#浅拷贝，对象包含的的子对象内容不拷贝，都引用同一个内容</span></span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615ED70</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615F820</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝，子对象也拷贝了</span></span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615ED70</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615ED10</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615ED40</span>&gt;</span><br><span class="line">&lt;__main__.Computer <span class="built_in">object</span> at <span class="number">0x000001C0D615DD50</span>&gt; &lt;__main__.CPU <span class="built_in">object</span> at <span class="number">0x000001C0D615D450</span>&gt; &lt;__main__.Disk <span class="built_in">object</span> at <span class="number">0x000001C0D615D3F0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="设计模式之委托模式">1.9.5 设计模式之委托模式</h6>
<p>所谓的<strong>委托</strong>，<strong>通常就是指控制对象内嵌其他对象，而把运算请求传给这些内嵌对象处理，控制器对象只负责管理工作</strong>。在python中，委托通常用<code>__getattr__</code>钩子方法实现，因为这个方法会拦截对不存在属性的读取，因此代理类可以使用<code>__getattr__</code>把任意读取操作转给被包装对象。 简而言之：通过一个类来调用另一个类里的方法来处理请求，即这两个类对象参与处理同一个请求对象，只不过一个是<strong>委托者</strong>，一个是<strong>处理者</strong>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,<span class="built_in">object</span></span>):</span><br><span class="line">		self.wrapped=<span class="built_in">object</span>;	<span class="comment">#内嵌对象</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self,attrname</span>):</span><br><span class="line">		<span class="keyword">if</span> attrname==<span class="string">&#x27;append&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped,attrname);</span><br><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">x=wrapper(L);</span><br><span class="line">x.append(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">print</span>(L)			<span class="comment">#[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure> 上述代码中，因为<code>x.append(4)</code>未在<code>wrapper</code>内定义，触发<code>__getattr__</code>函数,<code>getattr(x,y)</code>函数的作用就是点操作，即<code>x.y</code>。</p>
<h6 id="绑定和无绑定方法">1.9.6 绑定和无绑定方法</h6>
<ul>
<li>实例的绑定方法：即有<code>self</code>，且在类中没有被任何装饰器修饰的方法就是绑定到对象的方法，这类方法专门为对象定制。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    country = <span class="string">&quot;China&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">str</span>(self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;Kitty&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p.__dict__)</span><br><span class="line">p.speak()   <span class="comment">#通过对象调用 Kitty, 18</span></span><br><span class="line">Person.speak(p)   <span class="comment">#通过类调用Kitty, 18</span></span><br></pre></td></tr></table></figure>
<p>通过对象调用绑定到对象的方法，会有一个自动传值的过程，即自动将当前对象传递给方法的第一个参数（<code>self</code>，一般都叫<code>self</code>，也可以写成别的名称）；若是使用类调用，则第一个参数需要手动传值。</p>
<ul>
<li>类的绑定方法:类中使用<code>@classmethod</code>修饰的方法就是绑定到类的方法。这类方法专门为类定制。通过类名调用绑定到类的方法时，会将类本身当做参数传给类方法的第一个参数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operate_database</span>():</span><br><span class="line">    host = <span class="string">&#x27;192.168.0.5&#x27;</span></span><br><span class="line">    port = <span class="string">&#x27;3306&#x27;</span></span><br><span class="line">    user = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">cls</span>):  <span class="comment"># 约定俗成第一个参数名为cls，也可以定义为其他参数名</span></span><br><span class="line">        <span class="built_in">print</span>(cls)</span><br><span class="line">        <span class="built_in">print</span>(cls.host + <span class="string">&#x27;:&#x27;</span> + cls.port + <span class="string">&#x27; &#x27;</span> + cls.user + <span class="string">&#x27;/&#x27;</span> + cls.password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Operate_database.connect();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Operate_database&#x27;</span>&gt;</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span>:<span class="number">3306</span> abc/<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>非绑定方法:在类内部使用 <span class="citation" data-cites="staticmethod">@staticmethod</span> 修饰的方法即为非绑定方法，这类方法和普通定义的函数没有区别，不与类或对象绑定，谁都可以调用(实例和类都可以)，且没有自动传值的效果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operate_database</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port, user, password</span>):</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_passwrod</span>(<span class="params">salt, password</span>):</span><br><span class="line">        m = hashlib.md5(salt.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 加盐处理</span></span><br><span class="line">        m.update(password.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">hash_password = Operate_database.get_passwrod(<span class="string">&#x27;lala&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)  <span class="comment"># 通过类来调用</span></span><br><span class="line"><span class="built_in">print</span>(hash_password)</span><br><span class="line"></span><br><span class="line">p = Operate_database(<span class="string">&#x27;192.168.0.5&#x27;</span>, <span class="string">&#x27;3306&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line">hash_password = p.get_passwrod(p.user, p.password)  <span class="comment"># 也可以通过对象调用</span></span><br><span class="line"><span class="built_in">print</span>(hash_password)</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f7a1cc409ed6f51058c2b4a94a7e1956</span><br><span class="line">0659c7992e268962384eb17fafe88364</span><br></pre></td></tr></table></figure></p>
<h5 id="棱形继承">1.10 棱形继承</h5>
<p>在多层继承和多继承同时使用的情况下，就会出现复杂的继承关系，即重重复继乘，常说的<strong>菱形继承</strong> <img src="/2022/06/30/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/lengxing.png" width="300"> 在这种结构中，在调用顺序上就出现了疑惑，调用顺序究竟是以下哪一种顺序呢,如果是深度，那么A会重复调用，造成不必要的消耗</p>
<ul>
<li><code>D-&gt;B-&gt;A-&gt;C-&gt;A（深度优先）</code></li>
<li><code>D-&gt;B-&gt;C-&gt;A（广度优先）</code></li>
</ul>
<p>上面问题的根源都跟MRO有关,MRO(Method Resolution Order)也叫方法解析顺序，主要用于在多重继承时判断调的属性来自于哪个类，其使用了一种叫做C3的算法，其基本思想时在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则去寻找需要的属性和方法。 <strong>要避免顶层父类某个方法被多次调用，此时就需要super()来发挥作用了,super本质上是一个类，内部记录着MRO信息，由于C3算法确保同一个类只会被搜寻一次，这样就避免了顶层父类中的方法被多次执行了</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意，这段代码是个特例，在D的注释处明显调用了B/C的构造函数，所有会执行两次A的构造函数，要使其不执行两次，则需要使用super().xxx()。这种方法很常用，应该熟记</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init A...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end A...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init B...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(B, self).__init__()</span><br><span class="line">		<span class="comment"># A.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end B...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init C...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(C, self).__init__()</span><br><span class="line">		<span class="comment"># A.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end C...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init D...&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(D, self).__init__()</span><br><span class="line">		<span class="comment">#B.__init__(self)</span></span><br><span class="line">        <span class="comment">#C.__init__(self)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;end D...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    D()</span><br></pre></td></tr></table></figure> 输出：采用广度优先搜索 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init D...</span><br><span class="line">init B...</span><br><span class="line">init C...</span><br><span class="line">init A...</span><br><span class="line">end A...</span><br><span class="line">end C...</span><br><span class="line">end B...</span><br><span class="line">end D...</span><br><span class="line"></span><br></pre></td></tr></table></figure> 值得一提的是Python类分为两种，一种叫经典类，一种叫新式类。都支持多继承，但继承方式不同：</p>
<ul>
<li><strong>新式类</strong>：从object继承来的类。（如:class A(object)），采用广度优先搜索的方式继承（即先水平搜索，再向上搜索）。</li>
<li><strong>经典类</strong>：不从object继承来的类。（如：class A()），采用深度优先搜索的方式继承（即先深入继承树的左侧，再返回，再找右侧）。</li>
</ul>
<p><strong><em>注意：Python2.x中类的是有经典类和新式类两种。Python3.x中都是新式类（类都默认继承object）。因此对于多重继承，顺序很重要，他会根据继承类在首行位置，从左到右搜索</em></strong> 实例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    attr=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    attr=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B,C):</span><br><span class="line">    <span class="keyword">pass</span>;</span><br><span class="line"></span><br><span class="line">M=D();</span><br><span class="line"><span class="built_in">print</span>(M.attr)		<span class="comment">#2</span></span><br></pre></td></tr></table></figure> 上面的代码输出为2，先解释一下：因为B、C都继承自A，D继承自B，那么在python3.x版本以上，采用了广度优先，顺序是<code>D-&gt;B-&gt;C-&gt;A</code>,在C时遇到了属性<code>attr=2</code>，停止搜索返回，输出为2</p>
<h6 id="super详解">1.10.1 super详解</h6>
<p>上面已经提到了，在python3.x版本上，都使用新式类，python避免重复调用是采用<strong>MRO(Method Resolution Order)机制也叫方法解析顺序，主要用于在多重继承时判断调的属性来自于哪个类，其使用了一种叫做C3的算法，其基本思想时在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则去寻找需要的属性和方法。</strong></p>
<p><code>super</code>本质上是一个类，但super() 和父类没有实质性的关联：</p>
<ul>
<li><code>super()</code>函数需要两个参数，第一个是类名，第二个是一般都为<code>self</code>但也会有<code>cls</code>情况，但在python3.x中使用<code>super().xxxx()</code>等同于<code>super(classname,self).xxxx()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;B&quot;</span>)</span></span><br><span class="line"><span class="function">        super().__init__()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class C(A):</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;C&quot;</span>)</span></span><br><span class="line"><span class="function">        super(C, self).__init__()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class D(B,C):</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;D&quot;</span>,D.__mro__)</span></span><br><span class="line"><span class="function">        super(D, self).__init__()</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">#输出</span></span><br><span class="line"><span class="function">D (&lt;class <span class="string">&#x27;ListNode.D&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.B&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.C&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.A&#x27;</span>&gt;, &lt;class <span class="string">&#x27;object&#x27;</span>&gt;)</span></span><br><span class="line"><span class="function">B</span></span><br><span class="line"><span class="function">C</span></span><br><span class="line"><span class="function">A</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p><code>super</code>工作原理：如果在类D中调用<code>super()</code>会传入D类，那就会在它<code>__mro__</code>上一级开始查找，它的上一级是B，就会调用B的函数，依次类推下去。如下更改D类的<code>super()</code>输出改变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;D&quot;</span>,D.__mro__)</span></span><br><span class="line"><span class="function">        super(C, self).__init__()</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">#输出：</span></span><br><span class="line"><span class="function">D (&lt;class <span class="string">&#x27;ListNode.D&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.B&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.C&#x27;</span>&gt;, &lt;class <span class="string">&#x27;ListNode.A&#x27;</span>&gt;, &lt;class <span class="string">&#x27;object&#x27;</span>&gt;)</span></span><br><span class="line"><span class="function">A</span></span><br></pre></td></tr></table></figure>
<p>因为上一级是<code>__mro__</code>中C的上一级是A，就好执行A的<code>__init__()</code>函数</p>
<h5 id="slots可选">1.11 slots（可选）</h5>
<p>python类有一个双刃剑就是：即使我们没有在类内部创建属性，也可以在实例对象中通过<code>.</code>给实例对象创建一个属于实例的属性，这样听起来非常bug，不像java和c++这样有很好的封装性: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a=A();</span><br><span class="line">a.p=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">print</span>(a.p) <span class="comment">#20</span></span><br></pre></td></tr></table></figure> 之前提到过<code>__getattr__</code>能够对未在类内创建的属性提供操作。这里介绍python提供的<code>slots</code>来支持这一功能。 这个特殊属性一般是在类的顶层内将变量名称（字符串形式）按顺序赋值给变量<code>__slots__</code>，<strong>该属性规定：只有<code>__slots__</code>列表内的这些变量名可赋值为实例属性</strong>。它也要遵循python的规则，实例属性名必须在引用前赋值 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>:</span><br><span class="line">	__slots__=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=limiter();</span><br><span class="line"><span class="comment">#print(x.age)		#AttributeError,未赋值就引用</span></span><br><span class="line">x.age=<span class="number">40</span></span><br><span class="line"><span class="built_in">print</span>(x.age)		<span class="comment">#40</span></span><br><span class="line">x.jk=<span class="number">2</span>;				<span class="comment">#不允许，变量名不在__slots__</span></span><br></pre></td></tr></table></figure> 但是注意，类中有<code>__slots__</code>会没有<code>__dict__</code>属性，事实上，<code>__slots__</code>就是以<code>__dict__</code>的代价来起到这样一个功能的： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>:</span><br><span class="line">	__slots__=[<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;job&#x27;</span>,<span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x=limiter();</span><br><span class="line">x.jk=<span class="number">2</span>;				<span class="comment">#运行成功</span></span><br></pre></td></tr></table></figure> 没有<code>__dict__</code>，我们就不能在类的函数内随便起变量名，因此对于<code>__slots__</code>看情况使用</p>
<h5 id="装饰器">1.12. 装饰器</h5>
<p>装饰器一般有函数装饰器和类装饰器。装饰器即指通过对函数的包装来修改其他函数的功能的函数。我们知道在python中可以嵌套定义函数，<strong>但是我们外部无法直接访问嵌套内部函数，好在可以将一个函数名赋值给一个变量，其实函数名就是一个变量，只不过指向函数对象，也可通过返回函数变量名</strong>，然后通过变量名去调用<code>变量名()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">hi</span><span class="params">(name=<span class="string">&quot;yasoob&quot;</span>)</span>:</span></span><br><span class="line"><span class="function">    def greet():</span></span><br><span class="line"><span class="function">        return <span class="string">&quot;now you are in the greet() function&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    def welcome():</span></span><br><span class="line"><span class="function">        return <span class="string">&quot;now you are in the welcome() function&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    if name =</span>= <span class="string">&quot;yasoob&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> greet</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"> </span><br><span class="line">a = <span class="built_in">hi</span>()		#返回great</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">a</span>())				#调用<span class="built_in">a</span>()==<span class="built_in">great</span>()</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">&lt;function greet at <span class="number">0x7f2143c01500</span>&gt;</span><br><span class="line">now you are in the <span class="built_in">greet</span>() function</span><br></pre></td></tr></table></figure></p>
<p>既然我们能够将函数作为变量，那么变量当然可以作为参数，当我们将函数变量作为参数传递给另外一个函数时，就会产生装饰器的知识，实际上装饰器就是做这种事： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    def wrapTheFunction():</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">        a_func()</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    return wrapTheFunction</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">def a_function_requiring_decoration():</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration()</span></span><br><span class="line"><span class="function">#outputs: <span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration =</span> <span class="built_in">a_new_decorator</span>(a_function_requiring_decoration)</span><br><span class="line"><span class="meta">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">a_function_requiring_decoration</span>()</span><br><span class="line"><span class="meta">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line">#        I am the function which needs some decoration to remove my foul smell</span><br><span class="line">#        <span class="function">I am doing some boring work after executing <span class="title">a_func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h6 id="函数装饰器">1.12.1 函数装饰器</h6>
<p>上面讲解了函数装饰器的原理，提供了一种方式声明函数的特定运算模式，其原理是将函数包裹到另一个函数，在另一个函数的逻辑内实现。<strong>现在为简化其实现，使用<code>@</code>代替这些代码，所以函数装饰器在def语句前一行，由<code>@符号、后面跟着所谓的元函数</code></strong>组成。元函数就是管理另一函数（或其他可调用对象）的函数,如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">a_new_decorator</span></span><br><span class="line"><span class="function">def <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span></span><br><span class="line"><span class="function">          <span class="string">&quot;remove my foul smell&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">a_function_requiring_decoration()</span></span><br><span class="line"><span class="function">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="function">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="function">#         I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure> 上面的<code>@a_new_decorator</code>等价于<code>a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration</code></p>
<p><strong>python内置的装饰器：</strong></p>
<ul>
<li><code>@classmethod</code>：修饰类内的方法是绑定到类的方法，该方法专门为类提供，会将类本身当作参数传给类方法的第一个参数，不需要使用对象调用当然你可以使用对象调用。</li>
<li><code>@staticmethod</code>：在类内部使用该装饰器修饰方法，这类方法不与类或对象绑定，属于静态方法，谁都可以调用，且没有自动传值功能。</li>
<li><code>@wraps(函数变量名)</code>；在上面举例的函数装饰器<code>@a_new_decorator</code>中会改变函数的<code>__name__</code>为<code>wrapTheFunction</code>，正常应该为<code>a_function_requiring_decoration</code>。这时候就需要使用<code>@wraps()</code>装饰器 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: wrapTheFunction</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="comment">#使用@wraps()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_new_decorator</span>(<span class="params">a_func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">a_func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapTheFunction</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_function_requiring_decoration</span>():</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"><span class="comment">#输出正常</span></span><br><span class="line"><span class="built_in">print</span>(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: a_function_requiring_decoration</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="类装饰器">1.12.2 类装饰器</h6>
<p>类装饰器类似于函数装饰器（后续补充）</p>
<h4 id="链表实现">2. 链表实现</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value,<span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.value=value</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;节点已删除&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,Size=<span class="number">0</span>,pHead=<span class="literal">None</span></span>):</span><br><span class="line">        self.pHead=pHead</span><br><span class="line">        self.Next=pHead</span><br><span class="line">        self.Size=Size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已注销&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.Next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.currentNode=self.Next</span><br><span class="line">        self.Next=self.Next.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> self.currentNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Crease</span>(<span class="params">self</span>):</span><br><span class="line">        self.Size+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DeCrease</span>(<span class="params">self</span>):</span><br><span class="line">        self.Size-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node=ListNode(value)</span><br><span class="line">        <span class="comment">#判断是否为空链表</span></span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.pHead=node</span><br><span class="line">            <span class="keyword">return</span> self.pHead;</span><br><span class="line">        <span class="comment">#找到最后一个节点</span></span><br><span class="line">        current_Node=self.pHead;</span><br><span class="line">        preNode=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current_Node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode=current_Node</span><br><span class="line">            current_Node=current_Node.<span class="built_in">next</span></span><br><span class="line">        preNode.<span class="built_in">next</span>=node</span><br><span class="line">        self.Crease()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">erase</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            preNode=<span class="literal">None</span></span><br><span class="line">            current_node=self.pHead;</span><br><span class="line">            <span class="keyword">while</span> current_node!=<span class="literal">None</span> <span class="keyword">and</span> current_node.value != value:</span><br><span class="line">                preNode=current_node</span><br><span class="line">                current_node=current_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> preNode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">             self.pHead=self.pHead.<span class="built_in">next</span></span><br><span class="line">             self.DeCrease()</span><br><span class="line">             <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">elif</span> current_node.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode.<span class="built_in">next</span>=current_node.<span class="built_in">next</span></span><br><span class="line">            self.DeCrease()</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        <span class="keyword">return</span> self.pHead</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self,value</span>):</span><br><span class="line">        Next=self.pHead</span><br><span class="line">        <span class="keyword">while</span> Next.value <span class="keyword">is</span> <span class="keyword">not</span> value:</span><br><span class="line">            Next=Next.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> Next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        current_node=self.pHead</span><br><span class="line">        preNode=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current_node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            preNode=current_node</span><br><span class="line">            current_node=current_node.<span class="built_in">next</span></span><br><span class="line">        preNode.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">        self.DeCrease()</span><br><span class="line">        <span class="keyword">return</span> current_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        retNode=self.pHead</span><br><span class="line">        self.pHead=self.pHead.<span class="built_in">next</span></span><br><span class="line">        self.DeCrease()</span><br><span class="line">        <span class="keyword">return</span> retNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_front</span>(<span class="params">self,value</span>):</span><br><span class="line">        node = ListNode(value)</span><br><span class="line">        self.Next=self.pHead</span><br><span class="line">        <span class="keyword">if</span> self.pHead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.pHead=node</span><br><span class="line">            <span class="keyword">return</span> self.pHead</span><br><span class="line">        node.<span class="built_in">next</span>=self.pHead</span><br><span class="line">        self.pHead=node</span><br><span class="line">        self.Crease()</span><br><span class="line">        self.Next=self.pHead</span><br><span class="line">        <span class="keyword">return</span> self.pHead</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="trluper 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="trluper 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/24/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="prev" title="python基础知识">
      <i class="fa fa-chevron-left"></i> python基础知识
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/07/c-primer%E5%89%8D%E9%83%A8%E5%88%86/" rel="next" title="c++基础">
      c++基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">1. 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%8F%90%E4%BE%9B%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 类对象提供的默认行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%85%B7%E4%BD%93%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 实例对象是具体对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%88%9D%E8%AF%86"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 类的运算符重载初识</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D%E7%B1%BB%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 以实例介绍类的细节</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#person%E5%92%8Cmanager"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1 person和manager</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2 对象持久化</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 抽象类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 命名空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.8.</span> <span class="nav-text">1.8 运算符重载详解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%86%E7%89%87__getitem__"><span class="nav-number">1.8.1.</span> <span class="nav-text">1.8.1 索引和分片__getitem__</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%BF%AD%E4%BB%A3__iter__"><span class="nav-number">1.8.2.</span> <span class="nav-text">1.8.2 索引迭代__iter__</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.8.3.</span> <span class="nav-text">1.8.3 迭代器对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%85%B3%E7%B3%BB"><span class="nav-number">1.8.4.</span> <span class="nav-text">1.8.4 成员关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%BC%95%E7%94%A8"><span class="nav-number">1.8.5.</span> <span class="nav-text">1.8.5 属性引用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#call%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.8.6.</span> <span class="nav-text">1.8.6 call表达式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E6%B5%8B%E8%AF%95"><span class="nav-number">1.8.7.</span> <span class="nav-text">1.8.7 布尔测试</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E7%8E%AF%E5%A2%83__next__%E5%92%8C__iter__"><span class="nav-number">1.8.8.</span> <span class="nav-text">1.8.8 迭代环境__next__和__iter__</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#section"><span class="nav-number">1.8.9.</span> <span class="nav-text">1.8.9</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.9.</span> <span class="nav-text">1.9 类的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">1.9.1.</span> <span class="nav-text">1.9.1 封装</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="nav-number">1.9.2.</span> <span class="nav-text">1.9.2 继承</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">1.9.3.</span> <span class="nav-text">1.9.3 多态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.9.4.</span> <span class="nav-text">1.9.4 类的浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.9.5.</span> <span class="nav-text">1.9.5 设计模式之委托模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%92%8C%E6%97%A0%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.6.</span> <span class="nav-text">1.9.6 绑定和无绑定方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">1.10.</span> <span class="nav-text">1.10 棱形继承</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#super%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.10.1.</span> <span class="nav-text">1.10.1 super详解</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#slots%E5%8F%AF%E9%80%89"><span class="nav-number">1.11.</span> <span class="nav-text">1.11 slots（可选）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">1.12.</span> <span class="nav-text">1.12. 装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">1.12.1.</span> <span class="nav-text">1.12.1 函数装饰器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">1.12.2.</span> <span class="nav-text">1.12.2 类装饰器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">2. 链表实现</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="trluper"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">trluper</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/trluper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;trluper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Trluper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">804k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:11</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
      <script type="text/javascript">
      function renderGitalk(){
        var gitalk = new Gitalk({
            owner: '',
            repo: '',
            clientID: '123fe329fdbb06b0f1d1',
            clientSecret: '40add829107b6e69f43274d3545ae71c988de8eb',
            admin: '',
            
            });
        gitalk.render('gitalk-container');
      }
      renderGitalk();
      </script>
    
 


</body>
</html>
